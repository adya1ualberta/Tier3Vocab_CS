ARRAYS
AN
ARRAY
STORES
A
SEQUENCE
OF
VALUES
THAT
ARE
ALL
OF
THE
SAME
TYPE
WE
WANT
NOT
ONLY
TO
STORE
VALUES
BUT
ALSO
TO
ACCESS
EACH
INDIVIDUAL
VALUE
THE
METHOD
THAT
WE
USE
TO
REFER
TO
INDIVIDUAL
VALUES
IN
AN
ARRAY
IS
NUMBERING
AND
THEN
INDEXING
THEM
IF
WE
HAVE
N
VALUES
WE
THINK
OF
THEM
AS
BEING
NUMBERED
FROM
TO
N
THEN
WE
CAN
UNAMBIGUOUSLY
SPECIFY
ONE
OF
THEM
IN
JAVA
CODE
BY
USING
THE
NOTATION
A
I
TO
REFER
TO
THE
ITH
VALUE
FOR
ANY
VALUE
OF
I
FROM
TO
N
THIS
JAVA
CONSTRUCT
IS
KNOWN
AS
A
ONE
DIMENSIONAL
ARRAY
CREATING
AND
INITIALIZING
AN
ARRAY
MAKING
AN
ARRAY
IN
A
JAVA
PROGRAM
INVOLVES
THREE
DISTINCT
STEPS
DECLARE
THE
ARRAY
NAME
AND
TYPE
CREATE
THE
ARRAY
INITIALIZE
THE
ARRAY
VALUES
TO
DECLARE
THE
ARRAY
YOU
NEED
TO
SPECIFY
A
NAME
AND
THE
TYPE
OF
DATA
IT
WILL
CONTAIN
TO
CREATE
IT
YOU
NEED
TO
SPECIFY
ITS
LENGTH
THE
NUMBER
OF
VALUES
FOR
EXAMPLE
THE
LONG
FORM
CODE
SHOWN
AT
RIGHT
MAKES
AN
ARRAY
OF
N
NUMBERS
OF
TYPE
DOUBLE
ALL
INITIALIZED
TO
THE
FIRST
STATEMENT
IS
LONG
FORM
DOUBLE
A
DECLARATION
CREATION
THE
ARRAY
DECLARATION
IT
IS
JUST
LIKE
A
DEC
LARATION
OF
A
VARIABLE
OF
THE
CORRESPOND
ING
PRIMITIVE
TYPE
EXCEPT
FOR
THE
SQUARE
BRACKETS
FOLLOWING
THE
TYPE
NAME
WHICH
SPECIFY
THAT
WE
ARE
DECLARING
AN
ARRAY
THE
KEYWORD
NEW
IN
THE
SECOND
STATE
MENT
IS
A
JAVA
DIRECTIVE
TO
CREATE
THE
AR
RAY
THE
REASON
THAT
WE
NEED
TO
EXPLICITLY
CREATE
ARRAYS
AT
RUN
TIME
IS
THAT
THE
JAVA
COMPILER
CANNOT
KNOW
HOW
MUCH
SPACE
A
NEW
DOUBLE
N
FOR
INT
I
I
N
I
A
I
INITIALIZATION
SHORT
FORM
DOUBLE
A
NEW
DOUBLE
N
INITIALIZING
DECLARATION
INT
A
DECLARING
CREATING
AND
INITIALIZING
AN
ARRAY
TO
RESERVE
FOR
THE
ARRAY
AT
COMPILE
TIME
AS
IT
CAN
FOR
PRIMITIVE
TYPE
VALUES
THE
FOR
STATEMENT
INITIALIZES
THE
N
ARRAY
VALUES
THIS
CODE
SETS
ALL
OF
THE
ARRAY
ENTRIES
TO
THE
VALUE
WHEN
YOU
BEGIN
TO
WRITE
CODE
THAT
USES
AN
ARRAY
YOU
MUST
BE
SURE
THAT
YOUR
CODE
DECLARES
CREATES
AND
INITIALIZES
IT
OMITTING
ONE
OF
THESE
STEPS
IS
A
COMMON
PROGRAM
MING
MISTAKE
SHORT
FORM
FOR
ECONOMY
IN
CODE
WE
OFTEN
TAKE
ADVANTAGE
OF
JAVA
DEFAULT
ARRAY
INI
TIALIZATION
CONVENTION
AND
COMBINE
ALL
THREE
STEPS
INTO
A
SINGLE
STATEMENT
AS
IN
THE
SHORT
FORM
CODE
IN
OUR
EXAMPLE
THE
CODE
TO
THE
LEFT
OF
THE
EQUAL
SIGN
CONSTITUTES
THE
DECLARATION
THE
CODE
TO
THE
RIGHT
CONSTITUTES
THE
CREATION
THE
FOR
LOOP
IS
UNNECESSARY
IN
THIS
CASE
BECAUSE
THE
DEFAULT
INITIAL
VALUE
OF
VARIABLES
OF
TYPE
DOUBLE
IN
A
JAVA
ARRAY
IS
BUT
IT
WOULD
BE
REQUIRED
IF
A
NONZERO
VALUE
WERE
DESIRED
THE
DEFAULT
INITIAL
VALUE
IS
ZERO
FOR
NUMERIC
TYPES
AND
FALSE
FOR
TYPE
BOOLEAN
THE
THIRD
OPTION
SHOWN
FOR
OUR
EXAMPLE
IS
TO
SPECIFY
THE
INITIALIZATION
VALUES
AT
COMPILE
TIME
BY
LISTING
LITERAL
VALUES
BETWEEN
CURLY
BRACES
SEPARATED
BY
COMMAS
USING
AN
ARRAY
TYPICAL
ARRAY
PROCESSING
CODE
IS
SHOWN
ON
PAGE
AFTER
DECLARING
AND
CREATING
AN
ARRAY
YOU
CAN
REFER
TO
ANY
INDIVIDUAL
VALUE
ANYWHERE
YOU
WOULD
USE
A
VARIABLE
NAME
IN
A
PROGRAM
BY
ENCLOSING
AN
INTEGER
INDEX
IN
SQUARE
BRACKETS
AFTER
THE
ARRAY
NAME
ONCE
WE
CREATE
AN
ARRAY
ITS
SIZE
IS
FIXED
A
PROGRAM
CAN
REFER
TO
THE
LENGTH
OF
AN
ARRAY
A
WITH
THE
CODE
A
LENGTH
THE
LAST
ELEMENT
OF
AN
ARRAY
A
IS
ALWAYS
A
A
LENGTH
JAVA
DOES
AUTOMATIC
BOUNDS
CHECKING
IF
YOU
HAVE
CREATED
AN
ARRAY
OF
SIZE
N
AND
USE
AN
INDEX
WHOSE
VALUE
IS
LESS
THAN
OR
GREATER
THAN
N
YOUR
PRO
GRAM
WILL
TERMINATE
WITH
AN
ARRAYOUTOFBOUNDSEXCEPTION
RUNTIME
EXCEPTION
ALIASING
NOTE
CAREFULLY
THAT
AN
ARRAY
NAME
REFERS
TO
THE
WHOLE
ARRAY
IF
WE
ASSIGN
ONE
ARRAY
NAME
TO
ANOTHER
THEN
BOTH
REFER
TO
THE
SAME
ARRAY
AS
ILLUSTRATED
IN
THE
FOLLOWING
CODE
FRAGMENT
INT
A
NEW
INT
N
A
I
INT
B
A
B
I
A
I
IS
NOW
THIS
SITUATION
IS
KNOWN
AS
ALIASING
AND
CAN
LEAD
TO
SUBTLE
BUGS
IF
YOUR
INTENT
IS
TO
MAKE
A
COPY
OF
AN
ARRAY
THEN
YOU
NEED
TO
DECLARE
CREATE
AND
INITIALIZE
A
NEW
ARRAY
AND
THEN
COPY
ALL
OF
THE
ENTRIES
IN
THE
ORIGINAL
ARRAY
TO
THE
NEW
ARRAY
AS
IN
THE
THIRD
EXAMPLE
ON
PAGE
TWO
DIMENSIONAL
ARRAYS
A
TWO
DIMENSIONAL
ARRAY
IN
JAVA
IS
AN
ARRAY
OF
ONE
DIMEN
SIONAL
ARRAYS
A
TWO
DIMENSIONAL
ARRAY
MAY
BE
RAGGED
ITS
ARRAYS
MAY
ALL
BE
OF
DIFFERING
LENGTHS
BUT
WE
MOST
OFTEN
WORK
WITH
FOR
APPROPRIATE
PARAMETERS
M
AND
N
M
BY
N
TWO
DIMENSIONAL
ARRAYS
THAT
ARE
ARRAYS
OF
M
ROWS
EACH
AN
ARRAY
OF
LENGTH
N
SO
IT
ALSO
MAKES
SENSE
TO
REFER
TO
THE
ARRAY
AS
HAVING
N
COLUMNS
EXTENDING
JAVA
ARRAY
CONSTRUCTS
TO
HANDLE
TWO
DIMENSIONAL
ARRAYS
IS
STRAIGHTFORWARD
TO
REFER
TO
THE
ENTRY
IN
ROW
I
AND
COLUMN
J
OF
A
TWO
DIMENSIONAL
ARRAY
A
WE
USE
THE
NOTATION
A
I
J
TO
DECLARE
A
TWO
DIMENSIONAL
ARRAY
WE
ADD
ANOTHER
PAIR
OF
SQUARE
BRACKETS
AND
TO
CREATE
THE
ARRAY
WE
SPECIFY
THE
NUMBER
OF
ROWS
FOLLOWED
BY
THE
NUMBER
OF
COLUMNS
AFTER
THE
TYPE
NAME
BOTH
WITHIN
SQUARE
BRACKETS
AS
FOLLOWS
DOUBLE
A
NEW
DOUBLE
M
N
WE
REFER
TO
SUCH
AN
ARRAY
AS
AN
M
BY
N
ARRAY
BY
CONVENTION
THE
FIRST
DIMENSION
IS
THE
NUMBER
OF
ROWS
AND
THE
SECOND
IS
THE
NUMBER
OF
COLUMNS
AS
WITH
ONE
DIMENSIONAL
ARRAYS
JAVA
INITIALIZES
ALL
ENTRIES
IN
ARRAYS
OF
NUMERIC
TYPES
TO
ZERO
AND
IN
ARRAYS
OF
BOOLEAN
VALUES
TO
FALSE
DEFAULT
INITIALIZATION
OF
TWO
DIMENSIONAL
ARRAYS
IS
USEFUL
BECAUSE
IT
MASKS
MORE
CODE
THAN
FOR
ONE
DIMENSIONAL
ARRAYS
THE
FOLLOWING
CODE
IS
EQUIVALENT
TO
THE
SINGLE
LINE
CREATE
AND
INITIALIZE
IDIOM
THAT
WE
JUST
CONSIDERED
DOUBLE
A
A
NEW
DOUBLE
M
N
FOR
INT
I
I
M
I
FOR
INT
J
J
N
J
A
I
J
THIS
CODE
IS
SUPERFLUOUS
WHEN
INITIALIZING
TO
ZERO
BUT
THE
NESTED
FOR
LOOPS
ARE
NEEDED
TO
INITIALIZE
TO
OTHER
VALUE
TASK
IMPLEMENTATION
CODE
FRAGMENT
FIND
THE
MAXIMUM
OF
THE
ARRAY
VALUES
DOUBLE
MAX
A
FOR
INT
I
I
A
LENGTH
I
IF
A
I
MAX
MAX
A
I
COMPUTE
THE
AVERAGE
OF
THE
ARRAY
VALUES
INT
N
A
LENGTH
DOUBLE
SUM
FOR
INT
I
I
N
I
SUM
A
I
DOUBLE
AVERAGE
SUM
N
COPY
TO
ANOTHER
ARRAY
INT
N
A
LENGTH
DOUBLE
B
NEW
DOUBLE
N
FOR
INT
I
I
N
I
B
I
A
I
REVERSE
THE
ELEMENTS
WITHIN
AN
ARRAY
INT
N
A
LENGTH
FOR
INT
I
I
N
I
DOUBLE
TEMP
A
I
A
I
A
N
I
A
N
I
TEMP
MATRIX
MATRIX
MULTIPLICATION
SQUARE
MATRICES
A
B
C
INT
N
A
LENGTH
DOUBLE
C
NEW
DOUBLE
N
N
FOR
INT
I
I
N
I
FOR
INT
J
J
N
J
COMPUTE
DOT
PRODUCT
OF
ROW
I
AND
COLUMN
J
FOR
INT
K
K
N
K
C
I
J
A
I
K
B
K
J
TYPICAL
ARRAY
PROCESSING
CODE
STATIC
METHODS
EVERY
JAVA
PROGRAM
IN
THIS
BOOK
IS
EITHER
A
DATA
TYPE
DEFINITION
WHICH
WE
DESCRIBE
IN
DETAIL
IN
SECTION
OR
A
LIBRARY
OF
STATIC
METHODS
WHICH
WE
DE
SCRIBE
HERE
STATIC
METHODS
ARE
CALLED
FUNCTIONS
IN
MANY
PROGRAMMING
LANGUAGES
SINCE
THEY
CAN
BEHAVE
LIKE
MATHEMATICAL
FUNCTIONS
AS
DESCRIBED
NEXT
EACH
STATIC
METHOD
IS
A
SEQUENCE
OF
STATEMENTS
THAT
ARE
EXECUTED
ONE
AFTER
THE
OTHER
WHEN
THE
STATIC
METHOD
IS
CALLED
IN
THE
MANNER
DESCRIBED
BELOW
THE
MODIFIER
STATIC
DISTINGUISHES
THESE
METH
ODS
FROM
INSTANCE
METHODS
WHICH
WE
DISCUSS
IN
SECTION
WE
USE
THE
WORD
METHOD
WITHOUT
A
MODIFIER
WHEN
DESCRIBING
CHARACTERISTICS
SHARED
BY
BOTH
KINDS
OF
METHODS
DEFINING
A
STATIC
METHOD
A
METHOD
ENCAPSULATES
A
COMPUTATION
THAT
IS
DEFINED
AS
A
SEQUENCE
OF
STATEMENTS
A
METHOD
TAKES
ARGUMENTS
VALUES
OF
GIVEN
DATA
TYPES
AND
COMPUTES
A
RETURN
VALUE
OF
SOME
DATA
TYPE
THAT
DEPENDS
UPON
THE
ARGUMENTS
SUCH
AS
A
VALUE
DEFINED
BY
A
MATHEMATICAL
FUNCTION
OR
CAUSES
A
SIDE
EFFECT
THAT
DEPENDS
ON
THE
ARGUMENTS
SUCH
AS
PRINTING
A
VALUE
THE
STATIC
METHOD
RANK
IN
BINARYSEARCH
SIGNATURE
LOCAL
VARIABLES
METHOD
BODY
RETURN
TYPE
METHOD
NAME
ARGUMENT
TYPE
ARGUMENT
VARIABLE
IS
AN
EXAMPLE
OF
THE
FIRST
MAIN
IS
AN
EX
AMPLE
OF
THE
SECOND
EACH
STATIC
METHOD
IS
COMPOSED
OF
A
SIGNATURE
THE
KEYWORDS
PUBLIC
STATIC
FOLLOWED
BY
A
RETURN
TYPE
THE
METHOD
NAME
AND
A
SEQUENCE
OF
AR
GUMENTS
EACH
WITH
A
DECLARED
TYPE
AND
A
BODY
A
STATEMENT
BLOCK
A
SEQUENCE
OF
STATEMENTS
ENCLOSED
IN
CURLY
BRACES
EX
AMPLES
OF
STATIC
METHODS
ARE
SHOWN
IN
THE
TABLE
ON
THE
FACING
PAGE
RETURN
STATEMENT
CALL
ON
ANOTHER
METHOD
INVOKING
A
STATIC
METHOD
A
CALL
ON
A
STATIC
ANATOMY
OF
A
STATIC
METHOD
METHOD
IS
ITS
NAME
FOLLOWED
BY
EXPRESSIONS
THAT
SPECIFY
ARGUMENT
VALUES
IN
PARENTHE
SES
SEPARATED
BY
COMMAS
WHEN
THE
METHOD
CALL
IS
PART
OF
AN
EXPRESSION
THE
METHOD
COMPUTES
A
VALUE
AND
THAT
VALUE
IS
USED
IN
PLACE
OF
THE
CALL
IN
THE
EXPRESSION
FOR
EX
AMPLE
THE
CALL
ON
RANK
IN
BINARYSEARCH
RETURNS
AN
INT
VALUE
A
METHOD
CALL
FOLLOWED
BY
A
SEMICOLON
IS
A
STATEMENT
THAT
GENERALLY
CAUSES
SIDE
EFFECTS
FOR
EXAMPLE
THE
CALL
ARRAYS
SORT
IN
MAIN
IN
BINARYSEARCH
IS
A
CALL
ON
THE
SYSTEM
METHOD
ARRAYS
SORT
THAT
HAS
THE
SIDE
EFFECT
OF
PUTTING
THE
ENTRIES
IN
THE
ARRAY
IN
SORTED
ORDER
WHEN
A
METHOD
IS
CALLED
ITS
ARGUMENT
VARIABLES
ARE
INITIALIZED
WITH
THE
VALUES
OF
THE
CORRESPONDING
EXPRESSIONS
IN
THE
CALL
A
RETURN
STATEMENT
TERMINATES
A
STATIC
METHOD
RETURNING
CONTROL
TO
THE
CALLER
IF
THE
STATIC
METHOD
IS
TO
COMPUTE
A
VALUE
THAT
VALUE
MUST
BE
SPECIFIED
IN
A
RETURN
STATEMENT
IF
SUCH
A
STATIC
METHOD
CAN
REACH
THE
END
OF
ITS
SEQUENCE
OF
STATEMENTS
WITHOUT
A
RETURN
THE
COMPILER
WILL
REPORT
THE
ERROR
TASK
IMPLEMENTATION
ABSOLUTE
VALUE
OF
AN
INT
VALUE
PUBLIC
STATIC
INT
ABS
INT
X
IF
X
RETURN
X
ELSE
RETURN
X
ABSOLUTE
VALUE
OF
A
DOUBLE
VALUE
PUBLIC
STATIC
DOUBLE
ABS
DOUBLE
X
IF
X
RETURN
X
ELSE
RETURN
X
PUBLIC
STATIC
BOOLEAN
ISPRIME
INT
N
PRIMALITY
TEST
IF
N
RETURN
FALSE
FOR
INT
I
I
I
N
I
IF
N
I
RETURN
FALSE
RETURN
TRUE
PUBLIC
STATIC
DOUBLE
SQRT
DOUBLE
C
SQUARE
ROOT
NEWTON
METHOD
IF
C
RETURN
DOUBLE
NAN
DOUBLE
ERR
DOUBLE
T
C
WHILE
MATH
ABS
T
C
T
ERR
T
T
C
T
T
RETURN
T
HYPOTENUSE
OF
A
RIGHT
TRIANGLE
PUBLIC
STATIC
DOUBLE
HYPOTENUSE
DOUBLE
A
DOUBLE
B
RETURN
MATH
SQRT
A
A
B
B
HARMONIC
NUMBER
SEE
PAGE
PUBLIC
STATIC
DOUBLE
H
INT
N
DOUBLE
SUM
FOR
INT
I
I
N
I
SUM
I
RETURN
SUM
TYPICAL
IMPLEMENTATIONS
OF
STATIC
METHODS
PROPERTIES
OF
METHODS
A
COMPLETE
DETAILED
DESCRIPTION
OF
THE
PROPERTIES
OF
METHODS
IS
BEYOND
OUR
SCOPE
BUT
THE
FOLLOWING
POINTS
ARE
WORTH
NOTING
ARGUMENTS
ARE
PASSED
BY
VALUE
YOU
CAN
USE
ARGUMENT
VARIABLES
ANYWHERE
IN
THE
CODE
IN
THE
BODY
OF
THE
METHOD
IN
THE
SAME
WAY
YOU
USE
LOCAL
VARIABLES
THE
ONLY
DIFFERENCE
BETWEEN
AN
ARGUMENT
VARIABLE
AND
A
LOCAL
VARIABLE
IS
THAT
THE
ARGUMENT
VARIABLE
IS
INITIALIZED
WITH
THE
ARGUMENT
VALUE
PROVIDED
BY
THE
CALL
ING
CODE
THE
METHOD
WORKS
WITH
THE
VALUE
OF
ITS
ARGUMENTS
NOT
THE
ARGUMENTS
THEMSELVES
ONE
CONSEQUENCE
OF
THIS
APPROACH
IS
THAT
CHANGING
THE
VALUE
OF
AN
ARGUMENT
VARIABLE
WITHIN
A
STATIC
METHOD
HAS
NO
EFFECT
ON
THE
CALLING
CODE
GEN
ERALLY
WE
DO
NOT
CHANGE
ARGUMENT
VARIABLES
IN
THE
CODE
IN
THIS
BOOK
THE
PASS
BY
VALUE
CONVENTION
IMPLIES
THAT
ARRAY
ARGUMENTS
ARE
ALIASED
SEE
PAGE
THE
METHOD
USES
THE
ARGUMENT
VARIABLE
TO
REFER
TO
THE
CALLER
ARRAY
AND
CAN
CHANGE
THE
CONTENTS
OF
THE
ARRAY
THOUGH
IT
CANNOT
CHANGE
THE
ARRAY
ITSELF
FOR
EXAMPLE
ARRAYS
SORT
CERTAINLY
CHANGES
THE
CONTENTS
OF
THE
ARRAY
PASSED
AS
ARGUMENT
IT
PUTS
THE
ENTRIES
IN
ORDER
METHOD
NAMES
CAN
BE
OVERLOADED
FOR
EXAMPLE
THE
JAVA
MATH
LIBRARY
USES
THIS
APPROACH
TO
PROVIDE
IMPLEMENTATIONS
OF
MATH
ABS
MATH
MIN
AND
MATH
MAX
FOR
ALL
PRIMITIVE
NUMERIC
TYPES
ANOTHER
COMMON
USE
OF
OVERLOAD
ING
IS
TO
DEFINE
TWO
DIFFERENT
VERSIONS
OF
A
FUNCTION
ONE
THAT
TAKES
AN
ARGUMENT
AND
ANOTHER
THAT
USES
A
DEFAULT
VALUE
OF
THAT
ARGUMENT
A
METHOD
HAS
A
SINGLE
RETURN
VALUE
BUT
MAY
HAVE
MULTIPLE
RETURN
STATEMENTS
A
JAVA
METHOD
CAN
PROVIDE
ONLY
ONE
RETURN
VALUE
OF
THE
TYPE
DECLARED
IN
THE
METHOD
SIGNATURE
CONTROL
GOES
BACK
TO
THE
CALLING
PROGRAM
AS
SOON
AS
THE
FIRST
RETURN
STATEMENT
IN
A
STATIC
METHOD
IS
REACHED
YOU
CAN
PUT
RETURN
STATEMENTS
WHEREVER
YOU
NEED
THEM
EVEN
THOUGH
THERE
MAY
BE
MULTIPLE
RETURN
STATEMENTS
ANY
STATIC
METHOD
RETURNS
A
SINGLE
VALUE
EACH
TIME
IT
IS
INVOKED
THE
VALUE
FOLLOW
ING
THE
FIRST
RETURN
STATEMENT
ENCOUNTERED
A
METHOD
CAN
HAVE
SIDE
EFFECTS
A
METHOD
MAY
USE
THE
KEYWORD
VOID
AS
ITS
RETURN
TYPE
TO
INDICATE
THAT
IT
HAS
NO
RETURN
VALUE
AN
EXPLICIT
RETURN
IS
NOT
NECESSARY
IN
A
VOID
STATIC
METHOD
CONTROL
RETURNS
TO
THE
CALLER
AFTER
THE
LAST
STATEMENT
A
VOID
STATIC
METHOD
IS
SAID
TO
PRODUCE
SIDE
EFFECTS
CONSUME
INPUT
PRODUCE
OUTPUT
CHANGE
ENTRIES
IN
AN
ARRAY
OR
OTHERWISE
CHANGE
THE
STATE
OF
THE
SYSTEM
FOR
EXAMPLE
THE
MAIN
STATIC
METHOD
IN
OUR
PROGRAMS
HAS
A
VOID
RETURN
TYPE
BECAUSE
ITS
PURPOSE
IS
TO
PRODUCE
OUTPUT
TECHNICALLY
VOID
METHODS
DO
NOT
IMPLEMENT
MATHEMATICAL
FUNCTIONS
AND
NEITHER
DOES
MATH
RANDOM
WHICH
TAKES
NO
ARGUMENTS
BUT
DOES
PRODUCE
A
RETURN
VALUE
THE
INSTANCE
METHODS
THAT
ARE
THE
SUBJECT
OF
SECTION
SHARE
THESE
PROPERTIES
THOUGH
PROFOUND
DIFFERENCES
SURROUND
THE
ISSUE
OF
SIDE
EFFECTS
RECURSION
A
METHOD
CAN
CALL
ITSELF
IF
YOU
ARE
NOT
COMFORTABLE
WITH
THIS
IDEA
KNOWN
AS
RECURSION
YOU
ARE
ENCOURAGED
TO
WORK
EXERCISES
THROUGH
FOR
EX
AMPLE
THE
CODE
AT
THE
BOTTOM
OF
THIS
PAGE
GIVES
AN
ALTERNATE
IMPLEMENTATION
OF
THE
RANK
METHOD
IN
BINARYSEARCH
WE
OFTEN
USE
RECURSIVE
IMPLEMENTATIONS
OF
METHODS
BECAUSE
THEY
CAN
LEAD
TO
COMPACT
ELEGANT
CODE
THAT
IS
EASIER
TO
UNDERSTAND
THAN
A
COR
RESPONDING
IMPLEMENTATION
THAT
DOES
NOT
USE
RECURSION
FOR
EXAMPLE
THE
COMMENT
IN
THE
IMPLEMENTATION
BELOW
PROVIDES
A
SUCCINCT
DESCRIPTION
OF
WHAT
THE
CODE
IS
SUP
POSED
TO
DO
WE
CAN
USE
THIS
COMMENT
TO
CONVINCE
OURSELVES
THAT
IT
OPERATES
CORRECTLY
BY
MATHEMATICAL
INDUCTION
WE
WILL
EXPAND
ON
THIS
TOPIC
AND
PROVIDE
SUCH
A
PROOF
FOR
BINARY
SEARCH
IN
SECTION
THERE
ARE
THREE
IMPORTANT
RULES
OF
THUMB
IN
DEVELOPING
RECURSIVE
PROGRAMS
THE
RECURSION
HAS
A
BASE
CASE
WE
ALWAYS
INCLUDE
A
CONDITIONAL
STATEMENT
AS
THE
FIRST
STATEMENT
IN
THE
PROGRAM
THAT
HAS
A
RETURN
RECURSIVE
CALLS
MUST
ADDRESS
SUBPROBLEMS
THAT
ARE
SMALLER
IN
SOME
SENSE
SO
THAT
RECURSIVE
CALLS
CONVERGE
TO
THE
BASE
CASE
IN
THE
CODE
BELOW
THE
DIFFERENCE
BETWEEN
THE
VALUES
OF
THE
FOURTH
AND
THE
THIRD
ARGUMENTS
ALWAYS
DECREASES
RECURSIVE
CALLS
SHOULD
NOT
ADDRESS
SUBPROBLEMS
THAT
OVERLAP
IN
THE
CODE
BELOW
THE
PORTIONS
OF
THE
ARRAY
REFERENCED
BY
THE
TWO
SUBPROBLEMS
ARE
DISJOINT
VIOLATING
ANY
OF
THESE
GUIDELINES
IS
LIKELY
TO
LEAD
TO
INCORRECT
RESULTS
OR
A
SPECTACULARLY
INEFFICIENT
PROGRAM
SEE
EXERCISES
AND
ADHERING
TO
THEM
IS
LIKELY
TO
LEAD
TO
A
CLEAR
AND
CORRECT
PROGRAM
WHOSE
PERFORMANCE
IS
EASY
TO
UNDERSTAND
ANOTHER
REASON
TO
USE
RECURSIVE
METHODS
IS
THAT
THEY
LEAD
TO
MATHEMATICAL
MODELS
THAT
WE
CAN
USE
TO
UNDERSTAND
PERFORMANCE
WE
ADDRESS
THIS
ISSUE
FOR
BINARY
SEARCH
IN
SECTION
AND
IN
SEVERAL
OTHER
INSTANCES
THROUGHOUT
THE
BOOK
BASIC
PROGRAMMING
MODEL
A
LIBRARY
OF
STATIC
METHODS
IS
A
SET
OF
STATIC
METHODS
THAT
ARE
DEFINED
IN
A
JAVA
CLASS
BY
CREATING
A
FILE
WITH
THE
KEYWORDS
PUBLIC
CLASS
FOLLOWED
BY
THE
CLASS
NAME
FOLLOWED
BY
THE
STATIC
METHODS
ENCLOSED
IN
BRACES
KEPT
IN
A
FILE
WITH
THE
SAME
NAME
AS
THE
CLASS
AND
A
JAVA
EXTENSION
A
BASIC
MODEL
FOR
JAVA
PROGRAMMING
IS
TO
DEVELOP
A
PROGRAM
THAT
ADDRESSES
A
SPECIFIC
COMPUTATIONAL
TASK
BY
CREATING
A
LI
BRARY
OF
STATIC
METHODS
ONE
OF
WHICH
IS
NAMED
MAIN
TYPING
JAVA
FOLLOWED
BY
A
CLASS
NAME
FOLLOWED
BY
A
SEQUENCE
OF
STRINGS
LEADS
TO
A
CALL
ON
MAIN
IN
THAT
CLASS
WITH
AN
ARRAY
CONTAINING
THOSE
STRINGS
AS
ARGUMENT
AFTER
THE
LAST
STATEMENT
IN
MAIN
EXECUTES
THE
PROGRAM
TERMINATES
IN
THIS
BOOK
WHEN
WE
TALK
OF
A
JAVA
PROGRAM
FOR
ACCOMPLISHING
A
TASK
WE
ARE
TALKING
ABOUT
CODE
DEVELOPED
ALONG
THESE
LINES
POSSIBLY
ALSO
INCLUDING
A
DATA
TYPE
DEFINITION
AS
DESCRIBED
IN
SECTION
FOR
EXAMPLE
BINARYSEARCH
IS
A
JAVA
PROGRAM
COMPOSED
OF
TWO
STATIC
METHODS
RANK
AND
MAIN
THAT
ACCOMPLISHES
THE
TASK
OF
PRINTING
NUMBERS
ON
AN
INPUT
STREAM
THAT
ARE
NOT
FOUND
IN
A
WHITELIST
FILE
GIVEN
AS
COMMAND
LINE
ARGUMENT
MODULAR
PROGRAMMING
OF
CRITICAL
IMPORTANCE
IN
THIS
MODEL
IS
THAT
LIBRARIES
OF
STAT
IC
METHODS
ENABLE
MODULAR
PROGRAMMING
WHERE
WE
BUILD
LIBRARIES
OF
STATIC
METHODS
MODULES
AND
A
STATIC
METHOD
IN
ONE
LIBRARY
CAN
CALL
STATIC
METHODS
DEFINED
IN
OTHER
LIBRARIES
THIS
APPROACH
HAS
MANY
IMPORTANT
ADVANTAGES
IT
ALLOWS
US
TO
WORK
WITH
MODULES
OF
REASONABLE
SIZE
EVEN
IN
PROGRAM
INVOLVING
A
LARGE
AMOUNT
OF
CODE
SHARE
AND
REUSE
CODE
WITHOUT
HAVING
TO
REIMPLEMENT
IT
EASILY
SUBSTITUTE
IMPROVED
IMPLEMENTATIONS
DEVELOP
APPROPRIATE
ABSTRACT
MODELS
FOR
ADDRESSING
PROGRAMMING
PROBLEMS
LOCALIZE
DEBUGGING
SEE
THE
PARAGRAPH
BELOW
ON
UNIT
TESTING
FOR
EXAMPLE
BINARYSEARCH
MAKES
USE
OF
THREE
OTHER
INDEPENDENTLY
DEVELOPED
LIBRAR
IES
OUR
STDIN
AND
IN
LIBRARY
AND
JAVA
ARRAYS
LIBRARY
EACH
OF
THESE
LIBRARIES
IN
TURN
MAKES
USE
OF
SEVERAL
OTHER
LIBRARIES
UNIT
TESTING
A
BEST
PRACTICE
IN
JAVA
PROGRAMMING
IS
TO
INCLUDE
A
MAIN
IN
EVERY
LI
BRARY
OF
STATIC
METHODS
THAT
TESTS
THE
METHODS
IN
THE
LIBRARY
SOME
OTHER
PROGRAMMING
LANGUAGES
DISALLOW
MULTIPLE
MAIN
METHODS
AND
THUS
DO
NOT
SUPPORT
THIS
APPROACH
PROPER
UNIT
TESTING
CAN
BE
A
SIGNIFICANT
PROGRAMMING
CHALLENGE
IN
ITSELF
AT
A
MINIMUM
EVERY
MODULE
SHOULD
CONTAIN
A
MAIN
METHOD
THAT
EXERCISES
THE
CODE
IN
THE
MODULE
AND
PROVIDES
SOME
ASSURANCE
THAT
IT
WORKS
AS
A
MODULE
MATURES
WE
OFTEN
REFINE
THE
MAIN
METHOD
TO
BE
A
DEVELOPMENT
CLIENT
THAT
HELPS
US
DO
MORE
DETAILED
TESTS
AS
WE
DEVELOP
THE
CODE
OR
A
TEST
CLIENT
THAT
TESTS
ALL
THE
CODE
EXTENSIVELY
AS
A
CLIENT
BECOMES
MORE
COMPLICATED
WE
MIGHT
PUT
IT
IN
AN
INDEPENDENT
MODULE
IN
THIS
BOOK
WE
USE
MAIN
TO
HELP
ILLUSTRATE
THE
PURPOSE
OF
EACH
MODULE
AND
LEAVE
TEST
CLIENTS
FOR
EXERCISES
EXTERNAL
LIBRARIES
WE
USE
STATIC
METHODS
FROM
FOUR
DIFFERENT
KINDS
OF
LIBRARIES
EACH
REQUIRING
SLIGHTLY
DIFFERING
PROCEDURES
FOR
CODE
REUSE
MOST
OF
THESE
ARE
LIBRARIES
OF
STATIC
METHODS
BUT
A
FEW
ARE
DATA
TYPE
DEFINITIONS
THAT
ALSO
INCLUDE
SOME
STATIC
METHODS
THE
STANDARD
SYSTEM
LIBRARIES
JAVA
LANG
THESE
INCLUDE
MATH
WHICH
CONTAINS
METHODS
FOR
COMMONLY
USED
MATHEMATICAL
FUNCTIONS
INTEGER
AND
DOUBLE
WHICH
WE
USE
FOR
CONVERTING
BETWEEN
STRINGS
OF
CHARACTERS
AND
INT
AND
DOUBLE
VALUES
STRING
AND
STRINGBUILDER
WHICH
WE
DISCUSS
IN
DETAIL
LATER
IN
THIS
SECTION
AND
IN
CHAPTER
AND
DOZENS
OF
OTHER
LIBRARIES
THAT
WE
DO
NOT
USE
IMPORTED
SYSTEM
LIBRARIES
SUCH
AS
JAVA
UTIL
ARRAYS
THERE
ARE
THOUSANDS
OF
SUCH
LIBRARIES
IN
A
STANDARD
JAVA
RELEASE
BUT
WE
MAKE
SCANT
USE
OF
THEM
IN
THIS
BOOK
AN
IMPORT
STATEMENT
AT
THE
BEGINNING
OF
THE
PROGRAM
IS
NEEDED
TO
USE
SUCH
LIBRARIES
AND
SIGNAL
THAT
WE
ARE
DOING
SO
OTHER
LIBRARIES
IN
THIS
BOOK
FOR
EXAMPLE
ANOTHER
PROGRAM
CAN
USE
RANK
IN
BINARYSEARCH
TO
USE
SUCH
A
PROGRAM
DOWN
LOAD
THE
SOURCE
FROM
THE
BOOKSITE
INTO
YOUR
WORKING
DIRECTORY
THE
STANDARD
LIBRARIES
STD
THAT
WE
HAVE
DEVELOPED
FOR
USE
IN
THIS
BOOK
AND
OUR
INTRODUCTORY
BOOK
AN
INTRODUCTION
TO
PROGRAMMING
IN
JAVA
AN
INTERDISCIPLINARY
APPROACH
THESE
LIBRARIES
ARE
SUMMARIZED
IN
THE
FOLLOWING
SEVERAL
PAGES
SOURCE
CODE
AND
INSTRUCTIONS
FOR
DOWNLOADING
THEM
ARE
AVAILABLE
ON
THE
BOOKSITE
TO
INVOKE
A
METHOD
FROM
ANOTHER
LIBRARY
ONE
IN
THE
SAME
DIRECTORY
OR
A
SPECIFIED
DIRECTORY
A
STANDARD
SYSTEM
LIBRARY
OR
A
SYSTEM
LIBRARY
THAT
IS
NAMED
IN
AN
IMPORT
STATEMENT
BEFORE
THE
CLASS
DEFINITION
WE
PREPEND
THE
LIBRARY
NAME
TO
THE
METHOD
NAME
FOR
EACH
CALL
FOR
EX
AMPLE
THE
MAIN
METHOD
IN
BINARYSEARCH
CALLS
THE
SORT
METHOD
IN
THE
SYSTEM
LIBRARY
JAVA
UTIL
ARRAYS
THE
READINTS
METHOD
IN
OUR
LIBRARY
IN
AND
THE
PRINTLN
METHOD
IN
OUR
LIBRARY
STDOUT
STANDARD
SYSTEM
LIBRARIES
MATH
INTEGER
DOUBLE
STRING
STRINGBUILDER
SYSTEM
IMPORTED
SYSTEM
LIBRARIES
JAVA
UTIL
ARRAYS
OUR
STANDARD
LIBRARIES
STDIN
STDOUT
STDDRAW
STDRANDOM
STDSTATS
IN
OUT
DATA
TYPE
DEFINITIONS
THAT
INCLUDE
SOME
STATIC
METHODS
LIBRARIES
WITH
STATIC
METHODS
USED
IN
THIS
BOOK
LIBRARIES
OF
METHODS
IMPLEMENTED
BY
OURSELVES
AND
BY
OTHERS
IN
A
MODULAR
PROGRAMMING
ENVIRONMENT
CAN
VASTLY
EXPAND
THE
SCOPE
OF
OUR
PROGRAMMING
MODEL
BEYOND
ALL
OF
THE
LIBRARIES
AVAILABLE
IN
A
STANDARD
JAVA
RELEASE
THOUSANDS
MORE
ARE
AVAIL
ABLE
ON
THE
WEB
FOR
APPLICATIONS
OF
ALL
SORTS
TO
LIMIT
THE
SCOPE
OF
OUR
PROGRAMMING
MODEL
TO
A
MANAGEABLE
SIZE
SO
THAT
WE
CAN
CONCENTRATE
ON
ALGORITHMS
WE
USE
JUST
THE
LIBRARIES
LISTED
IN
THE
TABLE
AT
RIGHT
ON
THIS
PAGE
WITH
A
SUBSET
OF
THEIR
METHODS
LISTED
IN
APIS
AS
DESCRIBED
NEXT
APIS
A
CRITICAL
COMPONENT
OF
MODULAR
PROGRAMMING
IS
DOCUMENTATION
THAT
EXPLAINS
THE
OPERATION
OF
LIBRARY
METHODS
THAT
ARE
INTENDED
FOR
USE
BY
OTHERS
WE
WILL
CONSIS
TENTLY
DESCRIBE
THE
LIBRARY
METHODS
THAT
WE
USE
IN
THIS
BOOK
IN
APPLICATION
PROGRAMMING
INTERFACES
APIS
THAT
LIST
THE
LIBRARY
NAME
AND
THE
SIGNATURES
AND
SHORT
DESCRIPTIONS
OF
EACH
OF
THE
METHODS
THAT
WE
USE
WE
USE
THE
TERM
CLIENT
TO
REFER
TO
A
PROGRAM
THAT
CALLS
A
METHOD
IN
ANOTHER
LIBRARY
AND
THE
TERM
IMPLEMENTATION
TO
DESCRIBE
THE
JAVA
CODE
THAT
IMPLEMENTS
THE
METHODS
IN
AN
API
EXAMPLE
THE
FOLLOWING
EXAMPLE
THE
API
FOR
COMMONLY
USED
STATIC
METHODS
FROM
THE
STANDARD
MATH
LIBRARY
IN
JAVA
LANG
ILLUSTRATES
OUR
CONVENTIONS
FOR
APIS
PUBLIC
CLASS
MATH
STATIC
DOUBLE
ABS
DOUBLE
A
ABSOLUTE
VALUE
OF
A
STATIC
DOUBLE
MAX
DOUBLE
A
DOUBLE
B
MAXIMUM
OF
A
AND
B
STATIC
DOUBLE
MIN
DOUBLE
A
DOUBLE
B
MINIMUM
OF
A
AND
B
NOTE
ABS
MAX
AND
MIN
ARE
DEFINED
ALSO
FOR
INT
LONG
AND
FLOAT
STATIC
DOUBLE
SIN
DOUBLE
THETA
SINE
FUNCTION
STATIC
DOUBLE
COS
DOUBLE
THETA
COSINE
FUNCTION
STATIC
DOUBLE
TAN
DOUBLE
THETA
TANGENT
FUNCTION
NOTE
ANGLES
ARE
EXPRESSED
IN
RADIANS
USE
TODEGREES
AND
TORADIANS
TO
CONVERT
NOTE
USE
ASIN
ACOS
AND
ATAN
FOR
INVERSE
FUNCTIONS
STATIC
DOUBLE
EXP
DOUBLE
A
EXPONENTIAL
E
A
STATIC
DOUBLE
LOG
DOUBLE
A
NATURAL
LOG
LOGE
A
OR
LN
A
STATIC
DOUBLE
POW
DOUBLE
A
DOUBLE
B
RAISE
A
TO
THE
BTH
POWER
AB
STATIC
DOUBLE
RANDOM
RANDOM
NUMBER
IN
STATIC
DOUBLE
SQRT
DOUBLE
A
SQUARE
ROOT
OF
A
STATIC
DOUBLE
E
VALUE
OF
E
CONSTANT
STATIC
DOUBLE
PI
VALUE
OF
CONSTANT
SEE
BOOKSITE
FOR
OTHER
AVAILABLE
FUNCTIONS
API
FOR
JAVA
MATHEMATICS
LIBRARY
EXCERPTS
THESE
METHODS
IMPLEMENT
MATHEMATICAL
FUNCTIONS
THEY
USE
THEIR
ARGUMENTS
TO
COM
PUTE
A
VALUE
OF
A
SPECIFIED
TYPE
EXCEPT
RANDOM
WHICH
DOES
NOT
IMPLEMENT
A
MATH
EMATICAL
FUNCTION
BECAUSE
IT
DOES
NOT
TAKE
AN
ARGUMENT
SINCE
THEY
ALL
OPERATE
ON
DOUBLE
VALUES
AND
COMPUTE
A
DOUBLE
RESULT
YOU
CAN
CONSIDER
THEM
AS
EXTENDING
THE
DOUBLE
DATA
TYPE
EXTENSIBILITY
OF
THIS
NATURE
IS
ONE
OF
THE
CHARACTERISTIC
FEATURES
OF
MODERN
PROGRAMMING
LANGUAGES
EACH
METHOD
IS
DESCRIBED
BY
A
LINE
IN
THE
API
THAT
SPECIFIES
THE
INFORMATION
YOU
NEED
TO
KNOW
IN
ORDER
TO
USE
THE
METHOD
THE
MATH
LI
BRARY
ALSO
DEFINES
THE
PRECISE
CONSTANT
VALUES
PI
FOR
AND
E
FOR
E
SO
THAT
YOU
CAN
USE
THOSE
NAMES
TO
REFER
TO
THOSE
CONSTANTS
IN
YOUR
PROGRAMS
FOR
EXAMPLE
THE
VALUE
OF
MATH
SIN
MATH
PI
IS
AND
THE
VALUE
OF
MATH
LOG
MATH
E
IS
BECAUSE
MATH
SIN
TAKES
ITS
ARGUMENT
IN
RADIANS
AND
MATH
LOG
IMPLEMENTS
THE
NATURAL
LOGARITHM
FUNCTION
JAVA
LIBRARIES
EXTENSIVE
ONLINE
DESCRIPTIONS
OF
THOUSANDS
OF
LIBRARIES
ARE
PART
OF
EVERY
JAVA
RELEASE
BUT
WE
EXCERPT
JUST
A
FEW
METHODS
THAT
WE
USE
IN
THE
BOOK
IN
ORDER
TO
CLEAR
LY
DELINEATE
OUR
PROGRAMMING
MODEL
FOR
EXAMPLE
BINARYSEARCH
USES
THE
SORT
METHOD
FROM
JAVA
ARRAYS
LIBRARY
WHICH
WE
DOCUMENT
AS
FOLLOWS
PUBLIC
CLASS
ARRAYS
STATIC
VOID
SORT
INT
A
PUT
THE
ARRAY
IN
INCREASING
ORDER
NOTE
THIS
METHOD
IS
DEFINED
ALSO
FOR
OTHER
PRIMITIVE
TYPES
AND
OBJECT
EXCERPT
FROM
JAVA
ARRAYS
LIBRARY
JAVA
UTIL
ARRAYS
THE
ARRAYS
LIBRARY
IS
NOT
IN
JAVA
LANG
SO
AN
IMPORT
STATEMENT
IS
NEEDED
TO
USE
IT
AS
IN
BINARYSEARCH
ACTUALLY
CHAPTER
OF
THIS
BOOK
IS
DEVOTED
TO
IMPLEMENTATIONS
OF
SORT
FOR
ARRAYS
INCLUDING
THE
MERGESORT
AND
QUICKSORT
ALGORITHMS
THAT
ARE
IMPLE
MENTED
IN
ARRAYS
SORT
MANY
OF
THE
FUNDAMENTAL
ALGORITHMS
THAT
WE
CONSIDER
IN
THIS
BOOK
ARE
IMPLEMENTED
IN
JAVA
AND
IN
MANY
OTHER
PROGRAMMING
ENVIRONMENTS
FOR
EXAMPLE
ARRAYS
ALSO
INCLUDES
AN
IMPLEMENTATION
OF
BINARY
SEARCH
TO
AVOID
CONFUSION
WE
GENERALLY
USE
OUR
OWN
IMPLEMENTATIONS
ALTHOUGH
THERE
IS
NOTHING
WRONG
WITH
USING
A
FINELY
TUNED
LIBRARY
IMPLEMENTATION
OF
AN
ALGORITHM
THAT
YOU
UNDERSTAND
OUR
STANDARD
LIBRARIES
WE
HAVE
DEVELOPED
A
NUMBER
OF
LIBRARIES
THAT
PROVIDE
USEFUL
FUNCTIONALITY
FOR
INTRODUCTORY
JAVA
PROGRAMMING
FOR
SCIENTIFIC
APPLICATIONS
AND
FOR
THE
DEVELOPMENT
STUDY
AND
APPLICATION
OF
ALGORITHMS
MOST
OF
THESE
LIBRARIES
ARE
FOR
INPUT
AND
OUTPUT
WE
ALSO
MAKE
USE
OF
THE
FOLLOWING
TWO
LIBRARIES
TO
TEST
AND
ANALYZE
OUR
IMPLEMENTATIONS
THE
FIRST
EXTENDS
MATH
RANDOM
TO
ALLOW
US
TO
DRAW
RANDOM
VALUES
FROM
VARIOUS
DISTRIBUTIONS
THE
SECOND
SUPPORTS
STATISTICAL
CALCULATIONS
PUBLIC
CLASS
STDRANDOM
STATIC
VOID
INITIALIZE
LONG
SEED
INITIALIZE
STATIC
DOUBLE
RANDOM
REAL
BETWEEN
AND
STATIC
INT
UNIFORM
INT
N
INTEGER
BETWEEN
AND
N
STATIC
INT
UNIFORM
INT
LO
INT
HI
INTEGER
BETWEEN
LO
AND
HI
STATIC
DOUBLE
UNIFORM
DOUBLE
LO
DOUBLE
HI
REAL
BETWEEN
LO
AND
HI
STATIC
BOOLEAN
BERNOULLI
DOUBLE
P
TRUE
WITH
PROBABILITY
P
STATIC
DOUBLE
GAUSSIAN
NORMAL
MEAN
STD
DEV
STATIC
DOUBLE
GAUSSIAN
DOUBLE
M
DOUBLE
NORMAL
MEAN
M
STD
DEV
STATIC
INT
DISCRETE
DOUBLE
A
I
WITH
PROBABILITY
A
I
STATIC
VOID
SHUFFLE
DOUBLE
A
RANDOMLY
SHUFFLE
THE
ARRAY
A
NOTE
OVERLOADED
IMPLEMENTATIONS
OF
SHUFFLE
ARE
INCLUDED
FOR
OTHER
PRIMITIVE
TYPES
AND
FOR
OBJECT
API
FOR
OUR
LIBRARY
OF
STATIC
METHODS
FOR
RANDOM
NUMBERS
PUBLIC
CLASS
STDSTATS
STATIC
DOUBLE
MAX
DOUBLE
A
LARGEST
VALUE
STATIC
DOUBLE
MIN
DOUBLE
A
SMALLEST
VALUE
STATIC
DOUBLE
MEAN
DOUBLE
A
AVERAGE
STATIC
DOUBLE
VAR
DOUBLE
A
SAMPLE
VARIANCE
STATIC
DOUBLE
STDDEV
DOUBLE
A
SAMPLE
STANDARD
DEVIATION
STATIC
DOUBLE
MEDIAN
DOUBLE
A
MEDIAN
API
FOR
OUR
LIBRARY
OF
STATIC
METHODS
FOR
DATA
ANALYSIS
THE
INITIALIZE
METHOD
IN
STDRANDOM
ALLOWS
US
TO
SEED
THE
RANDOM
NUMBER
GEN
ERATOR
SO
THAT
WE
CAN
REPRODUCE
EXPERIMENTS
INVOLVING
RANDOM
NUMBERS
FOR
REFERENCE
IMPLEMENTATIONS
OF
MANY
OF
THESE
METHODS
ARE
GIVEN
ON
PAGE
SOME
OF
THESE
METHODS
ARE
EXTREMELY
EASY
TO
IMPLEMENT
WHY
DO
WE
BOTHER
INCLUDING
THEM
IN
A
LIBRARY
AN
SWERS
TO
THIS
QUESTION
ARE
STANDARD
FOR
WELL
DESIGNED
LIBRARIES
THEY
IMPLEMENT
A
LEVEL
OF
ABSTRACTION
THAT
ALLOW
US
TO
FOCUS
ON
IMPLEMENT
ING
AND
TESTING
THE
ALGORITHMS
IN
THE
BOOK
NOT
GENERATING
RANDOM
OBJECTS
OR
CALCULATING
STATISTICS
CLIENT
CODE
THAT
USES
SUCH
METHODS
IS
CLEARER
AND
EASIER
TO
UNDERSTAND
THAN
HOMEGROWN
CODE
THAT
DOES
THE
SAME
CALCULATION
LIBRARY
IMPLEMENTATIONS
TEST
FOR
EXCEPTIONAL
CONDITIONS
COVER
RARELY
ENCOUN
TERED
SITUATIONS
AND
SUBMIT
TO
EXTENSIVE
TESTING
SO
THAT
WE
CAN
COUNT
ON
THEM
TO
OPERATE
AS
EXPECTED
SUCH
IMPLEMENTATIONS
MIGHT
INVOLVE
A
SIGNIFICANT
AMOUNT
OF
CODE
FOR
EXAMPLE
WE
OFTEN
WANT
IMPLEMENTATIONS
FOR
VARIOUS
TYPES
OF
DATA
FOR
EXAMPLE
JAVA
ARRAYS
LIBRARY
INCLUDES
MULTIPLE
OVERLOADED
IMPLEMENTA
TIONS
OF
SORT
ONE
FOR
EACH
TYPE
OF
DATA
THAT
YOU
MIGHT
NEED
TO
SORT
THESE
ARE
BEDROCK
CONSIDERATIONS
FOR
MODULAR
PROGRAMMING
IN
JAVA
BUT
PERHAPS
A
BIT
OVERSTATED
IN
THIS
CASE
WHILE
THE
METHODS
IN
BOTH
OF
THESE
LIBRARIES
ARE
ESSENTIALLY
SELF
DOCUMENTING
AND
MANY
OF
THEM
ARE
NOT
DIFFICULT
TO
IMPLEMENT
SOME
OF
THEM
REPRESENT
INTERESTING
ALGORITHMIC
EXERCISES
ACCORDINGLY
YOU
ARE
WELL
ADVISED
TO
BOTH
STUDY
THE
CODE
IN
STDRANDOM
JAVA
AND
STDSTATS
JAVA
ON
THE
BOOKSITE
AND
TO
TAKE
ADVANTAGE
OF
THESE
TRIED
AND
TRUE
IMPLEMENTATIONS
THE
EASIEST
WAY
TO
USE
THESE
LIBRARIES
AND
TO
EXAMINE
THE
CODE
IS
TO
DOWNLOAD
THE
SOURCE
CODE
FROM
THE
BOOKSITE
AND
PUT
THEM
IN
YOUR
WORKING
DIRECTORY
VARIOUS
SYSTEM
DEPENDENT
MECHANISMS
FOR
USING
THEM
WITH
OUT
MAKING
MULTIPLE
COPIES
ARE
ALSO
DESCRIBED
ON
THE
BOOKSITE
YOUR
OWN
LIBRARIES
IT
IS
WORTHWHILE
TO
CONSIDER
EVERY
PROGRAM
THAT
YOU
WRITE
AS
A
LI
BRARY
IMPLEMENTATION
FOR
POSSIBLE
REUSE
IN
THE
FUTURE
WRITE
CODE
FOR
THE
CLIENT
A
TOP
LEVEL
IMPLEMENTATION
THAT
BREAKS
THE
COMPUTA
TION
UP
INTO
MANAGEABLE
PARTS
ARTICULATE
AN
API
FOR
A
LIBRARY
OR
MULTIPLE
APIS
FOR
MULTIPLE
LIBRARIES
OF
STATIC
METHODS
THAT
CAN
ADDRESS
EACH
PART
DEVELOP
AN
IMPLEMENTATION
OF
THE
API
WITH
A
MAIN
THAT
TESTS
THE
METHODS
INDEPENDENT
OF
THE
CLIENT
NOT
ONLY
DOES
THIS
APPROACH
PROVIDE
YOU
WITH
VALUABLE
SOFTWARE
THAT
YOU
CAN
LATER
REUSE
BUT
ALSO
TAKING
ADVANTAGE
OF
MODULAR
PROGRAMMING
IN
THIS
WAY
IS
A
KEY
TO
SUC
CESSFULLY
ADDRESSING
A
COMPLEX
PROGRAMMING
TASK
INTENDED
RESULT
IMPLEMENTATION
RANDOM
DOUBLE
VALUE
IN
A
B
PUBLIC
STATIC
DOUBLE
UNIFORM
DOUBLE
A
DOUBLE
B
RETURN
A
STDRANDOM
RANDOM
B
A
RANDOM
INT
VALUE
IN
N
PUBLIC
STATIC
INT
UNIFORM
INT
N
RETURN
INT
STDRANDOM
RANDOM
N
RANDOM
INT
VALUE
IN
LO
HI
PUBLIC
STATIC
INT
UNIFORM
INT
LO
INT
HI
RETURN
LO
STDRANDOM
UNIFORM
HI
LO
RANDOM
INT
VALUE
DRAWN
FROM
DISCRETE
DISTRIBUTION
I
WITH
PROBABILITY
A
I
PUBLIC
STATIC
INT
DISCRETE
DOUBLE
A
ENTRIES
IN
A
MUST
SUM
TO
DOUBLE
R
STDRANDOM
RANDOM
DOUBLE
SUM
FOR
INT
I
I
A
LENGTH
I
SUM
SUM
A
I
IF
SUM
R
RETURN
I
RETURN
PUBLIC
STATIC
VOID
SHUFFLE
DOUBLE
A
RANDOMLY
SHUFFLE
THE
ELEMENTS
IN
AN
ARRAY
OF
DOUBLE
VALUES
SEE
EXERCISE
INT
N
A
LENGTH
FOR
INT
I
I
N
I
EXCHANGE
A
I
WITH
RANDOM
ELEMENT
IN
A
I
N
INT
R
I
STDRANDOM
UNIFORM
N
I
DOUBLE
TEMP
A
I
A
I
A
R
A
R
TEMP
IMPLEMENTATIONS
OF
STATIC
METHODS
IN
STDRANDOM
LIBRARY
THE
PURPOSE
OF
AN
API
IS
TO
SEPARATE
THE
CLIENT
FROM
THE
IMPLEMENTATION
THE
CLIENT
SHOULD
KNOW
NOTHING
ABOUT
THE
IMPLEMENTATION
OTHER
THAN
INFORMATION
GIVEN
IN
THE
API
AND
THE
IMPLEMENTATION
SHOULD
NOT
TAKE
PROPERTIES
OF
ANY
PARTICULAR
CLIENT
INTO
ACCOUNT
APIS
ENABLE
US
TO
SEPARATELY
DEVELOP
CODE
FOR
VARIOUS
PURPOSES
THEN
REUSE
IT
WIDELY
NO
JAVA
LIBRARY
CAN
CONTAIN
ALL
THE
METHODS
THAT
WE
MIGHT
NEED
FOR
A
GIVEN
COMPUTATION
SO
THIS
ABILITY
IS
A
CRUCIAL
STEP
IN
ADDRESSING
COMPLEX
PROGRAMMING
AP
PLICATIONS
ACCORDINGLY
PROGRAMMERS
NORMALLY
THINK
OF
THE
API
AS
A
CONTRACT
BETWEEN
THE
CLIENT
AND
THE
IMPLEMENTATION
THAT
IS
A
CLEAR
SPECIFICATION
OF
WHAT
EACH
METHOD
IS
TO
DO
OUR
GOAL
WHEN
DEVELOPING
AN
IMPLEMENTATION
IS
TO
HONOR
THE
TERMS
OF
THE
CONTRACT
OFTEN
THERE
ARE
MANY
WAYS
TO
DO
SO
AND
SEPARATING
CLIENT
CODE
FROM
IMPLEMENTATION
CODE
GIVES
US
THE
FREEDOM
TO
SUBSTITUTE
NEW
AND
IMPROVED
IMPLEMENTATIONS
IN
THE
STUDY
OF
ALGORITHMS
THIS
ABILITY
IS
AN
IMPORTANT
INGREDIENT
IN
OUR
ABILITY
TO
UNDERSTAND
THE
IMPACT
OF
ALGORITHMIC
IMPROVEMENTS
THAT
WE
DEVELOP
STRINGS
A
STRING
IS
A
SEQUENCE
OF
CHARACTERS
CHAR
VALUES
A
LITERAL
STRING
IS
A
SEQUENCE
OF
CHARACTERS
WITHIN
DOUBLE
QUOTES
SUCH
AS
HELLO
WORLD
THE
DATA
TYPE
STRING
IS
A
JAVA
DATA
TYPE
BUT
IT
IS
NOT
A
PRIMITIVE
TYPE
WE
CONSIDER
STRING
NOW
BE
CAUSE
IT
IS
A
FUNDAMENTAL
DATA
TYPE
THAT
ALMOST
EVERY
JAVA
PROGRAM
USES
CONCATENATION
JAVA
HAS
A
BUILT
IN
CONCATENATION
OPERATOR
FOR
STRING
LIKE
THE
BUILT
IN
OPERATORS
THAT
IT
HAS
FOR
PRIMITIVE
TYPES
JUSTIFYING
THE
ADDITION
OF
THE
ROW
IN
THE
TABLE
BELOW
TO
THE
PRIMITIVE
TYPE
TABLE
ON
PAGE
THE
RESULT
OF
CONCATENATING
TWO
STRING
VALUES
IS
A
SINGLE
STRING
VALUE
THE
FIRST
STRING
FOLLOWED
BY
THE
SECOND
TYPICAL
EXPRESSIONS
TYPE
SET
OF
VALUES
TYPICAL
LITERALS
OPERATORS
EXPRESSION
VALUE
STRING
CHARACTER
SEQUENCES
AB
HELLO
CONCATENATE
HI
BOB
HI
BOB
JAVA
STRING
DATA
TYPE
CONVERSION
TWO
PRIMARY
USES
OF
STRINGS
ARE
TO
CONVERT
VALUES
THAT
WE
CAN
ENTER
ON
A
KEYBOARD
INTO
DATA
TYPE
VALUES
AND
TO
CONVERT
DATA
TYPE
VALUES
TO
VALUES
THAT
WE
CAN
READ
ON
A
DISPLAY
JAVA
HAS
BUILT
IN
OPERATIONS
FOR
STRING
TO
FACILITATE
THESE
OPERATIONS
IN
PARTICULAR
THE
LANGUAGE
INCLUDES
LIBRARIES
INTEGER
AND
DOUBLE
THAT
CONTAIN
STATIC
METHODS
TO
CONVERT
BETWEEN
STRING
VALUES
AND
INT
VALUES
AND
BETWEEN
STRING
VALUES
AND
DOUBLE
VALUES
RESPECTIVELY
PUBLIC
CLASS
INTEGER
STATIC
INT
PARSEINT
STRING
CONVERT
TO
AN
INT
VALUE
STATIC
STRING
TOSTRING
INT
I
CONVERT
I
TO
A
STRING
VALUE
PUBLIC
CLASS
DOUBLE
STATIC
DOUBLE
PARSEDOUBLE
STRING
CONVERT
TO
A
DOUBLE
VALUE
STATIC
STRING
TOSTRING
DOUBLE
X
CONVERT
X
TO
A
STRING
VALUE
APIS
FOR
CONVERSION
BETWEEN
NUMBERS
AND
STRING
VALUES
AUTOMATIC
CONVERSION
WE
RARELY
EXPLICITLY
USE
THE
STATIC
TOSTRING
METHODS
JUST
DESCRIBED
BECAUSE
JAVA
HAS
A
BUILT
IN
MECHANISM
THAT
ALLOWS
US
TO
CONVERT
FROM
ANY
DATA
TYPE
VALUE
TO
A
STRING
VALUE
BY
USING
CONCATENATION
IF
ONE
OF
THE
ARGUMENTS
OF
IS
A
STRING
JAVA
AUTOMATICALLY
CONVERTS
THE
OTHER
ARGUMENT
TO
A
STRING
IF
IT
IS
NOT
ALREADY
A
STRING
BEYOND
USAGE
LIKE
THE
SQUARE
ROOT
OF
IS
MATH
SQRT
THIS
MECHANISM
ENABLES
CONVERSION
OF
ANY
DATA
TYPE
VALUE
TO
A
STRING
BY
CONCATENAT
ING
IT
WITH
THE
EMPTY
STRING
COMMAND
LINE
ARGUMENTS
ONE
IMPORTANT
USE
OF
STRINGS
IN
JAVA
PROGRAMMING
IS
TO
ENABLE
A
MECHANISM
FOR
PASSING
INFORMATION
FROM
THE
COMMAND
LINE
TO
THE
PROGRAM
THE
MECHANISM
IS
SIMPLE
WHEN
YOU
TYPE
THE
JAVA
COMMAND
FOLLOWED
BY
A
LIBRARY
NAME
FOLLOWED
BY
A
SEQUENCE
OF
STRINGS
THE
JAVA
SYSTEM
INVOKES
THE
MAIN
METHOD
IN
THAT
LIBRARY
WITH
AN
ARRAY
OF
STRINGS
AS
ARGUMENT
THE
STRINGS
TYPED
AFTER
THE
LIBRARY
NAME
FOR
EXAMPLE
THE
MAIN
METHOD
IN
BINARYSEARCH
TAKES
ONE
COMMAND
LINE
ARGUMENT
SO
THE
SYSTEM
CREATES
AN
ARRAY
OF
SIZE
ONE
THE
PROGRAM
USES
THAT
VALUE
ARGS
TO
NAME
THE
FILE
CONTAINING
THE
WHITELIST
FOR
USE
AS
THE
ARGUMENT
TO
IN
READINTS
AN
OTHER
TYPICAL
PARADIGM
THAT
WE
OFTEN
USE
IN
OUR
CODE
IS
WHEN
A
COMMAND
LINE
ARGU
MENT
IS
INTENDED
TO
REPRESENT
A
NUMBER
SO
WE
USE
PARSEINT
TO
CONVERT
TO
AN
INT
VALUE
OR
PARSEDOUBLE
TO
CONVERT
TO
A
DOUBLE
VALUE
COMPUTING
WITH
STRINGS
IS
AN
ESSENTIAL
COMPONENT
OF
MODERN
COMPUTING
FOR
THE
MOMENT
WE
MAKE
USE
OF
STRING
JUST
TO
CONVERT
BETWEEN
EXTERNAL
REPRESENTATION
OF
NUMBERS
AS
SEQUENCES
OF
CHARACTERS
AND
INTERNAL
REPRESENTATION
OF
NUMERIC
DATA
TYPE
VALUES
IN
SECTION
WE
WILL
SEE
THAT
JAVA
SUPPORTS
MANY
MANY
MORE
OPERATIONS
ON
STRING
VALUES
THAT
WE
USE
THROUGHOUT
THE
BOOK
IN
SECTION
WE
WILL
EXAMINE
THE
INTERNAL
REPRESENTATION
OF
STRING
VALUES
AND
IN
CHAPTER
WE
CONSIDER
IN
DEPTH
AL
GORITHMS
THAT
PROCESS
STRING
DATA
THESE
ALGORITHMS
ARE
AMONG
THE
MOST
INTERESTING
INTRICATE
AND
IMPACTFUL
METHODS
THAT
WE
CONSIDER
IN
THIS
BOOK
INPUT
AND
OUTPUT
THE
PRIMARY
PURPOSE
OF
OUR
STANDARD
LIBRARIES
FOR
INPUT
OUT
PUT
AND
DRAWING
IS
TO
SUPPORT
A
SIMPLE
MODEL
FOR
JAVA
PROGRAMS
TO
INTERACT
WITH
THE
OUTSIDE
WORLD
THESE
LIBRARIES
ARE
BUILT
UPON
EXTENSIVE
CAPABILITIES
THAT
ARE
AVAILABLE
IN
JAVA
LIBRARIES
BUT
ARE
GENERALLY
MUCH
MORE
COMPLICATED
AND
MUCH
MORE
DIFFICULT
TO
LEARN
AND
USE
WE
BEGIN
BY
BRIEFLY
REVIEWING
THE
MODEL
STANDARD
INPUT
COMMAND
LINE
ARGUMENTS
STANDARD
OUTPUT
FILE
I
O
STANDARD
DRAWING
A
BIRD
EYE
VIEW
OF
A
JAVA
PROGRAM
IN
OUR
MODEL
A
JAVA
PROGRAM
TAKES
INPUT
VALUES
FROM
COMMAND
LINE
ARGUMENTS
OR
FROM
AN
ABSTRACT
STREAM
OF
CHARACTERS
KNOWN
AS
THE
STANDARD
INPUT
STREAM
AND
WRITES
TO
ANOTHER
ABSTRACT
STREAM
OF
CHARACTERS
KNOWN
AS
THE
STANDARD
OUTPUT
STREAM
NECESSARILY
WE
NEED
TO
CONSIDER
THE
INTERFACE
BETWEEN
JAVA
AND
THE
OPERATING
SYSTEM
SO
WE
NEED
TO
BRIEFLY
DIS
CUSS
BASIC
MECHANISMS
THAT
ARE
PROVIDED
BY
MOST
MODERN
OPERATING
SYSTEMS
AND
PROGRAM
DEVELOPMENT
ENVIRON
MENTS
YOU
CAN
FIND
MORE
DETAILS
ABOUT
YOUR
PARTICULAR
SYSTEM
ON
THE
BOOKSITE
BY
DEFAULT
COMMAND
LINE
ARGU
MENTS
STANDARD
INPUT
AND
STANDARD
OUTPUT
ARE
ASSOCIATED
WITH
AN
APPLICATION
SUPPORTED
BY
EITHER
THE
OPERATING
SYSTEM
OR
THE
PROGRAM
DEVELOP
MENT
ENVIRONMENT
THAT
TAKES
COMMANDS
WE
USE
THE
GENERIC
TERM
TERMINAL
WINDOW
TO
REFER
TO
THE
WINDOW
MAINTAINED
BY
THIS
APPLICATION
WHERE
WE
TYPE
AND
READ
TEXT
SINCE
EARLY
UNIX
SYSTEMS
IN
THE
THIS
MODEL
HAS
PROVEN
TO
BE
A
CONVENIENT
AND
DIRECT
WAY
FOR
US
TO
INTERACT
WITH
OUR
PROGRAMS
AND
DATA
WE
ADD
TO
THE
CLASSICAL
MODEL
A
STANDARD
DRAWING
THAT
ALLOWS
US
TO
CREATE
VISUAL
REPRESENTATIONS
FOR
DATA
ANALYSIS
COMMANDS
AND
ARGUMENTS
IN
THE
TERMINAL
WINDOW
WE
SEE
A
PROMPT
WHERE
WE
TYPE
COMMANDS
TO
THE
OPERATING
SYSTEM
THAT
MAY
TAKE
ARGUMENTS
WE
USE
ONLY
A
FEW
COM
MANDS
IN
THIS
BOOK
SHOWN
IN
THE
TABLE
BELOW
MOST
OFTEN
WE
USE
THE
JAVA
COM
MAND
TO
RUN
OUR
PROGRAMS
AS
MENTIONED
ON
PAGE
JAVA
CLASSES
HAVE
A
MAIN
STATIC
METHOD
THAT
TAKES
A
STRING
ARRAY
ARGS
AS
ITS
ARGUMENT
THAT
ARRAY
IS
THE
SEQUENCE
OF
COMMAND
LINE
ARGUMENTS
THAT
WE
TYPE
PROVIDED
TO
JAVA
BY
THE
OPERATING
SYSTEM
BY
CONVENTION
BOTH
JAVA
AND
THE
OPERATING
SYSTEM
PROCESS
THE
ARGUMENTS
AS
STRINGS
IF
JAVA
CLASS
FILE
NAME
NO
EXTENSION
RUN
JAVA
PROGRAM
AND
COMMAND
LINE
ARGUMENTS
WE
INTEND
FOR
AN
ARGUMENT
TO
BE
A
NUMBER
WE
USE
A
METHOD
MORE
ANY
TEXT
FILE
NAME
PRINT
FILE
CONTENTS
TYPICAL
OPERATING
SYSTEM
COMMANDS
SUCH
AS
INTEGER
PARSEINT
TO
CONVERT
IT
FROM
STRING
TO
THE
APPROPRIATE
TYPE
STANDARD
OUTPUT
OUR
STDOUT
LIBRARY
PROVIDES
SUP
PORT
FOR
STANDARD
OUTPUT
BY
DEFAULT
THE
SYSTEM
CON
NECTS
STANDARD
OUTPUT
TO
THE
TERMINAL
WINDOW
THE
PRINT
METHOD
PUTS
ITS
ARGUMENT
ON
STANDARD
OUT
PROMPT
CALL
THE
STATIC
METHOD
MAIN
IN
RANDOMSEQ
JAVA
RANDOMSEQ
ARGS
PUT
THE
PRINTLN
METHOD
ADDS
A
NEWLINE
AND
THE
PRINTF
METHOD
SUPPORTS
FORMATTED
OUTPUT
AS
DE
INVOKE
JAVA
RUNTIME
ARGS
ARGS
SCRIBED
NEXT
JAVA
PROVIDES
A
SIMILAR
METHOD
IN
ITS
SYSTEM
OUT
LIBRARY
WE
USE
STDOUT
TO
TREAT
STANDARD
INPUT
AND
STANDARD
OUTPUT
IN
A
UNIFORM
MANNER
AND
TO
PROVIDE
A
FEW
TECHNICAL
IMPROVEMENTS
PUBLIC
CLASS
STDOUT
STATIC
VOID
PRINT
STRING
PRINT
ANATOMY
OF
A
COMMAND
STATIC
VOID
PRINTLN
STRING
PRINT
FOLLOWED
BY
NEWLINE
STATIC
VOID
PRINTLN
PRINT
A
NEW
LINE
STATIC
VOID
PRINTF
STRING
F
FORMATTED
PRINT
NOTE
OVERLOADED
IMPLEMENTATIONS
ARE
INCLUDED
FOR
PRIMITIVE
TYPES
AND
FOR
OBJECT
API
FOR
OUR
LIBRARY
OF
STATIC
METHODS
FOR
STANDARD
OUTPUT
TO
USE
THESE
METHODS
DOWNLOAD
INTO
YOUR
WORKING
DIRECTORY
STDOUT
JAVA
FROM
THE
BOOKSITE
AND
USE
CODE
SUCH
AS
STDOUT
PRINTLN
HELLO
WORLD
TO
CALL
THEM
A
SAMPLE
CLIENT
IS
SHOWN
AT
RIGHT
FORMATTED
OUTPUT
IN
ITS
SIMPLEST
FORM
PRINTF
TAKES
TWO
ARGUMENTS
THE
FIRST
ARGUMENT
IS
A
FORMAT
STRING
THAT
DESCRIBES
HOW
THE
SECOND
ARGU
MENT
IS
TO
BE
CONVERTED
TO
A
STRING
FOR
OUTPUT
THE
SIMPLEST
TYPE
OF
FORMAT
STRING
BEGINS
WITH
AND
ENDS
WITH
A
ONE
LETTER
CONVERSION
CODE
THE
CONVERSION
CODES
THAT
WE
USE
MOST
FREQUENTLY
ARE
D
FOR
DECIMAL
VALUES
FROM
JAVA
INTEGER
TYPES
F
FOR
FLOATING
POINT
VALUES
AND
FOR
STRING
VALUES
BETWEEN
THE
AND
THE
CONVERSION
CODE
IS
AN
INTEGER
VALUE
THAT
SPECIFIES
THE
FIELD
WIDTH
OF
THE
CONVERTED
VALUE
THE
NUMBER
OF
CHARACTERS
IN
THE
CONVERTED
OUTPUT
STRING
BY
DEFAULT
BLANK
SPACES
ARE
ADDED
ON
THE
LEFT
TO
MAKE
THE
LENGTH
OF
THE
CONVERTED
OUTPUT
EQUAL
TO
THE
FIELD
WIDTH
IF
WE
WANT
THE
SPACES
ON
THE
RIGHT
WE
CAN
INSERT
A
MINUS
SIGN
BEFORE
THE
FIELD
WIDTH
IF
THE
CONVERTED
OUTPUT
STRING
IS
BIGGER
THAN
THE
FIELD
WIDTH
THE
FIELD
WIDTH
IS
IGNORED
FOLLOWING
THE
WIDTH
WE
HAVE
THE
OPTION
OF
INCLUDING
A
PERIOD
FOLLOWED
BY
THE
NUMBER
OF
DIGITS
TO
PUT
AFTER
THE
DECIMAL
POINT
THE
PRECISION
FOR
A
DOUBLE
VALUE
OR
THE
NUMBER
OF
CHARACTERS
TO
TAKE
FROM
THE
BEGINNING
OF
THE
STRING
FOR
A
STRING
VALUE
THE
MOST
IMPORTANT
THING
TO
REMEMBER
ABOUT
USING
PRINTF
IS
THAT
THE
CONVERSION
CODE
IN
THE
FORMAT
AND
THE
TYPE
OF
THE
CORRESPONDING
ARGUMENT
MUST
MATCH
THAT
IS
JAVA
MUST
BE
ABLE
TO
CONVERT
FROM
THE
TYPE
OF
THE
ARGUMENT
TO
THE
TYPE
REQUIRED
BY
THE
CON
VERSION
CODE
THE
FIRST
ARGUMENT
OF
PRINTF
IS
A
STRING
THAT
MAY
CONTAIN
CHARACTERS
OTHER
THAN
A
FORMAT
STRING
ANY
PART
OF
THE
ARGUMENT
THAT
IS
NOT
PART
OF
A
FORMAT
STRING
PASSES
THROUGH
TO
THE
OUTPUT
WITH
THE
FORMAT
STRING
REPLACED
BY
THE
ARGUMENT
VALUE
CONVERTED
TO
A
STRING
AS
SPECIFIED
FOR
EXAMPLE
THE
STATEMENT
STDOUT
PRINTF
PI
IS
APPROXIMATELY
N
MATH
PI
PRINTS
THE
LINE
PI
IS
APPROXIMATELY
NOTE
THAT
WE
NEED
TO
EXPLICITLY
INCLUDE
THE
NEWLINE
CHARACTER
N
IN
THE
ARGUMENT
IN
ORDER
TO
PRINT
A
NEW
LINE
WITH
PRINTF
THE
PRINTF
FUNCTION
CAN
TAKE
MORE
THAN
TWO
ARGUMENTS
IN
THIS
CASE
THE
FORMAT
STRING
WILL
HAVE
A
FORMAT
SPECIFIER
FOR
EACH
AD
DITIONAL
ARGUMENT
PERHAPS
SEPARATED
BY
OTHER
CHARACTERS
TO
PASS
THROUGH
TO
THE
OUT
PUT
YOU
CAN
ALSO
USE
THE
STATIC
METHOD
STRING
FORMAT
WITH
ARGUMENTS
EXACTLY
AS
JUST
DESCRIBED
FOR
PRINTF
TO
GET
A
FORMATTED
STRING
WITHOUT
PRINTING
IT
FORMATTED
PRINTING
IS
A
CONVENIENT
MECHANISM
THAT
ALLOWS
US
TO
DEVELOP
COMPACT
CODE
THAT
CAN
PRODUCE
TABULATED
EXPERIMENTAL
DATA
OUR
PRIMARY
USE
IN
THIS
BOOK
TYPE
CODE
TYPICAL
LITERAL
SAMPLE
FORMAT
STRINGS
CONVERTED
STRING
VALUES
FOR
OUTPUT
INT
D
DOUBLE
F
E
STRING
HELLO
WORLD
HELLO
WORLD
HELLO
WORLD
HELLO
FORMAT
CONVENTIONS
FOR
PRINTF
SEE
THE
BOOKSITE
FOR
MANY
OTHER
OPTIONS
STANDARD
INPUT
OUR
STDIN
LIBRARY
TAKES
DATA
FROM
THE
STANDARD
INPUT
STREAM
THAT
MAY
BE
EMPTY
OR
MAY
CONTAIN
A
SEQUENCE
OF
VALUES
SEPA
RATED
BY
WHITESPACE
SPACES
TABS
NEWLINE
CHARACTERS
AND
THE
LIKE
BY
DEFAULT
THE
SYSTEM
CONNECTS
STAN
DARD
OUTPUT
TO
THE
TERMINAL
WIN
DOW
WHAT
YOU
TYPE
IS
THE
INPUT
STREAM
TERMINATED
BY
CTRL
D
OR
CTRL
Z
DEPENDING
ON
YOUR
TERMI
NAL
WINDOW
APPLICATION
EACH
VALUE
IS
A
STRING
OR
A
VALUE
FROM
ONE
OF
JAVA
PRIMITIVE
TYPES
ONE
OF
THE
KEY
FEATURES
OF
THE
STANDARD
INPUT
STREAM
IS
THAT
YOUR
PROGRAM
CONSUMES
VALUES
WHEN
IT
READS
THEM
ONCE
YOUR
PROGRAM
HAS
READ
A
VALUE
IT
CANNOT
BACK
UP
AND
READ
IT
AGAIN
THIS
ASSUMPTION
IS
RESTRICTIVE
BUT
IT
REFLECTS
PHYSICAL
CHARACTERISTICS
OF
SOME
INPUT
DEVICES
AND
SIMPLIFIES
IMPLEMENTING
THE
ABSTRAC
TION
WITHIN
THE
INPUT
STREAM
MODEL
THE
STATIC
METHODS
IN
THIS
LI
BRARY
ARE
LARGELY
SELF
DOCUMENTING
DESCRIBED
BY
THEIR
SIGNATURES
PUBLIC
CLASS
STDIN
STATIC
BOOLEAN
ISEMPTY
TRUE
IF
NO
MORE
VALUES
FALSE
OTHERWISE
STATIC
INT
READINT
READ
A
VALUE
OF
TYPE
INT
STATIC
DOUBLE
READDOUBLE
READ
A
VALUE
OF
TYPE
DOUBLE
STATIC
FLOAT
READFLOAT
READ
A
VALUE
OF
TYPE
FLOAT
STATIC
LONG
READLONG
READ
A
VALUE
OF
TYPE
LONG
STATIC
BOOLEAN
READBOOLEAN
READ
A
VALUE
OF
TYPE
BOOLEAN
STATIC
CHAR
READCHAR
READ
A
VALUE
OF
TYPE
CHAR
STATIC
BYTE
READBYTE
READ
A
VALUE
OF
TYPE
BYTE
STATIC
STRING
READSTRING
READ
A
VALUE
OF
TYPE
STRING
STATIC
BOOLEAN
HASNEXTLINE
IS
THERE
ANOTHER
LINE
IN
THE
INPUT
STREAM
STATIC
STRING
READLINE
READ
THE
REST
OF
THE
LINE
STATIC
STRING
READALL
READ
THE
REST
OF
THE
INPUT
STREAM
API
FOR
OUR
LIBRARY
OF
STATIC
METHODS
FOR
STANDARD
INPUT
REDIRECTION
AND
PIPING
STANDARD
INPUT
AND
OUTPUT
ENABLE
US
TO
TAKE
ADVANTAGE
OF
COMMAND
LINE
EXTENSIONS
SUPPORTED
BY
MANY
OPERATING
SYSTEMS
BY
ADDING
A
SIMPLE
DIRECTIVE
TO
THE
COMMAND
THAT
INVOKES
A
PROGRAM
WE
CAN
REDIRECT
ITS
STANDARD
OUTPUT
TO
A
FILE
EITHER
FOR
PERMANENT
STORAGE
OR
FOR
INPUT
TO
ANOTHER
PROGRAM
AT
A
LATER
TIME
JAVA
RANDOMSEQ
DATA
TXT
THIS
COMMAND
SPECIFIES
THAT
THE
STANDARD
OUTPUT
STREAM
IS
NOT
TO
BE
PRINTED
IN
THE
TER
MINAL
WINDOW
BUT
INSTEAD
IS
TO
BE
WRITTEN
TO
A
TEXT
FILE
NAMED
DATA
TXT
EACH
CALL
TO
STDOUT
PRINT
ORSTDOUT
PRINTLN
REDIRECTING
FROM
A
FILE
TO
STANDARD
INPUT
JAVA
AVERAGE
DATA
TXT
DATA
TXT
REDIRECTING
STANDARD
OUTPUT
TO
A
FILE
JAVA
RANDOMSEQ
DATA
TXT
DATA
TXT
PIPING
THE
OUTPUT
OF
ONE
PROGRAM
TO
THE
INPUT
OF
ANOTHER
JAVA
RANDOMSEQ
JAVA
AVERAGE
REDIRECTION
AND
PIPING
FROM
THE
COMMAND
LINE
APPENDS
TEXT
AT
THE
END
OF
THAT
FILE
IN
THIS
EXAMPLE
THE
END
RESULT
IS
A
FILE
THAT
CONTAINS
RANDOM
VALUES
NO
OUT
PUT
APPEARS
IN
THE
TERMINAL
WINDOW
IT
GOES
DIRECTLY
INTO
THE
FILE
NAMED
AFTER
THE
SYMBOL
THUS
WE
CAN
SAVE
AWAY
INFORMATION
FOR
LATER
RETRIEVAL
NOT
THAT
WE
DO
NOT
HAVE
TO
CHANGE
RANDOMSEQ
IN
ANY
WAY
IT
IS
USING
THE
STANDARD
OUT
PUT
ABSTRACTION
AND
IS
UNAFFECTED
BY
OUR
USE
OF
A
DIFFERENT
IMPLEMENTATION
OF
THAT
ABSTRACTION
SIMILARLY
WE
CAN
REDI
RECT
STANDARD
INPUT
SO
THAT
STDIN
READS
DATA
FROM
A
FILE
INSTEAD
OF
THE
TERMINAL
APPLICATION
JAVA
AVERAGE
DATA
TXT
THIS
COMMAND
READS
A
SEQUENCE
OF
NUMBERS
FROM
THE
FILE
DATA
TXT
AND
COMPUTES
THEIR
AVERAGE
VALUE
SPECIFI
CALLY
THE
SYMBOL
IS
A
DIRECTIVE
THAT
TELLS
THE
OPERATING
SYSTEM
TO
IMPLEMENT
THE
STANDARD
INPUT
STREAM
BY
READING
FROM
THE
TEXT
FILE
DATA
TXT
INSTEAD
OF
WAITING
FOR
THE
USER
TO
TYPE
SOMETHING
INTO
THE
TERMINAL
WINDOW
WHEN
THE
PROGRAM
CALLS
STDIN
READDOUBLE
THE
OPERATING
SYSTEM
READS
THE
VALUE
FROM
THE
FILE
COMBINING
THESE
TO
REDIRECT
THE
OUTPUT
OF
ONE
PROGRAM
TO
THE
INPUT
OF
ANOTHER
IS
KNOWN
AS
PIPING
JAVA
RANDOMSEQ
JAVA
AVERAGE
THIS
COMMAND
SPECIFIES
THAT
STANDARD
OUTPUT
FOR
RANDOMSEQ
AND
STANDARD
INPUT
FOR
AVERAGE
ARE
THE
SAME
STREAM
THE
EFFECT
IS
AS
IF
RANDOMSEQ
WERE
TYPING
THE
NUMBERS
IT
GENERATES
INTO
THE
TERMINAL
WINDOW
WHILE
AVERAGE
IS
RUNNING
THIS
DIFFERENCE
IS
PRO
FOUND
BECAUSE
IT
REMOVES
THE
LIMITATION
ON
THE
SIZE
OF
THE
INPUT
AND
OUTPUT
STREAMS
THAT
WE
CAN
PROCESS
FOR
EXAMPLE
WE
COULD
REPLACE
IN
OUR
EXAMPLE
WITH
EVEN
THOUGH
WE
MIGHT
NOT
HAVE
THE
SPACE
TO
SAVE
A
BILLION
NUMBERS
ON
OUR
COMPUTER
WE
DO
NEED
THE
TIME
TO
PROCESS
THEM
WHEN
RANDOMSEQ
CALLS
STDOUT
PRINTLN
A
STRING
IS
ADDED
TO
THE
END
OF
THE
STREAM
WHEN
AVERAGE
CALLS
STDIN
READINT
A
STRING
IS
REMOVED
FROM
THE
BEGINNING
OF
THE
STREAM
THE
TIMING
OF
PRECISELY
WHAT
HAPPENS
IS
UP
TO
THE
OPERATING
SYSTEM
IT
MIGHT
RUN
RANDOMSEQ
UNTIL
IT
PRODUCES
SOME
OUTPUT
AND
THEN
RUN
AVERAGE
TO
CONSUME
THAT
OUTPUT
OR
IT
MIGHT
RUN
AVERAGE
UNTIL
IT
NEEDS
SOME
OUTPUT
AND
THEN
RUN
RANDOMSEQ
UNTIL
IT
PRODUCES
THE
NEEDED
OUTPUT
THE
END
RESULT
IS
THE
SAME
BUT
OUR
PROGRAMS
ARE
FREED
FROM
WORRYING
ABOUT
SUCH
DETAILS
BECAUSE
THEY
WORK
SOLELY
WITH
THE
STANDARD
INPUT
AND
STANDARD
OUTPUT
ABSTRACTIONS
INPUT
AND
OUTPUT
FROM
A
FILE
OUR
IN
AND
OUT
LIBRARIES
PROVIDE
STATIC
METHODS
THAT
IMPLEMENT
THE
ABSTRACTION
OF
READING
FROM
AND
WRITING
TO
A
FILE
THE
CONTENTS
OF
AN
AR
RAY
OF
VALUES
OF
A
PRIMITIVE
TYPE
OR
STRING
WE
USE
READINTS
READDOUBLES
AND
READSTRINGS
IN
THE
IN
LIBRARY
AND
WRITEINTS
WRITEDOUBLES
AND
WRITESTRINGS
IN
THE
OUT
LIBRARY
THE
NAMED
ARGUMENT
CAN
BE
A
FILE
OR
A
WEB
PAGE
FOR
EXAMPLE
THIS
ABILITY
ALLOWS
US
TO
USE
A
FILE
AND
STANDARD
INPUT
FOR
TWO
DIFFERENT
PUR
POSES
IN
THE
SAME
PROGRAM
AS
IN
BINARYSEARCH
THE
IN
AND
OUT
LIBRARIES
ALSO
IMPLE
MENT
DATA
TYPES
WITH
INSTANCE
METHODS
THAT
ALLOW
US
THE
MORE
GENERAL
ABILITY
TO
TREAT
MULTIPLE
FILES
AS
INPUT
AND
OUTPUT
STREAMS
AND
WEB
PAGES
AS
INPUT
STREAMS
SO
WE
WILL
REVISIT
THEM
IN
SECTION
PUBLIC
CLASS
IN
STATIC
INT
READINTS
STRING
NAME
READ
INT
VALUES
STATIC
DOUBLE
READDOUBLES
STRING
NAME
READ
DOUBLE
VALUES
STATIC
STRING
READSTRINGS
STRING
NAME
READ
STRING
VALUES
PUBLIC
CLASS
OUT
STATIC
VOID
WRITE
INT
A
STRING
NAME
WRITE
INT
VALUES
STATIC
VOID
WRITE
DOUBLE
A
STRING
NAME
WRITE
DOUBLE
VALUES
STATIC
VOID
WRITE
STRING
A
STRING
NAME
WRITE
STRING
VALUES
NOTE
OTHER
PRIMITIVE
TYPES
ARE
SUPPORTED
NOTE
STDIN
AND
STDOUT
ARE
SUPPORTED
OMIT
NAME
ARGUMENT
APIS
FOR
OUR
STATIC
METHODS
FOR
READING
AND
WRITING
ARRAYS
STANDARD
DRAWING
BASIC
METHODS
UP
TO
THIS
POINT
OUR
INPUT
OUTPUT
ABSTRACTIONS
HAVE
FOCUSED
EXCLUSIVELY
ON
TEXT
STRINGS
NOW
WE
INTRODUCE
AN
ABSTRACTION
FOR
PRODUCING
DRAWINGS
AS
OUTPUT
THIS
LIBRARY
IS
EASY
TO
USE
AND
ALLOWS
US
TO
TAKE
ADVANTAGE
OF
A
VISUAL
MEDI
UM
TO
COPE
WITH
FAR
MORE
INFORMATION
THAN
IS
POSSIBLE
WITH
JUST
TEXT
AS
WITH
STANDARD
INPUT
OUTPUT
OUR
STAN
DARD
DRAWING
ABSTRACTION
IS
IMPLEMENTED
IN
A
LIBRARY
STDDRAW
THAT
YOU
CAN
ACCESS
BY
DOWNLOADING
THE
FILE
STDDRAW
JAVA
FROM
THE
BOOKSITE
INTO
YOUR
WORKING
DIRECTORY
STANDARD
DRAW
IS
VERY
SIMPLE
WE
IMAGINE
AN
ABSTRACT
DRAWING
DEVICE
CAPABLE
OF
DRAWING
LINES
AND
POINTS
ON
A
TWO
DIMENSIONAL
CANVAS
THE
DEVICE
IS
CA
PABLE
OF
RESPONDING
TO
THE
COMMANDS
TO
DRAW
BASIC
GEOMETRIC
SHAPES
THAT
OUR
PROGRAMS
ISSUE
IN
THE
FORM
OF
CALLS
TO
STATIC
METHODS
IN
STDDRAW
INCLUDING
METH
ODS
FOR
DRAWING
LINES
POINTS
TEXT
STRINGS
CIRCLES
RECT
ANGLES
AND
POLYGONS
LIKE
THE
METHODS
FOR
STANDARD
INPUT
AND
STANDARD
OUTPUT
THESE
METHODS
ARE
NEARLY
SELF
DOCUMENTING
STDDRAW
LINE
DRAWS
A
STRAIGHT
STDDRAW
POINT
STDDRAW
LINE
STDDRAW
CIRCLE
X
Y
R
STDDRAW
SQUARE
X
Y
R
LINE
SEGMENT
CONNECTING
THE
POINT
X
Y
WITH
THE
POINT
WHOSE
COORDINATES
ARE
GIVEN
AS
ARGUMENTS
STDDRAW
POINT
DRAWS
A
SPOT
CENTERED
ON
THE
POINT
X
Y
WHOSE
COORDINATES
ARE
GIVEN
AS
ARGUMENTS
AND
SO
FORTH
AS
ILLUSTRATED
IN
THE
DIAGRAMS
AT
RIGHT
GEOMETRIC
SHAPES
CAN
BE
FILLED
IN
BLACK
BY
DEFAULT
THE
DEFAULT
SCALE
IS
THE
UNIT
SQUARE
ALL
COORDINATES
ARE
BETWEEN
AND
THE
STANDARD
IMPLEMENTATION
DISPLAYS
THE
CAN
VAS
IN
A
WINDOW
ON
YOUR
COMPUTER
SCREEN
WITH
BLACK
LINES
AND
POINTS
ON
A
WHITE
BACKGROUND
DOUBLE
X
DOUBLE
Y
STDDRAW
POLYGON
X
Y
STDDRAW
EXAMPLES
PUBLIC
CLASS
STDDRAW
STATIC
VOID
LINE
DOUBLE
DOUBLE
DOUBLE
DOUBLE
STATIC
VOID
POINT
DOUBLE
X
DOUBLE
Y
STATIC
VOID
TEXT
DOUBLE
X
DOUBLE
Y
STRING
STATIC
VOID
CIRCLE
DOUBLE
X
DOUBLE
Y
DOUBLE
R
STATIC
VOID
FILLEDCIRCLE
DOUBLE
X
DOUBLE
Y
DOUBLE
R
STATIC
VOID
ELLIPSE
DOUBLE
X
DOUBLE
Y
DOUBLE
RW
DOUBLE
RH
STATIC
VOID
FILLEDELLIPSE
DOUBLE
X
DOUBLE
Y
DOUBLE
RW
DOUBLE
RH
STATIC
VOID
SQUARE
DOUBLE
X
DOUBLE
Y
DOUBLE
R
STATIC
VOID
FILLEDSQUARE
DOUBLE
X
DOUBLE
Y
DOUBLE
R
STATIC
VOID
RECTANGLE
DOUBLE
X
DOUBLE
Y
DOUBLE
RW
DOUBLE
RH
STATIC
VOID
FILLEDRECTANGLE
DOUBLE
X
DOUBLE
Y
DOUBLE
RW
DOUBLE
RH
STATIC
VOID
POLYGON
DOUBLE
X
DOUBLE
Y
STATIC
VOID
FILLEDPOLYGON
DOUBLE
X
DOUBLE
Y
API
FOR
OUR
LIBRARY
OF
STATIC
METHODS
FOR
STANDARD
DRAWING
DRAWING
METHODS
STANDARD
DRAWING
CONTROL
METHODS
THE
LIBRARY
ALSO
INCLUDES
METHODS
TO
CHANGE
THE
SCALE
AND
SIZE
OF
THE
CANVAS
THE
COLOR
AND
WIDTH
OF
THE
LINES
THE
TEXT
FONT
AND
THE
TIMING
OF
DRAWING
FOR
USE
IN
ANIMATION
AS
ARGUMENTS
FOR
SETPENCOLOR
YOU
CAN
USE
ONE
OF
THE
PREDEFINED
COLORS
BLACK
BLUE
CYAN
GRAY
GREEN
MAGENTA
ORANGE
PINK
RED
WHITE
AND
YELLOW
THAT
ARE
DE
FINED
AS
CONSTANTS
IN
STDDRAW
SO
WE
REFER
TO
ONE
OF
THEM
WITH
CODE
LIKE
STDDRAW
RED
THE
WINDOW
ALSO
INCLUDES
A
MENU
OPTION
TO
SAVE
YOUR
DRAWING
TO
A
FILE
IN
A
FORMAT
SUITABLE
FOR
PUBLISHING
ON
THE
WEB
PUBLIC
CLASS
STDDRAW
STATIC
VOID
SETXSCALE
DOUBLE
DOUBLE
RESET
X
RANGE
TO
STATIC
VOID
SETYSCALE
DOUBLE
DOUBLE
RESET
Y
RANGE
TO
STATIC
VOID
SETPENRADIUS
DOUBLE
R
SET
PEN
RADIUS
TO
R
STATIC
VOID
SETPENCOLOR
COLOR
C
SET
PEN
COLOR
TO
C
STATIC
VOID
SETFONT
FONT
F
SET
TEXT
FONT
TO
F
STATIC
VOID
SETCANVASSIZE
INT
W
INT
H
SET
CANVAS
TO
W
BY
H
WINDOW
STATIC
VOID
CLEAR
COLOR
C
CLEAR
THE
CANVAS
COLOR
IT
C
STATIC
VOID
SHOW
INT
DT
SHOW
ALL
PAUSE
DT
MILLISECONDS
API
FOR
OUR
LIBRARY
OF
STATIC
METHODS
FOR
STANDARD
DRAWING
CONTROL
METHODS
IN
THIS
BOOK
WE
USE
STDDRAW
FOR
DATA
ANALYSIS
AND
FOR
CREATING
VISUAL
REPRESENTATIONS
OF
ALGORITHMS
IN
OPERATION
THE
TABLE
AT
ON
THE
OPPOSITE
PAGE
INDICATES
SOME
POSSIBLI
TIES
WE
WILL
CONSIDER
MANY
MORE
EXAMPLES
IN
THE
TEXT
AND
THE
EXERCISES
THROUGHOUT
THE
BOOK
THE
LIBRARY
ALSO
SUPPORTS
ANIMATION
OF
COURSE
THIS
TOPIC
IS
TREATED
PRIMARILY
ON
THE
BOOKSITE
DATA
PLOT
IMPLEMENTATION
CODE
FRAGMENT
RESULT
FUNCTION
VALUES
INT
N
STDDRAW
SETXSCALE
N
STDDRAW
SETYSCALE
N
N
STDDRAW
SETPENRADIUS
FOR
INT
I
I
N
I
STDDRAW
POINT
I
I
STDDRAW
POINT
I
I
I
STDDRAW
POINT
I
I
MATH
LOG
I
ARRAY
OF
RANDOM
VALUES
INT
N
DOUBLE
A
NEW
DOUBLE
N
FOR
INT
I
I
N
I
A
I
STDRANDOM
RANDOM
FOR
INT
I
I
N
I
DOUBLE
X
I
N
DOUBLE
Y
A
I
DOUBLE
RW
N
DOUBLE
RH
A
I
STDDRAW
FILLEDRECTANGLE
X
Y
RW
RH
SORTED
ARRAY
OF
RANDOM
VALUES
INT
N
DOUBLE
A
NEW
DOUBLE
N
FOR
INT
I
I
N
I
A
I
STDRANDOM
RANDOM
ARRAYS
SORT
A
FOR
INT
I
I
N
I
DOUBLE
X
I
N
DOUBLE
Y
A
I
DOUBLE
RW
N
DOUBLE
RH
A
I
STDDRAW
FILLEDRECTANGLE
X
Y
RW
RH
STDDRAW
PLOTTING
EXAMPLES
BINARY
SEARCH
THE
SAMPLE
JAVA
PROGRAM
THAT
WE
STARTED
WITH
SHOWN
ON
THE
FACING
PAGE
IS
BASED
ON
THE
FAMOUS
EFFECTIVE
AND
WIDELY
USED
BINARY
SEARCH
ALGORITHM
THIS
EXAMPLE
IS
A
PROTOTYPE
OF
THE
WAY
IN
WHICH
WE
WILL
EXAMINE
NEW
ALGORITHMS
THROUGHOUT
THE
BOOK
AS
WITH
ALL
OF
THE
PROGRAMS
WE
CONSIDER
IT
IS
BOTH
A
PRECISE
DEFINITION
OF
THE
METHOD
AND
A
COMPLETE
JAVA
IMPLEMENTATION
THAT
YOU
CAN
DOWNLOAD
FROM
THE
BOOKSITE
BINARY
SEARCH
WE
WILL
STUDY
THE
BINARY
SEARCH
ALGORITHM
IN
DETAIL
IN
SECTION
BUT
A
BRIEF
DESCRIPTION
IS
APPROPRIATE
HERE
THE
ALGORITHM
IS
IMPLEMENTED
IN
THE
STATIC
SUCCESSFUL
SEARCH
FOR
LO
MID
HI
LO
MID
HI
LO
MID
HI
UNSUCCESSFUL
SEARCH
FOR
LO
MID
HI
LO
MID
HI
LO
MID
HI
LO
MID
HI
METHOD
RANK
WHICH
TAKES
AN
INTEGER
KEY
AND
A
SORTED
ARRAY
OF
INT
VALUES
AS
ARGUMENTS
AND
RE
TURNS
THE
INDEX
OF
THE
KEY
IF
IT
IS
PRESENT
IN
THE
ARRAY
OTHERWISE
IT
ACCOMPLISHES
THIS
TASK
BY
MAINTAINING
VARIABLES
LO
AND
HI
SUCH
THAT
THE
KEY
IS
IN
A
LO
HI
IF
IT
IS
IN
THE
ARRAY
THEN
ENTERING
INTO
A
LOOP
THAT
TESTS
THE
MIDDLE
ENTRY
IN
THE
IN
TERVAL
AT
INDEX
MID
IF
THE
KEY
IS
EQUAL
TO
A
MID
THE
RETURN
VALUE
IS
MID
OTHERWISE
THE
METHOD
CUTS
THE
INTERVAL
SIZE
ABOUT
IN
HALF
LOOKING
AT
THE
LEFT
HALF
IF
THE
KEY
IS
LESS
THAN
A
MID
AND
AT
THE
RIGHT
HALF
IF
THE
KEY
IS
GREATER
THAN
A
MID
THE
PROCESS
TERMINATES
WHEN
THE
KEY
IS
FOUND
OR
THE
INTERVAL
IS
EMPTY
BINARY
SEARCH
IS
EFFECTIVE
BECAUSE
IT
NEEDS
TO
EXAMINE
JUST
A
FEW
AR
HI
LO
BINARY
SEARCH
IN
AN
ORDERED
ARRAY
RAY
ENTRIES
RELATIVE
TO
THE
SIZE
OF
THE
ARRAY
TO
FIND
THE
KEY
OR
DETERMINE
THAT
IT
IS
NOT
THERE
TINYW
TXT
TINYT
TXT
DEVELOPMENT
CLIENT
FOR
EVERY
ALGORITHM
IMPLEMENTATION
WE
INCLUDE
A
DEVELOPMENT
CLIENT
MAIN
THAT
YOU
CAN
USE
WITH
SAMPLE
INPUT
FILES
PROVIDED
IN
THE
BOOK
AND
ON
THE
BOOKSITE
TO
LEARN
ABOUT
THE
ALGORITHM
AND
TO
TEST
ITS
PERFORMANCE
IN
THIS
EXAMPLE
THE
CLIENT
READS
INTEGERS
FROM
THE
FILE
NAMED
ON
THE
COMMAND
LINE
THEN
PRINTS
ANY
INTEGERS
ON
STANDARD
INPUT
THAT
DO
NOT
APPEAR
IN
THE
FILE
WE
USE
SMALL
TEST
FILES
SUCH
AS
THOSE
SHOWN
AT
RIGHT
TO
DEMONSTRATE
THIS
BEHAVIOR
AND
AS
THE
NOT
IN
BASIS
FOR
TRACES
AND
EXAMPLES
SUCH
AS
THOSE
AT
LEFT
ABOVE
WE
USE
LARGE
TEST
FILES
TO
MODEL
REAL
WORLD
APPLICATIONS
AND
TO
TEST
PERFORMANCE
SEE
PAGE
SMALL
TEST
FILES
FOR
BINARYSEARCH
TEST
CLIENT
BINARY
SEARCH
IMPORT
JAVA
UTIL
ARRAYS
PUBLIC
CLASS
BINARYSEARCH
PUBLIC
STATIC
INT
RANK
INT
KEY
INT
A
ARRAY
MUST
BE
SORTED
INT
LO
INT
HI
A
LENGTH
WHILE
LO
HI
KEY
IS
IN
A
LO
HI
OR
NOT
PRESENT
INT
MID
LO
HI
LO
IF
KEY
A
MID
HI
MID
ELSE
IF
KEY
A
MID
LO
MID
ELSE
RETURN
MID
RETURN
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
WHITELIST
IN
READINTS
ARGS
ARRAYS
SORT
WHITELIST
WHILE
STDIN
ISEMPTY
READ
KEY
PRINT
IF
NOT
IN
WHITELIST
INT
KEY
STDIN
READINT
IF
RANK
KEY
WHITELIST
STDOUT
PRINTLN
KEY
THIS
PROGRAM
TAKES
THE
NAME
OF
A
WHITELIST
FILE
A
SEQUENCE
OF
INTEGERS
AS
ARGUMENT
AND
FILTERS
ANY
ENTRY
THAT
IS
ON
THE
WHITELIST
FROM
STANDARD
INPUT
LEAVING
ONLY
INTEGERS
THAT
ARE
NOT
ON
THE
WHITELIST
ON
STANDARD
OUTPUT
IT
USES
THE
BINARY
SEARCH
ALGORITHM
IMPLEMENTED
IN
THE
STATIC
METHOD
RANK
TO
ACCOMPLISH
THE
TASK
EFFICIENTLY
SEE
SEC
TION
FOR
A
FULL
DISCUSSION
OF
THE
BINARY
SEARCH
ALGORITHM
ITS
CORRECTNESS
ITS
PER
FORMANCE
ANALYSIS
AND
ITS
APPLICATIONS
WHITELISTING
WHEN
POSSIBLE
OUR
DEVELOPMENT
CLIENTS
ARE
INTENDED
TO
MIRROR
PRACTICAL
SITUATIONS
AND
DEMONSTRATE
THE
NEED
FOR
THE
ALGORITHM
AT
HAND
IN
THIS
CASE
THE
PROCESS
IS
KNOWN
AS
WHITELISTING
SPECIFICALLY
IMAGINE
A
CREDIT
CARD
COMPANY
THAT
NEEDS
TO
CHECK
WHETHER
CUSTOMER
TRANSACTIONS
ARE
FOR
A
VALID
ACCOUNT
TO
DO
SO
IT
CAN
KEEP
CUSTOMERS
ACCOUNT
NUMBERS
IN
A
FILE
WHICH
WE
REFER
TO
AS
A
WHITELIST
PRODUCE
THE
ACCOUNT
NUMBER
ASSOCIATED
WITH
EACH
TRANSACTION
IN
THE
STANDARD
INPUT
STREAM
USE
THE
TEST
CLIENT
TO
PUT
ONTO
STANDARD
OUTPUT
THE
NUMBERS
THAT
ARE
NOT
ASSOCIAT
ED
WITH
ANY
CUSTOMER
PRESUMABLY
THE
COMPANY
WOULD
REFUSE
SUCH
TRANSACTIONS
IT
WOULD
NOT
BE
UNUSUAL
FOR
A
BIG
COMPANY
WITH
MILLIONS
OF
CUSTOMERS
TO
HAVE
TO
PRO
CESS
MILLIONS
OF
TRANSACTIONS
OR
MORE
TO
MODEL
THIS
SITUATION
WE
PROVIDE
ON
THE
BOOK
SITE
THE
FILES
LARGEW
TXT
MILLION
INTEGERS
AND
LARGET
TXT
MILLION
INTEGERS
PERFORMANCE
A
WORKING
PROGRAM
IS
OFTEN
NOT
SUFFICIENT
FOR
EXAMPLE
A
MUCH
SIMPLER
IMPLEMENTATION
OF
RANK
WHICH
DOES
NOT
EVEN
REQUIRE
THE
ARRAY
TO
BE
SORTED
IS
TO
CHECK
EVERY
ENTRY
AS
FOLLOWS
PUBLIC
STATIC
INT
RANK
INT
KEY
INT
A
FOR
INT
I
I
A
LENGTH
I
IF
A
I
KEY
RETURN
I
RETURN
GIVEN
THIS
SIMPLE
AND
EASY
TO
UNDERSTAND
SOLUTION
WHY
DO
WE
USE
MERGESORT
AND
BI
NARY
SEARCH
IF
YOU
WORK
EXERCISE
YOU
WILL
SEE
THAT
YOUR
COMPUTER
IS
TOO
SLOW
TO
RUN
THIS
BRUTE
FORCE
IMPLEMENTATION
OF
RANK
FOR
LARGE
NUMBERS
OF
INPUTS
SAY
MILLION
WHITELIST
ENTRIES
AND
MILLION
TRANSACTIONS
SOLVING
THE
WHITELIST
PROBLEM
FOR
A
LARGE
NUMBER
OF
INPUTS
IS
NOT
FEASIBLE
WITHOUT
EFFICIENT
ALGORITHMS
SUCH
AS
BINARY
SEARCH
AND
MERGESORT
GOOD
PERFORMANCE
IS
OFTEN
OF
CRITICAL
IMPORTANCE
SO
WE
LAY
THE
GROUND
WORK
FOR
STUDYING
PERFORMANCE
IN
SECTION
AND
ANALYZE
THE
PERFORMANCE
CHARACTER
ISTICS
OF
ALL
OF
OUR
ALGORITHMS
INCLUDING
BINARY
SEARCH
IN
SECTION
AND
MERGESORT
IN
SECTION
IN
THE
PRESENT
CONTEXT
OUR
GOAL
IN
THOROUGHLY
OUTLINING
OUR
PROGRAMMING
MODEL
IS
TO
ENSURE
THAT
YOU
CAN
RUN
CODE
LIKE
BINARYSEARCH
ON
YOUR
COMPUTER
USE
IT
ON
TEST
DATA
LIKE
OURS
AND
MODIFY
IT
TO
ADAPT
TO
VARIOUS
SITUATIONS
SUCH
AS
THOSE
DESCRIBED
IN
THE
EXERCISES
AT
THE
END
OF
THIS
SECTION
IN
ORDER
TO
BEST
UNDERSTAND
ITS
APPLICABILITY
THE
PROGRAMMING
MODEL
THAT
WE
HAVE
SKETCHED
IS
DESIGNED
TO
FACILITATE
SUCH
ACTIVITIES
WHICH
ARE
CRUCIAL
TO
OUR
APPROACH
TO
STUDYING
ALGORITHMS
LARGEW
TXT
LARGET
TXT
295754
NOT
IN
LARGEW
TXT
INT
VALUES
INT
VALUES
INT
VALUES
LARGE
FILES
FOR
BINARYSEARCH
TEST
CLIENT
PERSPECTIVE
IN
THIS
SECTION
WE
HAVE
DESCRIBED
A
FINE
AND
COMPLETE
PROGRAMMING
MODEL
THAT
SERVED
AND
STILL
SERVES
MANY
PROGRAMMERS
FOR
MANY
DECADES
MODERN
PROGRAMMING
HOWEVER
GOES
ONE
STEP
FURTHER
THIS
NEXT
LEVEL
IS
CALLED
DATA
ABSTRACTION
SOMETIMES
KNOWN
AS
OBJECT
ORIENTED
PROGRAMMING
AND
IS
THE
SUBJECT
OF
THE
NEXT
SEC
TION
SIMPLY
PUT
THE
IDEA
BEHIND
DATA
ABSTRACTION
IS
TO
ALLOW
A
PROGRAM
TO
DEFINE
DATA
TYPES
SETS
OF
VALUES
AND
SETS
OF
OPERATIONS
ON
THOSE
VALUES
NOT
JUST
STATIC
METHODS
THAT
OPERATE
ON
PREDEFINED
DATA
TYPES
OBJECT
ORIENTED
PROGRAMMING
HAS
COME
INTO
WIDESPREAD
USE
IN
RECENT
DECADES
AND
DATA
ABSTRACTION
IS
CENTRAL
TO
MODERN
PROGRAM
DEVELOPMENT
WE
EMBRACE
DATA
ABSTRAC
TION
IN
THIS
BOOK
FOR
THREE
PRIMARY
REASONS
IT
ENABLES
US
TO
EXPAND
OUR
ABILITY
TO
REUSE
CODE
THROUGH
MODULAR
PROGRAMMING
FOR
EXAMPLE
OUR
SORTS
IN
CHAPTER
AND
BINARY
SEARCH
AND
OTHER
ALGORITHMS
IN
CHAPTER
ALLOW
CLIENTS
TO
MAKE
USE
OF
THE
SAME
CODE
FOR
ANY
TYPE
OF
DATA
NOT
JUST
INTEGERS
INCLUDING
ONE
DEFINED
BY
THE
CLIENT
IT
PROVIDES
A
CONVENIENT
MECHANISM
FOR
BUILDING
SO
CALLED
LINKED
DATA
STRUCTURES
THAT
PROVIDE
MORE
FLEXIBILITY
THAN
ARRAYS
AND
ARE
THE
BASIS
OF
EFFICIENT
ALGORITHMS
IN
MANY
SETTINGS
IT
ENABLES
US
TO
PRECISELY
DEFINE
THE
ALGORITHMIC
CHALLENGES
THAT
WE
FACE
FOR
EX
AMPLE
OUR
UNION
FIND
ALGORITHMS
IN
SECTION
OUR
PRIORITY
QUEUE
ALGORITHMS
IN
SECTION
AND
OUR
SYMBOL
TABLE
ALGORITHMS
IN
CHAPTER
ARE
ALL
ORIENTED
TOWARD
DEFINING
DATA
STRUCTURES
THAT
ENABLE
EFFICIENT
IMPLEMENTATIONS
OF
A
SET
OF
OPERATIONS
THIS
CHALLENGE
ALIGNS
PERFECTLY
WITH
DATA
ABSTRACTION
DESPITE
ALL
OF
THESE
CONSIDERATIONS
OUR
FOCUS
REMAINS
ON
THE
STUDY
OF
ALGORITHMS
IN
THIS
CONTEXT
WE
PROCEED
TO
CONSIDER
NEXT
THE
ESSENTIAL
FEATURES
OF
OBJECT
ORIENTED
PRO
GRAMMING
THAT
ARE
RELEVANT
TO
OUR
MISSION
Q
WHAT
IS
JAVA
BYTECODE
A
A
LOW
LEVEL
VERSION
OF
YOUR
PROGRAM
THAT
RUNS
ON
THE
JAVA
VIRTUAL
MACHINE
THIS
LEVEL
OF
ABSTRACTION
MAKES
IT
EASIER
FOR
THE
DEVELOPERS
OF
JAVA
TO
ENSURE
THAT
OUR
PROGRAMS
RUN
ON
A
BROAD
VARIETY
OF
DEVICES
Q
IT
SEEMS
WRONG
THAT
JAVA
SHOULD
JUST
LET
INTS
OVERFLOW
AND
GIVE
BAD
VALUES
SHOULDN
T
JAVA
AUTOMATICALLY
CHECK
FOR
OVERFLOW
A
THIS
ISSUE
IS
A
CONTENTIOUS
ONE
AMONG
PROGRAMMERS
THE
SHORT
ANSWER
IS
THAT
THE
LACK
OF
SUCH
CHECKING
IS
ONE
REASON
SUCH
TYPES
ARE
CALLED
PRIMITIVE
DATA
TYPES
A
LITTLE
KNOWLEDGE
CAN
GO
A
LONG
WAY
IN
AVOIDING
SUCH
PROBLEMS
WE
USE
THE
INT
TYPE
FOR
SMALL
NUMBERS
LESS
THAN
TEN
DECIMAL
DIGITS
AND
THE
LONG
TYPE
WHEN
VALUES
RUN
INTO
THE
BIL
LIONS
OR
MORE
Q
WHAT
IS
THE
VALUE
OF
MATH
ABS
A
THIS
STRANGE
BUT
TRUE
RESULT
IS
A
TYPICAL
EXAMPLE
OF
THE
EFFECTS
OF
INTEGER
OVERFLOW
Q
HOW
CAN
I
INITIALIZE
A
DOUBLE
VARIABLE
TO
INFINITY
A
JAVA
HAS
BUILT
IN
CONSTANTS
AVAILABLE
FOR
THIS
PURPOSE
DOUBLE
AND
DOUBLE
Q
CAN
YOU
COMPARE
A
DOUBLE
TO
AN
INT
A
NOT
WITHOUT
DOING
A
TYPE
CONVERSION
BUT
REMEMBER
THAT
JAVA
USUALLY
DOES
THE
REQ
UISITE
TYPE
CONVERSION
AUTOMATICALLY
FOR
EXAMPLE
IF
X
IS
AN
INT
WITH
THE
VALUE
THEN
THE
EXPRESSION
X
IS
TRUE
JAVA
CONVERTS
X
TO
DOUBLE
BECAUSE
IS
A
DOUBLE
LITERAL
BEFORE
PERFORMING
THE
COMPARISON
Q
WHAT
HAPPENS
IF
I
USE
A
VARIABLE
BEFORE
INITIALIZING
IT
TO
A
VALUE
A
JAVA
WILL
REPORT
A
COMPILE
TIME
ERROR
IF
THERE
IS
ANY
PATH
THROUGH
YOUR
CODE
THAT
WOULD
LEAD
TO
USE
OF
AN
UNINITIALIZED
VARIABLE
Q
WHAT
ARE
THE
VALUES
OF
AND
AS
JAVA
EXPRESSIONS
A
THE
FIRST
GENERATES
A
RUNTIME
EXCEPTION
FOR
DIVISION
BY
ZERO
WHICH
STOPS
YOUR
PRO
GRAM
BECAUSE
THE
VALUE
IS
UNDEFINED
THE
SECOND
HAS
THE
VALUE
INFINITY
Q
A
CONTINUED
Q
CAN
YOU
USE
AND
TO
COMPARE
STRING
VARIABLES
A
NO
THOSE
OPERATORS
ARE
DEFINED
ONLY
FOR
PRIMITIVE
TYPES
SEE
PAGE
Q
WHAT
IS
THE
RESULT
OF
DIVISION
AND
REMAINDER
FOR
NEGATIVE
INTEGERS
A
THE
QUOTIENT
A
B
ROUNDS
TOWARD
THE
REMAINDER
A
B
IS
DEFINED
SUCH
THAT
A
B
B
A
B
IS
ALWAYS
EQUAL
TO
A
FOR
EXAMPLE
AND
ARE
BOTH
BUT
IS
AND
IS
Q
WHY
DO
WE
SAY
A
B
AND
NOT
A
B
A
THE
OPERATORS
AND
ARE
BITWISE
LOGICAL
OPERATIONS
FOR
INTEGER
TYPES
THAT
DO
AND
OR
AND
EXCLUSIVE
OR
RESPECTIVELY
ON
EACH
BIT
POSITION
THUS
THE
VALUE
OF
IS
AND
THE
VALUE
OF
IS
WE
USE
THESE
OPERATORS
RARELY
BUT
OCCASIONALLY
IN
THIS
BOOK
THE
OPERATORS
AND
ARE
VALID
ONLY
IN
BOOLEAN
EXPRESSIONS
ARE
INCLUDED
SEPARATELY
BECAUSE
OF
SHORT
CIRCUITING
AN
EXPRESSION
IS
EVALUATED
LEFT
TO
RIGHT
AND
THE
EVALUATION
STOPS
WHEN
THE
VALUE
IS
KNOWN
Q
IS
AMBIGUITY
IN
NESTED
IF
STATEMENTS
A
PROBLEM
A
YES
IN
JAVA
WHEN
YOU
WRITE
IF
IF
STMNTA
ELSE
STMNTB
IT
IS
EQUIVALENT
TO
IF
IF
STMNTA
ELSE
STMNTB
EVEN
IF
YOU
MIGHT
HAVE
BEEN
THINKING
IF
IF
STMNTA
ELSE
STMNTB
USING
EXPLICIT
BRACES
IS
A
GOOD
WAY
TO
AVOID
THIS
DANGLING
ELSE
PITFALL
Q
WHAT
IS
THE
DIFFERENCE
BETWEEN
A
FOR
LOOP
AND
ITS
WHILE
FORMULATION
A
THE
CODE
IN
THE
FOR
LOOP
HEADER
IS
CONSIDERED
TO
BE
IN
THE
SAME
BLOCK
AS
THE
FOR
LOOP
BODY
IN
A
TYPICAL
FOR
LOOP
THE
INCREMENTING
VARIABLE
IS
NOT
AVAILABLE
FOR
USE
IN
LATER
STATEMENTS
IN
THE
CORRESPONDING
WHILE
LOOP
IT
IS
THIS
DISTINCTION
IS
OFTEN
A
REA
SON
TO
USE
A
WHILE
INSTEAD
OF
A
FOR
LOOP
Q
SOME
JAVA
PROGRAMMERS
USE
INT
A
INSTEAD
OF
INT
A
TO
DECLARE
ARRAYS
WHAT
THE
DIFFERENCE
A
IN
JAVA
BOTH
ARE
LEGAL
AND
EQUIVALENT
THE
FORMER
IS
HOW
ARRAYS
ARE
DECLARED
IN
C
THE
LATTER
IS
THE
PREFERRED
STYLE
IN
JAVA
SINCE
THE
TYPE
OF
THE
VARIABLE
INT
MORE
CLEARLY
INDICATES
THAT
IT
IS
AN
ARRAY
OF
INTEGERS
Q
WHY
DO
ARRAY
INDICES
START
AT
INSTEAD
OF
A
THIS
CONVENTION
ORIGINATED
WITH
MACHINE
LANGUAGE
PROGRAMMING
WHERE
THE
AD
DRESS
OF
AN
ARRAY
ELEMENT
WOULD
BE
COMPUTED
BY
ADDING
THE
INDEX
TO
THE
ADDRESS
OF
THE
BEGINNING
OF
AN
ARRAY
STARTING
INDICES
AT
WOULD
ENTAIL
EITHER
A
WASTE
OF
SPACE
AT
THE
BEGINNING
OF
THE
ARRAY
OR
A
WASTE
OF
TIME
TO
SUBTRACT
THE
Q
IF
A
IS
AN
ARRAY
WHY
DOES
STDOUT
PRINTLN
A
PRINT
OUT
A
HEXADECIMAL
INTEGER
SUCH
AS
INSTEAD
OF
THE
ELEMENTS
OF
THE
ARRAY
A
GOOD
QUESTION
IT
IS
PRINTING
OUT
THE
MEMORY
ADDRESS
OF
THE
ARRAY
WHICH
UNFORTU
NATELY
IS
RARELY
WHAT
YOU
WANT
Q
WHY
ARE
WE
NOT
USING
THE
STANDARD
JAVA
LIBRARIES
FOR
INPUT
AND
GRAPHICS
A
WE
ARE
USING
THEM
BUT
WE
PREFER
TO
WORK
WITH
SIMPLER
ABSTRACT
MODELS
THE
JAVA
LIBRARIES
BEHIND
STDIN
AND
STDDRAW
ARE
BUILT
FOR
PRODUCTION
PROGRAMMING
AND
THE
LIBRARIES
AND
THEIR
APIS
ARE
A
BIT
UNWIELDY
TO
GET
AN
IDEA
OF
WHAT
THEY
ARE
LIKE
LOOK
AT
THE
CODE
IN
STDIN
JAVA
AND
STDDRAW
JAVA
Q
CAN
MY
PROGRAM
REREAD
DATA
FROM
STANDARD
INPUT
A
NO
YOU
ONLY
GET
ONE
SHOT
AT
IT
IN
THE
SAME
WAY
THAT
YOU
CANNOT
UNDO
PRINTLN
Q
WHAT
HAPPENS
IF
MY
PROGRAM
ATTEMPTS
TO
READ
AFTER
STANDARD
INPUT
IS
EXHAUSTED
A
YOU
WILL
GET
AN
ERROR
STDIN
ISEMPTY
ALLOWS
YOU
TO
AVOID
SUCH
AN
ERROR
BY
CHECK
ING
WHETHER
THERE
IS
MORE
INPUT
AVAILABLE
Q
WHAT
DOES
THIS
ERROR
MESSAGE
MEAN
EXCEPTION
IN
THREAD
MAIN
JAVA
LANG
NOCLASSDEFFOUNDERROR
STDIN
A
YOU
PROBABLY
FORGOT
TO
PUT
STDIN
JAVA
IN
YOUR
WORKING
DIRECTORY
Q
CAN
A
STATIC
METHOD
TAKE
ANOTHER
STATIC
METHOD
AS
AN
ARGUMENT
IN
JAVA
A
NO
GOOD
QUESTION
SINCE
MANY
OTHER
LANGUAGES
DO
SUPPORT
THIS
CAPABILITY
GIVE
THE
VALUE
OF
EACH
OF
THE
FOLLOWING
EXPRESSIONS
A
B
C
TRUE
FALSE
TRUE
TRUE
GIVE
THE
TYPE
AND
VALUE
OF
EACH
OF
THE
FOLLOWING
EXPRESSIONS
A
B
C
D
WRITE
A
PROGRAM
THAT
TAKES
THREE
INTEGER
COMMAND
LINE
ARGUMENTS
AND
PRINTS
EQUAL
IF
ALL
THREE
ARE
EQUAL
AND
NOT
EQUAL
OTHERWISE
WHAT
IF
ANYTHING
IS
WRONG
WITH
EACH
OF
THE
FOLLOWING
STATEMENTS
A
IF
A
B
THEN
C
B
IF
A
B
C
C
IF
A
B
C
D
IF
A
B
C
ELSE
B
WRITE
A
CODE
FRAGMENT
THAT
PRINTS
TRUE
IF
THE
DOUBLE
VARIABLES
X
AND
Y
ARE
BOTH
STRICTLY
BETWEEN
AND
AND
FALSE
OTHERWISE
WHAT
DOES
THE
FOLLOWING
PROGRAM
PRINT
INT
F
INT
G
FOR
INT
I
I
I
STDOUT
PRINTLN
F
F
F
G
G
F
G
GIVE
THE
VALUE
PRINTED
BY
EACH
OF
THE
FOLLOWING
CODE
FRAGMENTS
A
DOUBLE
T
WHILE
MATH
ABS
T
T
T
T
T
STDOUT
PRINTF
N
T
B
INT
SUM
FOR
INT
I
I
I
FOR
INT
J
J
I
J
SUM
STDOUT
PRINTLN
SUM
C
INT
SUM
FOR
INT
I
I
I
FOR
INT
J
J
N
J
SUM
STDOUT
PRINTLN
SUM
WHAT
DO
EACH
OF
THE
FOLLOWING
PRINT
A
SYSTEM
OUT
PRINTLN
B
B
SYSTEM
OUT
PRINTLN
B
C
C
SYSTEM
OUT
PRINTLN
CHAR
A
EXPLAIN
EACH
OUTCOME
WRITE
A
CODE
FRAGMENT
THAT
PUTS
THE
BINARY
REPRESENTATION
OF
A
POSITIVE
INTEGER
N
INTO
A
STRING
SOLUTION
JAVA
HAS
A
BUILT
IN
METHOD
INTEGER
TOBINARYSTRING
N
FOR
THIS
JOB
BUT
THE
POINT
OF
THE
EXERCISE
IS
TO
SEE
HOW
SUCH
A
METHOD
MIGHT
BE
IMPLEMENTED
HERE
IS
A
PARTICULARLY
CONCISE
SOLUTION
STRING
FOR
INT
N
N
N
N
N
EXERCISES
CONTINUED
WHAT
IS
WRONG
WITH
THE
FOLLOWING
CODE
FRAGMENT
INT
A
FOR
INT
I
I
I
A
I
I
I
SOLUTION
IT
DOES
NOT
ALLOCATE
MEMORY
FOR
A
WITH
NEW
THIS
CODE
RESULTS
IN
A
VARIABLE
A
MIGHT
NOT
HAVE
BEEN
INITIALIZED
COMPILE
TIME
ERROR
WRITE
A
CODE
FRAGMENT
THAT
PRINTS
THE
CONTENTS
OF
A
TWO
DIMENSIONAL
BOOLEAN
ARRAY
USING
TO
REPRESENT
TRUE
AND
A
SPACE
TO
REPRESENT
FALSE
INCLUDE
ROW
AND
COLUMN
NUMBERS
WHAT
DOES
THE
FOLLOWING
CODE
FRAGMENT
PRINT
INT
A
NEW
INT
FOR
INT
I
I
I
A
I
I
FOR
INT
I
I
I
A
I
A
A
I
FOR
INT
I
I
I
SYSTEM
OUT
PRINTLN
I
WRITE
A
CODE
FRAGMENT
TO
PRINT
THE
TRANSPOSITION
ROWS
AND
COLUMNS
CHANGED
OF
A
TWO
DIMENSIONAL
ARRAY
WITH
M
ROWS
AND
N
COLUMNS
WRITE
A
STATIC
METHOD
LG
THAT
TAKES
AN
INT
VALUE
N
AS
ARGUMENT
AND
RETURNS
THE
LARGEST
INT
NOT
LARGER
THAN
THE
BASE
LOGARITHM
OF
N
DO
NOT
USE
MATH
WRITE
A
STATIC
METHOD
HISTOGRAM
THAT
TAKES
AN
ARRAY
A
OF
INT
VALUES
AND
AN
INTEGER
M
AS
ARGUMENTS
AND
RETURNS
AN
ARRAY
OF
LENGTH
M
WHOSE
ITH
ENTRY
IS
THE
NUM
BER
OF
TIMES
THE
INTEGER
I
APPEARED
IN
THE
ARGUMENT
ARRAY
IF
THE
VALUES
IN
A
ARE
ALL
BETWEEN
AND
M
THE
SUM
OF
THE
VALUES
IN
THE
RETURNED
ARRAY
SHOULD
BE
EQUAL
TO
A
LENGTH
GIVE
THE
VALUE
OF
PUBLIC
STATIC
STRING
INT
N
IF
N
RETURN
RETURN
N
N
N
N
CRITICIZE
THE
FOLLOWING
RECURSIVE
FUNCTION
PUBLIC
STATIC
STRING
INT
N
STRING
N
N
N
N
IF
N
RETURN
RETURN
ANSWER
THE
BASE
CASE
WILL
NEVER
BE
REACHED
A
CALL
TO
WILL
RESULT
IN
CALLS
TO
AND
SO
FORTH
UNTIL
A
STACKOVERFLOWERROR
OCCURS
CONSIDER
THE
FOLLOWING
RECURSIVE
FUNCTION
PUBLIC
STATIC
INT
MYSTERY
INT
A
INT
B
IF
B
RETURN
IF
B
RETURN
MYSTERY
A
A
B
RETURN
MYSTERY
A
A
B
A
WHAT
ARE
THE
VALUES
OF
MYSTERY
AND
MYSTERY
GIVEN
POSITIVE
INTEGERS
A
AND
B
DESCRIBE
WHAT
VALUE
MYSTERY
A
B
COMPUTES
ANSWER
THE
SAME
QUESTION
BUT
REPLACE
WITH
AND
REPLACE
RETURN
WITH
RETURN
RUN
THE
FOLLOWING
PROGRAM
ON
YOUR
COMPUTER
PUBLIC
CLASS
FIBONACCI
PUBLIC
STATIC
LONG
F
INT
N
IF
N
RETURN
IF
N
RETURN
RETURN
F
N
F
N
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
FOR
INT
N
N
N
STDOUT
PRINTLN
N
F
N
EXERCISES
CONTINUED
WHAT
IS
THE
LARGEST
VALUE
OF
N
FOR
WHICH
THIS
PROGRAM
TAKES
LESS
HOUR
TO
COMPUTE
THE
VALUE
OF
F
N
DEVELOP
A
BETTER
IMPLEMENTATION
OF
F
N
THAT
SAVES
COMPUTED
VALUES
IN
AN
ARRAY
WRITE
A
RECURSIVE
STATIC
METHOD
THAT
COMPUTES
THE
VALUE
OF
LN
N
WRITE
A
PROGRAM
THAT
READS
IN
LINES
FROM
STANDARD
INPUT
WITH
EACH
LINE
CONTAIN
ING
A
NAME
AND
TWO
INTEGERS
AND
THEN
USES
PRINTF
TO
PRINT
A
TABLE
WITH
A
COLUMN
OF
THE
NAMES
THE
INTEGERS
AND
THE
RESULT
OF
DIVIDING
THE
FIRST
BY
THE
SECOND
ACCURATE
TO
THREE
DECIMAL
PLACES
YOU
COULD
USE
A
PROGRAM
LIKE
THIS
TO
TABULATE
BATTING
AVERAGES
FOR
BASEBALL
PLAYERS
OR
GRADES
FOR
STUDENTS
WRITE
A
VERSION
OF
BINARYSEARCH
THAT
USES
THE
RECURSIVE
RANK
GIVEN
ON
PAGE
AND
TRACES
THE
METHOD
CALLS
EACH
TIME
THE
RECURSIVE
METHOD
IS
CALLED
PRINT
THE
ARGU
MENT
VALUES
LO
AND
HI
INDENTED
BY
THE
DEPTH
OF
THE
RECURSION
HINT
ADD
AN
ARGUMENT
TO
THE
RECURSIVE
METHOD
THAT
KEEPS
TRACK
OF
THE
DEPTH
ADD
TO
THE
BINARYSEARCH
TEST
CLIENT
THE
ABILITY
TO
RESPOND
TO
A
SECOND
ARGU
MENT
TO
PRINT
NUMBERS
FROM
STANDARD
INPUT
THAT
ARE
NOT
IN
THE
WHITELIST
TO
PRINT
NUMBERS
THAT
ARE
IN
THE
WHITELIST
GIVE
THE
SEQUENCE
OF
VALUES
OF
P
AND
Q
THAT
ARE
COMPUTED
WHEN
EUCLID
ALGO
RITHM
IS
USED
TO
COMPUTE
THE
GREATEST
COMMON
DIVISOR
OF
AND
EXTEND
THE
CODE
GIVEN
ON
PAGE
TO
DEVELOP
A
PROGRAM
EUCLID
THAT
TAKES
TWO
INTEGERS
FROM
THE
COMMAND
LINE
AND
COMPUTES
THEIR
GREATEST
COMMON
DIVISOR
PRINTING
OUT
THE
TWO
ARGUMENTS
FOR
EACH
CALL
ON
THE
RECURSIVE
METHOD
USE
YOUR
PROGRAM
TO
COMPUTE
THE
GREATEST
COMMON
DIVISOR
OR
AND
USE
MATHEMATICAL
INDUCTION
TO
PROVE
THAT
EUCLID
ALGORITHM
COMPUTES
THE
GREATEST
COMMON
DIVISOR
OF
ANY
PAIR
OF
NONNEGATIVE
INTEGERS
P
AND
Q
SORTING
THREE
NUMBERS
SUPPOSE
THAT
THE
VARIABLES
A
B
C
AND
T
ARE
ALL
OF
THE
SAME
NUMERIC
PRIMITIVE
TYPE
SHOW
THAT
THE
FOLLOWING
CODE
PUTS
A
B
AND
C
IN
ASCENDING
ORDER
IF
A
B
T
A
A
B
B
T
IF
A
C
T
A
A
C
C
T
IF
B
C
T
B
B
C
C
T
BINOMIAL
DISTRIBUTION
ESTIMATE
THE
NUMBER
OF
RECURSIVE
CALLS
THAT
WOULD
BE
USED
BY
THE
CODE
PUBLIC
STATIC
DOUBLE
BINOMIAL
INT
N
INT
K
DOUBLE
P
IF
N
K
RETURN
RETURN
P
BINOMIAL
N
K
P
BINOMIAL
N
K
TO
COMPUTE
BINOMIAL
DEVELOP
A
BETTER
IMPLEMENTATION
THAT
IS
BASED
ON
SAVING
COMPUTED
VALUES
IN
AN
ARRAY
REMOVE
DUPLICATES
MODIFY
THE
TEST
CLIENT
IN
BINARYSEARCH
TO
REMOVE
ANY
DU
PLICATE
KEYS
IN
THE
WHITELIST
AFTER
THE
SORT
EQUAL
KEYS
ADD
TO
BINARYSEARCH
A
STATIC
METHOD
RANK
THAT
TAKES
A
KEY
AND
A
SORTED
ARRAY
OF
INT
VALUES
SOME
OF
WHICH
MAY
BE
EQUAL
AS
ARGUMENTS
AND
RETURNS
THE
NUMBER
OF
ELEMENTS
THAT
ARE
SMALLER
THAN
THE
KEY
AND
A
SIMILAR
METHOD
COUNT
THAT
RETURNS
THE
NUMBER
OF
ELEMENTS
EQUAL
TO
THE
KEY
NOTE
IF
I
AND
J
ARE
THE
VALUES
RETURNED
BY
RANK
KEY
A
AND
COUNT
KEY
A
RESPECTIVELY
THEN
A
I
I
J
ARE
THE
VALUES
IN
THE
ARRAY
THAT
ARE
EQUAL
TO
KEY
ARRAY
EXERCISE
WRITE
A
CODE
FRAGMENT
THAT
CREATES
AN
N
BY
N
BOOLEAN
ARRAY
A
SUCH
THAT
A
I
J
IS
TRUE
IF
I
AND
J
ARE
RELATIVELY
PRIME
HAVE
NO
COMMON
FAC
TORS
AND
FALSE
OTHERWISE
RANDOM
CONNECTIONS
WRITE
A
PROGRAM
THAT
TAKES
AS
COMMAND
LINE
ARGUMENTS
AN
INTEGER
N
AND
A
DOUBLE
VALUE
P
BETWEEN
AND
PLOTS
N
EQUALLY
SPACED
DOTS
OF
SIZE
ON
THE
CIRCUMFERENCE
OF
A
CIRCLE
AND
THEN
WITH
PROBABILITY
P
FOR
EACH
PAIR
OF
POINTS
DRAWS
A
GRAY
LINE
CONNECTING
THEM
CREATIVE
PROBLEMS
CONTINUED
HISTOGRAM
SUPPOSE
THAT
THE
STANDARD
INPUT
STREAM
IS
A
SEQUENCE
OF
DOUBLE
VALUES
WRITE
A
PROGRAM
THAT
TAKES
AN
INTEGER
N
AND
TWO
DOUBLE
VALUES
L
AND
R
FROM
THE
COMMAND
LINE
AND
USES
STDDRAW
TO
PLOT
A
HISTOGRAM
OF
THE
COUNT
OF
THE
NUMBERS
IN
THE
STANDARD
INPUT
STREAM
THAT
FALL
IN
EACH
OF
THE
N
INTERVALS
DEFINED
BY
DIVIDING
L
R
INTO
N
EQUAL
SIZED
INTERVALS
MATRIX
LIBRARY
WRITE
A
LIBRARY
MATRIX
THAT
IMPLEMENTS
THE
FOLLOWING
API
PUBLIC
CLASS
MATRIX
STATIC
DOUBLE
DOT
DOUBLE
X
DOUBLE
Y
VECTOR
DOT
PRODUCT
STATIC
DOUBLE
MULT
DOUBLE
A
DOUBLE
B
MATRIX
MATRIX
PRODUCT
STATIC
DOUBLE
TRANSPOSE
DOUBLE
A
TRANSPOSE
STATIC
DOUBLE
MULT
DOUBLE
A
DOUBLE
X
MATRIX
VECTOR
PRODUCT
STATIC
DOUBLE
MULT
DOUBLE
Y
DOUBLE
A
VECTOR
MATRIX
PRODUCT
DEVELOP
A
TEST
CLIENT
THAT
READS
VALUES
FROM
STANDARD
INPUT
AND
TESTS
ALL
THE
METHODS
FILTERING
WHICH
OF
THE
FOLLOWING
REQUIRE
SAVING
ALL
THE
VALUES
FROM
STANDARD
INPUT
IN
AN
ARRAY
SAY
AND
WHICH
COULD
BE
IMPLEMENTED
AS
A
FILTER
USING
ONLY
A
FIXED
NUMBER
OF
VARIABLES
AND
ARRAYS
OF
FIXED
SIZE
NOT
DEPENDENT
ON
N
FOR
EACH
THE
INPUT
COMES
FROM
STANDARD
INPUT
AND
CONSISTS
OF
N
REAL
NUMBERS
BETWEEN
AND
PRINT
THE
MAXIMUM
AND
MINIMUM
NUMBERS
PRINT
THE
MEDIAN
OF
THE
NUMBERS
PRINT
THE
K
TH
SMALLEST
VALUE
FOR
K
LESS
THAN
PRINT
THE
SUM
OF
THE
SQUARES
OF
THE
NUMBERS
PRINT
THE
AVERAGE
OF
THE
N
NUMBERS
PRINT
THE
PERCENTAGE
OF
NUMBERS
GREATER
THAN
THE
AVERAGE
PRINT
THE
N
NUMBERS
IN
INCREASING
ORDER
PRINT
THE
N
NUMBERS
IN
RANDOM
ORDER
DICE
SIMULATION
THE
FOLLOWING
CODE
COMPUTES
THE
EXACT
PROBABILITY
DISTRIBU
TION
FOR
THE
SUM
OF
TWO
DICE
INT
SIDES
DOUBLE
DIST
NEW
DOUBLE
SIDES
FOR
INT
I
I
SIDES
I
FOR
INT
J
J
SIDES
J
DIST
I
J
FOR
INT
K
K
SIDES
K
DIST
K
THE
VALUE
DIST
I
IS
THE
PROBABILITY
THAT
THE
DICE
SUM
TO
K
RUN
EXPERIMENTS
TO
VALI
DATE
THIS
CALCULATION
SIMULATING
N
DICE
THROWS
KEEPING
TRACK
OF
THE
FREQUENCIES
OF
OC
CURRENCE
OF
EACH
VALUE
WHEN
YOU
COMPUTE
THE
SUM
OF
TWO
RANDOM
INTEGERS
BETWEEN
AND
HOW
LARGE
DOES
N
HAVE
TO
BE
BEFORE
YOUR
EMPIRICAL
RESULTS
MATCH
THE
EXACT
RESULTS
TO
THREE
DECIMAL
PLACES
EMPIRICAL
SHUFFLE
CHECK
RUN
COMPUTATIONAL
EXPERIMENTS
TO
CHECK
THAT
OUR
SHUFFLING
CODE
ON
PAGE
WORKS
AS
ADVERTISED
WRITE
A
PROGRAM
SHUFFLETEST
THAT
TAKES
COMMAND
LINE
ARGUMENTS
M
AND
N
DOES
N
SHUFFLES
OF
AN
ARRAY
OF
SIZE
M
THAT
IS
INITIAL
IZED
WITH
A
I
I
BEFORE
EACH
SHUFFLE
AND
PRINTS
AN
M
BY
M
TABLE
SUCH
THAT
ROW
I
GIVES
THE
NUMBER
OF
TIMES
I
WOUND
UP
IN
POSITION
J
FOR
ALL
J
ALL
ENTRIES
IN
THE
ARRAY
SHOULD
BE
CLOSE
TO
N
M
BAD
SHUFFLING
SUPPOSE
THAT
YOU
CHOOSE
A
RANDOM
INTEGER
BETWEEN
AND
N
IN
OUR
SHUFFLING
CODE
INSTEAD
OF
ONE
BETWEEN
I
AND
N
SHOW
THAT
THE
RESULTING
ORDER
IS
NOT
EQUALLY
LIKELY
TO
BE
ONE
OF
THE
N
POSSIBILITIES
RUN
THE
TEST
OF
THE
PREVIOUS
EXERCISE
FOR
THIS
VERSION
BINARY
SEARCH
VERSUS
BRUTE
FORCE
SEARCH
WRITE
A
PROGRAM
BRUTEFORCESEARCH
THAT
USES
THE
BRUTE
FORCE
SEARCH
METHOD
GIVEN
ON
PAGE
AND
COMPARE
ITS
RUNNING
TIME
ON
YOUR
COMPUTER
WITH
THAT
OF
BINARYSEARCH
FOR
LARGEW
TXT
AND
LARGET
TXT
EXPERIMENTS
CONTINUED
RANDOM
MATCHES
WRITE
A
BINARYSEARCH
CLIENT
THAT
TAKES
AN
INT
VALUE
T
AS
COMMAND
LINE
ARGUMENT
AND
RUNS
T
TRIALS
OF
THE
FOLLOWING
EXPERIMENT
FOR
N
AND
GENERATE
TWO
ARRAYS
OF
N
RANDOMLY
GENERATED
POSITIVE
SIX
DIGIT
INT
VALUES
AND
FIND
THE
NUMBER
OF
VALUES
THAT
APPEAR
IN
BOTH
ARRAYS
PRINT
A
TABLE
GIVING
THE
AVERAGE
VALUE
OF
THIS
QUANTITY
OVER
THE
T
TRIALS
FOR
EACH
VALUE
OF
N
THIS
PAGE
INTENTIONALLY
LEFT
BLANK
A
DATA
TYPE
IS
A
SET
OF
VALUES
AND
A
SET
OF
OPERATIONS
ON
THOSE
VALUES
SO
FAR
WE
HAVE
DISCUSSED
IN
DETAIL
JAVA
PRIMITIVE
DATA
TYPES
FOR
EXAMPLE
THE
VALUES
OF
THE
PRIMITIVE
DATA
TYPE
INT
ARE
INTEGERS
BETWEEN
AND
THE
OPERATIONS
OF
INT
INCLUDE
AND
IN
PRINCIPLE
WE
COULD
WRITE
ALL
OF
OUR
PROGRAMS
USING
ONLY
THE
BUILT
IN
PRIMITIVE
TYPES
BUT
IT
IS
MUCH
MORE
CONVENIENT
TO
WRITE
PROGRAMS
AT
A
HIGHER
LEVEL
OF
ABSTRACTION
IN
THIS
SECTION
WE
FOCUS
ON
THE
PROCESS
OF
DEFINING
AND
USING
DATA
TYPES
WHICH
IS
KNOWN
AS
DATA
ABSTRACTION
AND
SUPPLEMENTS
THE
FUNCTION
ABSTRACTION
STYLE
THAT
IS
THE
BASIS
OF
SECTION
PROGRAMMING
IN
JAVA
IS
LARGELY
BASED
ON
BUILDING
DATA
TYPES
KNOWN
AS
REFERENCE
TYPES
WITH
THE
FAMILIAR
JAVA
CLASS
THIS
STYLE
OF
PROGRAMMING
IS
KNOWN
AS
OBJECT
ORIENTED
PROGRAMMING
AS
IT
REVOLVES
AROUND
THE
CONCEPT
OF
AN
OBJECT
AN
ENTITY
THAT
HOLDS
A
DATA
TYPE
VALUE
WITH
JAVA
PRIMITIVE
TYPES
WE
ARE
LARGELY
CONFINED
TO
PROGRAMS
THAT
OPERATE
ON
NUMBERS
BUT
WITH
REFERENCE
TYPES
WE
CAN
WRITE
PROGRAMS
THAT
OPERATE
ON
STRINGS
PICTURES
SOUNDS
ANY
OF
HUNDREDS
OF
OTHER
ABSTRACTIONS
THAT
ARE
AVAILABLE
IN
JAVA
STAN
DARD
LIBRARIES
OR
ON
OUR
BOOKSITE
EVEN
MORE
SIGNIFICANT
THAN
LIBRARIES
OF
PREDEFINED
DATA
TYPES
IS
THAT
THE
RANGE
OF
DATA
TYPES
AVAILABLE
IN
JAVA
PROGRAMMING
IS
OPEN
ENDED
BECAUSE
YOU
CAN
DEFINE
YOUR
OWN
DATA
TYPES
TO
IMPLEMENT
ANY
ABSTRACTION
WHATSOEVER
AN
ABSTRACT
DATA
TYPE
ADT
IS
A
DATA
TYPE
WHOSE
REPRESENTATION
IS
HIDDEN
FROM
THE
CLIENT
IMPLEMENTING
AN
ADT
AS
A
JAVA
CLASS
IS
NOT
VERY
DIFFERENT
FROM
IMPLEMENTING
A
FUNCTION
LIBRARY
AS
A
SET
OF
STATIC
METHODS
THE
PRIMARY
DIFFERENCE
IS
THAT
WE
ASSOCIATE
DATA
WITH
THE
FUNCTION
IMPLEMENTATIONS
AND
WE
HIDE
THE
REPRESENTATION
OF
THE
DATA
FROM
THE
CLIENT
WHEN
USING
AN
ADT
WE
FOCUS
ON
THE
OPERATIONS
SPECIFIED
IN
THE
API
AND
PAY
NO
ATTENTION
TO
THE
DATA
REPRESENTATION
WHEN
IMPLEMENTING
AN
ADT
WE
FOCUS
ON
THE
DATA
THEN
IMPLEMENT
OPERATIONS
ON
THAT
DATA
ABSTRACT
DATA
TYPES
ARE
IMPORTANT
BECAUSE
THEY
SUPPORT
ENCAPSULATION
IN
PROGRAM
DESIGN
IN
THIS
BOOK
WE
USE
THEM
AS
A
MEANS
TO
PRECISELY
SPECIFY
PROBLEMS
IN
THE
FORM
OF
APIS
FOR
USE
BY
DIVERSE
CLIENTS
DESCRIBE
ALGORITHMS
AND
DATA
STRUCTURES
AS
API
IMPLEMENTATIONS
OUR
PRIMARY
REASON
FOR
STUDYING
DIFFERENT
ALGORITHMS
FOR
THE
SAME
TASK
IS
THAT
PERFOR
MANCE
CHARACTERISTICS
DIFFER
ABSTRACT
DATA
TYPES
ARE
AN
APPROPRIATE
FRAMEWORK
FOR
THE
STUDY
OF
ALGORITHMS
BECAUSE
THEY
ALLOW
US
TO
PUT
KNOWLEDGE
OF
ALGORITHM
PERFORMANCE
TO
IMMEDIATE
USE
WE
CAN
SUBSTITUTE
ONE
ALGORITHM
FOR
ANOTHER
TO
IMPROVE
PERFORMANCE
FOR
ALL
CLIENTS
WITHOUT
CHANGING
ANY
CLIENT
CODE
USING
ABSTRACT
DATA
TYPES
YOU
DO
NOT
NEED
TO
KNOW
HOW
A
DATA
TYPE
IS
IMPLE
MENTED
IN
ORDER
TO
BE
ABLE
TO
USE
IT
SO
WE
BEGIN
BY
DESCRIBING
HOW
TO
WRITE
PROGRAMS
THAT
USE
A
SIMPLE
DATA
TYPE
NAMED
COUNTER
WHOSE
VALUES
ARE
A
NAME
AND
A
NONNEGA
TIVE
INTEGER
AND
WHOSE
OPERATIONS
ARE
CREATE
AND
INITIALIZE
TO
ZERO
INCREMENT
BY
ONE
AND
EXAMINE
THE
CURRENT
VALUE
THIS
ABSTRACTION
IS
USEFUL
IN
MANY
CONTEXTS
FOR
EXAMPLE
IT
WOULD
BE
REASONABLE
TO
USE
SUCH
A
DATA
TYPE
IN
ELECTRONIC
VOTING
SOFTWARE
TO
ENSURE
THAT
THE
ONLY
THING
THAT
A
VOTER
CAN
DO
IS
INCREMENT
A
CHOSEN
CANDIDATE
TALLY
BY
ONE
OR
WE
MIGHT
USE
A
COUNTER
TO
KEEP
TRACK
OF
FUNDAMENTAL
OPERATIONS
WHEN
ANALYZING
THE
PERFORMANCE
OF
ALGORITHMS
TO
USE
A
COUNTER
YOU
NEED
TO
LEARN
OUR
MECHANISM
FOR
SPECIFYING
THE
OPERATIONS
DEFINED
IN
THE
DATA
TYPE
AND
THE
JAVA
LANGUAGE
MECHANISMS
FOR
CREATING
AND
MANIPULATING
DATA
TYPE
VALUES
SUCH
MECHANISMS
ARE
CRITICALLY
IM
PORTANT
IN
MODERN
PROGRAMMING
AND
WE
USE
THEM
THROUGHOUT
THIS
BOOK
SO
THIS
FIRST
EXAMPLE
IS
WORTHY
OF
CAREFUL
ATTENTION
API
FOR
AN
ABSTRACT
DATA
TYPE
TO
SPECIFY
THE
BEHAVIOR
OF
AN
ABSTRACT
DATA
TYPE
WE
USE
AN
APPLICATION
PROGRAMMING
INTERFACE
API
WHICH
IS
A
LIST
OF
CONSTRUCTORS
AND
INSTANCE
METHODS
OPERATIONS
WITH
AN
INFORMAL
DESCRIPTION
OF
THE
EFFECT
OF
EACH
AS
IN
THIS
API
FOR
COUNTER
PUBLIC
CLASS
COUNTER
COUNTER
STRING
ID
CREATE
A
COUNTER
NAMED
ID
VOID
INCREMENT
INCREMENT
THE
COUNTER
BY
ONE
INT
TALLY
NUMBER
OF
INCREMENTS
SINCE
CREATION
STRING
TOSTRING
STRING
REPRESENTATION
AN
API
FOR
A
COUNTER
EVEN
THOUGH
THE
BASIS
OF
A
DATA
TYPE
DEFINITION
IS
A
SET
OF
VALUES
THE
ROLE
OF
THE
VALUES
IS
NOT
VISIBLE
FROM
THE
API
ONLY
THE
OPERATIONS
ON
THOSE
VALUES
ACCORDINGLY
AN
ADT
DEFINITION
HAS
MANY
SIMILARITIES
WITH
A
LIBRARY
OF
STATIC
METHODS
SEE
PAGE
BOTH
ARE
IMPLEMENTED
AS
A
JAVA
CLASS
INSTANCE
METHODS
MAY
TAKE
ZERO
OR
MORE
ARGUMENTS
OF
A
SPECIFIED
TYPE
SEPA
RATED
BY
COMMAS
AND
ENCLOSED
IN
PARENTHESES
THEY
MAY
PROVIDE
A
RETURN
VALUE
OF
A
SPECIFIED
TYPE
OR
NO
RETURN
VALUE
SIGNIFIED
BY
VOID
AND
THERE
ARE
THREE
SIGNIFICANT
DIFFERENCES
SOME
ENTRIES
IN
THE
API
HAVE
THE
SAME
NAME
AS
THE
CLASS
AND
LACK
A
RETURN
TYPE
SUCH
ENTRIES
ARE
KNOWN
AS
CONSTRUCTORS
AND
PLAY
A
SPECIAL
ROLE
IN
THIS
CASE
COUNTER
HAS
A
CONSTRUCTOR
THAT
TAKES
A
STRING
ARGUMENT
INSTANCE
METHODS
LACK
THE
STATIC
MODIFIER
THEY
ARE
NOT
STATIC
METHODS
THEIR
PURPOSE
IS
TO
OPERATE
ON
DATA
TYPE
VALUES
SOME
INSTANCE
METHODS
ARE
PRESENT
SO
AS
TO
ADHERE
TO
JAVA
CONVENTIONS
WE
REFER
TO
SUCH
METHODS
AS
INHERITED
METHODS
AND
SHADE
THEM
GRAY
IN
THE
API
AS
WITH
APIS
FOR
LIBRARIES
OF
STATIC
METHODS
AN
API
FOR
AN
ABSTRACT
DATA
TYPE
IS
A
CON
TRACT
WITH
ALL
CLIENTS
AND
THEREFORE
THE
STARTING
POINT
BOTH
FOR
DEVELOPING
ANY
CLIENT
CODE
AND
FOR
DEVELOPING
ANY
DATA
TYPE
IMPLEMENTATION
IN
THIS
CASE
THE
API
TELLS
US
THAT
TO
USE
COUNTER
WE
HAVE
AVAILABLE
THE
COUNTER
CONSTRUCTOR
THE
INCREMENT
AND
TALLY
INSTANCE
METHODS
AND
THE
INHERITED
TOSTRING
METHOD
INHERITED
METHODS
VARIOUS
JAVA
CONVENTIONS
ENABLE
A
DATA
TYPE
TO
TAKE
ADVANTAGE
OF
BUILT
IN
LANGUAGE
MECHANISMS
BY
INCLUDING
SPECIFIC
METHODS
IN
THE
API
FOR
EXAMPLE
ALL
JAVA
DATA
TYPES
INHERIT
A
TOSTRING
METHOD
THAT
RETURNS
A
STRING
REPRESENTATION
OF
THE
DATA
TYPE
VALUES
JAVA
CALLS
THIS
METHOD
WHEN
ANY
DATA
TYPE
VALUE
IS
TO
BE
CONCAT
ENATED
WITH
A
STRING
VALUE
WITH
THE
OPERATOR
THE
DEFAULT
IMPLEMENTATION
IS
NOT
PAR
TICULARLY
USEFUL
IT
GIVES
A
STRING
REPRESENTATION
OF
THE
MEMORY
ADDRESS
OF
THE
DATA
TYPE
VALUE
SO
WE
OFTEN
PROVIDE
AN
IMPLEMENTATION
THAT
OVERRIDES
THE
DEFAULT
AND
INCLUDE
TOSTRING
IN
THE
API
WHENEVER
WE
DO
SO
OTHER
EXAMPLES
OF
SUCH
METHODS
INCLUDE
EQUALS
COMPARETO
AND
HASHCODE
SEE
PAGE
CLIENT
CODE
AS
WITH
MODULAR
PROGRAMMING
BASED
ON
STATIC
METHODS
THE
API
ALLOWS
US
TO
WRITE
CLIENT
CODE
WITHOUT
KNOWING
DETAILS
OF
THE
IMPLEMENTATION
AND
TO
WRITE
IMPLEMENTATION
CODE
WITHOUT
KNOWING
DETAILS
OF
ANY
PARTICULAR
CLIENT
THE
MECHA
NISMS
INTRODUCED
ON
PAGE
FOR
ORGANIZING
PROGRAMS
AS
INDEPENDENT
MODULES
ARE
USE
FUL
FOR
ALL
JAVA
CLASSES
AND
THUS
ARE
EFFECTIVE
FOR
MODULAR
PROGRAMMING
WITH
ADTS
AS
WELL
AS
FOR
LIBRARIES
OF
STATIC
METHODS
ACCORDINGLY
WE
CAN
USE
AN
ADT
IN
ANY
PROGRAM
PROVIDED
THAT
THE
SOURCE
CODE
IS
IN
A
JAVA
FILE
IN
THE
SAME
DIRECTORY
OR
IN
THE
STANDARD
JAVA
LIBRARY
OR
ACCESSIBLE
THROUGH
AN
IMPORT
STATEMENT
OR
THROUGH
ONE
OF
THE
CLASSPATH
MECHANISMS
DESCRIBED
ON
THE
BOOKSITE
ALL
OF
THE
BENEFITS
OF
MODULAR
PROGRAMMING
FOLLOW
BY
ENCAPSULATING
ALL
THE
CODE
THAT
IMPLEMENTS
A
DATA
TYPE
WITHIN
A
SINGLE
JAVA
CLASS
WE
ENABLE
THE
DEVELOPMENT
OF
CLIENT
CODE
AT
A
HIGHER
LEVEL
OF
ABSTRACTION
TO
DE
VELOP
CLIENT
CODE
YOU
NEED
TO
BE
ABLE
TO
DECLARE
VARIABLES
CREATE
OBJECTS
TO
HOLD
DATA
TYPE
VALUES
AND
PROVIDE
ACCESS
TO
THE
VALUES
FOR
INSTANCE
METHODS
TO
OPERATE
ON
THEM
THESE
PROCESSES
ARE
DIFFERENT
FROM
THE
CORRESPONDING
PROCESSES
FOR
PRIMITIVE
TYPES
THOUGH
YOU
WILL
NOTICE
MANY
SIMILARITIES
OBJECTS
NATURALLY
YOU
CAN
DECLARE
THAT
A
VARIABLE
HEADS
IS
TO
BE
ASSOCIATED
WITH
DATA
OF
TYPE
COUNTER
WITH
THE
CODE
COUNTER
HEADS
BUT
HOW
CAN
YOU
ASSIGN
VALUES
OR
SPECIFY
OPERATIONS
THE
ANSWER
TO
THIS
QUESTION
IN
VOLVES
A
FUNDAMENTAL
CONCEPT
IN
DATA
ABSTRACTION
AN
OBJECT
IS
AN
ENTITY
THAT
CAN
TAKE
ON
A
DATA
TYPE
VALUE
OBJECTS
ARE
CHARACTERIZED
BY
THREE
ESSENTIAL
PROP
ERTIES
STATE
IDENTITY
AND
BEHAVIOR
THE
STATE
OF
AN
OBJECT
IS
A
VALUE
FROM
ITS
DATA
TYPE
THE
IDENTITY
OF
AN
OBJECT
DISTINGUISHES
ONE
OBJECT
FROM
ANOTHER
IT
IS
USEFUL
TO
THINK
OF
AN
OBJECT
IDENTITY
AS
THE
PLACE
WHERE
ITS
VALUE
IS
STORED
IN
MEMORY
THE
BEHAVIOR
OF
AN
OBJECT
IS
THE
EFFECT
OF
DATA
TYPE
OPERATIONS
THE
IMPLEMENTATION
HAS
THE
SOLE
RE
SPONSIBILITY
FOR
MAINTAINING
AN
OBJECT
IDENTITY
SO
THAT
CLIENT
CODE
CAN
USE
A
DATA
TYPE
WITHOUT
REGARD
TO
THE
REPRESENTATION
OF
ITS
STATE
BY
CONFORMING
TO
AN
API
THAT
DESCRIBES
AN
OBJECT
BEHAVIOR
AN
OB
JECT
STATE
MIGHT
BE
USED
TO
PROVIDE
INFORMATION
TO
A
CLIENT
OR
CAUSE
A
SIDE
EFFECT
OR
BE
CHANGED
BY
ONE
OF
ITS
DATA
TYPE
OPERATIONS
BUT
THE
DETAILS
OF
THE
REPRESENTATION
OF
THE
DATA
TYPE
VALUE
ARE
NOT
REL
EVANT
TO
CLIENT
CODE
A
REFERENCE
IS
A
MECHANISM
FOR
ACCESSING
AN
OB
JECT
JAVA
NOMENCLATURE
MAKES
CLEAR
THE
DISTINCTION
FROM
PRIMITIVE
TYPES
WHERE
VARIABLES
ARE
ASSOCIATED
WITH
VALUES
BY
USING
THE
TERM
REFERENCE
TYPES
FOR
NONPRIMITIVE
TYPES
THE
DETAILS
OF
IMPLEMENTING
REFERENCES
VARY
IN
JAVA
IMPLEMENTATIONS
BUT
IT
IS
USEFUL
TO
THINK
OF
A
REFERENCE
AS
A
MEMORY
ADDRESS
AS
SHOWN
AT
RIGHT
FOR
BREVITY
WE
USE
THREE
DIGIT
MEMORY
ADDRESSES
IN
THE
DIAGRAM
CREATING
OBJECTS
EACH
DATA
TYPE
VALUE
IS
STORED
IN
AN
OBJECT
TO
CREATE
OR
INSTANTIATE
AN
INDIVIDUAL
OBJECT
WE
INVOKE
A
CONSTRUCTOR
BY
USING
THE
KEYWORD
NEW
FOLLOWED
BY
THE
CLASS
NAME
FOLLOWED
BY
OR
A
LIST
OF
ARGUMENT
VALUES
ENCLOSED
IN
PARENTHESES
IF
THE
CON
STRUCTOR
TAKES
ARGUMENTS
A
CONSTRUCTOR
HAS
NO
RETURN
TYPE
BECAUSE
IT
ALWAYS
RETURNS
A
REFERENCE
TO
AN
OBJECT
OF
ITS
DATA
TYPE
EACH
TIME
THAT
A
CLIENT
USES
NEW
THE
SYSTEM
ALLOCATES
MEMORY
SPACE
FOR
THE
OBJECT
ONE
COUNTER
OBJECT
HEADS
TWO
COUNTER
OBJECTS
HEADS
TAILS
REFERENCE
IDENTITY
DETAILS
HIDDEN
INVOKES
THE
CONSTRUCTOR
TO
INITIALIZE
ITS
VALUE
RETURNS
A
REFERENCE
TO
THE
OBJECT
OBJECT
REPRESENTATION
IN
CLIENT
CODE
WE
TYPICALLY
CREATE
OBJECTS
IN
AN
INITIALIZING
DECLARATION
THAT
ASSOCIATES
A
VARIABLE
WITH
THE
OBJECT
AS
WE
OFTEN
DO
WITH
VARIABLES
OF
PRIMITIVE
TYPES
UNLIKE
PRIMI
TIVE
TYPES
VARIABLES
ARE
ASSOCIATED
WITH
REFERENCES
TO
OBJECTS
NOT
THE
DATA
TYPE
VALUES
THEMSELVES
WE
CAN
CREATE
ANY
NUM
BER
OF
OBJECTS
FROM
THE
SAME
CLASS
DECLARATION
TO
ASSOCIATE
VARIABLE
WITH
OBJECT
REFERENCE
CALL
ON
CONSTRUCTOR
TO
CREATE
AN
OBJECT
EACH
OBJECT
HAS
ITS
OWN
IDENTITY
AND
MAY
OR
MAY
NOT
STORE
THE
SAME
VALUE
AS
ANOTHER
OBJECT
OF
THE
SAME
TYPE
FOR
EXAMPLE
THE
CODE
COUNTER
HEADS
NEW
COUNTER
HEADS
COUNTER
TAILS
NEW
COUNTER
TAILS
NEW
COUNTER
HEADS
CREATING
AN
OBJECT
CREATES
TWO
DIFFERENT
COUNTER
OBJECTS
IN
AN
ABSTRACT
DATA
TYPE
DETAILS
OF
THE
REPRESENTA
TION
OF
THE
VALUE
ARE
HIDDEN
FROM
CLIENT
CODE
YOU
MIGHT
ASSUME
THAT
THE
VALUE
ASSOCI
ATED
WITH
EACH
COUNTER
OBJECT
IS
A
STRING
NAME
AND
AN
INT
TALLY
BUT
YOU
CANNOT
WRITE
CODE
THAT
DEPENDS
ON
ANY
SPECIFIC
REPRESENTATION
OR
EVEN
KNOW
WHETHER
THAT
ASSUMPTION
IS
TRUE
PERHAPS
THE
TALLY
IS
A
LONG
VALUE
INVOKING
INSTANCE
METHODS
THE
PURPOSE
OF
AN
INSTANCE
METHOD
IS
TO
OPERATE
ON
DATA
TYPE
VALUES
SO
THE
JAVA
LANGUAGE
INCLUDES
A
SPECIAL
MECHANISM
TO
INVOKE
INSTANCE
METH
ODS
THAT
EMPHASIZES
A
CONNECTION
TO
AN
OBJECT
SPECIFICALLY
WE
INVOKE
AN
INSTANCE
METH
OD
BY
WRITING
A
VARIABLE
NAME
THAT
REFERS
TO
AN
OBJECT
COUNTER
HEADS
WITH
NEW
CONSTRUCTOR
HEADS
DECLARATION
FOLLOWED
BY
A
PERIOD
FOLLOWED
BY
AN
INSTANCE
METHOD
NAME
FOLLOWED
BY
OR
MORE
ARGUMENTS
ENCLOSED
IN
PARENTHESES
AND
SEPARATED
BY
COMMAS
AN
INSTANCE
METHOD
MIGHT
CHANGE
THE
DATA
TYPE
VALUE
OR
JUST
EXAM
INVOKE
A
CONSTRUCTOR
CREATE
AN
OBJECT
AS
A
STATEMENT
VOID
RETURN
VALUE
INE
THE
DATA
TYPE
VALUE
INSTANCE
METHODS
HAVE
ALL
OF
THE
PROPERTIES
OF
STATIC
METHODS
THAT
WE
CONSIDERED
ON
PAGE
ARGUMENTSAREPASSEDBYVALUE
METHODNAMES
CAN
BE
OVERLOADED
THEY
MAY
HAVE
A
RETURN
VALUE
AND
OBJECT
NAME
AS
AN
EXPRESSION
OBJECT
NAME
INVOKE
AN
INSTANCE
METHOD
THAT
CHANGES
THE
OBJECT
VALUE
TAILS
TALLY
INVOKE
AN
INSTANCE
METHOD
THAT
ACCESSES
THE
OBJECT
VALUE
THEY
MAY
CAUSE
SIDE
EFFECTS
BUT
THEY
HAVE
AN
ADDI
TIONAL
PROPERTY
THAT
CHARACTERIZES
THEM
EACH
INVOCA
TION
IS
ASSOCIATED
WITH
AN
OBJECT
FOR
EXAMPLE
THE
CODE
HEADS
INCREMENT
INVOKES
THE
INSTANCE
METHOD
INCREMENT
TO
OPERATE
ON
THE
COUNTER
OBJECT
HEADS
IN
THIS
CASE
THE
OPERA
TION
INVOLVES
INCREMENTING
THE
TALLY
AND
THE
CODE
VIA
AUTOMATIC
TYPE
CONVERSION
TOSTRING
STDOUT
PRINTLN
INVOKE
HEADS
TOSTRING
INVOKING
INSTANCE
METHODS
HEADS
TALLY
TAILS
TALLY
INVOKES
THE
INSTANCE
METHOD
TALLY
TWICE
FIRST
TO
OPERATE
ON
THE
COUNTER
OBJECT
HEADS
AND
THEN
TO
OP
ERATE
ON
THE
COUNTER
OBJECT
TAILS
IN
THIS
CASE
THE
OPERATION
INVOLVES
RETURNING
THE
TALLY
AS
AN
INT
VALUE
AS
THESE
EXAMPLES
ILLUSTRATE
YOU
CAN
USE
CALLS
ON
INSTANCE
METHODS
IN
CLIENT
CODE
IN
THE
SAME
WAY
AS
YOU
USE
CALLS
ON
STAT
IC
METHODS
AS
STATEMENTS
VOID
METHODS
OR
VALUES
IN
EXPRESSIONS
METHODS
THAT
RE
TURN
A
VALUE
THE
PRIMARY
PURPOSE
OF
STAT
IC
METHODS
IS
TO
IMPLEMENT
FUNCTIONS
THE
PRIMARY
PURPOSE
OF
NON
STATIC
INSTANCE
METHODS
IS
TO
IMPLEMENT
DATA
TYPE
OPERA
TIONS
EITHER
TYPE
OF
METHOD
MAY
APPEAR
IN
CLIENT
CODE
BUT
YOU
CAN
EASILY
DISTINGUISH
BETWEEN
THEM
BECAUSE
A
STATIC
METHOD
CALL
STARTS
WITH
A
CLASS
NAME
UPPERCASE
BY
PARAMETERS
REFERENCE
TO
OBJECT
AND
ARGUMENT
ARGUMENT
CONVENTION
AND
A
NON
STATIC
METHOD
CALL
ALWAYS
STARTS
WITH
AN
OBJECT
NAME
LOWER
PRIMARY
PURPOSE
EXAMINE
OR
CHANGE
OBJECT
VALUE
COMPUTE
RETURN
VALUE
CASE
BY
CONVENTION
THESE
DIFFERENCES
ARE
SUMMARIZED
IN
THE
TABLE
AT
RIGHT
INSTANCE
METHODS
VERSUS
STATIC
METHODS
USING
OBJECTS
DECLARATIONS
GIVE
US
VARIABLE
NAMES
FOR
OBJECTS
THAT
WE
CAN
USE
IN
CODE
NOT
JUST
TO
CREATE
OBJECTS
AND
INVOKE
INSTANCE
METHODS
BUT
ALSO
IN
THE
SAME
WAY
AS
WE
USE
VARIABLE
NAMES
FOR
INTEGERS
FLOATING
POINT
NUMBERS
AND
OTHER
PRIMITIVE
TYPES
TO
DEVELOP
CLIENT
CODE
FOR
A
GIVEN
DATA
TYPE
W
DECLARE
VARIABLES
OF
THE
TYPE
FOR
USE
IN
REFERRING
TO
OBJECTS
USE
THE
KEYWORD
NEW
TO
INVOKE
A
CONSTRUCTOR
THAT
CREATES
OBJECTS
OF
THE
TYPE
USE
THE
OBJECT
NAME
TO
INVOKE
INSTANCE
METHODS
EITHER
AS
STATEMENTS
OR
WITHIN
EXPRESSIONS
FOR
EXAMPLE
THE
CLASS
FLIPS
SHOWN
AT
THE
TOP
OF
THE
NEXT
PAGE
IS
A
COUNTER
CLIENT
THAT
TAKES
A
COMMAND
LINE
ARGUMENT
T
AND
SIMULATES
T
COIN
FLIPS
IT
IS
ALSO
A
STDRANDOM
CLI
ENT
BEYOND
THESE
DIRECT
USES
WE
CAN
USE
VARIABLES
ASSOCIATED
WITH
OBJECTS
IN
THE
SAME
WAY
AS
WE
USE
VARIABLES
ASSOCIATED
WITH
PRIMITIVE
TYPE
VALUES
IN
ASSIGNMENT
STATEMENTS
TO
PASS
OR
RETURN
OBJECTS
FROM
METHODS
TO
CREATE
AND
USE
ARRAYS
OF
OBJECT
UNDERSTANDING
THE
BEHAVIOR
OF
EACH
OF
THESE
TYPES
OF
USES
REQUIRES
THINKING
IN
TERMS
OF
REFERENCES
NOT
VALUES
AS
YOU
WILL
SEE
WHEN
WE
CONSIDER
THEM
IN
TURN
ASSIGNMENT
STATEMENTS
AN
ASSIGNMENT
STATEMENT
WITH
A
REFERENCE
TYPE
CREATES
A
COPY
OF
THE
REFERENCE
THE
ASSIGNMENT
STATEMENT
DOES
NOT
CREATE
A
NEW
OBJECT
JUST
ANOTHER
REFERENCE
TO
AN
EXISTING
OBJECT
THIS
SITUATION
IS
KNOWN
AS
ALIASING
BOTH
VARIABLES
REFER
TO
THE
SAME
OBJECT
THE
EFFECT
OF
ALIASING
IS
A
BIT
UNEXPECTED
BECAUSE
IT
IS
DIFFERENT
FOR
VARIABLES
HOLDING
VALUES
OF
A
PRIMITIVE
TYPE
BE
SURE
THAT
YOU
UNDERSTAND
THE
DIFFERENCE
IF
X
AND
Y
ARE
VARIABLES
OF
A
PRIMITIVE
TYPE
THEN
THE
AS
SIGNMENT
X
Y
COPIES
THE
VALUE
OF
Y
TO
X
FOR
REFERENCE
TYPES
THE
REFERENCE
IS
COPIED
NOT
THE
VALUE
ALIASING
IS
A
COMMON
SOURCE
OF
BUGS
IN
JAVA
PROGRAMS
AS
ILLUSTRATED
BY
THE
FOLLOWING
EXAMPLE
COUNTER
NEW
COUNTER
ONES
INCREMENT
COUNTER
INCREMENT
STDOUT
PRINTLN
WITH
A
TYPICAL
TOSTRING
IMPLEMENTATION
THIS
CODE
WOULD
PRINT
THE
STRING
ONES
WHICH
MAY
OR
MAY
NOT
BE
WHAT
WAS
INTENDED
AND
IS
COUNTERINTUITIVE
AT
FIRST
SUCH
BUGS
ARE
COMMON
IN
PROGRAMS
WRITTEN
BY
PEOPLE
WITHOUT
COUNTER
NEW
COUNTER
ONES
INCREMENT
COUNTER
INCREMENT
REFERENCES
TO
SAME
OBJECT
MUCH
EXPERIENCE
IN
USING
OBJECTS
THAT
MAY
BE
YOU
SO
PAY
ATTENTION
HERE
CHANGING
THE
STATE
OF
AN
OBJECT
IMPACTS
ALL
CODE
INVOLVING
ALIASED
VARIABLES
REFERENCING
THAT
OB
JECT
WE
ARE
USED
TO
THINKING
OF
TWO
DIFFERENT
VARIABLES
OF
PRIMITIVE
TYPES
AS
BEING
INDEPENDENT
BUT
THAT
INTUITION
DOES
NOT
CARRY
OVER
TO
VARIABLES
OF
REFERENCE
TYPES
ALIASING
REFERENCE
TO
ONES
OBJECTS
AS
ARGUMENTS
YOU
CAN
PASS
OBJECTS
AS
ARGUMENTS
TO
METHODS
THIS
ABILITY
TYPI
CALLY
SIMPLIFIES
CLIENT
CODE
FOR
EXAMPLE
WHEN
WE
USE
A
COUNTER
AS
AN
ARGUMENT
WE
ARE
ESSENTIALLY
PASSING
BOTH
A
NAME
AND
A
TALLY
BUT
NEED
ONLY
SPECIFY
ONE
VARIABLE
WHEN
WE
CALL
A
METHOD
WITH
ARGUMENTS
THE
EFFECT
IN
JAVA
IS
AS
IF
EACH
ARGUMENT
VALUE
WERE
TO
APPEAR
ON
THE
RIGHT
HAND
SIDE
OF
AN
ASSIGNMENT
STATEMENT
WITH
THE
CORRESPONDING
ARGUMENT
NAME
ON
THE
LEFT
THAT
IS
JAVA
PASSES
A
COPY
OF
THE
ARGUMENT
VALUE
FROM
THE
CALLING
PROGRAM
TO
THE
METHOD
THIS
ARRANGEMENT
IS
KNOWN
AS
PASS
BY
VALUE
SEE
PAGE
ONE
IMPORTANT
CONSEQUENCE
IS
THAT
THE
METHOD
CANNOT
CHANGE
THE
VALUE
OF
A
CALLER
VARIABLE
FOR
PRIMITIVE
TYPES
THIS
POLICY
IS
WHAT
WE
EXPECT
THE
TWO
VARIABLES
ARE
INDE
PENDENT
BUT
EACH
TIME
THAT
WE
USE
A
REFERENCE
TYPE
AS
A
METHOD
ARGUMENT
WE
CREATE
AN
ALIAS
SO
WE
MUST
BE
CAUTIOUS
IN
OTHER
WORDS
THE
CONVENTION
IS
TO
PASS
THE
REFERENCE
BY
VALUE
MAKE
A
COPY
OF
IT
BUT
TO
PASS
THE
OBJECT
BY
REFERENCE
FOR
EXAMPLE
IF
WE
PASS
A
REFERENCE
TO
AN
OBJECT
OF
TYPE
COUNTER
THE
METHOD
CANNOT
CHANGE
THE
ORIGINAL
REFER
ENCE
MAKE
IT
POINT
TO
A
DIFFERENT
COUNTER
BUT
IT
CAN
CHANGE
THE
VALUE
OF
THE
OBJECT
FOR
EXAMPLE
BY
USING
THE
REFERENCE
TO
CALL
INCREMENT
OBJECTS
AS
RETURN
VALUES
NATURALLY
YOU
CAN
ALSO
USE
AN
OBJECT
AS
A
RETURN
VALUE
FROM
A
METHOD
THE
METHOD
MIGHT
RETURN
AN
OBJECT
PASSED
TO
IT
AS
AN
ARGUMENT
AS
IN
THE
EXAMPLE
BELOW
OR
IT
MIGHT
CREATE
AN
OBJECT
AND
RETURN
A
REFERENCE
TO
IT
THIS
CAPA
BILITY
IS
IMPORTANT
BECAUSE
JAVA
METHODS
ALLOW
ONLY
ONE
RETURN
VALUE
USING
OBJECTS
ENABLES
US
TO
WRITE
CODE
THAT
IN
EFFECT
RETURNS
MULTIPLE
VALUES
ARRAYS
ARE
OBJECTS
IN
JAVA
EVERY
VALUE
OF
ANY
NONPRIMITIVE
TYPE
IS
AN
OBJECT
IN
PAR
TICULAR
ARRAYS
ARE
OBJECTS
AS
WITH
STRINGS
THERE
IS
SPECIAL
LANGUAGE
SUPPORT
FOR
CERTAIN
OPERATIONS
ON
ARRAYS
DECLARATIONS
INITIALIZATION
AND
INDEXING
AS
WITH
ANY
OTHER
OB
JECT
WHEN
WE
PASS
AN
ARRAY
TO
A
METHOD
OR
USE
AN
ARRAY
VARIABLE
ON
THE
RIGHT
HAND
SIDE
OF
AN
ASSIGNMENT
STATEMENT
WE
ARE
MAKING
A
COPY
OF
THE
ARRAY
REFERENCE
NOT
A
COPY
OF
THE
ARRAY
THIS
CONVENTION
IS
APPROPRIATE
FOR
THE
TYPICAL
CASE
WHERE
WE
EXPECT
THE
METHOD
TO
BE
ABLE
TO
MODIFY
THE
ARRAY
BY
REARRANGING
ITS
ENTRIES
AS
FOR
EXAMPLE
IN
JAVA
UTIL
ARRAYS
SORT
OR
THE
SHUFFLE
METHOD
THAT
WE
CONSIDERED
ON
PAGE
ARRAYS
OF
OBJECTS
ARRAY
ENTRIES
CAN
BE
OF
ANY
TYPE
AS
WE
HAVE
ALREADY
SEEN
ARGS
IN
OUR
MAIN
IMPLEMENTATIONS
IS
AN
ARRAY
OF
STRING
OBJECTS
WHEN
WE
CREATE
AN
ARRAY
OF
OBJECTS
WE
DO
SO
IN
TWO
STEPS
CREATE
THE
ARRAY
USING
THE
BRACKET
SYNTAX
FOR
ARRAY
CONSTRUCTORS
CREATE
EACH
OBJECT
IN
THE
ARRAY
USING
A
STANDARD
CONSTRUCTOR
FOR
EACH
FOR
EXAMPLE
THE
CODE
BELOW
SIMULATES
ROLLING
A
DIE
USING
AN
ARRAY
OF
COUNTER
OBJECTS
TO
KEEP
TRACK
OF
THE
NUMBER
OF
OCCURRENCES
OF
EACH
POSSIBLE
VALUE
AN
ARRAY
OF
OBJECTS
IN
JAVA
IS
AN
ARRAY
OF
REFERENCES
TO
OBJECTS
NOT
THE
OBJECTS
THEMSELVES
IF
THE
OBJECTS
ARE
LARGE
THEN
WE
MAY
GAIN
EFFICIENCY
BY
NOT
HAVING
TO
MOVE
THEM
AROUND
JUST
THEIR
REFER
ENCES
IF
THEY
ARE
SMALL
WE
MAY
LOSE
EFFICIENCY
BY
HAVING
TO
FOLLOW
A
REFERENCE
EACH
TIME
WE
NEED
TO
GET
TO
SOME
INFORMATION
WITH
THIS
FOCUS
ON
OBJECTS
WRITING
CODE
THAT
EMBRACES
DATA
ABSTRACTION
DEFINING
AND
USING
DATA
TYPES
WITH
DATA
TYPE
VALUES
HELD
IN
OBJECTS
IS
WIDELY
REFERRED
TO
AS
OBJECT
ORIENTED
PROGRAMMING
THE
BASIC
CONCEPTS
THAT
WE
HAVE
JUST
COVERED
ARE
THE
START
ING
POINT
FOR
OBJECT
ORIENTED
PROGRAMMING
SO
IT
IS
WORTHWHILE
TO
BRIEFLY
SUMMARIZE
THEM
A
DATA
TYPE
IS
A
SET
OF
VALUES
AND
A
SET
OF
OPERATIONS
DEFINED
ON
THOSE
VALUES
WE
IMPLEMENT
DATA
TYPES
IN
INDEPENDENT
JAVA
CLASS
MODULES
AND
WRITE
CLIENT
PROGRAMS
THAT
USE
THEM
AN
OBJECT
IS
AN
ENTITY
THAT
CAN
TAKE
ON
A
DATA
TYPE
VALUE
OR
AN
INSTANCE
OF
A
DATA
TYPE
OBJECTS
ARE
CHARACTERIZED
BY
THREE
ESSENTIAL
PROPERTIES
STATE
IDENTITY
AND
BEHAVIOR
A
DATA
TYPE
IMPLEMENTATION
SUPPORTS
CLIENTS
OF
THE
DATA
TYPE
AS
FOLLOWS
CLIENT
CODE
CAN
CREATE
OBJECTS
ESTABLISH
IDENTITY
BY
USING
THE
NEW
CONSTRUCT
TO
INVOKE
A
CONSTRUCTOR
THAT
CREATES
AN
OBJECT
INITIALIZES
ITS
INSTANCE
VARIABLES
AND
RETURNS
A
REFERENCE
TO
THAT
OBJECT
CLIENT
CODE
CAN
MANIPULATE
DATA
TYPE
VALUES
CONTROL
AN
OBJECT
BEHAVIOR
POS
SIBLY
CHANGING
ITS
STATE
BY
USING
A
VARIABLE
ASSOCIATED
WITH
AN
OBJECT
TO
INVOKE
AN
INSTANCE
METHOD
THAT
OPERATES
ON
THAT
OBJECT
INSTANCE
VARIABLES
CLIENT
CODE
CAN
MANIPULATE
OBJECTS
BY
CREATING
ARRAYS
OF
OBJECTS
AND
PASSING
THEM
AND
RETURNING
THEM
TO
METHODS
IN
THE
SAME
WAY
AS
FOR
PRIMITIVE
TYPE
VALUES
EXCEPT
THAT
VARIABLES
REFER
TO
REFERENCES
TO
VALUES
NOT
THE
VALUES
THEMSELVES
THESE
CAPABILITIES
ARE
THE
FOUNDATION
OF
A
FLEXIBLE
MODERN
AND
WIDELY
USEFUL
PROGRAM
MING
STYLE
THAT
WE
WILL
USE
AS
THE
BASIS
FOR
STUDYING
ALGORITHMS
IN
THIS
BOOK
EXAMPLES
OF
ABSTRACT
DATA
TYPES
THE
JAVA
LANGUAGE
HAS
THOUSANDS
OF
BUILT
IN
ADTS
AND
WE
HAVE
DEFINED
MANY
OTHER
ADTS
TO
FACILITATE
THE
STUDY
OF
ALGORITHMS
IN
DEED
EVERY
JAVA
PROGRAM
THAT
WE
WRITE
IS
A
DATA
TYPE
IMPLEMENTATION
OR
A
LIBRARY
OF
STATIC
METHODS
TO
CONTROL
COMPLEXITY
WE
WILL
SPECIFICALLY
CITE
APIS
FOR
ANY
ADT
THAT
WE
USE
IN
THIS
BOOK
NOT
MANY
ACTUALLY
IN
THIS
SECTION
WE
INTRODUCE
AS
EXAMPLES
SEVERAL
DATA
TYPES
WITH
SOME
EXAMPLES
OF
CLIENT
CODE
IN
SOME
CASES
WE
PRESENT
EXCERPTS
OF
APIS
THAT
MAY
CONTAIN
DOZENS
OF
INSTANCE
METHODS
OR
MORE
WE
ARTICULATE
THESE
APIS
TO
PRESENT
REAL
WORLD
EXAMPLES
TO
SPECIFY
THE
INSTANCE
METHODS
THAT
WE
WILL
USE
IN
THE
BOOK
AND
TO
EMPHASIZE
THAT
YOU
DO
NOT
NEED
TO
KNOW
THE
DETAILS
OF
AN
ADT
IMPLEMENTATION
IN
ORDER
TO
BE
ABLE
TO
USE
IT
FOR
REFERENCE
THE
DATA
TYPES
THAT
WE
USE
AND
DEVELOP
IN
THIS
BOOK
ARE
SHOWN
ON
THE
FACING
PAGE
THESE
FALL
INTO
SEVERAL
DIFFERENT
CATEGORIES
STANDARD
SYSTEM
ADTS
IN
JAVA
LANG
WHICH
CAN
BE
USED
IN
ANY
JAVA
PROGRAM
JAVA
ADTS
IN
LIBRARIES
SUCH
AS
JAVA
AWT
JAVA
NET
AND
JAVA
IO
WHICH
CAN
ALSO
BE
USED
IN
ANY
JAVA
PROGRAM
BUT
NEED
AN
IMPORT
STATEMENT
OUR
I
O
ADTS
THAT
ALLOW
US
TO
WORK
WITH
MULTIPLE
INPUT
OUTPUT
STREAMS
SIMILAR
TO
STDIN
AND
STDOUT
DATA
ORIENTED
ADTS
WHOSE
PRIMARY
PURPOSE
IS
TO
FACILITATE
ORGANIZING
AND
PRO
CESSING
DATA
BY
ENCAPSULATING
THE
REPRESENTATION
WE
DESCRIBE
SEVERAL
EXAMPLES
FOR
APPLICATIONS
IN
COMPUTATIONAL
GEOMETRY
AND
INFORMATION
PROCESSING
LATER
IN
THIS
SECTION
AND
USE
THEM
AS
EXAMPLES
IN
CLIENT
CODE
LATER
ON
COLLECTION
ADTS
WHOSE
PRIMARY
PURPOSE
IS
TO
FACILITATE
MANIPULATION
COLLECTIONS
OF
DATA
OF
THE
SAME
WE
DESCRIBE
THE
BASIC
BAG
STACK
AND
QUEUE
TYPES
IN
SEC
TION
PQ
TYPES
IN
CHAPTER
AND
THE
ST
AND
SET
TYPES
IN
CHAPTERS
AND
OPERTIONS
ORIENTED
ADTS
THAT
WE
USE
TO
ANALYZE
ALGORITHMS
AS
DESCRIBED
IN
SEC
TION
AND
SECTION
ADTS
FOR
GRAPH
ALGORITHMS
INCLUDING
BOTH
DATA
ORIENTED
ADTS
THAT
FOCUS
ON
ENCAPSULATING
REPRESENTATIONS
OF
VARIOUS
KINDS
OF
GRAPHS
AND
OPERATIONS
ORIENT
ED
ADTS
THAT
FOCUS
ON
PROVIDING
SPECIFICATIONS
FOR
GRAPH
PROCESSING
ALGORITHMS
THIS
LIST
DOES
NOT
INCLUDE
THE
DOZENS
OF
TYPES
THAT
WE
CONSIDER
IN
EXERCISES
WHICH
MAY
BE
FOUND
IN
THE
INDEX
ALSO
AS
DESCRIBED
ON
PAGE
WE
OFTEN
DISTINGUISH
MULTIPLE
IMPLE
MENTATIONS
OF
VARIOUS
ADTS
WITH
A
DESCRIPTIVE
PREFIX
AS
A
GROUP
THE
ADTS
THAT
WE
USE
DEMONSTRATE
THAT
ORGANIZING
AND
UNDERSTANDING
THE
DATA
TYPES
THAT
YOU
USE
IS
AN
IMPORTANT
FACTOR
IN
MODERN
PROGRAMMING
A
TYPICAL
APPLICATION
MIGHT
USE
ONLY
FIVE
TO
TEN
OF
THESE
ADTS
A
PRIME
GOAL
IN
THE
DEVELOPMENT
AND
ORGANIZATION
OF
THE
ADTS
IN
THIS
BOOK
IS
TO
ENABLE
PROGRAMMERS
TO
EASILY
TAKE
ADVANTAGE
OF
A
RELATIVELY
SMALL
SET
OF
THEM
IN
DEVELOPING
CLIENT
CODE
STANDARD
JAVA
SYSTEM
TYPES
IN
JAVA
LANG
INTEGER
INT
WRAPPER
DOUBLE
DOUBLE
WRAPPER
STRING
INDEXED
CHARS
STRINGBUILDER
BUILDER
FOR
STRINGS
OTHER
JAVA
TYPES
JAVA
AWT
COLOR
COLORS
JAVA
AWT
FONT
FONTS
JAVA
NET
URL
URLS
JAVA
IO
FILE
FILES
OUR
STANDARD
I
O
TYPES
IN
INPUT
STREAM
OUT
OUTPUT
STREAM
DRAW
DRAWING
DATA
ORIENTED
TYPES
FOR
CLIENT
EXAMPLES
POINT
IN
THE
PLANE
INTERVAL
INTERVAL
DATE
DATE
TRANSACTION
TRANSACTION
TYPES
FOR
THE
ANALYSIS
OF
ALGORITHMS
COUNTER
COUNTER
ACCUMULATOR
ACCUMULATOR
VISUALACCUMULATOR
VISUAL
VERSION
STOPWATCH
STOPWATCH
COLLECTION
TYPES
STACK
PUSHDOWN
STACK
QUEUE
FIFO
QUEUE
BAG
BAG
MINPQ
MAXPQ
PRIORITY
QUEUE
INDEXMINPQ
INDEXMINPQ
PRIORITY
QUEUE
INDEXED
ST
SYMBOL
TABLE
SET
SET
STRINGST
SYMBOL
TABLE
STRING
KEYS
DATA
ORIENTED
GRAPH
TYPES
GRAPH
GRAPH
DIGRAPH
DIRECTED
GRAPH
EDGE
EDGE
WEIGHTED
EDGEWEIGHTEDGRAPH
GRAPH
WEIGHTED
DIRECTEDEDGE
EDGE
DIRECTED
WEIGHTED
EDGEWEIGHTEDDIGRAPH
GRAPH
DIRECTED
WEIGHTED
OPERATIONS
ORIENTED
GRAPH
TYPES
UF
DYNAMIC
CONNECTIVITY
DEPTHFIRSTPATHS
DFS
PATH
SEARCHER
CC
CONNECTED
COMPONENTS
BREADTHFIRSTPATHS
BFS
PATH
SEARCH
DIRECTEDDFS
DFS
DIGRAPH
PATH
SEARCH
DIRECTEDBFS
BFS
DIGRAPH
PATH
SEARCH
TRANSITIVECLOSURE
ALL
PATHS
TOPOLOGICAL
TOPOLOGICAL
ORDER
DEPTHFIRSTORDER
DFS
ORDER
DIRECTEDCYCLE
CYCLE
SEARCH
SCC
STRONG
COMPONENTS
MST
MINIMUM
SPANNING
TREE
SP
SHORTEST
PATHS
SELECTED
ADTS
USED
IN
THIS
BOOK
GEOMETRIC
OBJECTS
A
NATURAL
EXAMPLE
OF
OBJECT
ORIENTED
PROGRAMMING
IS
DESIGN
ING
DATA
TYPES
FOR
GEOMETRIC
OBJECTS
FOR
EXAMPLE
THE
APIS
ON
THE
FACING
PAGE
DEFINE
ABSTRACT
DATA
TYPES
FOR
THREE
FAMILIAR
GEOMETRIC
OBJECTS
POINTS
IN
THE
PLANE
INTERVALS
ON
THE
LINE
AND
TWO
DIMENSIONAL
INTERVALS
IN
THE
PLANE
OR
AXIS
ALIGNED
RECTANGLES
AS
USUAL
THE
APIS
ARE
ESSENTIALLY
SELF
DOCUMENTING
AND
LEAD
IMMEDIATELY
TO
EASILY
UNDER
STOOD
CLIENT
CODE
SUCH
AS
THE
EXAMPLE
AT
LEFT
WHICH
READS
THE
BOUNDARIES
OF
AN
AND
AN
INTEGER
T
FROM
THE
COMMAND
LINE
GENERATES
T
RANDOM
POINTS
IN
THE
UNIT
SQUARE
AND
COUNTS
THE
NUMBER
OF
POINTS
THAT
FALL
IN
THE
INTERVAL
AN
ESTIMATE
OF
THE
AREA
OF
THE
RECTANGLE
FOR
DRAMATIC
EFFECT
THE
CLIENT
ALSO
DRAWS
THE
INTERVAL
AND
THE
POINTS
THAT
FALL
OUTSIDE
THE
INTER
VAL
THIS
COMPUTATION
IS
A
MODEL
FOR
A
METHOD
THAT
REDUCES
THE
PROBLEM
OF
COMPUTING
THE
AREA
AND
VOLUME
TEST
CLIENT
JAVA
HITS
OF
GEOMETRIC
SHAPES
TO
THE
PROBLEM
OF
DETERMINING
WHETHER
A
POINT
FALLS
WITHIN
THE
SHAPE
OR
NOT
A
LESS
DIFFICULT
BUT
NOT
TRIVIAL
PROB
LEM
OF
COURSE
WE
CAN
DEFINE
APIS
FOR
OTHER
GEOMETRIC
OB
JECTS
SUCH
AS
LINE
SEGMENTS
TRIANGLES
POLYGONS
CIRCLES
AND
SO
FORTH
THOUGH
IMPLEMENTING
OPERATIONS
ON
THEM
CAN
BE
CHALLENGING
SEVERAL
EXAMPLES
ARE
ADDRESSED
IN
THE
EXERCISES
AT
THE
END
OF
THIS
SECTION
PROGRAMS
THAT
PROCESS
GEOMETRIC
OBJECTS
HAVE
WIDE
APPLICATION
IN
COMPUTING
WITH
MODELS
OF
THE
NATURAL
WORLD
IN
SCIENTIFIC
COMPUTING
VIDEO
GAMES
MOVIES
AND
MANY
OTHER
APPLICATIONS
THE
DEVELOPMENT
AND
STUDY
OF
SUCH
PRO
GRAMS
AND
APPLICATIONS
HAS
BLOSSOMED
INTO
A
FAR
REACHING
FIELD
OF
STUDY
KNOWN
AS
COMPUTATIONAL
GEOMETRY
WHICH
IS
A
PUBLIC
CLASS
DOUBLE
X
DOUBLE
Y
CREATE
A
POINT
DOUBLE
X
X
COORDINATE
DOUBLE
Y
Y
COORDINATE
DOUBLE
R
RADIUS
POLAR
COORDINATES
DOUBLE
THETA
ANGLE
POLAR
COORDINATES
DOUBLE
DISTTO
THAT
EUCLIDEAN
DISTANCE
FROM
THIS
POINT
TO
THAT
VOID
DRAW
DRAW
THE
POINT
ON
STDDRAW
AN
API
FOR
POINTS
IN
THE
PLANE
PUBLIC
CLASS
DOUBLE
LO
DOUBLE
HI
CREATE
AN
INTERVAL
DOUBLE
LENGTH
LENGTH
OF
THE
INTERVAL
BOOLEAN
CONTAINS
DOUBLE
X
DOES
THE
INTERVAL
CONTAIN
X
BOOLEAN
INTERSECTS
THAT
DOES
THE
INTERVAL
INTERSECT
THAT
VOID
DRAW
DRAW
THE
INTERVAL
ON
STDDRAW
AN
API
FOR
INTERVALS
ON
THE
LINE
PUBLIC
CLASS
X
Y
CREATE
A
INTERVAL
DOUBLE
AREA
AREA
OF
THE
INTERVAL
BOOLEAN
CONTAINS
POINT
P
DOES
THE
INTERVAL
CONTAIN
P
BOOLEAN
INTERSECTS
THAT
DOES
THE
INTERVAL
INTERSECT
THAT
VOID
DRAW
DRAW
THE
INTERVAL
ON
STDDRAW
AN
API
FOR
TWO
DIMENSIONAL
INTERVALS
IN
THE
PLANE
FERTILE
AREA
OF
EXAMPLES
FOR
THE
APPLICATION
OF
THE
ALGORITHMS
THAT
WE
ADDRESS
IN
THIS
BOOK
AS
YOU
WILL
SEE
IN
EXAMPLES
THROUGHOUT
THE
BOOK
IN
THE
PRESENT
CONTEXT
OUR
INTEREST
IS
TO
SUGGEST
THAT
ABSTRACT
DATA
TYPES
THAT
DIRECTLY
REPRESENT
GEOMETRIC
ABSTRAC
TIONS
ARE
NOT
DIFFICULT
TO
DEFINE
AND
CAN
LEAD
TO
SIMPLE
AND
CLEAR
CLIENT
CODE
THIS
IDEA
IS
REINFORCED
IN
SEVERAL
EXERCISES
AT
THE
END
OF
THIS
SECTION
AND
ON
THE
BOOKSITE
INFORMATION
PROCESSING
WHETHER
IT
BE
A
BANK
PROCESSING
MILLIONS
OF
CREDIT
CARD
TRANS
ACTIONS
OR
A
WEB
ANALYTICS
COMPANY
PROCESSING
BILLIONS
OF
TOUCHPAD
TAPS
OR
A
SCIEN
TIFIC
RESEARCH
GROUP
PROCESSING
MILLIONS
OF
EXPERIMENTAL
OBSERVATIONS
A
GREAT
MANY
APPLICATIONS
ARE
CENTERED
AROUND
PROCESSING
AND
ORGANIZING
INFORMATION
ABSTRACT
DATA
TYPES
PROVIDE
A
NATURAL
MECHANISM
FOR
ORGANIZING
THE
INFORMATION
WITHOUT
GETTING
INTO
DETAILS
THE
TWO
APIS
ON
THE
FACING
PAGE
SUGGEST
A
TYPICAL
APPROACH
FOR
A
COMMER
CIAL
APPLICATION
THE
IDEA
IS
TO
DEFINE
DATA
TYPES
THAT
ALLOW
US
TO
KEEP
INFORMATION
IN
OBJECTS
THAT
CORRESPOND
TO
THINGS
IN
THE
REAL
WORLD
A
DATE
IS
A
DAY
A
MONTH
AND
A
YEAR
AND
A
TRANSACTION
IS
A
CUSTOMER
A
DATE
AND
AN
AMOUNT
THESE
TWO
ARE
JUST
EXAMPLES
WE
MIGHT
ALSO
DEFINE
DATA
TYPES
THAT
CAN
HOLD
DETAILED
INFORMATION
FOR
CUSTOMERS
TIMES
LOCATIONS
GOODS
AND
SERVICES
OR
WHATEVER
EACH
DATA
TYPE
CONSISTS
OF
CONSTRUCTORS
THAT
CREATE
OBJECTS
CONTAINING
THE
DATA
AND
METHODS
FOR
USE
BY
CLIENT
CODE
TO
ACCESS
IT
TO
SIMPLIFY
CLIENT
CODE
WE
PROVIDE
TWO
CONSTRUCTORS
FOR
EACH
TYPE
ONE
THAT
PRESENTS
THE
DATA
IN
ITS
APPROPRIATE
TYPE
AND
ANOTHER
THAT
PARSES
A
STRING
TO
GET
THE
DATA
SEE
EXER
CISE
FOR
DETAILS
AS
USUAL
THERE
IS
NO
REASON
FOR
CLIENT
CODE
TO
KNOW
THE
REP
RESENTATION
OF
THE
DATA
MOST
OFTEN
THE
REASON
TO
ORGANIZE
THE
DATA
IN
THIS
WAY
IS
TO
TREAT
THE
DATA
ASSOCIATED
WITH
AN
OBJECT
AS
A
SINGLE
ENTITY
WE
CAN
MAINTAIN
ARRAYS
OF
TRANSACTION
VALUES
USE
DATE
VALUES
AS
A
ARGUMENT
OR
A
RETURN
VALUE
FOR
A
METHOD
AND
SO
FORTH
THE
FOCUS
OF
SUCH
DATA
TYPES
IS
ON
ENCAPSULATING
THE
DATA
WHILE
AT
THE
SAME
TIME
ENABLING
THE
DEVELOPMENT
OF
CLIENT
CODE
THAT
DOES
NOT
DEPEND
ON
THE
REPRESENTA
TION
OF
THE
DATA
WE
DO
NOT
DWELL
ON
ORGANIZING
INFORMATION
IN
THIS
WAY
EXCEPT
TO
TAKE
NOTE
THAT
DOING
SO
AND
INCLUDING
THE
INHERITED
METHODS
TOSTRING
COMPARETO
EQUALS
AND
HASHCODE
ALLOWS
US
TO
TAKE
ADVANTAGE
OF
ALGORITHM
IMPLEMENTATIONS
THAT
CAN
PROCESS
ANY
TYPE
OF
DATA
WE
WILL
DISCUSS
INHERITED
METHODS
IN
MORE
DETAIL
ON
PAGE
FOR
EXAMPLE
WE
HAVE
ALREADY
NOTED
JAVA
CONVENTION
THAT
ENABLES
CLIENTS
TO
PRINT
A
STRING
REPRESENTATION
OF
EVERY
VALUE
IF
WE
INCLUDE
TOSTRING
IMPLEMEN
TATION
IN
A
DATA
TYPE
WE
CONSIDER
CONVENTIONS
CORRESPONDING
TO
THE
OTHER
INHERITED
METHODS
IN
SECTION
SECTION
SECTION
AND
SECTION
USING
DATE
AND
TRANSACTION
AS
EXAMPLES
SECTION
GIVES
CLASSIC
EXAMPLES
OF
DATA
TYPES
AND
A
JAVA
LANGUAGE
MECHANISM
KNOWN
AS
PARAMETERIZED
TYPES
OR
GENERICS
THAT
TAKES
ADVANTAGE
OF
THESE
CONVENTIONS
AND
CHAPTER
AND
CHAPTER
ARE
ALSO
DEVOTED
TO
TAKING
ADVANTAGE
OF
GENERIC
TYPES
AND
INHERITED
METHODS
TO
DEVELOP
IMPLEMENTATIONS
OF
SORTING
AND
SEARCHING
ALGORITHMS
THAT
ARE
EFFECTIVE
FOR
ANY
TYPE
OF
DATA
WHENEVER
YOU
HAVE
DATA
OF
DIFFERENT
TYPES
THAT
LOGICALLY
BELONG
TOGETHER
IT
IS
WORTHWHILE
TO
CONTEMPLATE
DEFINING
AN
ADT
AS
IN
THESE
EXAMPLES
THE
ABILITY
TO
DO
SO
HELPS
TO
ORGANIZE
THE
DATA
CAN
GREATLY
SIMPLIFY
CLIENT
CODE
IN
TYPICAL
APPLICATIONS
AND
IS
AN
IMPORTANT
STEP
ON
THE
ROAD
TO
DATA
ABSTRACTION
PUBLIC
CLASS
DATE
IMPLEMENTS
COMPARABLE
DATE
DATE
INT
MONTH
INT
DAY
INT
YEAR
CREATE
A
DATE
DATE
STRING
DATE
CREATE
A
DATE
PARSE
CONSTRUCTOR
INT
MONTH
MONTH
INT
DAY
DAY
INT
YEAR
YEAR
STRING
TOSTRING
STRING
REPRESENTATION
BOOLEAN
EQUALS
OBJECT
THAT
IS
THIS
THE
SAME
DATE
AS
THAT
INT
COMPARETO
DATE
THAT
COMPARE
THIS
DATE
TO
THAT
INT
HASHCODE
HASH
CODE
PUBLIC
CLASS
TRANSACTION
IMPLEMENTS
COMPARABLE
TRANSACTION
TRANSACTION
STRING
WHO
DATE
WHEN
DOUBLE
AMOUNT
TRANSACTION
STRING
TRANSACTION
CREATE
A
TRANSACTION
PARSE
CONSTRUCTOR
STRING
WHO
CUSTOMER
NAME
DATE
WHEN
DATE
DOUBLE
AMOUNT
AMOUNT
STRING
TOSTRING
STRING
REPRESENTATION
BOOLEAN
EQUALS
OBJECT
THAT
IS
THIS
THE
SAME
TRANSACTION
AS
THAT
INT
COMPARETO
TRANSACTION
THAT
COMPARE
THIS
TRANSACTION
TO
THAT
INT
HASHCODE
HASH
CODE
SAMPLE
APIS
FOR
COMMERCIAL
APPLICATIONS
DATES
AND
TRANSACTIONS
STRINGS
JAVA
STRING
IS
AN
IMPORTANT
AND
USEFUL
ADT
A
STRING
IS
AN
INDEXED
SE
QUENCE
OF
CHAR
VALUES
STRING
HAS
DOZENS
OF
INSTANCE
METHODS
INCLUDING
THE
FOLLOWING
PUBLIC
CLASS
STRING
STRING
CREATE
AN
EMPTY
STRING
INT
LENGTH
LENGTH
OF
THE
STRING
INT
CHARAT
INT
I
ITH
CHARACTER
INT
INDEXOF
STRING
P
FIRST
OCCURRENCE
OF
P
IF
NONE
INT
INDEXOF
STRING
P
INT
I
FIRST
OCCURRENCE
OF
P
AFTER
I
IF
NONE
STRING
CONCAT
STRING
T
THIS
STRING
WITH
T
APPENDED
STRING
SUBSTRING
INT
I
INT
J
SUBSTRING
OF
THIS
STRING
ITH
TO
J
CHARS
STRING
SPLIT
STRING
DELIM
STRINGS
BETWEEN
OCCURRENCES
OF
DELIM
INT
COMPARETO
STRING
T
STRING
COMPARISON
BOOLEAN
EQUALS
STRING
T
IS
THIS
STRING
VALUE
THE
SAME
AS
T
INT
HASHCODE
HASH
CODE
JAVA
STRING
API
PARTIAL
LIST
OF
METHODS
STRING
VALUES
ARE
SIMILAR
TO
ARRAYS
OF
CHARACTERS
BUT
THE
TWO
ARE
NOT
THE
SAME
AR
RAYS
HAVE
BUILT
IN
JAVA
LANGUAGE
SYNTAX
FOR
ACCESSING
A
CHARACTER
STRING
HAS
INSTANCE
METHODS
FOR
INDEXED
ACCESS
LENGTH
AND
MANY
OTHER
OPERATIONS
ON
THE
OTHER
HAND
STRING
HAS
SPECIAL
LANGUAGE
SUPPORT
FOR
INITIALIZATION
AND
CONCATENATION
INSTEAD
OF
CREATING
AND
INITIALIZING
A
STRING
WITH
A
CONSTRUCTOR
WE
CAN
USE
A
STRING
LITERAL
INSTEAD
OF
INVOKING
THE
METHOD
CONCAT
WE
CAN
USE
THE
OPERATOR
WE
DO
NOT
NEED
TO
CON
SIDER
THE
DETAILS
OF
THE
IMPLEMENTATION
THOUGH
UNDERSTANDING
PERFORMANCE
CHARACTERISTICS
OF
SOME
OF
THE
METHODS
IS
IMPORTANT
WHEN
DEVELOP
ING
STRING
PROCESSING
ALGORITHMS
AS
YOU
WILL
SEE
IN
CHAPTER
WHY
NOT
JUST
USE
ARRAYS
OF
CHARAC
STRING
A
NOW
IS
STRING
B
THE
TIME
STRING
C
TO
CALL
VALUE
TERS
INSTEAD
OF
STRING
VALUES
THE
ANSWER
TO
THIS
QUESTION
IS
THE
SAME
AS
FOR
ANY
ADT
TO
SIMPLIFY
AND
CLARIFY
CLIENT
CODE
WITH
STRING
WE
CAN
WRITE
CLEAR
AND
SIMPLE
CLIENT
CODE
THAT
USES
NUMEROUS
CONVENIENT
INSTANCE
METHODS
WITHOUT
REGARD
TO
THE
WAY
IN
WHICH
STRINGS
ARE
REPRESENTED
SEE
FAC
ING
PAGE
EVEN
THIS
SHORT
LIST
CONTAINS
POWERFUL
A
LENGTH
A
CHARAT
A
CONCAT
C
A
INDEXOF
IS
A
SUBSTRING
A
SPLIT
A
SPLIT
B
EQUALS
C
I
NOW
IS
TO
W
I
NOW
IS
FALSE
OPERATIONS
THAT
REQUIRE
ADVANCED
ALGORITHMS
SUCH
EXAMPLES
OF
STRING
OPERATIONS
TASK
IMPLEMENTATION
PUBLIC
STATIC
BOOLEAN
ISPALINDROME
STRING
IS
THE
STRING
A
PALINDROME
INT
N
LENGTH
FOR
INT
I
I
N
I
IF
CHARAT
I
CHARAT
N
I
RETURN
FALSE
RETURN
TRUE
EXTRACT
FILE
NAME
AND
EXTENSION
FROM
A
COMMAND
LINE
ARGUMENT
STRING
ARGS
INT
DOT
RANK
STRING
BASE
SUBSTRING
DOT
STRING
EXTENSION
SUBSTRING
DOT
LENGTH
PRINT
ALL
LINES
IN
STANDARD
INPUT
THAT
CONTAIN
A
STRING
SPECIFIED
ON
THE
COMMAND
LINE
STRING
QUERY
ARGS
WHILE
STDIN
ISEMPTY
STRING
STDIN
READLINE
IF
CONTAINS
QUERY
STDOUT
PRINTLN
CREATE
AN
ARRAY
OF
THE
STRINGS
ON
STDIN
DELIMITED
BY
WHITESPACE
STRING
INPUT
STDIN
READALL
STRING
WORDS
INPUT
SPLIT
PUBLIC
BOOLEAN
ISSORTED
STRING
A
CHECK
WHETHER
AN
ARRAY
OF
STRINGS
IS
IN
ALPHABETICAL
ORDER
FOR
INT
I
I
A
LENGTH
I
IF
A
I
COMPARETO
A
I
RETURN
FALSE
RETURN
TRUE
TYPICAL
STRING
PROCESSING
CODE
AS
THOSE
CONSIDERED
IN
CHAPTER
FOR
EXAMPLE
THE
ARGUMENT
OF
SPLIT
CAN
BE
A
REGULAR
EXPRESSION
SEE
SECTION
THE
SPLIT
EXAMPLE
ON
PAGE
USES
THE
ARGU
MENT
WHICH
MEANS
ONE
OR
MORE
TABS
SPACES
NEWLINES
OR
RETURNS
INPUT
AND
OUTPUT
REVISITED
A
DISADVANTAGE
OF
THE
STDIN
STDOUT
AND
STDDRAW
STAN
DARD
LIBRARIES
OF
SECTION
IS
THAT
THEY
RESTRICT
US
TO
WORKING
WITH
JUST
ONE
INPUT
FILE
ONE
OUTPUT
FILE
AND
ONE
DRAWING
FOR
ANY
GIVEN
PROGRAM
WITH
OBJECT
ORIENTED
PRO
GRAMMING
WE
CAN
DEFINE
SIMILAR
MECHANISMS
THAT
ALLOW
US
TO
WORK
WITH
MULTIPLE
INPUT
STREAMS
OUTPUT
STREAMS
AND
DRAWINGS
WITHIN
ONE
PROGRAM
SPECIFICALLY
OUR
STANDARD
LIBARY
INCLUDES
THE
DATA
TYPES
IN
OUT
AND
DRAW
WITH
THE
APIS
SHOWN
ON
THE
FACING
PAGE
WHEN
INVOKED
WITH
A
CONSTRUCTOR
HAVING
A
STRING
ARGUMENT
IN
AND
OUT
WILL
FIRST
TRY
TO
FIND
A
FILE
IN
THE
CURRENT
DIRECTORY
OF
YOUR
COMPUTER
THAT
HAS
THAT
NAME
IF
IT
CANNOT
DO
SO
IT
WILL
ASSUME
THE
ARGU
MENT
TO
BE
A
WEBSITE
NAME
AND
WILL
TRY
TO
CONNECT
TO
THAT
WEB
SITE
IF
NO
SUCH
WEBSITE
EXISTS
IT
WILL
ISSUE
A
RUNTIME
EXCEPTION
IN
EITHER
CASE
THE
SPECIFIED
FILE
OR
WEBSITE
BECOMES
THE
SOURCE
TARGET
OF
THE
INPUT
OUTPUT
FOR
THE
STREAM
OBJECT
THUS
CREATED
AND
THE
READ
AND
PRINT
METHODS
WILL
REFER
TO
THAT
FILE
OR
WEBSITE
IF
YOU
USE
THE
NO
ARGU
MENT
CONSTRUCTOR
THEN
YOU
OB
TAIN
THE
STANDARD
STREAMS
THIS
ARRANGEMENT
MAKES
IT
POSSIBLE
FOR
A
SINGLE
PROGRAM
TO
PROCESS
MULTIPLE
FILES
AND
DRAWINGS
YOU
ALSO
CAN
ASSIGN
SUCH
OBJECTS
TO
VARIABLES
PASS
THEM
AS
ARGUMENTS
OR
RE
TURN
VALUES
FROM
METHODS
CREATE
ARRAYS
OF
THEM
AND
MANIPULATE
THEM
JUST
AS
YOU
MANIPULATE
OBJECTS
OF
ANY
TYPE
THE
PROGRAM
CAT
SHOWN
AT
LEFT
IS
A
SAMPLE
CLIENT
OF
IN
AND
OUT
THAT
USES
MULTIPLE
INPUT
STREAMS
TO
CONCATENATE
SEVERAL
INPUT
FILES
INTO
A
SINGLE
OUT
PUT
FILE
THE
IN
AND
OUT
CLASSES
ALSO
CONTAIN
STATIC
METHODS
FOR
READING
FILES
CONTAINING
VALUES
THAT
ARE
ALL
INT
DOUBLE
OR
STRING
TYPES
INTO
AN
ARRAY
SEE
PAGE
AND
EXERCISE
PUBLIC
CLASS
IN
IN
CREATE
AN
INPUT
STREAM
FROM
STANDARD
INPUT
IN
STRING
NAME
CREATE
AN
INPUT
STREAM
FROM
A
FILE
OR
WEBSITE
BOOLEAN
ISEMPTY
TRUE
IF
NO
MORE
INPUT
FALSE
OTHERWISE
INT
READINT
READ
A
VALUE
OF
TYPE
INT
DOUBLE
READDOUBLE
READ
A
VALUE
OF
TYPE
DOUBLE
VOID
CLOSE
CLOSE
THE
INPUT
STREAM
NOTE
ALL
OPERATIONS
SUPPORTED
BY
STDIN
ARE
ALSO
SUPPORTED
FOR
IN
OBJECTS
API
FOR
OUR
DATA
TYPE
FOR
INPUT
STREAMS
PUBLIC
CLASS
OUT
OUT
CREATE
AN
OUTPUT
STREAM
TO
STANDARD
OUTPUT
OUT
STRING
NAME
CREATE
AN
OUTPUT
STREAM
TO
A
FILE
VOID
PRINT
STRING
APPEND
TO
THE
OUTPUT
STREAM
VOID
PRINTLN
STRING
APPEND
AND
A
NEWLINE
TO
THE
OUTPUT
STREAM
VOID
PRINTLN
APPEND
A
NEWLINE
TO
THE
OUTPUT
STREAM
VOID
PRINTF
STRING
F
FORMATTED
PRINT
TO
THE
OUTPUT
STEAM
VOID
CLOSE
CLOSE
THE
OUTPUT
STREAM
NOTE
ALL
OPERATIONS
SUPPORTED
BY
STDOUT
ARE
ALSO
SUPPORTED
FOR
OUT
OBJECTS
API
FOR
OUR
DATA
TYPE
FOR
OUTPUT
STREAMS
PUBLIC
CLASS
DRAW
DRAW
VOID
LINE
DOUBLE
DOUBLE
DOUBLE
DOUBLE
VOID
POINT
DOUBLE
X
DOUBLE
Y
NOTE
ALL
OPERATIONS
SUPPORTED
BY
STDDRAW
ARE
ALSO
SUPPORTED
FOR
DRAW
OBJECTS
API
FOR
OUR
DATA
TYPE
FOR
DRAWINGS
IMPLEMENTING
AN
ABSTRACT
DATA
TYPE
AS
WITH
LIBRARIES
OF
STATIC
METHODS
WE
IMPLEMENT
ADTS
WITH
A
JAVA
CLASS
PUTTING
THE
CODE
IN
A
FILE
WITH
THE
SAME
NAME
AS
THE
CLASS
FOLLOWED
BY
THE
JAVA
EXTENSION
THE
FIRST
STATEMENTS
IN
THE
FILE
DECLARE
IN
STANCE
VARIABLES
THAT
DEFINE
THE
DATA
TYPE
VALUES
FOLLOWING
THE
INSTANCE
VARIABLES
ARE
THE
CONSTRUCTOR
AND
THE
INSTANCE
METHODS
THAT
IMPLEMENT
OPERATIONS
ON
DATA
TYPE
VALUES
INSTANCE
METHODS
MAY
BE
PUBLIC
SPECIFIED
IN
THE
API
OR
PRIVATE
USED
TO
ORGANIZE
THE
COMPUTATION
AND
NOT
AVAILABLE
TO
CLIENTS
A
DATA
TYPE
DEFINITION
MAY
HAVE
MULTIPLE
CONSTRUCTORS
AND
MAY
ALSO
INCLUDE
DEFINITIONS
OF
STATIC
METHODS
IN
PARTICULAR
A
UNIT
TEST
CLIENT
MAIN
IS
NORMALLY
USEFUL
FOR
TESTING
AND
DEBUGGING
AS
A
FIRST
EXAMPLE
WE
CONSIDER
AN
IMPLEMENTATION
OF
THE
COUNTER
ADT
THAT
WE
DEFINED
ON
PAGE
A
FULL
ANNOTATED
IMPLEMENTATION
IS
SHOWN
ON
THE
FACING
PAGE
FOR
REFERENCE
AS
WE
DISCUSS
ITS
CONSTITUENT
PARTS
EVERY
ADT
IMPLEMENTATION
THAT
YOU
WILL
DEVELOP
HAS
THE
SAME
BASIC
INGREDIENTS
AS
THIS
SIMPLE
EXAMPLE
INSTANCE
VARIABLES
TO
DEFINE
DATA
TYPE
VALUES
THE
STATE
OF
EACH
OBJECT
WE
DE
INSTANCE
VARIABLE
PUBLIC
CLASS
COUNTER
PRIVATE
FINAL
STRING
NAME
PRIVATE
INT
COUNT
CLARE
INSTANCE
VARIABLES
IN
MUCH
THE
SAME
WAY
AS
WE
DECLARE
LOCAL
VARIABLES
THERE
IS
A
CRITICAL
DISTINCTION
BETWEEN
INSTANCE
VARI
ABLES
AND
THE
LOCAL
VARIABLES
WITHIN
A
STATIC
DECLARATIONS
INSTANCE
VARIABLES
IN
ADTS
ARE
PRIVATE
METHOD
OR
A
BLOCK
THAT
YOU
ARE
ACCUSTOMED
TO
THERE
IS
JUST
ONE
VALUE
CORRESPONDING
TO
EACH
LOCAL
VARIABLE
AT
A
GIVEN
TIME
BUT
THERE
ARE
NUMEROUS
VALUES
CORRESPONDING
TO
EACH
INSTANCE
VARIABLE
ONE
FOR
EACH
OBJECT
THAT
IS
AN
INSTANCE
OF
THE
DATA
TYPE
THERE
IS
NO
AMBIGUITY
WITH
THIS
ARRANGEMENT
BECAUSE
EACH
TIME
THAT
WE
ACCESS
AN
INSTANCE
VARIABLE
WE
DO
SO
WITH
AN
OBJECT
NAME
THAT
OBJECT
IS
THE
ONE
WHOSE
VALUE
WE
ARE
ACCESSING
ALSO
EACH
DECLARATION
IS
QUALIFIED
BY
A
VISIBILITY
MODIFIER
IN
ADT
IMPLEMENTATIONS
WE
USE
PRIVATE
USING
A
JAVA
LANGUAGE
MECHANSIM
TO
ENFORCE
THE
IDEA
THAT
THE
REPRESENTA
TION
OF
AN
ADT
IS
TO
BE
HIDDEN
FROM
THE
CLIENT
AND
ALSO
FINAL
IF
THE
VALUE
IS
NOT
TO
BE
CHANGED
ONCE
IT
IS
INITIALIZED
COUNTER
HAS
TWO
INSTANCE
VARIABLES
A
STRING
VALUE
NAME
AND
AN
INT
VALUE
COUNT
IF
WE
WERE
TO
USE
PUBLIC
INSTANCE
VARIABLES
ALLOWED
IN
JAVA
THE
DATA
TYPE
WOULD
BY
DEFINITION
NOT
BE
ABSTRACT
SO
WE
DO
NOT
DO
SO
CONSTRUCTORS
EVERY
JAVA
CLASS
HAS
AT
LEAST
ONE
CONSTRUCTOR
THAT
ESTABLISHES
AN
OBJECT
IDENTITY
A
CONSTRUCTOR
IS
LIKE
A
STATIC
METHOD
BUT
IT
CAN
REFER
DIRECTLY
TO
INSTANCE
VARI
ABLES
AND
HAS
NO
RETURN
VALUE
GENERALLY
THE
PURPOSE
OF
A
CONSTRUCTOR
IS
TO
INITIALIZE
THE
INSTANCE
VARIABLES
EVERY
CONSTRUCTOR
CREATES
AN
OBJECT
AND
PROVIDES
TO
THE
CLIENT
A
REFERENCE
TO
THAT
OBJECT
CONSTRUCTORS
ALWAYS
SHARE
THE
SAME
NAME
AS
THE
CLASS
WE
CAN
OVERLOAD
THE
NAME
AND
HAVE
MULTIPLE
CONSTRUCTORS
WITH
DIFFERENT
SIGNATURES
JUST
AS
WITH
METHODS
IF
NO
OTHER
CONSTRUCTOR
IS
DEFINED
A
DEFAULT
NO
ARGUMENT
CONSTRUCTOR
IS
PUBLIC
CLASS
COUNTER
CLASS
INSTANCE
VARIABLES
CONSTRUCTOR
PRIVATE
FINAL
STRING
NAME
PRIVATE
INT
COUNT
PUBLIC
COUNTER
STRING
ID
NAME
ID
NAME
INSTANCE
METHODS
PUBLIC
STRING
TOSTRING
RETURN
COUNT
NAME
INSTANCE
VARIABLE
NAME
TEST
CLIENT
CREATE
AND
INITIALIZE
OBJECTS
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
COUNTER
HEADS
NEW
COUNTER
HEADS
COUNTER
TAILS
NEW
INVOKE
HEADS
INCREMENT
HEADS
INCREMENT
TAILS
INCREMENT
CONSTRUCTOR
AUTOMATICALLY
INVOKE
TOSTRING
OBJECT
STDOUT
PRINTLN
HEADS
TAILS
NAME
STDOUT
PRINTLN
HEADS
TALLY
TAILS
TALLY
INVOKE
METHOD
ANATOMY
OF
A
CLASS
THAT
DEFINES
A
DATA
TYPE
IMPLICIT
HAS
NO
ARGUMENTS
AND
INITIALIZES
INSTANCE
VALUES
TO
DEFAULT
VALUES
THE
DEFAULT
VALUES
OF
INSTANCE
VARIABLES
ARE
FOR
PRIMITIVE
NUMERIC
TYPES
FALSE
FOR
BOOLEAN
AND
NULL
FOR
REFERENCE
TYPES
THESE
DEFAULTS
MAY
BE
CHANGED
BY
USING
INITIALIZING
DECLARATIONS
FOR
INSTANCE
VARIABLES
JAVA
AUTOMATICALLY
INVOKES
A
CONSTRUCTOR
WHEN
A
CLIENT
PROGRAM
USES
THE
KEYWORD
PUBLIC
CLASS
COUNTER
PRIVATE
FINAL
STRING
NAME
PRIVATE
INT
COUNT
NEW
OVERLOADED
CONSTRUCTORS
ARE
TYPI
CALLY
USED
TO
INITIALIZE
INSTANCE
VARIABLES
TO
CLIENT
SUPPLIED
VALUES
OTHER
THAN
THE
DEFAULTS
FOR
EXAMPLE
COUNTER
HAS
A
ONE
ARGUMENT
CONSTRUCTOR
THAT
INITIAL
VISIBILITY
MODIFIER
NO
RETURN
TYPE
CONSTRUCTOR
NAME
SAME
AS
CLASS
NAME
PARAMETER
VARIABLE
SIGNATURE
IZES
THE
NAME
INSTANCE
VARIABLE
TO
THE
VALUE
GIVEN
AS
ARGUMENT
LEAVING
THE
COUNT
INSTANCE
VARIABLE
TO
BE
INITIALIZED
TO
THE
DEFAULT
VALUE
CODE
TO
INITIALIZE
INSTANCE
VARIABLES
COUNT
INITIALIZED
TO
BY
DEFAULT
ANATOMY
OF
A
CONSTRUCTOR
INSTANCE
METHODS
TO
IMPLEMENT
DATA
TYPE
INSTANCE
METHODS
THE
BEHAVIOR
OF
EACH
OBJECT
WE
IMPLEMENT
INSTANCE
METHODS
WITH
CODE
THAT
IS
PRECISELY
LIKE
THE
CODE
THAT
YOU
LEARNED
IN
SECTION
TO
IMPLEMENT
STATIC
METHODS
FUNCTIONS
EACH
INSTANCE
METHOD
HAS
A
RETURN
TYPE
A
SIGNATURE
WHICH
SPECIFIES
ITS
NAME
AND
THE
TYPES
AND
NAMES
OF
ITS
PARAMETER
VARIABLES
AND
A
BODY
WHICH
CONSISTS
OF
A
SEQUENCE
OF
STATEMENTS
IN
CLUDING
A
RETURN
STATEMENT
THAT
PROVIDES
A
VALUE
OF
THE
RETURN
TYPE
BACK
TO
THE
CLI
ENT
WHEN
A
CLIENT
INVOKES
A
METHOD
THE
VISIBILITY
RETURN
MODIFIER
TYPE
METHOD
NAME
SIGNATURE
PARAMETER
VALUES
IF
ANY
ARE
INITIALIZED
WITH
CLIENT
VALUES
THE
STATEMENTS
ARE
EX
ECUTED
UNTIL
A
RETURN
VALUE
IS
COMPUTED
AND
THE
VALUE
IS
RETURNED
TO
THE
CLIENT
WITH
THE
SAME
EFFECT
AS
IF
THE
METHOD
IN
COUNT
INSTANCE
VARIABLE
NAME
ANATOMY
OF
AN
INSTANCE
METHOD
VOCATION
IN
THE
CLIENT
WERE
REPLACED
WITH
THAT
VALUE
ALL
OF
THIS
ACTION
IS
THE
SAME
AS
FOR
STATIC
METHODS
BUT
THERE
IS
ONE
CRITICAL
DISTINCTION
FOR
INSTANCE
METHODS
THEY
CAN
ACCESS
AND
PERFORM
OPERATIONS
ON
INSTANCE
VARIABLES
HOW
DO
WE
SPECIFY
WHICH
OBJECT
INSTANCE
VARIABLES
WE
WANT
TO
USE
IF
YOU
THINK
ABOUT
THIS
QUESTION
FOR
A
MOMENT
YOU
WILL
SEE
THE
LOGICAL
ANSWER
A
REFERENCE
TO
A
VARIABLE
IN
AN
INSTANCE
METHOD
REFERS
TO
THE
VALUE
FOR
THE
OBJECT
THAT
WAS
USED
TO
INVOKE
THE
METHOD
WHEN
WE
SAY
HEADS
INCREMENT
THE
CODE
IN
INCREMENT
IS
REFERRING
TO
THE
INSTANCE
VARIABLES
FOR
HEADS
IN
OTHER
WORDS
OBJECT
ORIENTED
PROGRAMMING
ADDS
ONE
CRITICALLY
IMPORTANT
ADDITIONAL
WAY
TO
USE
VARI
ABLES
IN
A
JAVA
PROGRAM
TO
INVOKE
AN
INSTANCE
METHOD
THAT
OPERATES
ON
THE
OBJECT
VALUES
THE
DIFFERENCE
FROM
WORKING
SOLELY
WITH
STATIC
METHODS
IS
SEMANTIC
SEE
THE
Q
A
BUT
HAS
REORIENTED
THE
WAY
THAT
MODERN
PROGRAMMERS
THINK
ABOUT
DEVELOPING
CODE
IN
MANY
SITUATIONS
AS
YOU
WILL
SEE
IT
ALSO
DOVETAILS
WELL
WITH
THE
STUDY
OF
ALGORITHMS
AND
DATA
STRUCTURES
SCOPE
IN
SUMMARY
THE
JAVA
CODE
THAT
WE
WRITE
TO
IMPLEMENT
INSTANCE
METHODS
USES
THREE
KINDS
OF
VARIABLES
PARAMETER
VARIABLES
LOCAL
VARIABLES
INSTANCE
VARIABLES
THE
FIRST
TWO
OF
THESE
ARE
THE
SAME
AS
FOR
STATIC
METHODS
PARAMETER
VARIABLES
ARE
SPEC
IFIED
IN
THE
METHOD
SIGNATURE
AND
INITIALIZED
WITH
CLIENT
VALUES
WHEN
THE
METHOD
IS
CALLED
AND
LOCAL
VARIABLES
ARE
DECLARED
AND
INITIALIZED
WITHIN
THE
METHOD
BODY
THE
SCOPE
OF
PARAMETER
VARIABLES
IS
THE
ENTIRE
METHOD
THE
SCOPE
OF
LOCAL
VARIABLES
IS
THE
FOLLOWING
STATEMENTS
IN
THE
BLOCK
WHERE
THEY
ARE
DEFINED
INSTANCE
VARIABLES
ARE
COM
PLETELY
DIFFERENT
THEY
HOLD
DATA
TYPE
VALUES
FOR
OBJECTS
IN
A
CLASS
AND
THEIR
SCOPE
IS
THE
ENTIRE
CLASS
WHENEVER
THERE
IS
AN
AMBIGUITY
YOU
CAN
USE
THE
THIS
PREFIX
TO
IDENTIFY
IN
STANCE
VARIABLES
UNDERSTANDING
THE
DISTINCTIONS
AMONG
THESE
THREE
KINDS
OF
VARIABLES
IN
INSTANCE
METHODS
IS
A
KEY
TO
SUCCESS
IN
OBJECT
ORIENTED
PROGRAMMING
PUBLIC
CLASS
EXAMPLE
INSTANCE
VARIABLE
PRIVATE
INT
VAR
PRIVATE
VOID
LOCAL
VARIABLE
INT
VAR
REFERS
TO
LOCAL
VARIABLE
NOT
INSTANCE
VARIABLE
VAR
THIS
VAR
REFERS
TO
INSTANCE
VARIABLE
PRIVATE
VOID
VAR
REFERS
TO
INSTANCE
VARIABLE
SCOPE
OF
INSTANCE
AND
LOCAL
VARIABLES
IN
AN
INSTANCE
METHOD
API
CLIENTS
AND
IMPLEMENTATIONS
THESE
ARE
THE
BASIC
COMPONENTS
THAT
YOU
NEED
TO
UNDERSTAND
TO
BE
ABLE
TO
BUILD
AND
USE
ABSTRACT
DATA
TYPES
IN
JAVA
EVERY
ADT
IM
PLEMENTATION
THAT
WE
WILL
CONSIDER
WILL
BE
A
JAVA
CLASS
WITH
PRIVATE
INSTANCE
VARIABLES
CONSTRUCTORS
INSTANCE
METHODS
AND
A
CLIENT
TO
FULLY
UNDERSTAND
A
DATA
TYPE
WE
NEED
THE
API
TYPICAL
CLIENT
CODE
AND
AN
IMPLEMENTATION
SUMMARIZED
FOR
COUNTER
ON
THE
FACING
PAGE
TO
EMPHASIZE
THE
SEPARATION
OF
CLIENT
AND
IMPLEMENTATION
WE
NORMALLY
PRESENT
EACH
CLIENT
AS
A
SEPARATE
CLASS
CONTAINING
A
STATIC
METHOD
MAIN
AND
RESERVE
TEST
CLIENT
MAIN
IN
THE
DATA
TYPE
DEFINITION
FOR
MINIMAL
UNIT
TESTING
AND
DEVELOP
MENT
CALLING
EACH
INSTANCE
METHOD
AT
LEAST
ONCE
IN
EACH
DATA
TYPE
THAT
WE
DEVELOP
WE
GO
THROUGH
THE
SAME
STEPS
RATHER
THAN
THINKING
ABOUT
WHAT
ACTION
WE
NEED
TO
TAKE
NEXT
TO
ACCOMPLISH
A
COMPUTATIONAL
GOAL
AS
WE
DID
WHEN
FIRST
LEARNING
TO
PROGRAM
WE
THINK
ABOUT
THE
NEEDS
OF
A
CLIENT
THEN
ACCOMMODATE
THEM
IN
AN
ADT
FOLLOWING
THESE
THREE
STEPS
SPECIFY
AN
API
THE
PURPOSE
OF
THE
API
IS
TO
SEPARATE
CLIENTS
FROM
IMPLEMENTA
TIONS
TO
ENABLE
MODULAR
PROGRAMMING
WE
HAVE
TWO
GOALS
WHEN
SPECIFYING
AN
API
FIRST
WE
WANT
TO
ENABLE
CLEAR
AND
CORRECT
CLIENT
CODE
INDEED
IT
IS
A
GOOD
IDEA
TO
WRITE
SOME
CLIENT
CODE
BEFORE
FINALIZING
THE
API
TO
GAIN
CONFIDENCE
THAT
THE
SPECIFIED
DATA
TYPE
OPERATIONS
ARE
THE
ONES
THAT
CLIENTS
NEED
SECOND
WE
WANT
TO
BE
ABLE
TO
IMPLEMENT
THE
OPERATIONS
THERE
IS
NO
POINT
SPECIFYING
OPERA
TIONS
THAT
WE
HAVE
NO
IDEA
HOW
TO
IMPLEMENT
IMPLEMENT
A
JAVA
CLASS
THAT
MEETS
THE
API
SPECIFICATIONS
FIRST
WE
CHOOSE
THE
INSTANCE
VARIABLES
THEN
WE
WRITE
CONSTRUCTORS
AND
THE
INSTANCE
METHODS
DEVELOP
MULTIPLE
TEST
CLIENTS
TO
VALIDATE
THE
DESIGN
DECISIONS
MADE
IN
THE
FIRST
TWO
STEPS
WHAT
OPERATIONS
DO
CLIENTS
NEED
TO
PERFORM
AND
WHAT
DATA
TYPE
VALUES
CAN
BEST
SUP
PORT
THOSE
OPERATIONS
THESE
BASIC
DECISIONS
ARE
AT
THE
HEART
OF
EVERY
IMPLEMENTATION
THAT
WE
DEVELOP
API
TYPICAL
CLIENT
PUBLIC
CLASS
COUNTER
COUNTER
STRING
ID
CREATE
A
COUNTER
NAMED
ID
VOID
INCREMENT
INCREMENT
THE
COUNTER
INT
TALLY
NUMBER
OF
INCREMENTS
SINCE
CREATION
STRING
TOSTRING
STRING
REPRESENTATION
IMPLEMENTATION
APPLICATION
AN
ABSTRACT
DATA
TYPE
FOR
A
SIMPLE
COUNTER
MORE
ADT
IMPLEMENTATIONS
AS
WITH
ANY
PROGRAMMING
CONCEPT
THE
BEST
WAY
TO
UNDERSTAND
THE
POWER
AND
UTILITY
OF
ADTS
IS
TO
CONSIDER
CAREFULLY
MORE
EXAMPLES
AND
MORE
IMPLEMENTATIONS
THERE
WILL
BE
AMPLE
OPPORTUNITY
FOR
YOU
TO
DO
SO
AS
MUCH
OF
THIS
BOOK
IS
DEVOTED
TO
ADT
IMPLEMENTATIONS
BUT
A
FEW
MORE
SIMPLE
EXAMPLES
WILL
HELP
US
LAY
THE
GROUNDWORK
FOR
ADDRESSING
THEM
DATE
SHOWN
ON
THE
FACING
PAGE
ARE
TWO
IMPLEMENTATIONS
OF
THE
DATE
ADT
THAT
WE
CON
SIDERED
ON
PAGE
TO
REDUCE
CLUTTER
WE
OMIT
THE
PARSING
CONSTRUCTOR
WHICH
IS
DESCRIBED
ANDTHEINHERITEDMETHODSEQUALS
COMPARETO
SEE
PAGE
AND
HASHCODE
SEE
EXERCISE
THE
STRAIGHTFORWARD
IMPLEMENTATION
ON
THE
LEFT
MAINTAINS
THE
DAY
MONTH
AND
YEAR
AS
INSTANCE
VARIABLES
SO
THAT
THE
INSTANCE
METHODS
CAN
JUST
RETURN
THE
APPROPRIATE
VALUE
THE
MORE
SPACE
EFFICIENT
IMPLEMENTA
TION
ON
THE
RIGHT
USES
ONLY
A
SINGLE
INT
VALUE
TO
REPRESENT
A
DATE
USING
A
MIXED
RADIX
NUMBER
THAT
REPRESENTS
THE
DATE
WITH
DAY
D
MONTH
M
AND
YEAR
Y
AS
D
ONE
WAY
THAT
A
CLIENT
MIGHT
NOTICE
THE
DIFFERENCE
BETWEEN
THESE
IMPLEMENTATIONS
IS
BY
VIOLATING
IMPLICIT
ASSUMPTIONS
THE
SECOND
IMPLEMENTATION
DEPENDS
FOR
ITS
CORRECTNESS
ON
THE
DAY
BEING
BETWEEN
AND
THE
MONTH
BEING
BETWEEN
AND
AND
THE
YEAR
BE
ING
POSITIVE
IN
PRACTICE
BOTH
IMPLEMENTATIONS
SHOULD
CHECK
THAT
MONTHS
ARE
BETWEEN
AND
DAYS
ARE
BETWEEN
AND
AND
THAT
DATES
SUCH
AS
JUNE
AND
FEBRUARY
ARE
ILLEGAL
THOUGH
THAT
REQUIRES
A
BIT
MORE
WORK
THIS
EXAMPLE
HIGHLIGHTS
THE
IDEA
THAT
WE
RARELY
FULLY
SPECIFY
IMPLEMENTATION
REQUIREMENTS
IN
AN
API
WE
NORMALLY
DO
THE
BEST
WE
CAN
AND
COULD
DO
BETTER
HERE
ANOTHER
WAY
THAT
A
CLIENT
MIGHT
NOTICE
THE
DIFFERENCE
BETWEEN
THE
TWO
IMPLEMENTATIONS
IS
PERFORMANCE
THE
IMPLEMENTATION
ON
THE
RIGHT
USES
LESS
SPACE
TO
HOLD
DATA
TYPE
VALUES
AT
THE
COST
OF
MORE
TIME
TO
PROVIDE
THEM
TO
THE
CLIENT
IN
THE
AGREED
FORM
ONE
OR
TWO
ARITHMETIC
OPERATIONS
ARE
NEEDED
SUCH
TRAD
EOFFS
ARE
COMMON
ONE
CLIENT
MAY
PREFER
ONE
OF
THE
IMPLEMENTATIONS
AND
ANOTHER
CLIENT
MIGHT
PREFER
THE
OTHER
SO
WE
NEED
TO
ACCOMMODATE
BOTH
INDEED
ONE
OF
THE
RECURRING
THEMES
OF
THIS
BOOK
IS
THAT
WE
NEED
TO
UNDERSTAND
THE
SPACE
AND
TIME
REQUIREMENTS
OF
VARIOUS
IMPLEMENTATIONS
AND
THEIR
SUITABILITY
FOR
USE
BY
VARIOUS
CLIENTS
ONE
OF
THE
KEY
ADVANTAGES
OF
USING
DATA
ABSTRACTION
IN
OUR
IMPLEMENTATIONS
IS
THAT
WE
CAN
NORMALLY
CHANGE
FROM
ONE
IMPLEMENTATION
TO
ANOTHER
WITHOUT
CHANGING
ANY
CLIENT
CODE
MAINTAINING
MULTIPLE
IMPLEMENTATIONS
MULTIPLE
IMPLEMENTATIONS
OF
THE
SAME
API
CAN
PRESENT
MAINTAINENCE
AND
NOMENCLATURE
ISSUES
IN
SOME
CASES
WE
SIMPLY
WANT
TO
REPLACE
AN
OLD
IMPLEMENTATION
WITH
AN
IMPROVED
ONE
IN
OTHERS
WE
MAY
NEED
TO
MAIN
TAIN
TWO
IMPLEMENTATIONS
ONE
SUITABLE
FOR
SOME
CLIENTS
THE
OTHER
SUITABLE
FOR
OTHERS
INDEED
A
PRIME
GOAL
OF
THIS
BOOK
IS
TO
CONSIDER
IN
DEPTH
SEVERAL
IMPLEMENTATIONS
OF
EACH
OF
A
NUMBER
OF
FUNDAMENTAL
ADTS
GENERALLY
WITH
DIFFERENT
PERFORMANCE
CHARAC
TERISTICS
IN
THIS
BOOK
WE
OFTEN
COMPARE
THE
PERFORMANCE
OF
A
SINGLE
CLIENT
USING
TWO
TEST
CLIENT
IMPLEMENTATION
APPLICATION
ALTERNATE
IMPLEMENTATION
AN
ABSTRACT
DATA
TYPE
TO
ENCAPSULATE
DATES
WITH
TWO
IMPLEMENTATIONS
DIFFERENT
IMPLEMENTATIONS
OF
THE
SAME
API
FOR
THIS
REASON
WE
GENERALLY
ADOPT
AN
IN
FORMAL
NAMING
CONVENTION
WHERE
WE
IDENTIFY
DIFFERENT
IMPLEMENTATIONS
OF
THE
SAME
API
BY
PREPENDING
A
DESCRIP
TIVE
MODIFIER
FOR
EXAMPLE
WE
MIGHT
NAME
OUR
DATE
IMPLEMENTATIONS
ON
THE
PREVIOUS
PAGE
BASICDATE
AND
SMALLDATE
AND
WE
MIGHT
WISH
TO
DEVELOP
A
SMARTDATE
IMPLEMENTATION
THAT
CAN
VALIDATE
THAT
DATES
ARE
LEGAL
MAINTAIN
A
REFERENCE
IMPLEMENTATION
WITH
NO
PREFIX
THAT
MAKES
A
CHOICE
THAT
SHOULD
BE
SUITABLE
FOR
MOST
CLIENTS
THAT
IS
MOST
CLIENTS
SHOULD
JUST
USE
DATE
IN
A
LARGE
SYSTEM
THIS
SOLUTION
IS
NOT
IDEAL
AS
IT
MIGHT
INVOLVE
CHANGING
CLIENT
CODE
FOR
EXAMPLE
IF
WE
WERE
TO
DEVELOP
A
NEW
IMPLEMENTATION
EXTRASMALLDATE
THEN
OUR
ONLY
OPTIONS
ARE
TO
CHANGE
CLIENT
CODE
OR
TO
MAKE
IT
THE
REFERENCE
IMPLEMENTATION
FOR
USE
BY
ALL
CLIENTS
JAVA
HAS
VARIOUS
ADVANCED
LANGUAGE
MECHANISMS
FOR
MAINTAINING
MULTIPLE
IMPLEMENTATIONS
WITHOUT
NEEDING
TO
CHANGE
CLIENT
CODE
BUT
WE
USE
THEM
SPARINGLY
BECAUSE
THEIR
USE
IS
CHALLENGING
AND
EVEN
CONTROVERSIAL
EVEN
FOR
EXPERTS
ESPECIALLY
IN
CONJUCTION
WITH
OTHER
ADVANCED
LANGUAGE
FEATURES
THAT
WE
DO
VALUE
GENERICS
AND
ITERA
TORS
THESE
ISSUES
ARE
IMPORTANT
FOR
EXAMPLE
IGNORING
THEM
LED
TO
THE
CELEBRATED
PROBLEM
AT
THE
TURN
OF
THE
MILLENNIUM
BECAUSE
MANY
PROGRAMS
USED
THEIR
OWN
IMPLE
MENTATIONS
OF
THE
DATE
ABSTRACTION
THAT
DID
NOT
TAKE
INTO
ACCOUNT
THE
FIRST
TWO
DIGITS
OF
THE
YEAR
BUT
DETAILED
CONSIDERATION
OF
THESE
ISSUES
WOULD
TAKE
US
RATHER
FAR
AFIELD
FROM
THE
STUDY
OF
ALGORITHMS
ACCUMULATOR
THE
ACCUMULATOR
API
SHOWN
ON
THE
FACING
PAGE
DEFINES
AN
ABSTRACT
DATA
TYPE
THAT
PROVIDES
TO
CLIENTS
THE
ABILITY
TO
MAINTAIN
A
RUNNING
AVERAGE
OF
DATA
VALUES
FOR
EXAMPLE
WE
USE
THIS
DATA
TYPE
FREQUENTLY
IN
THIS
BOOK
TO
PROCESS
EXPERIMENTAL
RESULTS
SEE
SECTION
THE
IMPLEMENTATION
IS
STRAIGHTFORWARD
IT
MAINTAINS
A
INT
INSTANCE
VARIABLE
COUNTS
THE
NUMBER
OF
DATA
VALUES
SEEN
SO
FAR
AND
A
DOUBLE
INSTANCE
VARIABLE
THAT
KEEPS
TRACK
OF
THE
SUM
OF
THE
VALUES
SEEN
SO
FAR
TO
COMPUTE
THE
AVERAGE
IT
DIVIDES
THE
SUM
BY
THE
COUNT
NOTE
THAT
THE
IMPLEMENTATION
DOES
NOT
SAVE
THE
DATA
VALUES
IT
COULD
BE
USED
FOR
A
HUGE
NUMBER
OF
THEM
EVEN
ON
A
DEVICE
THAT
IS
NOT
CAPABLE
OF
HOLDING
THAT
MANY
OR
A
HUGE
NUMBER
OF
ACCUMULATORS
COULD
BE
USED
ON
A
BIG
SYSTEM
THIS
PERFORMANCE
CHARACTERISTIC
IS
SUBTLE
AND
MIGHT
BE
SPECIFIED
IN
THE
API
BECAUSE
AN
IMPLEMENTATION
THAT
DOES
SAVE
THE
VALUES
MIGHT
CAUSE
AN
APPLICATION
TO
RUN
OUT
OF
MEMORY
API
TYPICAL
CLIENT
APPLICATION
IMPLEMENTATION
AN
ABSTRACT
DATA
TYPE
FOR
ACCUMULATING
DATA
VALUES
VISUAL
ACCUMULATOR
THE
VISUAL
ACCUMULATOR
IMPLEMENTATION
SHOWN
ON
THE
FACING
PAGE
EXTENDS
ACCUMULATOR
TO
PRESENT
A
USEFUL
SIDE
EFFECT
IT
DRAWS
ON
STDDRAW
ALL
THE
DATA
IN
GRAY
AND
THE
RUNNING
AVERAGE
IN
RED
THE
EASIEST
WAY
TO
DO
SO
IS
TO
ADD
A
CONSTRUCTOR
THAT
PROVIDES
THE
NUMBER
OF
POINTS
TO
BE
PLOTTED
AND
THE
MAXIMUM
VALUE
FOR
RESCALING
THE
PLOT
VISUALACCUMULATOR
IS
NOT
TECHNICALLY
AN
IMPLE
MENTATION
OF
THE
ACCUMULATOR
API
ITS
CONSTRUC
TOR
HAS
A
DIFFERENT
SIGNATURE
AND
IT
CAUSES
A
DIFFER
ENT
PRESCRIBED
SIDE
EFFECT
GENERALLY
WE
ARE
CAREFUL
TO
FULLY
SPECIFY
APIS
AND
ARE
LOATH
TO
MAKE
ANY
CHANGES
IN
AN
API
ONCE
ARTICULATED
AS
IT
MIGHT
HEIGHT
OF
NTH
RED
DOT
FROM
THE
LEFT
IS
THE
AVERAGE
OF
THE
HEIGHTS
OF
THE
LEFTMOST
N
GRAY
DOTS
HEIGHT
OF
GRAY
DOT
IS
THE
DATA
POINT
VALUE
VISUAL
ACCUMULATOR
PLOT
INVOLVE
CHANGING
AN
UNKNOWN
AMOUNT
OF
CLIENT
AND
IMPLEMENTATION
CODE
BUT
ADD
ING
A
CONSTRUCTOR
TO
GAIN
FUNCTIONALITY
CAN
SOMETIMES
BE
DEFENDED
BECAUSE
IT
INVOLVES
CHANGING
THE
SAME
LINE
IN
CLIENT
CODE
THAT
WE
CHANGE
WHEN
CHANGING
A
CLASS
NAME
IN
THIS
EXAMPLE
IF
WE
HAVE
DEVELOPED
A
CLIENT
THAT
USES
AN
ACCUMULATOR
AND
PERHAPS
HAS
MANY
CALLS
TO
ADDDATAVALUE
AND
AVG
WE
CAN
ENJOY
THE
BENEFITS
OF
VISUALACCUMULATOR
BY
JUST
CHANGING
ONE
LINE
OF
CLIENT
CODE
APPLICATION
JAVA
TESTVISUALACCUMULATOR
MEAN
VALUES
API
TYPICAL
CLIENT
IMPLEMENTATION
AN
ABSTRACT
DATA
TYPE
FOR
ACCUMULATING
DATA
VALUES
VISUAL
VERSION
DATA
TYPE
DESIGN
AN
ABSTRACT
DATA
TYPE
IS
A
DATA
TYPE
WHOSE
REPRESENTATION
IS
HID
DEN
FROM
THE
CLIENT
THIS
IDEA
HAS
HAD
A
POWERFUL
EFFECT
ON
MODERN
PROGRAMMING
THE
VARIOUS
EXAMPLES
THAT
WE
HAVE
CONSIDERED
GIVE
US
THE
VOCABULARY
TO
ADDRESS
ADVANCED
CHARACTERISTICS
OF
ADTS
AND
THEIR
IMPLEMENTATION
AS
JAVA
CLASSES
MANY
OF
THESE
TOPICS
ARE
ON
THE
SURFACE
TANGENTIAL
TO
THE
STUDY
OF
ALGORITHMS
SO
IT
IS
SAFE
FOR
YOU
TO
SKIM
THIS
SECTION
AND
REFER
TO
IT
LATER
IN
THE
CONTEXT
OF
SPECIFIC
IMPLEMENTATION
PROBLEMS
OUR
GOAL
IS
TO
PUT
IMPORTANT
INFORMATION
RELATED
TO
DESIGNING
DATA
TYPES
IN
ONE
PLACE
FOR
REFERENCE
AND
TO
SET
THE
STAGE
FOR
IMPLEMENTATIONS
THROUGHOUT
THIS
BOOK
ENCAPSULATION
A
HALLMARK
OF
OBJECT
ORIENTED
PROGRAMMING
IS
THAT
IT
ENABLES
US
TO
ENCAPSULATE
DATA
TYPES
WITHIN
THEIR
IMPLEMENTATIONS
TO
FACILITATE
SEPARATE
DEVELOPMENT
OF
CLIENTS
AND
DATA
TYPE
IMPLEMENTATIONS
ENCAPSULATION
ENABLES
MODULAR
PROGRAM
MING
ALLOWING
US
TO
INDEPENDENTLY
DEVELOP
OF
CLIENT
AND
IMPLEMENTATION
CODE
SUBSTITUTE
IMPROVED
IMPLEMENTATIONS
WITHOUT
AFFECTING
CLIENTS
SUPPORT
PROGRAMS
NOT
YET
WRITTEN
THE
API
IS
A
GUIDE
FOR
ANY
FUTURE
CLIENT
ENCAPSULATION
ALSO
ISOLATES
DATA
TYPE
OPERATIONS
WHICH
LEADS
TO
THE
POSSIBILITY
OF
LIMITING
THE
POTENTIAL
FOR
ERROR
ADDING
CONSISTENCY
CHECKS
AND
OTHER
DEBUGGING
TOOLS
IN
IMPLEMENTATIONS
CLARIFYING
CLIENT
CODE
AN
ENCAPSULATED
DATA
TYPE
CAN
BE
USED
BY
ANY
CLIENT
SO
IT
EXTENDS
THE
JAVA
LANGUAGE
THE
PROGRAMMING
STYLE
THAT
WE
ARE
ADVOCATING
IS
PREDICATED
ON
THE
IDEA
OF
BREAKING
LARGE
PROGRAMS
INTO
SMALL
MODULES
THAT
CAN
BE
DEVELOPED
AND
DEBUGGED
INDEPENDENTLY
THIS
APPROACH
IMPROVES
THE
RESILIENCY
OF
OUR
SOFTWARE
BY
LIMITING
AND
LOCALIZING
THE
EF
FECTS
OF
MAKING
CHANGES
AND
IT
PROMOTES
CODE
REUSE
BY
MAKING
IT
POSSIBLE
TO
SUBSTITUTE
NEW
IMPLEMENTATIONS
OF
A
DATA
TYPE
TO
IMPROVE
PERFORMANCE
ACCURACY
OR
MEMORY
FOOTPRINT
THE
SAME
IDEA
WORKS
IN
MANY
SETTINGS
WE
OFTEN
REAP
THE
BENEFITS
OF
ENCAP
SULATION
WHEN
WE
USE
SYSTEM
LIBRARIES
NEW
VERSIONS
OF
THE
JAVA
SYSTEM
OFTEN
INCLUDE
NEW
IMPLEMENTATIONS
OF
VARIOUS
DATA
TYPES
OR
STATIC
METHOD
LIBRARIES
BUT
THE
APIS
DO
NOT
CHANGE
IN
THE
CONTEXT
OF
THE
STUDY
OF
ALGORITHMS
AND
DATA
STRUCTURES
THERE
IS
STRONG
AND
CONSTANT
MOTIVATION
TO
DEVELOP
BETTER
ALGORITHMS
BECAUSE
WE
CAN
IMPROVE
PERFOR
MANCE
FOR
ALL
CLIENTS
BY
SUBSTITUTING
AN
IMPROVED
ADT
IMPLEMENTATION
WITHOUT
CHANG
ING
THE
CODE
OF
ANY
CLIENT
THE
KEY
TO
SUCCESS
IN
MODULAR
PROGRAMMING
IS
TO
MAINTAIN
INDEPENDENCE
AMONG
MODULES
WE
DO
SO
BY
INSISTING
ON
THE
API
BEING
THE
ONLY
POINT
OF
DEPENDENCE
BETWEEN
CLIENT
AND
IMPLEMENTATION
YOU
DO
NOT
NEED
TO
KNOW
HOW
A
DATA
TYPE
IS
IMPLEMENTED
IN
ORDER
TO
USE
IT
AND
YOU
CAN
ASSUME
THAT
A
CLIENT
KNOWS
NOTHING
BUT
THE
API
WHEN
IMPLEMENTING
A
DATA
TYPE
ENCAPSULATION
IS
THE
KEY
TO
ATTAINING
BOTH
OF
THESE
ADVANTAGES
DESIGNING
APIS
ONE
OF
THE
MOST
IMPORTANT
AND
MOST
CHALLENGING
STEPS
IN
BUILDING
MODERN
SOFTWARE
IS
DESIGNING
APIS
THIS
TASK
TAKES
PRACTICE
CAREFUL
DELIBERATION
AND
MANY
ITERATIONS
BUT
ANY
TIME
SPENT
DESIGNING
A
GOOD
API
IS
CERTAIN
TO
BE
REPAID
IN
TIME
SAVED
DEBUGGING
OR
CODE
REUSE
ARTICULATING
AN
API
MIGHT
SEEM
TO
BE
OVERKILL
WHEN
WRITING
A
SMALL
PROGRAM
BUT
YOU
SHOULD
CONSIDER
WRITING
EVERY
PROGRAM
AS
THOUGH
YOU
WILL
NEED
TO
REUSE
THE
CODE
SOMEDAY
IDEALLY
AN
API
WOULD
CLEARLY
ARTICULATE
BEHAVIOR
FOR
ALL
POSSIBLE
INPUTS
INCLUDING
SIDE
EFFECTS
AND
THEN
WE
WOULD
HAVE
SOFTWARE
TO
CHECK
THAT
IMPLEMENTATIONS
MEET
THE
SPECIFICATION
UNFORTUNATELY
A
FUNDAMENTAL
RESULT
FROM
THEORETICAL
COMPUTER
SCIENCE
KNOWN
AS
THE
SPECIFICATION
PROBLEM
IMPLIES
THAT
THIS
GOAL
IS
ACTUALLY
IMPOSSIBLE
TO
ACHIEVE
BRIEFLY
SUCH
A
SPECIFICATION
WOULD
HAVE
TO
BE
WRITTEN
IN
A
FORMAL
LANGUAGE
LIKE
A
PROGRAMMING
LANGUAGE
AND
THE
PROBLEM
OF
DETERMINING
WHETHER
TWO
PROGRAMS
PERFORM
THE
SAME
COMPUTATION
IS
KNOWN
MATHEMATICALLY
TO
BE
UNDECIDABLE
THEREFORE
OUR
APIS
ARE
BRIEF
ENGLISH
LANGUAGE
DESCRIPTIONS
OF
THE
SET
OF
VALUES
IN
THE
ASSOCIATED
ABSTRACT
DATA
TYPE
ALONG
WITH
A
LIST
OF
CONSTRUCTORS
AND
INSTANCE
METHODS
AGAIN
WITH
BRIEF
ENGLISH
LANGUAGE
DESCRIPTIONS
OF
THEIR
PURPOSE
INCLUDING
SIDE
EFFECTS
TO
VALIDATE
THE
DESIGN
WE
ALWAYS
INCLUDE
EXAMPLES
OF
CLIENT
CODE
IN
THE
TEXT
SURROUNDING
OUR
APIS
WITHIN
THIS
BROAD
OUTLINE
THERE
ARE
NUMEROUS
PITFALLS
THAT
EVERY
API
DESIGN
IS
SUSCEPTIBLE
TO
AN
API
MAY
BE
TOO
HARD
TO
IMPLEMENT
IMPLYING
IMPLEMENTATIONS
THAT
ARE
DIF
FICULT
OR
IMPOSSIBLE
TO
DEVELOP
AN
API
MAY
BE
TOO
HARD
TO
USE
LEADING
TO
CLIENT
CODE
THAT
IS
MORE
COMPLICATED
THAN
IT
WOULD
BE
WITHOUT
THE
API
AN
API
MAY
BE
TOO
NARROW
OMITTING
METHODS
THAT
CLIENTS
NEED
AN
API
MAY
BE
TOO
WIDE
INCLUDING
A
LARGE
NUMBER
OF
METHODS
NOT
NEEDED
BY
ANY
CLIENT
THIS
PITFALL
IS
PERHAPS
THE
MOST
COMMON
AND
ONE
OF
THE
MOST
DIFFICULT
TO
AVOID
THE
SIZE
OF
AN
API
TENDS
TO
GROW
OVER
TIME
BECAUSE
IT
IS
NOT
DIFFICULT
TO
ADD
METHODS
TO
AN
EXISTING
API
BUT
IT
IS
DIFFICULT
TO
REMOVE
METHODS
WITHOUT
BREAKING
EXISTING
CLIENTS
AN
API
MAY
BE
TOO
GENERAL
PROVIDING
NO
USEFUL
ABSTRACTIONS
AN
API
MAY
BE
TOO
SPECIFIC
PROVIDING
ABSTRACTIONS
SO
DETAILED
OR
SO
DIFFUSE
AS
TO
BE
USELESS
AN
API
MAY
BE
TOO
DEPENDENT
ON
A
PARTICULAR
REPRESENTATION
THEREFORE
NOT
SERV
ING
THE
PURPOSE
OF
FREEING
CLIENT
CODE
FROM
THE
DETAILS
OF
USING
THAT
REPRESENTA
TION
THIS
PITFALL
IS
ALSO
DIFFICULT
TO
AVOID
BECAUSE
THE
REPRESENTATION
IS
CERTAINLY
CENTRAL
TO
THE
DEVELOPMENT
OF
THE
IMPLEMENTATION
THESE
CONSIDERATIONS
ARE
SOMETIMES
SUMMARIZED
IN
YET
ANOTHER
MOTTO
PROVIDE
TO
CLI
ENTS
THE
METHODS
THEY
NEED
AND
NO
OTHERS
ALGORITHMS
AND
ABSTRACT
DATA
TYPES
DATA
ABSTRACTION
IS
NATURALLY
SUITED
TO
THE
STUDY
OF
ALGORITHMS
BECAUSE
IT
HELPS
US
PROVIDE
A
FRAMEWORK
WITHIN
WHICH
WE
CAN
PRECISELY
SPECIFY
BOTH
WHAT
AN
ALGORITHM
NEEDS
TO
ACCOMPLISH
AND
HOW
A
CLIENT
CAN
MAKE
USE
OF
AN
ALGORITHM
TYPICALLY
IN
THIS
BOOK
AN
ALGORITHM
IS
AN
IMPLEMENTATION
OF
AN
INSTANCE
METHOD
IN
AN
ABSTRACT
DATA
TYPE
FOR
EXAMPLE
OUR
WHITELISTING
EXAMPLE
AT
THE
BEGIN
NING
OF
THE
CHAPTER
IS
NATURALLY
CAST
AS
AN
ADT
CLIENT
BASED
ON
THE
FOLLOWING
OPERATIONS
CONSTRUCT
A
SET
FROM
AN
ARRAY
OF
GIVEN
VALUES
DETERMINE
WHETHER
A
GIVEN
VALUE
IS
IN
THE
SET
THESE
OPERATIONS
ARE
ENCAPSULATED
IN
THE
STATICSETOFINTS
ADT
SHOWN
ON
THE
FACING
PAGE
ALONG
WITH
WHITELIST
A
TYPICAL
CLIENT
STATICSETOFINTS
IS
A
SPECIAL
CASE
OF
THE
MORE
GENERAL
AND
MORE
USEFUL
SYMBOL
TABLE
ADT
THAT
IS
THE
FOCUS
OF
CHAPTER
BINARY
SEARCH
IS
ONE
OF
SEVERAL
ALGORITHMS
THAT
WE
STUDY
THAT
IS
SUITABLE
FOR
IMPLEMENTING
THESE
ADTS
BY
COMPARISON
WITH
THE
BINARYSEARCH
IMPLEMENTATION
ON
PAGE
THIS
IMPLE
MENTATION
LEADS
TO
CLEARER
AND
MORE
USEFUL
CLIENT
CODE
FOR
EXAMPLE
STATICSETOFINTS
ENFORCES
THE
IDEA
THAT
THE
ARRAY
MUST
BE
SORTED
BEFORE
RANK
IS
CALLED
WITH
THE
ABSTRACT
DATA
TYPE
WE
SEPARATE
THE
CLIENT
FROM
THE
IMPLEMENTATION
MAKING
IT
EASIER
FOR
ANY
CLIENT
TO
BENEFIT
FROM
THE
INGENUITY
OF
THE
BINARY
SEARCH
ALGORITHM
JUST
BY
FOLLOWING
THE
API
CLIENTS
OF
RANK
IN
BINARYSEARCH
HAVE
TO
KNOW
TO
SORT
THE
ARRAY
FIRST
WHITELISTING
IS
ONE
OF
MANY
CLIENTS
THAT
CAN
TAKE
ADVANTAGE
OF
BINARY
SEARCH
EVERY
JAVA
PROGRAM
IS
A
SET
OF
STATIC
METHODS
AND
OR
A
DATA
TYPE
IMPLEMENTATION
IN
THIS
BOOK
WE
FOCUS
PRIMARILY
ON
ABSTRACT
DATA
TYPE
IMPLEMENTATIONS
SUCH
AS
STATICSETOFINTS
WHERE
THE
FOCUS
IS
ON
OPERATIONS
AND
THE
REPRESENTA
TION
OF
THE
DATA
IS
HIDDEN
FROM
THE
CLIENT
AS
THIS
EXAMPLE
ILLUSTRATES
DATA
ABSTRACTION
ENABLES
US
TO
APPLICATION
PRECISELY
SPECIFY
WHAT
ALGORITHMS
CAN
PROVIDE
FOR
CLIENTS
SEPARATE
ALGORITHM
IMPLEMENTATIONS
FROM
THE
CLIENT
CODE
DEVELOP
LAYERS
OF
ABSTRACTION
WHERE
WE
MAKE
USE
OF
WELL
UNDERSTOOD
ALGORITHMS
TO
DEVELOP
OTHER
ALGORITHMS
THESE
ARE
DESIRABLE
PROPERTIES
OF
ANY
APPROACH
TO
DESCRIBING
ALGORITHMS
WHETHER
IT
BE
AN
ENGLISH
LANGUAGE
DESCRIPTION
OR
PSEUDO
CODE
BY
EMBRACING
THE
JAVA
CLASS
MECHA
NISM
IN
SUPPORT
OF
DATA
ABSTRACTION
WE
HAVE
LITTLE
TO
LOSE
AND
MUCH
TO
GAIN
WORKING
CODE
THAT
WE
CAN
TEST
AND
USE
TO
COMPARE
PERFORMANCE
FOR
DIVERSE
CLIENTS
API
PUBLIC
CLASS
STATICSETOFINTS
STATICSETOFINTS
INT
A
CREATE
A
SET
FROM
THE
VALUES
IN
A
BOOLEAN
CONTAINS
INT
KEY
IS
KEY
IN
THE
SET
TYPICAL
CLIENT
IMPLEMENTATION
BINARY
SEARCH
RECAST
AS
AN
OBJECT
ORIENTED
PROGRAM
AN
ADT
FOR
SEARCH
IN
A
SET
OF
INTEGERS
INTERFACE
INHERITANCE
JAVA
PROVIDES
LANGUAGE
SUPPORT
FOR
DEFINING
RELATIONSHIPS
AMONG
OBJECTS
KNOWN
AS
INHERITANCE
THESE
MECHANISMS
ARE
WIDELY
USED
BY
SOFTWARE
DEVELOPERS
SO
YOU
WILL
STUDY
THEM
IN
DETAIL
IF
YOU
TAKE
A
COURSE
IN
SOFTWARE
ENGINEER
ING
THE
FIRST
INHERITANCE
MECHANISM
THAT
WE
CONSIDER
IS
KNOWN
AS
SUBTYPING
WHICH
ALLOWS
US
TO
SPECIFY
A
RELATIONSHIP
BETWEEN
OTHERWISE
UNRELATED
CLASSES
BY
SPECIFYING
IN
AN
INTERFACE
A
SET
OF
COMMON
METHODS
THAT
EACH
IMPLEMENTING
CLASS
MUST
CONTAIN
AN
INTERFACE
IS
NOTHING
MORE
THAN
A
LIST
OF
INSTANCE
METHODS
FOR
EXAMPLE
INSTEAD
OF
USING
OUR
INFORMAL
API
WE
MIGHT
HAVE
ARTICULATED
AN
INTERFACE
FOR
DATE
PUBLIC
INTERFACE
DATABLE
INT
MONTH
INT
DAY
INT
YEAR
AND
THEN
REFERRED
TO
THE
INTERFACE
IN
OUR
IMPLEMENTATION
CODE
PUBLIC
CLASS
DATE
IMPLEMENTS
DATABLE
IMPLEMENTATION
CODE
SAME
AS
BEFORE
SO
THAT
THE
JAVA
COMPILER
WILL
CHECK
THAT
IT
MATCHES
THE
INTERFACE
ADDING
THE
CODE
IMPLEMENTS
DATABLE
TO
ANY
CLASS
THAT
IMPLEMENTS
MONTH
DAY
AND
YEAR
PRO
VIDES
A
GUARANTEE
TO
ANY
CLIENT
THAT
AN
OBJECT
OF
THAT
CLASS
CAN
INVOKE
THOSE
METHODS
THIS
ARRANGEMENT
IS
KNOWN
AS
INTERFACE
INHERITANCE
AN
IMPLEMENTING
CLASS
INHERITS
THE
INTERFACE
INTERFACE
INHERITANCE
ALLOWS
US
TO
WRITE
CLIENT
PROGRAMS
THAT
CAN
MANIPULATE
OBJECTS
OF
ANY
TYPE
THAT
IMPLEMENTS
THE
INTERFACE
EVEN
A
TYPE
TO
BE
CREAT
ED
IN
THE
FUTURE
BY
INVOKING
METH
ODS
IN
THE
INTERFACE
WE
MIGHT
HAVE
USED
INTERFACE
INHERITANCE
IN
PLACE
OF
OUR
MORE
INFORMAL
APIS
BUT
CHOSE
NOT
TO
DO
SO
TO
AVOID
DEPENDENCE
ON
SPECIFIC
HIGH
LEVEL
LANGUAGE
MECHA
NISMS
THAT
ARE
NOT
CRITICAL
TO
THE
UNDERSTANDING
OF
ALGORITHMS
AND
TO
AVOID
THE
EXTRA
BAGGAGE
OF
INTER
FACE
FILES
BUT
THERE
ARE
A
FEW
SITUA
JAVA
INTERFACES
USED
IN
THIS
BOOK
TIONS
WHERE
JAVA
CONVENTIONS
MAKE
IT
WORTHWHILE
FOR
US
TO
TAKE
ADVANTAGE
OF
INTERFACES
WE
USE
THEM
FOR
COMPARISON
AND
FOR
ITERATION
AS
DETAILED
IN
THE
TABLE
AT
THE
BOTTOM
OF
THE
PREVIOUS
PAGE
AND
WILL
CONSIDER
THEM
IN
MORE
DETAIL
WHEN
WE
COVER
THOSE
CONCEPTS
IMPLEMENTATION
INHERITANCE
JAVA
ALSO
SUPPORTS
ANOTHER
INHERITENCE
MECHANISM
KNOWN
AS
SUBCLASSING
WHICH
IS
A
POWERFUL
TECHNIQUE
THAT
ENABLES
A
PROGRAMMER
TO
CHANGE
BEHAVIOR
AND
ADD
FUNCTIONALITY
WITHOUT
REWRITING
AN
ENTIRE
CLASS
FROM
SCRATCH
THE
IDEA
IS
TO
DEFINE
A
NEW
CLASS
SUBCLASS
OR
DERIVED
CLASS
THAT
INHERITS
INSTANCE
METH
ODS
AND
INSTANCE
VARIABLES
FROM
ANOTHER
CLASS
SUPERCLASS
OR
BASE
CLASS
THE
SUBCLASS
CONTAINS
MORE
METHODS
THAN
THE
SUPERCLASS
MOREOVER
THE
SUBCLASS
CAN
REDEFINE
OR
OVERRIDE
METHODS
IN
THE
SUPERCLASS
SUBCLASSING
IS
WIDELY
USED
BY
SYSTEMS
PROGRAMMERS
TO
BUILD
SO
CALLED
EXTENSIBLE
LIBRARIES
ONE
PROGRAMMER
EVEN
YOU
CAN
ADD
METHODS
TO
A
LIBRARY
BUILT
BY
ANOTHER
PROGRAMMER
OR
PERHAPS
A
TEAM
OF
SYSTEMS
PROGRAMMERS
EFFECTIVELY
REUSING
THE
CODE
IN
A
POTENTIALLY
HUGE
LIBRARY
FOR
EXAMPLE
THIS
APPROACH
IS
WIDELY
USED
IN
THE
DEVELOPMENT
OF
GRAPHICAL
USER
INTERFACES
SO
THAT
THE
LARGE
AMOUNT
OF
CODE
REQUIRED
TO
PROVIDE
ALL
THE
FACILITIES
THAT
USERS
EXPECT
DROP
DOWN
MENUS
CUT
AND
PASTE
ACCESS
TO
FILES
AND
SO
FORTH
CAN
BE
REUSED
THE
USE
OF
SUBCLASSING
IS
CONTROVERSIAL
AMONG
SYSTEMS
AND
APPLICATIONS
PROGRAMMERS
ITS
ADVANTAGES
OVER
INTERFACE
INHERI
TANCE
ARE
DEBATABLE
AND
WE
AVOID
IT
IN
THIS
BOOK
BECAUSE
IT
GENERALLY
WORKS
AGAINST
ENCAPSULATION
CERTAIN
VESTIGES
OF
THE
APPROACH
ARE
BUILT
IN
TO
JAVA
AND
THEREFORE
UN
AVOIDABLE
SPECIFICALLY
EVERY
CLASS
IS
A
SUBTYPE
OF
JAVA
OBJECT
CLASS
THIS
STRUCTURE
ENABLES
THE
CONVENTION
THAT
EVERY
CLASS
INCLUDES
AN
IMPLEMENTATION
OF
GETCLASS
TOSTRING
EQUALS
HASHCODE
AND
SEVERAL
OTHER
METHODS
THAT
WE
DO
NOT
USE
IN
THIS
BOOK
ACTUALLY
EVERY
CLASS
INHERITS
THESE
METHODS
FROM
OBJECT
THROUGH
SUBCLASSING
SO
ANY
CLIENT
CAN
USE
THEM
FOR
ANY
OBJECT
WE
USUALLY
OVERRIDE
TOSTRING
EQUALS
HASHCODE
IN
NEW
CLASSES
BECAUSE
THE
DEFAULT
OBJECT
IMPLEMENTATION
GENERALLY
DOES
NOT
LEAD
TO
THE
DESIRED
BEHAVIOR
WE
NOW
WILL
CONSIDER
TOSTRING
AND
EQUALS
WE
DISCUSS
HASHCODE
IN
SECTION
METHOD
PURPOSE
SECTION
CLASS
GETCLASS
WHAT
CLASS
IS
THIS
OBJECT
STRING
TOSTRING
STRING
REPRESENTATION
OF
THIS
OBJECT
BOOLEAN
EQUALS
OBJECT
THAT
IS
THIS
OBJECT
EQUAL
TO
THAT
INT
HASHCODE
HASH
CODE
FOR
THIS
OBJECT
INHERITED
METHODS
FROM
OBJECT
USED
IN
THIS
BOOK
STRING
CONVERSION
BY
CONVENTION
EVERY
JAVA
TYPE
INHERITS
TOSTRING
FROM
OBJECT
SO
ANY
CLIENT
CAN
INVOKE
TOSTRING
FOR
ANY
OBJECT
THIS
CONVENTION
IS
THE
BASIS
FOR
JA
VA
AUTOMATIC
CONVERSION
OF
ONE
OPERAND
OF
THE
CONCATENATION
OPERATOR
TO
A
STRING
WHENEVER
THE
OTHER
OPERAND
IS
A
STRING
IF
AN
OBJECT
DATA
TYPE
DOES
NOT
INCLUDE
AN
IMPLEMENTATION
OF
TOSTRING
THEN
THE
DEFAULT
IMPLEMENTATION
IN
OBJECT
IS
INVOKED
WHICH
IS
NORMALLY
NOT
HELPFUL
SINCE
IT
TYPICALLY
RETURNS
A
STRING
REPRESENTATION
OF
THE
MEMORY
ADDRESS
OF
THE
OBJECT
ACCORDINGLY
WE
GENERALLY
INCLUDE
IMPLEMENTATIONS
OF
TOSTRING
THAT
OVERRIDE
THE
DEFAULT
IN
EVERY
CLASS
THAT
WE
DEVELOP
AS
HIGHLIGHTED
FOR
DATE
ON
THE
FACING
PAGE
AS
ILLUSTRATED
IN
THIS
CODE
TOSTRING
IMPLEMENTATIONS
ARE
OFTEN
QUITE
SIMPLE
IMPLICITLY
THROUGH
USING
TOSTRING
FOR
EACH
INSTANCE
VARIABLE
WRAPPER
TYPES
JAVA
SUPPLIES
BUILT
IN
REFERENCE
TYPES
KNOWN
AS
WRAPPER
TYPES
ONE
FOR
EACH
OF
THE
PRIMITIVE
TYPES
BOOLEAN
BYTE
CHARACTER
DOUBLE
FLOAT
INTEGER
LONG
AND
SHORT
CORRESPOND
TO
BOOLEAN
BYTE
CHAR
DOUBLE
FLOAT
INT
LONG
AND
SHORT
RESPECTIVELY
THESE
CLASSES
CONSIST
PRIMARILY
OF
STATIC
METHODS
SUCH
AS
PARSEINT
BUT
THEY
ALSO
INCLUDE
THE
INHERITED
INSTANCE
METHODS
TOSTRING
COMPARETO
EQUALS
AND
HASHCODE
JAVA
AUTOMATICALLY
CONVERTS
FROM
PRIMITIVE
TYPES
TO
WRAPPER
TYPES
WHEN
WARRANTED
AS
DESCRIBED
ON
PAGE
FOR
EXAMPLE
WHEN
AN
INT
VALUE
IS
CONCAT
ENATED
WITH
A
STRING
IT
IS
CONVERTED
TO
AN
INTEGER
THAT
CAN
INVOKE
TOSTRING
EQUALITY
WHAT
DOES
IT
MEAN
FOR
TWO
OBJECTS
TO
BE
EQUAL
IF
WE
TEST
EQUALITY
WITH
A
B
WHERE
A
AND
B
ARE
REFERENCE
VARIABLES
OF
THE
SAME
TYPE
WE
ARE
TESTING
WHETHER
THEY
HAVE
THE
SAME
IDENTITY
WHETHER
THE
REFERENCES
ARE
EQUAL
TYPICAL
CLIENTS
WOULD
RATHER
BE
ABLE
TO
TEST
WHETHER
THE
DATA
TYPE
VALUES
OBJECT
STATE
ARE
THE
SAME
OR
TO
IMPLEMENT
SOME
TYPE
SPECIFIC
RULE
JAVA
GIVES
US
A
HEAD
START
BY
PROVIDING
IMPLEMENTA
TIONS
BOTH
FOR
STANDARD
TYPES
SUCH
AS
INTEGER
DOUBLE
AND
STRING
AND
FOR
MORE
COM
PLICATED
TYPES
SUCH
AS
FILE
AND
URL
WHEN
USING
THESE
TYPES
OF
DATA
YOU
CAN
JUST
USE
THE
BUILT
IN
IMPLEMENTATION
FOR
EXAMPLE
IF
X
AND
Y
ARE
STRING
VALUES
THEN
X
EQUALS
Y
IS
TRUE
IF
AND
ONLY
IF
X
AND
Y
HAVE
THE
SAME
LENGTH
AND
ARE
IDENTICAL
IN
EACH
CHARACTER
POSITION
WHEN
WE
DEFINE
OUR
OWN
DATA
TYPES
SUCH
AS
DATE
OR
TRANSACTION
WE
NEED
TO
OVERRIDE
EQUALS
JAVA
CONVENTION
IS
THAT
EQUALS
MUST
BE
AN
EQUIVALENCE
RELA
TION
IT
MUST
BE
REFLEXIVE
X
EQUALS
X
IS
TRUE
SYMMETRIC
X
EQUALS
Y
IS
TRUE
IF
AND
ONLY
IF
Y
EQUALS
X
TRANSITIVE
IF
X
EQUALS
Y
AND
Y
EQUALS
Z
ARE
TRUE
THEN
SO
IS
X
EQUALS
Z
IN
ADDITION
IT
MUST
TAKE
AN
OBJECT
AS
ARGUMENT
AND
SATISFY
THE
FOLLOWING
PROPERTIES
CONSISTENT
MULTIPLE
INVOCATIONS
OF
X
EQUALS
Y
CONSISTENTLY
RETURN
THE
SAME
VALUE
PROVIDED
NEITHER
OBJECT
IS
MODIFIED
NOT
NULL
X
EQUALS
NULL
RETURNS
FALSE
THESE
ARE
NATURAL
DEFINITIONS
BUT
ENSURING
THAT
THESE
PROPERTIES
HOLD
ADHERING
TO
JAVA
CONVENTIONS
AND
AVOIDING
UNNECESSARY
WORK
IN
AN
IMPLEMENTATION
CAN
BE
TRICKY
AS
IL
LUSTRATED
FOR
DATE
BELOW
IT
TAKES
THE
FOLLOWING
STEP
BY
STEP
APPROACH
IF
THE
REFERENCE
TO
THIS
OBJECT
IS
THE
SAME
AS
THE
REFERENCE
TO
THE
ARGUMENT
OBJECT
RETURN
TRUE
THIS
TEST
SAVES
THE
WORK
OF
DOING
ALL
THE
OTHER
CHECKS
IN
THIS
CASE
IF
THE
ARGUMENT
IS
NULL
RETURN
FALSE
TO
ADHERE
TO
THE
CONVENTION
AND
TO
AVOID
FOLLOWING
A
NULL
REFERENCE
IN
CODE
TO
FOLLOW
IF
THE
OBJECTS
ARE
NOT
FROM
THE
SAME
CLASS
RETURN
FALSE
TO
DETERMINE
AN
OBJECT
CLASS
WE
USE
GETCLASS
NOTE
THAT
WE
CAN
USE
TO
TELL
US
WHETHER
TWO
OBJECTS
OF
TYPE
CLASS
ARE
EQUAL
BECAUSE
GETCLASS
IS
GUARANTEED
TO
RETURN
THE
SAME
REFERENCE
FOR
ALL
OBJECTS
IN
ANY
GIVEN
CLASS
CAST
THE
ARGUMENT
FROM
OBJECT
TO
DATE
THIS
CAST
MUST
SUCCEED
BECAUSE
OF
THE
PREVIOUS
TEST
RETURN
FALSE
IF
ANY
INSTANCE
VARIABLES
DO
NOT
MATCH
FOR
OTHER
CLASSES
SOME
OTHER
DEFINITION
OF
EQUALITY
MIGHT
BE
APPROPRIATE
FOR
EXAMPLE
WE
MIGHT
REGARD
TWO
COUNTER
OBJECTS
AS
EQUAL
IF
THEIR
COUNT
INSTANCE
VARIABLES
ARE
EQUAL
THIS
IMPLEMENTATION
IS
A
MODEL
THAT
YOU
CAN
USE
TO
IMPLEMENT
EQUALS
FOR
ANY
TYPE
THAT
YOU
IMPLEMENT
ONCE
YOU
HAVE
IMPLEMENTED
ONE
EQUALS
YOU
WILL
NOT
FIND
IT
DIFFICULT
TO
IMPLEMENT
ANOTHER
MEMORY
MANAGEMENT
THE
ABILITY
TO
ASSIGN
A
NEW
VALUE
TO
A
REFERENCE
VARIABLE
CRE
ATES
THE
POSSIBILITY
THAT
A
PROGRAM
MAY
HAVE
CREATED
AN
OBJECT
THAT
CAN
NO
LONGER
BE
REFERENCED
FOR
EXAMPLE
CONSIDER
THE
THREE
ASSIGNMENT
STATEMENTS
IN
THE
FIGURE
AT
LEFT
AFTER
THE
THIRD
ASSIGNMENT
STATEMENT
NOT
ONLY
DO
A
AND
B
REFER
TO
THE
SAME
DATE
OBJECT
BUT
ALSO
THERE
IS
NO
LONGER
A
REFERENCE
TO
THE
DATE
OBJECT
THAT
WAS
CREATED
AND
USED
TO
INITIALIZE
B
THE
ONLY
REFERENCE
TO
THAT
OBJECT
DATE
A
NEW
DATE
DATE
B
NEW
DATE
B
A
WAS
IN
THE
VARIABLE
B
AND
THIS
REFERENCE
WAS
OVERWRITTEN
BY
THE
ASSIGNMENT
SO
THERE
IS
NO
WAY
TO
REFER
TO
THE
OBJECT
AGAIN
SUCH
AN
OBJECT
IS
SAID
TO
BE
ORPHANED
OBJECTS
ARE
ALSO
ORPHANED
WHEN
THEY
GO
OUT
OF
SCOPE
JAVA
PROGRAMS
TEND
TO
CREATE
HUGE
NUMBERS
OF
OBJECTS
AND
VARIABLES
THAT
A
B
REFERENCES
TO
SAME
OBJECT
ORPHANED
OBJECT
NEW
YEAR
EVE
NEW
YEAR
DAY
HOLD
PRIMITIVE
DATA
TYPE
VALUES
BUT
ONLY
HAVE
A
NEED
FOR
A
SMALL
NUMBER
OF
THEM
AT
ANY
GIVEN
POINT
IN
TIME
ACCORD
INGLY
PROGRAMMING
LANGUAGES
AND
SYSTEMS
NEED
MECHA
NISMS
TO
ALLOCATE
MEMORY
FOR
DATA
TYPE
VALUES
DURING
THE
TIME
THEY
ARE
NEEDED
AND
TO
FREE
THE
MEMORY
WHEN
THEY
ARE
NO
LONGER
NEEDED
FOR
AN
OBJECT
SOMETIME
AFTER
IT
IS
ORPHANED
MEMORY
MANAGEMENT
TURNS
OUT
TO
BE
EASIER
FOR
PRIMITIVE
TYPES
BECAUSE
ALL
OF
THE
INFORMATION
NEEDED
FOR
MEMORY
ALLOCATION
IS
KNOWN
AT
COMPILE
TIME
JAVA
AND
MOST
OTHER
SYSTEMS
TAKES
CARE
OF
RESERVING
SPACE
FOR
VARI
ABLES
WHEN
THEY
ARE
DECLARED
AND
FREEING
THAT
SPACE
WHEN
THEY
GO
OUT
OF
SCOPE
MEMORY
MANAGEMENT
FOR
OBJECTS
IS
MORE
COMPLICATED
THE
SYSTEM
CAN
ALLOCATE
MEMORY
FOR
AN
OBJECT
WHEN
IT
IS
CREATED
BUT
CANNOT
KNOW
PRECISELY
WHEN
TO
FREE
THE
MEMORY
ASSOCIATED
WITH
EACH
OBJECT
BECAUSE
THE
DYNAMICS
OF
A
PROGRAM
IN
EXECUTION
DETERMINES
WHEN
AN
ORPHANED
OBJECT
OBJECTS
ARE
ORPHANED
IN
MANY
LANGUAGES
SUCH
AS
C
AND
C
THE
PROGRAMMER
IS
RESPONSIBLE
FOR
BOTH
ALLOCATING
AND
FREEING
MEMORY
DOING
SO
IS
TEDIOUS
AND
NOTORIOUSLY
ERROR
PRONE
ONE
OF
JAVA
MOST
SIGNIFICANT
FEATURES
IS
ITS
ABILITY
TO
AUTOMATICALLY
MAN
AGE
MEMORY
THE
IDEA
IS
TO
FREE
THE
PROGRAMMERS
FROM
THE
RESPONSIBILITY
OF
MANAGING
MEMORY
BY
KEEPING
TRACK
OF
ORPHANED
OBJECTS
AND
RETURNING
THE
MEMORY
THEY
USE
TO
A
POOL
OF
FREE
MEMORY
RECLAIMING
MEMORY
IN
THIS
WAY
IS
KNOWN
AS
GARBAGE
COLLECTION
ONE
OF
JAVA
CHARACTERISTIC
FEATURES
IS
ITS
POLICY
THAT
REFERENCES
CANNOT
BE
MODIFIED
THIS
POLICY
ENABLES
JAVA
TO
DO
EFFICIENT
AUTOMATIC
GARBAGE
COLLECTION
PROGRAMMERS
STILL
DEBATE
WHETHER
THE
OVERHEAD
OF
AUTOMATIC
GARBAGE
COLLECTION
JUSTIFIES
THE
CONVENIENCE
OF
NOT
HAVING
TO
WORRY
ABOUT
MEMORY
MANAGEMENT
IMMUTABILITY
AN
IMMUTABLE
DATA
TYPE
SUCH
AS
DATE
HAS
THE
PROPERTY
THAT
THE
VALUE
OF
AN
OBJECT
NEVER
CHANGES
ONCE
CONSTRUCTED
BY
CONTRAST
A
MUTABLE
DATA
TYPE
SUCH
AS
COUNTER
OR
ACCUMULATOR
MANIPULATES
OBJECT
VALUES
THAT
ARE
INTENDED
TO
CHANGE
JAVA
LANGUAGE
SUPPORT
FOR
HELPING
TO
ENFORCE
IMMUTABILITY
IS
THE
FINAL
MODIFIER
WHEN
YOU
DECLARE
A
VARIABLE
TO
BE
FINAL
YOU
ARE
PROMISING
TO
ASSIGN
IT
A
VALUE
ONLY
ONCE
EITHER
IN
AN
INITIALIZER
OR
IN
THE
CONSTRUCTOR
CODE
THAT
COULD
MODIFY
THE
VALUE
OF
A
FINAL
VARIABLE
LEADS
TO
A
COMPILE
TIME
ERROR
IN
OUR
CODE
WE
USE
THE
MODIFIER
FINAL
WITH
INSTANCE
VARIABLES
WHOSE
VALUES
NEVER
CHANGE
THIS
POLICY
SERVES
AS
DOCUMENTATION
THAT
THE
VALUE
DOES
NOT
CHANGE
PREVENTS
ACCIDENTAL
CHANGES
AND
MAKES
PROGRAMS
EASIER
TO
DEBUG
FOR
EXAMPLE
YOU
DO
NOT
HAVE
TO
INCLUDE
A
FINAL
VALUE
IN
A
TRACE
SINCE
YOU
KNOW
THAT
ITS
VALUE
NEVER
CHANGES
A
DATA
TYPE
SUCH
AS
DATE
WHOSE
INSTANCE
VARIABLES
ARE
ALL
PRIMITIVE
AND
FINAL
IS
IMMUTABLE
IN
CODE
THAT
DOES
NOT
USE
IMPLEMENTATION
INHERITENCE
OUR
CONVENTION
WHETHER
TO
MAKE
A
DATA
TYPE
IMMUTABLE
IS
AN
IMPORTANT
DESIGN
DECISION
AND
DEPENDS
ON
THE
APPLICATION
AT
HAND
FOR
DATA
TYPES
SUCH
AS
DATE
THE
PURPOSE
OF
THE
ABSTRACTION
IS
TO
ENCAP
SULATE
VALUES
THAT
DO
NOT
CHANGE
SO
THAT
WE
CAN
USE
THEM
IN
AS
SIGNMENT
STATEMENTS
AND
AS
ARGUMENTS
AND
RETURN
VALUES
FROM
FUNCTIONS
IN
THE
SAME
WAY
AS
WE
USE
PRIMITIVE
TYPES
WITHOUT
HAV
ING
TO
WORRY
ABOUT
THEIR
VALUES
CHANGING
A
PROGRAMMER
IMPLE
MENTING
A
DATE
CLIENT
MIGHT
REASONABLY
EXPECT
TO
WRITE
THE
CODE
D
FOR
TWO
DATE
VARIABLES
IN
THE
SAME
WAY
AS
FOR
DOUBLE
OR
INT
VALUES
BUT
IF
DATE
WERE
MUTABLE
AND
THE
VALUE
OF
D
WERE
TO
MUTABLE
IMMUTABLE
COUNTER
DATE
JAVA
ARRAYS
STRING
MUTABLE
IMMUTABLE
EXAMPLES
CHANGE
AFTER
THE
ASSIGNMENT
D
THEN
THE
VALUE
OF
WOULD
ALSO
CHANGE
THEY
ARE
BOTH
REFERENCES
TO
THE
SAME
OBJECT
ON
THE
OTHER
HAND
FOR
DATA
TYPES
SUCH
AS
COUNTER
AND
ACCUMULATOR
THE
VERY
PURPOSE
OF
THE
ABSTRACTION
IS
TO
ENCAPSULATE
VALUES
AS
THEY
CHANGE
YOU
HAVE
ALREADY
ENCOUNTERED
THIS
DISTINCTION
AS
A
CLIENT
PROGRAMMER
WHEN
USING
JAVA
ARRAYS
MUTABLE
AND
JAVA
STRING
DATA
TYPE
IMMUTABLE
WHEN
YOU
PASS
A
STRING
TO
A
METHOD
YOU
DO
NOT
WORRY
ABOUT
THAT
METHOD
CHANGING
THE
SEQUENCE
OF
CHARACTERS
IN
THE
STRING
BUT
WHEN
YOU
PASS
AN
ARRAY
TO
A
METHOD
THE
METHOD
IS
FREE
TO
CHANGE
THE
CONTENTS
OF
THE
ARRAY
STRING
OBJECTS
ARE
IMMUTABLE
BECAUSE
WE
GENERALLY
DO
NOT
WANT
STRING
VALUES
TO
CHANGE
AND
JAVA
ARRAYS
ARE
MUTABLE
BECAUSE
WE
GENERALLY
DO
WANT
ARRAY
VALUES
TO
CHANGE
THERE
ARE
ALSO
SITUATIONS
WHERE
WE
WANT
TO
HAVE
MUTABLE
STRINGS
THAT
IS
THE
PURPOSE
OF
JAVA
STRINGBUILDER
CLASS
AND
WHERE
WE
WANT
TO
HAVE
IMMUTABLE
ARRAYS
THAT
IS
THE
PURPOSE
OF
THE
VECTOR
CLASS
THAT
WE
CONSIDER
LATER
IN
THIS
SECTION
GENERALLY
IMMUTABLE
TYPES
ARE
EASIER
TO
USE
AND
HARDER
TO
MISUSE
THAN
MUTA
BLE
TYPES
BECAUSE
THE
SCOPE
OF
CODE
THAT
CAN
CHANGE
THEIR
VALUES
IS
FAR
SMALLER
IT
IS
EASIER
TO
DEBUG
CODE
THAT
USES
IMMUTABLE
TYPES
BECAUSE
IT
IS
EASIER
TO
GUARANTEE
THAT
VARIABLES
IN
CLIENT
CODE
THAT
USES
THEM
REMAIN
IN
A
CONSISTENT
STATE
WHEN
USING
MUTABLE
TYPES
YOU
MUST
ALWAYS
BE
CONCERNED
ABOUT
WHERE
AND
WHEN
THEIR
VALUES
CHANGE
THE
DOWN
SIDE
OF
IMMUTABILITY
IS
THAT
A
NEW
OBJECT
MUST
BE
CREATED
FOR
EVERY
VALUE
THIS
EXPENSE
IS
NORMALLY
MANAGEABLE
BECAUSE
JAVA
GARBAGE
COLLECTORS
ARE
TYPICALLY
OPTIMIZED
FOR
SUCH
SITUATIONS
ANOTHER
DOWNSIDE
OF
IMMUTABILITY
STEMS
FROM
THE
FACT
THAT
UNFORTUNATELY
FINAL
GUARANTEES
IMMUTABILITY
ONLY
WHEN
INSTANCE
VARIABLES
ARE
PRIMITIVE
TYPES
NOT
REFERENCE
TYPES
IF
AN
INSTANCE
VARIABLE
OF
A
REFERENCE
TYPE
HAS
THE
FINAL
MODIFIER
THE
VALUE
OF
THAT
INSTANCE
VARIABLE
THE
REFERENCE
TO
AN
OBJECT
WILL
NEVER
CHANGE
IT
WILL
ALWAYS
REFER
TO
THE
SAME
OBJECT
BUT
THE
VALUE
OF
THE
OBJECT
ITSELF
CAN
CHANGE
FOR
EX
AMPLE
THIS
CODE
DOES
NOT
IMPLEMENT
AN
IMMUTABLE
TYPE
PUBLIC
CLASS
VECTOR
PRIVATE
FINAL
DOUBLE
COORDS
PUBLIC
VECTOR
DOUBLE
A
COORDS
A
A
CLIENT
PROGRAM
COULD
CREATE
A
VECTOR
BY
SPECIFYING
THE
ENTRIES
IN
AN
ARRAY
AND
THEN
BYPASSING
THE
API
CHANGE
THE
ELEMENTS
OF
THE
VECTOR
AFTER
CONSTRUCTION
DOUBLE
A
VECTOR
VECTOR
NEW
VECTOR
A
A
BYPASSES
THE
PUBLIC
API
THE
INSTANCE
VARIABLE
COORDS
IS
PRIVATE
AND
FINAL
BUT
VECTOR
IS
MUTABLE
BECAUSE
THE
CLIENT
HOLDS
A
REFERENCE
TO
THE
DATA
IMMUTABILITY
NEEDS
TO
BE
TAKEN
INTO
ACCOUNT
IN
ANY
DATA
TYPE
DESIGN
AND
WHETHER
A
DATA
TYPE
IS
IMMUTABLE
SHOULD
BE
SPECIFIED
IN
THE
API
SO
THAT
CLIENTS
KNOW
THAT
OBJECT
VALUES
WILL
NOT
CHANGE
IN
THIS
BOOK
OUR
PRIMARY
INTEREST
IN
IMMUTABILITY
IS
FOR
USE
IN
CERTIFYING
THE
CORRECTNESS
OF
OUR
ALGORITHMS
FOR
EXAMPLE
IF
THE
TYPE
OF
DATA
USED
FOR
A
BINARY
SEARCH
ALGORITHM
WERE
MUTABLE
THEN
CLI
ENTS
COULD
INVALIDATE
OUR
ASSUMPTION
THAT
THE
ARRAY
IS
SORTED
FOR
BINARY
SEARCH
DESIGN
BY
CONTRACT
TO
CONCLUDE
WE
BRIEFLY
DISCUSS
JAVA
LANGUAGE
MECHANISMS
THAT
ENABLES
YOU
TO
VERIFY
ASSUMPTIONS
ABOUT
YOUR
PROGRAM
AS
IT
IS
RUNNING
WE
USE
TWO
JAVA
LANGUAGE
MECHANISMS
FOR
THIS
PURPOSE
EXCEPTIONS
WHICH
GENERALLY
HANDLE
UNFORESEEN
ERRORS
OUTSIDE
OUR
CONTROL
ASSERTIONS
WHICH
VERIFY
ASSUMPTIONS
THAT
WE
MAKE
WITHIN
CODE
WE
DEVELOP
LIBERAL
USE
OF
BOTH
EXCEPTIONS
AND
ASSERTIONS
IS
GOOD
PROGRAMMING
PRACTICE
WE
USE
THEM
SPARINGLY
IN
THE
BOOK
FOR
ECONOMY
BUT
YOU
WILL
FIND
THEM
THROUGHOUT
THE
CODE
ON
THE
BOOKSITE
THIS
CODE
ALIGNS
WITH
A
SUBSTANTIAL
AMOUNT
OF
THE
SURROUNDING
COM
MENTARY
ABOUT
EACH
ALGORITHM
IN
THE
TEXT
THAT
HAS
TO
DO
WITH
EXCEPTIONAL
CONDITIONS
AND
WITH
ASSERTED
INVARIANTS
EXCEPTIONS
AND
ERRORS
EXCEPTIONS
AND
ERRORS
ARE
DISRUPTIVE
EVENTS
THAT
OCCUR
WHILE
A
PROGRAM
IS
RUNNING
OFTEN
TO
SIGNAL
AN
ERROR
THE
ACTION
TAKEN
IS
KNOWN
AS
THROWING
AN
EXCEPTION
OR
THROWING
AN
ERROR
WE
HAVE
ALREADY
ENCOUNTERED
EXCEPTIONS
THROWN
BY
JAVA
SYSTEM
METHODS
IN
THE
COURSE
OF
LEARNING
BASIC
FEATURES
OF
JAVA
STACKOVERFLOWERROR
ARITHMETICEXCEPTION
ARRAYINDEXOUTOFBOUNDSEXCEPTION
OUTOFMEMORYERROR
AND
NULLPOINTEREXCEPTION
ARE
TYPICAL
EXAMPLES
YOU
CAN
ALSO
CREATE
YOUR
OWN
EX
CEPTIONS
THE
SIMPLEST
KIND
IS
A
RUNTIMEEXCEPTION
THAT
TERMINATES
EXECUTION
OF
THE
PROGRAM
AND
PRINTS
AN
ERROR
MESSAGE
THROW
NEW
RUNTIMEEXCEPTION
ERROR
MESSAGE
HERE
A
GENERAL
PRACTICE
KNOWN
AS
FAIL
FAST
PROGRAMMING
SUGGESTS
THAT
AN
ERROR
IS
MORE
EASILY
PINPOINTED
IF
AN
EXCEPTION
IS
THROWN
AS
SOON
AS
AN
ERROR
IS
DISCOVERED
AS
OPPOSED
TO
IGNORING
THE
ERROR
AND
DEFERRING
THE
EXCEPTION
TO
SOMETIME
IN
THE
FUTURE
ASSERTIONS
AN
ASSERTION
IS
A
BOOLEAN
EXPRESSION
THAT
YOU
ARE
AFFIRMING
IS
TRUE
AT
THAT
POINT
IN
THE
PROGRAM
IF
THE
EXPRESSION
IS
FALSE
THE
PROGRAM
WILL
TERMINATE
AND
RE
PORT
AN
ERROR
MESSAGE
WE
USE
ASSERTIONS
BOTH
TO
GAIN
CONFIDENCE
IN
THE
CORRECTNESS
OF
PROGRAMS
AND
TO
DOCUMENT
INTENT
FOR
EXAMPLE
SUPPOSE
THAT
YOU
HAVE
A
COMPUTED
VALUE
THAT
YOU
MIGHT
USE
TO
INDEX
INTO
AN
ARRAY
IF
THIS
VALUE
WERE
NEGATIVE
IT
WOULD
CAUSE
AN
ARRAYINDEXOUTOFBOUNDSEXCEPTION
SOMETIME
LATER
BUT
IF
YOU
WRITE
THE
CODE
ASSERT
INDEX
YOU
CAN
PINPOINT
THE
PLACE
WHERE
THE
ERROR
OCCURRED
YOU
CAN
ALSO
ADD
AN
OPTIONAL
DETAIL
MESSAGE
SUCH
AS
ASSERT
INDEX
NEGATIVE
INDEX
IN
METHOD
X
TO
HELP
YOU
LOCATE
THE
BUG
BY
DEFAULT
ASSERTIONS
ARE
DISABLED
YOU
CAN
ENABLE
THEM
FROM
THE
COMMAND
LINE
BY
USING
THE
ENABLEASSERTIONS
FLAG
EA
FOR
SHORT
ASSERTIONS
ARE
FOR
DEBUGGING
YOUR
PROGRAM
SHOULD
NOT
RELY
ON
ASSERTIONS
FOR
NORMAL
OPERATION
SINCE
THEY
MAY
BE
DISABLED
WHEN
YOU
TAKE
A
COURSE
IN
SYSTEMS
PROGRAMMING
YOU
WILL
LEARN
TO
USE
ASSERTIONS
TO
ENSURE
THAT
YOUR
CODE
NEVER
TERMINATES
IN
A
SYSTEM
ERROR
OR
GOES
INTO
AN
INFINITE
LOOP
ONE
MODEL
KNOWN
AS
THE
DESIGN
BY
CONTRACT
MODEL
OF
PROGRAMMING
EXPRESSES
THE
IDEA
THE
DESIGNER
OF
A
DATA
TYPE
EXPRESSES
A
PRECONDITION
THE
CONDITION
THAT
THE
CLIENT
PROMISES
TO
SATISFY
WHEN
CALLING
A
METHOD
A
POSTCONDITION
THE
CONDI
TION
THAT
THE
IMPLEMENTATION
PROMISES
TO
ACHIEVE
WHEN
RETURNING
FROM
A
METHOD
AND
SIDE
EFFECTS
ANY
OTHER
CHANGE
IN
STATE
THAT
THE
METHOD
COULD
CAUSE
DURING
DEVELOP
MENT
THESE
CONDITIONS
CAN
BE
TESTED
WITH
ASSERTIONS
SUMMARY
THE
LANGUAGE
MECHANISMS
DISCUSSED
THROUGHOUT
THIS
SECTION
ILLUSTRATE
THAT
EFFECTIVE
DATA
TYPE
DESIGN
LEADS
TO
NONTRIVIAL
ISSUES
THAT
ARE
NOT
EASY
TO
RESOLVE
EX
PERTS
ARE
STILL
DEBATING
THE
BEST
WAYS
TO
SUPPORT
SOME
OF
THE
DESIGN
IDEAS
THAT
WE
ARE
DISCUSSING
WHY
DOES
JAVA
NOT
ALLOW
FUNCTIONS
AS
ARGUMENTS
WHY
DOES
MATLAB
COPY
ARRAYS
PASSED
AS
ARGUMENTS
TO
FUNCTIONS
AS
MENTIONED
EARLY
IN
CHAPTER
IT
IS
A
SLIP
PERY
SLOPE
FROM
COMPLAINING
ABOUT
FEATURES
IN
A
PROGRAMMING
LANGUAGE
TO
BECOMING
A
PROGRAMMING
LANGUAGE
DESIGNER
IF
YOU
DO
NOT
PLAN
TO
DO
SO
YOUR
BEST
STRATEGY
IS
TO
USE
WIDELY
AVAILABLE
LANGUAGES
MOST
SYSTEMS
HAVE
EXTENSIVE
LIBRARIES
THAT
YOU
CER
TAINLY
SHOULD
USE
WHEN
APPROPRIATE
BUT
YOU
OFTEN
CAN
SIMPLIFY
YOUR
CLIENT
CODE
AND
PROTECT
YOURSELF
BY
BUILDING
ABSTRACTIONS
THAT
CAN
EASILY
TRANSPORT
TO
OTHER
LANGUAGES
YOUR
MAIN
GOAL
IS
TO
DEVELOP
DATA
TYPES
SO
THAT
MOST
OF
YOUR
WORK
IS
DONE
AT
A
LEVEL
OF
ABSTRACTION
THAT
IS
APPROPRIATE
TO
THE
PROBLEM
AT
HAND
THE
TABLE
ON
THE
FACING
PAGE
SUMMARIZES
THE
VARIOUS
KINDS
OF
JAVA
CLASSES
THAT
WE
HAVE
CONSIDERED
KIND
OF
CLASS
EXAMPLES
CHARACTERISTICS
STATIC
METHODS
MATH
STDIN
STDOUT
NO
INSTANCE
VARIABLES
IMMUTABLE
ABSTRACT
DATA
TYPE
DATE
TRANSACTION
STRING
INTEGER
INSTANCE
VARIABLES
ALL
PRIVATE
INSTANCE
VARIABLES
ALL
FINAL
DEFENSIVE
COPY
FOR
REFERENCE
TYPES
NOTE
THESE
ARE
NECESSARY
BUT
NOT
SUFFICIENT
MUTABLE
ABSTRACT
DATA
TYPE
COUNTER
ACCUMULATOR
INSTANCE
VARIABLES
ALL
PRIVATE
NOT
ALL
INSTANCE
VARIABLES
FINAL
ABSTRACT
DATA
TYPE
WITH
I
O
SIDE
EFFECTS
VISUALACCUMULATOR
IN
OUT
DRAW
INSTANCE
VARIABLES
ALL
PRIVATE
INSTANCE
METHODS
DO
I
O
JAVA
CLASSES
DATA
TYPE
IMPLEMENTATIONS
Q
WHY
BOTHER
WITH
DATA
ABSTRACTION
A
IT
HELPS
US
PRODUCE
RELIABLE
AND
CORRECT
CODE
FOR
EXAMPLE
IN
THE
PRESIDENTIAL
ELECTION
AL
GORE
RECEIVED
VOTES
ON
AN
ELECTRONIC
VOTING
MACHINE
IN
VOLUSIA
COUNTY
FLORIDA
THE
TALLY
WAS
CLEARLY
NOT
PROPERLY
ENCAPSULATED
IN
THE
VOTING
MACHINE
SOFTWARE
Q
WHY
THE
DISTINCTION
BETWEEN
PRIMITIVE
AND
REFERENCE
TYPES
WHY
NOT
JUST
HAVE
REFER
ENCE
TYPES
A
PERFORMANCE
JAVA
PROVIDES
THE
REFERENCE
TYPES
INTEGER
DOUBLE
AND
SO
FORTH
THAT
CORRESPOND
TO
PRIMITIVE
TYPES
THAT
CAN
BE
USED
BY
PROGRAMMERS
WHO
PREFER
TO
IGNORE
THE
DISTINCTION
PRIMITIVE
TYPES
ARE
CLOSER
TO
THE
TYPES
OF
DATA
THAT
ARE
SUPPORTED
BY
COMPUTER
HARDWARE
SO
PROGRAMS
THAT
USE
THEM
USUALLY
RUN
FASTER
THAN
PROGRAMS
THAT
USE
CORRESPONDING
REFERENCE
TYPES
Q
DO
DATA
TYPES
HAVE
TO
BE
ABSTRACT
A
NO
JAVA
ALSO
ALLOWS
PUBLIC
AND
PROTECTED
TO
ALLOW
SOME
CLIENTS
TO
REFER
DIRECTLY
TO
INSTANCE
VARIABLES
AS
DESCRIBED
IN
THE
TEXT
THE
ADVANTAGES
OF
ALLOWING
CLIENT
CODE
TO
DIRECTLY
REFER
TO
DATA
ARE
GREATLY
OUTWEIGHED
BY
THE
DISADVANTAGES
OF
DEPENDENCE
ON
A
PARTICULAR
REPRESENTATION
SO
ALL
INSTANCE
VARIABLES
ARE
PRIVATE
IN
OUR
CODE
WE
ALSO
OC
CASIONALLY
USE
PRIVATE
INSTANCE
METHODS
TO
SHARE
CODE
AMONG
PUBLIC
METHODS
Q
WHAT
HAPPENS
IF
I
FORGET
TO
USE
NEW
WHEN
CREATING
AN
OBJECT
A
TO
JAVA
IT
LOOKS
AS
THOUGH
YOU
WANT
TO
CALL
A
STATIC
METHOD
WITH
A
RETURN
VALUE
OF
THE
OBJECT
TYPE
SINCE
YOU
HAVE
NOT
DEFINED
SUCH
A
METHOD
THE
ERROR
MESSAGE
IS
THE
SAME
AS
ANYTIME
YOU
REFER
TO
AN
UNDEFINED
SYMBOL
IF
YOU
COMPILE
THE
CODE
COUNTER
C
COUNTER
TEST
YOU
GET
THIS
ERROR
MESSAGE
CANNOT
FIND
SYMBOL
SYMBOL
METHOD
COUNTER
STRING
YOU
GET
THE
SAME
KIND
OF
ERROR
MESSAGE
IF
YOU
PROVIDE
THE
WRONG
NUMBER
OF
ARGUMENTS
TO
A
CONSTRUCTOR
Q
WHAT
HAPPENS
IF
I
FORGET
TO
USE
NEW
WHEN
CREATING
AN
ARRAY
OF
OBJECTS
A
YOU
NEED
TO
USE
NEW
FOR
EACH
OBJECT
THAT
YOU
CREATE
SO
WHEN
YOU
CREATE
AN
ARRAY
OF
N
OBJECTS
YOU
NEED
TO
USE
NEW
N
TIMES
ONCE
FOR
THE
ARRAY
AND
ONCE
FOR
EACH
OF
THE
OBJECTS
IF
YOU
FORGET
TO
CREATE
THE
ARRAY
COUNTER
A
A
NEW
COUNTER
TEST
YOU
GET
THE
SAME
ERROR
MESSAGE
THAT
YOU
WOULD
GET
WHEN
TRYING
TO
ASSIGN
A
VALUE
TO
ANY
UNINITIALIZED
VARIABLE
VARIABLE
A
MIGHT
NOT
HAVE
BEEN
INITIALIZED
A
NEW
COUNTER
TEST
BUT
IF
YOU
FORGET
TO
USE
NEW
WHEN
CREATING
AN
OBJECT
WITHIN
THE
ARRAY
AND
THEN
TRY
TO
USE
IT
TO
INVOKE
A
METHOD
COUNTER
A
NEW
COUNTER
A
INCREMENT
YOU
GET
A
NULLPOINTEREXCEPTION
Q
WHY
NOT
WRITE
STDOUT
PRINTLN
X
TOSTRING
TO
PRINT
OBJECTS
A
THAT
CODE
WORKS
FINE
BUT
JAVA
SAVES
US
THE
TROUBLE
OF
WRITING
IT
BY
AUTOMATICALLY
INVOKING
THE
TOSTRING
METHOD
FOR
ANY
OBJECT
SINCE
PRINTLN
HAS
A
METHOD
THAT
TAKES
AN
OBJECT
AS
ARGUMENT
Q
WHAT
IS
A
POINTER
A
GOOD
QUESTION
PERHAPS
THAT
SHOULD
BE
NULLREFERENCEEXCEPTION
LIKE
A
JAVA
REF
ERENCE
YOU
CAN
THINK
OF
A
POINTER
AS
A
MACHINE
ADDRESS
IN
MANY
PROGRAMMING
LAN
GUAGES
THE
POINTER
IS
A
PRIMITIVE
DATA
TYPE
THAT
PROGRAMMERS
CAN
MANIPULATE
IN
MANY
WAYS
BUT
PROGRAMMING
WITH
POINTERS
IS
NOTORIOUSLY
ERROR
PRONE
SO
OPERATIONS
PRO
VIDED
FOR
POINTERS
NEED
TO
BE
CAREFULLY
DESIGNED
TO
HELP
PROGRAMMERS
AVOID
ERRORS
JAVA
TAKES
THIS
POINT
OF
VIEW
TO
AN
EXTREME
THAT
IS
FAVORED
BY
MANY
MODERN
PROGRAM
MING
LANGUAGE
DESIGNERS
IN
JAVA
THERE
IS
ONLY
ONE
WAY
TO
CREATE
A
REFERENCE
NEW
AND
ONLY
ONE
WAY
TO
CHANGE
A
REFERENCE
WITH
AN
ASSIGNMENT
STATEMENT
THAT
IS
THE
ONLY
THINGS
THAT
A
PROGRAMMER
CAN
DO
WITH
REFERENCES
ARE
TO
CREATE
THEM
AND
COPY
THEM
IN
Q
A
CONTINUED
PROGRAMMING
LANGUAGE
JARGON
JAVA
REFERENCES
ARE
KNOWN
AS
SAFE
POINTERS
BECAUSE
JAVA
CAN
GUARANTEE
THAT
EACH
REFERENCE
POINTS
TO
AN
OBJECT
OF
THE
SPECIFIED
TYPE
AND
IT
CAN
DETERMINE
WHICH
OBJECTS
ARE
NOT
IN
USE
FOR
GARBAGE
COLLECTION
PROGRAMMERS
USED
TO
WRITING
CODE
THAT
DIRECTLY
MANIPULATES
POINTERS
THINK
OF
JAVA
AS
HAVING
NO
POINTERS
AT
ALL
BUT
PEOPLE
STILL
DEBATE
WHETHER
IT
IS
REALLY
DESIRABLE
TO
HAVE
UNSAFE
POINTERS
Q
WHERE
CAN
I
FIND
MORE
DETAILS
ON
HOW
JAVA
IMPLEMENTS
REFERENCES
AND
DOES
GARBAGE
COLLECTION
A
ONE
JAVA
SYSTEM
MIGHT
DIFFER
COMPLETELY
FROM
ANOTHER
FOR
EXAMPLE
ONE
NATURAL
SCHEME
IS
TO
USE
A
POINTER
MACHINE
ADDRESS
ANOTHER
IS
TO
USE
A
HANDLE
A
POINTER
TO
A
POINTER
THE
FORMER
GIVES
FASTER
ACCESS
TO
DATA
THE
LATTER
PROVIDES
FOR
BETTER
GARBAGE
COLLECTION
Q
WHAT
EXACTLY
DOES
IT
MEAN
TO
IMPORT
A
NAME
A
NOT
MUCH
IT
JUST
SAVES
SOME
TYPING
YOU
COULD
TYPE
JAVA
UTIL
ARRAYS
INSTEAD
OF
ARRAYS
EVERYWHERE
IN
YOUR
CODE
INSTEAD
OF
USING
THE
IMPORT
STATEMENT
Q
WHAT
IS
THE
PROBLEM
WITH
IMPLEMENTATION
INHERITANCE
A
SUBTYPING
MAKES
MODULAR
PROGRAMMING
MORE
DIFFICULT
FOR
TWO
REASONS
FIRST
ANY
CHANGE
IN
THE
SUPERCLASS
AFFECTS
ALL
SUBCLASSES
THE
SUBCLASS
CANNOT
BE
DEVELOPED
INDE
PENDENTLY
OF
THE
SUPERCLASS
INDEED
IT
IS
COMPLETELY
DEPENDENT
ON
THE
SUPERCLASS
THIS
PROBLEM
IS
KNOWN
AS
THE
FRAGILE
BASE
CLASS
PROBLEM
SECOND
THE
SUBCLASS
CODE
HAV
ING
ACCESS
TO
INSTANCE
VARIABLES
CAN
SUBVERT
THE
INTENTION
OF
THE
SUPERCLASS
CODE
FOR
EXAMPLE
THE
DESIGNER
OF
A
CLASS
LIKE
COUNTER
FOR
A
VOTING
SYSTEM
MAY
TAKE
GREAT
CARE
TO
MAKE
IT
SO
THAT
COUNTER
CAN
ONLY
INCREMENT
THE
TALLY
BY
ONE
REMEMBER
AL
GORE
PROBLEM
BUT
A
SUBCLASS
WITH
FULL
ACCESS
TO
THE
INSTANCE
VARIABLE
CAN
CHANGE
IT
TO
ANY
VALUE
WHATEVER
Q
HOW
DO
I
MAKE
A
CLASS
IMMUTABLE
A
TO
ENSURE
IMMUTABILITY
OF
A
DATA
TYPE
THAT
INCLUDES
AN
INSTANCE
VARIABLE
OF
A
MU
TABLE
TYPE
WE
NEED
TO
MAKE
A
LOCAL
COPY
KNOWN
AS
A
DEFENSIVE
COPY
AND
THAT
MAY
NOT
BE
ENOUGH
MAKING
THE
COPY
IS
ONE
CHALLENGE
ENSURING
THAT
NONE
OF
THE
INSTANCE
METHODS
CHANGE
VALUES
IS
ANOTHER
Q
WHAT
IS
NULL
A
IT
IS
A
LITERAL
VALUE
THAT
REFERS
TO
NO
OBJECT
INVOKING
A
METHOD
USING
THE
NULL
REF
ERENCE
IS
MEANINGLESS
AND
RESULTS
IN
A
NULLPOINTEREXCEPTION
IF
YOU
GET
THIS
ERROR
MESSAGE
CHECK
TO
MAKE
SURE
THAT
YOUR
CONSTRUCTOR
PROPERLY
INITIALIZES
ALL
OF
ITS
INSTANCE
VARIABLES
Q
CAN
I
HAVE
A
STATIC
METHOD
IN
A
CLASS
THAT
IMPLEMENTS
A
DATA
TYPE
A
OF
COURSE
FOR
EXAMPLE
ALL
OF
OUR
CLASSES
HAVE
MAIN
ALSO
IT
IS
NATURAL
TO
CONSIDER
ADDING
STATIC
METHODS
FOR
OPERATIONS
THAT
INVOLVE
MULTIPLE
OBJECTS
WHERE
NONE
OF
THEM
NATURALLY
SUGGESTS
ITSELF
AS
THE
ONE
THAT
SHOULD
INVOKE
THE
METHOD
FOR
EXAMPLE
WE
MIGHT
DEFINE
A
STATIC
METHOD
LIKE
THE
FOLLOWING
WITHIN
POINT
PUBLIC
STATIC
DOUBLE
DISTANCE
POINT
A
POINT
B
RETURN
A
DISTTO
B
OFTEN
INCLUDING
SUCH
METHODS
CAN
SERVE
TO
CLARIFY
CLIENT
CODE
Q
ARE
THERE
OTHER
KINDS
OF
VARIABLES
BESIDES
PARAMETER
LOCAL
AND
INSTANCE
VARIABLES
A
IF
YOU
INCLUDE
THE
KEYWORD
STATIC
IN
A
CLASS
DECLARATION
OUTSIDE
OF
ANY
TYPE
IT
CREATES
A
COMPLETELY
DIFFERENT
TYPE
OF
VARIABLE
KNOWN
AS
A
STATIC
VARIABLE
LIKE
INSTANCE
VARIABLES
STATIC
VARIABLES
ARE
ACCESSIBLE
TO
EVERY
METHOD
IN
THE
CLASS
HOWEVER
THEY
ARE
NOT
ASSOCIATED
WITH
ANY
OBJECT
IN
OLDER
PROGRAMMING
LANGUAGES
SUCH
VARIABLES
ARE
KNOWN
AS
GLOBAL
VARIABLES
BECAUSE
OF
THEIR
GLOBAL
SCOPE
IN
MODERN
PROGRAMMING
WE
FOCUS
ON
LIMITING
SCOPE
AND
THEREFORE
RARELY
USE
SUCH
VARIABLES
WHEN
WE
DO
WE
WILL
CALL
ATTENTION
TO
THEM
Q
WHAT
IS
A
DEPRECATED
METHOD
A
A
METHOD
THAT
IS
NO
LONGER
FULLY
SUPPORTED
BUT
KEPT
IN
AN
API
TO
MAINTAIN
COMPAT
IBILITY
FOR
EXAMPLE
JAVA
ONCE
INCLUDED
A
METHOD
CHARACTER
ISSPACE
AND
PRO
GRAMMERS
WROTE
PROGRAMS
THAT
RELIED
ON
USING
THAT
METHOD
BEHAVIOR
WHEN
THE
DE
SIGNERS
OF
JAVA
LATER
WANTED
TO
SUPPORT
ADDITIONAL
UNICODE
WHITESPACE
CHARACTERS
THEY
COULD
NOT
CHANGE
THE
BEHAVIOR
OF
ISSPACE
WITHOUT
BREAKING
CLIENT
PROGRAMS
SO
INSTEAD
THEY
ADDED
A
NEW
METHOD
CHARACTER
ISWHITESPACE
AND
DEPRECATED
THE
OLD
METHOD
AS
TIME
WEARS
ON
THIS
PRACTICE
CERTAINLY
COMPLICATES
APIS
SOMETIMES
EN
TIRE
CLASSES
ARE
DEPRECATED
FOR
EXAMPLE
JAVA
DEPRECATED
ITS
JAVA
UTIL
DATE
IN
ORDER
TO
BETTER
SUPPORT
INTERNATIONALIZATION
WRITE
A
CLIENT
THAT
TAKES
AN
INTEGER
VALUE
N
FROM
THE
COMMAND
LINE
GENERATES
N
RANDOM
POINTS
IN
THE
UNIT
SQUARE
AND
COMPUTES
THE
DISTANCE
SEPARATING
THE
CLOSEST
PAIR
OF
POINTS
WRITE
AN
CLIENT
THAT
TAKES
AN
INT
VALUE
N
AS
COMMAND
LINE
ARGU
MENT
READS
N
INTERVALS
EACH
DEFINED
BY
A
PAIR
OF
DOUBLE
VALUES
FROM
STANDARD
INPUT
AND
PRINTS
ALL
PAIRS
THAT
INTERSECT
WRITE
AN
CLIENT
THAT
TAKES
COMMAND
LINE
ARGUMENTS
N
MIN
AND
MAX
AND
GENERATES
N
RANDOM
INTERVALS
WHOSE
WIDTH
AND
HEIGHT
ARE
UNIFORMLY
DISTRIBUTED
BETWEEN
MIN
AND
MAX
IN
THE
UNIT
SQUARE
DRAW
THEM
ON
STDDRAW
AND
PRINT
THE
NUMBER
OF
PAIRS
OF
INTERVALS
THAT
INTERSECT
AND
THE
NUMBER
OF
INTERVALS
THAT
ARE
CONTAINED
IN
ONE
ANOTHER
WHAT
DOES
THE
FOLLOWING
CODE
FRAGMENT
PRINT
STRING
HELLO
STRING
WORLD
STDOUT
PRINTLN
STDOUT
PRINTLN
WHAT
DOES
THE
FOLLOWING
CODE
FRAGMENT
PRINT
STRING
HELLO
WORLD
TOUPPERCASE
SUBSTRING
STDOUT
PRINTLN
ANSWER
HELLO
WORLD
STRING
OBJECTS
ARE
IMMUTABLE
STRING
METHODS
RETURN
A
NEW
STRING
OBJECT
WITH
THE
APPROPRIATE
VALUE
BUT
THEY
DO
NOT
CHANGE
THE
VALUE
OF
THE
OBJECT
THAT
WAS
USED
TO
INVOKE
THEM
THIS
CODE
IGNORES
THE
OBJECTS
RETURNED
AND
JUST
PRINTS
THE
ORIGINAL
STRING
TO
PRINT
WORLD
USE
TOUPPERCASE
AND
SUBSTRING
A
STRING
IS
A
CIRCULAR
ROTATION
OF
A
STRING
T
IF
IT
MATCHES
WHEN
THE
CHARACTERS
ARE
CIRCULARLY
SHIFTED
BY
ANY
NUMBER
OF
POSITIONS
E
G
ACTGACG
IS
A
CIRCULAR
SHIFT
OF
TGACGAC
AND
VICE
VERSA
DETECTING
THIS
CONDITION
IS
IMPORTANT
IN
THE
STUDY
OF
GENOMIC
SEQUENCES
WRITE
A
PROGRAM
THAT
CHECKS
WHETHER
TWO
GIVEN
STRINGS
AND
T
ARE
CIRCULAR
SHIFTS
OF
ONE
ANOTHER
HINT
THE
SOLUTION
IS
A
ONE
LINER
WITH
INDEXOF
LENGTH
AND
STRING
CONCATENATION
WHAT
DOES
THE
FOLLOWING
RECURSIVE
FUNCTION
RETURN
PUBLIC
STATIC
STRING
MYSTERY
STRING
INT
N
LENGTH
IF
N
RETURN
STRING
A
SUBSTRING
N
STRING
B
SUBSTRING
N
N
RETURN
MYSTERY
B
MYSTERY
A
SUPPOSE
THAT
A
AND
B
ARE
EACH
INTEGER
ARRAYS
CONSISTING
OF
MILLIONS
OF
INTE
GERS
WHAT
DOES
THE
FOLLOW
CODE
DO
IS
IT
REASONABLY
EFFICIENT
INT
T
A
A
B
B
T
ANSWER
IT
SWAPS
THEM
IT
COULD
HARDLY
BE
MORE
EFFICIENT
BECAUSE
IT
DOES
SO
BY
COPYING
REFERENCES
SO
THAT
IT
IS
NOT
NECESSARY
TO
COPY
MILLIONS
OF
ELEMENTS
INSTRUMENT
BINARYSEARCH
PAGE
TO
USE
A
COUNTER
TO
COUNT
THE
TOTAL
NUMBER
OF
KEYS
EXAMINED
DURING
ALL
SEARCHES
AND
THEN
PRINT
THE
TOTAL
AFTER
ALL
SEARCHES
ARE
COM
PLETE
HINT
CREATE
A
COUNTER
IN
MAIN
AND
PASS
IT
AS
AN
ARGUMENT
TO
RANK
DEVELOP
A
CLASS
VISUALCOUNTER
THAT
ALLOWS
BOTH
INCREMENT
AND
DECREMENT
OPERATIONS
TAKE
TWO
ARGUMENTS
N
AND
MAX
IN
THE
CONSTRUCTOR
WHERE
N
SPECIFIES
THE
MAXIMUM
NUMBER
OF
OPERATIONS
AND
MAX
SPECIFIES
THE
MAXIMUM
ABSOLUTE
VALUE
FOR
THE
COUNTER
AS
A
SIDE
EFFECT
CREATE
A
PLOT
SHOWING
THE
VALUE
OF
THE
COUNTER
EACH
TIME
ITS
TALLY
CHANGES
DEVELOP
AN
IMPLEMENTATION
SMARTDATE
OF
OUR
DATE
API
THAT
RAISES
AN
EXCEP
TION
IF
THE
DATE
IS
NOT
LEGAL
ADD
A
METHOD
DAYOFTHEWEEK
TO
SMARTDATE
THAT
RETURNS
A
STRING
VALUE
MONDAY
TUESDAY
WEDNESDAY
THURSDAY
FRIDAY
SATURDAY
OR
SUNDAY
GIVING
THE
AP
PROPRIATE
DAY
OF
THE
WEEK
FOR
THE
DATE
YOU
MAY
ASSUME
THAT
THE
DATE
IS
IN
THE
CENTURY
EXERCISES
CONTINUED
USING
OURIMPLEMENTATIONOF
DATE
ASAMODEL
PAGE
DEVELOPANIMPLEMENTA
TION
OF
TRANSACTION
USING
OUR
IMPLEMENTATION
OF
EQUALS
IN
DATE
AS
A
MODEL
PAGE
DEVELOP
IMPLEMENTATIONS
OF
EQUALS
FOR
TRANSACTION
FILE
INPUT
DEVELOP
A
POSSIBLE
IMPLEMENTATION
OF
THE
STATIC
READINTS
METH
OD
FROM
IN
WHICH
WE
USE
FOR
VARIOUS
TEST
CLIENTS
SUCH
AS
BINARY
SEARCH
ON
PAGE
THAT
IS
BASED
ON
THE
SPLIT
METHOD
IN
STRING
SOLUTION
PUBLIC
STATIC
INT
READINTS
STRING
NAME
IN
IN
NEW
IN
NAME
STRING
INPUT
STDIN
READALL
STRING
WORDS
INPUT
SPLIT
INT
INTS
NEW
INT
WORDS
LENGTH
FOR
INT
I
I
WORD
LENGTH
I
INTS
I
INTEGER
PARSEINT
WORDS
I
RETURN
INTS
WE
WILL
CONSIDER
A
DIFFERENT
IMPLEMENTATION
IN
SECTION
SEE
PAGE
RATIONAL
NUMBERS
IMPLEMENT
AN
IMMUTABLE
DATA
TYPE
RATIONAL
FOR
RATIONAL
NUMBERS
THAT
SUPPORTS
ADDITION
SUBTRACTION
MULTIPLICATION
AND
DIVISION
PUBLIC
CLASS
RATIONAL
RATIONAL
INT
NUMERATOR
INT
DENOMINATOR
RATIONAL
PLUS
RATIONAL
B
SUM
OF
THIS
NUMBER
AND
B
RATIONAL
MINUS
RATIONAL
B
DIFFERENCE
OF
THIS
NUMBER
AND
B
RATIONAL
TIMES
RATIONAL
B
PRODUCT
OF
THIS
NUMBER
AND
B
RATIONAL
DIVIDES
RATIONAL
B
QUOTIENT
OF
THIS
NUMBER
AND
B
BOOLEAN
EQUALS
RATIONAL
THAT
IS
THIS
NUMBER
EQUAL
TO
THAT
STRING
TOSTRING
STRING
REPRESENTATION
YOU
DO
NOT
HAVE
TO
WORRY
ABOUT
TESTING
FOR
OVERFLOW
SEE
EXERCISE
BUT
USE
AS
INSTANCE
VARIABLES
TWO
LONG
VALUES
THAT
REPRESENT
THE
NUMERATOR
AND
DENOMINATOR
TO
LIMIT
THE
POSSIBILITY
OF
OVERFLOW
USE
EUCLID
ALGORITHM
SEE
PAGE
TO
ENSURE
THAT
THE
NUMERATOR
AND
DENOMINATOR
NEVER
HAVE
ANY
COMMON
FACTORS
INCLUDE
A
TEST
CLIENT
THAT
EXERCISES
ALL
OF
YOUR
METHODS
CREATIVE
PROBLEMS
CONTINUED
ROBUST
IMPLEMENTATION
OF
RATIONAL
NUMBERS
USE
ASSERTIONS
TO
DEVELOP
AN
IM
PLEMENTATION
OF
RATIONAL
SEE
EXERCISE
THAT
IS
IMMUNE
TO
OVERFLOW
VARIANCE
FOR
ACCUMULATOR
VALIDATE
THAT
THE
FOLLOWING
CODE
WHICH
ADDS
THE
METHODS
VAR
AND
STDDEV
TO
ACCUMULATOR
COMPUTES
BOTH
THE
MEAN
AND
VARIANCE
OF
THE
NUMBERS
PRESENTED
AS
ARGUMENTS
TO
ADDDATAVALUE
PUBLIC
CLASS
ACCUMULATOR
PRIVATE
DOUBLE
M
PRIVATE
DOUBLE
PRIVATE
INT
N
PUBLIC
VOID
ADDDATAVALUE
DOUBLE
X
N
N
N
X
M
X
M
M
M
X
M
N
PUBLIC
DOUBLE
MEAN
RETURN
M
PUBLIC
DOUBLE
VAR
RETURN
N
PUBLIC
DOUBLE
STDDEV
RETURN
MATH
SQRT
THIS
VAR
THIS
IMPLEMENTATION
IS
LESS
SUSCEPTIBLE
TO
ROUNDOFF
ERROR
THAN
THE
STRAIGHTFORWARD
IM
PLEMENTATION
BASED
ON
SAVING
THE
SUM
OF
THE
SQUARES
OF
THE
NUMBERS
PARSING
DEVELOP
THE
PARSE
CONSTRUCTORS
FOR
YOUR
DATE
AND
TRANSACTION
IM
PLEMENTATIONS
OF
EXERCISE
THAT
TAKE
A
SINGLE
STRING
ARGUMENT
TO
SPECIFY
THE
INITIALIZATION
VALUES
USING
THE
FORMATS
GIVEN
IN
THE
TABLE
BELOW
PARTIAL
SOLUTION
PUBLIC
DATE
STRING
DATE
STRING
FIELDS
DATE
SPLIT
MONTH
INTEGER
PARSEINT
FIELDS
DAY
INTEGER
PARSEINT
FIELDS
YEAR
INTEGER
PARSEINT
FIELDS
TYPE
FORMAT
EXAMPLE
DATE
INTEGERS
SEPARATED
BY
SLASHES
TRANSACTION
CUSTOMER
DATE
AND
AMOUNT
SEPARATED
BY
WHITESPACE
FORMATS
FOR
PARSING
TURING
SEVERAL
FUNDAMENTAL
DATA
TYPES
INVOLVE
COLLECTIONS
OF
OBJECTS
SPECIFICALLY
THE
SET
OF
VALUES
IS
A
COLLECTION
OF
OBJECTS
AND
THE
OPERATIONS
REVOLVE
AROUND
ADDING
REMOV
ING
OR
EXAMINING
OBJECTS
IN
THE
COLLECTION
IN
THIS
SECTION
WE
CONSIDER
THREE
SUCH
DATA
TYPES
KNOWN
AS
THE
BAG
THE
QUEUE
AND
THE
STACK
THEY
DIFFER
IN
THE
SPECIFICATION
OF
WHICH
OBJECT
IS
TO
BE
REMOVED
OR
EXAMINED
NEXT
BAGS
QUEUES
AND
STACKS
ARE
FUNDAMENTAL
AND
BROADLY
USEFUL
WE
USE
THEM
IN
IMPLE
MENTATIONS
THROUGHOUT
THE
BOOK
BEYOND
THIS
DIRECT
APPLICABILITY
THE
CLIENT
AND
IMPLE
MENTATION
CODE
IN
THIS
SECTION
SERVES
AS
AN
INTRODUCTION
TO
OUR
GENERAL
APPROACH
TO
THE
DEVELOPMENT
OF
DATA
STRUCTURES
AND
ALGORITHMS
ONE
GOAL
OF
THIS
SECTION
IS
TO
EMPHASIZE
THE
IDEA
THAT
THE
WAY
IN
WHICH
WE
REPRESENT
THE
OBJECTS
IN
THE
COLLECTION
DIRECTLY
IMPACTS
THE
EFFICIENCY
OF
THE
VARIOUS
OPERATIONS
FOR
COLLECTIONS
WE
DESIGN
DATA
STRUCTURES
FOR
REPRESENTING
THE
COLLECTION
OF
OBJECTS
THAT
CAN
SUPPORT
EFFICIENT
IMPLEMENTATION
OF
THE
REQUISITE
OPERATIONS
A
SECOND
GOAL
OF
THIS
SECTION
IS
TO
INTRODUCE
GENERICS
AND
ITERATION
BASIC
JAVA
CON
STRUCTS
THAT
SUBSTANTIALLY
SIMPLIFY
CLIENT
CODE
THESE
ARE
ADVANCED
PROGRAMMING
LAN
GUAGE
MECHANISMS
THAT
ARE
NOT
NECESSARILY
ESSENTIAL
TO
THE
UNDERSTANDING
OF
ALGORITHMS
BUT
THEIR
USE
ALLOWS
US
TO
DEVELOP
CLIENT
CODE
AND
IMPLEMENTATIONS
OF
ALGORITHMS
THAT
IS
MORE
CLEAR
COMPACT
AND
ELEGANT
THAN
WOULD
OTHERWISE
BE
POSSIBLE
A
THIRD
GOAL
OF
THIS
SECTION
IS
TO
INTRODUCE
AND
SHOW
THE
IMPORTANCE
OF
LINKED
DATA
STRUCTURES
IN
PARTICULAR
A
CLASSIC
DATA
STRUCTURE
KNOWN
AS
THE
LINKED
LIST
ENABLES
IM
PLEMENTATION
OF
BAGS
QUEUES
AND
STACKS
THAT
ACHIEVE
EFFICIENCIES
NOT
OTHERWISE
POS
SIBLE
UNDERSTANDING
LINKED
LISTS
IS
A
KEY
FIRST
STEP
TO
THE
STUDY
OF
ALGORITHMS
AND
DATA
STRUCTURES
FOR
EACH
OF
THE
THREE
TYPES
WE
CONSIDER
APIS
AND
SAMPLE
CLIENT
PROGRAMS
THEN
LOOK
AT
POSSIBLE
REPRESENTATIONS
OF
THE
DATA
TYPE
VALUES
AND
IMPLEMENTATIONS
OF
THE
DATA
TYPE
OPERATIONS
THIS
SCENARIO
REPEATS
WITH
MORE
COMPLICATED
DATA
STRUCTURES
THROUGHOUT
THIS
BOOK
THE
IMPLEMENTATIONS
HERE
ARE
MODELS
OF
IMPLEMENTATIONS
LATER
IN
THE
BOOK
AND
WORTHY
OF
CAREFUL
STUDY
APIS
AS
USUAL
WE
BEGIN
OUR
DISCUSSION
OF
ABSTRACT
DATA
TYPES
FOR
COLLECTIONS
BY
DE
FINING
THEIR
APIS
SHOWN
BELOW
EACH
CONTAINS
A
NO
ARGUMENT
CONSTRUCTOR
A
METHOD
TO
ADD
AN
ITEM
TO
THE
COLLECTION
A
METHOD
TO
TEST
WHETHER
THE
COLLECTION
IS
EMPTY
AND
A
METHOD
THAT
RETURNS
THE
SIZE
OF
THE
COLLECTION
STACK
AND
QUEUE
EACH
HAVE
A
METHOD
TO
REMOVE
A
PARTICULAR
ITEM
FROM
THE
COLLECTION
BEYOND
THESE
BASICS
THESE
APIS
REFLECT
TWO
JAVA
FEATURES
THAT
WE
WILL
DESCRIBE
ON
THE
NEXT
FEW
PAGES
GENERICS
AND
ITERABLE
COLLECTIONS
BAG
PUBLIC
CLASS
BAG
ITEM
IMPLEMENTS
ITERABLE
ITEM
BAG
CREATE
AN
EMPTY
BAG
VOID
ADD
ITEM
ITEM
ADD
AN
ITEM
BOOLEAN
ISEMPTY
IS
THE
BAG
EMPTY
INT
SIZE
NUMBER
OF
ITEMS
IN
THE
BAG
FIFO
QUEUE
PUBLIC
CLASS
QUEUE
ITEM
IMPLEMENTS
ITERABLE
ITEM
QUEUE
CREATE
AN
EMPTY
QUEUE
VOID
ENQUEUE
ITEM
ITEM
ADD
AN
ITEM
ITEM
DEQUEUE
REMOVE
THE
LEAST
RECENTLY
ADDED
ITEM
BOOLEAN
ISEMPTY
IS
THE
QUEUE
EMPTY
INT
SIZE
NUMBER
OF
ITEMS
IN
THE
QUEUE
PUSHDOWN
LIFO
STACK
PUBLIC
CLASS
STACK
ITEM
IMPLEMENTS
ITERABLE
ITEM
STACK
CREATE
AN
EMPTY
STACK
VOID
PUSH
ITEM
ITEM
ADD
AN
ITEM
ITEM
POP
REMOVE
THE
MOST
RECENTLY
ADDED
ITEM
BOOLEAN
ISEMPTY
IS
THE
STACK
EMPTY
INT
SIZE
NUMBER
OF
ITEMS
IN
THE
STACK
APIS
FOR
FUNDAMENTAL
GENERIC
ITERABLE
COLLECTIONS
GENERICS
AN
ESSENTIAL
CHARACTERISTIC
OF
COLLECTION
ADTS
IS
THAT
WE
SHOULD
BE
ABLE
TO
USE
THEM
FOR
ANY
TYPE
OF
DATA
A
SPECIFIC
JAVA
MECHANISM
KNOWN
AS
GENERICS
ALSO
KNOWN
AS
PARAMETERIZED
TYPES
ENABLES
THIS
CAPABILITY
THE
IMPACT
OF
GENERICS
ON
THE
PROGRAM
MING
LANGUAGE
IS
SUFFICIENTLY
DEEP
THAT
THEY
ARE
NOT
FOUND
IN
MANY
LANGUAGES
INCLUDING
EARLY
VERSIONS
OF
JAVA
BUT
OUR
USE
OF
THEM
IN
THE
PRESENT
CONTEXT
INVOLVES
JUST
A
SMALL
BIT
OF
EXTRA
JAVA
SYNTAX
AND
IS
EASY
TO
UNDERSTAND
THE
NOTATION
ITEM
AFTER
THE
CLASS
NAME
IN
EACH
OF
OUR
APIS
DEFINES
THE
NAME
ITEM
AS
A
TYPE
PARAMETER
A
SYMBOLIC
PLACE
HOLDER
FOR
SOME
CONCRETE
TYPE
TO
BE
USED
BY
THE
CLIENT
YOU
CAN
READ
STACK
ITEM
AS
STACK
OF
ITEMS
WHEN
IMPLEMENTING
STACK
WE
DO
NOT
KNOW
THE
CONCRETE
TYPE
OF
ITEM
BUT
A
CLIENT
CAN
USE
OUR
STACK
FOR
ANY
TYPE
OF
DATA
INCLUDING
ONE
DEFINED
LONG
AFTER
WE
DEVELOP
OUR
IMPLEMENTATION
THE
CLIENT
CODE
PROVIDES
A
CONCRETE
TYPE
WHEN
THE
STACK
IS
CREATED
WE
CAN
REPLACE
ITEM
WITH
THE
NAME
OF
ANY
REFERENCE
DATA
TYPE
CONSISTENTLY
EVERYWHERE
IT
APPEARS
THIS
PROVIDES
EXACTLY
THE
CAPABILITY
THAT
WE
NEED
FOR
EXAMPLE
YOU
CAN
WRITE
CODE
SUCH
AS
STACK
STRING
STACK
NEW
STACK
STRING
STACK
PUSH
TEST
STRING
NEXT
STACK
POP
TO
USE
A
STACK
FOR
STRING
OBJECTS
AND
CODE
SUCH
AS
QUEUE
DATE
QUEUE
NEW
QUEUE
DATE
QUEUE
ENQUEUE
NEW
DATE
DATE
NEXT
QUEUE
DEQUEUE
TO
USE
A
QUEUE
FOR
DATE
OBJECTS
IF
YOU
TRY
TO
ADD
A
DATE
OR
DATA
OF
ANY
OTHER
TYPE
THAN
STRING
TO
STACK
OR
A
STRING
OR
DATA
OF
ANY
OTHER
TYPE
THAN
DATE
TO
QUEUE
YOU
WILL
GET
A
COMPILE
TIME
ERROR
WITHOUT
GENERICS
WE
WOULD
HAVE
TO
DEFINE
AND
IMPLEMENT
DIFFERENT
APIS
FOR
EACH
TYPE
OF
DATA
WE
MIGHT
NEED
TO
COLLECT
WITH
GENERICS
WE
CAN
USE
ONE
API
AND
ONE
IMPLEMENTATION
FOR
ALL
TYPES
OF
DATA
EVEN
TYPES
THAT
ARE
IMPLE
MENTED
IN
THE
FUTURE
AS
YOU
WILL
SOON
SEE
GENERIC
TYPES
LEAD
TO
CLEAR
CLIENT
CODE
THAT
IS
EASY
TO
UNDERSTAND
AND
DEBUG
SO
WE
USE
THEM
THROUGHOUT
THIS
BOOK
AUTOBOXING
TYPE
PARAMETERS
HAVE
TO
BE
INSTANTIATED
AS
REFERENCE
TYPES
SO
JAVA
HAS
SPECIAL
MECHANISMS
TO
ALLOW
GENERIC
CODE
TO
BE
USED
WITH
PRIMITIVE
TYPES
RECALL
THAT
JAVA
WRAPPER
TYPES
ARE
REFERENCE
TYPES
THAT
CORRESPOND
TO
PRIMITIVE
TYPES
BOOLEAN
BYTE
CHARACTER
DOUBLE
FLOAT
INTEGER
LONG
AND
SHORT
CORRESPOND
TO
BOOLEAN
BYTE
CHAR
DOUBLE
FLOAT
INT
LONG
AND
SHORT
RESPECTIVELY
JAVA
AUTOMATICALLY
CON
VERTS
BETWEEN
THESE
REFERENCE
TYPES
AND
THE
CORRESPONDING
PRIMITIVE
TYPES
IN
ASSIGN
MENTS
METHOD
ARGUMENTS
AND
ARITHMETIC
LOGIC
EXPRESSIONS
IN
THE
PRESENT
CONTEXT
THIS
CONVERSION
IS
HELPFUL
BECAUSE
IT
ENABLES
US
TO
USE
GENERICS
WITH
PRIMITIVE
TYPES
AS
IN
THE
FOLLOWING
CODE
STACK
INTEGER
STACK
NEW
STACK
INTEGER
STACK
PUSH
AUTO
BOXING
INT
INTEGER
INT
I
STACK
POP
AUTO
UNBOXING
INTEGER
INT
AUTOMATICALLY
CASTING
A
PRIMITIVE
TYPE
TO
A
WRAPPER
TYPE
IS
KNOWN
AS
AUTOBOXING
AND
AUTOMATICALLY
CASTING
A
WRAPPER
TYPE
TO
A
PRIMITIVE
TYPE
IS
KNOWN
AS
AUTO
UNBOXING
IN
THIS
EXAMPLE
JAVA
AUTOMATICALLY
CASTS
AUTOBOXES
THE
PRIMITIVE
VALUE
TO
BE
OF
TYPE
INTEGER
WHEN
WE
PASS
IT
TO
THE
PUSH
METHOD
THE
POP
METHOD
RETURNS
AN
INTEGER
WHICH
JAVA
CASTS
AUTO
UNBOXES
TO
AN
INT
BEFORE
ASSIGNING
IT
TO
THE
VARIABLE
I
ITERABLE
COLLECTIONS
FOR
MANY
APPLICATIONS
THE
CLIENT
REQUIREMENT
IS
JUST
TO
PROCESS
EACH
OF
THE
ITEMS
IN
SOME
WAY
OR
TO
ITERATE
THROUGH
THE
ITEMS
IN
THE
COLLECTION
THIS
PARADIGM
IS
SO
IMPORTANT
THAT
IT
HAS
ACHIEVED
FIRST
CLASS
STATUS
IN
JAVA
AND
MANY
OTHER
MODERN
LANGUAGES
THE
PROGRAMMING
LANGUAGE
ITSELF
HAS
SPECIFIC
MECHANISMS
TO
SUP
PORT
IT
NOT
JUST
THE
LIBRARIES
WITH
IT
WE
CAN
WRITE
CLEAR
AND
COMPACT
CODE
THAT
IS
FREE
FROM
DEPENDENCE
ON
THE
DETAILS
OF
A
COLLECTION
IMPLEMENTATION
FOR
EXAMPLE
SUPPOSE
THAT
A
CLIENT
MAINTAINS
A
COLLECTION
OF
TRANSACTIONS
IN
A
QUEUE
AS
FOLLOWS
QUEUE
TRANSACTION
COLLECTION
NEW
QUEUE
TRANSACTION
IF
THE
COLLECTION
IS
ITERABLE
THE
CLIENT
CAN
PRINT
A
TRANSACTION
LIST
WITH
A
SINGLE
STATEMENT
FOR
TRANSACTION
T
COLLECTION
STDOUT
PRINTLN
T
THIS
CONSTRUCT
IS
KNOWN
AS
THE
FOREACH
STATEMENT
YOU
CAN
READ
THE
FOR
STATEMENT
AS
FOR
EACH
TRANSACTION
T
IN
THE
COLLECTION
EXECUTE
THE
FOLLOWING
BLOCK
OF
CODE
THIS
CLIENT
CODE
DOES
NOT
NEED
TO
KNOW
ANYTHING
ABOUT
THE
REPRESENTATION
OR
THE
IMPLEMENTATION
OF
THE
COLLECTION
IT
JUST
WANTS
TO
PROCESS
EACH
OF
THE
ITEMS
IN
THE
COLLECTION
THE
SAME
FOR
LOOP
WOULD
WORK
WITH
A
BAG
OF
TRANSACTIONS
OR
ANY
OTHER
ITERABLE
COLLECTION
WE
COULD
HARDLY
IMAGINE
CLIENT
CODE
THAT
IS
MORE
CLEAR
AND
COMPACT
AS
YOU
WILL
SEE
SUPPORTING
THIS
CAPABILITY
REQUIRES
EXTRA
EFFORT
IN
THE
IMPLEMENTATION
BUT
THIS
EFFORT
IS
WELL
WORTHWHILE
IT
IS
INTERESTING
TO
NOTE
THAT
THE
ONLY
DIFFERENCES
BETWEEN
THE
APIS
FOR
STACK
AND
QUEUE
ARE
THEIR
NAMES
AND
THE
NAMES
OF
THE
METHODS
THIS
OBSERVATION
HIGHLIGHTS
THE
IDEA
THAT
WE
CANNOT
EASILY
SPECIFY
ALL
OF
THE
CHARACTERISTICS
OF
A
DATA
TYPE
IN
A
LIST
OF
METHOD
SIGNATURES
IN
THIS
CASE
THE
TRUE
SPECIFICATION
HAS
TO
DO
WITH
THE
ENGLISH
LAN
GUAGE
DESCRIPTIONS
THAT
SPECIFY
THE
RULES
BY
WHICH
AN
ITEM
IS
CHOSEN
TO
BE
REMOVED
OR
TO
BE
PROCESSED
NEXT
IN
THE
FOREACH
STATEMENT
DIFFERENCES
IN
THESE
RULES
ARE
PROFOUND
PART
OF
THE
API
AND
CERTAINLY
OF
CRITICAL
IMPORTANCE
IN
DEVELOPING
CLIENT
CODE
BAGS
A
BAG
IS
A
COLLECTION
WHERE
REMOVING
ITEMS
IS
NOT
SUPPORTED
ITS
PURPOSE
IS
TO
PROVIDE
CLIENTS
WITH
THE
ABILITY
TO
COLLECT
ITEMS
AND
THEN
TO
ITERATE
THROUGH
THE
COLLECTED
ITEMS
THE
CLIENT
CAN
ALSO
TEST
IF
A
BAG
IS
EMPTY
AND
FIND
ITS
NUMBER
OF
ITEMS
THE
ORDER
OF
ITERATION
IS
UNSPECIFIED
AND
SHOULD
BE
IMMATERIAL
TO
THE
CLIENT
TO
APPRECIATE
THE
CON
CEPT
CONSIDER
THE
IDEA
OF
AN
AVID
MARBLE
COLLECTOR
WHO
MIGHT
PUT
MARBLES
IN
A
BAG
ONE
AT
A
TIME
AND
PERIODICALLY
PROCESS
ALL
THE
MARBLES
TO
LOOK
FOR
ONE
HAVING
SOME
PARTICULAR
CHARACTERISTIC
WITH
OUR
BAG
API
A
CLIENT
CAN
ADD
ITEMS
TO
A
BAG
AND
PROCESS
THEM
ALL
WITH
A
FOREACH
STATEMENT
WHENEVER
NEEDED
SUCH
A
CLI
ENT
COULD
USE
A
STACK
OR
A
QUEUE
BUT
ONE
WAY
TO
EMPHASIZE
THAT
THE
ORDER
IN
WHICH
ITEMS
ARE
PROCESSED
IS
IMMATERIAL
IS
TO
USE
A
BAG
THE
CLASS
STATS
AT
RIGHT
ILLUSTRATES
A
TYPI
CAL
BAG
CLIENT
THE
TASK
IS
SIMPLY
TO
COMPUTE
THE
AVERAGE
AND
THE
SAMPLE
STANDARD
DEVIATION
OF
THE
DOUBLE
VALUES
ON
STANDARD
INPUT
IF
THERE
ARE
N
NUMBERS
ON
STANDARD
IN
PUT
THEIR
AVERAGE
IS
COMPUTED
BY
ADDING
THE
NUMBERS
AND
DIVIDING
BY
N
THEIR
SAMPLE
STANDARD
DEVIATION
IS
COMPUT
ED
BY
ADDING
THE
SQUARES
OF
THE
DIFFERENCE
BETWEEN
EACH
NUMBER
AND
THE
AVERAGE
DIVIDING
BY
N
AND
TAKING
THE
SQUARE
ROOT
THE
ORDER
IN
WHICH
THE
NUMBERS
ARE
CONSID
ERED
IS
NOT
RELEVANT
FOR
EITHER
OF
THESE
CALCULATIONS
SO
WE
SAVE
THEM
IN
A
BAG
AND
USE
THE
FOREACH
CONSTRUCT
TO
COM
PUTE
EACH
SUM
NOTE
IT
IS
POSSIBLE
TO
COMPUTE
THE
STANDARD
DEVIATION
WITHOUT
SAVING
ALL
THE
NUMBERS
AS
WE
DID
FOR
THE
AVERAGE
IN
ACCUMULATOR
SEE
EXERCISE
KEEPING
THE
ALL
NUMBERS
IN
A
BAG
IS
REQUIRED
FOR
MORE
COMPLICATED
STATISTICS
A
BAG
OF
MARBLES
ADD
ADD
FOR
MARBLE
M
BAG
PROCESS
EACH
MARBLE
M
IN
ANY
ORDER
OPERATIONS
ON
A
BAG
TYPICAL
BAG
CLIENT
APPLICATION
FIFO
QUEUES
A
FIFO
QUEUE
OR
JUST
A
QUEUE
IS
A
COLLECTION
THAT
IS
BASED
ON
THE
FIRST
IN
FIRST
OUT
FIFO
POLICY
THE
POLICY
OF
DOING
TASKS
IN
THE
SAME
ORDER
THAT
THEY
ARRIVE
IS
ONE
THAT
WE
ENCOUNTER
FREQUENTLY
IN
EVERYDAY
LIFE
ENQUEUE
ENQUEUE
DEQUEUE
DEQUEUE
SERVER
FIRST
IN
LINE
LEAVES
QUEUE
NEXT
IN
LINE
LEAVES
QUEUE
QUEUE
OF
CUSTOMERS
NEW
ARRIVAL
AT
THE
END
NEW
ARRIVAL
AT
THE
END
FROM
PEOPLE
WAITING
IN
LINE
AT
A
THEATER
TO
CARS
WAIT
ING
IN
LINE
AT
A
TOLL
BOOTH
TO
TASKS
WAITING
TO
BE
SER
VICED
BY
AN
APPLICATION
ON
YOUR
COMPUTER
ONE
BED
ROCK
PRINCIPLE
OF
ANY
SERVICE
POLICY
IS
THE
PERCEPTION
OF
FAIRNESS
THE
FIRST
IDEA
THAT
COMES
TO
MIND
WHEN
MOST
PEOPLE
THINK
ABOUT
FAIRNESS
IS
THAT
WHOEVER
HAS
BEEN
WAITING
THE
LONGEST
SHOULD
BE
SERVED
FIRST
THAT
IS
PRECISELY
THE
FIFO
DISCIPLINE
QUEUES
ARE
A
NATURAL
MODEL
FOR
MANY
EVERYDAY
PHENOMENA
AND
THEY
PLAY
A
CENTRAL
ROLE
IN
NUMEROUS
APPLICATIONS
WHEN
A
CLIENT
ITERATES
THROUGH
THE
ITEMS
IN
A
QUEUE
WITH
THE
FOREACH
CONSTRUCT
THE
ITEMS
ARE
PROCESSED
IN
THE
ORDER
THEY
WERE
ADDED
TO
THE
QUEUE
A
TYPI
CAL
REASON
TO
USE
A
QUEUE
IN
AN
APPLICATION
IS
TO
SAVE
ITEMS
IN
A
COLLECTION
WHILE
AT
THE
SAME
TIME
PRESERV
ING
THEIR
RELATIVE
ORDER
THEY
COME
OUT
IN
THE
SAME
ORDER
IN
WHICH
THEY
WERE
PUT
IN
FOR
EXAMPLE
THE
CLIENT
BELOW
IS
A
POSSIBLE
IMPLEMENTATION
OF
THE
READDOUBLES
STATIC
METHOD
FROM
OUR
IN
CLASS
A
TYPICAL
FIFO
QUEUE
THE
PROBLEM
THAT
THIS
METHOD
SOLVES
FOR
THE
CLIENT
IS
THAT
THE
CLIENT
CAN
GET
NUMBERS
FROM
A
FILE
INTO
AN
ARRAY
WITHOUT
KNOWING
THE
FILE
SIZE
AHEAD
OF
TIME
WE
ENQUEUE
THE
NUMBERS
FROM
THE
FILE
USE
THE
SIZE
METHOD
FROM
QUEUE
TO
FIND
THE
SIZE
NEEDED
FOR
THE
ARRAY
CREATE
THE
AR
RAY
AND
THEN
DEQUEUE
THE
NUM
BERS
TO
MOVE
THEM
TO
THE
ARRAY
A
QUEUE
IS
APPROPRIATE
BECAUSE
IT
PUTS
THE
NUMBERS
INTO
THE
AR
RAY
IN
THE
ORDER
IN
WHICH
THEY
APPEAR
IN
THE
FILE
WE
MIGHT
USE
A
BAG
IF
THAT
ORDER
IS
IMMATERI
AL
THIS
CODE
USES
AUTOBOXING
AND
AUTO
UNBOXING
TO
CONVERT
BETWEEN
THE
CLIENT
DOUBLE
PRIMITIVE
TYPE
AND
AND
THE
QUEUE
DOUBLE
WRAPPER
TYPE
PUSHDOWN
STACKS
A
PUSHDOWN
STACK
OR
JUST
A
STACK
IS
A
COLLECTION
THAT
IS
BASED
ON
THE
LAST
IN
FIRST
OUT
LIFO
POLICY
WHEN
YOU
KEEP
YOUR
MAIL
IN
A
PILE
ON
YOUR
DESK
YOU
ARE
USING
A
STACK
YOU
PILE
PIECES
OF
NEW
MAIL
ON
THE
TOP
WHEN
THEY
ARRIVE
AND
TAKE
EACH
PIECE
OF
MAIL
FROM
THE
TOP
WHEN
YOU
ARE
READY
TO
READ
IT
PEOPLE
DO
NOT
PROCESS
AS
MANY
PAPERS
AS
THEY
DID
IN
THE
PAST
BUT
THE
SAME
ORGANIZING
PRINCIPLE
UNDERLIES
SEVERAL
OF
THE
AP
PLICATIONS
THAT
YOU
USE
REGULARLY
ON
YOUR
COMPUTER
FOR
EXAMPLE
MANY
PEOPLE
ORGANIZE
THEIR
EMAIL
AS
A
STACK
THEY
PUSH
MESSAGES
ON
THE
TOP
WHEN
THEY
ARE
RECEIVED
AND
POP
THEM
FROM
THE
TOP
WHEN
THEY
READ
THEM
WITH
MOST
RECENTLY
RECEIVED
FIRST
LAST
IN
FIRST
OUT
THE
AD
VANTAGE
OF
THIS
STRATEGY
IS
THAT
WE
SEE
INTERESTING
EMAIL
AS
SOON
AS
POSSIBLE
THE
DISADVANTAGE
IS
THAT
SOME
OLD
EMAIL
MIGHT
NEVER
GET
READ
IF
WE
NEVER
EMPTY
THE
STACK
YOU
HAVE
LIKELY
ENCOUNTERED
ANOTHER
COMMON
EXAMPLE
OF
A
STACK
WHEN
SURFING
THE
WEB
WHEN
YOU
CLICK
A
HYPERLINK
YOUR
BROWSER
DISPLAYS
THE
NEW
PAGE
AND
PUSHES
ONTO
A
STACK
YOU
CAN
KEEP
CLICKING
ON
HYPERLINKS
TO
VISIT
NEW
PAGES
BUT
YOU
CAN
ALWAYS
REVISIT
THE
PREVIOUS
PAGE
BY
CLICKING
THE
BACK
BUTTON
POPPING
IT
FROM
THE
STACK
A
STACK
OF
DOCUMENTS
PUSH
PUSH
POP
POP
NEW
GRAY
ONE
GOES
ON
TOP
NEW
BLACK
ONE
GOES
ON
TOP
REMOVE
THE
BLACK
ONE
FROM
THE
TOP
REMOVE
THE
GRAY
ONE
FROM
THE
TOP
THE
LIFO
POLICY
OFFERED
BY
A
STACK
PROVIDES
JUST
THE
BE
HAVIOR
THAT
YOU
EXPECT
WHEN
A
CLIENT
ITERATES
THROUGH
THE
ITEMS
IN
A
STACK
WITH
THE
FOREACH
CONSTRUCT
THE
ITEMS
ARE
PROCESSED
IN
THE
REVERSE
OF
THE
ORDER
IN
WHICH
THEY
WERE
ADDED
A
TYPICAL
REASON
TO
USE
A
STACK
ITERATOR
IN
AN
APPLICATION
IS
TO
SAVE
ITEMS
IN
A
COLLECTION
WHILE
AT
THE
SAME
TIME
REVERSING
THEIR
RELATIVE
ORDER
FOR
EXAMPLE
THE
CLIENT
REVERSE
AT
RIGHT
REVERSES
THE
OR
DER
OF
THE
INTEGERS
ON
STANDARD
INPUT
AGAIN
WITHOUT
HAVING
TO
KNOW
AHEAD
OF
TIME
HOW
MANY
THERE
ARE
THE
IMPORTANCE
OF
STACKS
IN
COMPUTING
IS
FUNDAMENTAL
AND
PROFOUND
AS
INDICATED
IN
THE
DETAILED
EXAMPLE
THAT
WE
CONSIDER
NEXT
OPERATIONS
ON
A
PUSHDOWN
STACK
ARITHMETIC
EXPRESSION
EVALUATION
AS
ANOTHER
EXAMPLE
OF
A
STACK
CLIENT
WE
CONSIDER
A
CLASSIC
EXAMPLE
THAT
ALSO
DEMONSTRATES
THE
UTILITY
OF
GENERICS
SOME
OF
THE
FIRST
PRO
GRAMS
THAT
WE
CONSIDERED
IN
SECTION
INVOLVED
COMPUTING
THE
VALUE
OF
ARITHMETIC
EXPRESSIONS
LIKE
THIS
ONE
IF
YOU
MULTIPLY
BY
ADD
TO
MULTIPLY
THE
RESULT
AND
THEN
ADD
YOU
GET
THE
VALUE
BUT
HOW
DOES
THE
JAVA
SYSTEM
DO
THIS
CALCULATION
WITHOUT
GOING
INTO
THE
DETAILS
OF
HOW
THE
JAVA
SYSTEM
IS
BUILT
WE
CAN
ADDRESS
THE
ESSENTIAL
IDEAS
BY
WRITING
A
JAVA
PROGRAM
THAT
CAN
TAKE
A
STRING
AS
INPUT
THE
EXPRESSION
AND
PRODUCE
THE
NUMBER
REPRESENTED
BY
THE
EXPRESSION
AS
OUTPUT
FOR
SIMPLICITY
WE
BEGIN
WITH
THE
FOLLOWING
EXPLICIT
RECURSIVE
DEFINITION
AN
ARITHMETIC
EXPRESSION
IS
EITHER
A
NUMBER
OR
A
LEFT
PARENTHESIS
FOLLOWED
BY
AN
ARITHMETIC
EXPRESSION
FOLLOWED
BY
AN
OPERATOR
FOLLOWED
BY
ANOTHER
ARITHMETIC
EX
PRESSION
FOLLOWED
BY
A
RIGHT
PARENTHESIS
FOR
SIMPLICITY
THIS
DEFINITION
IS
FOR
FULLY
PAREN
THESIZED
ARITHMETIC
EXPRESSIONS
WHICH
SPECIFY
PRECISELY
WHICH
OPERATORS
APPLY
TO
WHICH
OPERANDS
YOU
ARE
A
BIT
MORE
FAMILIAR
WITH
EXPRESSIONS
SUCH
AS
WHERE
WE
OFTEN
RELY
ON
PRECEDENCE
RULES
INSTEAD
OF
PARENTHESES
THE
SAME
BASIC
MECHANISMS
THAT
WE
CONSIDER
CAN
HANDLE
PRECEDENCE
RULES
BUT
WE
AVOID
THAT
COMPLICATION
FOR
SPECI
FICITY
WE
SUPPORT
THE
FAMILIAR
BINARY
OPERATORS
AND
AS
WELL
AS
A
SQUARE
ROOT
OPERATOR
SQRT
THAT
TAKES
JUST
ONE
ARGUMENT
WE
COULD
EASILY
ALLOW
MORE
OPERATORS
AND
MORE
KINDS
OF
OPERATORS
TO
EMBRACE
A
LARGE
CLASS
OF
FAMILIAR
MATHEMATICAL
EXPRESSIONS
INVOLVING
TRIGONOMETRIC
EXPONENTIAL
AND
LOGARITHMIC
FUNCTIONS
OUR
FOCUS
IS
ON
UN
DERSTANDING
HOW
TO
INTERPRET
THE
STRING
OF
PARENTHESES
OPERATORS
AND
NUMBERS
TO
EN
ABLE
PERFORMING
IN
THE
PROPER
ORDER
THE
LOW
LEVEL
ARITHMETIC
OPERATIONS
THAT
ARE
AVAIL
ABLE
ON
ANY
COMPUTER
PRECISELY
HOW
CAN
WE
CONVERT
AN
ARITHMETIC
EXPRESSION
A
STRING
OF
CHARACTERS
TO
THE
VALUE
THAT
IT
REPRESENTS
A
REMARKABLY
SIMPLE
ALGORITHM
THAT
WAS
DEVELOPED
BY
E
W
DIJKSTRA
IN
THE
USES
TWO
STACKS
ONE
FOR
OPERANDS
AND
ONE
FOR
OPERATORS
TO
DO
THIS
JOB
AN
EXPRESSION
CONSISTS
OF
PARENTHESES
OPERATORS
AND
OPER
ANDS
NUMBERS
PROCEEDING
FROM
LEFT
TO
RIGHT
AND
TAKING
THESE
ENTITIES
ONE
AT
A
TIME
WE
MANIPULATE
THE
STACKS
ACCORDING
TO
FOUR
POSSIBLE
CASES
AS
FOLLOWS
PUSH
OPERANDS
ONTO
THE
OPERAND
STACK
PUSH
OPERATORS
ONTO
THE
OPERATOR
STACK
IGNORE
LEFT
PARENTHESES
ON
ENCOUNTERING
A
RIGHT
PARENTHESIS
POP
AN
OPERATOR
POP
THE
REQUISITE
NUMBER
OF
OPERANDS
AND
PUSH
ONTO
THE
OPERAND
STACK
THE
RESULT
OF
APPLYING
THAT
OPERA
TOR
TO
THOSE
OPERANDS
AFTER
THE
FINAL
RIGHT
PARENTHESIS
HAS
BEEN
PROCESSED
THERE
IS
ONE
VALUE
ON
THE
STACK
WHICH
IS
THE
VALUE
OF
THE
EXPRESSION
THIS
METHOD
MAY
SEEM
MYSTERIOUS
AT
FIRST
BUT
IT
DIJKSTRA
TWO
STACK
ALGORITHM
FOR
EXPRESSION
EVALUATION
PUBLIC
CLASS
EVALUATE
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
STACK
STRING
OPS
NEW
STACK
STRING
STACK
DOUBLE
VALS
NEW
STACK
DOUBLE
WHILE
STDIN
ISEMPTY
READ
TOKEN
PUSH
IF
OPERATOR
STRING
STDIN
READSTRING
IF
EQUALS
ELSE
IF
EQUALS
OPS
PUSH
ELSE
IF
EQUALS
OPS
PUSH
ELSE
IF
EQUALS
OPS
PUSH
ELSE
IF
EQUALS
OPS
PUSH
ELSE
IF
EQUALS
SQRT
OPS
PUSH
ELSE
IF
EQUALS
POP
EVALUATE
AND
PUSH
RESULT
IF
TOKEN
IS
STRING
OP
OPS
POP
DOUBLE
V
VALS
POP
IF
OP
EQUALS
V
VALS
POP
V
ELSE
IF
OP
EQUALS
V
VALS
POP
V
ELSE
IF
OP
EQUALS
V
VALS
POP
V
ELSE
IF
OP
EQUALS
V
VALS
POP
V
ELSE
IF
OP
EQUALS
SQRT
V
MATH
SQRT
V
VALS
PUSH
V
TOKEN
NOT
OPERATOR
OR
PAREN
PUSH
DOUBLE
VALUE
ELSE
VALS
PUSH
DOUBLE
PARSEDOUBLE
STDOUT
PRINTLN
VALS
POP
THIS
STACK
CLIENT
USES
TWO
STACKS
TO
EVALUATE
ARITHMETIC
EXPRESSIONS
ILLUSTRATING
AN
ESSENTIAL
COMPU
TATIONAL
PROCESS
INTERPRETING
A
STRING
AS
A
PROGRAM
AND
EXECUTING
THAT
PROGRAM
TO
COMPUTE
THE
DE
SIRED
RESULT
WITH
GENERICS
WE
CAN
USE
THE
CODE
IN
A
SINGLE
STACK
IMPLEMENTATION
TO
IMPLEMENT
ONE
STACK
OF
STRING
VALUES
AND
ANOTHER
STACK
OF
DOUBLE
VALUES
FOR
SIMPLICITY
THIS
CODE
ASSUMES
THAT
THE
EXPRES
SION
IS
FULLY
PARENTHESIZED
WITH
NUMBERS
AND
CHARACTERS
SEPARATED
BY
WHITESPACE
JAVA
EVALUATE
JAVA
EVALUATE
SQRT
IS
EASY
TO
CONVINCE
YOURSELF
THAT
IT
COMPUTES
THE
PROPER
VALUE
ANY
TIME
THE
ALGORITHM
ENCOUNTERS
A
SUBEXPRESSION
CONSISTING
OF
TWO
OPERANDS
SEPARATED
BY
AN
OPERATOR
ALL
SURROUNDED
BY
PARENTHESES
IT
LEAVES
THE
RESULT
OF
PERFORMING
THAT
OPERATION
ON
THOSE
OPERANDS
ON
THE
OPERAND
STACK
THE
RESULT
IS
THE
SAME
AS
IF
THAT
VALUE
HAD
APPEARED
IN
THE
INPUT
INSTEAD
OF
THE
SUBEXPRESSION
SO
WE
CAN
THINK
OF
REPLACING
THE
SUBEXPRESSION
BY
THE
VALUE
TO
GET
AN
EXPRESSION
THAT
WOULD
YIELD
THE
SAME
RESULT
WE
CAN
APPLY
THIS
ARGUMENT
AGAIN
AND
AGAIN
UNTIL
WE
GET
A
SINGLE
VALUE
FOR
EXAMPLE
THE
ALGORITHM
COM
PUTES
THE
SAME
VALUE
FOR
ALL
OF
THESE
EXPRESSIONS
EVALUATE
ON
THE
PREVIOUS
PAGE
IS
AN
IMPLEMENTATION
OF
THIS
ALGORITHM
THIS
CODE
IS
A
SIMPLE
EXAMPLE
OF
AN
INTERPRETER
A
PROGRAM
THAT
INTERPRETS
THE
COMPUTATION
SPECIFIED
BY
A
GIVEN
STRING
AND
PERFORMS
THE
COMPUTATION
TO
ARRIVE
AT
THE
RESULT
OPERAND
STACK
OPERATOR
STACK
LEFT
PARENTHESIS
IGNORE
OPERAND
PUSH
ONTO
OPERAND
STACK
OPERATOR
PUSH
ONTO
OPERATOR
STACK
RIGHT
PARENTHESIS
POP
OPERATOR
AND
OPERANDS
AND
PUSH
RESULT
TRACE
OF
DIJKSTRA
TWO
STACK
ARITHMETIC
EXPRESSION
EVALUATION
ALGORITHM
IMPLEMENTING
COLLECTIONS
TO
ADDRESS
THE
ISSUE
OF
IMPLEMENTING
BAG
STACK
AND
QUEUE
WE
BEGIN
WITH
A
SIMPLE
CLASSIC
IMPLEMENTATION
THEN
ADDRESS
IMPROVEMENTS
THAT
LEAD
US
TO
IMPLEMENTATIONS
OF
THE
APIS
ARTICULATED
ON
PAGE
FIXED
CAPACITY
STACK
AS
A
STRAWMAN
WE
CONSIDER
AN
ABSTRACT
DATA
TYPE
FOR
A
FIXED
CAPACITY
STACK
OF
STRINGS
SHOWN
ON
THE
OPPOSITE
PAGE
THE
API
DIFFERS
FROM
OUR
STACK
API
IT
WORKS
ONLY
FOR
STRING
VALUES
IT
REQUIRES
THE
CLIENT
TO
SPECIFY
A
CAPACITY
AND
IT
DOES
NOT
SUPPORT
ITERATION
THE
PRIMARY
CHOICE
IN
DEVELOPING
AN
API
IMPLEMENTATION
IS
TO
CHOOSE
A
REPRESENTATION
FOR
THE
DATA
FOR
FIXEDCAPACITYSTACKOFSTRINGS
AN
OBVIOUS
CHOICE
IS
TO
USE
AN
ARRAY
OF
STRING
VALUES
PURSUING
THIS
CHOICE
LEADS
TO
THE
IMPLEMEN
TATION
SHOWN
AT
THE
BOTTOM
ON
THE
OPPOSITE
PAGE
WHICH
COULD
HARDLY
BE
SIMPLER
EACH
METHOD
IS
A
ONE
LINER
THE
INSTANCE
VARIABLES
ARE
AN
ARRAY
A
THAT
HOLDS
THE
ITEMS
IN
THE
STACK
AND
AN
INTEGER
N
THAT
COUNTS
THE
NUMBER
OF
ITEMS
IN
THE
STACK
TO
REMOVE
AN
ITEM
WE
DECREMENT
N
AND
THEN
RETURN
A
N
TO
INSERT
A
NEW
ITEM
WE
SET
A
N
EQUAL
TO
THE
NEW
ITEM
AND
THEN
INCREMENT
N
THESE
OPERATIONS
PRESERVE
THE
FOLLOWING
PROPERTIES
THE
ITEMS
IN
THE
ARRAY
ARE
IN
THEIR
INSERTION
ORDER
THE
STACK
IS
EMPTY
WHEN
N
IS
THE
TOP
OF
THE
STACK
IF
IT
IS
NONEMPTY
IS
AT
A
N
AS
USUAL
THINKING
IN
TERMS
OF
INVARIANTS
OF
THIS
SORT
IS
THE
EASIEST
WAY
TO
VERIFY
THAT
AN
IMPLEMENTATION
OPERATES
AS
INTENDED
BE
SURE
THAT
YOU
FULLY
UNDERSTAND
THIS
IMPLEMEN
TATION
THE
BEST
WAY
TO
DO
SO
IS
TO
EXAMINE
A
TRACE
OF
THE
STACK
CONTENTS
FOR
A
SEQUENCE
OF
OPERATIONS
AS
ILLUSTRATED
AT
LEFT
FOR
THE
TEST
CLIENT
WHICH
READS
STRINGS
FROM
STANDARD
INPUT
AND
PUSH
ES
EACH
STRING
ONTO
A
STACK
UNLESS
IT
IS
WHEN
IT
POPS
THE
STACK
AND
PRINTS
THE
RESULT
THE
PRIMARY
PERFORMANCE
CHARACTERISTIC
OF
THIS
IMPLEMENTATION
IS
THAT
THE
PUSH
AND
POP
OPERATIONS
TAKE
TIME
INDE
PENDENT
OF
THE
STACK
SIZE
FOR
MANY
APPLICATIONS
IT
IS
THE
METHOD
OF
CHOICE
BECAUSE
OF
ITS
SIMPLICITY
BUT
IT
HAS
SEVERAL
DRAWBACKS
THAT
LIMIT
ITS
POTENTIAL
APPLICABILITY
AS
A
GENERAL
PURPOSE
TOOL
WHICH
WE
NOW
ADDRESS
WITH
A
MODERATE
AMOUNT
OF
EFFORT
AND
SOME
HELP
FROM
JAVA
LANGUAGE
MECHANISMS
WE
CAN
DEVELOP
AN
IMPLEMENTATION
THAT
IS
BROADLY
USEFUL
THIS
EFFORT
IS
WORTHWHILE
BECAUSE
THE
IM
PLEMENTATIONS
THAT
WE
DEVELOP
SERVE
AS
A
MODEL
FOR
IMPLEMENTATIONS
OF
OTHER
MORE
POWERFUL
ABSTRACT
TRACE
OF
FIXEDCAPACITYSTACKOFSTRINGS
TEST
CLIENT
DATA
TYPES
THROUGHOUT
THE
BOOK
API
PUBLIC
CLASS
FIXEDCAPACITYSTACKOFSTRINGS
FIXEDCAPACITYSTACKOFSTRINGS
INT
CAP
CREATE
AN
EMPTY
STACK
OF
CAPACITY
CAP
VOID
PUSH
STRING
ITEM
ADD
A
STRING
STRING
POP
REMOVE
THE
MOST
RECENTLY
ADDED
STRING
BOOLEAN
ISEMPTY
IS
THE
STACK
EMPTY
INT
SIZE
NUMBER
OF
STRINGS
ON
THE
STACK
TEST
CLIENT
APPLICATION
IMPLEMENTATION
AN
ABSTRACT
DATA
TYPE
FOR
A
FIXED
CAPACITY
STACK
OF
STRINGS
GENERICS
THE
FIRST
DRAWBACK
OF
FIXEDCAPACITYSTACKOFSTRINGS
IS
THAT
IT
WORKS
ONLY
FOR
STRING
OBJECTS
IF
WE
WANT
A
STACK
OF
DOUBLE
VALUES
WE
WOULD
NEED
TO
DEVELOP
ANOTHER
CLASS
WITH
SIMILAR
CODE
ESSENTIALLY
REPLACING
STRING
WITH
DOUBLE
EVERYWHERE
THIS
IS
EASY
ENOUGH
BUT
BECOMES
BURDENSOME
WHEN
WE
CONSIDER
BUILDING
A
STACK
OF
TRANSACTION
VALUES
OR
A
QUEUE
OF
DATE
VALUES
AND
SO
FORTH
AS
DISCUSSED
ON
PAGE
JAVA
PARAMETERIZED
TYPES
GENERICS
ARE
SPECIFICALLY
DESIGNED
TO
ADDRESS
THIS
SITUATION
AND
WE
SAW
SEVERAL
EXAMPLES
OF
CLIENT
CODE
ON
PAGES
AND
BUT
HOW
DO
WE
IMPLEMENT
A
GENERIC
STACK
THE
CODE
ON
THE
FACING
PAGE
SHOWS
THE
DETAILS
IT
IMPLE
MENTS
A
CLASS
FIXEDCAPACITYSTACK
THAT
DIFFERS
FROM
FIXEDCAPACITYSTACKOFSTRINGS
ONLY
IN
THE
CODE
HIGHLIGHTED
IN
RED
WE
REPLACE
EVERY
OCCURRENCE
OF
STRING
WITH
ITEM
WITH
ONE
EXCEPTION
DISCUSSED
BELOW
AND
DECLARE
THE
CLASS
WITH
THE
FOLLOWING
FIRST
LINE
OF
CODE
PUBLIC
CLASS
FIXEDCAPACITYSTACK
ITEM
THE
NAME
ITEM
IS
A
TYPE
PARAMETER
A
SYMBOLIC
PLACEHOLDER
FOR
SOME
CONCRETE
TYPE
TO
BE
USED
BY
THE
CLIENT
YOU
CAN
READ
FIXEDCAPACITYSTACK
ITEM
AS
STACK
OF
ITEMS
WHICH
IS
PRECISELY
WHAT
WE
WANT
WHEN
IMPLEMENTING
FIXEDCAPACITYSTACK
WE
DO
NOT
KNOW
THE
ACTUAL
TYPE
OF
ITEM
BUT
A
CLIENT
CAN
USE
OUR
STACK
FOR
ANY
TYPE
OF
DATA
BY
PROVIDING
A
CONCRETE
TYPE
WHEN
THE
STACK
IS
CREATED
CONCRETE
TYPES
MUST
BE
REFERENCE
TYPES
BUT
CLI
ENTS
CAN
DEPEND
ON
AUTOBOXING
TO
CONVERT
PRIMITIVE
TYPES
TO
THEIR
CORRESPONDING
WRAP
PER
TYPES
JAVA
USES
THE
TYPE
PARAMETER
ITEM
TO
CHECK
FOR
TYPE
MISMATCH
ERRORS
EVEN
THOUGH
NO
CONCRETE
TYPE
IS
YET
KNOWN
VARIABLES
OF
TYPE
ITEM
MUST
BE
ASSIGNED
VALUES
OF
TYPE
ITEM
AND
SO
FORTH
BUT
THERE
IS
ONE
SIGNIFICANT
HITCH
IN
THIS
STORY
WE
WOULD
LIKE
TO
IMPLEMENT
THE
CONSTRUCTOR
IN
FIXEDCAPACITYSTACK
WITH
THE
CODE
A
NEW
ITEM
CAP
WHICH
CALLS
FOR
CREATION
OF
A
GENERIC
ARRAY
FOR
HISTORICAL
AND
TECHNICAL
REASONS
BEYOND
OUR
SCOPE
GENERIC
ARRAY
CREATION
IS
DISALLOWED
IN
JAVA
INSTEAD
WE
NEED
TO
USE
A
CAST
A
ITEM
NEW
OBJECT
CAP
THIS
CODE
PRODUCES
THE
DESIRED
EFFECT
THOUGH
THE
JAVA
COMPILER
GIVES
A
WARNING
WHICH
WE
CAN
SAFELY
IGNORE
AND
WE
USE
THIS
IDIOM
THROUGHOUT
THE
BOOK
THE
JAVA
SYSTEM
LI
BRARY
IMPLEMENTATIONS
OF
SIMILAR
ABSTRACT
DATA
TYPES
USE
THE
SAME
IDIOM
API
PUBLIC
CLASS
FIXEDCAPACITYSTACK
ITEM
FIXEDCAPACITYSTACK
INT
CAP
CREATE
AN
EMPTY
STACK
OF
CAPACITY
CAP
VOID
PUSH
ITEM
ITEM
ADD
AN
ITEM
ITEM
POP
REMOVE
THE
MOST
RECENTLY
ADDED
ITEM
BOOLEAN
ISEMPTY
IS
THE
STACK
EMPTY
INT
SIZE
NUMBER
OF
ITEMS
ON
THE
STACK
TEST
CLIENT
APPLICATION
IMPLEMENTATION
AN
ABSTRACT
DATA
TYPE
FOR
A
FIXED
CAPACITY
GENERIC
STACK
ARRAY
RESIZING
CHOOSING
AN
ARRAY
TO
REPRESENT
THE
STACK
CONTENTS
IMPLIES
THAT
CLIENTS
MUST
ESTIMATE
THE
MAXIMUM
SIZE
OF
THE
STACK
AHEAD
OF
TIME
IN
JAVA
WE
CANNOT
CHANGE
THE
SIZE
OF
AN
ARRAY
ONCE
CREATED
SO
THE
STACK
ALWAYS
USES
SPACE
PROPORTIONAL
TO
THAT
MAXIMUM
A
CLIENT
THAT
CHOOSES
A
LARGE
CAPACITY
RISKS
WASTING
A
LARGE
AMOUNT
OF
MEM
ORY
AT
TIMES
WHEN
THE
COLLECTION
IS
EMPTY
OR
NEARLY
EMPTY
FOR
EXAMPLE
A
TRANSACTION
SYSTEM
MIGHT
INVOLVE
BILLIONS
OF
ITEMS
AND
THOUSANDS
OF
COLLECTIONS
OF
THEM
SUCH
A
CLIENT
WOULD
HAVE
TO
ALLOW
FOR
THE
POSSIBILITY
THAT
EACH
OF
THOSE
COLLECTIONS
COULD
HOLD
ALL
OF
THOSE
ITEMS
EVEN
THOUGH
A
TYPICAL
CONSTRAINT
IN
SUCH
SYSTEMS
IS
THAT
EACH
ITEM
CAN
APPEAR
IN
ONLY
ONE
COLLECTION
MOREOVER
EVERY
CLIENT
RISKS
OVERFLOW
IF
THE
COLLECTION
GROWS
LARGER
THAN
THE
ARRAY
FOR
THIS
REASON
PUSH
NEEDS
CODE
TO
TEST
FOR
A
FULL
STACK
AND
WE
SHOULD
HAVE
AN
ISFULL
METHOD
IN
THE
API
TO
ALLOW
CLIENTS
TO
TEST
FOR
THAT
CONDITION
WE
OMIT
THAT
CODE
BECAUSE
OUR
DESIRE
IS
TO
RELIEVE
THE
CLIENT
FROM
HAVING
TO
DEAL
WITH
THE
CONCEPT
OF
A
FULL
STACK
AS
ARTICULATED
IN
OUR
ORIGINAL
STACK
API
INSTEAD
WE
MODIFY
THE
ARRAY
IMPLEMENTATION
TO
DYNAMICALLY
ADJUST
THE
SIZE
OF
THE
ARRAY
A
SO
THAT
IT
IS
BOTH
SUFFICIENTLY
LARGE
TO
HOLD
ALL
OF
THE
ITEMS
AND
NOT
SO
LARGE
AS
TO
WASTE
AN
EXCESSIVE
AMOUNT
OF
SPACE
ACHIEVING
THESE
GOALS
TURNS
OUT
TO
BE
REMARKABLY
EASY
FIRST
WE
IMPLEMENT
A
METHOD
THAT
MOVES
A
STACK
INTO
AN
ARRAY
OF
A
DIFFERENT
SIZE
PRIVATE
VOID
RESIZE
INT
MAX
MOVE
STACK
OF
SIZE
N
MAX
TO
A
NEW
ARRAY
OF
SIZE
MAX
ITEM
TEMP
ITEM
NEW
OBJECT
MAX
FOR
INT
I
I
N
I
TEMP
I
A
I
A
TEMP
NOW
IN
PUSH
WE
CHECK
WHETHER
THE
ARRAY
IS
TOO
SMALL
IN
PARTICULAR
WE
CHECK
WHETH
ER
THERE
IS
ROOM
FOR
THE
NEW
ITEM
IN
THE
ARRAY
BY
CHECKING
WHETHER
THE
STACK
SIZE
N
IS
EQUAL
TO
THE
ARRAY
SIZE
A
LENGTH
IF
THERE
IS
NO
ROOM
WE
DOUBLE
THE
SIZE
OF
THE
ARRAY
THEN
WE
SIMPLY
INSERT
THE
NEW
ITEM
WITH
THE
CODE
A
N
ITEM
AS
BEFORE
PUBLIC
VOID
PUSH
STRING
ITEM
ADD
ITEM
TO
TOP
OF
STACK
IF
N
A
LENGTH
RESIZE
A
LENGTH
A
N
ITEM
SIMILARLY
IN
POP
WE
BEGIN
BY
DELETING
THE
ITEM
THEN
WE
HALVE
THE
ARRAY
SIZE
IF
IT
IS
TOO
LARGE
IF
YOU
THINK
A
BIT
ABOUT
THE
SITUATION
YOU
WILL
SEE
THAT
THE
APPROPRIATE
TEST
IS
WHETHER
THE
STACK
SIZE
IS
LESS
THAN
ONE
FOURTH
THE
ARRAY
SIZE
AFTER
THE
ARRAY
IS
HALVED
IT
WILL
BE
ABOUT
HALF
FULL
AND
CAN
ACCOMMODATE
A
SUBSTANTIAL
NUMBER
OF
PUSH
AND
POP
OPERATIONS
BEFORE
HAVING
TO
CHANGE
THE
SIZE
OF
THE
ARRAY
AGAIN
PUBLIC
STRING
POP
REMOVE
ITEM
FROM
TOP
OF
STACK
STRING
ITEM
A
N
A
N
NULL
AVOID
LOITERING
SEE
TEXT
IF
N
N
A
LENGTH
RESIZE
A
LENGTH
RETURN
ITEM
WITH
THIS
IMPLEMENTATION
THE
STACK
NEVER
OVERFLOWS
AND
NEVER
BECOMES
LESS
THAN
ONE
QUARTER
FULL
UNLESS
THE
STACK
IS
EMPTY
WHEN
THE
ARRAY
SIZE
IS
WE
WILL
ADDRESS
THE
PERFORMANCE
ANALYSIS
OF
THIS
APPROACH
IN
MORE
DETAIL
IN
SECTION
LOITERING
JAVA
GARBAGE
COLLECTION
POLICY
IS
TO
RECLAIM
THE
MEMORY
ASSOCIATED
WITH
ANY
OBJECTS
THAT
CAN
NO
LONGER
BE
ACCESSED
IN
OUR
POP
IMPLEMENTATIONS
THE
REFER
ENCE
TO
THE
POPPED
ITEM
REMAINS
IN
THE
ARRAY
THE
ITEM
IS
EFFECTIVELY
AN
ORPHAN
IT
WILL
BE
NEVER
BE
ACCESSED
AGAIN
BUT
THE
JAVA
GARBAGE
COLLECTOR
HAS
NO
WAY
TO
KNOW
THIS
UNTIL
IT
IS
OVERWRITTEN
EVEN
WHEN
THE
CLIENT
IS
DONE
WITH
THE
ITEM
THE
REFERENCE
IN
THE
ARRAY
MAY
KEEP
IT
ALIVE
THIS
CONDITION
HOLDING
A
REFERENCE
TO
AN
ITEM
THAT
IS
NO
LONGER
NEEDED
IS
KNOWN
AS
LOITERING
IN
THIS
CASE
LOITERING
IS
EASY
TO
AVOID
BY
SETTING
THE
ARRAY
ENTRY
CORRESPONDING
TO
THE
POPPED
ITEM
TO
NULL
THUS
OVERWRITING
THE
UNUSED
REFER
ENCE
AND
MAKING
IT
POSSIBLE
FOR
THE
SYSTEM
TO
RECLAIM
THE
MEMORY
ASSOCIATED
WITH
THE
POPPED
ITEM
WHEN
THE
CLIENT
IS
FINISHED
WITH
IT
A
PUSH
POP
N
A
LENGTH
NULL
TO
BE
OR
NOT
TO
TO
TO
TO
BE
BE
BE
OR
OR
NULL
NOT
TO
TO
BE
OR
NOT
TO
NULL
NULL
NULL
TO
TO
BE
OR
NOT
NULL
NULL
NULL
NULL
BE
TO
BE
OR
NOT
BE
NULL
NULL
NULL
BE
TO
BE
OR
NOT
NULL
NULL
NULL
NULL
NOT
TO
BE
OR
NULL
NULL
NULL
NULL
NULL
THAT
TO
BE
OR
THAT
NULL
NULL
NULL
NULL
THAT
TO
BE
OR
NULL
NULL
NULL
NULL
NULL
OR
TO
BE
NULL
NULL
BE
TO
NULL
IS
TO
IS
TRACE
OF
ARRAY
RESIZING
DURING
A
SEQUENCE
OF
PUSH
AND
POP
OPERATIONS
ITERATION
AS
MENTIONED
EARLIER
IN
THIS
SECTION
ONE
OF
THE
FUNDAMENTAL
OPERATIONS
ON
COLLECTIONS
IS
TO
PROCESS
EACH
ITEM
BY
ITERATING
THROUGH
THE
COLLECTION
USING
JAVA
FOREACH
STATEMENT
THIS
PARADIGM
LEADS
TO
CLEAR
AND
COMPACT
CODE
THAT
IS
FREE
FROM
DEPENDENCE
ON
THE
DETAILS
OF
A
COLLECTION
IMPLEMENTATION
TO
CONSIDER
THE
TASK
OF
IMPLEMENTING
ITERATION
WE
START
WITH
A
SNIPPET
OF
CLIENT
CODE
THAT
PRINTS
ALL
OF
THE
ITEMS
IN
A
COLLECTION
OF
STRINGS
ONE
PER
LINE
STACK
STRING
COLLECTION
NEW
STACK
STRING
FOR
STRING
COLLECTION
STDOUT
PRINTLN
NOW
THIS
FOREACH
STATEMENT
IS
SHORTHAND
FOR
A
WHILE
CONSTRUCT
JUST
LIKE
THE
FOR
STATE
MENT
ITSELF
IT
IS
ESSENTIALLY
EQUIVALENT
TO
THE
FOLLOWING
WHILE
STATEMENT
ITERATOR
STRING
I
COLLECTION
ITERATOR
WHILE
I
HASNEXT
STRING
I
NEXT
STDOUT
PRINTLN
THIS
CODE
EXPOSES
THE
INGREDIENTS
THAT
WE
NEED
TO
IMPLEMENT
IN
ANY
ITERABLE
COLLECTION
THE
COLLECTION
MUST
IMPLEMENT
AN
ITERATOR
METHOD
THAT
RETURNS
AN
ITERATOR
OBJECT
THE
ITERATOR
CLASS
MUST
INCLUDE
TWO
METHODS
HASNEXT
WHICH
RETURNS
A
BOOLEAN
VALUE
AND
NEXT
WHICH
RETURNS
A
GENERIC
ITEM
FROM
THE
COLLECTION
IN
JAVA
WE
USE
THE
INTERFACE
MECHANISM
TO
EXPRESS
THE
IDEA
THAT
A
CLASS
IMPLEMENTS
A
SPECIFIC
METHOD
SEE
PAGE
FOR
ITERABLE
COLLECTIONS
THE
NECESSARY
INTERFACES
ARE
AL
READY
DEFINED
FOR
US
IN
JAVA
TO
MAKE
A
CLASS
ITERABLE
THE
FIRST
STEP
IS
TO
ADD
THE
PHRASE
IMPLEMENTS
ITERABLE
ITEM
TO
ITS
DECLARATION
MATCHING
THE
INTERFACE
PUBLIC
INTERFACE
ITERABLE
ITEM
ITERATOR
ITEM
ITERATOR
WHICH
IS
IN
JAVA
LANG
ITERABLE
AND
TO
ADD
A
METHOD
ITERATOR
TO
THE
CLASS
THAT
RETURNS
AN
ITERATOR
ITEM
ITERATORS
ARE
GENERIC
SO
WE
CAN
USE
OUR
PARAMETERIZED
TYPE
ITEM
TO
ALLOW
CLIENTS
TO
ITERATE
THROUGH
OBJECTS
OF
WHATEVER
TYPE
IS
PROVIDED
BY
OUR
CLIENT
FOR
THE
ARRAY
REPRESENTATION
THAT
WE
HAVE
BEEN
USING
WE
NEED
TO
ITERATE
THROUGH
AN
ARRAY
IN
REVERSE
ORDER
SO
WE
NAME
THE
ITERATOR
REVERSEARRAYITERATOR
AND
ADD
THIS
METHOD
PUBLIC
ITERATOR
ITEM
ITERATOR
RETURN
NEW
REVERSEARRAYITERATOR
WHAT
IS
AN
ITERATOR
AN
OBJECT
FROM
A
CLASS
THAT
IMPLEMENTS
THE
METHODS
HASNEXT
AND
NEXT
AS
DEFINED
IN
THE
FOLLOWING
INTERFACE
WHICH
IS
IN
JAVA
UTIL
ITERATOR
PUBLIC
INTERFACE
ITERATOR
ITEM
BOOLEAN
HASNEXT
ITEM
NEXT
VOID
REMOVE
ALTHOUGH
THE
INTERFACE
SPECIFIES
A
REMOVE
METHOD
WE
ALWAYS
USE
AN
EMPTY
METHOD
FOR
REMOVE
IN
THIS
BOOK
BECAUSE
INTERLEAVING
ITERATION
WITH
OPERATIONS
THAT
MODIFY
THE
DATA
STRUCTURE
IS
BEST
AVOIDED
FOR
REVERSEARRAYITERATOR
THESE
METHODS
ARE
ALL
ONE
LINERS
IMPLEMENTED
IN
A
NESTED
CLASS
WITHIN
OUR
STACK
CLASS
PRIVATE
CLASS
REVERSEARRAYITERATOR
IMPLEMENTS
ITERATOR
ITEM
PRIVATE
INT
I
N
PUBLIC
BOOLEAN
HASNEXT
RETURN
I
PUBLIC
ITEM
NEXT
RETURN
A
I
PUBLIC
VOID
REMOVE
NOTE
THAT
THIS
NESTED
CLASS
CAN
ACCESS
THE
INSTANCE
VARIABLES
OF
THE
ENCLOSING
CLASS
IN
THIS
CASE
A
AND
N
THIS
ABILITY
IS
THE
MAIN
REASON
WE
USE
NESTED
CLASSES
FOR
ITERATORS
TECHNICALLY
TO
CONFORM
TO
THE
ITERATOR
SPECIFICATION
WE
SHOULD
THROW
EXCEPTIONS
IN
TWO
CASES
AN
UNSUPPORTEDOPERATIONEXCEPTION
IF
A
CLIENT
CALLS
REMOVE
AND
A
NOSUCHELEMENTEXCEPTION
IF
A
CLIENT
CALLS
NEXT
WHEN
I
IS
SINCE
WE
ONLY
USE
ITERA
TORS
IN
THE
FOREACH
CONSTRUCTION
WHERE
THESE
CONDITIONS
DO
NOT
ARISE
WE
OMIT
THIS
CODE
ONE
CRUCIAL
DETAIL
REMAINS
WE
HAVE
TO
INCLUDE
IMPORT
JAVA
UTIL
ITERATOR
AT
THE
BEGINNING
OF
THE
PROGRAM
BECAUSE
FOR
HISTORICAL
REASONS
ITERATOR
IS
NOT
PART
OF
JAVA
LANG
EVEN
THOUGH
ITERABLE
IS
PART
OF
JAVA
LANG
NOW
A
CLIENT
USING
THE
FOREACH
STATEMENT
FOR
THIS
CLASS
WILL
GET
BEHAVIOR
EQUIVALENT
TO
THE
COMMON
FOR
LOOP
FOR
ARRAYS
BUT
DOES
NOT
NEED
TO
BE
AWARE
OF
THE
ARRAY
REPRESENTATION
AN
IMPLEMENTATION
DETAIL
THIS
ARRANGEMENT
IS
OF
CRITICAL
IMPORTANCE
FOR
IMPLEMENTATIONS
OF
FUNDAMEN
TAL
DATA
TYPES
LIKE
THE
COLLECTIONS
THAT
WE
CONSIDER
IN
THIS
BOOK
AND
THOSE
INCLUDED
IN
JAVA
LIBRARIES
FOR
EXAMPLE
IT
FREES
US
TO
SWITCH
TO
A
TOTALLY
DIFFERENT
REPRESENTATION
WITHOUT
HAVING
TO
CHANGE
ANY
CLIENT
CODE
MORE
IMPORTANT
TAKING
THE
CLIENT
POINT
OF
VIEW
IT
ALLOWS
CLIENTS
TO
USE
ITERATION
WITHOUT
HAVING
TO
KNOW
ANY
DETAILS
OF
THE
CLASS
IMPLEMENTATION
ALGORITHM
IS
AN
IMPLEMENTATION
OF
OUR
STACK
API
THAT
RESIZES
THE
ARRAY
ALLOWS
CLIENTS
TO
MAKE
STACKS
FOR
ANY
TYPE
OF
DATA
AND
SUPPORTS
CLIENT
USE
OF
FOREACH
TO
ITERATE
THROUGH
THE
STACK
ITEMS
IN
LIFO
ORDER
THIS
IMPLEMENTATION
IS
BASED
ON
JAVA
LANGUAGE
NUANCES
INVOLVING
ITERATOR
AND
ITERABLE
BUT
THERE
IS
NO
NEED
TO
STUDY
THOSE
NUANCES
IN
DETAIL
AS
THE
CODE
ITSELF
IS
NOT
COMPLICATED
AND
CAN
BE
USED
AS
A
TEMPLATE
FOR
OTHER
COLLECTION
IMPLEMENTATIONS
FOR
EXAMPLE
WE
CAN
IMPLEMENT
THE
QUEUE
API
BY
MAINTAINING
TWO
INDICES
AS
IN
STANCE
VARIABLES
A
VARIABLE
HEAD
FOR
THE
BEGINNING
OF
THE
QUEUE
AND
A
VARIABLE
TAIL
FOR
THE
END
OF
THE
QUEUE
TO
REMOVE
AN
ITEM
USE
HEAD
TO
ACCESS
IT
AND
THEN
INCREMENT
HEAD
TO
INSERT
AN
ITEM
USE
TAIL
TO
STORE
IT
AND
THEN
INCREMENT
TAIL
IF
INCREMENTING
AN
INDEX
BRINGS
IT
PAST
THE
END
OF
THE
ARRAY
RESET
IT
TO
DEVELOPING
THE
DETAILS
OF
CHECKING
WHEN
THE
QUEUE
IS
EMPTY
AND
WHEN
THE
ARRAY
IS
FULL
AND
NEEDS
RESIZING
IS
AN
INTERESTING
AND
WORTHWHILE
PROGRAMMING
EXERCISE
SEE
EXERCISE
STDIN
STDOUT
A
ENQUEUE
DEQUEUE
N
HEAD
TAIL
TO
BE
OR
NOT
TO
TO
TO
BE
OR
NOT
TO
BE
TO
BE
OR
NOT
TO
BE
BE
TO
BE
OR
NOT
TO
BE
OR
TO
BE
OR
THAT
TO
BE
TRACE
OF
RESIZINGARRAYQUEUE
TEST
CLIENT
IN
THE
CONTEXT
OF
THE
STUDY
OF
ALGORITHMS
ALGORITHM
IS
SIGNIFICANT
BECAUSE
IT
ALMOST
BUT
NOT
QUITE
ACHIEVES
OPTIMUM
PERFORMANCE
GOALS
FOR
ANY
COLLECTION
IMPLEMENTATION
EACH
OPERATION
SHOULD
REQUIRE
TIME
INDEPENDENT
OF
THE
COLLECTION
SIZE
THE
SPACE
USED
SHOULD
ALWAYS
BE
WITHIN
A
CONSTANT
FACTOR
OF
THE
COLLECTION
SIZE
THE
FLAW
IN
RESIZINGARRAYSTACK
IS
THAT
SOME
PUSH
AND
POP
OPERATIONS
REQUIRE
RESIZ
ING
THIS
TAKES
TIME
PROPORTIONAL
TO
THE
SIZE
OF
THE
STACK
NEXT
WE
CONSIDER
A
WAY
TO
COR
RECT
THIS
FLAW
USING
A
FUNDAMENTALLY
DIFFERENT
WAY
TO
STRUCTURE
DATA
ALGORITHM
PUSHDOWN
LIFO
STACK
RESIZING
ARRAY
IMPLEMENTATION
IMPORT
JAVA
UTIL
ITERATOR
PUBLIC
CLASS
RESIZINGARRAYSTACK
ITEM
IMPLEMENTS
ITERABLE
ITEM
PRIVATE
ITEM
A
ITEM
NEW
OBJECT
STACK
ITEMS
PRIVATE
INT
N
NUMBER
OF
ITEMS
PUBLIC
BOOLEAN
ISEMPTY
RETURN
N
PUBLIC
INT
SIZE
RETURN
N
PRIVATE
VOID
RESIZE
INT
MAX
MOVE
STACK
TO
A
NEW
ARRAY
OF
SIZE
MAX
ITEM
TEMP
ITEM
NEW
OBJECT
MAX
FOR
INT
I
I
N
I
TEMP
I
A
I
A
TEMP
PUBLIC
VOID
PUSH
ITEM
ITEM
ADD
ITEM
TO
TOP
OF
STACK
IF
N
A
LENGTH
RESIZE
A
LENGTH
A
N
ITEM
PUBLIC
ITEM
POP
REMOVE
ITEM
FROM
TOP
OF
STACK
ITEM
ITEM
A
N
A
N
NULL
AVOID
LOITERING
SEE
TEXT
IF
N
N
A
LENGTH
RESIZE
A
LENGTH
RETURN
ITEM
PUBLIC
ITERATOR
ITEM
ITERATOR
RETURN
NEW
REVERSEARRAYITERATOR
PRIVATE
CLASS
REVERSEARRAYITERATOR
IMPLEMENTS
ITERATOR
ITEM
SUPPORT
LIFO
ITERATION
PRIVATE
INT
I
N
PUBLIC
BOOLEAN
HASNEXT
RETURN
I
PUBLIC
ITEM
NEXT
RETURN
A
I
PUBLIC
VOID
REMOVE
THIS
GENERIC
ITERABLE
IMPLEMENTATION
OF
OUR
STACK
API
IS
A
MODEL
FOR
COLLECTION
ADTS
THAT
KEEP
ITEMS
IN
AN
ARRAY
IT
RESIZES
THE
ARRAY
TO
KEEP
THE
ARRAY
SIZE
WITHIN
A
CONSTANT
FACTOR
OF
THE
STACK
SIZE
LINKED
LISTS
NOW
WE
CONSIDER
THE
USE
OF
A
FUNDAMENTAL
DATA
STRUCTURE
THAT
IS
AN
AP
PROPRIATE
CHOICE
FOR
REPRESENTING
THE
DATA
IN
A
COLLECTION
ADT
IMPLEMENTATION
THIS
IS
OUR
FIRST
EXAMPLE
OF
BUILDING
A
DATA
STRUCTURE
THAT
IS
NOT
DIRECTLY
SUPPORTED
BY
THE
JAVA
LANGUAGE
OUR
IMPLEMENTATION
SERVES
AS
A
MODEL
FOR
THE
CODE
THAT
WE
USE
FOR
BUILDING
MORE
COMPLEX
DATA
STRUCTURES
THROUGHOUT
THE
BOOK
SO
YOU
SHOULD
READ
THIS
SECTION
CAREFULLY
EVEN
IF
YOU
HAVE
EXPERIENCE
WORKING
WITH
LINKED
LISTS
THE
NODE
IN
THIS
DEFINITION
IS
AN
ABSTRACT
ENTITY
THAT
MIGHT
HOLD
ANY
KIND
OF
DATA
IN
AD
DITION
TO
THE
NODE
REFERENCE
THAT
CHARACTERIZES
ITS
ROLE
IN
BUILDING
LINKED
LISTS
AS
WITH
A
RECURSIVE
PROGRAM
THE
CONCEPT
OF
A
RECURSIVE
DATA
STRUCTURE
CAN
BE
A
BIT
MINDBENDING
AT
FIRST
BUT
IS
OF
GREAT
VALUE
BECAUSE
OF
ITS
SIMPLICITY
NODE
RECORD
WITH
OBJECT
ORIENTED
PROGRAMMING
IMPLEMENTING
LINKED
LISTS
IS
NOT
DIF
FICULT
WE
START
WITH
A
NESTED
CLASS
THAT
DEFINES
THE
NODE
ABSTRACTION
PRIVATE
CLASS
NODE
ITEM
ITEM
NODE
NEXT
A
NODE
HAS
TWO
INSTANCE
VARIABLES
AN
ITEM
A
PARAMETERIZED
TYPE
AND
A
NODE
WE
DEFINE
NODE
WITHIN
THE
CLASS
WHERE
WE
WANT
TO
USE
IT
AND
MAKE
IT
PRIVATE
BECAUSE
IT
IS
NOT
FOR
USE
BY
CLIENTS
AS
WITH
ANY
DATA
TYPE
WE
CREATE
AN
OBJECT
OF
TYPE
NODE
BY
IN
VOKING
THE
NO
ARGUMENT
CONSTRUCTOR
WITH
NEW
NODE
THE
RESULT
IS
A
REFERENCE
TO
A
NODE
OBJECT
WHOSE
INSTANCE
VARIABLES
ARE
BOTH
INITIALIZED
TO
THE
VALUE
NULL
THE
ITEM
IS
A
PLACEHOLDER
FOR
ANY
DATA
THAT
WE
MIGHT
WANT
TO
STRUCTURE
WITH
A
LINKED
LIST
WE
WILL
USE
JAVA
GENERIC
MECHANISM
SO
THAT
IT
CAN
REPRESENT
ANY
REFERENCE
TYPE
THE
INSTANCE
VARI
ABLE
OF
TYPE
NODE
CHARACTERIZES
THE
LINKED
NATURE
OF
THE
DATA
STRUCTURE
TO
EMPHASIZE
THAT
WE
ARE
JUST
USING
THE
NODE
CLASS
TO
STRUCTURE
THE
DATA
WE
DEFINE
NO
METHODS
AND
WE
REFER
DIRECTLY
TO
THE
INSTANCE
VARIABLES
IN
CODE
IF
FIRST
IS
A
VARIABLE
ASSOCIATED
WITH
AN
OBJECT
OF
TYPE
NODE
WE
CAN
REFER
TO
THE
INSTANCE
VARIABLES
WITH
THE
CODE
FIRST
ITEM
AND
FIRST
NEXT
CLASSES
OF
THIS
KIND
ARE
SOMETIMES
CALLED
RECORDS
THEY
DO
NOT
IMPLE
MENT
ABSTRACT
DATA
TYPES
BECAUSE
WE
REFER
DIRECTLY
TO
INSTANCE
VARIABLES
HOWEVER
NODE
AND
ITS
CLIENT
CODE
ARE
IN
THE
SAME
CLASS
IN
ALL
OF
OUR
IMPLEMENTATIONS
AND
NOT
ACCESSIBLE
BY
CLIENTS
OF
THAT
CLASS
SO
WE
STILL
ENJOY
THE
BENEFITS
OF
DATA
ABSTRACTION
BUILDING
A
LINKED
LIST
NOW
FROM
THE
RECURSIVE
DEFINITION
WE
CAN
REPRESENT
A
LINKED
LIST
WITH
A
VARIABLE
OF
TYPE
NODE
SIMPLY
BY
ENSURING
THAT
ITS
VALUE
IS
EITHER
NULL
OR
A
REF
ERENCE
TO
A
NODE
WHOSE
NEXT
FIELD
IS
A
REFERENCE
TO
A
LINKED
LIST
FOR
EXAMPLE
TO
BUILD
A
LINKED
LIST
THAT
CONTAINS
THE
ITEMS
TO
BE
AND
OR
WE
CREATE
A
NODE
FOR
EACH
ITEM
NODE
FIRST
NEW
NODE
NODE
SECOND
NEW
NODE
NODE
THIRD
NEW
NODE
AND
SET
THE
ITEM
FIELD
IN
EACH
OF
THE
NODES
TO
THE
DESIRED
VALUE
FOR
SIMPLICITY
THESE
EXAMPLES
ASSUME
THAT
ITEM
IS
STRING
FIRST
ITEM
TO
SECOND
ITEM
BE
THIRD
ITEM
OR
AND
SET
THE
NEXT
FIELDS
TO
BUILD
THE
LINKED
LIST
NODE
FIRST
NEW
NODE
FIRST
ITEM
TO
FIRST
NODE
SECOND
NEW
NODE
SECOND
ITEM
BE
FIRST
NEXT
SECOND
FIRST
NEXT
SECOND
SECOND
NEXT
THIRD
NOTE
THAT
THIRD
NEXT
REMAINS
NULL
THE
VALUE
IT
WAS
INITIALIZED
TO
AT
THE
TIME
OF
CREATION
AS
A
RESULT
FIRST
SECOND
THIRD
IS
A
LINKED
LIST
IT
IS
A
REFERENCE
TO
A
NODE
THAT
HAS
A
REFERENCE
TO
NULL
WHICH
IS
THE
NULL
REFERENCE
TO
AN
EMPTY
LINKED
LIST
AND
SECOND
IS
A
LINKED
LIST
NODE
THIRD
NEW
NODE
THIRD
ITEM
OR
SECOND
NEXT
THIRD
IT
IS
A
REFERENCE
TO
A
NODE
THAT
HAS
A
REFERENCE
TO
THIRD
WHICH
IS
A
LINKED
LIST
AND
FIRST
IS
A
LINKED
LIST
IT
IS
A
REFERENCE
TO
A
NODE
THAT
HAS
A
REFERENCE
TO
SECOND
WHICH
IS
A
LINKED
LIST
THE
CODE
THAT
WE
WILL
EXAMINE
DOES
THESE
ASSIGNMENT
STATEMENTS
IN
A
DIF
FIRST
SECOND
THIRD
FERENT
ORDER
DEPICTED
IN
THE
DIAGRAM
ON
THIS
PAGE
LINKING
TOGETHER
A
LIST
A
LINKED
LIST
REPRESENTS
A
SEQUENCE
OF
ITEMS
IN
THE
EXAMPLE
JUST
CONSIDERED
FIRST
REPRESENTS
THE
SEQUENCE
TO
BE
OR
WE
CAN
ALSO
USE
AN
ARRAY
TO
REPRESENT
A
SEQUENCE
OF
ITEMS
FOR
EXAMPLE
WE
COULD
USE
STRING
TO
BE
OR
TO
REPRESENT
THE
SAME
SEQUENCE
OF
STRINGS
THE
DIFFERENCE
IS
THAT
IT
IS
EASIER
TO
INSERT
ITEMS
INTO
THE
SEQUENCE
AND
TO
REMOVE
ITEMS
FROM
THE
SEQUENCE
WITH
LINKED
LISTS
NEXT
WE
CONSIDER
CODE
TO
ACCOMPLISH
THESE
TASKS
WHEN
TRACING
CODE
THAT
USES
LINKED
LISTS
AND
OTHER
LINKED
STRUCTURES
WE
USE
A
VISUAL
REPRESENTATION
WHERE
WE
DRAW
A
RECTANGLE
TO
REPRESENT
EACH
OBJECT
WE
PUT
THE
VALUES
OF
INSTANCE
VARIABLES
WITHIN
THE
RECTANGLE
WE
USE
ARROWS
THAT
POINT
TO
THE
REFERENCED
OBJECTS
TO
DEPICT
REFERENCES
THIS
VISUAL
REPRESENTATION
CAPTURES
THE
ESSENTIAL
CHARACTERISTIC
OF
LINKED
LISTS
FOR
ECON
OMY
WE
USE
THE
TERM
LINKS
TO
REFER
TO
NODE
REFERENCES
FOR
SIMPLICITY
WHEN
ITEM
VALUES
ARE
STRINGS
AS
IN
OUR
EXAMPLES
WE
PUT
THE
STRING
WITHIN
THE
OBJECT
RECTANGLE
RATHER
THAN
THE
MORE
ACCURATE
RENDITION
DEPICTING
THE
STRING
OBJECT
AND
THE
CHARACTER
ARRAY
THAT
WE
DISCUSSED
IN
SECTION
THIS
VISUAL
REPRESENTATION
ALLOWS
US
TO
FOCUS
ON
THE
LINKS
INSERT
AT
THE
BEGINNING
FIRST
SUPPOSE
THAT
YOU
WANT
TO
INSERT
A
NEW
NODE
INTO
A
LINKED
LIST
THE
EASIEST
PLACE
TO
DO
SO
IS
AT
THE
BEGINNING
OF
THE
LIST
FOR
EXAMPLE
TO
INSERT
THE
STRING
NOT
AT
THE
BEGINNING
OF
A
GIVEN
LINKED
LIST
WHOSE
FIRST
NODE
IS
FIRST
WE
SAVE
FIRST
IN
OLDFIRST
ASSIGN
TO
FIRST
A
NEW
NODE
AND
ASSIGN
ITS
ITEM
FIELD
TO
NOT
AND
ITS
NEXT
FIELD
TO
OLDFIRST
THIS
CODE
FOR
INSERTING
A
NODE
AT
THE
BEGINNING
OF
A
LINKED
LIST
INVOLVES
JUST
A
FEW
ASSIGNMENT
STATEMENTS
SO
THE
AMOUNT
OF
TIME
THAT
IT
TAKES
IS
INDE
PENDENT
OF
THE
LENGTH
OF
THE
LIST
SAVE
A
LINK
TO
THE
LIST
NODE
OLDFIRST
FIRST
OLDFIRST
FIRST
CREATE
A
NEW
NODE
FOR
THE
BEGINNING
FIRST
NEW
NODE
OLDFIRST
FIRST
SET
THE
INSTANCE
VARIABLES
IN
THE
NEW
NODE
FIRST
ITEM
NOT
FIRST
NEXT
OLDFIRST
FIRST
INSERTING
A
NEW
NODE
AT
THE
BEGINNING
OF
A
LINKED
LIST
REMOVE
FROM
THE
BEGINNING
NEXT
SUPPOSE
THAT
YOU
WANT
TO
REMOVE
THE
FIRST
NODE
FROM
A
LIST
THIS
OP
ERATION
IS
EVEN
EASIER
SIMPLY
ASSIGN
TO
FIRST
THE
VALUE
FIRST
NEXT
NORMALLY
YOU
WOULD
RETRIEVE
THE
VALUE
OF
THE
ITEM
BY
ASSIGNING
IT
TO
SOME
VARIABLE
OF
TYPE
ITEM
BEFORE
DOING
THIS
ASSIGNMENT
BECAUSE
ONCE
YOU
CHANGE
THE
VALUE
OF
FIRST
YOU
MAY
NOT
HAVE
ANY
ACCESS
TO
THE
NODE
TO
WHICH
IT
WAS
REFERRING
TYPICALLY
THE
NODE
OB
JECT
BECOMES
AN
ORPHAN
AND
THE
JAVA
MEMORY
MANAGE
MENT
SYSTEM
EVENTUALLY
RECLAIMS
THE
MEMORY
IT
OCCUPIES
FIRST
FIRST
NEXT
FIRST
FIRST
REMOVING
THE
FIRST
NODE
IN
A
LINKED
LIST
AGAIN
THIS
OPERATION
JUST
INVOLVES
ONE
ASSIGNMENT
STATEMENT
SO
ITS
RUNNING
TIME
IS
INDEPENDENT
OF
THE
LENGTH
OF
THE
LIST
INSERT
AT
THE
END
HOW
DO
WE
ADD
A
NODE
TO
THE
END
OF
A
LINKED
LIST
TO
DO
SO
WE
NEED
A
LINK
TO
THE
LAST
NODE
IN
THE
LIST
BECAUSE
THAT
NODE
LINK
HAS
TO
BE
CHANGED
TO
REFER
ENCE
A
NEW
NODE
CONTAINING
THE
ITEM
TO
BE
INSERTED
MAINTAINING
AN
EXTRA
LINK
IS
NOT
SOMETHING
THAT
SHOULD
BE
TAKEN
LIGHTLY
IN
LINKED
LIST
CODE
BECAUSE
EVERY
METHOD
THAT
MODIFIES
THE
LIST
NEEDS
CODE
TO
CHECK
WHETHER
THAT
VARIABLE
NEEDS
TO
BE
MODIFIED
AND
TO
MAKE
THE
NECESSARY
MODIFICATIONS
FOR
EXAMPLE
THE
CODE
THAT
WE
JUST
EXAMINED
FOR
REMOVING
THE
FIRST
NODE
IN
THE
LIST
MIGHT
IN
VOLVE
CHANGING
THE
REFERENCE
TO
THE
LAST
NODE
IN
THE
LIST
SINCE
WHEN
THERE
IS
ONLY
ONE
NODE
IN
THE
LIST
IT
IS
BOTH
THE
FIRST
ONE
AND
THE
LAST
ONE
ALSO
THIS
CODE
DOES
NOT
WORK
IT
FOLLOWS
A
NULL
LINK
IN
THE
CASE
THAT
THE
LIST
IS
EMPTY
DETAILS
LIKE
THESE
MAKE
LINKED
LIST
CODE
NOTO
RIOUSLY
DIFFICULT
TO
DEBUG
SAVE
A
LINK
TO
THE
LAST
NODE
NODE
OLDLAST
LAST
OLDLAST
FIRST
CREATE
A
NEW
NODE
FOR
THE
END
NODE
LAST
NEW
NODE
LAST
ITEM
NOT
LAST
INSERT
REMOVE
AT
OTHER
POSITIONS
IN
SUM
MARY
WE
HAVE
SHOWN
THAT
WE
CAN
IMPLEMENT
THE
FOLLOWING
OPERATIONS
ON
LINKED
LISTS
WITH
JUST
A
FEW
INSTRUCTIONS
PROVIDED
THAT
WE
HAVE
ACCESS
TO
BOTH
A
LINK
FIRST
TO
THE
FIRST
ELE
MENT
IN
THE
LIST
AND
A
LINK
LAST
TO
THE
LAST
ELEMENT
IN
THE
LIST
INSERT
AT
THE
BEGINNING
REMOVE
FROM
THE
BEGINNING
FIRST
LINK
THE
NEW
NODE
TO
THE
END
OF
THE
LIST
OLDLAST
NEXT
LAST
FIRST
OLDLAST
OLDLAST
LAST
LAST
INSERT
AT
THE
END
INSERTING
A
NEW
NODE
AT
THE
END
OF
A
LINKED
LIST
OTHER
OPERATIONS
SUCH
AS
THE
FOLLOWING
ARE
NOT
SO
EASILY
HANDLED
REMOVE
A
GIVEN
NODE
INSERT
A
NEW
NODE
BEFORE
A
GIVEN
NODE
FOR
EXAMPLE
HOW
CAN
WE
REMOVE
THE
LAST
NODE
FROM
A
LIST
THE
LINK
LAST
IS
NO
HELP
BECAUSE
WE
NEED
TO
SET
THE
LINK
IN
THE
PREVIOUS
NODE
IN
THE
LIST
THE
ONE
WITH
THE
SAME
VALUE
AS
LAST
TO
NULL
IN
THE
ABSENCE
OF
ANY
OTHER
INFORMATION
THE
ONLY
SOLUTION
IS
TO
TRAVERSE
THE
ENTIRE
LIST
LOOKING
FOR
THE
NODE
THAT
LINKS
TO
LAST
SEE
BELOW
AND
EXERCISE
SUCH
A
SOLUTION
IS
UNDESIRABLE
BECAUSE
IT
TAKES
TIME
PROPORTIONAL
TO
THE
LENGTH
OF
THE
LIST
THE
STANDARD
SOLUTION
TO
ENABLE
ARBITRARY
INSERTIONS
AND
DELETIONS
IS
TO
USE
A
DOUBLY
LINKED
LIST
WHERE
EACH
NODE
HAS
TWO
LINKS
ONE
IN
EACH
DIRECTION
WE
LEAVE
THE
CODE
FOR
THESE
OPERATIONS
AS
AN
EXERCISE
SEE
EXERCISE
WE
DO
NOT
NEED
DOUBLY
LINKED
LISTS
FOR
ANY
OF
OUR
IMPLEMENTATIONS
TRAVERSAL
TO
EXAMINE
EVERY
ITEM
IN
AN
ARRAY
WE
USE
FAMILIAR
CODE
LIKE
THE
FOLLOWING
LOOP
FOR
PROCESSING
THE
ITEMS
IN
AN
ARRAY
A
FOR
INT
I
I
N
I
PROCESS
A
I
THERE
IS
A
CORRESPONDING
IDIOM
FOR
EXAMINING
THE
ITEMS
IN
A
LINKED
LIST
WE
INITIALIZE
A
LOOP
INDEX
VARIABLE
X
TO
REFERENCE
THE
FIRST
NODE
OF
THE
LINKED
LIST
THEN
WE
FIND
THE
ITEM
ASSOCIATED
WITH
X
BY
ACCESSING
X
ITEM
AND
THEN
UPDATE
X
TO
REFER
TO
THE
NEXT
NODE
IN
THE
LINKED
LIST
ASSIGNING
TO
IT
THE
VALUE
OF
X
NEXT
AND
REPEATING
THIS
PROCESS
UNTIL
X
IS
NULL
WHICH
INDICATES
THAT
WE
HAVE
REACHED
THE
END
OF
THE
LINKED
LIST
THIS
PROCESS
IS
KNOWN
AS
TRAVERSING
THE
LIST
AND
IS
SUCCINCTLY
EXPRESSED
IN
CODE
LIKE
THE
FOLLOWING
LOOP
FOR
PRO
CESSING
THE
ITEMS
IN
A
LINKED
LIST
WHOSE
FIRST
ITEM
IS
ASSOCIATED
WITH
THE
VARIABLE
FIRST
FOR
NODE
X
FIRST
X
NULL
X
X
NEXT
PROCESS
X
ITEM
THIS
IDIOM
IS
AS
NATURAL
AS
THE
STANDARD
IDIOM
FOR
ITERATING
THROUGH
THE
ITEMS
IN
AN
AR
RAY
IN
OUR
IMPLEMENTATIONS
WE
USE
IT
AS
THE
BASIS
FOR
ITERATORS
FOR
PROVIDING
CLIENT
CODE
THE
CAPABILITY
OF
ITERATING
THROUGH
THE
ITEMS
WITHOUT
HAVING
TO
KNOW
THE
DETAILS
OF
THE
LINKED
LIST
IMPLEMENTATION
STACK
IMPLEMENTATION
GIVEN
THESE
PRELIMINARIES
DEVELOPING
AN
IMPLEMENTATION
FOR
OUR
STACK
API
IS
STRAIGHTFORWARD
AS
SHOWN
IN
ALGORITHM
ON
PAGE
IT
MAINTAINS
THE
STACK
AS
A
LINKED
LIST
WITH
THE
TOP
OF
THE
STACK
AT
THE
BEGINNING
REFERENCED
BY
AN
INSTANCE
VARIABLE
FIRST
THUS
TO
PUSH
AN
ITEM
WE
ADD
IT
TO
THE
BEGINNING
OF
THE
LIST
USING
THE
CODE
DISCUSSED
ON
PAGE
AND
TO
POP
AN
ITEM
WE
REMOVE
IT
FROM
THE
BEGINNINGOF
THE
LIST
USINGTHECODEDISCUSSEDONPAGE
TO
IMPLEMENT
SIZE
WEKEEP
TRACK
OF
THE
NUMBER
OF
ITEMS
IN
AN
INSTANCE
VARIABLE
N
INCREMENTING
N
WHEN
WE
PUSH
AND
DECREMENTING
N
WHEN
WE
POP
TO
IMPLEMENT
ISEMPTY
WE
CHECK
WHETHER
FIRST
IS
NULL
ALTERNATIVELY
WE
COULD
CHECK
WHETHER
N
IS
THE
IMPLEMENTATION
USES
THE
GENERIC
TYPE
ITEM
YOU
CAN
THINK
OF
THE
CODE
ITEM
AFTER
THE
CLASS
NAME
AS
MEANING
THAT
ANY
OCCURRENCE
OF
ITEM
IN
THE
IMPLEMENTATION
WILL
BE
REPLACED
BY
A
CLIENT
SUPPLIED
DATA
TYPE
NAME
SEE
PAGE
FOR
NOW
WE
OMIT
THE
CODE
TO
SUPPORT
ITERATION
WHICH
WE
CONSIDER
ON
PAGE
A
TRACE
FOR
THE
TEST
CLIENT
THAT
WE
HAVE
BEEN
USING
IS
SHOWN
ON
THE
NEXT
PAGE
THIS
USE
OF
LINKED
LISTS
ACHIEVES
OUR
OPTIMUM
DESIGN
GOALS
IT
CAN
BE
USED
FOR
ANY
TYPE
OF
DATA
THE
SPACE
REQUIRED
IS
ALWAYS
PROPORTIONAL
TO
THE
SIZE
OF
THE
COLLECTION
THE
TIME
PER
OPERATION
IS
ALWAYS
INDEPENDENT
OF
THE
SIZE
OF
THE
COLLECTION
THIS
IMPLEMENTATION
IS
A
PROTOTYPE
FOR
MANY
ALGORITHM
IMPLEMENTATIONS
THAT
WE
CON
SIDER
IT
DEFINES
THE
LINKED
LIST
DATA
STRUCTURE
AND
IMPLEMENTS
THE
CLIENT
METHODS
PUSH
AND
POP
THAT
ACHIEVE
THE
SPECIFIED
EFFECT
WITH
JUST
A
FEW
LINES
OF
CODE
THE
ALGORITHMS
AND
DATA
STRUCTURE
GO
HAND
IN
HAND
IN
THIS
CASE
THE
CODE
FOR
THE
ALGORITHM
IMPLEMEN
TATIONS
IS
QUITE
SIMPLE
BUT
THE
PROPERTIES
OF
THE
DATA
STRUCTURE
ARE
NOT
AT
ALL
ELEMEN
TARY
REQUIRING
EXPLANATIONS
ON
THE
PAST
SEVERAL
PAGES
THIS
INTERACTION
BETWEEN
DATA
STRUCTURE
DEFINITION
AND
ALGORITHM
IMPLEMENTATION
IS
TYPICAL
AND
IS
OUR
FOCUS
IN
ADT
IMPLEMENTATIONS
THROUGHOUT
THIS
BOOK
STDIN
STDOUT
TO
BE
OR
NOT
TO
BE
THAT
IS
TO
BE
NOT
THAT
OR
BE
TRACE
OF
STACK
DEVELOPMENT
CLIENT
ALGORITHM
PUSHDOWN
STACK
LINKED
LIST
IMPLEMENTATION
PUBLIC
CLASS
STACK
ITEM
IMPLEMENTS
ITERABLE
ITEM
PRIVATE
NODE
FIRST
TOP
OF
STACK
MOST
RECENTLY
ADDED
NODE
PRIVATE
INT
N
NUMBER
OF
ITEMS
PRIVATE
CLASS
NODE
NESTED
CLASS
TO
DEFINE
NODES
ITEM
ITEM
NODE
NEXT
PUBLIC
BOOLEAN
ISEMPTY
RETURN
FIRST
NULL
OR
N
PUBLIC
INT
SIZE
RETURN
N
PUBLIC
VOID
PUSH
ITEM
ITEM
ADD
ITEM
TO
TOP
OF
STACK
NODE
OLDFIRST
FIRST
FIRST
NEW
NODE
FIRST
ITEM
ITEM
FIRST
NEXT
OLDFIRST
N
PUBLIC
ITEM
POP
REMOVE
ITEM
FROM
TOP
OF
STACK
ITEM
ITEM
FIRST
ITEM
FIRST
FIRST
NEXT
N
RETURN
ITEM
SEE
PAGE
FOR
ITERATOR
IMPLEMENTATION
SEE
PAGE
FOR
TEST
CLIENT
MAIN
THIS
GENERIC
STACK
IMPLEMENTATION
IS
BASED
ON
A
LINKED
LIST
DATA
STRUCTURE
IT
CAN
BE
USED
TO
CREATE
STACKS
CONTAINING
ANY
TYPE
OF
DATA
TO
SUPPORT
ITERATION
ADD
THE
HIGHLIGHTED
CODE
DESCRIBED
FOR
BAG
ON
PAGE
QUEUE
IMPLEMENTATION
AN
IMPLEMENTATION
OF
OUR
QUEUE
API
BASED
ON
THE
LINKED
LIST
DATA
STRUCTURE
IS
ALSO
STRAIGHTFORWARD
AS
SHOWN
IN
ALGORITHM
ON
THE
FACING
PAGE
IT
MAINTAINS
THE
QUEUE
AS
A
LINKED
LIST
IN
ORDER
FROM
LEAST
RECENTLY
TO
MOST
RECENTLY
ADDED
ITEMS
WITH
THE
BEGINNING
OF
THE
QUEUE
REFERENCED
BY
AN
INSTANCE
VARIABLE
FIRST
AND
THE
END
OF
THE
QUEUE
REFERENCED
BY
AN
INSTANCE
VARIABLE
LAST
THUS
TO
ENQUEUE
AN
ITEM
WE
ADD
IT
TO
THE
END
OF
THE
LIST
USING
THE
CODE
DISCUSSED
ON
PAGE
AUGMENTED
TO
SET
BOTH
FIRST
AND
LAST
TO
REFER
TO
THE
NEW
NODE
WHEN
THE
LIST
IS
EMPTY
AND
TO
DEQUEUE
AN
ITEM
WE
REMOVE
IT
FROM
THE
BEGINNING
OF
THE
LIST
USING
THE
SAME
CODE
AS
FOR
POP
IN
STACK
AUGMENTED
TO
UPDATE
LAST
WHEN
THE
LIST
BECOMES
EMPTY
THE
IMPLEMENTATIONS
OF
SIZE
AND
ISEMPTY
ARE
THE
SAME
AS
FOR
STACK
AS
WITH
STACK
THE
IMPLEMENTATION
USES
THE
GENERIC
TYPE
PARAMETER
ITEM
AND
WE
OMIT
THE
CODE
TO
SUPPORT
ITERATION
WHICH
WE
CONSIDER
IN
OUR
BAG
IMPLEMENTATION
ON
PAGE
A
DEVELOP
MENT
CLIENT
SIMILAR
TO
THE
ONE
WE
USED
FOR
STACK
IS
SHOWN
BELOW
AND
THE
TRACE
FOR
THIS
CLIENT
IS
SHOWN
ON
THE
FOLLOWING
PAGE
THIS
IMPLEMENTATION
USES
THE
SAME
DATA
STRUC
TURE
AS
DOES
STACK
A
LINKED
LIST
BUT
IT
IMPLEMENTS
DIFFERENT
ALGORITHMS
FOR
ADDING
AND
REMOVING
ITEMS
WHICH
MAKE
THE
DIFFERENCE
BETWEEN
LIFO
AND
FIFO
FOR
THE
CLIENT
AGAIN
THE
USE
OF
LINKED
LISTS
ACHIEVES
OUR
OPTIMUM
DESIGN
GOALS
IT
CAN
BE
USED
FOR
ANY
TYPE
OF
DATA
THE
SPACE
REQUIRED
IS
PROPORTIONAL
TO
THE
NUMBER
OF
ITEMS
IN
THE
COLLECTION
AND
THE
TIME
REQUIRED
PER
OPERATION
IS
ALWAYS
INDEPENDENT
OF
THE
SIZE
OF
THE
COLLECTION
ALGORITHM
FIFO
QUEUE
PUBLIC
CLASS
QUEUE
ITEM
IMPLEMENTS
ITERABLE
ITEM
PRIVATE
NODE
FIRST
LINK
TO
LEAST
RECENTLY
ADDED
NODE
PRIVATE
NODE
LAST
LINK
TO
MOST
RECENTLY
ADDED
NODE
PRIVATE
INT
N
NUMBER
OF
ITEMS
ON
THE
QUEUE
PRIVATE
CLASS
NODE
NESTED
CLASS
TO
DEFINE
NODES
ITEM
ITEM
NODE
NEXT
PUBLIC
BOOLEAN
ISEMPTY
RETURN
FIRST
NULL
OR
N
PUBLIC
INT
SIZE
RETURN
N
PUBLIC
VOID
ENQUEUE
ITEM
ITEM
ADD
ITEM
TO
THE
END
OF
THE
LIST
NODE
OLDLAST
LAST
LAST
NEW
NODE
LAST
ITEM
ITEM
LAST
NEXT
NULL
IF
ISEMPTY
FIRST
LAST
ELSE
OLDLAST
NEXT
LAST
N
PUBLIC
ITEM
DEQUEUE
REMOVE
ITEM
FROM
THE
BEGINNING
OF
THE
LIST
ITEM
ITEM
FIRST
ITEM
FIRST
FIRST
NEXT
IF
ISEMPTY
LAST
NULL
N
RETURN
ITEM
SEE
PAGE
FOR
ITERATOR
IMPLEMENTATION
SEE
PAGE
FOR
TEST
CLIENT
MAIN
THIS
GENERIC
QUEUE
IMPLEMENTATION
IS
BASED
ON
A
LINKED
LIST
DATA
STRUCTURE
IT
CAN
BE
USED
TO
CREATE
QUEUES
CONTAINING
ANY
TYPE
OF
DATA
TO
SUPPORT
ITERATION
ADD
THE
HIGHLIGHTED
CODE
DESCRIBED
FOR
BAG
ON
PAGE
STDIN
STDOUT
TO
BE
OR
NOT
TO
BE
THAT
IS
TO
BE
OR
NOT
TO
BE
TRACE
OF
QUEUE
DEVELOPMENT
CLIENT
LINKED
LISTS
ARE
A
FUNDAMENTAL
ALTERNATIVE
TO
ARRAYS
FOR
STRUCTURING
A
COLLECTION
OF
DATA
FROM
A
HISTORICAL
PERSPECTIVE
THIS
ALTERNATIVE
HAS
BEEN
AVAILABLE
TO
PROGRAM
MERS
FOR
MANY
DECADES
INDEED
A
LANDMARK
IN
THE
HISTORY
OF
PROGRAMMING
LANGUAGES
WAS
THE
DEVELOPMENT
OF
LISP
BY
JOHN
MCCARTHY
IN
THE
WHERE
LINKED
LISTS
ARE
THE
PRIMARY
STRUCTURE
FOR
PROGRAMS
AND
DATA
PROGRAMMING
WITH
LINKED
LISTS
PRESENTS
ALL
SORTS
OF
CHALLENGES
AND
IS
NOTORIOUSLY
DIFFICULT
TO
DEBUG
AS
YOU
CAN
SEE
IN
THE
EXERCISES
IN
MODERN
CODE
THE
USE
OF
SAFE
POINTERS
AUTOMATIC
GARBAGE
COLLECTION
SEE
PAGE
AND
ADTS
ALLOWS
US
TO
ENCAPSULATE
LIST
PROCESSING
CODE
IN
JUST
A
FEW
CLASSES
SUCH
AS
THE
ONES
PRESENTED
HERE
BAG
IMPLEMENTATION
IMPLEMENTING
OUR
BAG
API
USING
A
LINKED
LIST
DATA
STRUCTURE
IS
SIMPLY
A
MATTER
OF
CHANGING
THE
NAME
OF
PUSH
IN
STACK
TO
ADD
AND
REMOVING
THE
IMPLEMENTATION
OF
POP
AS
SHOWN
IN
ALGORITHM
ON
THE
FACING
PAGE
DOING
THE
SAME
FOR
QUEUE
WOULD
ALSO
BE
EFFECTIVE
BUT
REQUIRES
A
BIT
MORE
CODE
THIS
IMPLEMEN
TATION
ALSO
HIGHLIGHTS
THE
CODE
NEEDED
TO
MAKE
STACK
QUEUE
AND
BAG
ALL
ITERABLE
BY
TRAVERSING
THE
LIST
FOR
STACK
THE
LIST
IS
IN
LIFO
ORDER
FOR
QUEUE
IT
IS
IN
FIFO
ORDER
AND
FOR
BAG
IT
HAPPENS
TO
BE
IN
LIFO
ORDER
BUT
THE
ORDER
IS
NOT
RELEVANT
AS
DETAILED
IN
THE
HIGHLIGHTED
CODE
IN
ALGORITHM
TO
IMPLEMENT
ITERATION
IN
A
COLLECTION
THE
FIRST
STEP
IS
TO
INCLUDE
IMPORT
JAVA
UTIL
ITERATOR
SO
THAT
OUR
CODE
CAN
REFER
TO
JAVA
ITERATOR
INTERFACE
THE
SECOND
STEP
IS
TO
ADD
IMPLEMENTS
ITERABLE
ITEM
TO
THE
CLASS
DECLARATION
A
PROMISE
TO
PROVIDE
AN
ITERATOR
METHOD
THE
ITERATOR
METHOD
ITSELF
SIMPLY
RETURNS
AN
OBJECT
FROM
A
CLASS
THAT
IMPLEMENTS
THE
ITERATOR
INTERFACE
PUBLIC
ITERATOR
ITEM
ITERATOR
RETURN
NEW
LISTITERATOR
THIS
CODE
IS
A
PROMISE
TO
IMPLEMENT
A
CLASS
THAT
IMPLEMENTS
THE
HASNEXT
NEXT
AND
REMOVE
METHODS
THAT
ARE
CALLED
WHEN
A
CLIENT
USES
THE
FOREACH
CONSTRUCT
TO
IMPLEMENT
THESE
METHODS
THE
NESTED
CLASS
LISTITERATOR
IN
ALGORITHM
MAINTAINS
AN
INSTANCE
VARIABLE
CURRENT
THAT
KEEPS
TRACK
OF
THE
CURRENT
NODE
ON
THE
LIST
THEN
THE
HASNEXT
METHOD
TESTS
IF
CURRENT
IS
NULL
AND
THE
NEXT
METHOD
SAVES
A
REFERENCE
TO
THE
CURRENT
ITEM
UPDATES
CURRENT
TO
REFER
TO
THE
NEXT
NODE
ON
THE
LIST
AND
RETURNS
THE
SAVED
REFERENCE
ALGORITHM
BAG
IMPORT
JAVA
UTIL
ITERATOR
PUBLIC
CLASS
BAG
ITEM
IMPLEMENTS
ITERABLE
ITEM
PRIVATE
NODE
FIRST
FIRST
NODE
IN
LIST
PRIVATE
CLASS
NODE
ITEM
ITEM
NODE
NEXT
PUBLIC
VOID
ADD
ITEM
ITEM
SAME
AS
PUSH
IN
STACK
NODE
OLDFIRST
FIRST
FIRST
NEW
NODE
FIRST
ITEM
ITEM
FIRST
NEXT
OLDFIRST
PUBLIC
ITERATOR
ITEM
ITERATOR
RETURN
NEW
LISTITERATOR
PRIVATE
CLASS
LISTITERATOR
IMPLEMENTS
ITERATOR
ITEM
PRIVATE
NODE
CURRENT
FIRST
PUBLIC
BOOLEAN
HASNEXT
RETURN
CURRENT
NULL
PUBLIC
VOID
REMOVE
PUBLIC
ITEM
NEXT
ITEM
ITEM
CURRENT
ITEM
CURRENT
CURRENT
NEXT
RETURN
ITEM
THIS
BAG
IMPLEMENTATION
MAINTAINS
A
LINKED
LIST
OF
THE
ITEMS
PROVIDED
IN
CALLS
TO
ADD
CODE
FOR
ISEMPTY
AND
SIZE
IS
THE
SAME
AS
IN
STACK
AND
IS
OMITTED
THE
ITERATOR
TRAVERSES
THE
LIST
MAIN
TAINING
THE
CURRENT
NODE
IN
CURRENT
WE
CAN
MAKE
STACK
AND
QUEUE
ITERABLE
BY
ADDING
THE
CODE
HIGHLIGHTED
IN
RED
TO
ALGORITHMS
AND
BECAUSE
THEY
USE
THE
SAME
UNDERLYING
DATA
STRUCTURE
AND
STACK
AND
QUEUE
MAINTAIN
THE
LIST
IN
LIFO
AND
FIFO
ORDER
RESPECTIVELY
OVERVIEW
THE
IMPLEMENTATIONS
OF
BAGS
QUEUES
AND
STACKS
THAT
SUPPORT
GENERICS
AND
ITERATION
THAT
WE
HAVE
CONSIDERED
IN
THIS
SECTION
PROVIDE
A
LEVEL
OF
ABSTRACTION
THAT
ALLOWS
US
TO
WRITE
COMPACT
CLIENT
PROGRAMS
THAT
MANIPULATE
COLLECTIONS
OF
OBJECTS
DE
TAILED
UNDERSTANDING
OF
THESE
ADTS
IS
IMPORTANT
AS
AN
INTRODUCTION
TO
THE
STUDY
OF
AL
GORITHMS
AND
DATA
STRUCTURES
FOR
THREE
REASONS
FIRST
WE
USE
THESE
DATA
TYPES
AS
BUILDING
BLOCKS
IN
HIGHER
LEVEL
DATA
STRUCTURES
THROUGHOUT
THIS
BOOK
SECOND
THEY
ILLUSTRATE
THE
INTERPLAY
BETWEEN
DATA
STRUCTURES
AND
ALGORITHMS
AND
THE
CHALLENGE
OF
SIMULTANEOUSLY
ACHIEVING
NATURAL
PERFORMANCE
GOALS
THAT
MAY
CONFLICT
THIRD
THE
FOCUS
OF
SEVERAL
OF
OUR
IMPLEMENTATIONS
IS
ON
ADTS
THAT
SUPPORT
MORE
POWERFUL
OPERATIONS
ON
COLLECTIONS
OF
OBJECTS
AND
WE
USE
THE
IMPLEMENTATIONS
HERE
AS
STARTING
POINTS
DATA
STRUCTURES
WE
NOW
HAVE
TWO
WAYS
TO
REPRESENT
COLLECTIONS
OF
OBJECTS
ARRAYS
AND
LINKED
LISTS
ARRAYS
ARE
BUILT
IN
TO
JAVA
LINKED
LISTS
ARE
EASY
TO
BUILD
WITH
STANDARD
JAVA
RECORDS
THESE
TWO
ALTERNATIVES
OFTEN
REFERRED
TO
AS
SEQUENTIAL
ALLOCATION
AND
LINKED
AL
LOCATION
ARE
FUNDAMENTAL
LATER
IN
THE
BOOK
WE
DEVELOP
ADT
IMPLEMENTATIONS
THAT
COMBINE
AND
EXTEND
THESE
BASIC
STRUCTURES
IN
NUMEROUS
WAYS
ONE
IMPORTANT
EXTEN
DATA
STRUCTURE
ADVANTAGE
DISADVANTAGE
SION
IS
TO
DATA
STRUCTURES
WITH
MULTIPLE
INDEX
PROVIDES
ARRAY
IMMEDIATE
ACCESS
TO
ANY
ITEM
USES
SPACE
PROPORTIONAL
TO
SIZE
NEED
TO
KNOW
SIZE
ON
INITIALIZATION
NEED
REFERENCE
TO
ACCESS
AN
ITEM
LINKS
FOR
EXAMPLE
OUR
FOCUS
IN
SECTIONS
AND
IS
ON
DATA
STRUCTURES
KNOWN
AS
BINARY
TREES
THAT
ARE
BUILT
FROM
NODES
THAT
EACH
HAVE
TWO
LINKS
ANOTHER
IMPORTANT
EXTENSION
IS
TO
COMPOSE
DATA
STRUCTURES
FUNDAMENTAL
DATA
STRUCTURES
WE
CAN
HAVE
A
BAG
OF
STACKS
A
QUEUE
OF
AR
RAYS
AND
SO
FORTH
FOR
EXAMPLE
OUR
FOCUS
IN
CHAPTER
IS
ON
GRAPHS
WHICH
WE
REP
RESENT
AS
ARRAYS
OF
BAGS
IT
IS
VERY
EASY
TO
DEFINE
DATA
STRUCTURES
OF
ARBITRARY
COMPLEXITY
IN
THIS
WAY
ONE
IMPORTANT
REASON
FOR
OUR
FOCUS
ON
ABSTRACT
DATA
TYPES
IS
AN
ATTEMPT
TO
CONTROL
SUCH
COMPLEXITY
OUR
TREATMENT
OF
BAGS
QUEUES
AND
STACKS
IN
THIS
SECTION
IS
A
PROTOTYPICAL
EX
AMPLE
OF
THE
APPROACH
THAT
WE
USE
THROUGHOUT
THIS
BOOK
TO
DESCRIBE
DATA
STRUCTURES
AND
ALGORITHMS
IN
APPROACHING
A
NEW
APPLICATIONS
DOMAIN
WE
IDENTIFY
COMPUTATIONAL
CHALLENGES
AND
USE
DATA
ABSTRACTION
TO
ADDRESS
THEM
PROCEEDING
AS
FOLLOWS
SPECIFY
AN
API
DEVELOP
CLIENT
CODE
WITH
REFERENCE
TO
SPECIFIC
APPLICATIONS
DESCRIBE
A
DATA
STRUCTURE
REPRESENTATION
OF
THE
SET
OF
VALUES
THAT
CAN
SERVE
AS
THE
BASIS
FOR
THE
INSTANCE
VARIABLES
IN
A
CLASS
THAT
WILL
IMPLEMENT
AN
ADT
THAT
MEETS
THE
SPECIFICATION
IN
THE
API
DESCRIBE
ALGORITHMS
APPROACHES
TO
IMPLEMENTING
THE
SET
OF
OPERATIONS
THAT
CAN
SERVE
AS
THE
BASIS
FOR
IMPLEMENTING
THE
INSTANCE
METHODS
IN
THE
CLASS
ANALYZE
THE
PERFORMANCE
CHARACTERISTICS
OF
THE
ALGORITHMS
IN
THE
NEXT
SECTION
WE
CONSIDER
THIS
LAST
STEP
IN
DETAIL
AS
IT
OFTEN
DICTATES
WHICH
ALGO
RITHMS
AND
IMPLEMENTATIONS
CAN
BE
MOST
USEFUL
IN
ADDRESSING
REAL
WORLD
APPLICATIONS
HASH
TABLE
HASH
TABLE
LINEARPROBINGHASHST
TWO
ARRAYS
OF
OBJECTS
GRAPH
ADJACENCY
LISTS
GRAPH
ARRAY
OF
BAG
OBJECTS
TRIE
TRIEST
NODE
WITH
ARRAY
OF
LINKS
TERNARY
SEARCH
TRIE
TST
THREE
LINKS
PER
NODE
EXAMPLES
OF
DATA
STRUCTURES
DEVELOPED
IN
THIS
BOOK
Q
NOT
ALL
PROGRAMMING
LANGUAGES
HAVE
GENERICS
EVEN
EARLY
VERSIONS
OF
JAVA
WHAT
ARE
THE
ALTERNATIVES
A
ONE
ALTERNATIVE
IS
TO
MAINTAIN
A
DIFFERENT
IMPLEMENTATION
FOR
EACH
TYPE
OF
DATA
AS
MENTIONED
IN
THE
TEXT
ANOTHER
IS
TO
BUILD
A
STACK
OF
OBJECT
VALUES
THEN
CAST
TO
THE
DESIRED
TYPE
IN
CLIENT
CODE
FOR
POP
THE
PROBLEM
WITH
THIS
APPROACH
IS
THAT
TYPE
MIS
MATCH
ERRORS
CANNOT
BE
DETECTED
UNTIL
RUN
TIME
BUT
WITH
GENERICS
IF
YOU
WRITE
CODE
TO
PUSH
AN
OBJECT
OF
THE
WRONG
TYPE
ON
THE
STACK
LIKE
THIS
STACK
APPLE
STACK
NEW
STACK
APPLE
APPLE
A
NEW
APPLE
ORANGE
B
NEW
ORANGE
STACK
PUSH
A
STACK
PUSH
B
COMPILE
TIME
ERROR
YOU
WILL
GET
A
COMPILE
TIME
ERROR
PUSH
APPLE
IN
STACK
APPLE
CANNOT
BE
APPLIED
TO
ORANGE
THIS
ABILITY
TO
DISCOVER
SUCH
ERRORS
AT
COMPILE
TIME
IS
REASON
ENOUGH
TO
USE
GENERICS
Q
WHY
DOES
JAVA
DISALLOW
GENERIC
ARRAYS
A
EXPERTS
STILL
DEBATE
THIS
POINT
YOU
MIGHT
NEED
TO
BECOME
ONE
TO
UNDERSTAND
IT
FOR
STARTERS
LEARN
ABOUT
COVARIANT
ARRAYS
AND
TYPE
ERASURE
Q
HOW
DO
I
CREATE
AN
ARRAY
OF
STACKS
OF
STRINGS
A
USE
A
CAST
SUCH
AS
THE
FOLLOWING
STACK
STRING
A
STACK
STRING
NEW
STACK
N
WARNING
THIS
CAST
IN
CLIENT
CODE
IS
DIFFERENT
FROM
THE
ONE
DESCRIBED
ON
PAGE
YOU
MIGHT
HAVE
EXPECTED
TO
USE
OBJECT
INSTEAD
OF
STACK
WHEN
USING
GENERICS
JAVA
CHECKS
FOR
TYPE
SAFETY
AT
COMPILE
TIME
BUT
THROWS
AWAY
THAT
INFORMATION
AT
RUN
TIME
SO
IT
IS
LEFT
WITH
STACK
OBJECT
OR
JUST
STACK
FOR
SHORT
WHICH
WE
MUST
CAST
TO
STACK
STRING
Q
WHAT
HAPPENS
IF
MY
PROGRAM
CALLS
POP
FOR
AN
EMPTY
STACK
A
IT
DEPENDSONTHEIMPLEMENTATION
FOROURIMPLEMENTATIONONPAGE
YOUWILLGETA
NULLPOINTEREXCEPTION
IN
OUR
IMPLEMENTATIONS
ON
THE
BOOKSITE
WE
THROW
A
RUNTIME
EXCEPTION
TO
HELP
USERS
PINPOINT
THE
ERROR
GENERALLY
INCLUDING
AS
MANY
SUCH
CHECKS
AS
POSSIBLE
IS
WISE
IN
CODE
THAT
IS
LIKELY
TO
BE
USED
BY
MANY
PEOPLE
Q
WHY
DO
WE
CARE
ABOUT
RESIZING
ARRAYS
WHEN
WE
HAVE
LINKED
LISTS
A
WE
WILL
SEE
SEVERAL
EXAMPLES
OF
ADT
IMPLEMENTATIONS
THAT
NEED
TO
USE
AR
RAYS
TO
PERFORM
OTHER
OPERATIONS
THAT
ARE
NOT
EASILY
SUPPORTED
WITH
LINKED
LISTS
RESIZINGARRAYSTACK
IS
A
MODEL
FOR
KEEPING
THEIR
MEMORY
USAGE
UNDER
CONTROL
Q
WHY
DECLARE
NODE
AS
A
NESTED
CLASS
WHY
PRIVATE
A
BY
DECLARING
THE
NESTED
CLASS
NODE
TO
BE
PRIVATE
WE
RESTRICT
ACCESS
TO
METHODS
AND
INSTANCE
VARIABLES
WITHIN
THE
ENCLOSING
CLASS
ONE
CHARACTERISTIC
OF
A
PRIVATE
NESTED
CLASS
IS
THAT
ITS
INSTANCE
VARIABLES
CAN
BE
DIRECTLY
ACCESSED
FROM
WITHIN
THE
ENCLOSING
CLASS
BUT
NOWHERE
ELSE
SO
THERE
IS
NO
NEED
TO
DECLARE
THE
INSTANCE
VARIABLES
PUBLIC
OR
PRIVATE
NOTE
FOR
EXPERTS
A
NESTED
CLASS
THAT
IS
NOT
STATIC
IS
KNOWN
AS
AN
INNER
CLASS
SO
TECHNICALLY
OUR
NODE
CLASSES
ARE
INNER
CLASSES
THOUGH
THE
ONES
THAT
ARE
NOT
GENERIC
COULD
BE
STATIC
Q
WHEN
I
TYPE
JAVAC
STACK
JAVA
TO
RUN
ALGORITHM
AND
SIMILAR
PROGRAMS
I
FIND
STACK
CLASS
AND
A
FILE
STACK
NODE
CLASS
WHAT
IS
THE
PURPOSE
OF
THAT
SECOND
ONE
A
THAT
FILE
IS
FOR
THE
INNER
CLASS
NODE
JAVA
NAMING
CONVENTION
IS
TO
USE
TO
SEPARATE
THE
NAME
OF
THE
OUTER
CLASS
FROM
THE
INNER
CLASS
Q
ARE
THERE
JAVA
LIBRARIES
FOR
STACKS
AND
QUEUES
A
YES
AND
NO
JAVA
HAS
A
BUILT
IN
LIBRARY
CALLED
JAVA
UTIL
STACK
BUT
YOU
SHOULD
AVOID
USING
IT
WHEN
YOU
WANT
A
STACK
IT
HAS
SEVERAL
ADDITIONAL
OPERATIONS
THAT
ARE
NOT
NORMALLY
ASSOCIATED
WITH
A
STACK
E
G
GETTING
THE
ITH
ELEMENT
IT
ALSO
ALLOWS
ADDING
AN
ELEMENT
TO
THE
BOTTOM
OF
THE
STACK
INSTEAD
OF
THE
TOP
SO
IT
CAN
IMPLEMENT
A
QUEUE
ALTHOUGH
HAVING
SUCH
EXTRA
OPERATIONS
MAY
APPEAR
TO
BE
A
BONUS
IT
IS
ACTUALLY
A
CURSE
WE
USE
DATA
TYPES
NOT
JUST
AS
LIBRARIES
OF
ALL
THE
OPERATIONS
WE
CAN
IMAGINE
BUT
ALSO
AS
A
MECHANISM
TO
PRECISELY
SPECIFY
THE
OPERATIONS
WE
NEED
THE
PRIME
BENEFIT
OF
DOING
SO
IS
THAT
THE
SYSTEM
CAN
PREVENT
US
FROM
PERFORMING
OPERATIONS
THAT
WE
DO
NOT
ACTUALLY
Q
A
CONTINUED
WANT
THE
JAVA
UTIL
STACK
API
IS
AN
EXAMPLE
OF
A
WIDE
INTERFACE
WHICH
WE
GENERALLY
STRIVE
TO
AVOID
Q
SHOULD
A
CLIENT
BE
ALLOWED
TO
INSERT
NULL
ITEMS
ONTO
A
STACK
OR
QUEUE
A
THIS
QUESTION
ARISES
FREQUENTLY
WHEN
IMPLEMENTING
COLLECTIONS
IN
JAVA
OUR
IMPLE
MENTATION
AND
JAVA
STACK
AND
QUEUE
LIBRARIES
DO
PERMIT
THE
INSERTION
OF
NULL
VALUES
Q
WHAT
SHOULD
THE
STACK
ITERATOR
DO
IF
THE
CLIENT
CALLS
PUSH
OR
POP
DURING
ITERATOR
A
THROW
A
JAVA
UTIL
CONCURRENTMODIFICATIONEXCEPTION
TO
MAKE
IT
A
FAIL
FAST
IT
ERATOR
SEE
Q
CAN
I
USE
A
FOREACH
LOOP
WITH
ARRAYS
A
YES
EVEN
THOUGH
ARRAYS
DO
NOT
IMPLEMENT
THE
ITERABLE
INTERFACE
THE
FOLLOWING
ONE
LINER
PRINTS
OUT
THE
COMMAND
LINE
ARGUMENTS
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
FOR
STRING
ARGS
STDOUT
PRINTLN
Q
CAN
I
USE
A
FOREACH
LOOP
WITH
STRINGS
A
NO
STRING
DOES
NOT
IMPLEMENT
ITERABLE
Q
WHY
NOT
HAVE
A
SINGLE
COLLECTION
DATA
TYPE
THAT
IMPLEMENTS
METHODS
TO
ADD
ITEMS
REMOVE
THE
MOST
RECENTLY
INSERTED
REMOVE
THE
LEAST
RECENTLY
INSERTED
REMOVE
RANDOM
ITERATE
RETURN
THE
NUMBER
OF
ITEMS
IN
THE
COLLECTION
AND
WHATEVER
OTHER
OPERATIONS
WE
MIGHT
DESIRE
THEN
WE
COULD
GET
THEM
ALL
IMPLEMENTED
IN
A
SINGLE
CLASS
THAT
COULD
BE
USED
BY
MANY
CLIENTS
A
AGAIN
THIS
IS
AN
EXAMPLE
OF
A
WIDE
INTERFACE
JAVA
HAS
SUCH
IMPLEMENTATIONS
IN
ITS
JAVA
UTIL
ARRAYLIST
AND
JAVA
UTIL
LINKEDLIST
CLASSES
ONE
REASON
TO
AVOID
THEM
IS
THAT
IT
THERE
IS
NO
ASSURANCE
THAT
ALL
OPERATIONS
ARE
IMPLEMENTED
EFFICIENTLY
THROUGH
OUT
THIS
BOOK
WE
USE
APIS
AS
STARTING
POINTS
FOR
DESIGNING
EFFICIENT
ALGORITHMS
AND
DATA
STRUCTURES
WHICH
IS
CERTAINLY
EASIER
TO
DO
FOR
INTERFACES
WITH
JUST
A
FEW
OPERATIONS
AS
OPPOSED
TO
AN
INTERFACE
WITH
MANY
OPERATIONS
ANOTHER
REASON
TO
INSIST
ON
NARROW
IN
TERFACES
IS
THAT
THEY
ENFORCE
A
CERTAIN
DISCIPLINE
ON
CLIENT
PROGRAMS
WHICH
MAKES
CLIENT
CODE
MUCH
EASIER
TO
UNDERSTAND
IF
ONE
CLIENT
USES
STACK
STRING
AND
ANOTHER
USES
QUEUE
TRANSACTION
WE
HAVE
A
GOOD
IDEA
THAT
THE
LIFO
DISCIPLINE
IS
IMPORTANT
TO
THE
FIRST
AND
THE
FIFO
DISCIPLINE
IS
IMPORTANT
TO
THE
SECOND
ADD
A
METHOD
ISFULL
TO
FIXEDCAPACITYSTACKOFSTRINGS
GIVE
THE
OUTPUT
PRINTED
BY
JAVA
STACK
FOR
THE
INPUT
IT
WAS
THE
BEST
OF
TIMES
IT
WAS
THE
SUPPOSE
THAT
A
CLIENT
PERFORMS
AN
INTERMIXED
SEQUENCE
OF
STACK
PUSH
AND
POP
OPERATIONS
THE
PUSH
OPERATIONS
PUT
THE
INTEGERS
THROUGH
IN
ORDER
ONTO
THE
STACK
THE
POP
OPERATIONS
PRINT
OUT
THE
RETURN
VALUES
WHICH
OF
THE
FOLLOWING
SEQUENCE
COULD
NOT
OCCUR
A
B
C
D
E
F
G
H
WRITE
A
STACK
CLIENT
PARENTHESES
THAT
READS
IN
A
TEXT
STREAM
FROM
STANDARD
INPUT
AND
USES
A
STACK
TO
DETERMINE
WHETHER
ITS
PARENTHESES
ARE
PROPERLY
BALANCED
FOR
EX
AMPLE
YOUR
PROGRAM
SHOULD
PRINT
TRUE
FOR
AND
FALSE
FOR
WHAT
DOES
THE
FOLLOWING
CODE
FRAGMENT
PRINT
WHEN
N
IS
GIVE
A
HIGH
LEVEL
DESCRIPTION
OF
WHAT
IT
DOES
WHEN
PRESENTED
WITH
A
POSITIVE
INTEGER
N
STACK
INTEGER
STACK
NEW
STACK
INTEGER
WHILE
N
STACK
PUSH
N
N
N
FOR
INT
D
STACK
STDOUT
PRINT
D
STDOUT
PRINTLN
ANSWER
PRINTS
THE
BINARY
REPRESENTATION
OF
N
WHEN
N
IS
EXERCISES
CONTINUED
WHAT
DOES
THE
FOLLOWING
CODE
FRAGMENT
DO
TO
THE
QUEUE
Q
STACK
STRING
STACK
NEW
STACK
STRING
WHILE
Q
ISEMPTY
STACK
PUSH
Q
DEQUEUE
WHILE
STACK
ISEMPTY
Q
ENQUEUE
STACK
POP
ADD
A
METHOD
PEEK
TO
STACK
THAT
RETURNS
THE
MOST
RECENTLY
INSERTED
ITEM
ON
THE
STACK
WITHOUT
POPPING
IT
GIVE
THE
CONTENTS
AND
SIZE
OF
THE
ARRAY
FOR
DOUBLINGSTACKOFSTRINGS
WITH
THE
INPUT
IT
WAS
THE
BEST
OF
TIMES
IT
WAS
THE
WRITE
A
PROGRAM
THAT
TAKES
FROM
STANDARD
INPUT
AN
EXPRESSION
WITHOUT
LEFT
PA
RENTHESES
AND
PRINTS
THE
EQUIVALENT
INFIX
EXPRESSION
WITH
THE
PARENTHESES
INSERTED
FOR
EXAMPLE
GIVEN
THE
INPUT
YOUR
PROGRAM
SHOULD
PRINT
WRITE
A
FILTER
INFIXTOPOSTFIX
THAT
CONVERTS
AN
ARITHMETIC
EXPRESSION
FROM
IN
FIX
TO
POSTFIX
WRITE
A
PROGRAM
EVALUATEPOSTFIX
THAT
TAKES
A
POSTFIX
EXPRESSION
FROM
STAN
DARD
INPUT
EVALUATES
IT
AND
PRINTS
THE
VALUE
PIPING
THE
OUTPUT
OF
YOUR
PROGRAM
FROM
THE
PREVIOUS
EXERCISE
TO
THIS
PROGRAM
GIVES
EQUIVALENT
BEHAVIOR
TO
EVALUATE
WRITE
AN
ITERABLE
STACK
CLIENT
THAT
HAS
A
STATIC
METHOD
COPY
THAT
TAKES
A
STACK
OF
STRINGS
AS
ARGUMENT
AND
RETURNS
A
COPY
OF
THE
STACK
NOTE
THIS
ABILITY
IS
A
PRIME
EXAMPLE
OF
THE
VALUE
OF
HAVING
AN
ITERATOR
BECAUSE
IT
ALLOWS
DEVELOPMENT
OF
SUCH
FUNC
TIONALITY
WITHOUT
CHANGING
THE
BASIC
API
SUPPOSE
THAT
A
CLIENT
PERFORMS
AN
INTERMIXED
SEQUENCE
OF
QUEUE
ENQUEUE
AND
DEQUEUE
OPERATIONS
THE
ENQUEUE
OPERATIONS
PUT
THE
INTEGERS
THROUGH
IN
ORDER
ONTO
THE
QUEUE
THE
DEQUEUE
OPERATIONS
PRINT
OUT
THE
RETURN
VALUE
WHICH
OF
THE
FOLLOWING
SEQUENCE
COULD
NOT
OCCUR
A
B
C
D
DEVELOP
A
CLASS
RESIZINGARRAYQUEUEOFSTRINGS
THAT
IMPLEMENTS
THE
QUEUE
ABSTRACTION
WITH
A
FIXED
SIZE
ARRAY
AND
THEN
EXTEND
YOUR
IMPLEMENTATION
TO
USE
ARRAY
RESIZING
TO
REMOVE
THE
SIZE
RESTRICTION
WRITE
A
QUEUE
CLIENT
THAT
TAKES
A
COMMAND
LINE
ARGUMENT
K
AND
PRINTS
THE
KTH
FROM
THE
LAST
STRING
FOUND
ON
STANDARD
INPUT
ASSUMING
THAT
STANDARD
INPUT
HAS
K
OR
MORE
STRINGS
USING
READINTS
ONPAGE
ASAMODEL
WRITEASTATICMETHOD
READDATES
FOR
DATE
THAT
READS
DATES
FROM
STANDARD
INPUT
IN
THE
FORMAT
SPECIFIED
IN
THE
TABLE
ON
PAGE
AND
RETURNS
AN
ARRAY
CONTAINING
THEM
DO
EXERCISE
FOR
TRANSACTION
THIS
LIST
OF
EXERCISES
IS
INTENDED
TO
GIVE
YOU
EXPERIENCE
IN
WORKING
WITH
LINKED
LISTS
SUGGES
TION
MAKE
DRAWINGS
USING
THE
VISUAL
REPRESENTATION
DESCRIBED
IN
THE
TEXT
SUPPOSE
X
IS
A
LINKED
LIST
NODE
AND
NOT
THE
LAST
NODE
ON
THE
LIST
WHAT
IS
THE
EF
FECT
OF
THE
FOLLOWING
CODE
FRAGMENT
X
NEXT
X
NEXT
NEXT
ANSWER
DELETES
FROM
THE
LIST
THE
NODE
IMMEDIATELY
FOLLOWING
X
GIVE
A
CODE
FRAGMENT
THAT
REMOVES
THE
LAST
NODE
IN
A
LINKED
LIST
WHOSE
FIRST
NODE
IS
FIRST
WRITE
A
METHOD
DELETE
THAT
TAKES
AN
INT
ARGUMENT
K
AND
DELETES
THE
KTH
ELE
MENT
IN
A
LINKED
LIST
IF
IT
EXISTS
WRITE
A
METHOD
FIND
THAT
TAKES
A
LINKED
LIST
AND
A
STRING
KEY
AS
ARGUMENTS
AND
RETURNS
TRUE
IF
SOME
NODE
IN
THE
LIST
HAS
KEY
AS
ITS
ITEM
FIELD
FALSE
OTHERWISE
SUPPOSE
THAT
X
IS
A
LINKED
LIST
NODE
WHAT
DOES
THE
FOLLOWING
CODE
FRAGMENT
DO
T
NEXT
X
NEXT
X
NEXT
T
ANSWER
INSERTS
NODE
T
IMMEDIATELY
AFTER
NODE
X
WHY
DOES
THE
FOLLOWING
CODE
FRAGMENT
NOT
DO
THE
SAME
THING
AS
IN
THE
PREVIOUS
QUESTION
X
NEXT
T
T
NEXT
X
NEXT
ANSWER
WHEN
IT
COMES
TIME
TO
UPDATE
T
NEXT
X
NEXT
IS
NO
LONGER
THE
ORIGINAL
NODE
FOLLOWING
X
BUT
IS
INSTEAD
T
ITSELF
WRITE
A
METHOD
REMOVEAFTER
THAT
TAKES
A
LINKED
LIST
NODE
AS
ARGUMENT
AND
REMOVES
THE
NODE
FOLLOWING
THE
GIVEN
ONE
AND
DOES
NOTHING
IF
THE
ARGUMENT
OR
THE
NEXT
FIELD
IN
THE
ARGUMENT
NODE
IS
NULL
WRITE
A
METHOD
INSERTAFTER
THAT
TAKES
TWO
LINKED
LIST
NODE
ARGUMENTS
AND
INSERTS
THE
SECOND
AFTER
THE
FIRST
ON
ITS
LIST
AND
DOES
NOTHING
IF
EITHER
ARGUMENT
IS
NULL
WRITE
A
METHOD
REMOVE
THAT
TAKES
A
LINKED
LIST
AND
A
STRING
KEY
AS
ARGUMENTS
AND
REMOVES
ALL
OF
THE
NODES
IN
THE
LIST
THAT
HAVE
KEY
AS
ITS
ITEM
FIELD
WRITE
A
METHOD
MAX
THAT
TAKES
A
REFERENCE
TO
THE
FIRST
NODE
IN
A
LINKED
LIST
AS
ARGUMENT
AND
RETURNS
THE
VALUE
OF
THE
MAXIMUM
KEY
IN
THE
LIST
ASSUME
THAT
ALL
KEYS
ARE
POSITIVE
INTEGERS
AND
RETURN
IF
THE
LIST
IS
EMPTY
DEVELOP
A
RECURSIVE
SOLUTION
TO
THE
PREVIOUS
QUESTION
WRITE
A
QUEUE
IMPLEMENTATION
THAT
USES
A
CIRCULAR
LINKED
LIST
WHICH
IS
THE
SAME
AS
A
LINKED
LIST
EXCEPT
THAT
NO
LINKS
ARE
NULL
AND
THE
VALUE
OF
LAST
NEXT
IS
FIRST
WHEN
EVER
THE
LIST
IS
NOT
EMPTY
KEEP
ONLY
ONE
NODE
INSTANCE
VARIABLE
LAST
WRITE
A
FUNCTION
THAT
TAKES
THE
FIRST
NODE
IN
A
LINKED
LIST
AS
ARGUMENT
AND
DE
STRUCTIVELY
REVERSES
THE
LIST
RETURNING
THE
FIRST
NODE
IN
THE
RESULT
ITERATIVE
SOLUTION
TO
ACCOMPLISH
THIS
TASK
WE
MAINTAIN
REFERENCES
TO
THREE
CONSECUTIVE
NODES
IN
THE
LINKED
LIST
REVERSE
FIRST
AND
SECOND
AT
EACH
ITERATION
WE
EXTRACT
THE
NODE
FIRST
FROM
THE
ORIGINAL
LINKED
LIST
AND
INSERT
IT
AT
THE
BEGINNING
OF
THE
REVERSED
LIST
WE
MAINTAIN
THE
INVARIANT
THAT
FIRST
IS
THE
FIRST
NODE
OF
WHAT
LEFT
OF
THE
ORIGINAL
LIST
SECOND
IS
THE
SECOND
NODE
OF
WHAT
LEFT
OF
THE
ORIGINAL
LIST
AND
REVERSE
IS
THE
FIRST
NODE
OF
THE
RESULTING
REVERSED
LIST
PUBLIC
NODE
REVERSE
NODE
X
NODE
FIRST
X
NODE
REVERSE
NULL
WHILE
FIRST
NULL
NODE
SECOND
FIRST
NEXT
FIRST
NEXT
REVERSE
REVERSE
FIRST
FIRST
SECOND
RETURN
REVERSE
WHEN
WRITING
CODE
INVOLVING
LINKED
LISTS
WE
MUST
ALWAYS
BE
CAREFUL
TO
PROPERLY
HANDLE
THE
EXCEPTIONAL
CASES
WHEN
THE
LINKED
LIST
IS
EMPTY
WHEN
THE
LIST
HAS
ONLY
ONE
OR
TWO
LINKED
LIST
EXERCISES
CONTINUED
NODES
AND
THE
BOUNDARY
CASES
DEALING
WITH
THE
FIRST
OR
LAST
ITEMS
THIS
IS
USUALLY
MUCH
TRICKIER
THAN
HANDLING
THE
NORMAL
CASES
RECURSIVE
SOLUTION
ASSUMING
THE
LINKED
LIST
HAS
N
NODES
WE
RECURSIVELY
REVERSE
THE
LAST
N
NODES
AND
THEN
CAREFULLY
APPEND
THE
FIRST
NODE
TO
THE
END
PUBLIC
NODE
REVERSE
NODE
FIRST
IF
FIRST
NULL
RETURN
NULL
IF
FIRST
NEXT
NULL
RETURN
FIRST
NODE
SECOND
FIRST
NEXT
NODE
REST
REVERSE
SECOND
SECOND
NEXT
FIRST
FIRST
NEXT
NULL
RETURN
REST
IMPLEMENT
A
NESTED
CLASS
DOUBLENODE
FOR
BUILDING
DOUBLY
LINKED
LISTS
WHERE
EACH
NODE
CONTAINS
A
REFERENCE
TO
THE
ITEM
PRECEDING
IT
AND
THE
ITEM
FOLLOWING
IT
IN
THE
LIST
NULL
IF
THERE
IS
NO
SUCH
ITEM
THEN
IMPLEMENT
STATIC
METHODS
FOR
THE
FOLLOWING
TASKS
INSERT
AT
THE
BEGINNING
INSERT
AT
THE
END
REMOVE
FROM
THE
BEGINNING
REMOVE
FROM
THE
END
INSERT
BEFORE
A
GIVEN
NODE
INSERT
AFTER
A
GIVEN
NODE
AND
REMOVE
A
GIVEN
NODE
STEQUE
A
STACK
ENDED
QUEUE
OR
STEQUE
IS
A
DATA
TYPE
THAT
SUPPORTS
PUSH
POP
AND
ENQUEUE
ARTICULATE
AN
API
FOR
THIS
ADT
DEVELOP
A
LINKED
LIST
BASED
IMPLEMENTATION
DEQUE
A
DOUBLE
ENDED
QUEUE
OR
DEQUE
PRONOUNCED
DECK
IS
LIKE
A
STACK
OR
A
QUEUE
BUT
SUPPORTS
ADDING
AND
REMOVING
ITEMS
AT
BOTH
ENDS
A
DEQUE
STORES
A
COLLEC
TION
OF
ITEMS
AND
SUPPORTS
THE
FOLLOWING
API
PUBLIC
CLASS
DEQUE
ITEM
IMPLEMENTS
ITERABLE
ITEM
DEQUE
CREATE
AN
EMPTY
DEQUE
BOOLEAN
ISEMPTY
IS
THE
DEQUE
EMPTY
INT
SIZE
NUMBER
OF
ITEMS
IN
THE
DEQUE
VOID
PUSHLEFT
ITEM
ITEM
ADD
AN
ITEM
TO
THE
LEFT
END
VOID
PUSHRIGHT
ITEM
ITEM
ADD
AN
ITEM
TO
THE
RIGHT
END
ITEM
POPLEFT
REMOVE
AN
ITEM
FROM
THE
LEFT
END
ITEM
POPRIGHT
REMOVE
AN
ITEM
FROM
THE
RIGHT
END
API
FOR
A
GENERIC
DOUBLE
ENDED
QUEUE
WRITE
A
CLASS
DEQUE
THAT
USES
A
DOUBLY
LINKED
LIST
TO
IMPLEMENT
THIS
API
AND
A
CLASS
RESIZINGARRAYDEQUE
THAT
USES
A
RESIZING
ARRAY
RANDOM
BAG
A
RANDOM
BAG
STORES
A
COLLECTION
OF
ITEMS
AND
SUPPORTS
THE
FOL
LOWING
API
PUBLIC
CLASS
RANDOMBAG
ITEM
IMPLEMENTS
ITERABLE
ITEM
RANDOMBAG
CREATE
AN
EMPTY
RANDOM
BAG
BOOLEAN
ISEMPTY
IS
THE
BAG
EMPTY
INT
SIZE
NUMBER
OF
ITEMS
IN
THE
BAG
VOID
ADD
ITEM
ITEM
ADD
AN
ITEM
API
FOR
A
GENERIC
RANDOM
BAG
WRITE
A
CLASS
RANDOMBAG
THAT
IMPLEMENTS
THIS
API
NOTE
THAT
THIS
API
IS
THE
SAME
AS
FOR
BAG
EXCEPT
FOR
THE
ADJECTIVE
RANDOM
WHICH
INDICATES
THAT
THE
ITERATION
SHOULD
PROVIDE
CREATIVE
PROBLEMS
CONTINUED
THE
ITEMS
IN
RANDOM
ORDER
ALL
N
PERMUTATIONS
EQUALLY
LIKELY
FOR
EACH
ITERATOR
HINT
PUT
THE
ITEMS
IN
AN
ARRAY
AND
RANDOMIZE
THEIR
ORDER
IN
THE
ITERATOR
CONSTRUCTOR
RANDOM
QUEUE
A
RANDOM
QUEUE
STORES
A
COLLECTION
OF
ITEMS
AND
SUPPORTS
THE
FOLLOWING
API
PUBLIC
CLASS
RANDOMQUEUE
ITEM
RANDOMQUEUE
CREATE
AN
EMPTY
RANDOM
QUEUE
BOOLEAN
ISEMPTY
IS
THE
QUEUE
EMPTY
VOID
ENQUEUE
ITEM
ITEM
ADD
AN
ITEM
ITEM
DEQUEUE
REMOVE
AND
RETURN
A
RANDOM
ITEM
SAMPLE
WITHOUT
REPLACEMENT
ITEM
SAMPLE
RETURN
A
RANDOM
ITEM
BUT
DO
NOT
REMOVE
SAMPLE
WITH
REPLACEMENT
API
FOR
A
GENERIC
RANDOM
QUEUE
WRITE
A
CLASS
RANDOMQUEUE
THAT
IMPLEMENTS
THIS
API
HINT
USE
AN
ARRAY
REPRESENTATION
WITH
RESIZING
TO
REMOVE
AN
ITEM
SWAP
ONE
AT
A
RANDOM
POSITION
INDEXED
THROUGH
N
WITH
THE
ONE
AT
THE
LAST
POSITION
INDEX
N
THEN
DELETE
AND
RETURN
THE
LAST
OB
JECT
AS
IN
RESIZINGARRAYSTACK
WRITE
A
CLIENT
THAT
DEALS
BRIDGE
HANDS
CARDS
EACH
USING
RANDOMQUEUE
CARD
RANDOM
ITERATOR
WRITE
AN
ITERATOR
FOR
RANDOMQUEUE
ITEM
FROM
THE
PREVIOUS
EXERCISE
THAT
RETURNS
THE
ITEMS
IN
RANDOM
ORDER
JOSEPHUS
PROBLEM
IN
THE
JOSEPHUS
PROBLEM
FROM
ANTIQUITY
N
PEOPLE
ARE
IN
DIRE
STRAITS
AND
AGREE
TO
THE
FOLLOWING
STRATEGY
TO
REDUCE
THE
POPULATION
THEY
ARRANGE
THEM
SELVES
IN
A
CIRCLE
AT
POSITIONS
NUMBERED
FROM
TO
N
AND
PROCEED
AROUND
THE
CIRCLE
ELIMINATING
EVERY
MTH
PERSON
UNTIL
ONLY
ONE
PERSON
IS
LEFT
LEGEND
HAS
IT
THAT
JOSEPHUS
FIGURED
OUT
WHERE
TO
SIT
TO
AVOID
BEING
ELIMINATED
WRITE
A
QUEUE
CLIENT
JOSEPHUS
THAT
TAKES
N
AND
M
FROM
THE
COMMAND
LINE
AND
PRINTS
OUT
THE
ORDER
IN
WHICH
PEOPLE
ARE
ELIMINATED
AND
THUS
WOULD
SHOW
JOSEPHUS
WHERE
TO
SIT
IN
THE
CIRCLE
JAVA
JOSEPHUS
DELETE
KTH
ELEMENT
IMPLEMENT
A
CLASS
THAT
SUPPORTS
THE
FOLLOWING
API
PUBLIC
CLASS
GENERALIZEDQUEUE
ITEM
GENERALIZEDQUEUE
CREATE
AN
EMPTY
QUEUE
BOOLEAN
ISEMPTY
IS
THE
QUEUE
EMPTY
VOID
INSERT
ITEM
X
ADD
AN
ITEM
ITEM
DELETE
INT
K
DELETE
AND
RETURN
THE
KTH
LEAST
RECENTLY
INSERTED
ITEM
API
FOR
A
GENERIC
GENERALIZED
QUEUE
FIRST
DEVELOP
AN
IMPLEMENTATION
THAT
USES
AN
ARRAY
IMPLEMENTATION
AND
THEN
DEVELOP
ONE
THAT
USES
A
LINKED
LIST
IMPLEMENTATION
NOTE
THE
ALGORITHMS
AND
DATA
STRUCTURES
THAT
WE
INTRODUCE
IN
CHAPTER
MAKE
IT
POSSIBLE
TO
DEVELOP
AN
IMPLEMENTATION
THAT
CAN
GUARANTEE
THAT
BOTH
INSERT
AND
DELETE
TAKE
TIME
PRORTIONAL
TO
THE
LOGARITHM
OF
THE
NUMBER
OF
ITEMS
IN
THE
QUEUE
SEE
EXERCISE
RING
BUFFER
A
RING
BUFFER
OR
CIRCULAR
QUEUE
IS
A
FIFO
DATA
STRUCTURE
OF
A
FIXED
SIZE
N
IT
IS
USEFUL
FOR
TRANSFERRING
DATA
BETWEEN
ASYNCHRONOUS
PROCESSES
OR
FOR
STORING
LOG
FILES
WHEN
THE
BUFFER
IS
EMPTY
THE
CONSUMER
WAITS
UNTIL
DATA
IS
DEPOSITED
WHEN
THE
BUFFER
IS
FULL
THE
PRODUCER
WAITS
TO
DEPOSIT
DATA
DEVELOP
AN
API
FOR
A
RINGBUFFER
AND
AN
IMPLEMENTATION
THAT
USES
AN
ARRAY
REPRESENTATION
WITH
CIRCULAR
WRAP
AROUND
MOVE
TO
FRONT
READ
IN
A
SEQUENCE
OF
CHARACTERS
FROM
STANDARD
INPUT
AND
MAINTAIN
THE
CHARACTERS
IN
A
LINKED
LIST
WITH
NO
DUPLICATES
WHEN
YOU
READ
IN
A
PREVI
OUSLY
UNSEEN
CHARACTER
INSERT
IT
AT
THE
FRONT
OF
THE
LIST
WHEN
YOU
READ
IN
A
DUPLICATE
CHARACTER
DELETE
IT
FROM
THE
LIST
AND
REINSERT
IT
AT
THE
BEGINNING
NAME
YOUR
PROGRAM
MOVETOFRONT
IT
IMPLEMENTS
THE
WELL
KNOWN
MOVE
TO
FRONT
STRATEGY
WHICH
IS
USEFUL
FOR
CACHING
DATA
COMPRESSION
AND
MANY
OTHER
APPLICATIONS
WHERE
ITEMS
THAT
HAVE
BEEN
RECENTLY
ACCESSED
ARE
MORE
LIKELY
TO
BE
REACCESSED
COPY
A
QUEUE
CREATE
A
NEW
CONSTRUCTOR
SO
THAT
QUEUE
ITEM
R
NEW
QUEUE
ITEM
Q
MAKES
R
A
REFERENCE
TO
A
NEW
AND
INDEPENDENT
COPY
OF
THE
QUEUE
Q
YOU
SHOULD
BE
ABLE
TO
PUSH
AND
POP
FROM
EITHER
Q
OR
R
WITHOUT
INFLUENCING
THE
OTHER
HINT
DELETE
ALL
OF
THE
ELEMENTS
FROM
Q
AND
ADD
THESE
ELEMENTS
TO
BOTH
Q
AND
R
CREATIVE
PROBLEMS
CONTINUED
COPY
A
STACK
CREATE
A
NEW
CONSTRUCTOR
FOR
THE
LINKED
LIST
IMPLEMENTATION
OF
STACK
SO
THAT
STACK
ITEM
T
NEW
STACK
ITEM
MAKES
T
A
REFERENCE
TO
A
NEW
AND
INDEPENDENT
COPY
OF
THE
STACK
LISTING
FILES
A
FOLDER
IS
A
LIST
OF
FILES
AND
FOLDERS
WRITE
A
PROGRAM
THAT
TAKES
THE
NAME
OF
A
FOLDER
AS
A
COMMAND
LINE
ARGUMENT
AND
PRINTS
OUT
ALL
OF
THE
FILES
CONTAINED
IN
THAT
FOLDER
WITH
THE
CONTENTS
OF
EACH
FOLDER
RECURSIVELY
LISTED
INDENTED
UNDER
THAT
FOLDER
NAME
HINT
USE
A
QUEUE
AND
SEE
JAVA
IO
FILE
TEXT
EDITOR
BUFFER
DEVELOP
A
DATA
TYPE
FOR
A
BUFFER
IN
A
TEXT
EDITOR
THAT
IMPLE
MENTS
THE
FOLLOWING
API
PUBLIC
CLASS
BUFFER
BUFFER
CREATE
AN
EMPTY
BUFFER
VOID
INSERT
CHAR
C
INSERT
C
AT
THE
CURSOR
POSITION
CHAR
DELETE
DELETE
AND
RETURN
THE
CHARACTER
AT
THE
CURSOR
VOID
LEFT
INT
K
MOVE
THE
CURSOR
K
POSITIONS
TO
THE
LEFT
VOID
RIGHT
INT
K
MOVE
THE
CURSOR
K
POSITIONS
TO
THE
RIGHT
INT
SIZE
NUMBER
OF
CHARACTERS
IN
THE
BUFFER
API
FOR
A
TEXT
BUFFER
HINT
USE
TWO
STACKS
STACK
GENERABILITY
SUPPOSE
THAT
WE
HAVE
A
SEQUENCE
OF
INTERMIXED
PUSH
AND
POP
OPERATIONS
AS
WITH
OUR
TEST
STACK
CLIENT
WHERE
THE
INTEGERS
N
IN
THAT
ORDER
PUSH
DIRECTIVES
ARE
INTERMIXED
WITH
N
MINUS
SIGNS
POP
DIRECTIVES
DEVISE
AN
ALGORITHM
THAT
DETERMINES
WHETHER
THE
INTERMIXED
SEQUENCE
CAUSES
THE
STACK
TO
UNDER
FLOW
YOU
MAY
USE
ONLY
AN
AMOUNT
OF
SPACE
INDEPENDENT
OF
N
YOU
CANNOT
STORE
THE
INTEGERS
IN
A
DATA
STRUCTURE
DEVISE
A
LINEAR
TIME
ALGORITHM
THAT
DETERMINES
WHETHER
A
GIVEN
PERMUTATION
CAN
BE
GENERATED
AS
OUTPUT
BY
OUR
TEST
CLIENT
DEPENDING
ON
WHERE
THE
POP
DIRECTIVES
OCCUR
SOLUTION
THE
STACK
DOES
NOT
OVERFLOW
UNLESS
THERE
EXISTS
AN
INTEGER
K
SUCH
THAT
THE
FIRST
K
POP
OPERATIONS
OCCUR
BEFORE
THE
FIRST
K
PUSH
OPERATIONS
IF
A
GIVEN
PERMUTATION
CAN
BE
GENERATED
IT
IS
UNIQUELY
GENERATED
AS
FOLLOWS
IF
THE
NEXT
INTEGER
IN
THE
OUTPUT
PERMUTA
TION
IS
IN
THE
TOP
OF
THE
STACK
POP
IT
OTHERWISE
PUSH
IT
ONTO
THE
STACK
FORBIDDEN
TRIPLE
FOR
STACK
GENERABILITY
PROVE
THAT
A
PERMUTATION
CAN
BE
GENER
ATED
BY
A
STACK
AS
IN
THE
PREVIOUS
QUESTION
IF
AND
ONLY
IF
IT
HAS
NO
FORBIDDEN
TRIPLE
A
B
C
SUCH
THAT
A
B
C
WITH
C
FIRST
A
SECOND
AND
B
THIRD
POSSIBLY
WITH
OTHER
INTERVENING
INTEGERS
BETWEEN
C
AND
A
AND
BETWEEN
A
AND
B
PARTIAL
SOLUTION
SUPPOSE
THAT
THERE
IS
A
FORBIDDEN
TRIPLE
A
B
C
ITEM
C
IS
POPPED
BEFORE
A
AND
B
BUT
A
AND
B
ARE
PUSHED
BEFORE
C
THUS
WHEN
C
IS
PUSHED
BOTH
A
AND
B
ARE
ON
THE
STACK
THEREFORE
A
CANNOT
BE
POPPED
BEFORE
B
CATENABLE
QUEUES
STACKS
OR
STEQUES
ADD
AN
EXTRA
OPERATION
CATENATION
THAT
DE
STRUCTIVELY
CONCATENATES
TWO
QUEUES
STACKS
OR
STEQUES
SEE
EXERCISE
HINT
USE
A
CIRCULAR
LINKED
LIST
MAINTAINING
A
POINTER
TO
THE
LAST
ITEM
TWO
STACKS
WITH
A
DEQUE
IMPLEMENT
TWO
STACKS
WITH
A
SINGLE
DEQUE
SO
THAT
EACH
OPERATION
TAKES
A
CONSTANT
NUMBER
OF
DEQUE
OPERATIONS
SEE
EXERCISE
QUEUE
WITH
THREE
STACKS
IMPLEMENT
A
QUEUE
WITH
THREE
STACKS
SO
THAT
EACH
QUEUE
OPERATION
TAKES
A
CONSTANT
WORST
CASE
NUMBER
OF
STACK
OPERATIONS
WARNING
HIGH
DEGREE
OF
DIFFICULTY
FAIL
FAST
ITERATOR
MODIFY
THE
ITERATOR
CODE
IN
STACK
TO
IMMEDIATELY
THROW
A
JAVA
UTIL
CONCURRENTMODIFICATIONEXCEPTION
IF
THE
CLIENT
MODIFIES
THE
COLLECTION
VIA
PUSH
OR
POP
DURING
ITERATION
B
SOLUTION
MAINTAIN
A
COUNTER
THAT
COUNTS
THE
NUMBER
OF
PUSH
AND
POP
OPERATIONS
WHEN
CREATING
AN
ITERATOR
STORE
THIS
VALUE
AS
AN
ITERATOR
INSTANCE
VARIABLE
BEFORE
EACH
CALL
TO
HASNEXT
AND
NEXT
CHECK
THAT
THIS
VALUE
HAS
NOT
CHANGED
SINCE
CON
STRUCTION
OF
THE
ITERATOR
IF
IT
HAS
THROW
THE
EXCEPTION
AS
PEOPLE
GAIN
EXPERIENCE
USING
COMPUTERS
THEY
USE
THEM
TO
SOLVE
DIFFICULT
PROB
LEMS
OR
TO
PROCESS
LARGE
AMOUNTS
OF
DATA
AND
ARE
INVARIABLY
LED
TO
QUESTIONS
LIKE
THESE
HOW
LONG
WILL
MY
PROGRAM
TAKE
WHY
DOES
MY
PROGRAM
RUN
OUT
OF
MEMORY
YOU
CERTAINLY
HAVE
ASKED
YOURSELF
THESE
QUESTIONS
PERHAPS
WHEN
REBUILDING
A
MUSIC
OR
PHOTO
LIBRARY
INSTALLING
A
NEW
APPLICATION
WORKING
WITH
A
LARGE
DOCUMENT
OR
WORK
ING
WITH
A
LARGE
AMOUNT
OF
EXPERIMENTAL
DATA
THE
QUESTIONS
ARE
MUCH
TOO
VAGUE
TO
BE
ANSWERED
PRECISELY
THE
ANSWERS
DEPEND
ON
MANY
FACTORS
SUCH
AS
PROPERTIES
OF
THE
PARTICULAR
COMPUTER
BEING
USED
THE
PARTICULAR
DATA
BEING
PROCESSED
AND
THE
PARTICULAR
PROGRAM
THAT
IS
DOING
THE
JOB
WHICH
IMPLEMENTS
SOME
ALGORITHM
ALL
OF
THESE
FACTORS
LEAVE
US
WITH
A
DAUNTING
AMOUNT
OF
INFORMATION
TO
ANALYZE
DESPITE
THESE
CHALLENGES
THE
PATH
TO
DEVELOPING
USEFUL
ANSWERS
TO
THESE
BASIC
QUES
TIONS
IS
OFTEN
REMARKABLY
STRAIGHTFORWARD
AS
YOU
WILL
SEE
IN
THIS
SECTION
THIS
PROCESS
IS
BASED
ON
THE
SCIENTIFIC
METHOD
THE
COMMONLY
ACCEPTED
BODY
OF
TECHNIQUES
USED
BY
SCI
ENTISTS
TO
DEVELOP
KNOWLEDGE
ABOUT
THE
NATURAL
WORLD
WE
APPLY
MATHEMATICAL
ANALYSIS
TO
DEVELOP
CONCISE
MODELS
OF
COSTS
AND
DO
EXPERIMENTAL
STUDIES
TO
VALIDATE
THESE
MODELS
SCIENTIFIC
METHOD
THE
VERY
SAME
APPROACH
THAT
SCIENTISTS
USE
TO
UNDERSTAND
THE
NATURAL
WORLD
IS
EFFECTIVE
FOR
STUDYING
THE
RUNNING
TIME
OF
PROGRAMS
OBSERVE
SOME
FEATURE
OF
THE
NATURAL
WORLD
GENERALLY
WITH
PRECISE
MEASUREMENTS
HYPOTHESIZE
A
MODEL
THAT
IS
CONSISTENT
WITH
THE
OBSERVATIONS
PREDICT
EVENTS
USING
THE
HYPOTHESIS
VERIFY
THE
PREDICTIONS
BY
MAKING
FURTHER
OBSERVATIONS
VALIDATE
BY
REPEATING
UNTIL
THE
HYPOTHESIS
AND
OBSERVATIONS
AGREE
ONE
OF
THE
KEY
TENETS
OF
THE
SCIENTIFIC
METHOD
IS
THAT
THE
EXPERIMENTS
WE
DESIGN
MUST
BE
REPRODUCIBLE
SO
THAT
OTHERS
CAN
CONVINCE
THEMSELVES
OF
THE
VALIDITY
OF
THE
HYPOTHESIS
HYPOTHESES
MUST
ALSO
BE
FALSIFIABLE
SO
THAT
WE
CAN
KNOW
FOR
SURE
WHEN
A
GIVEN
HYPOTH
ESIS
IS
WRONG
AND
THUS
NEEDS
REVISION
AS
EINSTEIN
FAMOUSLY
IS
REPORTED
TO
HAVE
SAID
NO
AMOUNT
OF
EXPERIMENTATION
CAN
EVER
PROVE
ME
RIGHT
A
SINGLE
EXPERIMENT
CAN
PROVE
ME
WRONG
WE
CAN
NEVER
KNOW
FOR
SURE
THAT
ANY
HYPOTHESIS
IS
ABSOLUTELY
CORRECT
WE
CAN
ONLY
VALIDATE
THAT
IT
IS
CONSISTENT
WITH
OUR
OBSERVATIONS
OBSERVATIONS
OUR
FIRST
CHALLENGE
IS
TO
DETERMINE
HOW
TO
MAKE
QUANTITATIVE
MEA
SUREMENTS
OF
THE
RUNNING
TIME
OF
OUR
PROGRAMS
THIS
TASK
IS
FAR
EASIER
THAN
IN
THE
NATU
RAL
SCIENCES
WE
DO
NOT
HAVE
TO
SEND
A
ROCKET
TO
MARS
OR
KILL
LABORATORY
ANIMALS
OR
SPLIT
AN
ATOM
WE
CAN
SIMPLY
RUN
THE
PROGRAM
INDEED
EVERY
TIME
YOU
RUN
A
PROGRAM
YOU
ARE
PERFORMING
A
SCIENTIFIC
EXPERIMENT
THAT
RELATES
THE
PROGRAM
TO
THE
NATURAL
WORLD
AND
ANSWERS
ONE
OF
OUR
CORE
QUESTIONS
HOW
LONG
WILL
MY
PROGRAM
TAKE
OUR
FIRST
QUALITATIVE
OBSERVATION
ABOUT
MOST
PROGRAMS
IS
THAT
THERE
IS
A
PROBLEM
SIZE
THAT
CHARACTERIZES
THE
DIFFICULTY
OF
THE
COMPUTATIONAL
TASK
NORMALLY
THE
PROBLEM
SIZE
IS
EITHER
THE
SIZE
OF
THE
INPUT
OR
THE
VALUE
OF
A
COMMAND
LINE
ARGUMENT
INTUITIVELY
THE
RUNNING
TIME
SHOULD
INCREASE
WITH
PROBLEM
SIZE
BUT
THE
QUESTION
OF
BY
HOW
MUCH
IT
INCREASES
NATURALLY
COMES
UP
EVERY
TIME
WE
DEVELOP
AND
RUN
A
PROGRAM
ANOTHER
QUALITATIVE
OBSERVATION
FOR
MANY
PROGRAMS
IS
THAT
THE
RUNNING
TIME
IS
RELA
TIVELY
INSENSITIVE
TO
THE
INPUT
ITSELF
IT
DEPENDS
PRIMARILY
ON
THE
PROBLEM
SIZE
IF
THIS
RELATIONSHIP
DOES
NOT
HOLD
WE
NEED
TO
TAKE
STEPS
TO
BETTER
UNDERSTAND
AND
PERHAPS
BETTER
CONTROL
THE
RUNNING
TIME
SENSITIVITY
TO
THE
INPUT
BUT
IT
DOES
OFTEN
HOLD
SO
WE
NOW
FOCUS
ON
THE
GOAL
OF
BETTER
QUANTIFYING
THE
RELATIONSHIP
BETWEEN
PROBLEM
SIZE
AND
RUNNING
TIME
EXAMPLE
AS
A
RUNNING
EXAMPLE
WE
WILL
WORK
WITH
THE
PROGRAM
THREESUM
SHOWN
HERE
WHICH
COUNTS
THE
NUMBER
OF
TRIPLES
IN
A
FILE
OF
N
INTEGERS
THAT
SUM
TO
ASSUM
ING
THAT
OVERFLOW
PLAYS
NO
ROLE
THIS
COMPUTATION
MAY
SEEM
CONTRIVED
TO
YOU
BUT
IT
IS
DEEPLY
RELATED
TO
NUMEROUS
FUN
DAMENTAL
COMPUTATIONAL
TASKS
FOR
EXAM
PLE
SEE
EXERCISE
AS
A
TEST
INPUT
CONSIDER
THE
FILE
TXT
FROM
THE
BOOKSITE
WHICH
CONTAINS
MILLION
RAN
DOMLY
GENERATED
INT
VALUES
THE
SECOND
EIGHTH
AND
TENTH
ENTRIES
IN
TXT
SUM
TO
HOW
MANY
MORE
SUCH
TRIPLES
ARE
THERE
IN
THE
FILE
THREESUM
CAN
TELL
US
BUT
CAN
IT
DO
SO
IN
A
REASONABLE
AMOUNT
OF
TIME
WHAT
IS
THE
RELATIONSHIP
BETWEEN
THE
PROBLEM
SIZE
N
AND
RUNNING
TIME
FOR
THREESUM
AS
A
FIRST
EXPERIMENT
TRY
RUNNING
THREESUM
ON
YOUR
COMPUTER
FOR
THE
FILES
TXT
TXT
TXT
AND
TXT
ON
THE
BOOKSITE
THAT
CONTAIN
THE
FIRST
AND
INTEGERS
FROM
TXT
RESPECTIVELY
YOU
CAN
QUICKLY
DETERMINE
THAT
THERE
ARE
TRIPLES
THAT
SUM
TO
IN
TXT
AND
THAT
THERE
ARE
TRIPLES
THAT
SUM
TO
IN
TXT
THE
PROGRAM
TAKES
SUBSTANTIALLY
MORE
TIME
TO
DETERMINE
THAT
THERE
ARE
TRIPLES
THAT
SUM
TO
IN
TXT
AND
AS
YOU
WAIT
FOR
THE
PROGRAM
TO
FINISH
FOR
TXT
YOU
WILL
FIND
YOURSELF
ASKING
THE
QUESTION
HOW
LONG
WILL
MY
PROGRAM
TAKE
AS
YOU
WILL
SEE
ANSWERING
THIS
QUESTION
FOR
THIS
PROGRAM
TURNS
OUT
TO
BE
EASY
IN
DEED
YOU
CAN
OFTEN
COME
UP
WITH
A
FAIRLY
ACCURATE
PREDICTION
WHILE
THE
PROGRAM
IS
RUNNING
STOPWATCH
RELIABLY
MEASURING
THE
EXACT
RUNNING
TIME
OF
A
GIVEN
PROGRAM
CAN
BE
DIFFICULT
FORTU
NATELY
WE
ARE
USUALLY
HAPPY
WITH
ESTIMATES
WE
WANT
TO
BE
ABLE
TO
DISTINGUISH
PROGRAMS
THAT
WILL
FINISH
IN
A
FEW
SECONDS
OR
A
FEW
MINUTES
FROM
THOSE
THAT
MIGHT
REQUIRE
A
FEW
DAYS
OR
A
FEW
MONTHS
OR
MORE
AND
WE
WANT
TO
KNOW
WHEN
ONE
PROGRAM
IS
TWICE
AS
FAST
AS
ANOTHER
FOR
THE
SAME
TASK
STILL
WE
NEED
ACCURATE
MEASUREMENTS
TO
GENERATE
EXPERIMENTAL
DATA
THAT
WE
CAN
USE
TO
FORMULATE
AND
TO
CHECK
THE
VALIDITY
OF
HYPOTHESES
ABOUT
THE
RELATIONSHIP
BETWEEN
RUNNING
TIME
AND
PROBLEM
SIZE
FOR
THIS
PURPOSE
WE
USE
THE
STOPWATCH
DATA
TYPE
SHOWN
ON
THE
FACING
PAGE
ITS
ELAPSEDTIME
METHOD
RETURNS
THE
ELAPSED
TIME
SINCE
IT
WAS
CREATED
IN
SECONDS
THE
IMPLEMENTATION
IS
BASED
ON
USING
THE
JAVA
SYSTEM
CURRENTTIMEMILLIS
METHOD
WHICH
GIVES
THE
CURRENT
TIME
IN
MILLISECONDS
TO
SAVE
THE
TIME
WHEN
THE
CONSTRUCTOR
IS
INVOKED
THEN
USES
IT
AGAIN
TO
COMPUTE
THE
ELAPSED
TIME
WHEN
ELAPSEDTIME
IS
INVOKED
JAVA
THREESUM
TXT
TICK
TICK
TICK
JAVA
THREESUM
TXT
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
JAVA
THREESUM
TXT
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
TICK
OBSERVING
THE
RUNNING
TIME
OF
A
PROGRAM
API
PUBLIC
CLASS
STOPWATCH
STOPWATCH
DOUBLE
ELAPSEDTIME
CREATE
A
STOPWATCH
RETURN
ELAPSED
TIME
SINCE
CREATION
TYPICAL
CLIENT
APPLICATION
IMPLEMENTATION
AN
ABSTRACT
DATA
TYPE
FOR
A
STOPWATCH
ANALYSIS
OF
EXPERIMENTAL
DATA
THE
PROGRAM
DOUBLINGTEST
ON
THE
FACING
PAGE
IS
A
MORE
SOPHISTICATED
STOPWATCH
CLIENT
THAT
PRODUCES
EXPERIMENTAL
DATA
FOR
THREESUM
IT
GENERATES
A
SEQUENCE
OF
RANDOM
INPUT
ARRAYS
DOUBLING
THE
ARRAY
SIZE
AT
EACH
STEP
AND
PRINTS
THE
RUNNING
TIMES
OF
THREESUM
COUNT
FOR
EACH
INPUT
SIZE
THESE
EXPERIMENTS
ARE
CERTAINLY
REPRODUCIBLE
YOU
CAN
ALSO
RUN
THEM
ON
YOUR
OWN
COMPUTER
AS
MANY
TIMES
AS
YOU
LIKE
WHEN
YOU
RUN
DOUBLINGTEST
YOU
WILL
FIND
YOURSELF
IN
A
PREDICTION
VERIFICATION
CYCLE
IT
PRINTS
SEVERAL
LINES
VERY
QUICKLY
BUT
THEN
SLOWS
DOWN
CONSIDERABLY
EACH
TIME
IT
PRINTS
A
LINE
YOU
FIND
YOURSELF
WONDERING
HOW
LONG
IT
WILL
BE
UNTIL
IT
PRINTS
THE
NEXT
LINE
OF
COURSE
SINCE
YOU
HAVE
A
DIFFERENT
COMPUTER
FROM
OURS
THE
ACTUAL
RUN
NING
TIMES
THAT
YOU
GET
ARE
LIKELY
TO
BE
DIFFERENT
FROM
THOSE
SHOWN
FOR
OUR
COMPUTER
INDEED
IF
YOUR
COMPUTER
IS
TWICE
AS
FAST
AS
OURS
YOUR
RUNNING
TIMES
WILL
BE
ABOUT
HALF
OURS
WHICH
LEADS
IMMEDIATELY
TO
THE
WELL
FOUNDED
HYPOTHESIS
THAT
RUNNING
TIMES
ON
DIFFERENT
COMPUTERS
ARE
LIKELY
TO
DIFFER
BY
A
CONSTANT
FACTOR
STILL
YOU
WILL
FIND
YOURSELF
ASKING
THE
MORE
DETAILED
QUESTION
HOW
LONG
WILL
MY
PROGRAM
TAKE
AS
A
FUNCTION
OF
THE
INPUT
SIZE
TO
HELP
ANSWER
THIS
QUESTION
WE
PLOT
THE
DATA
THE
DIAGRAMS
AT
THE
BOTTOM
OF
THE
FACING
PAGE
SHOW
THE
RESULT
OF
PLOTTING
THE
DATA
BOTH
ON
A
NORMAL
AND
ON
A
LOG
LOG
SCALE
WITH
THE
PROBLEM
SIZE
N
ON
THE
X
AXIS
AND
THE
RUNNING
TIME
T
N
ON
THE
Y
AXIS
THE
LOG
LOG
PLOT
IMMEDIATELY
LEADS
TO
A
HYPOTHESIS
ABOUT
THE
RUNNING
TIME
THE
DATA
FITS
A
STRAIGHT
LINE
OF
SLOPE
ON
THE
LOG
LOG
PLOT
THE
EQUATION
OF
SUCH
A
LINE
IS
LG
T
N
LG
N
LG
A
WHERE
A
IS
A
CONSTANT
WHICH
IS
EQUIVALENT
TO
T
N
A
N
THE
RUNNING
TIME
AS
A
FUNCTION
OF
THE
INPUT
SIZE
AS
DESIRED
WE
CAN
USE
ONE
OF
OUR
DATA
POINTS
TO
SOLVE
FOR
A
FOR
EXAMPLE
T
A
SO
A
AND
THEN
USE
THE
EQUATION
T
N
N
TO
PREDICT
RUNNING
TIMES
FOR
LARGE
N
INFORMALLY
WE
ARE
CHECKING
THE
HYPOTHESIS
THAT
THE
DATA
POINTS
ON
THE
LOG
LOG
PLOT
FALL
CLOSE
TO
THIS
LINE
STATISTICAL
METHODS
ARE
AVAILABLE
FOR
DOING
A
MORE
CAREFUL
ANALYSIS
TO
FIND
ESTIMATES
OF
A
AND
THE
EXPONENT
B
BUT
OUR
QUICK
CALCULATIONS
SUFFICE
TO
ESTIMATE
RUNNING
TIME
FOR
MOST
PURPOSES
FOR
EXAMPLE
WE
CAN
ESTIMATE
THE
RUNNING
TIME
ON
OUR
COMPUTER
FOR
N
TO
BE
ABOUT
SECONDS
OR
ABOUT
MINUTES
THE
ACTUAL
TIME
WAS
SECONDS
WHILE
WAITING
FOR
YOUR
COMPUTER
TO
PRINT
THE
LINE
FOR
N
IN
DOUBLINGTEST
YOU
MIGHT
USE
THIS
METHOD
TO
PREDICT
WHEN
IT
WILL
FINISH
THEN
CHECK
THE
RESULT
BY
WAITING
TO
SEE
IF
YOUR
PREDICTION
IS
TRUE
PROGRAM
TO
PERFORM
EXPERIMENTS
RESULTS
OF
EXPERIMENTS
PUBLIC
CLASS
DOUBLINGTEST
JAVA
DOUBLINGTEST
PUBLIC
STATIC
DOUBLE
TIMETRIAL
INT
N
TIME
THREESUM
COUNT
FOR
N
RANDOM
DIGIT
INTS
INT
MAX
INT
A
NEW
INT
N
FOR
INT
I
I
N
I
A
I
STDRANDOM
UNIFORM
MAX
MAX
STOPWATCH
TIMER
NEW
STOPWATCH
INT
CNT
THREESUM
COUNT
A
RETURN
TIMER
ELAPSEDTIME
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
PRINT
TABLE
OF
RUNNING
TIMES
FOR
INT
N
TRUE
N
N
PRINT
TIME
FOR
PROBLEM
SIZE
N
DOUBLE
TIME
TIMETRIAL
N
STDOUT
PRINTF
N
N
TIME
STANDARD
PLOT
LOG
LOG
PLOT
PROBLEM
SIZE
N
LG
N
ANALYSIS
OF
EXPERIMENTAL
DATA
THE
RUNNING
TIME
OF
THREESUM
COUNT
SO
FAR
THIS
PROCESS
MIRRORS
THE
PROCESS
SCIENTISTS
USE
WHEN
TRYING
TO
UNDERSTAND
PROPERTIES
OF
THE
REAL
WORLD
A
STRAIGHT
LINE
IN
A
LOG
LOG
PLOT
IS
EQUIVALENT
TO
THE
HY
POTHESIS
THAT
THE
DATA
FITS
THE
EQUATION
T
N
A
NB
SUCH
A
FIT
IS
KNOWN
AS
A
POWER
LAW
A
GREAT
MANY
NATURAL
AND
SYNTHETIC
PHENOMENA
ARE
DESCRIBED
BY
POWER
LAWS
AND
IT
IS
REASONABLE
TO
HYPOTHESIZE
THAT
THE
RUNNING
TIME
OF
A
PROGRAM
DOES
AS
WELL
INDEED
FOR
THE
ANALYSIS
OF
ALGORITHMS
WE
HAVE
MATHEMATICAL
MODELS
THAT
STRONGLY
SUPPORT
THIS
AND
SIMILAR
HYPOTHESES
TO
WHICH
WE
NOW
TURN
MATHEMATICAL
MODELS
IN
THE
EARLY
DAYS
OF
COMPUTER
SCIENCE
D
E
KNUTH
POSTU
LATED
THAT
DESPITE
ALL
OF
THE
COMPLICATING
FACTORS
IN
UNDERSTANDING
THE
RUNNING
TIMES
OF
OUR
PROGRAMS
IT
IS
POSSIBLE
IN
PRINCIPLE
TO
BUILD
A
MATHEMATICAL
MODEL
TO
DESCRIBE
THE
RUNNING
TIME
OF
ANY
PROGRAM
KNUTH
BASIC
INSIGHT
IS
SIMPLE
THE
TOTAL
RUNNING
TIME
OF
A
PROGRAM
IS
DETERMINED
BY
TWO
PRIMARY
FACTORS
THE
COST
OF
EXECUTING
EACH
STATEMENT
THE
FREQUENCY
OF
EXECUTION
OF
EACH
STATEMENT
THE
FORMER
IS
A
PROPERTY
OF
THE
COMPUTER
THE
JAVA
COMPILER
AND
THE
OPERATING
SYSTEM
THE
LATTER
IS
A
PROPERTY
OF
THE
PROGRAM
AND
THE
INPUT
IF
WE
KNOW
BOTH
FOR
ALL
INSTRUC
TIONS
IN
THE
PROGRAM
WE
CAN
MULTIPLY
THEM
TOGETHER
AND
SUM
FOR
ALL
INSTRUCTIONS
IN
THE
PROGRAM
TO
GET
THE
RUNNING
TIME
THE
PRIMARY
CHALLENGE
IS
TO
DETERMINE
THE
FREQUENCY
OF
EXECUTION
OF
THE
STATEMENTS
SOME
STATEMENTS
ARE
EASY
TO
ANALYZE
FOR
EXAMPLE
THE
STATEMENT
THAT
SETS
CNT
TO
IN
THREESUM
COUNT
IS
EXECUTED
EXACTLY
ONCE
OTHERS
REQUIRE
HIGHER
LEVEL
REASONING
FOR
EXAMPLE
THE
IF
STATEMENT
IN
THREESUM
COUNT
IS
EXECUTED
PRECISELY
N
N
N
TIMES
THE
NUMBER
OF
WAYS
TO
PICK
THREE
DIFFERENT
NUMBERS
FROM
THE
INPUT
ARRAY
SEE
EXERCISE
OTHERS
DEPEND
ON
THE
INPUT
DATA
FOR
EXAMPLE
THE
NUMBER
OF
TIMES
THE
INSTRUCTION
CNT
IN
THREESUM
COUNT
IS
EXECUTED
IS
PRECISELY
THE
NUMBER
OF
TRIPLES
THAT
SUM
TO
IN
THE
INPUT
WHICH
COULD
RANGE
FROM
OF
THEM
TO
ALL
OF
THEM
IN
THE
CASE
OF
DOUBLINGTEST
WHERE
WE
GENERATE
THE
NUMBERS
RANDOMLY
IT
IS
POSSIBLE
TO
DO
A
PROB
ABILISTIC
ANALYSIS
TO
DETERMINE
THE
EXPECTED
VALUE
OF
THIS
QUANTITY
SEE
EXERCISE
TILDE
APPROXIMATIONS
FREQUENCY
ANALYSES
OF
THIS
SORT
CAN
LEAD
TO
COMPLICATED
AND
LENGTHY
MATHEMATICAL
EXPRESSIONS
FOR
EXAMPLE
CONSIDER
THE
COUNT
JUST
CONSIDERED
OF
THE
NUMBER
OF
TIMES
THE
IF
STATEMENT
IN
THREESUM
IS
EXECUTED
N
N
N
N
N
N
AS
IS
TYPICAL
IN
SUCH
EXPRESSIONS
THE
TERMS
AFTER
THE
LEADING
TERM
ARE
RELATIVELY
SMALL
FOR
EXAM
PLE
WHEN
N
THE
VALUE
OF
N
N
IS
CERTAINLY
INSIGNIFICANT
BY
COM
PARISON
WITH
N
TO
ALLOW
US
TO
IGNORE
INSIGNIFICANT
TERMS
AND
THEREFORE
SUB
STANTIALLY
SIMPLIFY
THE
MATHEMATICAL
FORMULAS
THAT
WE
WORK
WITH
WE
OFTEN
USE
A
MATHEMATI
CAL
DEVICE
KNOWN
AS
THE
TILDE
NOTATION
THIS
N
N
NOTATION
ALLOWS
US
TO
WORK
WITH
TILDE
APPROXI
MATIONS
WHERE
WE
THROW
AWAY
LOW
ORDER
TERMS
THAT
COMPLICATE
FORMULAS
AND
REPRESENT
A
NEGLI
GIBLE
CONTRIBUTION
TO
VALUES
OF
INTEREST
LEADING
TERM
APPROXIMATION
FUNCTION
TILDE
ORDER
TYPICAL
TILDE
APPROXIMATIONS
ORDER
OF
GROWTH
DESCRIPTION
FUNCTION
CONSTANT
LOGARITHMIC
LOG
N
LINEAR
N
LINEARITHMIC
N
LOG
N
QUADRATIC
N
CUBIC
N
EXPONENTIAL
N
COMMONLY
ENCOUNTERED
ORDER
OF
GROWTH
FUNCTIONS
FOR
EXAMPLE
WE
USE
THE
APPROXIMATION
N
TO
DE
SCRIBE
THE
NUMBER
OF
TIMES
THE
IF
STATEMENT
IN
THREESUM
IS
EXECUTED
SINCE
N
N
N
DI
VIDED
BY
N
APPROACHES
AS
N
GROWS
MOST
OF
TEN
WE
WORK
WITH
TILDE
APPROXIMATIONS
OF
THE
FORM
G
N
AF
N
WHERE
F
N
NB
LOG
N
C
WITH
A
B
AND
C
CONSTANTS
AND
REFER
TO
F
N
AS
THE
ORDER
OF
GROWTH
OF
G
N
WHEN
USING
THE
LOGARITHM
IN
THE
ORDER
OF
GROWTH
WE
GENER
ALLY
DO
NOT
SPECIFY
THE
BASE
SINCE
THE
CONSTANT
A
CAN
ABSORB
THAT
DETAIL
THIS
USAGE
COVERS
THE
RELATIVELY
FEW
FUNCTIONS
THAT
ARE
COMMONLY
ENCOUNTERED
IN
STUDYING
THE
ORDER
OF
GROWTH
OF
A
PROGRAM
RUNNING
TIME
SHOWN
IN
THE
TABLE
AT
LEFT
WITH
THE
EXCEPTION
OF
THE
EXPONENTIAL
WHICH
WE
DEFER
TO
CONTEXT
WE
WILL
DESCRIBE
THESE
FUNCTIONS
IN
MORE
DE
TAIL
AND
BRIEFLY
DISCUSS
WHY
THEY
APPEAR
IN
THE
ANALYSIS
OF
ALGORITHMS
AFTER
WE
COMPLETE
OUR
TREATMENT
OF
THREESUM
APPROXIMATE
RUNNING
TIME
TO
FOLLOW
THROUGH
ON
KNUTH
APPROACH
TO
DEVELOP
A
MATHEMATICAL
EXPRESSION
FOR
THE
TOTAL
RUNNING
TIME
OF
A
JAVA
PROGRAM
WE
CAN
IN
PRIN
CIPLE
STUDY
OUR
JAVA
COMPILER
TO
FIND
THE
NUMBER
OF
MACHINE
INSTRUCTIONS
CORRESPOND
ING
TO
EACH
JAVA
INSTRUCTION
AND
STUDY
OUR
MACHINE
SPECIFICATIONS
TO
FIND
THE
TIME
OF
EXECUTION
OF
EACH
OF
THE
MACHINE
INSTRUCTIONS
TO
PRODUCE
A
GRAND
TOTAL
THIS
PROCESS
FOR
THREESUM
IS
BRIEFLY
SUMMARIZED
ON
THE
FACING
PAGE
WE
CLASSIFY
BLOCKS
OF
JAVA
STATE
MENTS
BY
THEIR
FREQUENCY
OF
EXECUTION
DEVELOP
LEADING
TERM
APPROXIMATIONS
FOR
THE
FREQUENCIES
DETERMINE
THE
COST
OF
EACH
STATEMENT
AND
THEN
COMPUTE
A
TOTAL
NOTE
THAT
SOME
FREQUENCIES
MAY
DEPEND
ON
THE
INPUT
IN
THIS
CASE
THE
NUMBER
OF
TIMES
CNT
IS
EXECUTED
CERTAINLY
DEPENDS
ON
THE
INPUT
IT
IS
THE
NUMBER
OF
TRIPLES
THAT
SUM
TO
AND
COULD
RANGE
FROM
TO
N
WE
STOP
SHORT
OF
EXHIBITING
THE
DETAILS
VALUES
OF
THE
CONSTANTS
FOR
ANY
PARTICULAR
SYSTEM
EXCEPT
TO
HIGHLIGHT
THAT
BY
USING
CONSTANT
VALUES
FOR
THE
TIME
TAKEN
BY
THE
BLOCKS
OF
STATEMENTS
WE
ARE
ASSUMING
THAT
EACH
BLOCK
OF
JAVA
STATEMENTS
CORRESPONDS
TO
MACHINE
INSTRUCTIONS
THAT
REQUIRE
A
SPECIFIED
FIXED
AMOUNT
OF
TIME
A
KEY
OBSERVATION
FROM
THIS
EXERCISE
IS
TO
NOTE
THAT
ONLY
THE
INSTRUC
TIONS
THAT
ARE
EXECUTED
THE
MOST
FREQUENTLY
PLAY
A
ROLE
IN
THE
FINAL
TOTAL
WE
REFER
TO
THESE
INSTRUCTIONS
AS
THE
INNER
LOOP
OF
THE
PROGRAM
FOR
THREESUM
THE
INNER
LOOP
IS
THE
STATEMENTS
THAT
INCREMENT
K
AND
TEST
THAT
IT
IS
LESS
THAN
N
AND
THE
STATEMENTS
THAT
TEST
WHETHER
THE
SUM
OF
THREE
GIVEN
NUMBERS
IS
AND
POSSIBLY
THE
STATEMENT
THAT
IMPLE
MENTS
THE
COUNT
DEPENDING
ON
THE
INPUT
THIS
BEHAVIOR
IS
TYPICAL
THE
RUNNING
TIMES
OF
A
GREAT
MANY
PROGRAMS
DEPEND
ONLY
ON
A
SMALL
SUBSET
OF
THEIR
INSTRUCTIONS
ORDER
OF
GROWTH
HYPOTHESIS
IN
SUMMARY
THE
EXPERIMENTS
ON
PAGE
AND
THE
MATH
EMATICAL
MODEL
ON
PAGE
BOTH
SUPPORT
THE
FOLLOWING
HYPOTHESIS
THROUGHOUT
THIS
BOOK
WE
USE
THE
TERM
PROPERTY
TO
REFER
TO
A
HYPOTHESIS
THAT
NEEDS
TO
BE
VALIDATED
THROUGH
EXPERIMENTATION
THE
END
RESULT
OF
OUR
MATHEMATICAL
ANALYSIS
IS
PRECISELY
THE
SAME
AS
THE
END
RESULT
OF
OUR
EXPERIMENTAL
ANALYSIS
THE
RUNNING
TIME
OF
THREESUM
IS
A
N
FOR
A
MACHINE
DEPENDENT
CONSTANT
A
THIS
MATCH
VALIDATES
BOTH
THE
EXPERIMENTS
AND
THE
MATHEMATICAL
MODEL
AND
ALSO
EXHIBITS
MORE
INSIGHT
ABOUT
THE
PUBLIC
CLASS
THREESUM
PUBLIC
STATIC
INT
COUNT
INT
A
A
INT
N
A
LENGTH
INT
CNT
FOR
INT
I
I
N
I
B
FOR
INT
J
I
J
N
J
C
FOR
INT
K
J
K
N
K
D
IF
A
I
A
J
A
K
E
RETURN
CNT
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
A
IN
READINTS
ARGS
STDOUT
PRINTLN
COUNT
A
N
N
N
X
INNER
LOOP
ANATOMY
OF
A
PROGRAM
STATEMENT
EXECUTION
FREQUENCIES
STATEMENT
TIME
IN
FREQUENCY
TOTAL
TIME
GRAND
TOTAL
N
N
N
X
TILDE
APPROXIMATION
N
ASSUMING
X
IS
SMALL
ORDER
OF
GROWTH
N
ANALYZING
THE
RUNNING
TIME
OF
A
PROGRAM
EXAMPLE
PROGRAM
BECAUSE
IT
DOES
NOT
REQUIRE
EXPERIMENTATION
TO
DETERMINE
THE
EXPONENT
WITH
SOME
EFFORT
WE
COULD
VALIDATE
THE
VALUE
OF
A
ON
A
PARTICULAR
SYSTEM
AS
WELL
THOUGH
THAT
ACTIVITY
IS
GENERALLY
RESERVED
FOR
EXPERTS
IN
SITUATIONS
WHERE
PERFORMANCE
IS
CRITICAL
ANALYSIS
OF
ALGORITHMS
HYPOTHESES
SUCH
AS
PROPERTY
A
ARE
SIGNIFICANT
BECAUSE
THEY
RELATE
THE
ABSTRACT
WORLD
OF
A
JAVA
PROGRAM
TO
THE
REAL
WORLD
OF
A
COMPUTER
RUNNING
IT
WORKING
WITH
THE
ORDER
OF
GROWTH
ALLOWS
US
TO
TAKE
ONE
FURTHER
STEP
TO
SEPARATE
A
PRO
GRAM
FROM
THE
ALGORITHM
IT
IMPLEMENTS
THE
IDEA
THAT
THE
ORDER
OF
GROWTH
OF
THE
RUN
NING
TIME
OF
THREESUM
IS
N
DOES
NOT
DEPEND
ON
THE
FACT
THAT
IT
IS
IMPLEMENTED
IN
JAVA
OR
THAT
IT
IS
RUNNING
ON
YOUR
LAPTOP
OR
SOMEONE
ELSE
CELLPHONE
OR
A
SUPERCOMPUTER
IT
DEPENDS
PRIMARILY
ON
THE
FACT
THAT
IT
EXAMINES
ALL
THE
DIFFERENT
TRIPLES
OF
NUMBERS
IN
THE
INPUT
THE
ALGORITHM
THAT
YOU
ARE
USING
AND
SOMETIMES
THE
INPUT
MODEL
DETERMINES
THE
ORDER
OF
GROWTH
SEPARATING
THE
ALGORITHM
FROM
THE
IMPLEMENTATION
ON
A
PARTICULAR
COMPUTER
IS
A
POWERFUL
CONCEPT
BECAUSE
IT
ALLOWS
US
TO
DEVELOP
KNOWLEDGE
ABOUT
THE
PERFORMANCE
OF
ALGORITHMS
AND
THEN
APPLY
THAT
KNOWLEDGE
TO
ANY
COMPUTER
FOR
EX
AMPLE
WE
MIGHT
SAY
THAT
THREESUM
IS
AN
IMPLEMENTATION
OF
THE
BRUTE
FORCE
ALGORITHM
COMPUTE
THE
SUM
OF
ALL
DIFFERENT
TRIPLES
COUNTING
THOSE
THAT
SUM
TO
WE
EXPECT
THAT
AN
IMPLEMENTATION
OF
THIS
ALGORITHM
IN
ANY
PROGRAMMING
LANGUAGE
ON
ANY
COMPUTER
WILL
LEAD
TO
A
RUNNING
TIME
THAT
IS
PROPORTIONAL
TO
N
IN
FACT
MUCH
OF
THE
KNOWLEDGE
ABOUT
THE
PERFORMANCE
OF
CLASSIC
ALGORITHMS
WAS
DEVELOPED
DECADES
AGO
BUT
THAT
KNOWLEDGE
IS
STILL
RELEVANT
TO
TODAY
COMPUTERS
COST
MODEL
WE
FOCUS
ATTENTION
ON
PROPERTIES
OF
AL
GORITHMS
BY
ARTICULATING
A
COST
MODEL
THAT
DEFINES
THE
BASIC
OPERATIONS
USED
BY
THE
ALGORITHMS
WE
ARE
STUDY
ING
TO
SOLVE
THE
PROBLEM
AT
HAND
FOR
EXAMPLE
AN
AP
PROPRIATE
COST
MODEL
FOR
THE
SUM
PROBLEM
SHOWN
AT
RIGHT
IS
THE
NUMBER
OF
TIMES
WE
ACCESS
AN
ARRAY
ENTRY
WITH
THIS
COST
MODEL
WE
CAN
MAKE
PRECISE
MATHEMATICAL
STATEMENTS
ABOUT
PROP
ERTIES
OF
AN
ALGORITHM
NOT
JUST
A
PARTICULAR
IMPLEMENTATION
AS
FOLLOWS
WE
USE
THE
TERM
PROPOSITION
TO
REFER
TO
MATHEMATICAL
TRUTHS
ABOUT
ALGORITHMS
IN
TERMS
OF
A
COST
MODEL
THROUGHOUT
THIS
BOOK
WE
STUDY
THE
ALGORITHMS
THAT
WE
CONSIDER
WITHIN
THE
FRAMEWORK
OF
A
SPECIFIC
COST
MODEL
OUR
INTENT
IS
TO
ARTICULATE
COST
MODELS
SUCH
THAT
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
FOR
A
GIVEN
IMPLEMENTATION
IS
THE
SAME
AS
THE
ORDER
OF
GROWTH
OF
THE
COST
OF
THE
UNDERLYING
ALGORITHM
IN
OTHER
WORDS
THE
COST
MODEL
SHOULD
INCLUDE
OPERATIONS
THAT
FALL
WITHIN
THE
INNER
LOOP
WE
SEEK
PRECISE
MATHEMATI
CAL
RESULTS
ABOUT
ALGORITHMS
PROPOSITIONS
AND
ALSO
HYPOTHESES
ABOUT
PERFORMANCE
OF
IMPLEMENTATIONS
PROPERTIES
THAT
YOU
CAN
CHECK
THROUGH
EXPERIMENTATION
IN
THIS
CASE
PROPOSITION
B
IS
A
MATHEMATICAL
TRUTH
THAT
SUPPORTS
THE
HYPOTHESIS
STATED
IN
PROPERTY
A
WHICH
WE
HAVE
VALIDATED
WITH
EXPERIMENTS
IN
ACCORDANCE
WITH
THE
SCIEN
TIFIC
METHOD
SUMMARY
FOR
MANY
PROGRAMS
DEVELOPING
A
MATHEMATICAL
MODEL
OF
RUNNING
TIME
REDUCES
TO
THE
FOLLOWING
STEPS
DEVELOP
AN
INPUT
MODEL
INCLUDING
A
DEFINITION
OF
THE
PROBLEM
SIZE
IDENTIFY
THE
INNER
LOOP
DEFINE
A
COST
MODEL
THAT
INCLUDES
OPERATIONS
IN
THE
INNER
LOOP
DETERMINE
THE
FREQUENCY
OF
EXECUTION
OF
THOSE
OPERATIONS
FOR
THE
GIVEN
INPUT
DOING
SO
MIGHT
REQUIRE
MATHEMATICAL
ANALYSIS
WE
WILL
CONSIDER
SOME
EXAMPLES
IN
THE
CONTEXT
OF
SPECIFIC
FUNDAMENTAL
ALGORITHMS
LATER
IN
THE
BOOK
IF
A
PROGRAM
IS
DEFINED
IN
TERMS
OF
MULTIPLE
METHODS
WE
NORMALLY
CONSIDER
THE
METHODS
SEPARATELY
AS
AN
EXAMPLE
CONSIDER
OUR
EXAMPLE
PROGRAM
OF
SECTION
BINARYSEARCH
BINARY
SEARCH
THE
INPUT
MODEL
IS
THE
ARRAY
A
OF
SIZE
N
THE
INNER
LOOP
IS
THE
STATEMENTS
IN
THE
SINGLE
WHILE
LOOP
THE
COST
MODEL
IS
THE
COMPARE
OPERATION
COMPARE
THE
VALUES
OF
TWO
ARRAY
ENTRIES
AND
THE
ANALYSIS
DISCUSSED
IN
SECTION
AND
GIVEN
IN
FULL
DETAIL
IN
PROPOSITION
B
IN
SECTION
SHOWS
THAT
THE
NUM
BER
OF
COMPARES
IS
AT
MOST
LG
N
WHITELIST
THE
INPUT
MODEL
IS
THE
N
NUMBERS
IN
THE
WHITELIST
AND
THE
M
NUMBERS
ON
STANDARD
INPUT
WHERE
WE
ASSUME
M
N
THE
INNER
LOOP
IS
THE
STATEMENTS
IN
THE
SINGLE
WHILE
LOOP
THE
COST
MODEL
IS
THE
COMPARE
OPERATION
INHERITED
FROM
BINARY
SEARCH
AND
THE
ANALYSIS
IS
IMMEDIATE
GIVEN
THE
ANALYSIS
OF
BINARY
SEARCH
THE
NUMBER
OF
COMPARES
IS
AT
MOST
M
LG
N
THUS
WE
DRAW
THE
CONCLUSION
THAT
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
THE
WHITELIST
COMPUTATION
IS
AT
MOST
M
LG
N
SUBJECT
TO
THE
FOLLOWING
CONSIDERATIONS
IF
N
IS
SMALL
THE
INPUT
OUTPUT
COST
MIGHT
DOMINATE
THE
NUMBER
OF
COMPARES
DEPENDS
ON
THE
INPUT
IT
LIES
BETWEEN
M
AND
M
LG
N
DEPENDING
ON
HOW
MANY
OF
THE
NUMBERS
ON
STANDARD
INPUT
ARE
IN
THE
WHITELIST
AND
ON
HOW
LONG
THE
BINARY
SEARCH
TAKES
TO
FIND
THE
ONES
THAT
ARE
TYPI
CALLY
IT
IS
M
LG
N
WE
ARE
ASSUMING
THAT
THE
COST
OF
ARRAYS
SORT
IS
SMALL
COMPARED
TO
M
LG
N
ARRAYS
SORT
IMPLEMENTS
THE
MERGESORT
ALGORITHM
AND
IN
SECTION
WE
WILL
SEE
THAT
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
MERGESORT
IS
N
LOG
N
SEE
PROPOSITION
G
IN
CHAPTER
SO
THIS
ASSUMPTION
IS
JUSTIFIED
THUS
THE
MODEL
SUPPORTS
OUR
HYPOTHESIS
FROM
SECTION
THAT
THE
BINARY
SEARCH
ALGO
RITHM
MAKES
THE
COMPUTATION
FEASIBLE
WHEN
M
AND
N
ARE
LARGE
IF
WE
DOUBLE
THE
LENGTH
OF
THE
STANDARD
INPUT
STREAM
THEN
WE
CAN
EXPECT
THE
RUNNING
TIME
TO
DOUBLE
IF
WE
DOUBLE
THE
SIZE
OF
THE
WHITELIST
THEN
WE
CAN
EXPECT
THE
RUNNING
TIME
TO
INCREASE
ONLY
SLIGHTLY
DEVELOPING
MATHEMATICAL
MODELS
FOR
THE
ANALYSIS
OF
ALGORITHMS
IS
A
FRUITFUL
AREA
OF
RESEARCH
THAT
IS
SOMEWHAT
BEYOND
THE
SCOPE
OF
THIS
BOOK
STILL
AS
YOU
WILL
SEE
WITH
BINARY
SEARCH
MERGESORT
AND
MANY
OTHER
ALGORITHMS
UNDERSTANDING
CERTAIN
MATH
EMATICAL
MODELS
IS
CRITICAL
TO
UNDERSTANDING
THE
EFFICIENCY
OF
FUNDAMENTAL
ALGORITHMS
SO
WE
OFTEN
PRESENT
DETAILS
AND
OR
QUOTE
THE
RESULTS
OF
CLASSIC
STUDIES
WHEN
DOING
SO
WE
ENCOUNTER
VARIOUS
FUNCTIONS
AND
APPROXIMATIONS
THAT
ARE
WIDELY
USED
IN
MATHEMATI
CAL
ANALYSIS
FOR
REFERENCE
WE
SUMMARIZE
SOME
OF
THIS
INFORMATION
IN
THE
TABLES
BELOW
DESCRIPTION
NOTATION
DEFINITION
FLOOR
X
LARGEST
INTEGER
NOT
GREATER
THAN
X
CEILING
X
SMALLEST
INTEGER
NOT
SMALLER
THAN
X
NATURAL
LOGARITHM
LN
N
LOG
E
N
X
SUCH
THAT
E
X
N
BINARY
LOGARITHM
LG
N
LOG
N
X
SUCH
THAT
N
INTEGER
LG
N
BINARY
LOGARITHM
LARGEST
INTEGER
NOT
GREATER
THAN
LG
N
BITS
IN
BINARY
REPRESENTATION
OF
N
HARMONIC
NUMBERS
HN
N
FACTORIAL
N
X
X
X
X
X
N
COMMONLY
ENCOUNTERED
FUNCTIONS
IN
THE
ANALYSIS
OF
ALGORITHMS
DESCRIPTION
APPROXIMATION
HARMONIC
SUM
HN
N
LN
N
TRIANGULAR
SUM
N
N
GEOMETRIC
SUM
N
WHEN
N
STIRLING
APPROXIMATION
BINOMIAL
COEFFICIENTS
LG
N
LG
LG
LG
LG
LG
N
N
LG
N
N
NK
K
WHEN
K
IS
A
SMALL
CONSTANT
EXPONENTIAL
X
X
E
USEFUL
APPROXIMATIONS
FOR
THE
ANALYSIS
OF
ALGORITHMS
ORDER
OF
GROWTH
CLASSIFICATIONS
WE
USE
JUST
A
FEW
STRUCTURAL
PRIMITIVES
STATE
MENTS
CONDITIONALS
LOOPS
NESTING
AND
METHOD
CALLS
TO
IMPLEMENT
ALGORITHMS
SO
VERY
OFTEN
THE
ORDER
OF
GROWTH
OF
THE
COST
IS
ONE
OF
JUST
A
FEW
FUNCTIONS
OF
THE
PROBLEM
SIZE
N
THESE
FUNCTIONS
ARE
SUMMARIZED
IN
THE
TABLE
ON
THE
FACING
PAGE
ALONG
WITH
THE
NAMES
THAT
WE
USE
TO
REFER
TO
THEM
TYPICAL
CODE
THAT
LEADS
TO
EACH
FUNCTION
AND
EXAMPLES
CONSTANT
A
PROGRAM
WHOSE
RUNNING
TIME
ORDER
OF
GROWTH
IS
CONSTANT
EXECUTES
A
FIXED
NUMBER
OF
OPERATIONS
TO
FINISH
ITS
JOB
CONSEQUENTLY
ITS
RUNNING
TIME
DOES
NOT
DEPEND
ON
N
MOST
JAVA
OPERATIONS
TAKE
CONSTANT
TIME
LOGARITHMIC
A
PROGRAM
WHOSE
RUNNING
TIME
ORDER
OF
GROWTH
IS
LOGARITHMIC
IS
BARELY
SLOWER
THAN
A
CONSTANT
TIME
PROGRAM
THE
CLASSIC
EXAMPLE
OF
A
PROGRAM
WHOSE
RUNNING
TIME
IS
LOGARITHMIC
IN
THE
PROBLEM
SIZE
IS
BINARY
SEARCH
SEE
BINARYSEARCH
ON
PAGE
THE
BASE
OF
THE
LOGARITHM
IS
NOT
RELEVANT
WITH
RESPECT
TO
THE
ORDER
OF
GROWTH
SINCE
ALL
LOGARITHMS
WITH
A
CONSTANT
BASE
ARE
RELATED
BY
A
CONSTANT
FACTOR
SO
WE
USE
LOG
N
WHEN
REFERRING
TO
ORDER
OF
GROWTH
LINEAR
PROGRAMS
THAT
SPEND
A
CONSTANT
AMOUNT
OF
TIME
PROCESSING
EACH
PIECE
OF
INPUT
DATA
OR
THAT
ARE
BASED
ON
A
SINGLE
FOR
LOOP
ARE
QUITE
COMMON
THE
ORDER
OF
GROWTH
OF
SUCH
A
PROGRAM
IS
SAID
TO
BE
LINEAR
ITS
RUNNING
TIME
IS
PROPORTIONAL
TO
N
LINEARITHMIC
WE
USE
THE
TERM
LINEARITHMIC
TO
DESCRIBE
PROGRAMS
WHOSE
RUNNING
TIME
FOR
A
PROBLEM
OF
SIZE
N
HAS
ORDER
OF
GROWTH
N
LOG
N
AGAIN
THE
BASE
OF
THE
LOGARITHM
IS
NOT
RELEVANT
WITH
RESPECT
TO
THE
ORDER
OF
GROWTH
THE
PROTOTYPICAL
EXAMPLES
OF
LIN
EARITHMIC
ALGORITHMS
ARE
MERGE
SORT
SEE
ALGORITHM
AND
QUICK
SORT
SEE
ALGORITHM
QUADRATIC
A
TYPICAL
PROGRAM
WHOSE
RUNNING
TIME
HAS
ORDER
OF
GROWTH
N
HAS
TWO
NESTED
FOR
LOOPS
USED
FOR
SOME
CALCULATION
INVOLVING
ALL
PAIRS
OF
N
ELEMENTS
THE
ELEMENTARY
SORTING
ALGORITHMS
SELECTION
SORT
SEE
ALGORITHM
AND
INSERTION
SORT
SEE
ALGORITHM
ARE
PROTOTYPES
OF
THE
PROGRAMS
IN
THIS
CLASSIFICATION
CUBIC
A
TYPICAL
PROGRAM
WHOSE
RUNNING
TIME
HAS
ORDER
OF
GROWTH
N
HAS
THREE
NESTED
FOR
LOOPS
USED
FOR
SOME
CALCULATION
INVOLVING
ALL
TRIPLES
OF
N
ELEMENTS
OUR
EXAMPLE
FOR
THIS
SECTION
THREESUM
IS
A
PROTOTYPE
EXPONENTIAL
IN
CHAPTER
BUT
NOT
UNTIL
THEN
WE
WILL
CONSIDER
PROGRAMS
WHOSE
RUNNING
TIMES
ARE
PROPORTIONAL
TO
OR
HIGHER
GENERALLY
WE
USE
THE
TERM
EXPONENTIAL
TO
REFER
TO
ALGORITHMS
WHOSE
ORDER
OF
GROWTH
IS
B
N
FOR
ANY
CONSTANT
B
EVEN
THOUGH
DIFFERENT
VALUES
OF
B
LEAD
TO
VASTLY
DIFFERENT
RUNNING
TIMES
EXPONENTIAL
ALGORITHMS
ARE
EXTREMELY
SLOW
YOU
WILL
NEVER
RUN
ONE
OF
THEM
TO
COMPLETION
FOR
A
LARGE
PROBLEM
STILL
EXPONENTIAL
ALGORITHMS
PLAY
A
CRITICAL
ROLE
IN
THE
THEORY
OF
ALGORITHMS
BECAUSE
DESCRIPTION
ORDER
OF
TYPICAL
CODE
FRAMEWORK
DESCRIPTION
EXAMPLE
CONSTANT
A
B
C
STATEMENT
ADD
TWO
NUMBERS
LOGARITHMIC
LOG
N
SEE
PAGE
DIVIDE
IN
HALF
BINARY
SEARCH
LINEAR
N
DOUBLE
MAX
A
FOR
INT
I
I
N
I
IF
A
I
MAX
MAX
A
I
LOOP
FIND
THE
MAXIMUM
LINEARITHMIC
N
LOG
N
SEE
ALGORITHM
DIVIDE
AND
MERGESORT
QUADRATIC
N
FOR
INT
I
I
N
I
FOR
INT
J
I
J
N
J
IF
A
I
A
J
CNT
DOUBLE
LOOP
CHECK
ALL
PAIRS
CUBIC
N
FOR
INT
I
I
N
I
FOR
INT
J
I
J
N
J
FOR
INT
K
J
K
N
K
IF
A
I
A
J
A
K
CNT
TRIPLE
LOOP
CHECK
ALL
TRIPLES
EXPONENTIAL
N
SEE
CHAPTER
EXHASUTIVE
CHECK
ALL
SUBSETS
SUMMARY
OF
COMMON
ORDER
OF
GROWTH
HYPOTHESES
THERE
EXISTS
A
LARGE
CLASS
OF
PROBLEMS
FOR
WHICH
IT
SEEMS
THAT
AN
EXPONENTIAL
ALGORITHM
IS
THE
BEST
POSSIBLE
CHOICE
THESE
CLASSIFICATIONS
ARE
THE
MOST
COMMON
BUT
CERTAINLY
NOT
A
COMPLETE
SET
THE
ORDER
OF
GROWTH
OF
AN
ALGORITHM
COST
MIGHT
BE
N
LOG
N
OR
N
OR
SOME
SIMILAR
FUNC
TION
INDEED
THE
DETAILED
ANALYSIS
OF
ALGORITHMS
STANDARD
PLOT
LOG
LOG
PLOT
T
PROBLEM
SIZE
CONSTANT
PROBLEM
SIZE
TYPICAL
ORDERS
OF
GROWTH
CAN
REQUIRE
THE
FULL
GAMUT
OF
MATHEMATICAL
TOOLS
THAT
HAVE
BEEN
DEVELOPED
OVER
THE
CENTURIES
A
GREAT
MANY
OF
THE
ALGORITHMS
THAT
WE
CON
SIDER
HAVE
STRAIGHTFORWARD
PERFORMANCE
CHARAC
TERISTICS
THAT
CAN
BE
ACCURATELY
DESCRIBED
BY
ONE
OF
THE
ORDERS
OF
GROWTH
THAT
WE
HAVE
CONSIDERED
ACCORDINGLY
WE
CAN
USUALLY
WORK
WITH
SPECIFIC
PROPOSITIONS
WITH
A
COST
MODEL
SUCH
AS
MERGESORT
USES
BETWEEN
N
LG
N
AND
N
LG
N
COMPARES
THAT
IMMEDIATELY
IMPLY
HYPOTHESES
PROPERTIES
SUCH
AS
THE
ORDER
OF
GROWTH
OF
MERGESORT
RUNNING
TIME
IS
LINEARITHMIC
FOR
ECONOMY
WE
ABBREVIATE
SUCH
A
STATEMENT
TO
JUST
SAY
MERGESORT
IS
LINEARITHMIC
THE
PLOTS
AT
LEFT
INDICATE
THE
IMPORTANCE
OF
THE
ORDER
OF
GROWTH
IN
PRACTICE
THE
X
AXIS
IS
THE
PROBLEM
SIZE
THE
Y
AXIS
IS
THE
RUNNING
TIME
THESE
CHARTS
MAKE
PLAIN
THAT
QUADRATIC
AND
CUBIC
ALGORITHMS
ARE
NOT
FEASIBLE
FOR
USE
ON
LARGE
PROB
LEMS
AS
IT
TURNS
OUT
SEVERAL
IMPORTANT
PROB
LEMS
HAVE
NATURAL
SOLUTIONS
THAT
ARE
QUADRATIC
BUT
CLEVER
ALGORITHMS
THAT
ARE
LINEARITHMIC
SUCH
ALGORITHMS
INCLUDING
MERGESORT
ARE
CRITICALLY
IMPORTANT
IN
PRACTICE
BECAUSE
THEY
ENABLE
US
TO
ADDRESS
PROBLEM
SIZES
FAR
LARGER
THAN
COULD
BE
ADDRESSED
WITH
QUADRATIC
SOLUTIONS
NATURALLY
WE
THEREFORE
FOCUS
IN
THIS
BOOK
ON
DEVELOPING
LOGA
RITHMIC
LINEAR
AND
LINEARITHMIC
ALGORITHMS
FOR
FUNDAMENTAL
PROBLEMS
DESIGNING
FASTER
ALGORITHMS
ONE
OF
THE
PRIMARY
REASONS
TO
STUDY
THE
ORDER
OF
GROWTH
OF
A
PROGRAM
IS
TO
HELP
DESIGN
A
FASTER
ALGORITHM
TO
SOLVE
THE
SAME
PROBLEM
TO
ILLUSTRATE
THIS
POINT
WE
CONSIDER
NEXT
A
FASTER
ALGORITHM
FOR
THE
SUM
PROBLEM
HOW
CAN
WE
DEVISE
A
FASTER
ALGORITHM
BEFORE
EVEN
EMBARKING
ON
THE
STUDY
OF
ALGORITHMS
THE
ANSWER
TO
THIS
QUESTION
IS
THAT
WE
HAVE
DISCUSSED
AND
USED
TWO
CLASSIC
ALGORITHMS
MERGESORT
AND
BINARY
SEARCH
HAVE
INTRODUCED
THE
FACTS
THAT
THE
MERGESORT
IS
LINEARITH
MIC
AND
BINARY
SEARCH
IS
LOGARITHMIC
HOW
CAN
WE
TAKE
ADVANTAGE
OF
THESE
ALGORITHMS
TO
SOLVE
THE
SUM
PROBLEM
WARMUP
SUM
CONSIDER
THE
EASIER
PROBLEM
OF
DETERMINING
THE
NUMBER
OF
PAIRS
OF
INTEGERS
IN
AN
INPUT
FILE
THAT
SUM
TO
TO
SIMPLIFY
THE
DISCUSSION
ASSUME
ALSO
THAT
THE
INTEGERS
ARE
DISTINCT
THIS
PROBLEM
IS
EASILY
SOLVED
IN
QUADRATIC
TIME
BY
DELETING
THE
K
LOOP
AND
A
K
FROM
THREESUM
COUNT
LEAVING
A
DOUBLE
LOOP
THAT
EXAMINES
ALL
PAIRS
AS
SHOWN
IN
THE
QUADRATIC
ENTRY
IN
THE
TABLE
ON
PAGE
WE
REFER
TO
SUCH
AN
IMPLEMENTA
TION
AS
TWOSUM
THE
IMPLEMENTATION
BELOW
SHOWS
HOW
MERGESORT
AND
BINARY
SEARCH
SEE
PAGE
CAN
SERVE
AS
A
BASIS
FOR
A
LINEARITHMIC
SOLUTION
TO
THE
SUM
PROBLEM
THE
IMPROVED
ALGORITHM
IS
BASED
ON
THE
FACT
THAT
AN
ENTRY
A
I
IS
ONE
OF
A
PAIR
THAT
SUMS
TO
IF
AND
ONLY
IF
THE
VALUE
A
I
IS
IN
THE
ARRAY
AND
A
I
IS
NOT
ZERO
TO
SOLVE
THE
PROB
LEM
WE
SORT
THE
ARRAY
TO
ENABLE
BINARY
SEARCH
AND
THEN
FOR
EVERY
ENTRY
A
I
IN
THE
AR
RAY
DO
A
BINARY
SEARCH
FOR
A
I
WITH
RANK
IN
BINARYSEARCH
IF
THE
RESULT
IS
AN
INDEX
J
WITH
J
I
WE
INCREMENT
THE
COUNT
THIS
SUCCINCT
TEST
COVERS
THREE
CASES
AN
UNSUCCESSFUL
BINARY
SEARCH
RE
TURNS
SO
WE
DO
NOT
INCREMENT
THE
COUNT
IF
THE
BINARY
SEARCH
RE
TURNS
J
I
WE
HAVE
A
I
A
J
SO
WE
INCRE
MENT
THE
COUNT
IF
THE
BINARY
SEARCH
RETURNS
J
BETWEEN
AND
I
WE
ALSO
HAVE
A
I
A
J
BUT
DO
NOT
INCREMENT
THE
COUNT
TO
AVOID
DOUBLE
COUNTING
THE
RESULT
OF
THE
COMPUTATION
IS
PRECISE
LY
THE
SAME
AS
THE
RESULT
OF
THE
QUADRATIC
ALGORITHM
BUT
IT
TAKES
MUCH
LESS
TIME
THE
RUNNING
TIME
OF
THE
MERGESORT
IS
PROPORTIONAL
TO
N
LOG
N
AND
THE
N
BINARY
SEARCHES
EACH
TAKE
TIME
PROPORTIONAL
TO
LOG
N
SO
THE
RUNNING
TIME
OF
THE
WHOLE
ALGORITHM
IS
PROPORTIONAL
TO
N
LOG
N
DEVELOPING
A
FASTER
ALGORITHM
LIKE
THIS
IS
NOT
MERELY
AN
ACADEMIC
EXERCISE
THE
FASTER
ALGORITHM
ENABLES
US
TO
ADDRESS
MUCH
LARGER
PROBLEMS
FOR
EXAMPLE
YOU
ARE
LIKELY
TO
BE
ABLE
TO
SOLVE
THE
SUM
PROBLEM
FOR
MILLION
INTEGERS
TXT
IN
A
REASONABLE
AMOUNT
OF
TIME
ON
YOUR
COMPUTER
BUT
YOU
WOULD
HAVE
TO
WAIT
QUITE
A
LONG
TIME
TO
DO
IT
WITH
THE
QUADRATIC
ALGORITHM
SEE
EXERCISE
FAST
ALGORITHM
FOR
SUM
THE
VERY
SAME
IDEA
IS
EFFECTIVE
FOR
THE
SUM
PROBLEM
AGAIN
ASSUME
ALSO
THAT
THE
INTEGERS
ARE
DISTINCT
A
PAIR
A
I
AND
A
J
IS
PART
OF
A
TRIPLE
THAT
SUMS
TO
IF
AND
ONLY
IF
THE
VALUE
A
I
A
J
IS
IN
THE
ARRAY
AND
NOT
A
I
OR
A
J
THE
CODE
BELOW
SORTS
THE
ARRAY
THEN
DOES
N
N
BINARY
SEARCHES
THAT
EACH
TAKE
TIME
PROPORTIONAL
TO
LOG
N
FOR
A
TOTAL
RUNNING
TIME
PROPORTIONAL
TO
N
LOG
N
NOTE
THAT
IN
THIS
CASE
THE
COST
OF
THE
SORT
IS
INSIGNIFICANT
AGAIN
THIS
SOLUTION
ENABLES
US
TO
AD
DRESS
MUCH
LARGER
PROBLEMS
SEE
EXERCISE
THE
PLOTS
IN
THE
FIGURE
AT
THE
BOTTOM
OF
THE
NEXT
PAGE
SHOW
THE
DISPARITY
IN
COSTS
AMONG
THESE
FOUR
ALGORITHMS
FOR
PROBLEM
SIZES
IN
THE
RANGE
WE
HAVE
CONSIDERED
SUCH
DIFFERENCES
CERTAINLY
MOTIVATE
THE
SEARCH
FOR
FASTER
ALGORITHMS
LOWER
BOUNDS
THE
TABLE
ON
PAGE
SUMMARIZES
THE
DISCUSSION
OF
THIS
SECTION
AN
IN
TERESTING
QUESTION
IMMEDIATELY
ARISES
CAN
WE
FIND
ALGORITHMS
FOR
THE
SUM
AND
SUM
PROBLEMS
THAT
ARE
SUBSTANTIALLY
FASTER
THAN
TWOSUMFAST
AND
THREESUMFAST
IS
THERE
A
LINEAR
ALGORITHM
FOR
SUM
OR
A
LINEA
RITHMIC
ALGORITHM
FOR
SUM
THE
ANSWER
TO
THIS
QUESTION
IS
NO
FOR
SUM
UNDER
A
MODEL
THAT
COUNTS
AND
ALLOWS
ONLY
COMPARI
SONS
OF
LINEAR
OR
QUADRATIC
FUNC
TIONS
OF
THE
NUMBERS
AND
NO
ONE
KNOWS
FOR
SUM
THOUGH
EXPERTS
BELIEVE
THAT
THE
BEST
POSSIBLE
AL
GORITHM
FOR
SUM
IS
QUADRATIC
THE
IDEA
OF
A
LOWER
BOUND
ON
THE
ORDER
OF
GROWTH
OF
THE
WORST
CASE
RUNNING
TIME
FOR
ALL
POSSIBLE
AL
GORITHMS
TO
SOLVE
A
PROBLEM
IS
A
VERY
POWERFUL
ONE
WHICH
WE
WILL
REVISIT
IN
DETAIL
IN
SECTION
IN
THE
CONTEXT
OF
SORTING
NON
TRIVIAL
LOWER
BOUNDS
ARE
DIFFICULT
TO
ESTABLISH
BUT
VERY
HELPFUL
IN
GUIDING
OUR
SEARCH
FOR
EFFICIENT
ALGORITHMS
ALGORITHM
ORDER
OF
GROWTH
OF
RUNNING
TIME
THE
EXAMPLES
IN
THIS
SECTION
SET
THE
STAGE
FOR
OUR
TREAT
MENT
OF
ALGORITHMS
IN
THIS
BOOK
THROUGHOUT
THE
BOOK
OUR
STRATEGY
FOR
ADDRESSING
NEW
PROBLEMS
IS
THE
FOLLOWING
IMPLEMENT
AND
ANALYZE
A
STRAIGHFORWARD
SOLUTION
TO
THE
PROBLEM
WE
USUALLY
REFER
TO
SUCH
SOLUTIONS
LIKE
THREESUM
AND
TWOSUM
AS
THE
BRUTE
FORCE
SOLUTION
EXAMINE
ALGORITHMIC
IMPROVEMENTS
USUALLY
DESIGNED
TWOSUM
N
TWOSUMFAST
N
LOG
N
THREESUM
N
THREESUMFAST
N
LOG
N
SUMMARY
OF
RUNNING
TIMES
TO
REDUCE
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
SUCH
AS
TWOSUMFAST
AND
THREESUMFAST
RUN
EXPERIMENTS
TO
VALIDATE
THE
HYPOTHESES
THAT
THE
NEW
ALGORITHMS
ARE
FASTER
IN
MANY
CASES
WE
EXAMINE
SEVERAL
ALGORITHMS
FOR
THE
SAME
PROBLEM
BECAUSE
RUNNING
TIME
IS
ONLY
ONE
CONSIDERATION
WHEN
CHOOSING
AN
ALGORITHM
FOR
A
PRACTICAL
PROBLEM
WE
WILL
DEVELOP
THIS
IDEA
IN
DETAIL
IN
THE
CONTEXT
OF
FUNDAMENTAL
PROBLEMS
THROUGHOUT
THE
BOOK
LGN
PROBLEM
SIZE
N
PROBLEM
SIZE
N
COSTS
OF
ALGORITHMS
TO
SOLVE
THE
SUM
AND
SUM
PROBLEMS
DOUBLING
RATIO
EXPERIMENTS
THE
FOLLOWING
IS
A
SIMPLE
AND
EFFECTIVE
SHORTCUT
FOR
PREDICTING
PERFORMANCE
AND
FOR
DETERMINING
THE
APPROXIMATE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
ANY
PROGRAM
DEVELOP
AN
INPUT
GENERATOR
THAT
PRODUCES
INPUTS
THAT
MODEL
THE
INPUTS
EXPECTED
IN
PRACTICE
SUCH
AS
THE
RANDOM
INTEGERS
IN
TIMETRIAL
IN
DOUBLINGTEST
RUN
THE
PROGRAM
DOUBLINGRATIO
GIVEN
BELOW
A
MODIFICATION
OF
DOUBLINGTEST
THAT
CALCULATES
THE
RATIO
OF
EACH
RUNNING
TIME
WITH
THE
PREVIOUS
RUN
UNTIL
THE
RATIOS
APPROACH
A
LIMIT
THIS
TEST
IS
NOT
EFFECTIVE
IF
THE
RATIOS
DO
NOT
APPROACH
A
LIMITING
VALUE
BUT
THEY
DO
FOR
MANY
MANY
PROGRAMS
IMPLYING
THE
FOLLOWING
CONCLUSIONS
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
IS
APPROXIMATELY
NB
TO
PREDICT
RUNNING
TIMES
MULTIPLY
THE
LAST
OBSERVED
RUNNING
TIME
BY
AND
DOUBLE
N
CONTINUING
AS
LONG
AS
DESIRED
IF
YOU
WANT
TO
PREDICT
FOR
AN
INPUT
SIZE
THAT
IS
NOT
A
POWER
OF
TIMES
N
YOU
CAN
ADJUST
RATIOS
ACCORDINGLY
SEE
EXERCISE
AS
ILLUSTRATED
BELOW
THE
RATIO
FOR
THREESUM
IS
ABOUT
AND
WE
CAN
PREDICT
THE
RUNNING
TIMES
FOR
N
TO
BE
SECONDS
RESPECTIVELY
JUST
BY
SUCCESSIVELY
MULTIPLYING
THE
LAST
TIME
FOR
BY
PROGRAM
TO
PERFORM
EXPERIMENTS
RESULTS
OF
EXPERIMENTS
PREDICTIONS
THIS
TEST
IS
ROUGHLY
EQUIVALENT
TO
THE
PROCESS
DESCRIBED
ON
PAGE
RUN
EXPERIMENTS
PLOT
VALUES
ON
A
LOG
LOG
PLOT
TO
DEVELOP
THE
HYPOTHESIS
THAT
THE
RUNNING
TIME
IS
ANB
DETERMINE
THE
VALUE
OF
B
FROM
THE
SLOPE
OF
THE
LINE
THEN
SOLVE
FOR
A
BUT
IT
IS
SIM
PLER
TO
APPLY
INDEED
YOU
CAN
ACCURATELY
PREDICT
PREFORMANCE
BY
HAND
WHEN
YOU
RUN
DOUBLINGRATIO
AS
THE
RATIO
APPROACHES
A
LIMIT
JUST
MULTIPLY
BY
THAT
RATIO
TO
FILL
IN
LATER
VALUES
IN
THE
TABLE
YOUR
APPROXIMATE
MODEL
OF
THE
ORDER
OF
GROWTH
IS
A
POWER
LAW
WITH
THE
BINARY
LOGARITHM
OF
THAT
RATIO
AS
THE
POWER
WHY
DOES
THE
RATIO
APPROACH
A
CONSTANT
A
SIMPLE
MATHEMATICAL
CALCULATION
SHOWS
THAT
TO
BE
THE
CASE
FOR
ALL
OF
THE
COMMON
ORDERS
OF
GROWTH
JUST
DISCUSSED
EXCEPT
EXPONENTIAL
GENERALLY
THE
LOGARITHMIC
FACTOR
CANNOT
BE
IGNORED
WHEN
DEVELOPING
A
MATHEMATICAL
MODEL
BUT
IT
PLAYS
A
LESS
IMPORTANT
ROLE
IN
PREDICTING
PERFORMANCE
WITH
A
DOUBLING
HYPOTHESIS
YOU
SHOULD
CONSIDER
RUNNING
DOUBLING
RATIO
EXPERIMENTS
FOR
EVERY
PROGRAM
THAT
YOU
WRITE
WHERE
PERFORMANCE
MATTERS
DOING
SO
IS
A
VERY
SIMPLE
WAY
TO
ESTIMATE
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
PERHAPS
REVEALING
A
PERFORMANCE
BUG
WHERE
A
PROGRAM
MAY
TURN
OUT
TO
BE
NOT
AS
EFFICIENT
AS
YOU
MIGHT
THINK
MORE
GENERALLY
WE
CAN
USE
HYPOTHESES
ABOUT
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
PROGRAMS
TO
PREDICT
PERFORMANCE
IN
ONE
OF
THE
FOLLOWING
WAYS
ESTIMATING
THE
FEASIBILITY
OF
SOLVING
LARGE
PROBLEMS
YOU
NEED
TO
BE
ABLE
TO
ANSWER
THIS
BASIC
QUESTION
FOR
EVERY
PROGRAM
THAT
YOU
WRITE
WILL
THE
PROGRAM
BE
ABLE
TO
PROCESS
THIS
GIVEN
INPUT
DATA
IN
A
REASONABLE
AMOUNT
OF
TIME
TO
ADDRESS
SUCH
QUESTIONS
FOR
A
LARGE
AMOUNT
OF
DATA
WE
EXTRAPOLATE
BY
A
MUCH
LARGER
FACTOR
THAN
FOR
DOUBLING
SAY
AS
SHOWN
IN
THE
FOURTH
COLUMN
IN
THE
TABLE
AT
THE
BOTTOM
OF
THE
NEXT
PAGE
WHETHER
IT
IS
AN
INVESTMENT
BANKER
RUNNING
DAILY
FINANCIAL
MODELS
OR
A
SCIENTIST
RUNNING
A
PROGRAM
TO
ANALYZE
EXPERIMENTAL
DATA
OR
AN
ENGINEER
RUNNING
SIMULATIONS
TO
TEST
A
DESIGN
IT
IS
NOT
UNUSUAL
FOR
PEOPLE
TO
REGULARLY
RUN
PROGRAMS
THAT
TAKE
SEVERAL
HOURS
TO
COMPLETE
SO
THE
TABLE
FOCUSES
ON
THAT
SITUATION
KNOWING
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
AN
ALGORITHM
PROVIDES
PRECISELY
THE
INFORMATION
THAT
YOU
NEED
TO
UNDERSTAND
LIMITA
TIONS
ON
THE
SIZE
OF
THE
PROBLEMS
THAT
YOU
CAN
SOLVE
DEVELOPING
SUCH
UNDERSTANDING
IS
THE
MOST
IMPORTANT
REASON
TO
STUDY
PERFORMANCE
WITHOUT
IT
YOU
ARE
LIKELY
HAVE
NO
IDEA
HOW
MUCH
TIME
A
PROGRAM
WILL
CONSUME
WITH
IT
YOU
CAN
MAKE
A
BACK
OF
THE
ENVELOPE
CALCULATION
TO
ESTIMATE
COSTS
AND
PROCEED
ACCORDINGLY
ESTIMATING
THE
VALUE
OF
USING
A
FASTER
COMPUTER
YOU
ALSO
MAY
BE
FACED
WITH
THIS
BASIC
QUESTION
PERIODICALLY
HOW
MUCH
FASTER
CAN
I
SOLVE
THE
PROBLEM
IF
I
GET
A
FASTER
COMPUTER
GENERALLY
IF
THE
NEW
COMPUTER
IS
X
TIMES
FASTER
THAN
THE
OLD
ONE
YOU
CAN
IMPROVE
YOUR
RUNNING
TIME
BY
A
FACTOR
OF
X
BUT
IT
IS
USUALLY
THE
CASE
THAT
YOU
CAN
ADDRESS
LARGER
PROB
LEMS
WITH
YOUR
NEW
COMPUTER
HOW
WILL
THAT
CHANGE
AFFECT
THE
RUNNING
TIME
AGAIN
THE
ORDER
OF
GROWTH
IS
PRECISELY
THE
INFORMATION
NEEDED
TO
ANSWER
THAT
QUESTION
A
FAMOUS
RULE
OF
THUMB
KNOWN
AS
MOORE
LAW
IMPLIES
THAT
YOU
CAN
EXPECT
TO
HAVE
A
COMPUTER
WITH
ABOUT
DOUBLE
THE
SPEED
AND
DOUBLE
THE
MEMORY
MONTHS
FROM
NOW
OR
A
COMPUTER
WITH
ABOUT
TIMES
THE
SPEED
AND
TIMES
THE
MEMORY
IN
ABOUT
YEARS
THE
TABLE
BELOW
DEMONSTRATES
THAT
YOU
CANNOT
KEEP
PACE
WITH
MOORE
LAW
IF
YOU
ARE
USING
A
QUADRATIC
OR
A
CUBIC
ALGORITHM
AND
YOU
CAN
QUICKLY
DETERMINE
WHETHER
THAT
IS
THE
CASE
BY
DOING
A
DOUBLING
RATIO
TEST
AND
CHECKING
THAT
THE
RATIO
OF
RUNNING
TIMES
AS
THE
INPUT
SIZE
DOUBLES
APPROACHES
NOT
OR
ORDER
OF
GROWTH
OF
TIME
FOR
A
PROGRAM
THAT
TAKES
A
FEW
HOURS
FOR
INPUT
OF
SIZE
N
PREDICTED
TIME
DESCRIPTION
FUNCTION
FACTOR
FACTOR
PREDICTED
TIME
FOR
ON
A
FASTER
COMPUTER
LINEAR
N
A
DAY
A
FEW
HOURS
LINEARITHMIC
N
LOG
N
A
DAY
A
FEW
HOURS
QUADRATIC
N
A
FEW
WEEKS
A
DAY
CUBIC
N
SEVERAL
MONTHS
A
FEW
WEEKS
EXPONENTIAL
N
N
NEVER
NEVER
PREDICTIONS
ON
THE
BASIS
OF
ORDER
OF
GROWTH
FUNCTION
CAVEATS
THERE
ARE
MANY
REASONS
THAT
YOU
MIGHT
GET
INCONSISTENT
OR
MISLEADING
RE
SULTS
WHEN
TRYING
TO
ANALYZE
PROGRAM
PERFORMANCE
IN
DETAIL
ALL
OF
THEM
HAVE
TO
DO
WITH
THE
IDEA
THAT
ONE
OR
MORE
OF
THE
BASIC
ASSUMPTIONS
UNDERLYING
OUR
HYPOTHESES
MIGHT
BE
NOT
QUITE
CORRECT
WE
CAN
DEVELOP
NEW
HYPOTHESES
BASED
ON
NEW
ASSUMPTIONS
BUT
THE
MORE
DETAILS
THAT
WE
NEED
TO
TAKE
INTO
ACCOUNT
THE
MORE
CARE
IS
REQUIRED
IN
THE
ANALYSIS
LARGE
CONSTANTS
WITH
LEADING
TERM
APPROXIMATIONS
WE
IGNORE
CONSTANT
COEFFICIENTS
IN
LOWER
ORDER
TERMS
WHICH
MAY
NOT
BE
JUSTIFED
FOR
EXAMPLE
WHEN
WE
APPROXIMATE
THE
FUNCTION
N
C
N
BY
N
WE
ARE
ASSUMING
THAT
C
IS
SMALL
IF
THAT
IS
NOT
THE
CASE
SUPPOSE
THAT
C
IS
OR
THE
APPROXIMATION
IS
MISLEADING
THUS
WE
HAVE
TO
BE
SENSITIVE
TO
THE
POSSIBILITY
OF
LARGE
CONSTANTS
NONDOMINANT
INNER
LOOP
THE
ASSUMPTION
THAT
THE
INNER
LOOP
DOMINATES
MAY
NOT
ALWAYS
BE
CORRECT
THE
COST
MODEL
MIGHT
MISS
THE
TRUE
INNER
LOOP
OR
THE
PROBLEM
SIZE
N
MIGHT
NOT
BE
SUFFICIENTLY
LARGE
TO
MAKE
THE
LEADING
TERM
IN
THE
MATHEMATICAL
DESCRIP
TION
OF
THE
FREQUENCY
OF
EXECUTION
OF
INSTRUCTIONS
IN
THE
INNER
LOOP
SO
MUCH
LARGER
THAN
LOWER
ORDER
TERMS
THAT
WE
CAN
IGNORE
THEM
SOME
PROGRAMS
HAVE
A
SIGNIFICANT
AMOUNT
OF
CODE
OUTSIDE
THE
INNER
LOOP
THAT
NEEDS
TO
BE
TAKEN
INTO
CONSIDERATION
IN
OTHER
WORDS
THE
COST
MODEL
MAY
NEED
TO
BE
REFINED
INSTRUCTION
TIME
THE
ASSUMPTION
THAT
EACH
INSTRUCTION
ALWAYS
TAKES
THE
SAME
AMOUNT
OF
TIME
IS
NOT
ALWAYS
CORRECT
FOR
EXAMPLE
MOST
MODERN
COMPUTER
SYSTEMS
USE
A
TECH
NIQUE
KNOWN
AS
CACHING
TO
ORGANIZE
MEMORY
IN
WHICH
CASE
ACCESSING
ELEMENTS
IN
HUGE
ARRAYS
CAN
TAKE
MUCH
LONGER
IF
THEY
ARE
NOT
CLOSE
TOGETHER
IN
THE
ARRAY
YOU
MIGHT
OB
SERVE
THE
EFFECT
OF
CACHING
FOR
THREESUM
BY
LETTING
DOUBLINGTEST
RUN
FOR
A
WHILE
AFTER
SEEMING
TO
CONVERGE
TO
THE
RATIO
OF
RUNNING
TIMES
MAY
JUMP
TO
A
LARGER
VALUE
FOR
LARGE
ARRAYS
BECAUSE
OF
CACHING
SYSTEM
CONSIDERATIONS
TYPICALLY
THERE
ARE
MANY
MANY
THINGS
GOING
ON
IN
YOUR
COM
PUTER
JAVA
IS
ONE
APPLICATION
OF
MANY
COMPETING
FOR
RESOURCES
AND
JAVA
ITSELF
HAS
MANY
OPTIONS
AND
CONTROLS
THAT
SIGNIFICANTLY
AFFECT
PERFORMANCE
A
GARBAGE
COLLECTOR
OR
A
JUST
IN
TIME
COMPILER
OR
A
DOWNLOAD
FROM
THE
INTERNET
MIGHT
DRASTICALLY
AFFECT
THE
RESULTS
OF
EXPERIMENTS
SUCH
CONSIDERATIONS
CAN
INTERFERE
WITH
THE
BEDROCK
PRINCIPLE
OF
THE
SCIENTIFIC
METHOD
THAT
EXPERIMENTS
SHOULD
BE
REPRODUCIBLE
SINCE
WHAT
IS
HAPPENING
AT
THIS
MOMENT
IN
YOUR
COMPUTER
WILL
NEVER
BE
REPRODUCED
AGAIN
WHATEVER
ELSE
IS
GOING
ON
IN
YOUR
SYSTEM
SHOULD
IN
PRINCIPLE
BE
NEGLIGIBLE
OR
POSSIBLE
TO
CONTROL
TOO
CLOSE
TO
CALL
OFTEN
WHEN
WE
COMPARE
TWO
DIFFERENT
PROGRAMS
FOR
THE
SAME
TASK
ONE
MIGHT
BE
FASTER
IN
SOME
SITUATIONS
AND
SLOWER
IN
OTHERS
ONE
OR
MORE
OF
THE
CONSID
ERATIONS
JUST
MENTIONED
COULD
MAKE
THE
DIFFERENCE
THERE
IS
A
NATURAL
TENDENCY
AMONG
SOME
PROGRAMMERS
AND
SOME
STUDENTS
TO
DEVOTE
AN
EXTREME
AMOUNT
OF
ENERGY
RUN
NING
RACES
TO
FIND
THE
BEST
IMPLEMENTATION
BUT
SUCH
WORK
IS
BEST
LEFT
FOR
EXPERTS
STRONG
DEPENDENCE
ON
INPUTS
ONE
OF
THE
FIRST
ASSUMPTIONS
THAT
WE
MADE
IN
ORDER
TO
DETERMINE
THE
ORDER
OF
GROWTH
OF
THE
PROGRAM
RUNNING
TIME
OF
A
PROGRAM
WAS
THAT
THE
RUNNING
TIME
SHOULD
BE
RELATIVELY
INSENSITIVE
TO
THE
INPUTS
WHEN
THAT
IS
NOT
THE
CASE
WE
MAY
GET
INCONSISTENT
RESULTS
OR
BE
UNABLE
TO
VALIDATE
OUR
HYPOTHESES
FOR
EXAMPLE
SUP
POSE
THAT
WE
MODIFY
THREESUM
TO
ANSWER
THE
QUESTION
DOES
THE
INPUT
HAVE
A
TRIPLE
THAT
SUMS
TO
BY
CHANGING
IT
TO
RETURN
A
BOOLEAN
VALUE
REPLACING
CNT
BY
RETURN
TRUE
AND
ADDING
RETURN
FALSE
AS
THE
LAST
STATEMENT
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
THIS
PROGRAM
IS
CONSTANT
IF
THE
FIRST
THREE
INTEGERS
SUM
TO
AND
CUBIC
IF
THERE
ARE
NO
SUCH
TRIPLES
IN
THE
INPUT
MULTIPLE
PROBLEM
PARAMETERS
WE
HAVE
BEEN
FOCUSING
ON
MEASURING
PERFORMANCE
AS
A
FUNCTION
OF
A
SINGLE
PARAMETER
GENERALLY
THE
VALUE
OF
A
COMMAND
LINE
ARGUMENT
OR
THE
SIZE
OF
THE
INPUT
HOWEVER
IT
IS
NOT
UNUSUAL
TO
HAVE
SEVERAL
PARAMETERS
A
TYPICAL
EX
AMPLE
ARISES
WHEN
AN
ALGORITHM
INVOLVES
BUILDING
A
DATA
STRUCTURE
AND
THEN
PERFORMING
A
SEQUENCE
OF
OPERATIONS
THAT
USE
THAT
DATA
STRUCTURE
BOTH
THE
SIZE
OF
THE
DATA
STRUCTURE
AND
THE
NUMBER
OF
OPERATIONS
ARE
PARAMETERS
FOR
SUCH
APPLICATIONS
WE
HAVE
ALREADY
SEEN
AN
EXAMPLE
OF
THIS
IN
OUR
ANALYSIS
OF
THE
PROBLEM
OF
WHITELISTING
USING
BINARY
SEARCH
WHERE
WE
HAVE
N
NUMBERS
IN
THE
WHITELIST
AND
M
NUMBERS
ON
STANDARD
INPUT
AND
A
TYPICAL
RUNNING
TIME
PROPORTIONAL
TO
M
LOG
N
DESPITE
ALL
THESE
CAVEATS
UNDERSTANDING
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
EACH
PROGRAM
IS
VALUABLE
KNOWLEDGE
FOR
ANY
PROGRAMMER
AND
THE
METHODS
THAT
WE
HAVE
DESCRIBED
ARE
POWERFUL
AND
BROADLY
APPLICABLE
KNUTH
INSIGHT
WAS
THAT
WE
CAN
CARRY
THESE
METHODS
THROUGH
TO
THE
LAST
DETAIL
IN
PRINCIPLE
TO
MAKE
DETAILED
ACCURATE
PREDICTIONS
TYPICAL
COMPUTER
SYSTEMS
ARE
EXTREMELY
COMPLEX
AND
CLOSE
ANALYSIS
IS
BEST
LEFT
FOR
EXPERTS
BUT
THE
SAME
METHODS
ARE
EFFECTIVE
FOR
DEVELOPING
APPROXIMATE
ESTI
MATES
OF
THE
RUNNING
TIME
OF
ANY
PROGRAM
A
ROCKET
SCIENTIST
NEEDS
TO
HAVE
SOME
IDEA
OF
WHETHER
A
TEST
FLIGHT
WILL
LAND
IN
THE
OCEAN
OR
IN
A
CITY
A
MEDICAL
RESEARCHER
NEEDS
TO
KNOW
WHETHER
A
DRUG
TRIAL
WILL
KILL
OR
CURE
ALL
THE
SUBJECTS
AND
ANY
SCIENTIST
OR
ENGINEER
USING
A
COMPUTER
PROGRAM
NEEDS
TO
HAVE
SOME
IDEA
OF
WHETHER
IT
WILL
RUN
FOR
A
SECOND
OR
FOR
A
YEAR
COPING
WITH
DEPENDENCE
ON
INPUTS
FOR
MANY
PROBLEMS
ONE
OF
THE
MOST
SIG
NIFICANT
OF
THE
CAVEATS
JUST
MENTIONED
IS
THE
DEPENDENCE
ON
INPUTS
BECAUSE
RUNNING
TIMES
CAN
VARY
WIDELY
THE
RUNNING
TIME
OF
THE
MODIFICATION
OF
THREESUM
MENTIONED
ON
THE
FACING
PAGE
RANGES
FROM
CONSTANT
TO
CUBIC
DEPENDING
ON
THE
INPUT
SO
A
CLOSER
ANALYSIS
IS
REQUIRED
IF
WE
WANT
TO
PREDICT
PERFORMANCE
WE
BRIEFLY
CONSIDER
HERE
SOME
OF
THE
APPROACHES
THAT
ARE
EFFECTIVE
AND
THAT
WE
WILL
CONSIDER
FOR
SPECIFIC
ALGORITHMS
LATER
IN
THE
BOOK
INPUT
MODELS
ONE
APPROACH
IS
TO
MORE
CAREFULLY
MODEL
THE
KIND
OF
INPUT
TO
BE
PRO
CESSED
IN
THE
PROBLEMS
THAT
WE
NEED
TO
SOLVE
FOR
EXAMPLE
WE
MIGHT
ASSUME
THAT
THE
NUMBERS
IN
THE
INPUT
TO
THREESUM
ARE
RANDOM
INT
VALUES
THIS
APPROACH
IS
CHALLENGING
FOR
TWO
REASONS
THE
MODEL
MAY
BE
UNREALISTIC
THE
ANALYSIS
MAY
BE
EXTREMELY
DIFFICULT
REQUIRING
MATHEMATICAL
SKILLS
QUITE
BE
YOND
THOSE
OF
THE
TYPICAL
STUDENT
OR
PROGRAMMER
THE
FIRST
OF
THESE
IS
THE
MORE
SIGNIFICANT
OFTEN
BECAUSE
THE
GOAL
OF
A
COMPUTATION
IS
TO
DISCOVER
CHARACTERISTICS
OF
THE
INPUT
FOR
EXAMPLE
IF
WE
ARE
WRITING
A
PROGRAM
TO
PROCESS
A
GENOME
HOW
CAN
WE
ESTIMATE
ITS
PERFORMANCE
ON
A
DIFFERENT
GENOME
A
GOOD
MODEL
DESCRIBING
THE
GENOMES
FOUND
IN
NATURE
IS
PRECISELY
WHAT
SCIENTISTS
SEEK
SO
ESTIMATING
THE
RUNNING
TIME
OF
OUR
PROGRAMS
ON
DATA
FOUND
IN
NATURE
ACTUALLY
AMOUNTS
TO
CON
TRIBUTING
TO
THAT
MODEL
THE
SECOND
CHALLENGE
LEADS
TO
A
FOCUS
ON
MATHEMATICAL
RESULTS
ONLY
FOR
OUR
MOST
IMPORTANT
ALGORITHMS
WE
WILL
SEE
SEVERAL
EXAMPLES
WHERE
A
SIMPLE
AND
TRACTABLE
INPUT
MODEL
IN
CONJUNCTION
WITH
CLASSICAL
MATHEMATICAL
ANALYSIS
HELPS
US
PREDICT
PERFORMANCE
WORST
CASE
PERFORMANCE
GUARANTEES
SOME
APPLICATIONS
DEMAND
THAT
THE
RUNNING
TIME
OF
A
PROGRAM
BE
LESS
THAN
A
CERTAIN
BOUND
NO
MATTER
WHAT
THE
INPUT
TO
PROVIDE
SUCH
PERFORMANCE
GUARANTEES
THEORETICIANS
TAKE
AN
EXTREMELY
PESSIMISTIC
VIEW
OF
THE
PERFORMANCE
OF
ALGORITHMS
WHAT
WOULD
THE
RUNNING
TIME
BE
IN
THE
WORST
CASE
FOR
EXAMPLE
SUCH
A
CONSERVATIVE
APPROACH
MIGHT
BE
APPROPRIATE
FOR
THE
SOFTWARE
THAT
RUNS
A
NUCLEAR
REACTOR
OR
A
PACEMAKER
OR
THE
BRAKES
IN
YOUR
CAR
WE
WANT
TO
GUARANTEE
THAT
SUCH
SOFTWARE
COMPLETES
ITS
JOB
WITHIN
THE
BOUNDS
THAT
WE
SET
BECAUSE
THE
RESULT
COULD
BE
CATASTROPHIC
IF
IT
DOES
NOT
SCIENTISTS
NORMALLY
DO
NOT
CONTEMPLATE
THE
WORST
CASE
WHEN
STUDYING
THE
NATURAL
WORLD
IN
BIOLOGY
THE
WORST
CASE
MIGHT
BE
THE
EXTINCTION
OF
THE
HUMAN
RACE
IN
PHYSICS
THE
WORST
CASE
MIGHT
BE
THE
END
OF
THE
UNIVERSE
BUT
THE
WORST
CASE
CAN
BE
A
VERY
REAL
CONCERN
IN
COMPUTER
SYSTEMS
WHERE
THE
INPUT
MAY
BE
GENERATED
BY
ANOTHER
POTENTIALLY
MALICIOUS
USER
RATHER
THAN
BY
NATURE
FOR
EXAMPLE
WEBSITES
THAT
DO
NOT
USE
ALGORITHMS
WITH
PERFORMANCE
GUARANTEES
ARE
SUBJECT
TO
DENIAL
OF
SERVICE
ATTACKS
WHERE
HACKERS
FLOOD
THEM
WITH
PATHOLOGICAL
REQUESTS
THAT
MAKE
THEM
RUN
MUCH
MORE
SLOWLY
THAN
PLANNED
ACCORDINGLY
MANY
OF
OUR
ALGORITHMS
ARE
DESIGNED
TO
PROVIDE
PERFORMANCE
GUARANTEES
SUCH
AS
THE
FOLLOWING
RANDOMIZED
ALGORITHMS
ONE
IMPORTANT
WAY
TO
PROVIDE
A
PERFORMANCE
GUARANTEE
IS
TO
INTRODUCE
RANDOMNESS
FOR
EXAMPLE
THE
QUICKSORT
ALGORITHM
FOR
SORTING
THAT
WE
STUDY
IN
SECTION
PERHAPS
THE
MOST
WIDELY
USED
SORTING
ALGORITHM
IS
QUADRATIC
IN
THE
WORST
CASE
BUT
RANDOMLY
ORDERING
THE
INPUT
GIVES
A
PROBABILISTIC
GUARANTEE
THAT
ITS
RUNNING
TIME
IS
LINEARITHMIC
EVERY
TIME
YOU
RUN
THE
ALGORITHM
IT
WILL
TAKE
A
DIFFERENT
AMOUNT
OF
TIME
BUT
THE
CHANCE
THAT
THE
TIME
WILL
NOT
BE
LINEARITHMIC
IS
SO
SMALL
AS
TO
BE
NEGLIGIBLE
SIMILARLY
THE
HASHING
ALGORITHMS
FOR
SYMBOL
TABLES
THAT
WE
STUDY
IN
SECTION
AGAIN
PERHAPS
THE
MOST
WIDELY
USED
APPROACH
ARE
LINEAR
TIME
IN
THE
WORST
CASE
BUT
CONSTANT
TIME
UNDER
A
PROBABILISTIC
GUARANTEE
THESE
GUARANTEES
ARE
NOT
ABSOLUTE
BUT
THE
CHANCE
THAT
THEY
ARE
INVALID
IS
LESS
THAN
THE
CHANCE
YOUR
COMPUTER
WILL
BE
STRUCK
BY
LIGHTNING
THUS
SUCH
GUARANTEES
ARE
AS
USEFUL
IN
PRACTICE
AS
WORST
CASE
GUARANTEES
SEQUENCES
OF
OPERATIONS
FOR
MANY
APPLICATIONS
THE
ALGORITHM
INPUT
MIGHT
BE
NOT
JUST
DATA
BUT
THE
SEQUENCE
OF
OPERATIONS
PERFORMED
BY
THE
CLIENT
FOR
EXAMPLE
A
PUSHDOWN
STACK
WHERE
THE
CLIENT
PUSHES
N
VALUES
THEN
POPS
THEM
ALL
MAY
HAVE
QUITE
DIFFERENT
PERFORMANCE
CHARACTERISTICS
FROM
ONE
WHERE
THE
CLIENT
ISSUES
AN
ALTERNATING
SEQUENCE
N
OF
PUSH
AND
POP
OPERATIONS
OUR
ANALYSIS
HAS
TO
TAKE
BOTH
SITUATIONS
INTO
ACCOUNT
OR
TO
INCLUDE
A
REASONABLE
MODEL
OF
THE
SEQUENCE
OF
OPERATIONS
AMORTIZED
ANALYSIS
ACCORDINGLY
ANOTHER
WAY
TO
PROVIDE
A
PERFORMANCE
GUARANTEE
IS
TO
AMORTIZE
THE
COST
BY
KEEPING
TRACK
OF
THE
TOTAL
COST
OF
ALL
OPERATIONS
DIVIDED
BY
THE
NUMBER
OF
OPERATIONS
IN
THIS
SETTING
WE
CAN
ALLOW
SOME
EXPENSIVE
OPERATIONS
WHILE
KEEPING
THE
AVERAGE
COST
OF
OPERATIONS
LOW
THE
PROTOTYPICAL
EXAMPLE
OF
THIS
TYPE
OF
ANALYSIS
IS
THE
STUDY
OF
THE
RESIZING
ARRAY
DATA
STRUCTURE
FOR
STACK
THAT
WE
CONSIDERED
IN
SECTION
ALGORITHM
ON
PAGE
FOR
SIMPLICITY
SUPPOSE
THAT
N
IS
A
POWER
OF
STARTING
WITH
AN
EMPTY
STRUCTURE
HOW
MANY
ARRAY
ENTRIES
ARE
ACCESSED
FOR
N
CONSECU
TIVE
CALLS
TO
PUSH
THIS
QUANTITY
IS
EASY
TO
CALCULATE
THE
NUMBER
OF
ARRAY
ACCESSES
IS
N
THE
FIRST
TERM
ACCOUNTS
FOR
THE
ARRAY
ACCESS
WITHIN
EACH
OF
THE
N
CALLS
TO
PUSH
THE
SUB
SEQUENT
TERMS
ACCOUNT
FOR
THE
ARRAY
ACCESSES
TO
INITIALIZE
THE
DATA
STRUCTURE
EACH
TIME
IT
DOUBLES
IN
SIZE
THUS
THE
AVERAGE
NUMBER
OF
ARRAY
ACCESS
ES
PER
OPERATION
IS
CONSTANT
EVEN
THOUGH
THE
LAST
OPERATION
TAKES
LINEAR
TIME
THIS
IS
KNOWN
AS
AN
AMORTIZED
ANALYSIS
BECAUSE
WE
SPREAD
THE
COST
OF
THE
FEW
EXPENSIVE
OPERATIONS
BY
ASSIGNING
A
NUMBER
OF
ADD
OPERATIONS
AMORTIZED
COST
OF
ADDING
TO
A
RANDOMBAG
PORTION
OF
IT
TO
EACH
OF
A
LARGE
NUMBER
OF
INEXPENSIVE
OPERATIONS
VISUALACCUMULATOR
PROVIDES
AN
EASY
WAY
TO
ILLUSTRATE
THE
PROCESS
SHOWN
ABOVE
THIS
KIND
OF
ANALYSIS
IS
WIDELY
APPLICABLE
IN
PARTICULAR
WE
USE
RESIZING
ARRAYS
AS
THE
UNDERLYING
DATA
STRUCTURE
FOR
SEVERAL
ALGORITHMS
THAT
WE
CONSIDER
LATER
IN
THIS
BOOK
IT
IS
THE
TASK
OF
THE
ALGORITHM
ANALYST
TO
DISCOVER
AS
MUCH
RELEVANT
INFORMATION
ABOUT
AN
ALGORITHM
AS
POSSIBLE
AND
IT
IS
THE
TASK
OF
THE
APPLICATIONS
PROGRAMMER
TO
APPLY
THAT
KNOWLEDGE
TO
DEVELOP
PROGRAMS
THAT
EFFECTIVELY
SOLVE
THE
PROBLEMS
AT
HAND
IDEALLY
WE
WANT
ALGORITHMS
THAT
LEAD
TO
CLEAR
AND
COMPACT
CODE
THAT
PROVIDES
BOTH
A
GOOD
GUARANTEE
AND
GOOD
PERFORMANCE
ON
INPUT
VALUES
OF
INTEREST
MANY
OF
THE
CLASSIC
ALGORITHMS
THAT
WE
CONSIDER
IN
THIS
CHAPTER
ARE
IMPORTANT
FOR
A
BROAD
VARIETY
OF
AP
PLICATIONS
PRECISELY
BECAUSE
THEY
HAVE
THESE
PROPERTIES
USING
THEM
AS
MODELS
YOU
CAN
DEVELOP
GOOD
SOLUTIONS
YOURSELF
FOR
TYPICAL
PROBLEMS
THAT
YOU
FACE
WHILE
PROGRAMMING
MEMORY
AS
WITH
RUNNING
TIME
A
PROGRAM
MEMORY
USAGE
CONNECTS
DIRECTLY
TO
THE
PHYSICAL
WORLD
A
SUBSTANTIAL
AMOUNT
OF
YOUR
COMPUTER
CIRCUITRY
ENABLES
YOUR
PRO
GRAM
TO
STORE
VALUES
AND
LATER
RETRIEVE
THEM
THE
MORE
VALUES
YOU
NEED
TO
HAVE
STORED
AT
ANY
GIVEN
INSTANT
THE
MORE
CIRCUITRY
YOU
NEED
YOU
PROBABLY
ARE
AWARE
OF
LIMITS
ON
MEMORY
USAGE
ON
YOUR
COMPUTER
EVEN
MORE
SO
THAN
FOR
TIME
BECAUSE
YOU
PROBABLY
HAVE
PAID
EXTRA
MONEY
TO
GET
MORE
MEMORY
MEMORY
USAGE
IS
WELL
DEFINED
FOR
JAVA
ON
YOUR
COMPUTER
EVERY
VALUE
REQUIRES
PRE
CISELY
THE
SAME
AMOUNT
OF
MEMORY
EACH
TIME
THAT
YOU
RUN
YOUR
PROGRAM
BUT
JAVA
IS
IMPLEMENTED
ON
A
VERY
WIDE
RANGE
OF
COMPUTATIONAL
DEVICES
AND
MEMORY
CONSUMP
TION
IS
IMPLEMENTATION
DEPENDENT
FOR
ECONOMY
WE
USE
THE
WORD
TYPICAL
TO
SIGNAL
THAT
VALUES
ARE
SUBJECT
TO
MACHINE
DEPENDENCIES
ONE
OF
JAVA
MOST
SIGNIFICANT
FEATURES
IS
ITS
MEMORY
ALLOCATION
SYSTEM
TYPE
BYTES
BOOLEAN
BYTE
CHAR
INT
FLOAT
LONG
DOUBLE
TYPICAL
MEMORY
REQUIREMENTS
FOR
PRIMITIVE
TYPES
WHICH
IS
SUPPOSED
TO
RELIEVE
YOU
FROM
HAVING
TO
WORRY
ABOUT
MEMORY
CERTAINLY
YOU
ARE
WELL
ADVISED
TO
TAKE
ADVANTAGE
OF
THIS
FEATURE
WHEN
AP
PROPRIATE
STILL
IT
IS
YOUR
RESPONSIBILITY
TO
KNOW
AT
LEAST
APPROXIMATELY
WHEN
A
PROGRAM
MEMORY
REQUIREMENTS
WILL
PREVENT
YOU
FROM
SOLVING
A
GIVEN
PROBLEM
ANALYZING
MEMORY
USAGE
IS
MUCH
EASIER
THAN
ANALYZING
RUNNING
TIME
PRIMARILY
BECAUSE
NOT
AS
MANY
PROGRAM
STATEMENTS
ARE
INVOLVED
JUST
DEC
LARATIONS
AND
BECAUSE
THE
ANALYSIS
REDUCES
COMPLEX
OBJECTS
TO
THE
PRIMI
TIVE
TYPES
WHOSE
MEMORY
USAGE
IS
WELL
DEFINED
AND
SIMPLE
TO
UNDERSTAND
WE
CAN
COUNT
UP
THE
NUMBER
OF
VARIABLES
AND
WEIGHT
THEM
BY
THE
NUMBER
OF
BYTES
ACCORDING
TO
THEIR
TYPE
FOR
EXAMPLE
SINCE
THE
JAVA
INT
DATA
TYPE
IS
THE
SET
OF
INTEGER
VALUES
BETWEEN
AND
A
GRAND
TOTAL
OF
DIFFERENT
VALUES
TYPICAL
JAVA
IMPLEMENTATIONS
USE
BITS
TO
REPRESENT
INT
VALUES
SIMILAR
CONSIDERATIONS
HOLD
FOR
OTHER
PRIMITIVE
TYPES
TYPICAL
JAVA
IMPLEMENTATIONS
USE
BIT
BYTES
REPRESENTING
EACH
CHAR
VALUE
WITH
BYTES
BITS
EACH
INT
VALUE
WITH
BYTES
BITS
EACH
DOUBLE
AND
EACH
LONG
VALUE
WITH
BYTES
BITS
AND
EACH
BOOLEAN
VALUE
WITH
BYTE
SINCE
COMPUTERS
TYPICALLY
ACCESS
MEMORY
ONE
BYTE
AT
A
TIME
COMBINED
WITH
KNOWLEDGE
OF
THE
AMOUNT
OF
MEMORY
AVAILABLE
YOU
CAN
CALCULATE
LIMITATIONS
FROM
THESE
VALUES
FOR
EXAMPLE
IF
YOU
HAVE
OF
MEMORY
ON
YOUR
COMPUTER
BILLION
BYTES
YOU
CANNOT
FIT
MORE
THAN
ABOUT
MIL
LION
INT
VALUES
OR
MILLION
DOUBLE
VALUES
IN
MEMORY
AT
ANY
ONE
TIME
ON
THE
OTHER
HAND
ANALYZING
MEMORY
USAGE
IS
SUBJECT
TO
VARIOUS
DIFFERENCES
IN
MA
CHINE
HARDWARE
AND
IN
JAVA
IMPLEMENTATIONS
SO
YOU
SHOULD
CONSIDER
THE
SPECIFIC
EX
AMPLES
THAT
WE
GIVE
AS
INDICATIVE
OF
HOW
YOU
MIGHT
GO
ABOUT
DETERMINING
MEMORY
USAGE
WHEN
WARRANTED
NOT
THE
FINAL
WORD
FOR
YOUR
COMPUTER
FOR
EXAMPLE
MANY
DATA
STRUCTURES
INVOLVE
REPRESENTATION
OF
MACHINE
ADDRESSES
AND
THE
AMOUNT
OF
MEMORY
NEEDED
FOR
A
MACHINE
ADDRESS
VARIES
FROM
MACHINE
TO
MACHINE
FOR
CONSISTENCY
WE
ASSUME
THAT
BYTES
ARE
NEEDED
TO
REPRESENT
ADDRESSES
AS
IS
TYPICAL
FOR
BIT
ARCHITECTURES
THAT
ARE
NOW
WIDELY
USED
RECOGNIZING
THAT
MANY
OLDER
MACHINES
USE
A
BIT
ARCHITECTURE
THAT
WOULD
INVOLVE
JUST
BYTES
PER
MACHINE
ADDRESS
OBJECTS
TO
DETERMINE
THE
MEMORY
USAGE
OF
AN
OBJECT
WE
ADD
THE
AMOUNT
OF
MEMORY
USED
BY
EACH
INSTANCE
VARIABLE
TO
THE
OVERHEAD
ASSOCIATED
WITH
EACH
OBJECT
TYPICALLY
BYTES
THE
OVERHEAD
INCLUDES
A
REFERENCE
TO
THE
OBJECT
CLASS
GARBAGE
COLLECTION
INFORMATION
AND
SYNCHRONIZATION
INFORMATION
MOREOVER
THE
MEMORY
USAGE
IS
TYPICALLY
PADDED
TO
BE
A
MULTIPLE
OF
BYTES
MACHINE
WORDS
ON
A
BIT
MACHINE
FOR
EXAMPLE
AN
INTEGER
OBJECT
USES
BYTES
BYTES
OF
OVERHEAD
BYTES
FOR
ITS
INT
INSTANCE
VARIABLE
AND
BYTES
OF
PADDING
SIMILARLY
A
DATE
PAGE
OBJECT
ALSO
USES
BYTES
BYTES
OF
OVERHEAD
BYTES
FOR
EACH
OF
ITS
THREE
INT
INSTANCE
VARIABLES
AND
BYTES
OF
PADDING
A
REF
ERENCE
TO
AN
OBJECT
TYPICALLY
IS
A
MEMORY
ADDRESS
AND
THUS
USES
BYTES
OF
MEMORY
FOR
EXAMPLE
A
COUNTER
PAGE
OBJECT
USES
BYTES
BYTES
OF
OVERHEAD
BYTES
FOR
ITS
STRING
INSTANCE
VARIABLE
A
REFERENCE
BYTES
FOR
ITS
INT
INSTANCE
VARIABLE
AND
BYTES
OF
PAD
DING
WHEN
WE
ACCOUNT
FOR
THE
MEMORY
FOR
A
REFERENCE
WE
ACCOUNT
SEPARATELY
FOR
THE
MEMORY
FOR
THE
OBJECT
ITSELF
SO
THIS
TOTAL
DOES
NOT
COUNT
THE
MEMORY
FOR
THE
STRING
VALUE
INTEGER
WRAPPER
OBJECT
PUBLIC
CLASS
INTEGER
PRIVATE
INT
X
DATE
OBJECT
PUBLIC
CLASS
DATE
PRIVATE
INT
DAY
PRIVATE
INT
MONTH
PRIVATE
INT
YEAR
COUNTER
OBJECT
PUBLIC
CLASS
COUNTER
PRIVATE
STRING
NAME
PRIVATE
INT
COUNT
NODE
OBJECT
INNER
CLASS
PUBLIC
CLASS
NODE
PRIVATE
ITEM
ITEM
PRIVATE
NODE
NEXT
BYTES
BYTES
OBJECT
OVERHEAD
DAY
MONTH
YEAR
PADDING
BYTES
OBJECT
OVERHEAD
NAME
COUNT
PADDING
BYTES
OBJECT
OVERHEAD
EXTRA
OVERHEAD
ITEM
NEXT
INT
VALUE
INT
VALUES
STRING
REFERENCE
INT
VALUE
REFERENCES
LINKED
LISTS
A
NESTED
NON
STATIC
INNER
CLASS
SUCH
AS
OUR
NODE
CLASS
PAGE
REQUIRES
AN
EXTRA
BYTES
OF
TYPICAL
OBJECT
MEMORY
REQUIREMENTS
OVERHEAD
FOR
A
REFERENCE
TO
THE
ENCLOSING
INSTANCE
THUS
A
NODE
OBJECT
USES
BYTES
BYTES
OF
OBJECT
OVERHEAD
BYTES
EACH
FOR
THE
REFERENCES
TO
THE
ITEM
AND
NODE
OB
JECTS
AND
BYTES
FOR
THE
EXTRA
OVERHEAD
THUS
SINCE
AN
INTEGER
OBJECT
USES
BYTES
A
STACK
WITH
N
INTEGERS
BUILT
WITH
A
LINKED
LIST
REPRESENTATION
ALGORITHM
USES
BYTES
THE
USUAL
FOR
OBJECT
OVERHEAD
FOR
STACK
FOR
ITS
REFERENCE
INSTANCE
VARI
ABLE
FOR
ITS
INT
INSTANCE
VARIABLE
FOR
PADDING
AND
FOR
EACH
ENTRY
FOR
A
NODE
AND
FOR
AN
INTEGER
ARRAYS
TYPICAL
MEMORY
REQUIREMENTS
FOR
VARIOUS
TYPES
OF
ARRAYS
IN
JAVA
ARE
SUMMA
RIZED
IN
THE
DIAGRAMS
ON
THE
FACING
PAGE
ARRAYS
IN
JAVA
ARE
IMPLEMENTED
AS
OBJECTS
TYPICALLY
WITH
EXTRA
OVERHEAD
FOR
THE
LENGTH
AN
ARRAY
OF
PRIMITIVE
TYPE
VALUES
TYPICALLY
REQUIRES
BYTES
OF
HEADER
INFORMATION
BYTES
OF
OBJECT
OVERHEAD
BYTES
FOR
THE
LENGTH
AND
BYTES
OF
PADDING
PLUS
THE
MEMORY
NEEDED
TO
STORE
THE
VALUES
FOR
EX
AMPLE
AN
ARRAY
OF
N
INT
VALUES
USES
BYTES
ROUNDED
UP
TO
BE
A
MULTIPLE
OF
AND
AN
ARRAY
OF
N
DOUBLE
VALUES
USES
BYTES
AN
ARRAY
OF
OBJECTS
IS
AN
ARRAY
OF
REFERENCES
TO
THE
OBJECTS
SO
WE
NEED
TO
ADD
THE
SPACE
FOR
THE
REFERENCES
TO
THE
SPACE
REQUIRED
FOR
THE
OBJECTS
FOR
EXAMPLE
AN
ARRAY
OF
N
DATE
OBJECTS
PAGE
USES
BYTES
ARRAY
OVERHEAD
PLUS
BYTES
REFERENCES
PLUS
BYTES
FOR
EACH
OBJECT
AND
BYTES
OF
PADDING
FOR
A
GRAND
TOTAL
OF
BYTES
A
TWO
DIMENSIONAL
ARRAY
IS
AN
ARRAY
OF
AR
RAYS
EACH
ARRAY
IS
AN
OBJECT
FOR
EXAMPLE
A
TWO
DIMENSIONAL
M
BY
N
ARRAY
OF
DOUBLE
VALUES
USES
BYTES
OVERHEAD
FOR
THE
ARRAY
OF
ARRAYS
PLUS
M
BYTES
REFERENCES
TO
THE
ROW
ARRAYS
PLUS
M
TIMES
BYTES
OVERHEAD
FROM
THE
ROW
ARRAYS
PLUS
M
TIMES
N
TIMES
BYTES
FOR
THE
N
DOUBLE
VALUES
IN
EACH
OF
THE
M
ROWS
FOR
A
GRAND
TOTAL
OF
BYTES
WHEN
ARRAY
ENTRIES
ARE
OBJECTS
A
SIMILAR
ACCOUNTING
LEADS
TO
A
TOTAL
OF
BYTES
FOR
THE
ARRAY
OF
ARRAYS
FILLED
WITH
REFERENCES
TO
OBJECTS
PLUS
THE
MEMORY
FOR
THE
OBJECTS
THEMSELVES
STRING
OBJECTS
WE
ACCOUNT
FOR
MEMORY
IN
JAVA
STRING
OBJECTS
IN
THE
SAME
WAY
AS
FOR
ANY
OTHER
OBJECT
EXCEPT
THAT
ALIASING
IS
COMMON
FOR
STRINGS
THE
STANDARD
STRING
IMPLEMENTATION
HAS
FOUR
INSTANCE
VARIABLES
A
REFERENCE
TO
A
CHARACTER
ARRAY
BYTES
AND
THREE
INT
VALUES
BYTES
EACH
THE
FIRST
INT
VALUE
IS
AN
OFFSET
INTO
THE
CHARACTER
AR
RAY
THE
SECOND
IS
A
COUNT
THE
STRING
LENGTH
IN
TERMS
OF
THE
INSTANCE
VARIABLE
NAMES
IN
THE
DRAWING
ON
THE
FACING
PAGE
THE
STRING
THAT
IS
REPRESENTED
CONSISTS
OF
THE
CHARACTERS
VALUE
OFFSET
THROUGH
VALUE
OFFSET
COUNT
THE
THIRD
INT
VALUE
IN
STRING
OBJECTS
IS
A
HASH
CODE
THAT
SAVES
RECOMPUTATION
IN
CERTAIN
CIRCUMSTANCES
THAT
NEED
NOT
CONCERN
US
NOW
THEREFORE
EACH
STRING
OBJECT
USES
A
TOTAL
OF
BYTES
BYTES
FOR
OBJECT
OVERHEAD
PLUS
BYTES
FOR
EACH
OF
THE
THREE
INT
INSTANCE
VARIABLES
PLUS
BYTES
FOR
THE
ARRAY
REFERENCE
PLUS
BYTES
OF
PADDING
THIS
SPACE
REQUIREMENT
IS
IN
ADDITION
TO
THE
SPACE
NEEDED
FOR
THE
CHARACTERS
THEMSELVES
WHICH
ARE
IN
THE
ARRAY
THE
SPACE
NEEDED
FOR
THE
CHARACTERS
IS
ACCOUNTED
FOR
SEPARATELY
BECAUSE
THE
CHAR
ARRAY
IS
OFTEN
SHARED
AMONG
STRINGS
SINCE
STRING
OBJECTS
ARE
IMMUTABLE
THIS
ARRANGEMENT
ALLOWS
THE
IMPLE
MENTATION
TO
SAVE
MEMORY
WHEN
STRING
OBJECTS
HAVE
THE
SAME
UNDERLYING
VALUE
STRING
VALUES
AND
SUBSTRINGS
A
STRING
OF
LENGTH
N
TYPICALLY
USES
BYTES
FOR
THE
STRING
OBJECT
PLUS
BYTES
FOR
THE
ARRAY
THAT
CONTAINS
THE
CHARACTERS
FOR
A
TOTAL
OF
BYTES
BUT
IT
IS
TYPICAL
IN
STRING
PROCESSING
TO
WORK
WITH
SUBSTRINGS
AND
JAVA
REPRESENTATION
IS
MEANT
TO
ALLOW
US
TO
DO
SO
WITHOUT
HAVING
TO
MAKE
COPIES
OF
ARRAY
OF
INT
VALUES
ARRAY
OF
DOUBLE
VALUES
INT
A
NEW
INT
N
DOUBLE
C
NEW
DOUBLE
N
A
C
BYTES
BYTES
INT
VALUE
BYTES
TOTAL
N
EVEN
N
INT
VALUES
BYTES
INT
VALUE
BYTES
TOTAL
N
DOUBLE
VALUES
BYTES
BYTES
BYTES
BYTES
ARRAY
OF
OBJECTS
DOUBLE
DATE
DOUBLE
BYTES
OBJECT
OVERHEAD
DAY
MONTH
YEAR
PADDING
ARRAY
OF
ARRAYS
TWO
DIMENSIONAL
ARRAY
DOUBLE
T
T
NEW
DOUBLE
M
N
T
BYTES
INT
VALUE
BYTES
M
REFERENCES
BYTES
TOTAL
MX
N
DOUBLE
VALUES
BYTES
TYPICAL
MEMORY
REQUIREMENTS
FOR
ARRAYS
OF
INT
VALUES
DOUBLE
VALUES
OBJECTS
AND
ARRAYS
STRING
OBJECT
JAVA
LIBRARY
PUBLIC
CLASS
STRING
BYTES
THE
STRING
CHARACTERS
WHEN
YOU
USE
THE
SUBSTRING
METHOD
YOU
CREATE
A
NEW
STRING
OBJECT
BYTES
PRIVATE
CHAR
VALUE
PRIVATE
INT
OFFSET
PRIVATE
INT
COUNT
PRIVATE
INT
HASH
SUBSTRING
EXAMPLE
STRING
GENOME
CGCCTGGCGTCTGTAC
REFERENCE
INT
VALUES
BUT
REUSE
THE
SAME
VALUE
ARRAY
SO
A
SUBSTRING
OF
AN
EXISTING
STRING
TAKES
JUST
BYTES
THE
CHARACTER
ARRAY
CONTAINING
THE
ORIGINAL
STRING
IS
ALIASED
IN
THE
OBJECT
FOR
THE
SUBSTRING
THE
OFFSET
AND
LENGTH
FIELDS
IDENTIFY
THE
SUBSTRING
IN
OTHER
WORDS
A
SUBSTRING
TAKES
CONSTANT
EX
TRA
MEMORY
AND
FORMING
A
SUBSTRING
TAKES
CONSTANT
TIME
EVEN
WHEN
THE
LENGTHS
OF
THE
STRING
AND
THE
SUBSTRING
ARE
HUGE
A
NAIVE
REPRESENTATION
THAT
REQUIRES
COPYING
STRING
CODON
GENOME
SUBSTRING
GENOME
R
ES
A
STRING
AND
A
SUBSTRING
CHARACTERS
TO
MAKE
SUBSTRINGS
WOULD
TAKE
LINEAR
TIME
AND
SPACE
THE
ABILITY
TO
CREATE
A
SUBSTRING
USING
SPACE
AND
TIME
INDEPENDENT
OF
ITS
LENGTH
IS
THE
KEY
TO
EFFI
CIENCY
IN
MANY
BASIC
STRING
PROCESSING
ALGORITHMS
THESE
BASIC
MECHANISMS
ARE
EFFECTIVE
FOR
ESTI
MATING
THE
MEMORY
USAGE
OF
A
GREAT
MANY
PROGRAMS
BUT
THERE
ARE
NUMEROUS
COMPLICATING
FACTORS
THAT
CAN
MAKE
THE
TASK
SIGNIFICANTLY
MORE
DIFFICULT
WE
HAVE
ALREADY
NOTED
THE
POTENTIAL
EFFECT
OF
ALIASING
MORE
OVER
MEMORY
CONSUMPTION
IS
A
COMPLICATED
DYNAMIC
PROCESS
WHEN
FUNCTION
CALLS
ARE
INVOLVED
BECAUSE
THE
SYSTEM
MEMORY
ALLOCATION
MECHANISM
PLAYS
A
MORE
IMPORTANT
ROLE
WITH
MORE
SYSTEM
DEPENDENCIES
FOR
EXAMPLE
WHEN
YOUR
PROGRAM
CALLS
A
METHOD
THE
SYS
TEM
ALLOCATES
THE
MEMORY
NEEDED
FOR
THE
METHOD
FOR
ITS
LOCAL
VARIABLES
FROM
A
SPECIAL
AREA
OF
MEMORY
CALLED
THE
STACK
A
SYSTEM
PUSHDOWN
STACK
AND
WHEN
THE
METHOD
RETURNS
TO
THE
CALLER
THE
MEMORY
IS
RETURNED
TO
THE
STACK
FOR
THIS
REASON
CREATING
ARRAYS
OR
OTHER
LARGE
OBJECTS
IN
RECURSIVE
PROGRAMS
IS
DANGEROUS
SINCE
EACH
RECURSIVE
CALL
IMPLIES
SIGNIFICANT
MEMORY
USAGE
WHEN
YOU
CREATE
AN
OBJECT
WITH
NEW
THE
SYSTEM
ALLOCATES
THE
MEMORY
NEEDED
FOR
THE
OBJECT
FROM
ANOTHER
SPECIAL
AREA
OF
MEMORY
KNOWN
AS
THE
HEAP
NOT
THE
SAME
AS
THE
BINARY
HEAP
DATA
STRUCTURE
WE
CONSIDER
IN
SECTION
AND
YOU
MUST
REMEMBER
THAT
EVERY
OBJECT
LIVES
UNTIL
NO
REFERENCES
TO
IT
REMAIN
AT
WHICH
POINT
A
SYSTEM
PROCESS
KNOWN
AS
GARBAGE
COLLECTION
RECLAIMS
ITS
MEMORY
FOR
THE
HEAP
SUCH
DYNAMICS
CAN
MAKE
THE
TASK
OF
PRE
CISELY
ESTIMATING
MEMORY
USAGE
OF
A
PROGRAM
CHALLENGING
PERSPECTIVE
GOOD
PERFORMANCE
IS
IMPORTANT
AN
IMPOSSIBLY
SLOW
PROGRAM
IS
AL
MOST
AS
USELESS
AS
AN
INCORRECT
ONE
SO
IT
IS
CERTAINLY
WORTHWHILE
TO
PAY
ATTENTION
TO
THE
COST
AT
THE
OUTSET
TO
HAVE
SOME
IDEA
OF
WHICH
KINDS
OF
PROBLEMS
YOU
MIGHT
FEASIBLY
ADDRESS
IN
PARTICULAR
IT
IS
ALWAYS
WISE
TO
HAVE
SOME
IDEA
OF
WHICH
CODE
CONSTITUTES
THE
INNER
LOOP
OF
YOUR
PROGRAMS
PERHAPS
THE
MOST
COMMON
MISTAKE
MADE
IN
PROGRAMMING
IS
TO
PAY
TOO
MUCH
AT
TENTION
TO
PERFORMANCE
CHARACTERISTICS
YOUR
FIRST
PRIORITY
IS
TO
MAKE
YOUR
CODE
CLEAR
AND
CORRECT
MODIFYING
A
PROGRAM
FOR
THE
SOLE
PURPOSE
OF
SPEEDING
IT
UP
IS
BEST
LEFT
FOR
EXPERTS
INDEED
DOING
SO
IS
OFTEN
COUNTERPRODUCTIVE
AS
IT
TENDS
TO
CREATE
CODE
THAT
IS
COMPLICATED
AND
DIFFICULT
TO
UNDERSTAND
C
A
R
HOARE
THE
INVENTOR
OF
QUICKSORT
AND
A
LEADING
PROPONENT
OF
WRITING
CLEAR
AND
CORRECT
CODE
ONCE
SUMMARIZED
THIS
IDEA
BY
SAYING
THAT
PREMATURE
OPTIMIZATION
IS
THE
ROOT
OF
ALL
EVIL
TO
WHICH
KNUTH
ADDED
THE
QUALIFIER
OR
AT
LEAST
MOST
OF
IT
IN
PROGRAMMING
BEYOND
THAT
IMPROVING
THE
RUNNING
TIME
IS
NOT
WORTHWHILE
IF
THE
AVAILABLE
COST
BENEFITS
ARE
INSIGNIFICANT
FOR
EXAMPLE
IM
PROVING
THE
RUNNING
TIME
OF
A
PROGRAM
BY
A
FACTOR
OF
IS
INCONSEQUENTIAL
IF
THE
RUN
NING
TIME
IS
ONLY
AN
INSTANT
EVEN
WHEN
A
PROGRAM
TAKES
A
FEW
MINUTES
TO
RUN
THE
TOTAL
TIME
REQUIRED
TO
IMPLEMENT
AND
DEBUG
AN
IMPROVED
ALGORITHM
MIGHT
BE
SUBSTANTIALLY
MORE
THAN
THE
TIME
REQUIRED
SIMPLY
TO
RUN
A
SLIGHTLY
SLOWER
ONE
YOU
MAY
AS
WELL
LET
THE
COMPUTER
DO
THE
WORK
WORSE
YOU
MIGHT
SPEND
A
CONSIDERABLE
AMOUNT
OF
TIME
AND
EFFORT
IMPLEMENTING
IDEAS
THAT
SHOULD
IN
THEORY
IMPROVE
A
PROGRAM
BUT
DO
NOT
DO
SO
IN
PRACTICE
PERHAPS
THE
SECOND
MOST
COMMON
MISTAKE
MADE
IN
PROGRAMMING
IS
TO
IGNORE
PER
FORMANCE
CHARACTERISTICS
FASTER
ALGORITHMS
ARE
OFTEN
MORE
COMPLICATED
THAN
BRUTE
FORCE
ONES
SO
YOU
MIGHT
BE
TEMPTED
TO
ACCEPT
A
SLOWER
ALGORITHM
TO
AVOID
HAVING
TO
DEAL
WITH
MORE
COMPLICATED
CODE
HOWEVER
YOU
CAN
SOMETIMES
REAP
HUGE
SAVINGS
WITH
JUST
A
FEW
LINES
OF
GOOD
CODE
USERS
OF
A
SURPRISING
NUMBER
OF
COMPUTER
SYSTEMS
LOSE
SUBSTANTIAL
TIME
UNKNOWINGLY
WAITING
FOR
BRUTE
FORCE
QUADRATIC
ALGORITHMS
TO
FINISH
SOLVING
A
PROBLEM
WHEN
LINEAR
OR
LINEARITHMIC
ALGORITHMS
ARE
AVAILABLE
THAT
COULD
SOLVE
THE
PROBLEM
IN
A
FRACTION
OF
THE
TIME
WHEN
WE
ARE
DEALING
WITH
HUGE
PROBLEM
SIZES
WE
OFTEN
HAVE
NO
CHOICE
BUT
TO
SEEK
BETTER
ALGORITHMS
WE
GENERALLY
TAKE
AS
IMPLICIT
THE
METHODOLOGY
DESCRIBED
IN
THIS
SECTION
TO
ESTIMATE
MEMORY
USAGE
AND
TO
DEVELOP
AN
ORDER
OF
GROWTH
HYPOTHESIS
OF
THE
RUNNING
TIME
FROM
A
TILDE
APPROXIMATION
RESULTING
FROM
A
MATHEMATICAL
ANALYSIS
WITHIN
A
COST
MODEL
AND
TO
CHECK
THOSE
HYPOTHESES
WITH
EXPERIMENTS
IMPROVING
A
PROGRAM
TO
MAKE
IT
MORE
CLEAR
EFFICIENT
AND
ELEGANT
SHOULD
BE
YOUR
GOAL
EVERY
TIME
THAT
YOU
WORK
ON
IT
IF
YOU
PAY
ATTENTION
TO
THE
COST
ALL
THE
WAY
THROUGH
THE
DEVELOPMENT
OF
A
PROGRAM
YOU
WILL
REAP
THE
BENEFITS
EVERY
TIME
YOU
USE
IT
Q
WHY
NOT
USE
STDRANDOM
TO
GENERATE
RANDOM
VALUES
INSTEAD
OF
MAINTAINING
THE
FILE
TXT
A
IT
IS
EASIER
TO
DEBUG
CODE
IN
DEVELOPMENT
AND
TO
REPRODUCE
EXPERIMENTS
STDRANDOM
PRODUCES
DIFFERENT
VALUES
EACH
TIME
IT
IS
CALLED
SO
RUNNING
A
PROGRAM
AFTER
FIXING
A
BUG
MAY
NOT
TEST
THE
FIX
YOU
COULD
USE
THE
INITIALIZE
METHOD
IN
STDRANDOM
TO
ADDRESS
THIS
PROBLEM
BUT
A
REFERENCE
FILE
SUCH
AS
TXT
MAKES
IT
EASIER
TO
ADD
TEST
CASES
WHILE
DEBUGGING
ALSO
DIFFERENT
PROGRAMMERS
CAN
COMPARE
PERFORMANCE
ON
DIFFERENT
COMPUTERS
WITHOUT
WORRYING
ABOUT
THE
INPUT
MODEL
ONCE
YOU
HAVE
DEBUGGED
A
PRO
GRAM
AND
HAVE
A
GOOD
IDEA
OF
HOW
IT
PERFORMS
IT
IS
CERTAINLY
WORTHWHILE
TO
TEST
IT
ON
RANDOM
DATA
FOR
EXAMPLE
DOUBLINGTEST
AND
DOUBLINGRATIO
TAKE
THIS
APPROACH
Q
I
RAN
DOUBLINGRATIO
ON
MY
COMPUTER
BUT
THE
RESULTS
WERE
NOT
AS
CONSISTENT
AS
IN
THE
BOOK
SOME
OF
THE
RATIOS
WERE
NOT
CLOSE
TO
WHY
A
THATISWHYWEDISCUSSED
CAVEATS
ONPAGE
MOSTLIKELY
YOURCOMPUTER
SOPERATING
SYSTEM
DECIDED
TO
DO
SOMETHING
ELSE
DURING
THE
EXPERIMENT
ONE
WAY
TO
MITIGATE
SUCH
PROBLEMS
IS
TO
INVEST
MORE
TIME
IN
MORE
EXPERIMENTS
FOR
EXAMPLE
YOU
COULD
CHANGE
DOUBLINGTEST
TO
RUN
THE
EXPERIMENTS
TIMES
FOR
EACH
N
GIVING
A
MUCH
MORE
AC
CURATE
ESTIMATE
FOR
THE
RUNNING
TIME
FOR
EACH
SIZE
SEE
EXERCISE
Q
WHAT
EXACTLY
DOES
AS
N
GROWS
MEAN
IN
THE
DEFINITION
OF
THE
TILDE
NOTATION
A
THE
FORMAL
DEFINITION
OF
F
N
G
N
IS
LIMN
F
N
G
N
Q
I
VE
SEEN
OTHER
NOTATIONS
FOR
DESCRIBING
ORDER
OF
GROWTH
WHAT
THE
STORY
A
THE
BIG
OH
NOTATION
IS
WIDELY
USED
WE
SAY
THAT
F
N
IS
O
G
N
IF
THERE
EXIST
CONSTANTS
C
AND
SUCH
THAT
F
N
C
G
N
FOR
ALL
N
THIS
NOTATION
IS
VERY
USE
FUL
IN
PROVIDING
ASYMPTOTIC
UPPER
BOUNDS
ON
THE
PERFORMANCE
OF
ALGORITHMS
WHICH
IS
IMPORTANT
IN
THE
THEORY
OF
ALGORITHMS
BUT
IT
IS
NOT
USEFUL
FOR
PREDICTING
PERFORMANCE
OR
FOR
COMPARING
ALGORITHMS
Q
WHY
NOT
A
THE
PRIMARY
REASON
IS
THAT
IT
DESCRIBES
ONLY
AN
UPPER
BOUND
ON
THE
RUNNING
TIME
ACTUAL
PERFORMANCE
MIGHT
BE
MUCH
BETTER
THE
RUNNING
TIME
OF
AN
ALGORITHM
MIGHT
BE
BOTH
O
N
AND
A
N
LOG
N
AS
A
RESULT
IT
CANNOT
BE
USED
TO
JUSTIFY
TESTS
LIKE
OUR
DOUBLING
RATIO
TEST
SEE
PROPOSITION
C
ON
PAGE
Q
SO
WHY
IS
THE
BIG
OH
NOTATION
SO
WIDELY
USED
A
IT
FACILITATES
DEVELOPMENT
OF
BOUNDS
ON
THE
ORDER
OF
GROWTH
EVEN
FOR
COMPLICATED
ALGORITHMS
FOR
WHICH
MORE
PRECISE
ANALYSIS
MIGHT
NOT
BE
FEASIBLE
MOREOVER
IT
IS
COM
PATIBLE
WITH
THE
BIG
OMEGA
AND
BIG
THETA
NOTATIONS
THAT
THEORETICAL
COMPUTER
SCI
ENTISTS
USE
TO
CLASSIFY
ALGORITHMS
BY
BOUNDING
THEIR
WORST
CASE
PERFORMANCE
WE
SAY
THAT
F
N
IS
D
G
N
IF
THERE
EXIST
CONSTANTS
C
AND
SUCH
THAT
F
N
C
G
N
FOR
N
AND
IF
F
N
IS
O
G
N
AND
D
G
N
WE
SAY
THAT
F
N
IS
G
N
THE
BIG
OMEGA
NOTATION
IS
TYPICALLY
USED
TO
DESCRIBE
A
LOWER
BOUND
ON
THE
WORST
CASE
AND
THE
BIG
THETA
NOTATION
IS
TYPICALLY
USED
TO
DESCRIBE
THE
PERFORMANCE
OF
ALGORITHMS
THAT
ARE
OPTIMAL
IN
THE
SENSE
THAT
NO
ALGORITHM
CAN
HAVE
BETTER
ASYMPTOTIC
WORST
CASE
ORDER
OF
GROWTH
OPTIMAL
ALGORITHMS
ARE
CERTAINLY
WORTH
CONSIDERING
IN
PRACTICAL
APPLICA
TIONS
BUT
THERE
ARE
MANY
OTHER
CONSIDERATIONS
AS
YOU
WILL
SEE
Q
AREN
T
UPPER
BOUNDS
ON
ASYMPTOTIC
PERFORMANCE
IMPORTANT
A
YES
BUT
WE
PREFER
TO
DISCUSS
PRECISE
RESULTS
IN
TERMS
OF
FREQUENCY
OF
STATEMENT
EX
CEUTION
WITH
RESPECT
TO
COST
MODELS
BECAUSE
THEY
PROVIDE
MORE
INFORMATION
ABOUT
ALGORITHM
PERFORMANCE
AND
BECAUSE
DERIVING
SUCH
RESULTS
IS
FEASIBLE
FOR
THE
ALGORITHMS
THAT
WE
DISCUSS
FOR
EXAMPLE
WE
SAY
THREESUM
USES
N
ARRAY
ACCESSES
AND
THE
NUMBER
OF
TIMES
CNT
IS
EXECUTED
IN
THREESUM
IS
N
IN
THE
WORST
CASE
WHICH
IS
A
BIT
MORE
VERBOSE
BUT
MUCH
MORE
INFORMATIVE
THAN
THE
STATEMENT
THE
RUNNING
TIME
OF
THREESUM
IS
O
N
Q
WHEN
THE
ORDER
OF
GROWTH
OF
THE
RUNNING
TIME
OF
AN
ALGORITHM
IS
N
LOG
N
THE
DOU
BLING
TEST
WILL
LEAD
TO
THE
HYPOTHESIS
THAT
THE
RUNNING
TIME
IS
A
N
FOR
A
CONSTANT
A
ISN
T
THAT
A
PROBLEM
A
WE
HAVE
TO
BE
CAREFUL
NOT
TO
TRY
TO
INFER
THAT
THE
EXPERIMENTAL
DATA
IMPLIES
A
PAR
TICULAR
MATHEMATICAL
MODEL
BUT
WHEN
WE
ARE
JUST
PREDICTING
PERFORMANCE
THIS
IS
NOT
REALLY
A
PROBLEM
FOR
EXAMPLE
WHEN
N
IS
BETWEEN
AND
THE
PLOTS
OF
AND
N
LG
N
ARE
VERY
CLOSE
TO
ONE
ANOTHER
THE
DATA
FITS
BOTH
CURVES
AS
N
INCREASES
THE
CURVES
BECOME
CLOSER
TOGETHER
IT
ACTUALLY
REQUIRES
SOME
CARE
TO
EXPERIMENTALLY
CHECK
THE
HYPOTHESIS
THAT
AN
ALGORITHM
RUNNING
TIME
IS
LINEARITHMIC
BUT
NOT
LINEAR
Q
DOES
INT
A
NEW
INT
N
COUNT
AS
N
ARRAY
ACCESSES
TO
INITIALIZE
ENTRIES
TO
A
MOST
LIKELY
YES
SO
WE
MAKE
THAT
ASSUMPTION
IN
THIS
BOOK
THOUGH
A
SOPHISTICATED
COMPILER
IMPLEMENTATION
MIGHT
TRY
TO
AVOID
THIS
COST
FOR
HUGE
SPARSE
ARRAYS
SHOW
THAT
THE
NUMBER
OF
DIFFERENT
TRIPLES
THAT
CAN
BE
CHOSEN
FROM
N
ITEMS
IS
PRECISELY
N
N
N
HINT
USE
MATHEMATICAL
INDUCTION
MODIFY
THREESUM
TO
WORK
PROPERLY
EVEN
WHEN
THE
INT
VALUES
ARE
SO
LARGE
THAT
ADDING
TWO
OF
THEM
MIGHT
CAUSE
OVERFLOW
MODIFY
DOUBLINGTEST
TO
USE
STDDRAW
TO
PRODUCE
PLOTS
LIKE
THE
STANDARD
AND
LOG
LOG
PLOTS
IN
THE
TEXT
RESCALING
AS
NECESSARY
SO
THAT
THE
PLOT
ALWAYS
FILLS
A
SUBSTANTIAL
PORTION
OF
THE
WINDOW
DEVELOP
A
TABLE
LIKE
THE
ONE
ON
PAGE
FOR
TWOSUM
GIVE
TILDE
APPROXIMATIONS
FOR
THE
FOLLOWING
QUANTITIES
A
N
B
N
C
N
N
D
N
N
E
LG
LG
N
F
LG
N
LG
N
G
N
GIVE
THE
ORDER
OF
GROWTH
AS
A
FUNCTION
OF
N
OF
THE
RUNNING
TIMES
OF
EACH
OF
THE
FOLLOWING
CODE
FRAGMENTS
A
INT
SUM
FOR
INT
N
N
N
N
FOR
INT
I
I
N
I
SUM
B
INT
SUM
FOR
INT
I
I
N
I
FOR
INT
J
J
I
J
SUM
C
INT
SUM
FOR
INT
I
I
N
I
FOR
INT
J
J
N
J
SUM
ANALYZE
THREESUM
UNDER
A
COST
MODEL
THAT
COUNTS
ARITHMETIC
OPERATIONS
AND
COMPARISONS
INVOLVING
THE
INPUT
NUMBERS
WRITE
A
PROGRAM
TO
DETERMINE
THE
NUMBER
PAIRS
OF
VALUES
IN
AN
INPUT
FILE
THAT
ARE
EQUAL
IF
YOUR
FIRST
TRY
IS
QUADRATIC
THINK
AGAIN
AND
USE
ARRAYS
SORT
TO
DEVELOP
A
LINEARITHMIC
SOLUTION
GIVE
A
FORMULA
TO
PREDICT
THE
RUNNING
TIME
OF
A
PROGRAM
FOR
A
PROBLEM
OF
SIZE
N
WHEN
DOUBLING
EXPERIMENTS
HAVE
SHOWN
THAT
THE
DOUBLING
FACTOR
IS
AND
THE
RUNNING
TIME
FOR
PROBLEMS
OF
SIZE
IS
T
MODIFY
BINARY
SEARCH
SO
THAT
IT
ALWAYS
RETURNS
THE
ELEMENT
WITH
THE
SMALLEST
INDEX
THAT
MATCHES
THE
SEARCH
ELEMENT
AND
STILL
GUARANTEES
LOGARITHMIC
RUNNING
TIME
ADD
ANINSTANCEMETHOD
HOWMANY
TO
STATICSETOFINTS
PAGE
THATFINDSTHE
NUMBER
OF
OCCURRENCES
OF
A
GIVEN
KEY
IN
TIME
PROPORTIONAL
TO
LOG
N
IN
THE
WORST
CASE
WRITE
A
PROGRAM
THAT
GIVEN
TWO
SORTED
ARRAYS
OF
N
INT
VALUES
PRINTS
ALL
ELE
MENTS
THAT
APPEAR
IN
BOTH
ARRAYS
IN
SORTED
ORDER
THE
RUNNING
TIME
OF
YOUR
PROGRAM
SHOULD
BE
PROPORTIONAL
TO
N
IN
THE
WORST
CASE
USING
THE
ASSUMPTIONS
DEVELOPED
IN
THE
TEXT
GIVE
THE
AMOUNT
OF
MEMORY
NEED
ED
TO
REPRESENT
AN
OBJECT
OF
EACH
OF
THE
FOLLOWING
TYPES
A
ACCUMULATOR
B
TRANSACTION
C
FIXEDCAPACITYSTACKOFSTRINGS
WITH
CAPACITY
C
AND
N
ENTRIES
D
E
F
G
DOUBLE
SUM
DEVELOP
AN
ALGORITHM
FOR
THE
SUM
PROBLEM
FASTER
SUM
AS
A
WARMUP
DEVELOP
AN
IMPLEMENTATION
TWOSUMFASTER
THAT
USES
A
LINEAR
ALGORITHM
TO
COUNT
THE
PAIRS
THAT
SUM
TO
ZERO
AFTER
THE
ARRAY
IS
SORTED
IN
STEAD
OF
THE
BINARY
SEARCH
BASED
LINEARITHMIC
ALGORITHM
THEN
APPLY
A
SIMILAR
IDEA
TO
DEVELOP
A
QUADRATIC
ALGORITHM
FOR
THE
SUM
PROBLEM
CLOSEST
PAIR
IN
ONE
DIMENSION
WRITE
A
PROGRAM
THAT
GIVEN
AN
ARRAY
A
OF
N
DOUBLE
VALUES
FINDS
A
CLOSEST
PAIR
TWO
VALUES
WHOSE
DIFFERENCE
IS
NO
GREATER
THAN
THE
THE
DIFFERENCE
OF
ANY
OTHER
PAIR
IN
ABSOLUTE
VALUE
THE
RUNNING
TIME
OF
YOUR
PROGRAM
SHOULD
BE
LINEARITHMIC
IN
THE
WORST
CASE
FARTHEST
PAIR
IN
ONE
DIMENSION
WRITE
A
PROGRAM
THAT
GIVEN
AN
ARRAY
A
OF
N
DOUBLE
VALUES
FINDS
A
FARTHEST
PAIR
TWO
VALUES
WHOSE
DIFFERENCE
IS
NO
SMALLER
THAN
THE
THE
DIFFERENCE
OF
ANY
OTHER
PAIR
IN
ABSOLUTE
VALUE
THE
RUNNING
TIME
OF
YOUR
PROGRAM
SHOULD
BE
LINEAR
IN
THE
WORST
CASE
LOCAL
MINIMUM
OF
AN
ARRAY
WRITE
A
PROGRAM
THAT
GIVEN
AN
ARRAY
A
OF
N
DIS
TINCT
INTEGERS
FINDS
A
LOCAL
MINIMUM
AN
INDEX
I
SUCH
THAT
A
I
A
I
A
I
YOUR
PROGRAM
SHOULD
USE
N
COMPARES
IN
THE
WORST
CASE
ANSWER
EXAMINE
THE
MIDDLE
VALUE
A
N
AND
ITS
TWO
NEIGHBORS
A
N
AND
A
N
IF
A
N
IS
A
LOCAL
MINIMUM
STOP
OTHERWISE
SEARCH
IN
THE
HALF
WITH
THE
SMALLER
NEIGHBOR
LOCAL
MINIMUM
OF
A
MATRIX
GIVEN
AN
N
BY
N
ARRAY
A
OF
N
DISTINCT
INTE
GERS
DESIGN
AN
ALGORITHM
THAT
RUNS
IN
TIME
PROPORTIONAL
TO
N
TO
FIND
A
LOCAL
MINIMUM
A
PAIR
OF
INDICES
I
AND
J
SUCH
THAT
A
I
J
A
I
J
A
I
J
A
I
J
A
I
J
A
I
J
AND
A
I
J
A
I
J
THE
RUNNING
TIME
OF
YOUR
PRO
GRAM
SHOULD
BE
PROPORTIONAL
TO
N
IN
THE
WORST
CASE
BITONIC
SEARCH
AN
ARRAY
IS
BITONIC
IF
IT
IS
COMPRISED
OF
AN
INCREASING
SEQUENCE
OF
INTEGERS
FOLLOWED
IMMEDIATELY
BY
A
DECREASING
SEQUENCE
OF
INTEGERS
WRITE
A
PROGRAM
THAT
GIVEN
A
BITONIC
ARRAY
OF
N
DISTINCT
INT
VALUES
DETERMINES
WHETHER
A
GIVEN
INTEGER
IS
IN
THE
ARRAY
YOUR
PROGRAM
SHOULD
USE
N
COMPARES
IN
THE
WORST
CASE
BINARY
SEARCH
ON
DISTINCT
VALUES
DEVELOP
AN
IMPLEMENTATION
OF
BINARY
SEARCH
FOR
STATICSETOFINTS
SEEPAGE
WHERETHERUNNINGTIMEOF
CONTAINS
ISGUARANTEED
TO
BE
LG
R
WHERE
R
IS
THE
NUMBER
OF
DIFFERENT
INTEGERS
IN
THE
ARRAY
GIVEN
AS
ARGUMENT
TO
THE
CONSTRUCTOR
BINARY
SEARCH
WITH
ONLY
ADDITION
AND
SUBTRACTION
MIHAI
PATRASCU
WRITE
A
PROGRAM
THAT
GIVEN
AN
ARRAY
OF
N
DISTINCT
INT
VALUES
IN
ASCENDING
ORDER
DETERMINES
WHETHER
A
GIVEN
INTEGER
IS
IN
THE
ARRAY
YOU
MAY
USE
ONLY
ADDITIONS
AND
SUBTRACTIONS
AND
A
CONSTANT
AMOUNT
OF
EXTRA
MEMORY
THE
RUNNING
TIME
OF
YOUR
PROGRAM
SHOULD
BE
PROPORTIONAL
TO
LOG
N
IN
THE
WORST
CASE
ANSWER
INSTEAD
OF
SEARCHING
BASED
ON
POWERS
OF
TWO
BINARY
SEARCH
USE
FIBONACCI
NUMBERS
WHICH
ALSO
GROW
EXPONENTIALLY
MAINTAIN
THE
CURRENT
SEARCH
RANGE
TO
BE
THE
INTERVAL
I
I
FK
AND
KEEP
FK
AND
FK
IN
TWO
VARIABLES
AT
EACH
STEP
COMPUTE
FK
VIA
SUBTRACTION
CHECK
ELEMENT
I
FK
AND
UPDATE
THE
CURRENT
RANGE
TO
EITHER
I
I
FK
OR
I
FK
I
FK
FK
BINARY
SEARCH
FOR
A
FRACTION
DEVISE
A
METHOD
THAT
USES
A
LOGARITHMIC
NUMBER
OF
QUERIES
OF
THE
FORM
IS
THE
NUMBER
LESS
THAN
X
TO
FIND
A
RATIONAL
NUMBER
P
Q
SUCH
THAT
P
Q
N
HINT
TWO
FRACTIONS
WITH
DENOMINATORS
LESS
THAN
N
CANNOT
DIFFER
BY
MORE
THAN
N
THROWING
EGGS
FROM
A
BUILDING
SUPPOSE
THAT
YOU
HAVE
AN
N
STORY
BUILDING
AND
PLENTY
OF
EGGS
SUPPOSE
ALSO
THAT
AN
EGG
IS
BROKEN
IF
IT
IS
THROWN
OFF
FLOOR
F
OR
HIGHER
AND
UNHURT
OTHERWISE
FIRST
DEVISE
A
STRATEGY
TO
DETERMINE
THE
VALUE
OF
F
SUCH
THAT
THE
NUMBER
OF
BROKEN
EGGS
IS
LG
N
WHEN
USING
LG
N
THROWS
THEN
FIND
A
WAY
TO
REDUCE
THE
COST
TO
F
THROWING
TWO
EGGS
FROM
A
BUILDING
CONSIDER
THE
PREVIOUS
QUESTION
BUT
NOW
SUPPOSE
YOU
ONLY
HAVE
TWO
EGGS
AND
YOUR
COST
MODEL
IS
THE
NUMBER
OF
THROWS
DEVISE
A
STRATEGY
TO
DETERMINE
F
SUCH
THAT
THE
NUMBER
OF
THROWS
IS
AT
MOST
N
THEN
FIND
A
WAY
TO
REDUCE
THE
COST
TO
C
F
THIS
IS
ANALOGOUS
TO
A
SITUATION
WHERE
SEARCH
HITS
EGG
INTACT
ARE
MUCH
CHEAPER
THAN
MISSES
EGG
BROKEN
COLLINEARITY
SUPPOSE
THAT
YOU
HAVE
AN
ALGORITHM
THAT
TAKES
AS
INPUT
N
DIS
TINCT
POINTS
IN
THE
PLANE
AND
CAN
RETURN
THE
NUMBER
OF
TRIPLES
THAT
FALL
ON
THE
SAME
LINE
SHOW
THAT
YOU
CAN
USE
THIS
ALGORITHM
TO
SOLVE
THE
SUM
PROBLEM
STRONG
HINT
USE
ALGEBRA
TO
SHOW
THAT
A
B
AND
C
ARE
COLLINEAR
IF
AND
ONLY
IF
A
B
C
QUEUE
WITH
TWO
STACKS
IMPLEMENT
A
QUEUE
WITH
TWO
STACKS
SO
THAT
EACH
QUEUE
CREATIVE
PROBLEMS
CONTINUED
OPERATION
TAKES
A
CONSTANT
AMORTIZED
NUMBER
OF
STACK
OPERATIONS
HINT
IF
YOU
PUSH
ELEMENTS
ONTO
A
STACK
AND
THEN
POP
THEM
ALL
THEY
APPEAR
IN
REVERSE
ORDER
IF
YOU
REPEAT
THIS
PROCESS
THEY
RE
NOW
BACK
IN
ORDER
STACK
WITH
A
QUEUE
IMPLEMENT
A
STACK
WITH
A
SINGLE
QUEUE
SO
THAT
EACH
STACK
OPERATIONS
TAKES
A
LINEAR
NUMBER
OF
QUEUE
OPERATIONS
HINT
TO
DELETE
AN
ITEM
GET
ALL
OF
THE
ELEMENTS
ON
THE
QUEUE
ONE
AT
A
TIME
AND
PUT
THEM
AT
THE
END
EXCEPT
FOR
THE
LAST
ONE
WHICH
YOU
SHOULD
DELETE
AND
RETURN
THIS
SOLUTION
IS
ADMITTEDLY
VERY
INEFFICIENT
STEQUE
WITH
TWO
STACKS
IMPLEMENT
A
STEQUE
WITH
TWO
STACKS
SO
THAT
EACH
STEQUE
OPERATION
SEE
EXERCISE
TAKES
A
CONSTANT
AMORTIZED
NUMBER
OF
STACK
OPERATIONS
DEQUE
WITH
A
STACK
AND
A
STEQUE
IMPLEMENT
A
DEQUE
WITH
A
STACK
AND
A
STEQUE
SEE
EXERCISE
SO
THAT
EACH
DEQUE
OPERATION
TAKES
A
CONSTANT
AMORTIZED
NUMBER
OF
STACK
AND
STEQUE
OPERATIONS
DEQUE
WITH
THREE
STACKS
IMPLEMENT
A
DEQUE
WITH
THREE
STACKS
SO
THAT
EACH
DEQUE
OPERATION
TAKES
A
CONSTANT
AMORTIZED
NUMBER
OF
STACK
OPERATIONS
AMORTIZED
ANALYSIS
PROVE
THAT
STARTING
FROM
AN
EMPTY
STACK
THE
NUMBER
OF
AR
RAY
ACCESSES
USED
BY
ANY
SEQUENCE
OF
M
OPERATIONS
IN
THE
RESIZING
ARRAY
IMPLEMENTATION
OF
STACK
IS
PROPORTIONAL
TO
M
MEMORY
REQUIREMENTS
ON
A
BIT
MACHINE
GIVE
THE
MEMORY
REQUIREMENTS
FOR
INTEGER
DATE
COUNTER
INT
DOUBLE
DOUBLE
STRING
NODE
AND
STACK
LINKED
LIST
REPRESENTATION
FOR
A
BIT
MACHINE
ASSUME
THAT
REFERENCES
ARE
BYTES
OBJECT
OVERHEAD
IS
BYTES
AND
PADDING
IS
TO
A
MULTIPLE
OF
BYTES
HOT
OR
COLD
YOUR
GOAL
IS
TO
GUESS
A
SECRET
INTEGER
BETWEEN
AND
N
YOU
REPEAT
EDLY
GUESS
INTEGERS
BETWEEN
AND
N
AFTER
EACH
GUESS
YOU
LEARN
IF
YOUR
GUESS
EQUALS
THE
SECRET
INTEGER
AND
THE
GAME
STOPS
OTHERWISE
YOU
LEARN
IF
THE
GUESS
IS
HOTTER
CLOSER
TO
OR
COLDER
FARTHER
FROM
THE
SECRET
NUMBER
THAN
YOUR
PREVIOUS
GUESS
DESIGN
AN
ALGO
RITHM
THAT
FINDS
THE
SECRET
NUMBER
IN
AT
MOST
LG
N
GUESSES
THEN
DESIGN
AN
ALGORITHM
THAT
FINDS
THE
SECRET
NUMBER
IN
AT
MOST
LG
N
GUESSES
TIME
COSTS
FOR
PUSHDOWN
STACKS
JUSTIFY
THE
ENTRIES
IN
THE
TABLE
BELOW
WHICH
SHOWS
TYPICAL
TIME
COSTS
FOR
VARIOUS
PUSHDOWN
STACK
IMPLEMENTATIONS
USING
A
COST
MODEL
THAT
COUNTS
BOTH
DATA
REFERENCES
REFERENCES
TO
DATA
PUSHED
ONTO
THE
STACK
EITHER
AN
ARRAY
REFERENCE
OR
A
REFERENCE
TO
AN
OBJECT
INSTANCE
VARIABLE
AND
OBJECTS
CREATED
DATA
STRUCTURE
ITEM
TYPE
COST
TO
PUSH
N
INT
VALUES
LINKED
LIST
TIME
COSTS
FOR
PUSHDOWN
STACKS
VARIOUS
IMPLEMENTATIONS
SPACE
USAGE
FOR
PUSHDOWN
STACKS
JUSTIFY
THE
ENTRIES
IN
THE
TABLE
BELOW
WHICH
SHOWS
TYPICAL
SPACE
USAGE
FOR
VARIOUS
PUSHDOWN
STACK
IMPLEMENTATIONS
USE
A
STATIC
NESTED
CLASS
FOR
LINKED
LIST
NODES
TO
AVOID
THE
NON
STATIC
NESTED
CLASS
OVERHEAD
DATA
STRUCTURE
ITEM
TYPE
SPACE
USAGE
FOR
N
INT
VALUES
BYTES
INT
N
LINKED
LIST
RESIZING
ARRAY
INTEGER
N
INT
BETWEEN
N
AND
N
INTEGER
BETWEEN
N
AND
N
SPACE
USAGE
IN
PUSHDOWN
STACKS
VARIOUS
IMPLEMENTATIONS
AUTOBOXING
PERFORMANCE
PENALTY
RUN
EXPERIMENTS
TO
DETERMINE
THE
PERFOR
MANCE
PENALTY
ON
YOUR
MACHINE
FOR
USING
AUTOBOXING
AND
AUTO
UNBOXING
DEVELOP
AN
IMPLEMENTATION
FIXEDCAPACITYSTACKOFINTS
AND
USE
A
CLIENT
SUCH
AS
DOUBLINGRATIO
TO
COMPARE
ITS
PERFORMANCE
WITH
THE
GENERIC
FIXEDCAPACITYSTACK
INTEGER
FOR
A
LARGE
NUMBER
OF
PUSH
AND
POP
OPERATIONS
NAIVE
SUM
IMPLEMENTATION
RUN
EXPERIMENTS
TO
EVALUATE
THE
FOLLOWING
IM
PLEMENTATION
OF
THE
INNER
LOOP
OF
THREESUM
FOR
INT
I
I
N
I
FOR
INT
J
J
N
J
FOR
INT
K
K
N
K
IF
I
J
J
K
IF
A
I
A
J
A
K
CNT
DO
SO
BY
DEVELOPING
A
VERSION
OF
DOUBLINGTEST
THAT
COMPUTES
THE
RATIO
OF
THE
RUNNING
TIMES
OF
THIS
PROGRAM
AND
THREESUM
IMPROVED
ACCURACY
FOR
DOUBLING
TEST
MODIFY
DOUBLINGRATIO
TO
TAKE
A
SECOND
COMMAND
LINE
ARGUMENT
THAT
SPECIFIES
THE
NUMBER
OF
CALLS
TO
MAKE
TO
TIMETRIAL
FOR
EACH
VALUE
OF
N
RUN
YOUR
PROGRAM
FOR
AND
TRIALS
AND
COMMENT
ON
THE
PRECISION
OF
THE
RESULTS
SUM
FOR
RANDOM
VALUES
FORMULATE
AND
VALIDATE
A
HYPOTHESIS
DESCRIBING
THE
NUMBER
OF
TRIPLES
OF
N
RANDOM
INT
VALUES
THAT
SUM
TO
IF
YOU
ARE
SKILLED
IN
MATH
EMATICAL
ANALYSIS
DEVELOP
AN
APPROPRIATE
MATHEMATICAL
MODEL
FOR
THIS
PROBLEM
WHERE
THE
VALUES
ARE
UNIFORMLY
DISTRIBUTED
BETWEEN
M
AND
M
WHERE
M
IS
NOT
SMALL
RUNNING
TIMES
ESTIMATE
THE
AMOUNT
OF
TIME
IT
WOULD
TAKE
TO
RUN
TWOSUMFAST
TWOSUM
THREESUMFAST
AND
THREESUM
ON
YOUR
COMPUTER
TO
SOLVE
THE
PROBLEMS
FOR
A
FILE
OF
MILLION
NUMBERS
USE
DOUBLINGRATIO
TO
DO
SO
PROBLEM
SIZES
ESTIMATE
THE
SIZE
OF
THE
LARGEST
VALUE
OF
P
FOR
WHICH
YOU
CAN
RUN
TWOSUMFAST
TWOSUM
THREESUMFAST
AND
THREESUM
ON
YOUR
COMPUTER
TO
SOLVE
THE
PROBLEMS
FOR
A
FILE
OF
THOUSAND
NUMBERS
USE
DOUBLINGRATIO
TO
DO
SO
RESIZING
ARRAYS
VERSUS
LINKED
LISTS
RUN
EXPERIMENTS
TO
VALIDATE
THE
HYPOTHESIS
THAT
RESIZING
ARRAYS
ARE
FASTER
THAN
LINKED
LISTS
FOR
STACKS
SEE
EXERCISE
AND
EXER
CISE
DO
SO
BY
DEVELOPING
A
VERSION
OF
DOUBLINGRATIO
THAT
COMPUTES
THE
RATIO
OF
THE
RUNNING
TIMES
OF
THE
TWO
PROGRAMS
BIRTHDAY
PROBLEM
WRITE
A
PROGRAM
THAT
TAKES
AN
INTEGER
N
FROM
THE
COMMAND
LINE
AND
USES
STDRANDOM
UNIFORM
TO
GENERATE
A
RANDOM
SEQUENCE
OF
INTEGERS
BE
TWEEN
AND
N
RUN
EXPERIMENTS
TO
VALIDATE
THE
HYPOTHESIS
THAT
THE
NUMBER
OF
INTEGERS
GENERATED
BEFORE
THE
FIRST
REPEATED
VALUE
IS
FOUND
IS
COUPON
COLLECTOR
PROBLEM
GENERATING
RANDOM
INTEGERS
AS
IN
THE
PREVIOUS
EXER
CISE
RUN
EXPERIMENTS
TO
VALIDATE
THE
HYPOTHESIS
THAT
THE
NUMBER
OF
INTEGERS
GENERATED
BEFORE
ALL
POSSIBLE
VALUES
ARE
GENERATED
IS
N
HN
TO
ILLUSTRATE
OUR
BASIC
APPROACH
TO
DEVELOPING
AND
ANALYZING
ALGORITHMS
WE
NOW
CONSIDER
A
DETAILED
EXAMPLE
OUR
PURPOSE
IS
TO
EMPHASIZE
THE
FOLLOWING
THEMES
GOOD
ALGORITHMS
CAN
MAKE
THE
DIFFERENCE
BETWEEN
BEING
ABLE
TO
SOLVE
A
PRACTICAL
PROBLEM
AND
NOT
BEING
ABLE
TO
ADDRESS
IT
AT
ALL
AN
EFFICIENT
ALGORITHM
CAN
BE
AS
SIMPLE
TO
CODE
AS
AN
INEFFICIENT
ONE
UNDERSTANDING
THE
PERFORMANCE
CHARACTERISTICS
OF
AN
IMPLEMENTATION
CAN
BE
AN
INTERESTING
AND
SATISFYING
INTELLECTUAL
CHALLENGE
THE
SCIENTIFIC
METHOD
IS
AN
IMPORTANT
TOOL
IN
HELPING
US
CHOOSE
AMONG
DIFFERENT
METHODS
FOR
SOLVING
THE
SAME
PROBLEM
AN
ITERATIVE
REFINEMENT
PROCESS
CAN
LEAD
TO
INCREASINGLY
EFFICIENT
ALGORITHMS
THESE
THEMES
ARE
REINFORCED
THROUGHOUT
THE
BOOK
THIS
PROTOTYPICAL
EXAMPLE
SETS
THE
STAGE
FOR
OUR
USE
OF
THE
SAME
GENERAL
METHODOLOGY
FOR
MANY
OTHER
PROBLEMS
THE
PROBLEM
THAT
WE
CONSIDER
IS
NOT
A
TOY
PROBLEM
IT
IS
A
FUNDAMENTAL
COMPU
TATIONAL
TASK
AND
THE
SOLUTION
THAT
WE
DEVELOP
IS
OF
USE
IN
A
VARIETY
OF
APPLICATIONS
FROM
PERCOLATION
IN
PHYSICAL
CHEMISTRY
TO
CONNECTIVITY
IN
COMMUNICATIONS
NETWORKS
WE
START
WITH
A
SIMPLE
SOLUTION
THEN
SEEK
TO
UNDERSTAND
THAT
SOLUTION
PERFORMANCE
CHARACTERISTICS
WHICH
HELP
US
TO
SEE
HOW
TO
IMPROVE
THE
ALGORITHM
DYNAMIC
CONNECTIVITY
WE
START
WITH
THE
FOLLOWING
PROBLEM
SPECIFICATION
THE
INPUT
IS
A
SEQUENCE
OF
PAIRS
OF
INTEGERS
WHERE
EACH
INTEGER
REPRESENTS
AN
OBJECT
OF
SOME
TYPE
AND
WE
ARE
TO
INTERPRET
THE
PAIR
P
Q
AS
MEANING
P
IS
CONNECTED
TO
Q
WE
ASSUME
THAT
IS
CONNECTED
TO
IS
AN
EQUIVALENCE
RELATION
WHICH
MEANS
THAT
IT
IS
REFLEXIVE
P
IS
CONNECTED
TO
P
SYMMETRIC
IF
P
IS
CONNECTED
TO
Q
THEN
Q
IS
CONNECTED
TO
P
TRANSITIVE
IF
P
IS
CONNECTED
TO
Q
AND
Q
IS
CONNECTED
TO
R
THEN
P
IS
CONNECTED
TO
R
AN
EQUIVALENCE
RELATION
PARTITIONS
THE
OBJECTS
INTO
EQUIVALENCE
CLASSES
IN
THIS
CASE
TWO
OBJECTS
ARE
IN
THE
SAME
EQUIVALENCE
CLASS
IF
AND
ONLY
IF
THEY
ARE
CONNECTED
OUR
GOAL
IS
TO
WRITE
A
PROGRAM
TO
FILTER
OUT
EXTRANEOUS
PAIRS
PAIRS
WHERE
BOTH
OBJECTS
ARE
IN
THE
SAME
EQUIVALENCE
CLASS
FROM
THE
SEQUENCE
IN
OTHER
WORDS
WHEN
THE
PROGRAM
READS
A
PAIR
P
Q
FROM
THE
INPUT
IT
SHOULD
WRITE
THE
PAIR
TO
THE
OUTPUT
ONLY
IF
THE
PAIRS
IT
HAS
SEEN
TO
THAT
POINT
DO
NOT
IMPLY
THAT
P
IS
CONNECTED
TO
Q
IF
THE
PREVIOUS
PAIRS
DO
IMPLY
THAT
P
IS
CONNECTED
TO
Q
THEN
THE
PROGRAM
SHOULD
IGNORE
THE
PAIR
P
Q
AND
PROCEED
TO
READ
IN
THE
NEXT
PAIR
THE
FIGURE
ON
THE
FACING
PAGE
GIVES
AN
EXAMPLE
OF
THIS
PROCESS
TO
ACHIEVE
THE
DESIRED
GOAL
WE
NEED
TO
DEVISE
A
DATA
STRUCTURE
THAT
CAN
REMEMBER
SUFFICIENT
INFORMATION
ABOUT
THE
PAIRS
IT
HAS
SEEN
TO
BE
ABLE
TO
DECIDE
WHETHER
OR
NOT
A
NEW
PAIR
OF
OBJECTS
IS
CONNECTED
INFORMALLY
WE
REFER
TO
THE
TASK
OF
DESIGNING
SUCH
A
METHOD
AS
THE
DYNAMIC
CONNECTIVITY
PROBLEM
THIS
PROBLEM
ARISES
APPLICATIONS
SUCH
AS
THE
FOLLOWING
NETWORKS
THE
INTEGERS
MIGHT
REPRESENT
COMPUTERS
IN
A
LARGE
NETWORK
AND
THE
PAIRS
MIGHT
REPRESENT
CONNECTIONS
IN
THE
NETWORK
THEN
OUR
PROGRAM
DETERMINES
WHETHER
WE
NEED
TO
ESTABLISH
A
NEW
DIRECT
CONNECTION
FOR
P
AND
Q
TO
BE
ABLE
TO
COMMUNICATE
OR
WHETHER
WE
CAN
USE
EXISTING
CONNECTIONS
TO
SET
UP
A
COMMUNICATIONS
PATH
OR
THE
INTEGERS
MIGHT
REPRESENT
CONTACT
SITES
IN
AN
ELECTRICAL
CIRCUIT
AND
THE
PAIRS
MIGHT
REPRESENT
WIRES
CONNECTING
THE
SITES
OR
THE
INTEGERS
MIGHT
REPRESENT
PEOPLE
IN
A
SOCIAL
NETWORK
AND
THE
PAIRS
MIGHT
REPRESENT
FRIENDSHIPS
IN
SUCH
APPLICATIONS
WE
MIGHT
NEED
TO
PROCESS
MILLIONS
OF
OBJECTS
AND
BILLIONS
OF
CONNECTIONS
VARIABLE
NAME
EQUIVALENCE
IN
CERTAIN
PROGRAMMING
ENVIRON
MENTS
IT
IS
POSSIBLE
TO
DECLARE
TWO
VARIABLE
NAMES
AS
BEING
EQUIV
ALENT
REFERENCES
TO
THE
SAME
OBJECT
AFTER
A
SEQUENCE
OF
SUCH
DEC
LARATIONS
THE
SYSTEM
NEEDS
TO
BE
ABLE
TO
DETERMINE
WHETHER
TWO
GIVEN
NAMES
ARE
EQUIVALENT
THIS
APPLICATION
IS
AN
EARLY
ONE
FOR
THE
FORTRAN
PROGRAMMING
LANGUAGE
THAT
MOTIVATED
THE
DEVEL
OPMENT
OF
THE
ALGORITHMS
THAT
WE
ARE
ABOUT
TO
CONSIDER
MATHEMATICAL
SETS
ON
A
MORE
ABSTRACT
LEVEL
YOU
CAN
THINK
OF
THE
INTEGERS
AS
BELONGING
TO
MATHEMATICAL
SETS
WHEN
WE
PROCESS
A
PAIR
P
Q
WE
ARE
ASKING
WHETHER
THEY
BELONG
TO
THE
SAME
SET
IF
NOT
WE
UNITE
P
SET
AND
Q
SET
PUTTING
THEM
IN
THE
SAME
SET
TO
FIX
IDEAS
WE
WILL
USE
NETWORKING
TERMINOLOGY
FOR
THE
REST
OF
THIS
SECTION
AND
REFER
TO
THE
OBJECTS
AS
SITES
THE
PAIRS
AS
CONNEC
TIONS
AND
THE
EQUIVALENCE
CLASSES
AS
CONNECTED
COMPONENTS
OR
JUST
COMPONENTS
FOR
SHORT
FOR
SIMPLICITY
WE
ASSUME
THAT
WE
HAVE
N
COMPONENTS
DON
T
PRINT
PAIRS
THAT
ARE
ALREADY
CONNECTED
SITES
WITH
INTEGER
NAMES
FROM
TO
N
WE
DO
SO
WITHOUT
LOSS
OF
GENERALITY
BECAUSE
WE
SHALL
BE
CONSIDERING
A
HOST
OF
ALGORITHMS
IN
CHAPTER
THAT
CAN
ASSOCIATE
ARBITRARY
NAMES
WITH
SUCH
INTEGER
IDENTIFIERS
IN
AN
EFFICIENT
MANNER
DYNAMIC
CONNECTIVITY
EXAMPLE
A
LARGER
EXAMPLE
THAT
GIVES
SOME
INDICATION
OF
THE
DIFFICULTY
OF
THE
CONNECTIVITY
PROBLEM
IS
DEPICTED
IN
THE
FIGURE
AT
THE
TOP
OF
THE
NEXT
PAGE
YOU
CAN
QUICKLY
IDENTIFY
THE
COMPONENT
CONSISTING
OF
A
SINGLE
SITE
IN
THE
LEFT
MIDDLE
OF
THE
DIAGRAM
AND
THE
CONNECTED
COMPONENT
MEDIUM
CONNECTIVITY
EXAMPLE
SITES
EDGES
CONNECTED
COMPONENTS
COMPONENT
CONSISTING
OF
FIVE
SITES
AT
THE
BOTTOM
LEFT
BUT
YOU
MIGHT
HAVE
DIFFICULTY
VERI
FYING
THAT
ALL
OF
THE
OTHER
SITES
ARE
CONNECTED
TO
ONE
ANOTHER
FOR
A
PROGRAM
THE
TASK
IS
EVEN
MORE
DIFFICULT
BECAUSE
IT
HAS
TO
WORK
JUST
WITH
SITE
NAMES
AND
CONNECTIONS
AND
HAS
NO
ACCESS
TO
THE
GEOMETRIC
PLACEMENT
OF
SITES
IN
THE
DIAGRAM
HOW
CAN
WE
TELL
QUICKLY
WHETHER
OR
NOT
ANY
GIVEN
TWO
SITES
IN
SUCH
A
NETWORK
ARE
CONNECTED
THE
FIRST
TASK
THAT
WE
FACE
IN
DEVELOPING
AN
ALGORITHM
IS
TO
SPECIFY
THE
PROBLEM
IN
A
PRECISE
MANNER
THE
MORE
WE
REQUIRE
OF
AN
ALGORITHM
THE
MORE
TIME
AND
SPACE
WE
MAY
EXPECT
IT
TO
NEED
TO
FINISH
THE
JOB
IT
IS
IMPOSSIBLE
TO
QUANTIFY
THIS
RELATIONSHIP
A
PRIORI
AND
WE
OFTEN
MODIFY
A
PROBLEM
SPECIFICATION
ON
FINDING
THAT
IT
IS
DIFFICULT
OR
EXPENSIVE
TO
SOLVE
OR
IN
HAPPY
CIRCUMSTANCES
ON
FINDING
THAT
AN
ALGORITHM
CAN
PROVIDE
INFORMA
TION
MORE
USEFUL
THAN
WHAT
WAS
CALLED
FOR
IN
THE
ORIGINAL
SPECIFICATION
FOR
EXAMPLE
OUR
CONNECTIVITY
PROBLEM
SPECIFICATION
REQUIRES
ONLY
THAT
OUR
PROGRAM
BE
ABLE
TO
DETERMINE
WHETHER
OR
NOT
ANY
GIVEN
PAIR
P
Q
IS
CONNECTED
AND
NOT
THAT
IT
BE
ABLE
TO
DEMONSTRATE
A
SET
OF
CONNECTIONS
THAT
CONNECT
THAT
PAIR
SUCH
A
REQUIREMENT
MAKES
THE
PROBLEM
MORE
DIFFICULT
AND
LEADS
US
TO
A
DIFFERENT
FAMILY
OF
ALGORITHMS
WHICH
WE
CONSIDER
IN
SECTION
TO
SPECIFY
THE
PROBLEM
WE
DEVELOP
AN
API
THAT
ENCAPSULATES
THE
BASIC
OPERATIONS
THAT
WE
NEED
INITIALIZE
ADD
A
CONNECTION
BETWEEN
TWO
SITES
IDENTIFY
THE
COMPONENT
CONTAINING
A
SITE
DETERMINE
WHETHER
TWO
SITES
ARE
IN
THE
SAME
COMPONENT
AND
COUNT
THE
NUMBER
OF
COMPONENTS
THUS
WE
ARTICULATE
THE
FOLLOWING
API
THE
UNION
OPERATION
MERGES
TWO
COMPONENTS
IF
THE
TWO
SITES
ARE
IN
DIFFERENT
COM
PONENTS
THE
FIND
OPERATION
RETURNS
AN
INTEGER
COMPONENT
IDENTIFIER
FOR
A
GIVEN
SITE
THE
CONNECTED
OPERATION
DETERMINES
WHETHER
TWO
SITES
ARE
IN
THE
SAME
COMPONENT
AND
THE
COUNT
METHOD
RETURNS
THE
NUMBER
OF
COMPONENTS
WE
START
WITH
N
COMPO
NENTS
AND
EACH
UNION
THAT
MERGES
TWO
DIFFERENT
COMPONENTS
DECREMENTS
THE
NUM
BER
OF
COMPONENTS
BY
AS
WE
SHALL
SOON
SEE
THE
DEVELOPMENT
OF
AN
ALGORITHMIC
SOLUTION
FOR
DYNAMIC
CON
NECTIVITY
THUS
REDUCES
TO
THE
TASK
OF
DEVELOPING
AN
IMPLEMENTATION
OF
THIS
API
EVERY
IMPLEMENTATION
HAS
TO
DEFINE
A
DATA
STRUCTURE
TO
REPRESENT
THE
KNOWN
CONNECTIONS
DEVELOP
EFFICIENT
UNION
FIND
CONNECTED
AND
COUNT
IMPLEMENTA
TIONS
THAT
ARE
BASED
ON
THAT
DATA
STRUCTURE
AS
USUAL
THE
NATURE
OF
THE
DATA
STRUCTURE
HAS
A
DIRECT
IMPACT
ON
THE
EFFICIENCY
OF
THE
ALGORITHMS
SO
DATA
STRUCTURE
AND
ALGORITHM
DESIGN
GO
HAND
IN
HAND
THE
API
ALREADY
SPECIFIES
THE
CONVENTION
THAT
BOTH
SITES
AND
COMPONENTS
WILL
BE
IDENTIFIED
BY
INT
VAL
UES
BETWEEN
AND
N
SO
IT
MAKES
SENSE
TO
USE
A
SITE
INDEXED
ARRAY
ID
AS
OUR
BASIC
DATA
STRUCTURE
TO
REPRESENT
THE
COMPONENTS
WE
ALWAYS
USE
THE
NAME
OF
ONE
OF
THE
SITES
IN
A
COMPONENT
AS
THE
COMPONENT
IDENTIFIER
SO
YOU
CAN
THINK
OF
EACH
COMPONENT
AS
BEING
REPRESENTED
BY
ONE
OF
ITS
SITES
INITIALLY
WE
START
WITH
N
COMPONENTS
EACH
SITE
IN
ITS
OWN
COMPONENT
SO
WE
INITIALIZE
ID
I
TO
I
FOR
ALL
I
FROM
TO
N
FOR
EACH
SITE
I
WE
KEEP
THE
INFORMATION
NEEDED
BY
FIND
TO
DETERMINE
THE
COMPONENT
CONTAIN
ING
I
IN
ID
I
USING
VARIOUS
ALGORITHM
DEPENDENT
STRATEGIES
ALL
OF
OUR
IMPLEMENTA
TIONS
USE
A
ONE
LINE
IMPLEMENTATION
OF
CONNECTED
THAT
RETURNS
THE
BOOLEAN
VALUE
FIND
P
FIND
Q
IN
SUMMARY
OUR
STARTING
POINT
IS
ALGORITHM
ON
THE
FACING
PAGE
WE
MAINTAIN
TWO
INSTANCE
VARIABLES
THE
COUNT
OF
COMPONENTS
AND
THE
ARRAY
ID
IMPLEMENTATIONS
OF
FIND
AND
UNION
ARE
THE
TOPIC
OF
THE
REMAINDER
OF
THIS
SECTION
TO
TEST
THE
UTILITY
OF
THE
API
AND
TO
PROVIDE
A
BASIS
FOR
DEVELOP
MENT
WE
INCLUDE
A
CLIENT
IN
MAIN
THAT
USES
IT
TO
SOLVE
THE
DY
NAMIC
CONNECTIVITY
PROBLEM
IT
READS
THE
VALUE
OF
N
FOLLOWED
BY
A
SEQUENCE
OF
PAIRS
OF
INTEGERS
EACH
IN
THE
RANGE
TO
N
CALLING
FIND
FOR
EACH
PAIR
IF
THE
TWO
SITES
IN
THE
PAIR
ARE
ALREADY
CON
NECTED
IT
MOVES
ON
TO
THE
NEXT
PAIR
IF
THEY
ARE
NOT
IT
CALLS
UNION
AND
PRINTS
THE
PAIR
BEFORE
CONSIDERING
IMPLEMENTATIONS
WE
ALSO
PREPARE
TEST
DATA
THE
FILE
TINYUF
TXT
CONTAINS
THE
CONNECTIONS
AMONG
SITES
USED
IN
THE
SMALL
EXAMPLE
ILLUSTRATED
ON
PAGE
THE
FILE
MEDIUMUF
TXT
CONTAINS
THE
CONNECTIONS
AMONG
SITES
ILLUSTRATED
ON
PAGE
AND
THE
FILE
LARGEUF
TXT
IS
AN
EXAMPLE
WITH
MILLION
CONNECTIONS
AMONG
MILLIONS
SITES
OUR
GOAL
IS
TO
BE
ABLE
TO
HANDLE
INPUTS
SUCH
AS
LARGEUF
TXT
IN
A
REASONABLE
AMOUNT
OF
TIME
TO
ANALYZE
THE
ALGORITHMS
WE
FOCUS
ON
THE
NUMBER
OF
TIMES
EACH
ALGORITHM
ACCESSES
AN
ARRAY
ENTRY
BY
DOING
SO
WE
ARE
IMPLICITLY
FOR
MULATING
THE
HYPOTHESIS
THAT
THE
RUNNING
TIMES
OF
THE
ALGORITHMS
ON
A
PARTICULAR
MACHINE
ARE
WITHIN
A
CONSTANT
FACTOR
OF
THIS
QUANTITY
THIS
HYPOTHESIS
IS
IMMEDIATE
FROM
THE
CODE
IS
NOT
DIFFICULT
TO
VALIDATE
THROUGH
EX
PERIMENTATION
AND
PROVIDES
A
USEFUL
STARTING
POINT
FOR
COMPARING
ALGORITHMS
AS
WE
WILL
SEE
ALGORITHM
UNION
FIND
IMPLEMENTATION
PUBLIC
CLASS
UF
PRIVATE
INT
ID
ACCESS
TO
COMPONENT
ID
SITE
INDEXED
PRIVATE
INT
COUNT
NUMBER
OF
COMPONENTS
PUBLIC
UF
INT
N
INITIALIZE
COMPONENT
ID
ARRAY
COUNT
N
ID
NEW
INT
N
FOR
INT
I
I
N
I
ID
I
I
PUBLIC
INT
COUNT
RETURN
COUNT
PUBLIC
BOOLEAN
CONNECTED
INT
P
INT
Q
RETURN
FIND
P
FIND
Q
PUBLIC
INT
FIND
INT
P
PUBLIC
VOID
UNION
INT
P
INT
Q
SEE
PAGE
QUICK
FIND
PAGE
QUICK
UNION
ANDPAGE
WEIGHTED
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
SOLVE
DYNAMIC
CONNECTIVITY
PROBLEM
ON
STDIN
INT
N
STDIN
READINT
READ
NUMBER
OF
SITES
UF
UF
NEW
UF
N
INITIALIZE
N
COMPONENTS
WHILE
STDIN
ISEMPTY
INT
P
STDIN
READINT
INT
Q
STDIN
READINT
READ
PAIR
TO
CONNECT
IF
UF
CONNECTED
P
Q
CONTINUE
IGNORE
IF
CONNECTED
UF
UNION
P
Q
COMBINE
COMPONENTS
STDOUT
PRINTLN
P
Q
AND
PRINT
CONNECTION
STDOUT
PRINTLN
UF
COUNT
COMPONENTS
OUR
UF
IMPLEMENTATIONS
ARE
BASED
ON
THIS
CODE
WHICH
MAINTAINS
AN
ARRAY
OF
INTEGERS
ID
SUCH
THAT
THE
FIND
METHOD
RETURNS
THE
SAME
INTEGER
FOR
EVERY
SITE
IN
EACH
CONNECTED
COMPONENT
THE
UNION
METHOD
MUST
MAINTAIN
THIS
INVARIANT
IMPLEMENTATIONS
WE
SHALL
CONSIDER
THREE
DIFFERENT
IMPLEMENTATIONS
ALL
BASED
ON
USING
THE
SITE
INDEXED
ID
ARRAY
TO
DETERMINE
WHETHER
TWO
SITES
ARE
IN
THE
SAME
CON
NECTED
COMPONENT
QUICK
FIND
ONE
APPROACH
IS
TO
MAINTAIN
THE
INVARIANT
THAT
P
AND
Q
ARE
CONNECTED
IF
AND
ONLY
IF
ID
P
IS
EQUAL
TO
ID
Q
IN
OTHER
WORDS
ALL
SITES
IN
A
COMPONENT
MUST
HAVE
THE
SAME
VALUE
IN
ID
THIS
METHOD
IS
CALLED
QUICK
FIND
BECAUSE
FIND
P
JUST
RETURNS
ID
P
WHICH
IMMEDIATELY
IMPLIES
THAT
CONNECTED
P
Q
REDUCES
TO
JUST
THE
TEST
ID
P
ID
Q
AND
RETURNS
TRUE
IF
AND
ONLY
IF
P
AND
Q
ARE
IN
THE
SAME
COMPONENT
TO
MAINTAIN
THE
INVARIANT
FOR
THE
CALL
UNION
P
Q
WE
FIRST
CHECK
WHETHER
THEY
ARE
ALREADY
IN
THE
SAME
COMPONENT
IN
WHICH
CASE
THERE
IS
NOTHING
TO
DO
OTHERWISE
WE
ARE
FACED
WITH
THE
SITUATION
THAT
ALL
OF
THE
ID
ENTRIES
CORRESPONDING
TO
SITES
IN
THE
SAME
COMPONENT
AS
P
HAVE
ONE
VALUE
AND
ALL
OF
THE
ID
ENTRIES
CORRE
SPONDING
TO
SITES
IN
THE
SAME
COMPONENT
AS
Q
HAVE
ANOTHER
VALUE
TO
COMBINE
THE
TWO
COMPONENTS
INTO
ONE
WE
HAVE
TO
MAKE
ALL
OF
THE
ID
ENTRIES
COR
RESPONDING
TO
BOTH
SETS
OF
SITES
THE
SAME
VALUE
AS
FIND
EXAMINES
ID
AND
ID
P
Q
UNION
HAS
TO
CHANGE
ALL
TO
P
Q
QUICK
FIND
OVERVIEW
SHOWN
IN
THE
EXAMPLE
AT
RIGHT
TO
DO
SO
WE
GO
THROUGH
THE
ARRAY
CHANGING
ALL
THE
ENTRIES
WITH
VALUES
EQUAL
TO
ID
P
TO
THE
VALUE
ID
Q
WE
COULD
HAVE
DECIDED
TO
CHANGE
ALL
THE
ENTRIES
EQUAL
TO
ID
Q
TO
THE
VALUE
ID
P
THE
CHOICE
BETWEEN
THESE
TWO
ALTERNATIVES
IS
ARBITRARY
THE
CODE
FOR
FIND
AND
UNION
BASED
ON
THESE
DESCRIPTIONS
GIVEN
AT
LEFT
IS
STRAIGHTFORWARD
A
FULL
TRACE
FOR
OUR
DEVELOPMENT
CLIENT
WITH
OUR
SAMPLE
TEST
DATA
TINYUF
TXT
IS
SHOWN
ON
THE
NEXT
PAGE
QUICK
FIND
ANALYSIS
THE
FIND
OPERATION
IS
CERTAINLY
QUICK
AS
IT
ONLY
ACCESSES
THE
ID
ARRAY
ONCE
IN
ORDER
TO
COMPLETE
THE
OPERATION
BUT
QUICK
FIND
IS
TYPICALLY
NOT
USE
FUL
FOR
LARGE
PROBLEMS
BECAUSE
UNION
NEEDS
TO
SCAN
THROUGH
THE
WHOLE
ID
ARRAY
FOR
EACH
INPUT
PAIR
ID
P
Q
ID
P
AND
ID
Q
DIFFER
SO
UNION
CHANGES
ENTRIES
EQUAL
TO
ID
P
TO
ID
Q
IN
RED
ID
P
AND
ID
Q
MATCH
SO
NO
CHANGE
QUICK
FIND
TRACE
IN
PARTICULAR
SUPPOSE
THAT
WE
USE
QUICK
FIND
FOR
THE
DYNAMIC
CONNECTIVITY
PROBLEM
AND
WIND
UP
WITH
A
SINGLE
COMPONENT
THIS
REQUIRES
AT
LEAST
N
CALLS
TO
UNION
AND
CONSEQUENTLY
AT
LEAST
N
N
N
ARRAY
ACCESSES
WE
ARE
LED
IMMEDIATELY
TO
THE
HY
POTHESIS
THAT
DYNAMIC
CONNECTIVITY
WITH
QUICK
FIND
CAN
BE
A
QUADRATIC
TIME
PROCESS
THIS
ANALYSIS
GENER
ALIZES
TO
SAY
THAT
QUICK
FIND
IS
QUADRATIC
FOR
TYPICAL
APPLICATIONS
WHERE
WE
END
UP
WITH
A
SMALL
NUMBER
OF
COMPONENTS
YOU
CAN
EASILY
VALIDATE
THIS
HYPOTHESIS
ON
YOUR
COMPUTER
WITH
A
DOUBLING
TEST
SEE
EXERCISE
FOR
AN
INSTRUCTIVE
EXAMPLE
MODERN
COMPUT
ERS
CAN
EXECUTE
HUNDREDS
OF
MILLIONS
OR
BILLIONS
OF
IN
STRUCTIONS
PER
SECOND
SO
THIS
COST
IS
NOT
NOTICEABLE
IF
N
IS
SMALL
BUT
WE
ALSO
MIGHT
FIND
OURSELVES
WITH
MIL
LIONS
OR
BILLIONS
OF
SITES
AND
CONNECTIONS
TO
PROCESS
IN
A
MODERN
APPLICATION
AS
REPRESENTED
BY
OUR
TEST
FILE
LARGEUF
TXT
IF
YOU
ARE
STILL
NOT
CONVINCED
AND
FEEL
THAT
YOU
HAVE
A
PARTICULARLY
FAST
COMPUTER
TRY
USING
QUICK
FIND
TO
DETERMINE
THE
NUMBER
OF
COMPONENTS
IMPLIED
BY
THE
PAIRS
IN
LARGEUF
TXT
THE
INESCAP
ABLE
CONCLUSION
IS
THAT
WE
CANNOT
FEASIBLY
SOLVE
SUCH
A
PROBLEM
USING
THE
QUICK
FIND
ALGORITHM
SO
WE
SEEK
BETTER
ALGORITHMS
QUICK
UNION
THE
NEXT
ALGORITHM
THAT
WE
CONSIDER
IS
A
COMPLEMENTARY
METHOD
THAT
CONCENTRATES
ON
SPEEDING
UP
THE
UNION
OPERATION
IT
IS
BASED
ON
THE
SAME
DATA
STRUCTURE
THE
SITE
INDEXED
ID
AR
RAY
BUT
WE
INTERPRET
THE
VALUES
DIF
FERENTLY
TO
DEFINE
MORE
COMPLICATED
STRUCTURES
SPECIFICALLY
THE
ID
ENTRY
FOR
EACH
SITE
IS
THE
NAME
OF
ANOTHER
SITE
IN
THE
SAME
COMPONENT
POSSIBLY
ITSELF
WE
REFER
TO
THIS
CONNECTION
AS
A
LINK
TO
IMPLEMENT
FIND
WE
START
AT
THE
GIVEN
SITE
FOLLOW
ITS
LINK
TO
AN
OTHER
SITE
FOLLOW
THAT
SITE
LINK
TO
YET
ANOTHER
SITE
AND
SO
FORTH
FOLLOWING
LINKS
UNTIL
REACHING
A
ROOT
A
SITE
THAT
HAS
A
LINK
TO
ITSELF
WHICH
IS
GUARAN
TEED
TO
HAPPEN
AS
YOU
WILL
SEE
TWO
SITES
ARE
IN
THE
SAME
COMPONENT
IF
AND
ONLY
IF
THIS
PROCESS
LEADS
THEM
TO
THE
SAME
ROOT
TO
VALIDATE
THIS
PROCESS
WE
NEED
UNION
P
Q
TO
MAINTAIN
THIS
INVARIANT
WHICH
IS
EASILY
ARRANGED
WE
FOLLOW
LINKS
TO
FIND
THE
ROOTS
ASSOCIATED
WITH
P
AND
Q
THEN
RENAME
ONE
OF
THE
COMPONENTS
BY
LINKING
ONE
OF
THESE
ROOTS
TO
THE
OTHER
HENCE
THE
NAME
QUICK
UNION
AGAIN
WE
HAVE
AN
ARBITRARY
CHOICE
OF
WHETHER
TO
RENAME
THE
COM
PONENT
CONTAINING
P
OR
THE
COMPONENT
CONTAINING
Q
THE
IMPLEMENTATION
ABOVE
RE
NAMES
THE
ONE
CONTAINING
P
THE
ID
IS
PARENT
LINK
REPRESENTATION
OF
A
FOREST
OF
TREES
ROOT
FIND
HAS
TO
FOLLOW
LINKS
TO
THE
ROOT
P
Q
FIGURE
ON
THE
NEXT
PAGE
SHOWS
A
TRACE
OF
THE
QUICK
UNION
ALGO
RITHM
FOR
TINYUF
TXT
THIS
TRACE
IS
BEST
UNDERSTOOD
IN
TERMS
OF
THE
BECOMES
PARENT
OF
FIND
IS
ID
ID
ID
UNION
CHANGES
JUST
ONE
LINK
FIND
IS
ID
ID
GRAPHICAL
REPRESENTATION
DEPICT
ED
AT
LEFT
WHICH
WE
CONSIDER
NEXT
P
Q
QUICK
UNION
OVERVIEW
FOREST
OF
TREES
REPRESENTATION
THE
CODE
FOR
QUICK
UNION
IS
COMPACT
BUT
A
BIT
OPAQUE
REPRESENTING
SITES
AS
NODES
LABELED
CIRCLES
AND
LINKS
AS
ARROWS
FROM
ONE
NODE
TO
AN
OTHER
GIVES
A
GRAPHICAL
REPRESENTATION
OF
THE
DATA
STRUCTURE
THAT
MAKES
IT
RELATIVELY
EASY
TO
UNDERSTAND
THE
OPERATION
OF
THE
ALGORITHM
THE
RESULTING
STRUCTURES
ARE
TREES
IN
TECHNICAL
TERMS
OUR
ID
ARRAY
IS
A
PARENT
LINK
REPRESENTATION
OF
A
FOREST
SET
OF
TREES
TO
SIM
PLIFY
THE
DIAGRAMS
WE
OFTEN
OMIT
BOTH
THE
ARROWHEADS
IN
THE
LINKS
BECAUSE
THEY
ALL
POINT
UPWARDS
AND
THE
SELF
LINKS
IN
THE
ROOTS
OF
THE
TREES
THE
FORESTS
CORRE
SPONDING
TO
THE
ID
ARRAY
FOR
TINYUF
TXT
ARE
SHOWN
AT
RIGHT
WHEN
WE
START
AT
THE
NODE
COR
RESPONDING
TO
ANY
SITE
AND
FOLLOW
LINKS
WE
EVENTUALLY
END
UP
AT
THE
ROOT
OF
THE
TREE
CONTAINING
THAT
NODE
WE
CAN
PROVE
THIS
PROP
ERTY
TO
BE
TRUE
BY
INDUCTION
IT
IS
TRUE
AFTER
THE
ARRAY
IS
INITIALIZED
TO
HAVE
EVERY
NODE
LINK
TO
ITSELF
AND
IF
IT
IS
TRUE
BEFORE
A
GIVEN
UNION
OPERATION
IT
IS
CERTAINLY
TRUE
AFTERWARD
THUS
THE
FIND
METHOD
ON
PAGE
RETURNS
THE
NAME
OF
THE
SITE
AT
THE
ROOT
SO
THAT
CONNECTED
CHECKS
WHETH
ER
TWO
SITES
ARE
IN
THE
SAME
TREE
THIS
REPRESENTATION
IS
USEFUL
FOR
THIS
PROBLEM
BECAUSE
THE
NODES
CORRESPONDING
TO
TWO
SITES
ARE
IN
THE
SAME
TREE
IF
AND
ONLY
IF
THE
SITES
ARE
IN
THE
SAME
COMPONENT
ID
P
Q
QUICK
UNION
TRACE
WITH
CORRESPONDING
FORESTS
OF
TREES
MOREOVER
THE
TREES
ARE
NOT
DIFFICULT
TO
BUILD
THE
UNION
IMPLEMENTATION
ON
PAGE
COMBINES
TWO
TREES
INTO
ONE
IN
A
SINGLE
STATEMENT
BY
MAKING
THE
ROOT
OF
ONE
THE
PARENT
OF
THE
OTHER
QUICK
UNION
ANALYSIS
THE
QUICK
UNION
ALGORITHM
WOULD
SEEM
TO
BE
FASTER
THAN
THE
QUICK
FIND
ALGORITHM
BECAUSE
IT
DOES
NOT
HAVE
TO
GO
THROUGH
THE
ENTIRE
ARRAY
FOR
EACH
INPUT
PAIR
BUT
HOW
MUCH
FASTER
IS
IT
ANALYZING
THE
ID
COST
OF
QUICK
UNION
IS
MORE
DIFFICULT
THAN
IT
WAS
FOR
QUICK
FIND
BECAUSE
THE
COST
IS
MORE
DEPENDENT
ON
THE
NATURE
OF
THE
INPUT
IN
THE
BEST
CASE
FIND
JUST
NEEDS
ONE
ARRAY
ACCESS
TO
FIND
THE
IDENTIFIER
ASSOCI
ATED
WITH
A
SITE
AS
IN
QUICK
FIND
IN
THE
WORST
CASE
IT
NEEDS
ARRAY
ACCESSES
AS
FOR
IN
THE
EXAMPLE
AT
LEFT
THIS
COUNT
IS
CONSERVATIVE
SINCE
COMPILED
CODE
WILL
TYPICALLY
NOT
DO
AN
ARRAY
ACCESS
FOR
THE
SECOND
REFERENCE
TO
ID
P
IN
THE
WHILE
LOOP
AC
CORDINGLY
IT
IS
NOT
DIFFICULT
TO
CONSTRUCT
A
BEST
CASE
INPUT
FOR
WHICH
THE
RUNNING
TIME
OF
OUR
DYNAMIC
CONNECTIVITY
CLIENT
IS
LINEAR
ON
THE
OTHER
HAND
IT
IS
ALSO
NOT
DIFFICULT
TO
CONSTRUCT
A
WORST
CASE
INPUT
FOR
WHICH
THE
RUNNING
TIME
IS
QUADRATIC
SEE
THE
DIA
DEPTH
QUICK
UNION
WORST
CASE
GRAM
AT
LEFT
AND
PROPOSITION
G
BELOW
FORTUNATE
LY
WE
DO
NOT
NEED
TO
FACE
THE
PROBLEM
OF
ANALYZING
QUICK
UNION
AND
WE
WILL
NOT
DWELL
ON
COMPARATIVE
PERFORMANCE
OF
QUICK
FIND
AND
QUICK
UNION
BE
CAUSE
WE
WILL
NEXT
EXAMINE
ANOTHER
VARIANT
THAT
IS
FAR
MORE
EFFICIENT
THAN
EITHER
FOR
THE
MOMENT
YOU
CAN
REGARD
QUICK
UNION
AS
AN
IMPROVEMENT
OVER
QUICK
FIND
BECAUSE
IT
REMOVES
QUICK
FIND
MAIN
LIABILITY
THAT
UNION
ALWAYS
TAKES
LINEAR
TIME
THIS
DIFFER
ENCE
CERTAINLY
REPRESENTS
AN
IMPROVEMENT
FOR
TYPICAL
DATA
BUT
QUICK
UNION
STILL
HAS
THE
LIABILITY
THAT
WE
CANNOT
GUARANTEE
IT
TO
BE
SUBSTANTIALLY
FASTER
THAN
QUICK
FIND
IN
EVERY
CASE
FOR
CERTAIN
INPUT
DATA
QUICK
UNION
IS
NO
FASTER
THAN
QUICK
FIND
AGAIN
SUPPOSE
THAT
WE
USE
QUICK
UNION
FOR
THE
DYNAMIC
CONNECTIVITY
PROBLEM
AND
WIND
UP
WITH
A
SINGLE
COMPONENT
AN
IMMEDIATE
IMPLICATION
OF
PROPOSITION
G
IS
THAT
THE
RUNNING
TIME
IS
QUADRATIC
IN
THE
WORST
CASE
SUPPOSE
THAT
THE
INPUT
PAIRS
COME
IN
THE
ORDER
THEN
THEN
AND
SO
FORTH
AFTER
N
SUCH
PAIRS
WE
HAVE
N
SITES
ALL
IN
THE
SAME
SET
AND
THE
TREE
THAT
IS
FORMED
BY
THE
QUICK
UNION
ALGORITHM
HAS
HEIGHT
N
WITH
LINKING
TO
WHICH
LINKS
TO
WHICH
LINKS
TO
AND
SO
FORTH
SEE
THE
DIAGRAM
ON
THE
FACING
PAGE
BY
PROPOSITION
G
THE
NUMBER
OF
ARRAY
ACCESSES
FOR
THE
UNION
OPERATION
FOR
THE
PAIR
I
IS
EXACTLY
SITE
IS
AT
DEPTH
I
AND
SITE
I
AT
DEPTH
THUS
THE
TOTAL
NUMBER
OF
ARRAY
ACCESSES
FOR
THE
FIND
OPERATIONS
FOR
THESE
N
PAIRS
IS
N
N
WEIGHTED
QUICK
UNION
FORTUNATELY
THERE
IS
AN
EASY
MODIFICATION
TO
QUICK
UNION
THAT
ALLOWS
US
TO
GUARANTEE
THAT
BAD
CASES
SUCH
AS
THIS
ONE
DO
NOT
OCCUR
RATHER
THAN
ARBITRARILY
CONNECTING
THE
QUICK
UNION
P
Q
SMALLER
TREE
MIGHT
PUT
THE
SMALLER
TREE
LARGER
TREE
SECOND
TREE
TO
THE
FIRST
FOR
UNION
WE
KEEP
TRACK
OF
THE
SIZE
OF
EACH
TREE
AND
ALWAYS
CONNECT
THE
SMALLER
TREE
TO
THE
LARGER
THIS
CHANGE
REQUIRES
SLIGHTLY
MORE
CODE
AND
ANOTHER
ARRAY
TO
HOLD
THE
NODE
COUNTS
AS
SHOWN
ON
PAGE
BUT
IT
LEADS
TO
SUBSTANTIAL
IMPROVEMENTS
IN
EFFICIENCY
WE
REFER
TO
THIS
ALGORITHM
AS
THE
WEIGHTED
QUICK
UNION
AL
WEIGHTED
LARGER
TREE
P
LARGER
TREE
LARGER
TREE
LOWER
ALWAYS
CHOOSES
THE
BETTER
ALTERNATIVE
Q
SMALLER
TREE
SMALLER
TREE
LARGER
TREE
GORITHM
THE
FOREST
OF
TREES
CONSTRUCTED
BY
THIS
ALGORITHM
FOR
TINYUF
TXT
IS
SHOWN
IN
THE
FIGURE
WEIGHTED
QUICK
UNION
AT
LEFT
ON
THE
TOP
OF
PAGE
EVEN
FOR
THIS
SMALL
EXAMPLE
THE
TREE
HEIGHT
IS
SUBSTANTIALLY
SMALLER
THAN
THE
HEIGHT
FOR
THE
UNWEIGHTED
VERSION
WEIGHTED
QUICK
UNION
ANALYSIS
THE
FIGURE
AT
RIGHT
ON
THE
TOP
OF
PAGE
ILLUSTRATES
THE
WORST
CASE
FOR
WEIGHTED
QUICK
UNION
WHEN
THE
SIZES
OF
THE
TREES
TO
BE
MERGED
BY
UNION
ARE
ALWAYS
EQUAL
AND
A
POWER
OF
THESE
TREE
STRUCTURES
LOOK
COMPLEX
BUT
THEY
HAVE
THE
SIMPLE
PROPERTY
THAT
THE
HEIGHT
OF
A
TREE
OF
NODES
IS
N
FUR
THERMORE
WHEN
WE
MERGE
TWO
TREES
OF
NODES
WE
GET
A
TREE
OF
NODES
AND
WE
INCREASE
THE
HEIGHT
OF
THE
TREE
TO
N
THIS
OBSERVATION
GENERALIZES
TO
PROVIDE
A
PROOF
THAT
THE
WEIGHTED
ALGORITHM
CAN
GUARANTEE
LOGARITHMIC
PERFORMANCE
ALGORITHM
CONTINUED
UNION
FIND
IMPLEMENTATION
WEIGHTED
QUICK
UNION
PUBLIC
CLASS
WEIGHTEDQUICKUNIONUF
PRIVATE
INT
ID
PARENT
LINK
SITE
INDEXED
PRIVATE
INT
SZ
SIZE
OF
COMPONENT
FOR
ROOTS
SITE
INDEXED
PRIVATE
INT
COUNT
NUMBER
OF
COMPONENTS
PUBLIC
WEIGHTEDQUICKUNIONUF
INT
N
COUNT
N
ID
NEW
INT
N
FOR
INT
I
I
N
I
ID
I
I
SZ
NEW
INT
N
FOR
INT
I
I
N
I
SZ
I
PUBLIC
INT
COUNT
RETURN
COUNT
PUBLIC
BOOLEAN
CONNECTED
INT
P
INT
Q
RETURN
FIND
P
FIND
Q
PRIVATE
INT
FIND
INT
P
FOLLOW
LINKS
TO
FIND
A
ROOT
WHILE
P
ID
P
P
ID
P
RETURN
P
PUBLIC
VOID
UNION
INT
P
INT
Q
INT
I
FIND
P
INT
J
FIND
Q
IF
I
J
RETURN
MAKE
SMALLER
ROOT
POINT
TO
LARGER
ONE
IF
SZ
I
SZ
J
ID
I
J
SZ
J
SZ
I
ELSE
ID
J
I
SZ
I
SZ
J
COUNT
THIS
CODE
IS
BEST
UNDERSTOOD
IN
TERMS
OF
THE
FOREST
OF
TREES
REPRESENTATION
DESCRIBED
IN
THE
TEXT
WE
ADD
A
SITE
INDEXED
ARRAY
SZ
AS
AN
INSTANCE
VARIABLE
SO
THAT
UNION
CAN
LINK
THE
ROOT
OF
THE
SMALLER
TREE
TO
THE
ROOT
OF
THE
LARGER
TREE
THIS
ADDITION
MAKES
IT
FEASIBLE
TO
ADDRESS
LARGE
PROBLEMS
REFERENCE
INPUT
WORST
CASE
INPUT
P
Q
P
Q
WEIGHTED
QUICK
UNION
TRACES
FORESTS
OF
TREES
QUICK
UNION
WEIGHTED
QUICK
UNION
AND
WEIGHTED
QUICK
UNION
SITES
UNION
OPERATIONS
FOR
DYNAMIC
CONNECTIVITY
THE
PRACTICAL
IMPLICATION
OF
PROPOSITION
H
AND
ITS
COROLLARY
IS
THAT
WEIGHTED
QUICK
UNION
IS
THE
ONLY
ONE
OF
THE
THREE
ALGORITHMS
THAT
CAN
FEASIBLY
BE
USED
FOR
HUGE
PRACTICAL
PROBLEMS
THE
WEIGHTED
QUICK
UNION
ALGORITHM
USES
AT
MOST
C
M
LG
N
ARRAY
ACCESSES
TO
PROCESS
M
CONNECTIONS
AMONG
N
SITES
FOR
A
SMALL
CONSTANT
C
THIS
RESULT
IS
IN
STARK
CONTRAST
TO
OUR
FINDING
THAT
QUICK
FIND
ALWAYS
AND
QUICK
UNION
SOMETIMES
USES
AT
LEAST
MN
ARRAY
ACCESSES
THUS
WITH
WEIGHTED
QUICK
UNION
WE
CAN
GUARANTEE
THAT
WE
CAN
SOLVE
HUGE
PRACTICAL
DYNAMIC
CONNECTIVITY
PROBLEMS
IN
A
REASON
ABLE
AMOUNT
OF
TIME
FOR
THE
PRICE
OF
A
FEW
EXTRA
LINES
OF
CODE
WE
GET
A
PROGRAM
THAT
CAN
BE
MILLIONS
OF
TIMES
FASTER
THAN
THE
SIMPLER
ALGORITHMS
FOR
THE
HUGE
DYNAMIC
CON
NECTIVITY
PROBLEMS
THAT
WE
MIGHT
ENCOUNTER
IN
PRACTICAL
APPLICATIONS
A
SITE
EXAMPLE
IS
SHOWN
ON
THE
TOP
OF
THIS
PAGE
IT
IS
EVIDENT
FROM
THIS
DIAGRAM
THAT
RELATIVELY
FEW
NODES
FALL
FAR
FROM
THE
ROOT
WITH
WEIGHTED
QUICK
UNION
INDEED
IT
IS
FREQUENTLY
THE
CASE
THAT
A
NODE
TREE
IS
MERGED
WITH
A
LARGER
TREE
WHICH
PUTS
THE
NODE
JUST
ONE
LINK
FROM
THE
ROOT
EMPIRICAL
STUDIES
ON
HUGE
PROBLEMS
TELL
US
THAT
WEIGHTED
QUICK
UNION
TYPICALLY
SOLVES
PRACTICAL
PROBLEMS
IN
CONSTANT
TIME
PER
OPERATION
WE
COULD
HARDLY
EXPECT
TO
FIND
A
MORE
EFFICIENT
ALGORITHM
ALGORITHM
ORDER
OF
GROWTH
FOR
N
SITES
WORST
CASE
CONSTRUCTOR
UNION
FIND
QUICK
FIND
N
N
QUICK
UNION
N
TREE
HEIGHT
TREE
HEIGHT
WEIGHTED
QUICK
UNION
N
LG
N
LG
N
WEIGHTED
QUICK
UNION
WITH
PATH
COMPRESSON
VERY
VERY
NEARLY
BUT
NOT
QUITE
AMORTIZED
SEE
EXERCISE
IMPOSSIBLE
N
PERFORMANCE
CHARACTERISTICS
OF
UNION
FIND
ALGORITHMS
OPTIMAL
ALGORITHMS
CAN
WE
FIND
AN
ALGORITHM
THAT
HAS
GUARANTEED
CONSTANT
TIME
PER
OPERATION
PERFORMANCE
THIS
QUESTION
IS
AN
EXTREMELY
DIFFICULT
ONE
THAT
PLAGUED
RESEARCHERS
FOR
MANY
YEARS
IN
PURSUIT
OF
AN
ANSWER
A
NUMBER
OF
VARIATIONS
OF
QUICK
UNION
AND
WEIGHTED
QUICK
UNION
HAVE
BEEN
STUDIED
FOR
EXAMPLE
THE
FOLLOWING
METH
OD
KNOWN
AS
PATH
COMPRESSION
IS
EASY
TO
IMPLEMENT
IDEALLY
WE
WOULD
LIKE
EVERY
NODE
TO
LINK
DIRECTLY
TO
THE
ROOT
OF
ITS
TREE
BUT
WE
DO
NOT
WANT
TO
PAY
THE
PRICE
OF
CHANGING
A
LARGE
NUMBER
OF
LINKS
AS
WE
DID
IN
THE
QUICK
FIND
ALGORITHM
WE
CAN
APPROACH
THE
IDEAL
SIMPLY
BY
MAKING
ALL
THE
NODES
THAT
WE
DO
EXAMINE
DIRECTLY
LINK
TO
THE
ROOT
THIS
STEP
SEEMS
DRASTIC
AT
FIRST
BLUSH
BUT
IT
IS
EASY
TO
IMPLEMENT
AND
THERE
IS
NOTHING
SACROSANCT
ABOUT
THE
STRUCTURE
OF
THESE
TREES
IF
WE
CAN
MODIFY
THEM
TO
MAKE
THE
ALGORITHM
MORE
EFFICIENT
WE
SHOULD
DO
SO
TO
IMPLEMENT
PATH
COMPRESSION
WE
JUST
ADD
ANOTHER
LOOP
TO
FIND
THAT
SETS
THE
ID
ENTRY
CORRESPONDING
TO
EACH
NODE
ENCOUNTERED
ALONG
THE
WAY
TO
LINK
DIRECTLY
TO
THE
ROOT
THE
NET
RESULT
IS
TO
FLATTEN
THE
TREES
ALMOST
COMPLETELY
AP
PROXIMATING
THE
IDEAL
ACHIEVED
BY
THE
QUICK
FIND
ALGORITHM
THE
METHOD
IS
SIMPLE
AND
EFFECTIVE
BUT
YOU
ARE
NOT
LIKELY
TO
BE
ABLE
TO
DISCERN
ANY
IMPROVEMENT
OVER
WEIGHTED
QUICK
UNION
IN
A
PRACTICAL
SITUATION
SEE
EXERCISE
THEORETICAL
RESULTS
ABOUT
THE
SITUATION
ARE
EXTREMELY
COMPLICATED
AND
QUITE
REMARKABLE
WEIGHTED
QUICK
UNION
WITH
PATH
COMPRESSION
IS
OPTIMAL
BUT
NOT
QUITE
CONSTANT
TIME
PER
OPERATION
THAT
IS
NOT
ONLY
IS
WEIGHTED
QUICK
FIND
WITH
PATH
COMPRESSION
NOT
CONSTANT
TIME
PER
OPERATION
IN
THE
WORST
CASE
AMORTIZED
BUT
ALSO
THERE
EXISTS
NO
ALGORITHM
THAT
CAN
GUARANTEE
TO
PERFORM
EACH
UNION
FIND
OPERATION
IN
AMORTIZED
CONSTANT
TIME
UNDER
THE
VERY
GENERAL
CELL
PROBE
MODEL
OF
COMPUTATION
WEIGHTED
QUICK
UNION
WITH
PATH
COMPRESSION
IS
VERY
CLOSE
TO
THE
BEST
THAT
WE
CAN
DO
FOR
THIS
PROBLEM
QUICK
FIND
AMORTIZED
COST
PLOTS
AS
WITH
ANY
DATA
TYPE
IMPLEMENTATION
IT
IS
WORTHWHILE
TO
RUN
EXPERIMENTS
TO
TEST
THE
VALIDITY
OF
OUR
PERFORMANCE
HYPOTHESES
FOR
TYPICAL
CLIENTS
AS
DIS
CUSSION
IN
SECTION
THE
FIGURE
AT
LEFT
SHOWS
DETAILS
OF
THE
PERFORMANCE
OF
THE
ALGORITHMS
FOR
OUR
DYNAMIC
CONNECTIVITY
DEVELOPMENT
CLIENT
WHEN
SOLVING
OUR
SITE
CONNECTIVITY
EXAMPLE
MEDIUMUF
TXT
SUCH
DIAGRAMS
ARE
EASY
TO
PRO
UNION
OPERATIONS
USE
AT
LEAST
REFERENCES
ONE
GRAY
DOT
FOR
EACH
CONNECTION
PROCESSED
BY
CLIENT
DUCE
SEE
EXERCISE
FOR
THE
I
TH
CONNEC
TION
PROCESSED
WE
MAINTAIN
A
VARIABLE
COST
THAT
COUNTS
THE
NUMBER
OF
ARRAY
ACCESSES
TO
ID
OR
SZ
AND
A
VARIABLE
TOTAL
THAT
IS
THE
SUM
OF
THE
TOTAL
NUMBER
OF
ARRAY
ACCESSES
SO
FAR
THEN
WE
PLOT
A
GRAY
DOT
AT
I
COST
AND
A
RED
DOT
AT
I
TOTAL
I
THE
RED
DOTS
ARE
THE
AVERAGE
COST
PER
OPERATION
OR
AMORTIZED
COST
THESE
RED
DOTS
GIVE
CUMULATIVE
AVERAGE
CONNECTED
OPERATIONS
USE
EXACTLY
ARRAY
ACCESSES
PLOTS
PROVIDE
GOOD
INSIGHTS
INTO
ALGORITHM
BE
HAVIOR
FOR
QUICK
FIND
EVERY
UNION
OPERA
TION
USES
AT
LEAST
ACCESSES
PLUS
FOR
EACH
COMPONENT
MERGED
UP
TO
ANOTHER
AND
EVERY
CONNECTED
OPERATION
USES
ACCESSES
INITIALLY
MOST
OF
THE
CONNECTIONS
LEAD
TO
A
CALL
ON
UNION
SO
THE
CUMULATIVE
AVERAGE
HOVERS
AROUND
LATER
MOST
CONNECTIONS
ARE
CALLS
TO
QUICK
UNION
NUMBER
OF
CONNECTIONS
FIND
OPERATIONS
BECOME
EXPENSIVE
CONNECTED
THAT
CAUSE
THE
CALL
TO
UNION
TO
BE
SKIPPED
SO
THE
CUMULATIVE
AVERAGE
DECREAS
ES
BUT
STILL
REMAINS
RELATIVELY
HIGH
INPUTS
THAT
LEAD
TO
A
LARGE
NUMBER
OF
CONNECTED
CALLS
THAT
CAUSE
UNION
TO
BE
SKIPPED
WILL
EXHIBIT
SIGNIFI
CANTLY
BETTER
PERFORMANCE
SEE
EXERCISE
FOR
AN
EXAMPLE
FOR
QUICK
UNION
ALL
OPERATIONS
WEIGHTED
QUICK
UNION
NO
EXPENSIVE
OPERATIONS
INITIALLY
REQUIRE
ONLY
A
FEW
ARRAY
ACCESSES
EVENTU
ALLY
THE
HEIGHT
OF
THE
TREES
BECOMES
A
SIGNIFICANT
FACTOR
AND
THE
AMORTIZED
COST
GROWS
NOTICABLY
COST
OF
ALL
OPERATIONS
SITES
FOR
WEIGHTED
QUICK
UNION
THE
TREE
HEIGHT
STAYS
SMALL
NONE
OF
THE
OPERATIONS
ARE
EXPENSIVE
AND
THE
AMORTIZED
COST
IS
LOW
THESE
EXPERIMENTS
VALIDATE
OUR
CONCLUSION
THAT
WEIGHTED
QUICK
UNION
IS
CERTAINLY
WORTH
IMPLEMENTING
AND
THAT
THERE
IS
NOT
MUCH
FURTHER
ROOM
FOR
IMPROVEMENT
FOR
PRACTICAL
PROBLEMS
PERSPECTIVE
EACH
OF
THE
UF
IMPLEMENTATIONS
THAT
WE
CONSIDERED
IS
AN
IMPROVEMENT
OVER
THE
PREVIOUS
IN
SOME
INTUITIVE
SENSE
BUT
THE
PROCESS
IS
ARTIFICIALLY
SMOOTH
BECAUSE
WE
HAVE
THE
BENEFIT
OF
HINDSIGHT
IN
LOOKING
OVER
THE
DEVELOPMENT
OF
THE
ALGORITHMS
AS
THEY
WERE
STUDIED
BY
RESEARCHERS
OVER
THE
YEARS
THE
IMPLEMENTATIONS
ARE
SIMPLE
AND
THE
PROBLEM
IS
WELL
SPECIFIED
SO
WE
CAN
EVALUATE
THE
VARIOUS
ALGORITHMS
DIRECTLY
BY
RUN
NING
EMPIRICAL
STUDIES
FURTHERMORE
WE
CAN
USE
THESE
STUDIES
TO
VALIDATE
MATHEMATICAL
RESULTS
THAT
QUANTIFY
THE
PERFORMANCE
OF
THESE
ALGORITHMS
WHEN
POSSIBLE
WE
FOLLOW
THE
SAME
BASIC
STEPS
FOR
FUNDAMENTAL
PROBLEMS
THROUGHOUT
THE
BOOK
THAT
WE
HAVE
TAKEN
FOR
UNION
FIND
ALGORITHMS
IN
THIS
SECTION
SOME
OF
WHICH
ARE
HIGHLIGHTED
IN
THIS
LIST
DECIDE
ON
A
COMPLETE
AND
SPECIFIC
PROBLEM
STATEMENT
INCLUDING
IDENTIFYING
FUNDAMENTAL
ABSTRACT
OPERATIONS
THAT
ARE
INTRINSIC
TO
THE
PROBLEM
AND
AN
API
CAREFULLY
DEVELOP
A
SUCCINCT
IMPLEMENTATION
FOR
A
STRAIGHTFORWARD
ALGORITHM
USING
A
WELL
THOUGHT
OUT
DEVELOPMENT
CLIENT
AND
REALISTIC
INPUT
DATA
KNOW
WHEN
AN
IMPLEMENTATION
COULD
NOT
POSSIBLY
BE
USED
TO
SOLVE
PROBLEMS
ON
THE
SCALE
CONTEMPLATED
AND
MUST
BE
IMPROVED
OR
ABANDONED
DEVELOP
IMPROVED
IMPLEMENTATIONS
THROUGH
A
PROCESS
OF
STEPWISE
REFINEMENT
VALIDATING
THE
EFFICACY
OF
IDEAS
FOR
IMPROVEMENT
THROUGH
EMPIRICAL
ANALYSIS
MATHEMATICAL
ANALYSIS
OR
BOTH
FIND
HIGH
LEVEL
ABSTRACT
REPRESENTATIONS
OF
DATA
STRUCTURES
OR
ALGORITHMS
IN
OP
ERATION
THAT
ENABLE
EFFECTIVE
HIGH
LEVEL
DESIGN
OF
IMPROVED
VERSIONS
STRIVE
FOR
WORST
CASE
PERFORMANCE
GUARANTEES
WHEN
POSSIBLE
BUT
ACCEPT
GOOD
PERFORMANCE
ON
TYPICAL
DATA
WHEN
AVAILABLE
KNOW
WHEN
TO
LEAVE
FURTHER
IMPROVEMENTS
FOR
DETAILED
IN
DEPTH
STUDY
TO
SKILLED
RESEARCHERS
AND
MOVE
ON
TO
THE
NEXT
PROBLEM
THE
POTENTIAL
FOR
SPECTACULAR
PERFORMANCE
IMPROVEMENTS
FOR
PRACTICAL
PROBLEMS
SUCH
AS
THOSE
THAT
WE
SAW
FOR
UNION
FIND
MAKES
ALGORITHM
DESIGN
A
COMPELLING
FIELD
OF
STUDY
WHAT
OTHER
DESIGN
ACTIVITIES
HOLD
THE
POTENTIAL
TO
REAP
SAVINGS
FACTORS
OF
MILLIONS
OR
BILLIONS
OR
MORE
DEVELOPING
AN
EFFICIENT
ALGORITHM
IS
AN
INTELLECTUALLY
SATISFYING
ACTIVITY
THAT
CAN
HAVE
DIRECT
PRACTICAL
PAYOFF
AS
THE
DYNAMIC
CONNECTIVITY
PROBLEM
INDICATES
A
SIMPLY
STATED
PROBLEM
CAN
LEAD
US
TO
STUDY
NUMEROUS
ALGORITHMS
THAT
ARE
NOT
ONLY
BOTH
USEFUL
AND
INTERESTING
BUT
ALSO
INTRICATE
AND
CHALLENGING
TO
UNDERSTAND
WE
SHALL
ENCOUNTER
MANY
INGENIOUS
ALGORITHMS
THAT
HAVE
BEEN
DEVELOPED
OVER
THE
YEARS
FOR
A
HOST
OF
PRACTICAL
PROBLEMS
AS
THE
SCOPE
OF
APPLICABILITY
OF
COMPUTATIONAL
SOLUTIONS
TO
SCIENTIFIC
AND
COMMERCIAL
PROBLEMS
WIDENS
SO
ALSO
GROWS
THE
IMPORTANCE
OF
BEING
ABLE
TO
USE
EF
FICIENT
ALGORITHMS
TO
SOLVE
KNOWN
PROBLEMS
AND
OF
BEING
ABLE
TO
DEVELOP
EFFICIENT
SOLU
TIONS
TO
NEW
PROBLEMS
Q
I
D
LIKE
TO
ADD
A
DELETE
METHOD
TO
THE
API
THAT
ALLOWS
CLIENTS
TO
DELETE
CONNEC
TIONS
ANY
ADVICE
ON
HOW
TO
PROCEED
A
NO
ONE
HAS
DEVISED
AN
ALGORITHM
AS
SIMPLE
AND
EFFICIENT
AS
THE
ONES
IN
THIS
SECTION
THAT
CAN
HANDLE
DELETIONS
THIS
THEME
RECURS
THROUGHOUT
THIS
BOOK
SEVERAL
OF
THE
DATA
STRUCTURES
THAT
WE
CONSIDER
HAVE
THE
PROPERTY
THAT
DELETING
SOMETHING
IS
MUCH
MORE
DIFFICULT
THAN
ADDING
SOMETHING
Q
WHAT
IS
THE
CELL
PROBE
MODEL
A
A
MODEL
OF
COMPUTATION
WHERE
WE
ONLY
COUNT
ACCESSES
TO
A
RANDOM
ACCESS
MEMORY
LARGE
ENOUGH
TO
HOLD
THE
INPUT
AND
CONSIDER
ALL
OTHER
OPERATIONS
TO
BE
FREE
SHOW
THE
CONTENTS
OF
THE
ID
ARRAY
AND
THE
NUMBER
OF
TIMES
THE
AR
RAY
IS
ACCESSED
FOR
EACH
INPUT
PAIR
WHEN
YOU
USE
QUICK
FIND
FOR
THE
SEQUENCE
DO
EXERCISE
BUT
USE
QUICK
UNION
PAGE
IN
ADDITION
DRAW
THE
FOREST
OF
TREES
REPRESENTED
BY
THE
ID
ARRAY
AFTER
EACH
INPUT
PAIR
IS
PROCESSED
DO
EXERCISE
BUT
USE
WEIGHTED
QUICK
UNION
PAGE
SHOW
THE
CONTENTS
OF
THE
SZ
AND
ID
ARRAYS
AND
THE
NUMBER
OF
ARRAY
ACCESSES
FOR
EACH
INPUT
PAIR
CORRESPONDING
TO
THE
WEIGHTED
QUICK
UNION
EXAMPLES
IN
THE
TEXT
BOTH
THE
REFERENCE
INPUT
AND
THE
WORST
CASE
INPUT
ESTIMATE
THE
MINIMUM
AMOUNT
OF
TIME
IN
DAYS
THAT
WOULD
BE
REQUIRED
FOR
QUICK
FIND
TO
SOLVE
A
DYNAMIC
CONNECTIVITY
PROBLEM
WITH
SITES
AND
INPUT
PAIRS
ON
A
COMPUTER
CAPABLE
OF
EXECUTING
INSTRUCTIONS
PER
SECOND
ASSUME
THAT
EACH
ITERA
TION
OF
THE
INNER
FOR
LOOP
REQUIRES
MACHINE
INSTRUCTIONS
REPEAT
EXERCISE
FOR
WEIGHTED
QUICK
UNION
DEVELOP
CLASSES
QUICKUNIONUF
AND
QUICKFINDUF
THAT
IMPLEMENT
QUICK
UNION
AND
QUICK
FIND
RESPECTIVELY
GIVE
A
COUNTEREXAMPLE
THAT
SHOWS
WHY
THIS
INTUITIVE
IMPLEMENTATION
OF
UNION
FOR
QUICK
FIND
IS
NOT
CORRECT
PUBLIC
VOID
UNION
INT
P
INT
Q
IF
CONNECTED
P
Q
RETURN
RENAME
P
COMPONENT
TO
Q
NAME
FOR
INT
I
I
ID
LENGTH
I
IF
ID
I
ID
P
ID
I
ID
Q
COUNT
DRAW
THE
TREE
CORRESPONDING
TO
THE
ID
ARRAY
DEPICTED
AT
RIGHT
CAN
THIS
BE
THE
RESULT
OF
RUNNING
WEIGHTED
QUICK
UNION
EXPLAIN
WHY
THIS
IS
IMPOSSIBLE
OR
GIVE
A
SEQUENCE
OF
OPERATIONS
THAT
RESULTS
IN
THIS
ARRAY
I
ID
I
EXERCISES
CONTINUED
IN
THE
WEIGHTED
QUICK
UNION
ALGORITHM
SUPPOSE
THAT
WE
SET
ID
FIND
P
TO
Q
INSTEAD
OF
TO
ID
FIND
Q
WOULD
THE
RESULTING
ALGORITHM
BE
CORRECT
ANSWER
YES
BUT
IT
WOULD
INCREASE
THE
TREE
HEIGHT
SO
THE
PERFORMANCE
GUARANTEE
WOULD
BE
INVALID
IMPLEMENT
WEIGHTED
QUICK
FIND
WHERE
YOU
ALWAYS
CHANGE
THE
ID
ENTRIES
OF
THE
SMALLER
COMPONENT
TO
THE
IDENTIFIER
OF
THE
LARGER
COMPONENT
HOW
DOES
THIS
CHANGE
AFFECT
PERFORMANCE
QUICK
UNION
WITH
PATH
COMPRESSION
MODIFY
QUICK
UNION
PAGE
TO
INCLUDE
PATH
COMPRESSION
BY
ADDING
A
LOOP
TO
UNION
THAT
LINKS
EVERY
SITE
ON
THE
PATHS
FROM
P
AND
Q
TO
THE
ROOTS
OF
THEIR
TREES
TO
THE
ROOT
OF
THE
NEW
TREE
GIVE
A
SEQUENCE
OF
INPUT
PAIRS
THAT
CAUSES
THIS
METHOD
TO
PRODUCE
A
PATH
OF
LENGTH
NOTE
THE
AMORTIZED
COST
PER
OPERATION
FOR
THIS
ALGORITHM
IS
KNOWN
TO
BE
LOGARITHMIC
WEIGHTED
QUICK
UNION
WITH
PATH
COMPRESSION
MODIFY
WEIGHTED
QUICK
UNION
ALGORITHM
TO
IMPLEMENT
PATH
COMPRESSION
AS
DESCRIBED
IN
EXERCISE
GIVE
A
SEQUENCE
OF
INPUT
PAIRS
THAT
CAUSES
THIS
METHOD
TO
PRODUCE
A
TREE
OF
HEIGHT
NOTE
THE
AMORTIZED
COST
PER
OPERATION
FOR
THIS
ALGORITHM
IS
KNOWN
TO
BE
BOUNDED
BY
A
FUNCTION
KNOWN
AS
THE
INVERSE
ACKERMANN
FUNCTION
AND
IS
LESS
THAN
FOR
ANY
CONCEIVABLE
PRACTICAL
VALUE
OF
N
WEIGHTED
QUICK
UNION
BY
HEIGHT
DEVELOP
A
UF
IMPLEMENTATION
THAT
USES
THE
SAME
BASIC
STRATEGY
AS
WEIGHTED
QUICK
UNION
BUT
KEEPS
TRACK
OF
TREE
HEIGHT
AND
ALWAYS
LINKS
THE
SHORTER
TREE
TO
THE
TALLER
ONE
PROVE
A
LOGARITHMIC
UPPER
BOUND
ON
THE
HEIGHT
OF
THE
TREES
FOR
N
SITES
WITH
YOUR
ALGORITHM
BINOMIAL
TREES
SHOW
THAT
THE
NUMBER
OF
NODES
AT
EACH
LEVEL
IN
THE
WORST
CASE
TREES
FOR
WEIGHTED
QUICK
UNION
ARE
BINOMIAL
COEFFICIENTS
COMPUTE
THE
AVERAGE
DEPTH
OF
A
NODE
IN
A
WORST
CASE
TREE
WITH
N
NODES
AMORTIZED
COSTS
PLOTS
INSTRUMENT
YOUR
IMPLEMENTATIONS
FROM
EXERCISE
TO
MAKE
AMORTIZED
COSTS
PLOTS
LIKE
THOSE
IN
THE
TEXT
RANDOM
CONNECTIONS
DEVELOP
A
UF
CLIENT
ERDOSRENYI
THAT
TAKES
AN
INTEGER
VALUE
N
FROM
THE
COMMAND
LINE
GENERATES
RANDOM
PAIRS
OF
INTEGERS
BETWEEN
AND
N
CALLING
CONNECTED
TO
DETERMINE
IF
THEY
ARE
CONNECTED
AND
THEN
UNION
IF
NOT
AS
IN
OUR
DEVELOPMENT
CLIENT
LOOPING
UNTIL
ALL
SITES
ARE
CONNECTED
AND
PRINTING
THE
NUMBER
OF
CONNECTIONS
GENERATED
PACKAGE
YOUR
PROGRAM
AS
A
STATIC
METHOD
COUNT
THAT
TAKES
N
AS
ARGUMENT
AND
RETURNS
THE
NUMBER
OF
CONNECTIONS
AND
A
MAIN
THAT
TAKES
N
FROM
THE
COMMAND
LINE
CALLS
COUNT
AND
PRINTS
THE
RETURNED
VALUE
RANDOM
GRID
GENERATOR
WRITE
A
PROGRAM
RANDOMGRID
THAT
TAKES
AN
INT
VALUE
N
FROM
THE
COMMAND
LINE
GENERATES
ALL
THE
CONNECTIONS
IN
AN
N
BY
N
GRID
PUTS
THEM
IN
RANDOM
ORDER
RANDOMLY
ORIENTS
THEM
SO
THAT
P
Q
AND
Q
P
ARE
EQUALLY
LIKELY
TO
OC
CUR
AND
PRINTS
THE
RESULT
TO
STANDARD
OUTPUT
TO
RANDOMLY
ORDER
THE
CONNECTIONS
USE
A
RANDOMBAG
SEE
EXERCISE
ON
PAGE
TO
ENCAPSULATE
P
AND
Q
IN
A
SINGLE
OBJECT
CREATIVE
PROBLEMS
CONTINUED
USE
THE
CONNECTION
NESTED
CLASS
SHOWN
BELOW
PACKAGE
YOUR
PROGRAM
AS
TWO
STATIC
METHODS
GENERATE
WHICH
TAKES
N
AS
ARGUMENT
AND
RETURNS
AN
ARRAY
OF
CONNEC
TIONS
AND
MAIN
WHICH
TAKES
N
FROM
THE
COMMAND
LINE
CALLS
GENERATE
AND
ITERATES
THROUGH
THE
RETURNED
ARRAY
TO
PRINT
THE
CONNECTIONS
ANIMATION
WRITE
A
RANDOMGRID
CLIENT
SEE
EXERCISE
THAT
USES
UNIONFIND
AS
IN
OUR
DEVELOPMENT
CLIENT
TO
CHECK
CONNECTIVITY
AND
USES
STDDRAW
TO
DRAW
THE
CONNECTIONS
AS
THEY
ARE
PROCESSED
DYNAMIC
GROWTH
USING
LINKED
LISTS
OR
A
RESIZING
ARRAY
DEVELOP
A
WEIGHTED
QUICK
UNION
IMPLEMENTATION
THAT
REMOVES
THE
RESTRICTION
ON
NEEDING
THE
NUMBER
OF
OBJECTS
AHEAD
OF
TIME
ADD
A
METHOD
NEWSITE
TO
THE
API
WHICH
RETURNS
AN
INT
IDENTIFIER
ERDS
RENYI
MODEL
USE
YOUR
CLIENT
FROM
EXERCISE
TO
TEST
THE
HYPOTHESIS
THAT
THE
NUMBER
OF
PAIRS
GENERATED
TO
GET
ONE
COMPONENT
IS
LN
N
DOUBLING
TEST
FOR
ERDS
RENYI
MODEL
DEVELOP
A
PERFORMANCE
TESTING
CLIENT
THAT
TAKES
AN
INT
VALUE
T
FROM
THE
COMMAND
LINE
AND
PERFORMS
T
TRIALS
OF
THE
FOLLOWING
EX
PERIMENT
USE
YOUR
CLIENT
FROM
EXERCISE
TO
GENERATE
RANDOM
CONNECTIONS
USING
UNIONFIND
TO
DETERMINE
CONNECTIVITY
AS
IN
OUR
DEVELOPMENT
CLIENT
LOOPING
UNTIL
ALL
SITES
ARE
CONNECTED
FOR
EACH
N
PRINT
THE
VALUE
OF
N
THE
AVERAGE
NUMBER
OF
CONNECTIONS
PROCESSED
AND
THE
RATIO
OF
THE
RUNNING
TIME
TO
THE
PREVIOUS
USE
YOUR
PROGRAM
TO
VALI
DATE
THE
HYPOTHESES
IN
THE
TEXT
THAT
THE
RUNNING
TIMES
FOR
QUICK
FIND
AND
QUICK
UNION
ARE
QUADRATIC
AND
WEIGHTED
QUICK
UNION
IS
NEAR
LINEAR
COMPARE
QUICK
FIND
WITH
QUICK
UNION
FOR
ERDS
RENYI
MODEL
DEVELOP
A
PERFOR
MANCE
TESTING
CLIENT
THAT
TAKES
AN
INT
VALUE
T
FROM
THE
COMMAND
LINE
AND
PERFORMS
T
TRIALS
OF
THE
FOLLOWING
EXPERIMENT
USE
YOUR
CLIENT
FROM
EXERCISE
TO
GENERATE
RANDOM
CONNECTIONS
SAVE
THE
CONNECTIONS
SO
THAT
YOU
CAN
USE
BOTH
QUICK
UNION
AND
QUICK
FIND
TO
DETERMINE
CONNECTIVITY
AS
IN
OUR
DEVELOPMENT
CLIENT
LOOPING
UNTIL
ALL
SITES
ARE
CONNECTED
FOR
EACH
N
PRINT
THE
VALUE
OF
N
AND
THE
RATIO
OF
THE
TWO
RUNNING
TIMES
FAST
ALGORITHMS
FOR
ERDS
RENYI
MODEL
ADD
WEIGHTED
QUICK
UNION
AND
WEIGHT
ED
QUICK
UNION
WITH
PATH
COMPRESSION
TO
YOUR
TESTS
FROM
EXERCISE
CAN
YOU
DISCERN
A
DIFFERENCE
BETWEEN
THESE
TWO
ALGORITHMS
DOUBLING
TEST
FOR
RANDOM
GRIDS
DEVELOP
A
PERFORMANCE
TESTING
CLIENT
THAT
TAKES
AN
INT
VALUE
T
FROM
THE
COMMAND
LINE
AND
PERFORMS
T
TRIALS
OF
THE
FOLLOWING
EXPERIE
MENT
USE
YOUR
CLIENT
FROM
EXERCISE
TO
GENERATE
THE
CONNECTIONS
IN
AN
N
BY
N
SQUARE
GRID
RANDOMLY
ORIENTED
AND
IN
RANDOM
ORDER
THEN
USE
UNIONFIND
TO
DETERMINE
CONNECTIVITY
AS
IN
OUR
DEVELOPMENT
CLIENT
LOOPING
UNTIL
ALL
SITES
ARE
CONNECTED
FOR
EACH
N
PRINT
THE
VALUE
OF
N
THE
AVERAGE
NUMBER
OF
CONNECTIONS
PROCESSED
AND
THE
RATIO
OF
THE
RUNNING
TIME
TO
THE
PREVIOUS
USE
YOUR
PROGRAM
TO
VALIDATE
THE
HYPOTHESES
IN
THE
TEXT
THAT
THE
RUNNING
TIMES
FOR
QUICK
FIND
AND
QUICK
UNION
ARE
QUADRATIC
AND
WEIGHTED
QUICK
UNION
IS
NEAR
LINEAR
NOTE
AS
N
DOUBLES
THE
NUMBER
OF
SITES
IN
THE
GRID
INCREASES
BY
A
FACTOR
OF
SO
EXPECT
A
DOUBLING
FACTOR
OF
FOR
QUADRATIC
AND
FOR
LINEAR
EXPERIMENTS
CONTINUED
AMORTIZED
PLOT
FOR
ERDS
RENYI
DEVELOP
A
CLIENT
THAT
TAKES
AN
INT
VALUE
N
FROM
THE
COMMAND
LINE
AND
DOES
AN
AMORTIZED
PLOT
OF
THE
COST
OF
ALL
OPERATIONS
IN
THE
STYLE
OF
THE
PLOTS
IN
THE
TEXT
FOR
THE
PROCESS
OF
GENERATING
RANDOM
PAIRS
OF
INTEGERS
BETWEEN
AND
N
CALLING
CONNECTED
TO
DETERMINE
IF
THEY
ARE
CONNECTED
AND
THEN
UNION
IF
NOT
AS
IN
OUR
DEVELOPMENT
CLIENT
LOOPING
UNTIL
ALL
SITES
ARE
CONNECTED
THIS
PAGE
INTENTIONALLY
LEFT
BLANK
TWO
SORTING
ELEMENTARY
SORTS
MERGESORT
QUICKSORT
PRIORITY
QUEUES
APPLICATIONS
ORTING
IS
THE
PROCESS
OF
REARRANGING
A
SEQUENCE
OF
OBJECTS
SO
AS
TO
PUT
THEM
IN
SOME
LOGICAL
ORDER
FOR
EXAMPLE
YOUR
CREDIT
CARD
BILL
PRESENTS
TRANSACTIONS
IN
ORDER
BY
DATE
THEY
WERE
LIKELY
PUT
INTO
THAT
ORDER
BY
A
SORTING
ALGORITHM
IN
THE
EARLY
DAYS
OF
COMPUTING
THE
COMMON
WISDOM
WAS
THAT
UP
TO
PERCENT
OF
ALL
COM
PUTING
CYCLES
WAS
SPENT
SORTING
IF
THAT
FRACTION
IS
LOWER
TODAY
ONE
LIKELY
REASON
IS
THAT
SORTING
ALGORITHMS
ARE
RELATIVELY
EFFICIENT
NOT
THAT
SORTING
HAS
DIMINISHED
IN
RELATIVE
IMPORTANCE
INDEED
THE
UBIQUITY
OF
COMPUTER
USAGE
HAS
PUT
US
AWASH
IN
DATA
AND
THE
FIRST
STEP
TO
ORGANIZING
DATA
IS
OFTEN
TO
SORT
IT
ALL
COMPUTER
SYSTEMS
HAVE
IMPLEMENTA
TIONS
OF
SORTING
ALGORITHMS
FOR
USE
BY
THE
SYSTEM
AND
BY
USERS
THERE
ARE
THREE
PRACTICAL
REASONS
FOR
YOU
TO
STUDY
SORTING
ALGORITHMS
EVEN
THOUGH
YOU
MIGHT
JUST
USE
A
SYSTEM
SORT
ANALYZING
SORTING
ALGORITHMS
IS
A
THOROUGH
INTRODUCTION
TO
THE
APPROACH
THAT
WE
USE
TO
COMPARE
ALGORITHM
PERFORMANCE
THROUGHOUT
THE
BOOK
SIMILAR
TECHNIQUES
ARE
EFFECTIVE
IN
ADDRESSING
OTHER
PROBLEMS
WE
OFTEN
USE
SORTING
ALGORITHMS
AS
A
STARTING
POINT
TO
SOLVE
OTHER
PROBLEMS
MORE
IMPORTANT
THAN
THESE
PRACTICAL
REASONS
IS
THAT
THE
ALGORITHMS
ARE
ELEGANT
CLASSIC
AND
EFFECTIVE
SORTING
PLAYS
A
MAJOR
ROLE
IN
COMMERCIAL
DATA
PROCESSING
AND
IN
MODERN
SCIENTIFIC
COMPUTING
APPLICATIONS
ABOUND
IN
TRANSACTION
PROCESSING
COMBINATORIAL
OPTIMIZA
TION
ASTROPHYSICS
MOLECULAR
DYNAMICS
LINGUISTICS
GENOMICS
WEATHER
PREDICTION
AND
MANY
OTHER
FIELDS
INDEED
A
SORTING
ALGORITHM
QUICKSORT
IN
SECTION
WAS
NAMED
AS
ONE
OF
THE
TOP
TEN
ALGORITHMS
FOR
SCIENCE
AND
ENGINEERING
OF
THE
CENTURY
IN
THIS
CHAPTER
WE
CONSIDER
SEVERAL
CLASSICAL
SORTING
METHODS
AND
AN
EFFICIENT
IMPLE
MENTATION
OF
A
FUNDAMENTAL
DATA
TYPE
KNOWN
AS
THE
PRIORITY
QUEUE
WE
DISCUSS
THE
THEORETICAL
BASIS
FOR
COMPARING
SORTING
ALGORITHMS
AND
CONCLUDE
THE
CHAPTER
WITH
A
SURVEY
OF
APPLICATIONS
OF
SORTING
AND
PRIORITY
QUEUES
FOR
OUR
FIRST
EXCURSION
INTO
THE
AREA
OF
SORTING
ALGORITHMS
WE
SHALL
STUDY
TWO
ELE
MENTARY
SORTING
METHODS
AND
A
VARIATION
OF
ONE
OF
THEM
AMONG
THE
REASONS
FOR
STUDY
ING
THESE
RELATIVELY
SIMPLE
ALGORITHMS
IN
DETAIL
ARE
THE
FOLLOWING
FIRST
THEY
PROVIDE
CONTEXT
IN
WHICH
WE
CAN
LEARN
TERMINOLOGY
AND
BASIC
MECHANISMS
SECOND
THESE
SIMPLE
ALGORITHMS
ARE
MORE
EFFECTIVE
IN
SOME
APPLICATIONS
THAN
THE
SOPHISTICATED
ALGORITHMS
THAT
WE
SHALL
DISCUSS
LATER
THIRD
THEY
ARE
USEFUL
IN
IMPROVING
THE
EFFICIENCY
OF
MORE
SOPHISTICATED
ALGORITHMS
AS
WE
WILL
SEE
RULES
OF
THE
GAME
OUR
PRIMARY
CONCERN
IS
ALGORITHMS
FOR
REARRANGING
ARRAYS
OF
ITEMS
WHERE
EACH
ITEM
CONTAINS
A
KEY
THE
OBJECTIVE
OF
THE
SORTING
ALGORITHM
IS
TO
REAR
RANGE
THE
ITEMS
SUCH
THAT
THEIR
KEYS
ARE
ORDERED
ACCORDING
TO
SOME
WELL
DEFINED
ORDER
ING
RULE
USUALLY
NUMERICAL
OR
ALPHABETICAL
ORDER
WE
WANT
TO
REARRANGE
THE
ARRAY
SO
THAT
EACH
ENTRY
KEY
IS
NO
SMALLER
THAN
THE
KEY
IN
EACH
ENTRY
WITH
A
LOWER
INDEX
AND
NO
LARGER
THAN
THE
KEY
IN
EACH
ENTRY
WITH
A
LARGER
INDEX
SPECIFIC
CHARACTERISTICS
OF
THE
KEYS
AND
THE
ITEMS
CAN
VARY
WIDELY
ACROSS
APPLICATIONS
IN
JAVA
ITEMS
ARE
JUST
OBJECTS
AND
THE
ABSTRACT
NOTION
OF
A
KEY
IS
CAPTURED
IN
A
BUILT
IN
MECHANISM
THE
COMPARABLE
INTERFACE
THAT
IS
DESCRIBED
ON
PAGE
THE
CLASS
EXAMPLE
ON
THE
FACING
PAGE
ILLUSTRATES
THE
CONVENTIONS
THAT
WE
SHALL
USE
WE
PUT
OUR
SORT
CODE
IN
A
SORT
METHOD
WITHIN
A
SINGLE
CLASS
ALONG
WITH
PRIVATE
HELPER
FUNCTIONS
LESS
AND
EXCH
AND
PERHAPS
SOME
OTHERS
AND
A
SAMPLE
CLIENT
MAIN
EXAMPLE
ALSO
ILLUSTRATES
CODE
THAT
MIGHT
BE
USEFUL
FOR
INITIAL
DEBUGGING
ITS
TEST
CLIENT
MAIN
SORTS
STRINGS
FROM
STANDARD
INPUT
USING
THE
PRIVATE
METHOD
SHOW
TO
PRINT
THE
CONTENTS
OF
THE
ARRAY
LATER
IN
THIS
CHAPTER
WE
WILL
EXAMINE
VARIOUS
TEST
CLIENTS
FOR
COM
PARING
ALGORITHMS
AND
FOR
STUDYING
THEIR
PERFORMANCE
TO
DIFFERENTIATE
SORTING
METH
ODS
WE
GIVE
OUR
VARIOUS
SORT
CLASSES
DIFFERENT
NAMES
CLIENTS
CAN
CALL
DIFFERENT
IMPLE
MENTATIONS
BY
NAME
INSERTION
SORT
MERGE
SORT
QUICK
SORT
AND
SO
FORTH
WITH
BUT
A
FEW
EXCEPTIONS
OUR
SORT
CODE
REFERS
TO
THE
DATA
ONLY
THROUGH
TWO
OPERA
TIONS
THE
METHOD
LESS
THAT
COMPARES
ITEMS
AND
THE
METHOD
EXCH
THAT
EXCHANGES
THEM
THE
EXCH
METHOD
IS
EASY
TO
IMPLEMENT
AND
THE
COMPARABLE
INTERFACE
MAKES
IT
EASY
TO
IMPLEMENT
LESS
RESTRICTING
DATA
ACCESS
TO
THESE
TWO
OPERATIONS
MAKES
OUR
CODE
READABLE
AND
PORTABLE
AND
MAKES
IT
EASIER
FOR
US
CERTIFY
THAT
ALGORITHMS
ARE
COR
RECT
TO
STUDY
PERFORMANCE
AND
TO
COMPARE
ALGORITHMS
BEFORE
PROCEEDING
TO
CONSIDER
SORT
IMPLEMENTATIONS
WE
DISCUSS
A
NUMBER
OF
IMPORTANT
ISSUES
THAT
NEED
TO
BE
CARE
FULLY
CONSIDERED
FOR
EVERY
SORT
TEMPLATE
FOR
SORT
CLASSES
PUBLIC
CLASS
EXAMPLE
PUBLIC
STATIC
VOID
SORT
COMPARABLE
A
SEE
ALGORITHMS
OR
PRIVATE
STATIC
BOOLEAN
LESS
COMPARABLE
V
COMPARABLE
W
RETURN
V
COMPARETO
W
PRIVATE
STATIC
VOID
EXCH
COMPARABLE
A
INT
I
INT
J
COMPARABLE
T
A
I
A
I
A
J
A
J
T
PRIVATE
STATIC
VOID
SHOW
COMPARABLE
A
PRINT
THE
ARRAY
ON
A
SINGLE
LINE
FOR
INT
I
I
A
LENGTH
I
STDOUT
PRINT
A
I
STDOUT
PRINTLN
PUBLIC
STATIC
BOOLEAN
ISSORTED
COMPARABLE
A
TEST
WHETHER
THE
ARRAY
ENTRIES
ARE
IN
ORDER
FOR
INT
I
I
A
LENGTH
I
IF
LESS
A
I
A
I
RETURN
FALSE
RETURN
TRUE
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
READ
STRINGS
FROM
STANDARD
INPUT
SORT
THEM
AND
PRINT
STRING
A
IN
READSTRINGS
SORT
A
ASSERT
ISSORTED
A
SHOW
A
THIS
CLASS
ILLUSTRATES
OUR
CONVENTIONS
FOR
IMPLE
MENTING
ARRAY
SORTS
FOR
EACH
SORTING
ALGORITHM
THAT
WE
CONSIDER
WE
PRESENT
A
SORT
METHOD
FOR
A
CLASS
LIKE
THIS
WITH
EXAMPLE
CHANGED
TO
A
NAME
THAT
CORRESPONDS
TO
THE
ALGORITHM
THE
TEST
CLIENT
SORTS
STRINGS
TAKEN
FROM
STANDARD
INPUT
BUT
WITH
THIS
CODE
OUR
SORT
METHODS
ARE
EFFECTIVE
FOR
ANY
TYPE
OF
DATA
THAT
IMPLEMENTS
COMPARABLE
CERTIFICATION
DOES
THE
SORT
IMPLEMENTATION
ALWAYS
PUT
THE
ARRAY
IN
ORDER
NO
MAT
TER
WHAT
THE
INITIAL
ORDER
AS
A
CONSERVATIVE
PRACTICE
WE
INCLUDE
THE
STATEMENT
ASSERT
ISSORTED
A
IN
OUR
TEST
CLIENT
TO
CERTIFY
THAT
ARRAY
ENTRIES
ARE
IN
ORDER
AFTER
THE
SORT
IT
IS
REASONABLE
TO
INCLUDE
THIS
STATEMENT
IN
EVERY
SORT
IMPLEMENTATION
EVEN
THOUGH
WE
NORMALLY
TEST
OUR
CODE
AND
DEVELOP
MATHEMATICAL
ARGUMENTS
THAT
OUR
AL
GORITHMS
ARE
CORRECT
NOTE
THAT
THIS
TEST
IS
SUFFICIENT
ONLY
IF
WE
USE
EXCH
EXCLUSIVELY
TO
CHANGE
ARRAY
ENTRIES
WHEN
WE
USE
CODE
THAT
STORES
VALUES
INTO
THE
ARRAY
DIRECTLY
WE
DO
NOT
HAVE
FULL
ASSURANCE
FOR
EXAMPLE
CODE
THAT
DESTROYS
THE
ORIGINAL
INPUT
ARRAY
BY
SETTING
ALL
VALUES
TO
BE
THE
SAME
WOULD
PASS
THIS
TEST
RUNNING
TIME
WE
ALSO
TEST
ALGORITHM
PERFORMANCE
WE
START
BY
PROVING
FACTS
ABOUT
THE
NUMBER
OF
BASIC
OPERATIONS
COMPARES
AND
EXCHANGES
OR
PERHAPS
THE
NUMBER
OF
TIMES
THE
ARRAY
IS
AC
CESSED
FOR
READ
OR
WRITE
THAT
THE
VARIOUS
SORTING
ALGORITHMS
PER
FORM
FOR
VARIOUS
NATURAL
INPUT
MODELS
THEN
WE
USE
THESE
FACTS
TO
DEVELOP
HYPOTHESES
ABOUT
THE
COMPARATIVE
PERFORMANCE
OF
THE
ALGORITHMS
AND
PRESENT
TOOLS
THAT
YOU
CAN
USE
TO
EXPERIMENTALLY
CHECK
THE
VALIDITY
OF
SUCH
HYPOTHESES
WE
USE
A
CONSISTENT
CODING
STYLE
TO
FACILITATE
THE
DEVELOPMENT
OF
VALID
HYPOTHESES
ABOUT
PER
FORMANCE
THAT
WILL
HOLD
TRUE
FOR
TYPICAL
IMPLEMENTATIONS
EXTRA
MEMORY
THE
AMOUNT
OF
EXTRA
MEMORY
USED
BY
A
SORTING
ALGORITHM
IS
OFTEN
AS
IMPORTANT
A
FACTOR
AS
RUNNING
TIME
THE
SORTING
ALGORITHMS
DIVIDE
INTO
TWO
BASIC
TYPES
THOSE
THAT
SORT
IN
PLACE
AND
USE
NO
EXTRA
MEMORY
EXCEPT
PERHAPS
FOR
A
SMALL
FUNCTION
CALL
STACK
OR
A
CONSTANT
NUMBER
OF
INSTANCE
VARIABLES
AND
THOSE
THAT
NEED
ENOUGH
EXTRA
MEMORY
TO
HOLD
ANOTHER
COPY
OF
THE
ARRAY
TO
BE
SORTED
TYPES
OF
DATA
OUR
SORT
CODE
IS
EFFECTIVE
FOR
ANY
ITEM
TYPE
THAT
IMPLEMENTS
THE
COMPARABLE
INTERFACE
ADHERING
TO
JAVA
CONVENTION
IN
THIS
WAY
IS
CONVENIENT
BE
CAUSE
MANY
OF
THE
TYPES
OF
DATA
THAT
YOU
MIGHT
WANT
TO
SORT
IMPLEMENT
COMPARABLE
FOR
EXAMPLE
JAVA
NUMERIC
WRAPPER
TYPES
SUCH
AS
INTEGER
AND
DOUBLE
IMPLEMENT
COMPARABLE
AS
DO
STRING
AND
VARIOUS
ADVANCED
TYPES
SUCH
AS
FILE
OR
URL
THUS
YOU
CAN
JUST
CALL
ONE
OF
OUR
SORT
METHODS
WITH
AN
ARRAY
OF
ANY
OF
THESE
TYPES
AS
ARGU
MENT
FOR
EXAMPLE
THE
CODE
AT
RIGHT
USES
QUICKSORT
SEE
SECTION
TO
SORT
N
RANDOM
DOUBLE
VALUES
WHEN
WE
CREATE
TYPES
OF
OUR
OWN
WE
CAN
ENABLE
CLIENT
CODE
TO
SORT
THAT
TYPE
OF
DATA
BY
IMPLEMENTING
THE
COMPARABLE
IN
TERFACE
TO
DO
SO
WE
JUST
NEED
TO
IMPLEMENT
A
COMPARETO
METHOD
THAT
DEFINES
AN
ORDERING
ON
OBJECTS
OF
THAT
TYPE
KNOWN
AS
THE
NATURAL
ORDER
FOR
THAT
TYPE
AS
SHOWN
HERE
FOR
OUR
DATE
DATA
TYPE
SEE
PAGE
JAVA
CONVENTION
IS
THAT
THE
CALL
V
COMPARETO
W
RETURNS
AN
INTEGER
THAT
IS
NEGATIVE
ZERO
OR
POSITIVE
USUALLY
OR
WHEN
V
W
V
W
OR
V
W
RESPECTIVELY
FOR
ECONOMY
WE
USE
STANDARD
NOTATION
LIKE
V
W
AS
SHORT
HAND
FOR
CODE
LIKE
V
COMPARETO
W
FOR
THE
REMAINDER
OF
THIS
PARAGRAPH
BY
CONVENTION
V
COMPARETO
W
THROWS
AN
EXCEPTION
IF
V
AND
W
ARE
INCOMPATIBLE
TYPES
OR
EITHER
IS
NULL
FURTHERMORE
COMPARETO
MUST
IMPLEMENT
A
TOTAL
ORDER
IT
MUST
BE
REFLEXIVE
FOR
ALL
V
V
V
ANTISYMMETRIC
FOR
ALL
V
AND
W
IF
V
W
THEN
W
V
AND
IF
V
W
THEN
W
V
TRANSITIVE
FOR
ALL
V
W
AND
X
IF
V
W
AND
W
X
THEN
V
X
THESE
RULES
ARE
INTUITIVE
AND
STANDARD
IN
MATHEMATICS
YOU
WILL
HAVE
LITTLE
DIFFICULTY
ADHERING
TO
THEM
IN
SHORT
COMPARETO
IMPLEMENTS
OUR
KEY
AB
STRACTION
IT
DEFINES
THE
ORDERING
OF
THE
ITEMS
OBJECTS
TO
BE
SORTED
WHICH
CAN
BE
ANY
TYPE
OF
DATA
THAT
IMPLEMENTS
COMPARABLE
NOTE
THAT
COMPARETO
NEED
NOT
USE
ALL
OF
THE
INSTANCE
VARIABLES
INDEED
THE
KEY
MIGHT
BE
A
SMALL
PART
OF
EACH
ITEM
FOR
THE
REMAINDER
OF
THIS
CHAPTER
WE
SHALL
ADDRESS
NUMEROUS
ALGORITHMS
FOR
SORT
ING
ARRAYS
OF
OBJECTS
HAVING
A
NATURAL
ORDER
TO
COMPARE
AND
CONTRAST
THE
ALGORITHMS
WE
SHALL
EXAMINE
A
NUMBER
OF
THEIR
PROPERTIES
INCLUDING
THE
NUMBER
OF
COMPARES
AND
EXCHANGES
THAT
THEY
USE
FOR
VARIOUS
TYPES
OF
INPUTS
AND
THE
AMOUNT
OF
EXTRA
MEMORY
THAT
THEY
USE
THESE
PROPERTIES
LEAD
TO
THE
DEVELOPMENT
OF
HYPOTHESES
ABOUT
PERFOR
MANCE
PROPERTIES
MANY
OF
WHICH
HAVE
BEEN
VALIDATED
ON
COUNTLESS
COMPUTERS
OVER
THE
PAST
SEVERAL
DECADES
SPECIFIC
IMPLEMENTATIONS
ALWAYS
NEED
TO
BE
CHECKED
SO
WE
ALSO
CONSIDER
TOOLS
FOR
DOING
SO
AFTER
CONSIDERING
THE
CLASSIC
SELECTION
SORT
INSERTION
SORT
SHELLSORT
MERGESORT
QUICKSORT
AND
HEAPSORT
ALGORITHMS
WE
WILL
CONSIDER
PRACTICAL
IS
SUES
AND
APPLICATIONS
IN
SECTION
SELECTION
SORT
ONE
OF
THE
SIMPLEST
SORTING
ALGORITHMS
WORKS
AS
FOLLOWS
FIRST
FIND
THE
SMALLEST
ITEM
IN
THE
ARRAY
AND
EXCHANGE
IT
WITH
THE
FIRST
ENTRY
ITSELF
IF
THE
FIRST
ENTRY
IS
ALREADY
THE
SMALLEST
THEN
FIND
THE
NEXT
SMALLEST
ITEM
AND
EXCHANGE
IT
WITH
THE
SEC
OND
ENTRY
CONTINUE
IN
THIS
WAY
UNTIL
THE
ENTIRE
ARRAY
IS
SORTED
THIS
METHOD
IS
CALLED
SELECTION
SORT
BECAUSE
IT
WORKS
BY
REPEATEDLY
SELECTING
THE
SMALLEST
REMAINING
ITEM
AS
YOU
CAN
SEE
FROM
THE
IMPLEMENTATION
IN
ALGORITHM
THE
INNER
LOOP
OF
SELEC
TION
SORT
IS
JUST
A
COMPARE
TO
TEST
A
CURRENT
ITEM
AGAINST
THE
SMALLEST
ITEM
FOUND
SO
FAR
PLUS
THE
CODE
NECESSARY
TO
INCREMENT
THE
CURRENT
INDEX
AND
TO
CHECK
THAT
IT
DOES
NOT
EXCEED
THE
ARRAY
BOUNDS
IT
COULD
HARDLY
BE
SIMPLER
THE
WORK
OF
MOVING
THE
ITEMS
AROUND
FALLS
OUTSIDE
THE
INNER
LOOP
EACH
EXCHANGE
PUTS
AN
ITEM
INTO
ITS
FINAL
POSITION
SO
THE
NUMBER
OF
EXCHANGES
IS
N
THUS
THE
RUNNING
TIME
IS
DOMINATED
BY
THE
NUMBER
OF
COMPARES
IN
SUMMARY
SELECTION
SORT
IS
A
SIMPLE
SORTING
METHOD
THAT
IS
EASY
TO
UNDERSTAND
AND
TO
IMPLEMENT
AND
IS
CHARACTERIZED
BY
THE
FOLLOWING
TWO
SIGNATURE
PROPERTIES
RUNNING
TIME
IS
INSENSITIVE
TO
INPUT
THE
PROCESS
OF
FINDING
THE
SMALLEST
ITEM
ON
ONE
PASS
THROUGH
THE
ARRAY
DOES
NOT
GIVE
MUCH
INFORMATION
ABOUT
WHERE
THE
SMALLEST
ITEM
MIGHT
BE
ON
THE
NEXT
PASS
THIS
PROPERTY
CAN
BE
DISADVANTAGEOUS
IN
SOME
SITUATIONS
FOR
EXAMPLE
THE
PERSON
USING
THE
SORT
CLIENT
MIGHT
BE
SURPRISED
TO
REALIZE
THAT
IT
TAKES
ABOUT
AS
LONG
TO
RUN
SELECTION
SORT
FOR
AN
ARRAY
THAT
IS
ALREADY
IN
ORDER
OR
FOR
AN
ARRAY
WITH
ALL
KEYS
EQUAL
AS
IT
DOES
FOR
A
RANDOMLY
ORDERED
ARRAY
AS
WE
SHALL
SEE
OTHER
ALGO
RITHMS
ARE
BETTER
ABLE
TO
TAKE
ADVANTAGE
OF
INITIAL
ORDER
IN
THE
INPUT
DATA
MOVEMENT
IS
MINIMAL
EACH
OF
THE
N
EXCHANGES
CHANGES
THE
VALUE
OF
TWO
ARRAY
ENTRIES
SO
SELECTION
SORT
USES
N
EXCHANGES
THE
NUMBER
OF
ARRAY
ACCESSES
IS
A
LINEAR
FUNCTION
OF
THE
ARRAY
SIZE
NONE
OF
THE
OTHER
SORTING
ALGORITHMS
THAT
WE
CONSIDER
HAVE
THIS
PROPERTY
MOST
INVOLVE
LINEARITHMIC
OR
QUADRATIC
GROWTH
ALGORITHM
SELECTION
SORT
PUBLIC
CLASS
SELECTION
PUBLIC
STATIC
VOID
SORT
COMPARABLE
A
SORT
A
INTO
INCREASING
ORDER
INT
N
A
LENGTH
ARRAY
LENGTH
FOR
INT
I
I
N
I
EXCHANGE
A
I
WITH
SMALLEST
ENTRY
IN
A
I
N
INT
MIN
I
INDEX
OF
MINIMAL
ENTR
FOR
INT
J
I
J
N
J
IF
LESS
A
J
A
MIN
MIN
J
EXCH
A
I
MIN
SEE
PAGE
FOR
LESS
EXCH
ISSORTED
AND
MAIN
FOR
EACH
I
THIS
IMPLEMENTATION
PUTS
THE
ITH
SMALLEST
ITEM
IN
A
I
THE
ENTRIES
TO
THE
LEFT
OF
POSITION
I
ARE
THE
I
SMALLEST
ITEMS
IN
THE
ARRAY
AND
ARE
NOT
EXAMINED
AGAIN
A
I
MIN
ENTRIES
IN
BLACK
ARE
EXAMINED
TO
FIND
O
R
T
E
X
A
M
P
L
E
O
R
T
E
X
A
M
P
L
E
A
O
R
T
E
X
M
P
L
E
A
E
R
T
O
X
M
P
L
E
A
E
E
T
O
X
M
P
L
R
A
E
E
L
O
X
M
P
T
R
A
E
E
L
M
X
O
P
T
R
A
E
E
L
M
O
X
P
T
R
A
E
E
L
M
O
P
X
T
R
A
E
E
L
M
O
P
R
T
X
A
E
E
L
M
O
P
R
T
X
A
E
E
L
M
O
P
R
T
X
A
E
E
L
M
O
P
R
T
X
THE
MINIMUM
ENTRIES
IN
RED
ARE
A
MIN
ENTRIES
IN
GRAY
ARE
IN
FINAL
POSITION
TRACE
OF
SELECTION
SORT
ARRAY
CONTENTS
JUST
AFTER
EACH
EXCHANGE
INSERTION
SORT
THE
ALGORITHM
THAT
PEOPLE
OFTEN
USE
TO
SORT
BRIDGE
HANDS
IS
TO
CON
SIDER
THE
CARDS
ONE
AT
A
TIME
INSERTING
EACH
INTO
ITS
PROPER
PLACE
AMONG
THOSE
ALREADY
CONSIDERED
KEEPING
THEM
SORTED
IN
A
COMPUTER
IMPLEMENTATION
WE
NEED
TO
MAKE
SPACE
TO
INSERT
THE
CURRENT
ITEM
BY
MOVING
LARGER
ITEMS
ONE
POSITION
TO
THE
RIGHT
BEFORE
INSERTING
THE
CURRENT
ITEM
INTO
THE
VACATED
POSITION
ALGORITHM
IS
AN
IMPLEMENTA
TION
OF
THIS
METHOD
WHICH
IS
CALLED
INSERTION
SORT
AS
IN
SELECTION
SORT
THE
ITEMS
TO
THE
LEFT
OF
THE
CURRENT
INDEX
ARE
IN
SORTED
ORDER
DUR
ING
THE
SORT
BUT
THEY
ARE
NOT
IN
THEIR
FINAL
POSITION
AS
THEY
MAY
HAVE
TO
BE
MOVED
TO
MAKE
ROOM
FOR
SMALLER
ITEMS
ENCOUNTERED
LATER
THE
ARRAY
IS
HOWEVER
FULLY
SORTED
WHEN
THE
INDEX
REACHES
THE
RIGHT
END
UNLIKE
THAT
OF
SELECTION
SORT
THE
RUNNING
TIME
OF
INSERTION
SORT
DEPENDS
ON
THE
INI
TIAL
ORDER
OF
THE
ITEMS
IN
THE
INPUT
FOR
EXAMPLE
IF
THE
ARRAY
IS
LARGE
AND
ITS
ENTRIES
ARE
ALREADY
IN
ORDER
OR
NEARLY
IN
ORDER
THEN
INSERTION
SORT
IS
MUCH
MUCH
FASTER
THAN
IF
THE
ENTRIES
ARE
RANDOMLY
ORDERED
OR
IN
REVERSE
ORDER
INSERTION
SORT
WORKS
WELL
FOR
CERTAIN
TYPES
OF
NONRANDOM
ARRAYS
THAT
OFTEN
ARISE
IN
PRACTICE
EVEN
IF
THEY
ARE
HUGE
FOR
EXAMPLE
AS
JUST
MENTIONED
CONSIDER
WHAT
HAPPENS
WHEN
YOU
USE
INSERTION
SORT
ON
AN
ARRAY
THAT
IS
ALREADY
SORTED
EACH
ITEM
IS
IMMEDIATELY
DETERMINED
TO
BE
IN
ITS
PROPER
PLACE
IN
THE
ARRAY
AND
THE
TOTAL
RUNNING
TIME
IS
LINEAR
THE
RUNNING
TIME
OF
SELECTION
SORT
IS
QUADRATIC
FOR
SUCH
AN
ARRAY
THE
SAME
IS
TRUE
FOR
ARRAYS
WHOSE
KEYS
ARE
ALL
EQUAL
HENCE
THE
CONDITION
IN
PROPOSITION
B
THAT
THE
KEYS
MUST
BE
DISTINCT
ALGORITHM
INSERTION
SORT
PUBLIC
CLASS
INSERTION
PUBLIC
STATIC
VOID
SORT
COMPARABLE
A
SORT
A
INTO
INCREASING
ORDER
INT
N
A
LENGTH
FOR
INT
I
I
N
I
INSERT
A
I
AMONG
A
I
A
I
A
I
FOR
INT
J
I
J
LESS
A
J
A
J
J
EXCH
A
J
J
SEE
PAGE
FOR
LESS
EXCH
ISSORTED
AND
MAIN
FOR
EACH
I
FROM
TO
N
EXCHANGE
A
I
WITH
THE
ENTRIES
THAT
ARE
SMALLER
IN
A
THROUGH
A
I
AS
THE
INDEX
I
TRAVELS
FROM
LEFT
TO
RIGHT
THE
ENTRIES
TO
ITS
LEFT
ARE
IN
SORTED
ORDER
IN
THE
ARRAY
SO
THE
ARRAY
IS
FULLY
SORTED
WHEN
I
REACHES
THE
RIGHT
END
TRACE
OF
INSERTION
SORT
ARRAY
CONTENTS
JUST
AFTER
EACH
INSERTION
ENTRIES
IN
GRAY
DO
NOT
MOVE
ENTRY
IN
RED
IS
A
J
ENTRIES
IN
BLACK
MOVED
ONE
POSITION
RIGHT
FOR
INSERTION
MORE
GENERALLY
WE
CONSIDER
THE
CONCEPT
OF
A
PARTIALLY
SORTED
ARRAY
AS
FOLLOWS
AN
IN
VERSION
IS
A
PAIR
OF
ENTRIES
THAT
ARE
OUT
OF
ORDER
IN
THE
ARRAY
FOR
INSTANCE
E
X
A
M
P
L
E
HAS
INVERSIONS
E
A
X
A
X
M
X
P
X
L
X
E
M
L
M
E
P
L
P
E
AND
L
E
IF
THE
NUMBER
OF
INVERSIONS
IN
AN
ARRAY
IS
LESS
THAN
A
CONSTANT
MULTIPLE
OF
THE
ARRAY
SIZE
WE
SAY
THAT
THE
ARRAY
IS
PARTIALLY
SORTED
TYPICAL
EXAMPLES
OF
PARTIALLY
SORTED
ARRAYS
ARE
THE
FOLLOWING
AN
ARRAY
WHERE
EACH
ENTRY
IS
NOT
FAR
FROM
ITS
FINAL
POSITION
A
SMALL
ARRAY
APPENDED
TO
A
LARGE
SORTED
ARRAY
AN
ARRAY
WITH
ONLY
A
FEW
ENTRIES
THAT
ARE
NOT
IN
PLACE
INSERTION
SORT
IS
AN
EFFICIENT
METHOD
FOR
SUCH
ARRAYS
SELECTION
SORT
IS
NOT
INDEED
WHEN
THE
NUMBER
OF
INVERSIONS
IS
LOW
INSERTION
SORT
IS
LIKELY
TO
BE
FASTER
THAN
ANY
SORTING
METHOD
THAT
WE
CONSIDER
IN
THIS
CHAPTER
IT
IS
NOT
DIFFICULT
TO
SPEED
UP
INSERTION
SORT
SUBSTANTIALLY
BY
SHORTENING
ITS
INNER
LOOP
TO
MOVE
THE
LARGER
ENTRIES
TO
THE
RIGHT
ONE
POSITION
RATHER
THAN
DOING
FULL
EXCHANGES
THUS
CUTTING
THE
NUMBER
OF
ARRAY
ACCESSES
IN
HALF
WE
LEAVE
THIS
IMPROVEMENT
FOR
AN
EXERCISE
SEE
EXERCISE
IN
SUMMARY
INSERTION
SORT
IS
AN
EXCELLENT
METHOD
FOR
PARTIALLY
SORTED
ARRAYS
AND
IS
ALSO
A
FINE
METHOD
FOR
TINY
ARRAYS
THESE
FACTS
ARE
IMPORTANT
NOT
JUST
BECAUSE
SUCH
ARRAYS
FREQUENTLY
ARISE
IN
PRACTICE
BUT
ALSO
BECAUSE
BOTH
TYPES
OF
ARRAYS
ARISE
IN
INTERMEDIATE
STAGES
OF
ADVANCED
SORTING
ALGORITHMS
SO
WE
WILL
BE
CONSIDERING
INSERTION
SORT
AGAIN
IN
RELATION
TO
SUCH
ALGORITHMS
VISUALIZING
SORTING
ALGORITHMS
THROUGHOUT
THIS
CHAPTER
WE
WILL
BE
USING
A
SIMPLE
VISUAL
REPRESENTATION
TO
HELP
DESCRIBE
THE
PROPERTIES
OF
SORTING
ALGORITHMS
RATHER
THAN
TRACING
THE
PROGRESS
OF
A
SORT
WITH
KEY
VALUES
SUCH
AS
LETTERS
NUMBERS
OR
WORDS
WE
USE
VERTICAL
BARS
TO
BE
SORTED
BY
THEIR
HEIGHTS
THE
ADVANTAGE
OF
SUCH
A
REPRESENTATION
IS
THAT
IT
CAN
GIVE
INSIGHTS
INTO
THE
BEHAVIOR
OF
A
SORT
ING
METHOD
FOR
EXAMPLE
YOU
CAN
SEE
AT
A
GLANCE
ON
THE
VISUAL
TRACES
AT
RIGHT
THAT
INSERTION
SORT
DOES
NOT
TOUCH
ENTRIES
TO
THE
RIGHT
OF
THE
SCAN
POINTER
AND
SELEC
TION
SORT
DOES
NOT
TOUCH
ENTRIES
TO
THE
LEFT
OF
THE
SCAN
POINTER
MOREOVER
IT
IS
CLEAR
FROM
THE
VISUAL
TRACES
THAT
SINCE
INSERTION
SORT
ALSO
DOES
NOT
TOUCH
ENTRIES
SMALLER
THAN
THE
INSERTED
ITEM
IT
USES
ABOUT
HALF
THE
NUMBER
OF
COMPARES
AS
SELECTION
SORT
ON
THE
AVERAGE
WITH
OUR
STDDRAW
LIBRARY
DEVELOPING
A
VISUAL
TRACE
IS
NOT
MUCH
MORE
DIFFICULT
THAN
DOING
A
STAN
DARD
TRACE
WE
SORT
DOUBLE
VALUES
INSTRUMENT
THE
ALGORITHM
TO
CALL
SHOW
AS
APPROPRIATE
JUST
AS
WE
DO
FOR
A
STANDARD
TRACE
AND
DEVELOP
A
VERSION
OF
SHOW
THAT
USES
STDDRAW
TO
DRAW
THE
BARS
INSTEAD
OF
PRINTING
THE
RESULTS
THE
MOST
COMPLICATED
TASK
IS
SETTING
THE
SCALE
FOR
THE
Y
AXIS
SO
THAT
THE
LINES
OF
THE
TRACE
APPEAR
IN
THE
EXPECTED
ORDER
YOU
ARE
EN
COURAGED
TO
WORK
EXERCISE
IN
ORDER
TO
GAIN
A
BETTER
APPRECIATION
OF
THE
VALUE
OF
VISUAL
TRACES
AND
GRAY
ENTRIES
ARE
UNTOUCHED
BLACK
ENTRIES
ARE
INVOLVED
IN
COMPARES
THE
EASE
OF
CREATING
THEM
AN
EVEN
SIMPLER
TASK
IS
TO
ANIMATE
THE
TRACE
SO
THAT
YOU
CAN
SEE
THE
ARRAY
DYNAMICALLY
EVOLVE
TO
THE
SORTED
RESULT
DEVELOPING
AN
ANIMATED
TRACE
IN
INSERTION
SORT
SELECTION
SORT
VISUAL
TRACES
OF
ELEMENTARY
SORTING
ALGORITHMS
VOLVES
ESSENTIALLY
THE
SAME
PROCESS
DESCRIBED
IN
THE
PREVIOUS
PARAGRAPH
BUT
WITHOUT
HAVING
TO
WORRY
ABOUT
THE
Y
AXIS
JUST
CLEAR
THE
WINDOW
AND
REDRAW
THE
BARS
EACH
TIME
THOUGH
WE
CANNOT
MAKE
THE
CASE
ON
THE
PRINTED
PAGE
SUCH
ANIMATED
REPRESENTATIONS
ARE
ALSO
EFFECTIVE
IN
GAINING
INSIGHT
INTO
HOW
AN
ALGORITHM
WORKS
YOU
ARE
ALSO
ENCOUR
AGED
TO
WORK
EXERCISE
TO
SEE
FOR
YOURSELF
COMPARING
TWO
SORTING
ALGORITHMS
NOW
THAT
WE
HAVE
TWO
IMPLEMENTATIONS
WE
ARE
NATURALLY
INTERESTED
IN
KNOWING
WHICH
ONE
IS
FASTER
SELECTION
SORT
ALGORITHM
OR
INSERTION
SORT
ALGORITHM
QUESTIONS
LIKE
THIS
ARISE
AGAIN
AND
AGAIN
AND
AGAIN
IN
THE
STUDY
OF
ALGORITHMS
AND
ARE
A
MAJOR
FOCUS
THROUGHOUT
THIS
BOOK
WE
HAVE
DISCUSSED
SOME
FUNDAMENTAL
IDEAS
IN
CHAPTER
BUT
WE
USE
THIS
FIRST
CASE
IN
POINT
TO
ILLUSTRATE
OUR
BASIC
APPROACH
TO
ANSWERING
SUCH
QUESTIONS
GENERALLY
FOLLOWING
THE
AP
PROACH
INTRODUCED
IN
SECTION
WE
COMPARE
ALGORITHMS
BY
IMPLEMENTING
AND
DEBUGGING
THEM
ANALYZING
THEIR
BASIC
PROPERTIES
FORMULATING
A
HYPOTHESIS
ABOUT
COMPARATIVE
PERFORMANCE
RUNNING
EXPERIMENTS
TO
VALIDATE
THE
HYPOTHESIS
THESE
STEPS
ARE
NOTHING
MORE
THAN
THE
TIME
HONORED
SCIENTIFIC
METHOD
APPLIED
TO
THE
STUDY
OF
ALGORITHMS
IN
THE
PRESENT
CONTEXT
ALGORITHM
AND
ALGORITHM
ARE
EVIDENCE
OF
THE
FIRST
STEP
PROPOSITIONS
A
B
AND
C
CONSTITUTE
THE
SECOND
STEP
PROPERTY
D
ON
PAGE
CONSTITUTES
THE
THIRD
STEP
AND
THE
CLASS
SORTCOMPARE
ON
PAGE
ENABLES
THE
FOURTH
STEP
THESE
ACTIVITIES
ARE
ALL
INTERRELATED
OUR
BRIEF
DESCRIPTIONS
MASK
A
SUBSTANTIAL
AMOUNT
OF
EFFORT
THAT
IS
REQUIRED
TO
PROP
ERLY
IMPLEMENT
ANALYZE
AND
TEST
ALGORITHMS
EVERY
PROGRAMMER
KNOWS
THAT
SUCH
CODE
IS
THE
PRODUCT
OF
A
LONG
ROUND
OF
DEBUGGING
AND
REFINEMENT
EVERY
MATHEMATICIAN
KNOWS
THAT
PROPER
ANALYSIS
CAN
BE
VERY
DIFFICULT
AND
EVERY
SCIENTIST
KNOWS
THAT
FORMU
LATING
HYPOTHESES
AND
DESIGNING
AND
EXECUTING
EXPERIMENTS
TO
VALIDATE
THEM
REQUIRE
GREAT
CARE
FULL
DEVELOPMENT
OF
SUCH
RESULTS
IS
RESERVED
FOR
EXPERTS
STUDYING
OUR
MOST
IMPORTANT
ALGORITHMS
BUT
EVERY
PROGRAMMER
USING
AN
ALGORITHM
SHOULD
BE
AWARE
OF
THE
SCIENTIFIC
CONTEXT
UNDERLYING
ITS
PERFORMANCE
PROPERTIES
HAVING
DEVELOPED
IMPLEMENTATIONS
OUR
NEXT
CHOICE
IS
TO
SETTLE
ON
AN
APPROPRIATE
MODEL
FOR
THE
INPUT
FOR
SORTING
A
NATURAL
MODEL
WHICH
WE
HAVE
USED
FOR
PROPOSI
TIONS
A
B
AND
C
IS
TO
ASSUME
THAT
THE
ARRAYS
ARE
RANDOMLY
ORDERED
AND
THAT
THE
KEY
VALUES
ARE
DISTINCT
IN
APPLICATIONS
WHERE
SIGNIFICANT
NUMBERS
OF
EQUAL
KEY
VALUES
ARE
PRESENT
WE
WILL
NEED
A
MORE
COMPLICATED
MODEL
HOW
DO
WE
FORMULATE
A
HYPOTHESIS
ABOUT
THE
RUNNING
TIMES
OF
INSERTION
SORT
AND
SELECTION
SORT
FOR
RANDOMLY
ORDERED
ARRAYS
EXAMINING
ALGORITHMS
AND
AND
PROPOSITIONS
A
AND
B
IT
FOLLOWS
IMMEDIATELY
THAT
THE
RUNNING
TIME
OF
BOTH
ALGORITHMS
SHOULD
BE
QUADRATIC
FOR
RANDOMLY
ORDERED
ARRAYS
THAT
IS
THE
RUNNING
TIME
OF
INSERTION
SORT
FOR
SUCH
AN
INPUT
IS
PROPORTIONAL
TO
SOME
SMALL
CONSTANT
TIMES
N
AND
THE
RUNNING
TIME
OF
SELECTION
SORT
IS
PROPORTIONAL
TO
SOME
OTHER
SMALL
CONSTANT
TIMES
N
THE
VALUES
OF
THE
TWO
CONSTANTS
DEPEND
ON
THE
COST
OF
COMPARES
AND
EXCHANGES
ON
THE
PARTICULAR
COMPUTER
BEING
USED
FOR
MANY
TYPES
OF
DATA
AND
FOR
TYPICAL
COMPUTERS
IT
IS
REASONABLE
TO
ASSUME
THAT
THESE
COSTS
ARE
SIMILAR
THOUGH
WE
WILL
SEE
A
FEW
SIGNIFICANT
EXCEPTIONS
THE
FOLLOWING
HYPOTHESIS
FOLLOWS
DIRECTLY
TO
VALIDATE
THIS
HYPOTHESIS
WE
USE
SORTCOMPARE
SEE
PAGE
TO
PERFORM
THE
EXPERI
MENTS
AS
USUAL
WE
USE
STOPWATCH
TO
COMPUTE
THE
RUNNING
TIME
THE
IMPLEMENTATION
OF
TIME
SHOWN
HERE
DOES
THE
JOB
FOR
THE
BASIC
SORTS
IN
THIS
CHAPTER
THE
RANDOMLY
OR
DERED
INPUT
MODEL
IS
EMBEDDED
IN
THE
TIMERANDOMINPUT
METHOD
IN
SORTCOMPARE
WHICH
GENERATES
RANDOM
DOUBLE
VALUES
SORTS
THEM
AND
RETURNS
THE
TOTAL
MEASURED
TIME
OF
THE
SORT
FOR
THE
GIVEN
NUMBER
OF
TRIALS
USING
RAN
DOM
DOUBLE
VALUES
BETWEEN
AND
IS
MUCH
SIMPLER
THAN
THE
ALTERNATIVE
OF
US
ING
A
LIBRARY
FUNCTION
SUCH
AS
STDRANDOM
SHUFFLE
AND
IS
EFFECTIVE
BECAUSE
EQUAL
KEY
VALUES
ARE
VERY
UNLIKELY
SEE
EXERCISE
AS
DISCUSSED
IN
CHAPTER
THE
NUMBER
OF
TRIALS
IS
TAKEN
AS
AN
ARGUMENT
BOTH
TO
TAKE
ADVAN
TAGE
OF
THE
LAW
OF
LARGE
NUMBERS
THE
MORE
TRIALS
THE
TOTAL
RUNNING
TIME
DIVIDED
BY
THE
NUMBER
OF
TRIALS
IS
A
MORE
ACCURATE
ESTIMATE
OF
THE
TRUE
AVERAGE
RUNNING
TIME
AND
TO
HELP
DAMP
OUT
SYSTEM
EFFECTS
YOU
ARE
ENCOURAGED
TO
EXPERIMENT
WITH
SORTCOMPARE
COMPARING
TWO
SORTING
ALGORITHMS
PUBLIC
CLASS
SORTCOMPARE
PUBLIC
STATIC
DOUBLE
TIME
STRING
ALG
DOUBLE
A
SEE
TEXT
PUBLIC
STATIC
DOUBLE
TIMERANDOMINPUT
STRING
ALG
INT
N
INT
T
USE
ALG
TO
SORT
T
RANDOM
ARRAYS
OF
LENGTH
N
DOUBLE
TOTAL
DOUBLE
A
NEW
DOUBLE
N
FOR
INT
T
T
T
T
PERFORM
ONE
EXPERIMENT
GENERATE
AND
SORT
AN
ARRAY
FOR
INT
I
I
N
I
A
I
STDRANDOM
UNIFORM
TOTAL
TIME
ALG
A
RETURN
TOTAL
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
STRING
ARGS
STRING
ARGS
INT
N
INTEGER
PARSEINT
ARGS
INT
T
INTEGER
PARSEINT
ARGS
DOUBLE
TIMERANDOMINPUT
N
T
TOTAL
FOR
DOUBLE
TIMERANDOMINPUT
N
T
TOTAL
FOR
STDOUT
PRINTF
FOR
D
RANDOM
DOUBLES
N
IS
N
STDOUT
PRINTF
TIMES
FASTER
THAN
N
THIS
CLIENT
RUNS
THE
TWO
SORTS
NAMED
IN
THE
FIRST
TWO
COMMAND
LINE
ARGUMENTS
ON
ARRAYS
OF
N
THE
THIRD
COMMAND
LINE
ARGUMENT
RANDOM
DOUBLE
VALUES
BETWEEN
AND
REPEATING
THE
EXPERI
MENT
T
THE
FOURTH
COMMAND
LINE
ARGUMENT
TIMES
THEN
PRINTS
THE
RATIO
OF
THE
TOTAL
RUNNING
TIMES
ON
YOUR
COMPUTER
TO
LEARN
THE
EXTENT
TO
WHICH
ITS
CONCLUSION
ABOUT
INSERTION
SORT
AND
SELECTION
SORT
IS
ROBUST
PROPERTY
D
IS
INTENTIONALLY
A
BIT
VAGUE
THE
VALUE
OF
THE
SMALL
CONSTANT
FACTOR
IS
LEFT
UNSTATED
AND
THE
ASSUMPTION
THAT
THE
COSTS
OF
COMPARES
AND
EXCHANGES
ARE
SIMILAR
IS
LEFT
UNSTATED
SO
THAT
IT
CAN
APPLY
IN
A
BROAD
VARIETY
OF
SITUATIONS
WHEN
POSSIBLE
WE
TRY
TO
CAPTURE
ESSENTIAL
ASPECTS
OF
THE
PERFORMANCE
OF
EACH
OF
THE
ALGORITHMS
THAT
WE
STUDY
IN
STATEMENTS
LIKE
THIS
AS
DISCUSSED
IN
CHAPTER
EACH
PROPERTY
THAT
WE
CONSIDER
NEEDS
TO
BE
TESTED
SCIENTIFICALLY
IN
A
GIVEN
SITUATION
PERHAPS
SUPPLEMENTED
WITH
A
MORE
REFINED
HYPOTHESIS
BASED
UPON
A
RELATED
PROPOSITION
MATHEMATICAL
TRUTH
FOR
PRACTICAL
APPLICATIONS
THERE
IS
ONE
FURTHER
STEP
WHICH
IS
CRUCIAL
RUN
EXPERIMENTS
TO
VALIDATE
THE
HYPOTHESIS
ON
THE
DATA
AT
HAND
WE
DEFER
CONSIDERATION
OF
THIS
STEP
TO
SECTION
AND
THE
EXERCISES
IN
THIS
CASE
IF
YOUR
SORT
KEYS
ARE
NOT
DISTINCT
AND
OR
NOT
RANDOMLY
ORDERED
PROPERTY
D
MIGHT
NOT
HOLD
YOU
CAN
RANDOMLY
ORDER
AN
ARRAY
WITH
STDRANDOM
SHUFFLE
BUT
APPLICATIONS
WITH
SIGNIFICANT
NUMBERS
OF
EQUAL
KEYS
INVOLVE
MORE
CAREFUL
ANALYSIS
OUR
DISCUSSIONS
OF
THE
ANALYSES
OF
ALGORITHMS
ARE
INTENDED
TO
BE
STARTING
POINTS
NOT
FINAL
CONCLUSIONS
IF
SOME
OTHER
QUESTION
ABOUT
PERFORMANCE
OF
THE
ALGORITHMS
COMES
TO
MIND
YOU
CAN
STUDY
IT
WITH
A
TOOL
LIKE
SORTCOMPARE
MANY
OPPORTUNITIES
TO
DO
SO
ARE
PRESENTED
IN
THE
EXERCISES
WE
DO
NOT
DWELL
FURTHER
ON
THE
COMPARATIVE
PERFORMANCE
OF
INSERTION
SORT
AND
SELEC
TION
SORT
BECAUSE
WE
ARE
MUCH
MORE
INTERESTED
IN
ALGORITHMS
THAT
CAN
RUN
A
HUNDRED
OR
A
THOUSAND
OR
A
MILLION
TIMES
FASTER
THAN
EITHER
STILL
UNDERSTANDING
THESE
ELEMENTARY
ALGORITHMS
IS
WORTHWHILE
FOR
SEVERAL
REASONS
THEY
HELP
US
WORK
OUT
THE
GROUND
RULES
THEY
PROVIDE
PERFORMANCE
BENCHMARKS
THEY
OFTEN
ARE
THE
METHOD
OF
CHOICE
IN
SOME
SPECIALIZED
SITUATIONS
THEY
CAN
SERVE
AS
THE
BASIS
FOR
DEVELOPING
BETTER
ALGORITHMS
FOR
THESE
REASONS
WE
WILL
USE
THE
SAME
BASIC
APPROACH
AND
CONSIDER
ELEMENTARY
ALGO
RITHMS
FOR
EVERY
PROBLEM
THAT
WE
STUDY
THROUGHOUT
THIS
BOOK
NOT
JUST
SORTING
PRO
GRAMS
LIKE
SORTCOMPARE
PLAY
A
CRITICAL
ROLE
IN
THIS
INCREMENTAL
APPROACH
TO
ALGORITHM
DEVELOPMENT
AT
EVERY
STEP
ALONG
THE
WAY
WE
CAN
USE
SUCH
A
PROGRAM
TO
HELP
EVALUATE
WHETHER
A
NEW
ALGORITHM
OR
AN
IMPROVED
VERSION
OF
A
KNOWN
ALGORITHM
PROVIDES
THE
PERFORMANCE
GAINS
THAT
WE
EXPECT
H
SHELLSORT
TO
EXHIBIT
THE
VALUE
OF
KNOWING
PROPERTIES
OF
ELEMENTARY
SORTS
WE
NEXT
CONSIDER
A
FAST
ALGORITHM
BASED
ON
INSERTION
SORT
INSERTION
SORT
IS
SLOW
FOR
LARGE
UN
ORDERED
ARRAYS
BECAUSE
THE
ONLY
EXCHANGES
IT
DOES
INVOLVE
ADJACENT
ENTRIES
SO
ITEMS
CAN
MOVE
THROUGH
THE
ARRAY
ONLY
ONE
PLACE
AT
A
TIME
FOR
EXAMPLE
IF
THE
ITEM
WITH
THE
SMALLEST
KEY
HAPPENS
TO
BE
AT
THE
END
OF
THE
ARRAY
N
EXCHANGES
ARE
NEEDED
TO
GET
THAT
ONE
ITEM
WHERE
IT
BELONGS
SHELLSORT
IS
A
SIMPLE
EXTENSION
OF
INSERTION
SORT
THAT
GAINS
SPEED
BY
ALLOWING
EXCHANGES
OF
ARRAY
ENTRIES
THAT
ARE
FAR
APART
TO
PRODUCE
PARTIALLY
SORTED
ARRAYS
THAT
CAN
BE
EFFICIENTLY
SORTED
EVENTUALLY
BY
INSERTION
SORT
THE
IDEA
IS
TO
REARRANGE
THE
ARRAY
TO
GIVE
IT
THE
PROPERTY
THAT
TAKING
EVERY
HTH
ENTRY
STARTING
ANYWHERE
YIELDS
A
SORTED
SUBSEQUENCE
SUCH
AN
ARRAY
IS
SAID
TO
BE
H
SORTED
PUT
ANOTHER
WAY
AN
H
SORTED
ARRAY
IS
H
INDE
PENDENT
SORTED
SUBSEQUENCES
INTERLEAVED
L
E
E
A
M
H
L
E
P
O
L
T
X
R
L
M
P
T
E
H
E
L
O
X
A
E
L
R
AN
H
SORTED
SEQUENCE
IS
H
INTERLEAVED
SORTED
SUBSEQUENCES
TOGETHER
BY
H
SORTING
FOR
SOME
LARGE
VAL
UES
OF
H
WE
CAN
MOVE
ITEMS
IN
THE
ARRAY
LONG
DISTANCES
AND
THUS
MAKE
IT
EASIER
TO
H
SORT
FOR
SMALLER
VALUES
OF
H
USING
SUCH
A
PROCEDURE
FOR
ANY
SEQUENCE
OF
VALUES
OF
H
THAT
ENDS
IN
WILL
PRODUCE
A
SORTED
AR
RAY
THAT
IS
SHELLSORT
THE
IMPLEMENTATION
IN
ALGORITHM
ON
THE
FACING
PAGE
USES
THE
SEQUENCE
OF
DECREASING
VALUES
STARTING
AT
THE
LARGEST
INCREMENT
LESS
THAN
N
AND
DECREASING
TO
WE
REFER
TO
SUCH
A
SEQUENCE
AS
AN
INCREMENT
SEQUENCE
ALGORITHM
COMPUTES
ITS
INCREMENT
SEQUENCE
ANOTHER
ALTERNATIVE
IS
TO
STORE
AN
INCREMENT
SEQUENCE
IN
AN
ARRAY
ONE
WAY
TO
IMPLEMENT
SHELLSORT
WOULD
BE
FOR
EACH
H
TO
USE
INSERTION
SORT
INDEPEN
DENTLY
ON
EACH
OF
THE
H
SUBSEQUENCES
BECAUSE
THE
SUBSEQUENCES
ARE
INDEPENDENT
WE
CAN
USE
AN
EVEN
SIMPLER
APPROACH
WHEN
H
SORTING
THE
ARRAY
WE
INSERT
EACH
ITEM
AMONG
THE
PREVIOUS
ITEMS
IN
ITS
H
SUBSEQUENCE
BY
EXCHANGING
IT
WITH
THOSE
THAT
HAVE
LARGER
KEYS
MOVING
THEM
EACH
ONE
POSITION
TO
THE
RIGHT
IN
THE
SUBSEQUENCE
WE
ACCOMPLISH
THIS
TASK
BY
USING
THE
INSERTION
SORT
CODE
BUT
MODIFIED
TO
DECREMENT
BY
H
INSTEAD
OF
WHEN
MOVING
THROUGH
THE
ARRAY
THIS
OBSERVATION
REDUCES
THE
SHELLSORT
IMPLEMENTA
TION
TO
AN
INSERTION
SORT
LIKE
PASS
THROUGH
THE
ARRAY
FOR
EACH
INCREMENT
SHELLSORT
GAINS
EFFICIENCY
BY
MAKING
A
TRADEOFF
BETWEEN
SIZE
AND
PARTIAL
ORDER
IN
THE
SUBSEQUENCES
AT
THE
BEGINNING
THE
SUBSEQUENCES
ARE
SHORT
LATER
IN
THE
SORT
THE
SUBSE
QUENCES
ARE
PARTIALLY
SORTED
IN
BOTH
CASES
INSERTION
SORT
IS
THE
METHOD
OF
CHOICE
THE
EXTENT
TO
WHICH
THE
SUBSEQUENCES
ARE
PARTIALLY
SORTED
IS
A
VARIABLE
FACTOR
THAT
DEPENDS
STRONGLY
ON
THE
INCREMENT
SEQUENCE
UNDERSTANDING
SHELLSORT
PERFORMANCE
IS
A
CHAL
LENGE
INDEED
ALGORITHM
IS
THE
ONLY
SORTING
METHOD
WE
CONSIDER
WHOSE
PERFOR
MANCE
ON
RANDOMLY
ORDERED
ARRAYS
HAS
NOT
BEEN
PRECISELY
CHARACTERIZED
ALGORITHM
SHELLSORT
PUBLIC
CLASS
SHELL
PUBLIC
STATIC
VOID
SORT
COMPARABLE
A
SORT
A
INTO
INCREASING
ORDER
INT
N
A
LENGTH
INT
H
WHILE
H
N
H
H
WHILE
H
H
SORT
THE
ARRAY
FOR
INT
I
H
I
N
I
INSERT
A
I
AMONG
A
I
H
A
I
H
A
I
H
FOR
INT
J
I
J
H
LESS
A
J
A
J
H
J
H
EXCH
A
J
J
H
H
H
SEE
PAGE
FOR
LESS
EXCH
ISSORTED
AND
MAIN
IF
WE
MODIFY
INSERTION
SORT
ALGORITHM
TO
H
SORT
THE
ARRAY
AND
ADD
AN
OUTER
LOOP
TO
DECREASE
H
THROUGH
A
SEQUENCE
OF
INCREMENTS
STARTING
AT
AN
INCREMENT
AS
LARGE
AS
A
CONSTANT
FRACTION
OF
THE
AR
RAY
LENGTH
AND
ENDING
AT
WE
ARE
LED
TO
THIS
COMPACT
SHELLSORT
IMPLEMENTATION
INPUT
H
E
L
L
O
R
T
E
X
A
M
P
L
E
SORT
P
H
E
L
L
O
R
T
E
X
A
M
L
E
SORT
L
E
E
A
M
H
L
E
P
O
L
T
X
R
SORT
A
E
E
E
H
L
L
L
M
O
P
R
T
X
SHELLSORT
TRACE
ARRAY
CONTENTS
AFTER
EACH
PASS
HOW
DO
WE
DECIDE
WHAT
INCREMENT
SEQUENCE
TO
USE
IN
GENERAL
THIS
QUESTION
IS
A
DIF
FICULT
ONE
TO
ANSWER
THE
PERFORMANCE
OF
THE
ALGORITHM
DEPENDS
NOT
JUST
ON
THE
NUM
BER
OF
INCREMENTS
BUT
ALSO
ON
ARITHMETICAL
INTERACTIONS
AMONG
THE
INCREMENTS
SUCH
AS
THE
SIZE
OF
THEIR
COMMON
DIVI
INPUT
H
E
L
L
O
R
T
E
X
A
M
P
L
E
DETAILED
TRACE
OF
SHELLSORT
INSERTIONS
SORS
AND
OTHER
PROPERTIES
MANY
DIFFERENT
INCREMENT
SEQUENCES
HAVE
BEEN
STUDIED
IN
THE
LIT
ERATURE
BUT
NO
PROVABLY
BEST
SEQUENCE
HAS
BEEN
FOUND
THE
INCREMENT
SEQUENCE
THAT
IS
USED
IN
ALGORITHM
IS
EASY
TO
COMPUTE
AND
USE
AND
PERFORMS
NEARLY
AS
WELL
AS
MORE
SOPHISTI
CATED
INCREMENT
SEQUENCES
THAT
HAVE
BEEN
DISCOVERED
THAT
HAVE
PROVABLY
BETTER
WORST
CASE
PER
FORMANCE
INCREMENT
SEQUENCES
THAT
ARE
SUBSTANTIALLY
BETTER
STILL
MAY
BE
WAITING
TO
BE
DISCOVERED
SHELLSORT
IS
USEFUL
EVEN
FOR
LARGE
ARRAYS
PARTICULARLY
BY
CONTRAST
WITH
SELECTION
SORT
AND
INSERTION
SORT
IT
ALSO
PERFORMS
WELL
ON
ARRAYS
THAT
ARE
IN
ARBI
TRARY
ORDER
NOT
NECESSARILY
RAN
DOM
INDEED
CONSTRUCTING
AN
ARRAY
FOR
WHICH
SHELLSORT
RUNS
SLOWLY
FOR
A
PARTICULAR
INCRE
MENT
SEQUENCE
IS
USUALLY
A
CHAL
LENGING
EXERCISE
AS
YOU
CAN
LEARN
WITH
SORTCOMPARE
SHELLSORT
IS
MUCH
FASTER
THAN
INSERTION
SORT
AND
SELECTION
SORT
AND
ITS
SPEED
AD
VANTAGE
INCREASES
WITH
THE
ARRAY
SIZE
BEFORE
READING
FURTHER
TRY
USING
SORTCOMPARE
TO
COMPARE
SHELLSORT
WITH
INSERTION
SORT
AND
SELECTION
SORT
FOR
ARRAY
SIZES
THAT
ARE
INCREASING
POWERS
OF
ON
YOUR
COMPUTER
SEE
EXERCISE
YOU
WILL
SEE
THAT
SHELLSORT
MAKES
IT
POSSIBLE
TO
ADDRESS
SORTING
INPUT
SORTED
SORTED
SORTED
RESULT
VISUAL
TRACE
OF
SHELLSORT
PROBLEMS
THAT
COULD
NOT
BE
ADDRESSED
WITH
THE
MORE
ELEMENTARY
ALGORITHMS
THIS
EX
AMPLE
IS
OUR
FIRST
PRACTICAL
ILLUSTRATION
OF
AN
IMPORTANT
PRINCIPLE
THAT
PERVADES
THIS
BOOK
ACHIEVING
SPEEDUPS
THAT
ENABLE
THE
SOLUTION
OF
PROBLEMS
THAT
COULD
NOT
OTHERWISE
BE
SOLVED
IS
ONE
OF
THE
PRIME
REASONS
TO
STUDY
ALGORITHM
PERFORMANCE
AND
DESIGN
THE
STUDY
OF
THE
PERFORMANCE
CHARACTERISTICS
OF
SHELLSORT
REQUIRES
MATHEMATICAL
AR
GUMENTS
THAT
ARE
BEYOND
THE
SCOPE
OF
THIS
BOOK
IF
YOU
WANT
TO
BE
CONVINCED
START
BY
THINKING
ABOUT
HOW
YOU
WOULD
PROVE
THE
FOLLOWING
FACT
WHEN
AN
H
SORTED
ARRAY
IS
K
SORTED
IT
REMAINS
H
SORTED
AS
FOR
THE
PERFORMANCE
OF
ALGORITHM
THE
MOST
IM
PORTANT
RESULT
IN
THE
PRESENT
CONTEXT
IS
THE
KNOWLEDGE
THAT
THE
RUNNING
TIME
OF
SHELLSORT
IS
NOT
NECESSARILY
QUADRATIC
FOR
EXAMPLE
IT
IS
KNOWN
THAT
THE
WORST
CASE
NUMBER
OF
COMPARES
FOR
ALGORITHM
IS
PROPORTIONAL
TO
N
THAT
SUCH
A
SIMPLE
MODIFICATION
CAN
BREAK
THE
QUADRATIC
RUNNING
TIME
BARRIER
IS
QUITE
INTERESTING
AS
DOING
SO
IS
A
PRIME
GOAL
FOR
MANY
ALGORITHM
DESIGN
PROBLEMS
NO
MATHEMATICAL
RESULTS
ARE
AVAILABLE
ABOUT
THE
AVERAGE
CASE
NUMBER
OF
COMPARES
FOR
SHELLSORT
FOR
RANDOMLY
ORDERED
INPUT
INCREMENT
SEQUENCES
HAVE
BEEN
DEVISED
THAT
DRIVE
THE
ASYMPTOTIC
GROWTH
OF
THE
WORST
CASE
NUMBER
OF
COMPARES
DOWN
TO
N
N
N
BUT
MANY
OF
THESE
RESULTS
ARE
PRIMARILY
OF
ACADEMIC
INTEREST
BECAUSE
THESE
FUNCTIONS
ARE
HARD
TO
DISTINGUISH
FROM
ONE
ANOTHER
AND
FROM
A
CONSTANT
FACTOR
OF
N
FOR
PRACTICAL
VALUES
OF
N
IN
PRACTICE
YOU
CAN
SAFELY
TAKE
ADVANTAGE
OF
THE
PAST
SCIENTIFIC
STUDY
OF
SHELLSORT
JUST
BY
USING
THE
INCREMENT
SEQUENCE
IN
ALGORITHM
OR
ONE
OF
THE
INCREMENT
SEQUENCES
IN
THE
EXERCISES
AT
THE
END
OF
THIS
SECTION
WHICH
MAY
IMPROVE
PERFORMANCE
BY
TO
PERCENT
MOREOVER
YOU
CAN
EASILY
VALIDATE
THE
FOLLOWING
HYPOTHESIS
EXPERIENCED
PROGRAMMERS
SOMETIMES
CHOOSE
SHELLSORT
BECAUSE
IT
HAS
ACCEPTABLE
RUNNING
TIME
EVEN
FOR
MODERATELY
LARGE
ARRAYS
IT
REQUIRES
A
SMALL
AMOUNT
OF
CODE
AND
IT
USES
NO
EXTRA
SPACE
IN
THE
NEXT
FEW
SECTIONS
WE
SHALL
SEE
METHODS
THAT
ARE
MORE
EF
FICIENT
BUT
THEY
ARE
PERHAPS
ONLY
TWICE
AS
FAST
IF
THAT
MUCH
EXCEPT
FOR
VERY
LARGE
N
AND
THEY
ARE
MORE
COMPLICATED
IF
YOU
NEED
A
SOLUTION
TO
A
SORTING
PROBLEM
AND
ARE
WORK
ING
IN
A
SITUATION
WHERE
A
SYSTEM
SORT
MAY
NOT
BE
AVAILABLE
FOR
EXAMPLE
CODE
DESTINED
FOR
HARDWARE
OR
AN
EMBEDDED
SYSTEM
YOU
CAN
SAFELY
USE
SHELLSORT
THEN
DETERMINE
SOMETIME
LATER
WHETHER
IT
WILL
BE
WORTHWHILE
TO
REPLACE
IT
WITH
A
MORE
SOPHISTICATED
METHOD
Q
SORTING
SEEMS
LIKE
A
TOY
PROBLEM
AREN
T
MANY
OF
THE
OTHER
THINGS
THAT
WE
DO
WITH
COMPUTERS
MUCH
MORE
INTERESTING
A
PERHAPS
BUT
MANY
OF
THOSE
INTERESTING
THINGS
ARE
MADE
POSSIBLE
BY
FAST
SORTING
AL
GORITHMS
YOU
WILL
FIND
MANY
EXAMPLES
IN
SECTION
AND
THROUGHOUT
THE
REST
OF
THE
BOOK
SORTING
IS
WORTH
STUDYING
NOW
BECAUSE
THE
PROBLEM
IS
EASY
TO
UNDERSTAND
AND
YOU
CAN
APPRECIATE
THE
INGENUITY
BEHIND
THE
FASTER
ALGORITHMS
Q
WHY
SO
MANY
SORTING
ALGORITHMS
A
ONE
REASON
IS
THAT
THE
PERFORMANCE
OF
MANY
ALGORITHMS
DEPENDS
ON
THE
INPUT
VAL
UES
SO
DIFFERENT
ALGORITHMS
MIGHT
BE
APPROPRIATE
FOR
DIFFERENT
APPLICATIONS
HAVING
DIF
FERENT
KINDS
OF
INPUT
FOR
EXAMPLE
INSERTION
SORT
IS
THE
METHOD
OF
CHOICE
FOR
PARTIALLY
SORTED
OR
TINY
ARRAYS
OTHER
CONSTRAINTS
SUCH
AS
SPACE
AND
TREATMENT
OF
EQUAL
KEYS
ALSO
COME
INTO
PLAY
WE
WILL
REVISIT
THIS
QUESTION
IN
SECTION
Q
WHY
BOTHER
USING
THE
TINY
HELPER
METHODS
LESS
AND
EXCH
A
THEY
ARE
BASIC
ABSTRACT
OPERATIONS
NEEDED
BY
ANY
SORT
ALGORITHM
AND
THE
CODE
IS
EASIER
TO
UNDERSTAND
IN
TERMS
OF
THESE
ABSTRACTIONS
MOREOVER
THEY
MAKE
THE
CODE
DI
RECTLY
PORTABLE
TO
OTHER
SETTINGS
FOR
EXAMPLE
MUCH
OF
THE
CODE
IN
ALGORITHMS
AND
IS
LEGAL
CODE
IN
SEVERAL
OTHER
PROGRAMMING
LANGUAGES
EVEN
IN
JAVA
WE
CAN
USE
THIS
CODE
AS
THE
BASIS
FOR
SORTING
PRIMITIVE
TYPES
WHICH
ARE
NOT
COMPARABLE
SIMPLY
IMPLEMENT
LESS
WITH
THE
CODE
V
W
Q
WHEN
I
RUN
SORTCOMPARE
I
GET
DIFFERENT
VALUES
EACH
TIME
THAT
I
RUN
IT
AND
THOSE
ARE
DIFFERENT
FROM
THE
VALUES
IN
THE
BOOK
WHY
A
FOR
STARTERS
YOU
HAVE
A
DIFFERENT
COMPUTER
FROM
THE
ONE
WE
USED
NOT
TO
MENTION
A
DIFFERENT
OPERATING
SYSTEM
JAVA
RUNTIME
AND
SO
FORTH
ALL
OF
THESE
DIFFERENCES
MIGHT
LEAD
TO
SLIGHT
DIFFERENCES
IN
THE
MACHINE
CODE
FOR
THE
ALGORITHMS
DIFFERENCES
EACH
TIME
THAT
YOU
RUN
IT
ON
YOUR
COMPUTER
MIGHT
BE
DUE
TO
OTHER
APPLICATIONS
THAT
YOU
ARE
RUN
NING
OR
VARIOUS
OTHER
CONDITIONS
RUNNING
A
VERY
LARGE
NUMBER
OF
TRIALS
SHOULD
DAMPEN
THE
EFFECT
THE
LESSON
IS
THAT
SMALL
DIFFERENCES
IN
ALGORITHM
PERFORMANCE
ARE
DIFFICULT
TO
NOTICE
NOWADAYS
THAT
IS
A
PRIMARY
REASON
THAT
WE
FOCUS
ON
LARGE
ONES
SHOW
IN
THE
STYLE
OF
THE
EXAMPLE
TRACE
WITH
ALGORITHM
HOW
SELECTION
SORT
SORTS
THE
ARRAY
E
A
Y
Q
U
E
T
I
O
N
WHAT
IS
THE
MAXIMUM
NUMBER
OF
EXCHANGES
INVOLVING
ANY
PARTICULAR
ELEMENT
DURING
SELECTION
SORT
WHAT
IS
THE
AVERAGE
NUMBER
OF
EXCHANGES
INVOLVING
AN
ELEMENT
GIVE
AN
EXAMPLE
OF
AN
ARRAY
OF
N
ITEMS
THAT
MAXIMIZES
THE
NUMBER
OF
TIMES
THE
TEST
A
J
A
MIN
FAILS
AND
THEREFORE
MIN
GETS
UPDATED
DURING
THE
OPERATION
OF
SELECTION
SORT
ALGORITHM
SHOW
IN
THE
STYLE
OF
THE
EXAMPLE
TRACE
WITH
ALGORITHM
HOW
INSERTION
SORT
SORTS
THE
ARRAY
E
A
Y
Q
U
E
T
I
O
N
FOR
EACH
OF
THE
TWO
CONDITIONS
IN
THE
INNER
FOR
LOOP
IN
INSERTION
SORT
ALGO
RITHM
DESCRIBE
AN
ARRAY
OF
N
ITEMS
WHERE
THAT
CONDITION
IS
ALWAYS
FALSE
WHEN
THE
LOOP
TERMINATES
WHICH
METHOD
RUNS
FASTER
FOR
AN
ARRAY
WITH
ALL
KEYS
IDENTICAL
SELECTION
SORT
OR
INSERTION
SORT
WHICH
METHOD
RUNS
FASTER
FOR
AN
ARRAY
IN
REVERSE
ORDER
SELECTION
SORT
OR
INSER
TION
SORT
SUPPOSE
THAT
WE
USE
INSERTION
SORT
ON
A
RANDOMLY
ORDERED
ARRAY
WHERE
ELEMENTS
HAVE
ONLY
ONE
OF
THREE
VALUES
IS
THE
RUNNING
TIME
LINEAR
QUADRATIC
OR
SOMETHING
IN
BETWEEN
SHOW
IN
THE
STYLE
OF
THE
EXAMPLE
TRACE
WITH
ALGORITHM
HOW
SHELLSORT
SORTS
THE
ARRAY
E
A
Y
H
E
L
L
O
R
T
Q
U
E
T
I
O
N
WHY
NOT
USE
SELECTION
SORT
FOR
H
SORTING
IN
SHELLSORT
IMPLEMENT
A
VERSION
OF
SHELLSORT
THAT
KEEPS
THE
INCREMENT
SEQUENCE
IN
AN
ARRAY
RATHER
THAN
COMPUTING
IT
INSTRUMENT
SHELLSORT
TO
PRINT
THE
NUMBER
OF
COMPARES
DIVIDED
BY
THE
ARRAY
SIZE
FOR
EACH
INCREMENT
WRITE
A
TEST
CLIENT
THAT
TESTS
THE
HYPOTHESIS
THAT
THIS
NUMBER
IS
A
SMALL
CONSTANT
BY
SORTING
ARRAYS
OF
RANDOM
DOUBLE
VALUES
USING
ARRAY
SIZES
THAT
ARE
INCREASING
POWERS
OF
STARTING
AT
DECK
SORT
EXPLAIN
HOW
YOU
WOULD
PUT
A
DECK
OF
CARDS
IN
ORDER
BY
SUIT
IN
THE
ORDER
SPADES
HEARTS
CLUBS
DIAMONDS
AND
BY
RANK
WITHIN
EACH
SUIT
WITH
THE
RESTRICTION
THAT
THE
CARDS
MUST
BE
LAID
OUT
FACE
DOWN
IN
A
ROW
AND
THE
ONLY
ALLOWED
OPERATIONS
ARE
TO
CHECK
THE
VALUES
OF
TWO
CARDS
AND
TO
EXCHANGE
TWO
CARDS
KEEPING
THEM
FACE
DOWN
DEQUEUE
SORT
EXPLAIN
HOW
YOU
WOULD
SORT
A
DECK
OF
CARDS
WITH
THE
RESTRIC
TION
THAT
THE
ONLY
ALLOWED
OPERATIONS
ARE
TO
LOOK
AT
THE
VALUES
OF
THE
TOP
TWO
CARDS
TO
EXCHANGE
THE
TOP
TWO
CARDS
AND
TO
MOVE
THE
TOP
CARD
TO
THE
BOTTOM
OF
THE
DECK
EXPENSIVE
EXCHANGE
A
CLERK
AT
A
SHIPPING
COMPANY
IS
CHARGED
WITH
THE
TASK
OF
REARRANGING
A
NUMBER
OF
LARGE
CRATES
IN
ORDER
OF
THE
TIME
THEY
ARE
TO
BE
SHIPPED
OUT
THUS
THE
COST
OF
COMPARES
IS
VERY
LOW
JUST
LOOK
AT
THE
LABELS
RELATIVE
TO
THE
COST
OF
EX
CHANGES
MOVE
THE
CRATES
THE
WAREHOUSE
IS
NEARLY
FULL
THERE
IS
EXTRA
SPACE
SUFFICIENT
TO
HOLD
ANY
ONE
OF
THE
CRATES
BUT
NOT
TWO
WHAT
SORTING
METHOD
SHOULD
THE
CLERK
USE
CERTIFICATION
WRITE
A
CHECK
METHOD
THAT
CALLS
SORT
FOR
A
GIVEN
ARRAY
AND
RETURNS
TRUE
IF
SORT
PUTS
THE
ARRAY
IN
ORDER
AND
LEAVES
THE
SAME
SET
OF
OBJECTS
IN
THE
ARRAY
AS
WERE
THERE
INITIALLY
FALSE
OTHERWISE
DO
NOT
ASSUME
THAT
SORT
IS
RESTRICTED
TO
MOVE
DATA
ONLY
WITH
EXCH
YOU
MAY
USE
ARRAYS
SORT
AND
ASSUME
THAT
IT
IS
CORRECT
ANIMATION
ADD
CODE
TO
INSERTION
AND
SELECTION
TO
MAKE
THEM
DRAW
THE
ARRAY
CONTENTS
AS
VERTICAL
BARS
LIKE
THE
VISUAL
TRACES
IN
THIS
SECTION
REDRAWING
THE
BARS
AFTER
EACH
PASS
TO
PRODUCE
AN
ANIMATED
EFFECT
ENDING
IN
A
SORTED
PICTURE
WHERE
THE
BARS
APPEAR
IN
ORDER
OF
THEIR
HEIGHT
HINT
USE
A
CLIENT
LIKE
THE
ONE
IN
THE
TEXT
THAT
GENER
ATES
RANDOM
DOUBLE
VALUES
INSERT
CALLS
TO
SHOW
AS
APPROPRIATE
IN
THE
SORT
CODE
AND
IMPLEMENT
A
SHOW
METHOD
THAT
CLEARS
THE
CANVAS
AND
DRAWS
THE
BARS
VISUAL
TRACE
MODIFY
YOUR
SOLUTION
TO
THE
PREVIOUS
EXERCISE
TO
MAKE
INSERTION
AND
SELECTION
PRODUCE
VISUAL
TRACES
SUCH
AS
THOSE
DEPICTED
IN
THIS
SECTION
HINT
JUDI
CIOUS
USE
OF
SETYSCALE
MAKES
THIS
PROBLEM
EASY
EXTRA
CREDIT
ADD
THE
CODE
NECESSARY
TO
PRODUCE
RED
AND
GRAY
COLOR
ACCENTS
SUCH
AS
THOSE
IN
OUR
FIGURES
SHELLSORT
WORST
CASE
CONSTRUCT
AN
ARRAY
OF
ELEMENTS
CONTAINING
THE
NUM
BERS
THROUGH
FOR
WHICH
SHELLSORT
WITH
THE
INCREMENTS
USES
AS
LARGE
A
NUMBER
OF
COMPARES
AS
YOU
CAN
FIND
SHELLSORT
BEST
CASE
WHAT
IS
THE
BEST
CASE
FOR
SHELLSORT
JUSTIFY
YOUR
ANSWER
CREATIVE
PROBLEMS
CONTINUED
COMPARABLE
TRANSACTIONS
USING
OUR
CODE
FOR
DATE
PAGE
AS
A
MODEL
EX
PAND
YOUR
IMPLEMENTATION
OF
TRANSACTION
EXERCISE
SO
THAT
IT
IMPLEMENTS
COMPARABLE
SUCH
THAT
TRANSACTIONS
ARE
KEPT
IN
ORDER
BY
AMOUNT
SOLUTION
PUBLIC
CLASS
TRANSACTION
IMPLEMENTS
COMPARABLE
TRANSACTION
PRIVATE
FINAL
DOUBLE
AMOUNT
PUBLIC
INT
COMPARETO
TRANSACTION
THAT
IF
THIS
AMOUNT
THAT
AMOUNT
RETURN
IF
THIS
AMOUNT
THAT
AMOUNT
RETURN
RETURN
TRANSACTION
SORT
TEST
CLIENT
WRITE
A
CLASS
SORTTRANSACTIONS
THAT
CONSISTS
OF
A
STATIC
METHOD
MAIN
THAT
READS
A
SEQUENCE
OF
TRANSACTIONS
FROM
STANDARD
INPUT
SORTS
THEM
AND
PRINTS
THE
RESULT
ON
STANDARD
OUTPUT
SEE
EXERCISE
SOLUTION
PUBLIC
CLASS
SORTTRANSACTIONS
PUBLIC
STATIC
TRANSACTION
READTRANSACTIONS
SEE
EXERCISE
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
TRANSACTION
TRANSACTIONS
READTRANSACTIONS
SHELL
SORT
TRANSACTIONS
FOR
TRANSACTION
T
TRANSACTIONS
STDOUT
PRINTLN
T
DECK
SORT
ASK
A
FEW
FRIENDS
TO
SORT
A
DECK
OF
CARDS
SEE
EXERCISE
OB
SERVE
THEM
CAREFULLY
AND
WRITE
DOWN
THE
METHOD
THAT
THEY
USE
INSERTION
SORT
WITH
SENTINEL
DEVELOP
AN
IMPLEMENTATION
OF
INSERTION
SORT
THAT
ELIMINATES
THE
J
TEST
IN
THE
INNER
LOOP
BY
FIRST
PUTTING
THE
SMALLEST
ITEM
INTO
POSITION
USE
SORTCOMPARE
TO
EVALUATE
THE
EFFECTIVENESS
OF
DOING
SO
NOTE
IT
IS
OFTEN
POSSIBLE
TO
AVOID
AN
INDEX
OUT
OF
BOUNDS
TEST
IN
THIS
WAY
THE
ELEMENT
THAT
ENABLES
THE
TEST
TO
BE
ELIMINATED
IS
KNOWN
AS
A
SENTINEL
INSERTION
SORT
WITHOUT
EXCHANGES
DEVELOP
AN
IMPLEMENTATION
OF
INSERTION
SORT
THAT
MOVES
LARGER
ELEMENTS
TO
THE
RIGHT
ONE
POSITION
WITH
ONE
ARRAY
ACCESS
PER
ENTRY
RATHER
THAN
USING
EXCH
USE
SORTCOMPARE
TO
EVALUATE
THE
EFFECTIVENESS
OF
DOING
SO
PRIMITIVE
TYPES
DEVELOP
A
VERSION
OF
INSERTION
SORT
THAT
SORTS
ARRAYS
OF
INT
VALUES
AND
COMPARE
ITS
PERFORMANCE
WITH
THE
IMPLEMENTATION
GIVEN
IN
THE
TEXT
WHICH
SORTS
INTEGER
VALUES
AND
IMPLICITLY
USES
AUTOBOXING
AND
AUTO
UNBOXING
TO
CONVERT
SHELLSORT
IS
SUBQUADRATIC
USE
SORTCOMPARE
TO
COMPARE
SHELLSORT
WITH
INSERTION
SORT
AND
SELECTION
SORT
ON
YOUR
COMPUTER
USE
ARRAY
SIZES
THAT
ARE
INCREASING
POWERS
OF
STARTING
AT
EQUAL
KEYS
FORMULATE
AND
VALIDATE
HYPOTHESES
ABOUT
THE
RUNNING
TIME
OF
IN
SERTION
SORT
AND
SELECTION
SORT
FOR
ARRAYS
THAT
CONTAIN
JUST
TWO
KEY
VALUES
ASSUMING
THAT
THE
VALUES
ARE
EQUALLY
LIKELY
TO
OCCUR
SHELLSORT
INCREMENTS
RUN
EXPERIMENTS
TO
COMPARE
THE
INCREMENT
SEQUENCE
IN
ALGORITHM
WITH
THE
SEQUENCE
64769
WHICH
IS
FORMED
BY
MERGING
TOGETHER
THE
SE
QUENCES
AND
SEE
EXERCISE
GEOMETRIC
INCREMENTS
RUN
EXPERIMENTS
TO
DETERMINE
A
VALUE
OF
T
THAT
LEADS
TO
THE
LOWEST
RUNNING
TIME
OF
SHELLSORT
FOR
RANDOM
ARRAYS
FOR
THE
INCREMENT
SEQUENCE
T
T
T
T
FOR
N
GIVE
THE
VALUES
OF
T
AND
THE
INCREMENT
SEQUENCES
FOR
THE
BEST
THREE
VALUES
THAT
YOU
FIND
EXPERIMENTS
CONTINUED
THE
FOLLOWING
EXERCISES
DESCRIBE
VARIOUS
CLIENTS
FOR
HELPING
TO
EVALUATE
SORTING
METHODS
THEY
ARE
INTENDED
AS
STARTING
POINTS
FOR
HELPING
TO
UNDERSTAND
PERFORMANCE
PROPERTIES
USING
RAN
DOM
DATA
IN
ALL
OF
THEM
USE
TIME
AS
IN
SORTCOMPARE
SO
THAT
YOU
CAN
GET
MORE
ACCURATE
RESULTS
BY
SPECIFYING
MORE
TRIALS
IN
THE
SECOND
COMMAND
LINE
ARGUMENT
WE
REFER
BACK
TO
THESE
EXERCISES
IN
LATER
SECTIONS
WHEN
EVALUATING
MORE
SOPHISTICATED
METHODS
DOUBLING
TEST
WRITE
A
CLIENT
THAT
PERFORMS
A
DOUBLING
TEST
FOR
SORT
ALGORITHMS
START
AT
N
EQUAL
TO
AND
PRINT
N
THE
PREDICTED
NUMBER
OF
SECONDS
THE
ACTUAL
NUM
BER
OF
SECONDS
AND
THE
RATIO
AS
N
DOUBLES
USE
YOUR
PROGRAM
TO
VALIDATE
THAT
INSERTION
SORT
AND
SELECTION
SORT
ARE
QUADRATIC
FOR
RANDOM
INPUTS
AND
FORMULATE
AND
TEST
A
HY
POTHESIS
FOR
SHELLSORT
PLOT
RUNNING
TIMES
WRITE
A
CLIENT
THAT
USES
STDDRAW
TO
PLOT
THE
AVERAGE
RUNNING
TIMES
OF
THE
ALGORITHM
FOR
RANDOM
INPUTS
AND
VARIOUS
VALUES
OF
THE
ARRAY
SIZE
YOU
MAY
ADD
ONE
OR
TWO
MORE
COMMAND
LINE
ARGUMENTS
STRIVE
TO
DESIGN
A
USEFUL
TOOL
DISTRIBUTION
WRITE
A
CLIENT
THAT
ENTERS
INTO
AN
INFINITE
LOOP
RUNNING
SORT
ON
ARRAYS
OF
THE
SIZE
GIVEN
AS
THE
THIRD
COMMAND
LINE
ARGUMENT
MEASURES
THE
TIME
TAKEN
FOR
EACH
RUN
AND
USES
STDDRAW
TO
PLOT
THE
AVERAGE
RUNNING
TIMES
A
PICTURE
OF
THE
DIS
TRIBUTION
OF
THE
RUNNING
TIMES
SHOULD
EMERGE
CORNER
CASES
WRITE
A
CLIENT
THAT
RUNS
SORT
ON
DIFFICULT
OR
PATHOLOGICAL
CASES
THAT
MIGHT
TURN
UP
IN
PRACTICAL
APPLICATIONS
EXAMPLES
INCLUDE
ARRAYS
THAT
ARE
ALREADY
IN
ORDER
ARRAYS
IN
REVERSE
ORDER
ARRAYS
WHERE
ALL
KEYS
ARE
THE
SAME
ARRAYS
CONSISTING
OF
ONLY
TWO
DISTINCT
VALUES
AND
ARRAYS
OF
SIZE
OR
NONUNIFORM
DISTRIBUTIONS
WRITE
A
CLIENT
THAT
GENERATES
TEST
DATA
BY
RANDOMLY
ORDERING
OBJECTS
USING
OTHER
DISTRIBUTIONS
THAN
UNIFORM
INCLUDING
THE
FOLLOWING
GAUSSIAN
POISSON
GEOMETRIC
DISCRETE
SEE
EXERCISE
FOR
A
SPECIAL
CASE
DEVELOP
AND
TEST
HYPOTHESES
ABOUT
THE
EFFECT
OF
SUCH
INPUT
ON
THE
PERFORMANCE
OF
THE
ALGORITHMS
IN
THIS
SECTION
NONUNIFORM
DATA
WRITE
A
CLIENT
THAT
GENERATES
TEST
DATA
THAT
IS
NOT
UNIFORM
INCLUDING
THE
FOLLOWING
HALF
THE
DATA
IS
HALF
HALF
THE
DATA
IS
HALF
THE
REMAINDER
IS
HALF
THE
REMAINDER
IS
AND
SO
FORTH
HALF
THE
DATA
IS
HALF
RANDOM
INT
VALUES
DEVELOP
AND
TEST
HYPOTHESES
ABOUT
THE
EFFECT
OF
SUCH
INPUT
ON
THE
PERFORMANCE
OF
THE
ALGORITHMS
IN
THIS
SECTION
PARTIALLY
SORTED
WRITE
A
CLIENT
THAT
GENERATES
PARTIALLY
SORTED
ARRAYS
INCLUDING
THE
FOLLOWING
PERCENT
SORTED
LAST
PERCENT
RANDOM
VALUES
ALL
ENTRIES
WITHIN
POSITIONS
OF
THEIR
FINAL
PLACE
IN
THE
ARRAY
SORTED
EXCEPT
FOR
PERCENT
OF
THE
ENTRIES
RANDOMLY
DISPERSED
THROUGHOUT
THE
ARRAY
DEVELOP
AND
TEST
HYPOTHESES
ABOUT
THE
EFFECT
OF
SUCH
INPUT
ON
THE
PERFORMANCE
OF
THE
ALGORITHMS
IN
THIS
SECTION
VARIOUS
TYPES
OF
ITEMS
WRITE
A
CLIENT
THAT
GENERATES
ARRAYS
OF
ITEMS
OF
VARIOUS
TYPES
WITH
RANDOM
KEY
VALUES
INCLUDING
THE
FOLLOWING
STRING
KEY
AT
LEAST
TEN
CHARACTERS
ONE
DOUBLE
VALUE
DOUBLE
KEY
TEN
STRING
VALUES
ALL
AT
LEAST
TEN
CHARACTERS
INT
KEY
ONE
INT
VALUE
DEVELOP
AND
TEST
HYPOTHESES
ABOUT
THE
EFFECT
OF
SUCH
INPUT
ON
THE
PERFORMANCE
OF
THE
ALGORITHMS
IN
THIS
SECTION
THE
ALGORITHMS
THAT
WE
CONSIDER
IN
THIS
SECTION
ARE
BASED
ON
A
SIMPLE
OPERATION
KNOWN
AS
MERGING
COMBINING
TWO
ORDERED
ARRAYS
TO
MAKE
ONE
LARGER
ORDERED
ARRAY
THIS
OPERATION
IMMEDIATELY
LEADS
TO
A
SIMPLE
RECURSIVE
SORT
METHOD
KNOWN
AS
MERGE
SORT
TO
SORT
AN
ARRAY
DIVIDE
IT
INTO
TWO
HALVES
SORT
THE
TWO
HALVES
RECURSIVELY
AND
THEN
MERGE
THE
RESULTS
AS
YOU
WILL
SEE
ONE
OF
MERGESORT
MOST
ATTRACTIVE
PROPERTIES
IS
THAT
IT
GUARANTEES
TO
SORT
ANY
ARRAY
OF
N
ITEMS
IN
TIME
PROPORTIONAL
TO
N
LOG
N
ITS
PRIME
DISADVANTAGE
IS
THAT
IT
USES
EXTRA
SPACE
PROPORTIONAL
TO
N
INPUT
M
E
R
G
E
O
R
T
E
X
A
M
P
L
E
SORT
LEFT
HALF
E
E
G
M
O
R
R
T
E
X
A
M
P
L
E
SORT
RIGHT
HALF
E
E
G
M
O
R
R
A
E
E
L
M
P
T
X
MERGE
RESULTS
A
E
E
E
E
G
L
M
M
O
P
R
R
T
X
MERGESORT
OVERVIEW
ABSTRACT
IN
PLACE
MERGE
THE
STRAIGHTFORWARD
APPROACH
TO
IMPLEMENTING
MERG
ING
IS
TO
DESIGN
A
METHOD
THAT
MERGES
TWO
DISJOINT
ORDERED
ARRAYS
OF
COMPARABLE
OB
JECTS
INTO
A
THIRD
ARRAY
THIS
STRATEGY
IS
EASY
TO
IMPLEMENT
CREATE
AN
OUTPUT
ARRAY
OF
THE
REQUISITE
SIZE
AND
THEN
CHOOSE
SUCCESSIVELY
THE
SMALLEST
REMAINING
ITEM
FROM
THE
TWO
INPUT
ARRAYS
TO
BE
THE
NEXT
ITEM
ADDED
TO
THE
OUTPUT
ARRAY
HOWEVER
WHEN
WE
MERGESORT
A
LARGE
ARRAY
WE
ARE
DOING
A
HUGE
NUMBER
OF
MERGES
SO
THE
COST
OF
CREATING
A
NEW
ARRAY
TO
HOLD
THE
OUTPUT
EVERY
TIME
THAT
WE
DO
A
MERGE
IS
PROBLEMATIC
IT
WOULD
BE
MUCH
MORE
DESIRABLE
TO
HAVE
AN
IN
PLACE
METHOD
SO
THAT
WE
COULD
SORT
THE
FIRST
HALF
OF
THE
ARRAY
IN
PLACE
THEN
SORT
THE
SECOND
HALF
OF
THE
ARRAY
IN
PLACE
THEN
DO
THE
MERGE
OF
THE
TWO
HALVES
BY
MOVING
THE
ITEMS
AROUND
WITHIN
THE
AR
RAY
WITHOUT
USING
A
SIGNIFICANT
AMOUNT
OF
OTHER
EXTRA
SPACE
IT
IS
WORTHWHILE
TO
PAUSE
MOMENTARILY
TO
CONSIDER
HOW
YOU
MIGHT
DO
THAT
AT
FIRST
BLUSH
THIS
PROBLEM
SEEMS
TO
BE
ONE
THAT
MUST
BE
SIMPLE
TO
SOLVE
BUT
SOLUTIONS
THAT
ARE
KNOWN
ARE
QUITE
COMPLICATED
ESPECIALLY
BY
COMPARISON
TO
ALTERNATIVES
THAT
USE
EXTRA
SPACE
STILL
THE
ABSTRACTION
OF
AN
IN
PLACE
MERGE
IS
USEFUL
ACCORDINGLY
WE
USE
THE
METHOD
SIGNATURE
MERGE
A
LO
MID
HI
TO
SPECIFY
A
MERGE
METHOD
THAT
PUTS
THE
RESULT
OF
MERGING
THE
SUBARRAYS
A
LO
MID
WITH
A
MID
HI
INTO
A
SINGLE
ORDERED
ARRAY
LEAVING
THE
RESULT
IN
A
LO
HI
THE
CODE
ON
THE
NEXT
PAGE
IMPLEMENTS
THIS
MERGE
METHOD
IN
JUST
A
FEW
LINES
BY
COPYING
EVERYTHING
TO
AN
AUXILIARY
ARRAY
AND
THEN
MERGING
BACK
TO
THE
ORIGINAL
ANOTHER
APPROACH
IS
DESCRIBED
IN
EXERCISE
ABSTRACT
IN
PLACE
MERGE
PUBLIC
STATIC
VOID
MERGE
COMPARABLE
A
INT
LO
INT
MID
INT
HI
MERGE
A
LO
MID
WITH
A
MID
HI
INT
I
LO
J
MID
FOR
INT
K
LO
K
HI
K
COPY
A
LO
HI
TO
AUX
LO
HI
AUX
K
A
K
FOR
INT
K
LO
K
HI
K
MERGE
BACK
TO
A
LO
HI
IF
I
MID
A
K
AUX
J
ELSE
IF
J
HI
A
K
AUX
I
ELSE
IF
LESS
AUX
J
AUX
I
A
K
AUX
J
ELSE
A
K
AUX
I
THIS
METHOD
MERGES
BY
FIRST
COPYING
INTO
THE
AUXILIARY
ARRAY
AUX
THEN
MERGING
BACK
TO
A
IN
THE
MERGE
THE
SECOND
FOR
LOOP
THERE
ARE
FOUR
CONDITIONS
LEFT
HALF
EXHAUSTED
TAKE
FROM
THE
RIGHT
RIGHT
HALF
EXHAUSTED
TAKE
FROM
THE
LEFT
CURRENT
KEY
ON
RIGHT
LESS
THAN
CURRENT
KEY
ON
LEFT
TAKE
FROM
THE
RIGHT
AND
CURRENT
KEY
ON
RIGHT
GREATER
THAN
OR
EQUAL
TO
CURRENT
KEY
ON
LEFT
TAKE
FROM
THE
LEFT
A
AUX
K
I
J
INPUT
COPY
E
E
E
E
G
G
M
M
R
R
A
A
C
C
E
E
R
R
T
T
E
E
G
M
R
A
C
E
R
T
A
E
E
G
M
R
A
C
E
R
T
A
C
E
E
G
M
R
C
E
R
T
A
C
E
E
E
G
M
R
E
R
T
A
C
E
E
E
G
M
R
E
R
T
A
C
E
E
E
G
M
R
E
R
T
A
C
E
E
E
G
G
M
R
R
T
A
C
E
E
E
G
M
M
R
R
T
A
C
E
E
E
G
M
R
R
R
T
A
C
E
E
E
G
M
R
R
R
T
A
C
E
E
E
G
M
R
R
T
T
MERGED
RESULT
A
C
E
E
E
G
M
R
R
T
ABSTRACT
IN
PLACE
MERGE
TRACE
TOP
DOWN
MERGESORT
ALGORITHM
IS
A
RECUR
SIVE
MERGESORT
IMPLEMENTATION
BASED
ON
THIS
ABSTRACT
IN
SORT
SORT
A
SORT
A
PLACE
MERGE
IT
IS
ONE
OF
THE
BEST
KNOWN
EXAMPLES
OF
THE
UTILITY
OF
THE
DIVIDE
AND
CONQUER
PARADIGM
FOR
EFFICIENT
ALGORITHM
DESIGN
THIS
RECURSIVE
CODE
IS
THE
BASIS
FOR
AN
INDUCTIVE
PROOF
THAT
THE
ALGORITHM
SORTS
THE
ARRAY
IF
IT
SORTS
THE
TWO
SUBARRAYS
IT
SORTS
THE
WHOLE
ARRAY
BY
MERG
ING
TOGETHER
THE
SUBARRAYS
TO
UNDERSTAND
MERGESORT
IT
IS
WORTHWHILE
TO
CONSIDER
CAREFULLY
THE
DYNAMICS
OF
THE
METHOD
CALLS
SHOWN
IN
THE
TRACE
AT
RIGHT
TO
SORT
A
THE
SORT
METHOD
CALLS
ITSELF
TO
SORT
A
THEN
CALLS
ITSELF
TO
SORT
A
AND
A
BEFORE
FINALLY
DOING
THE
FIRST
MERGE
OF
A
WITH
A
AFTER
CALLING
ITSELF
TO
SORT
A
AND
THEN
A
FOR
BREVITY
WE
OMIT
THE
CALLS
FOR
THE
BASE
CASE
ENTRY
SORTS
IN
THE
TRACE
THEN
THE
NEXT
MERGE
IS
A
WITH
A
AND
THEN
A
WITH
A
AND
SO
FORTH
FROM
THIS
TRACE
WE
SEE
THAT
THE
SORT
CODE
SIMPLY
PROVIDES
AN
ORGA
NIZED
WAY
TO
SEQUENCE
THE
CALLS
TO
THE
MERGE
METHOD
THIS
INSIGHT
WILL
BE
USEFUL
LATER
IN
THIS
SECTION
THE
RECURSIVE
CODE
ALSO
PROVIDES
US
WITH
THE
BASIS
FOR
ANALYZING
MERGESORT
RUNNING
TIME
BECAUSE
MERGESORT
IS
A
PROTOTYPE
OF
THE
DIVIDE
AND
CONQUER
ALGORITHM
DE
SIGN
PARADIGM
WE
WILL
CONSIDER
THIS
ANALYSIS
IN
DETAIL
LEFT
HALF
SORT
RIGHT
HALF
MERGE
RESULTS
SORT
A
SORT
A
MERGE
A
SORT
A
MERGE
A
MERGE
A
SORT
A
SORT
A
MERGE
A
SORT
A
MERGE
A
MERGE
A
MERGE
A
SORT
A
SORT
A
SORT
A
MERGE
A
SORT
A
MERGE
A
MERGE
A
SORT
A
SORT
A
MERGE
A
SORT
A
MERGE
A
MERGE
A
MERGE
A
MERGE
A
TOP
DOWN
MERGESORT
CALL
TRACE
ALGORITHM
TOP
DOWN
MERGESORT
PUBLIC
CLASS
MERGE
PRIVATE
STATIC
COMPARABLE
AUX
AUXILIARY
ARRAY
FOR
MERGES
PUBLIC
STATIC
VOID
SORT
COMPARABLE
A
AUX
NEW
COMPARABLE
A
LENGTH
ALLOCATE
SPACE
JUST
ONCE
SORT
A
A
LENGTH
PRIVATE
STATIC
VOID
SORT
COMPARABLE
A
INT
LO
INT
HI
SORT
A
LO
HI
IF
HI
LO
RETURN
INT
MID
LO
HI
LO
SORT
A
LO
MID
SORT
LEFT
HALF
SORT
A
MID
HI
SORT
RIGHT
HALF
MERGE
A
LO
MID
HI
MERGE
RESULTS
CODE
ON
PAGE
TO
SORT
A
SUBARRAY
A
LO
HI
WE
DIVIDE
IT
INTO
TWO
PARTS
A
LO
MID
AND
A
MID
HI
SORT
THEM
INDEPENDENTLY
VIA
RECURSIVE
CALLS
AND
MERGE
THE
RESULTING
ORDERED
SUBARRAYS
TO
PRODUCE
THE
RESULT
LO
HI
A
M
E
R
G
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
M
R
G
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
G
M
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
G
M
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
G
M
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
G
M
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
E
G
M
O
R
R
T
E
X
A
M
P
L
E
MERGE
A
E
E
G
M
O
R
R
E
T
X
A
M
P
L
E
MERGE
A
E
E
G
M
O
R
R
E
T
A
X
M
P
L
E
MERGE
A
E
E
G
M
O
R
R
A
E
T
X
M
P
L
E
MERGE
A
E
E
G
M
O
R
R
A
E
T
X
M
P
L
E
MERGE
A
E
E
G
M
O
R
R
A
E
T
X
M
P
E
L
MERGE
A
E
E
G
M
O
R
R
A
E
T
X
E
L
M
P
MERGE
A
E
E
G
M
O
R
R
A
E
E
L
M
P
T
X
MERGE
A
A
E
E
E
E
G
L
M
M
O
P
R
R
T
X
TRACE
OF
MERGE
RESULTS
FOR
TOP
DOWN
MERGESORT
TERM
IS
THE
NUMBER
OF
COMPARES
FOR
THE
MERGE
THE
LOWER
BOUND
C
N
C
N
C
N
N
FOLLOWS
BECAUSE
THE
NUMBER
OF
COMPARES
FOR
THE
MERGE
IS
AT
LEAST
N
WE
DERIVE
AN
EXACT
SOLUTION
TO
THE
RECURRENCE
WHEN
EQUALITY
HOLDS
AND
N
IS
A
POWER
OF
SAY
N
FIRST
SINCE
N
N
WE
HAVE
C
DIVIDING
BOTH
SIDES
BY
GIVES
C
C
APPLYING
THE
SAME
EQUATION
TO
THE
FIRST
TERM
ON
THE
RIGHT
WE
HAVE
C
C
REPEATING
THE
PREVIOUS
STEP
N
ADDITIONAL
TIMES
GIVES
C
C
N
WHICH
AFTER
MULTIPLYING
BOTH
SIDES
BY
LEAVES
US
WITH
THE
SOLUTION
C
N
C
N
N
LG
N
EXACT
SOLUTIONS
FOR
GENERAL
N
ARE
MORE
COMPLICATED
BUT
IT
IS
NOT
DIFFICULT
TO
APPLY
THE
SAME
ARGUMENT
TO
THE
INEQUALITIES
DESCRIBING
THE
BOUNDS
ON
THE
NUMBER
OF
COMPARES
TO
PROVE
THE
STATED
RESULT
FOR
ALL
VALUES
OF
N
THIS
PROOF
IS
VALID
NO
MATTER
WHAT
THE
INPUT
VALUES
ARE
AND
NO
MATTER
IN
WHAT
ORDER
THEY
APPEAR
ANOTHER
WAY
TO
UNDERSTAND
PROPOSITION
F
IS
TO
EXAMINE
THE
TREE
DRAWN
BELOW
WHERE
EACH
NODE
DEPICTS
A
SUBARRAY
FOR
WHICH
SORT
DOES
A
MERGE
THE
TREE
HAS
PRECISELY
N
LEVELS
FOR
K
FROM
TO
N
THE
KTH
LEVEL
FROM
THE
TOP
DEPICTS
SUBARRAYS
EACH
OF
LENGTH
K
EACH
OF
WHICH
THUS
REQUIRES
AT
MOST
K
COMPARES
FOR
THE
MERGE
THUS
WE
HAVE
K
TOTAL
COST
FOR
EACH
OF
THE
N
LEVELS
FOR
A
TOTAL
OF
N
N
LGN
MERGESORT
SUBARRAY
DEPENDENCE
TREE
FOR
N
PROPOSITIONS
F
AND
G
TELL
US
THAT
WE
CAN
EXPECT
THE
TIME
REQUIRED
BY
MERGESORT
TO
BE
PROPORTIONAL
TO
N
LOG
N
THAT
FACT
BRINGS
US
TO
A
DIFFERENT
LEVEL
FROM
THE
ELEMENTARY
METHODS
IN
SECTION
BECAUSE
IT
TELLS
US
THAT
WE
CAN
SORT
HUGE
ARRAYS
USING
JUST
A
LOGARITHMIC
FACTOR
MORE
TIME
THAN
IT
TAKES
TO
EXAMINE
EVERY
ENTRY
YOU
CAN
SORT
MILLIONS
OF
ITEMS
OR
MORE
WITH
MERGESORT
BUT
NOT
WITH
INSERTION
SORT
OR
SELECTION
SORT
THE
PRIMARY
DRAWBACK
OF
MERGESORT
IS
THAT
IT
REQUIRES
EXTRA
SPACE
PROPORTIONAL
TO
N
FOR
THE
AUXILIARY
ARRAY
FOR
MERGING
IF
SPACE
IS
AT
A
PREMIUM
WE
NEED
TO
CONSIDER
ANOTHER
METHOD
ON
THE
OTHER
HAND
WE
CAN
CUT
THE
RUNNING
TIME
OF
MERGESORT
SUBSTANTIALLY
WITH
SOME
CAREFULLY
CONSIDERED
MODIFICATIONS
TO
THE
IMPLEMENTATION
USE
INSERTION
SORT
FOR
SMALL
SUBARRAYS
WE
CAN
IMPROVE
MOST
RECURSIVE
ALGORITHMS
BY
HANDLING
SMALL
CASES
DIFFERENTLY
BECAUSE
THE
RECURSION
GUARANTEES
THAT
THE
METHOD
WILL
BE
USED
OFTEN
FOR
SMALL
CASES
SO
IMPROVEMENTS
IN
HANDLING
THEM
LEAD
TO
IMPROVEMENTS
IN
THE
WHOLE
ALGORITHM
IN
THE
CASE
OF
SORTING
WE
KNOW
THAT
INSERTION
SORT
OR
SELECTION
SORT
IS
SIMPLE
AND
THEREFORE
LIKELY
TO
BE
FASTER
THAN
MERGESORT
FOR
TINY
SUBARRAYS
AS
USUAL
A
VISUAL
TRACE
PROVIDES
INSIGHT
INTO
THE
OPERATION
OF
MERGESORT
THE
VISUAL
TRACE
ON
THE
FACING
PAGE
SHOWS
THE
OPERATION
OF
A
MERGESORT
IMPLEMENTATION
WITH
A
CUTOFF
FOR
SMALL
SUBARRAYS
SWITCHING
TO
INSERTION
SORT
FOR
SMALL
SUBARRAYS
LENGTH
OR
LESS
SAY
WILL
IMPROVE
THE
RUNNING
TIME
OF
A
TYPICAL
MERGESORT
IMPLEMENTATION
BY
TO
PERCENT
SEE
EXERCISE
TEST
WHETHER
THE
ARRAY
IS
ALREADY
IN
ORDER
WE
CAN
REDUCE
THE
RUNNING
TIME
TO
BE
LINEAR
FOR
ARRAYS
THAT
ARE
ALREADY
IN
ORDER
BY
ADDING
A
TEST
TO
SKIP
THE
CALL
TO
MERGE
IF
A
MID
IS
LESS
THAN
OR
EQUAL
TO
A
MID
WITH
THIS
CHANGE
WE
STILL
DO
ALL
THE
RECURSIVE
CALLS
BUT
THE
RUNNING
TIME
FOR
ANY
SORTED
SUBARRAY
IS
LINEAR
SEE
EXERCISE
ELIMINATE
THE
COPY
TO
THE
AUXILIARY
ARRAY
IT
IS
POSSIBLE
TO
ELIMINATE
THE
TIME
BUT
NOT
THE
SPACE
TAKEN
TO
COPY
TO
THE
AUXILIARY
ARRAY
USED
FOR
MERGING
TO
DO
SO
WE
USE
TWO
INVOCATIONS
OF
THE
SORT
METHOD
ONE
TAKES
ITS
INPUT
FROM
THE
GIVEN
ARRAY
AND
PUTS
THE
SORTED
OUTPUT
IN
THE
AUXILIARY
ARRAY
THE
OTHER
TAKES
ITS
INPUT
FROM
THE
AUXILIARY
ARRAY
AND
PUTS
THE
SORTED
OUTPUT
IN
THE
GIVEN
ARRAY
WITH
THIS
APPROACH
IN
A
BIT
OF
RECURSIVE
TRICKERY
WE
CAN
ARRANGE
THE
RECURSIVE
CALLS
SUCH
THAT
THE
COMPUTATION
SWITCHES
THE
ROLES
OF
THE
INPUT
ARRAY
AND
THE
AUXILIARY
ARRAY
AT
EACH
LEVEL
SEE
EXERCISE
FIRST
SUBARRAY
SECOND
SUBARRAY
FIRST
MERGE
FIRST
HALF
SORTED
L
I
I
II
L
II
I
I
I
I
I
II
IIIII
I
IIII
II
I
II
I
I
IIIII
I
I
L
II
L
I
I
I
II
II
I
II
II
I
II
I
I
I
II
II
I
II
II
I
I
I
I
II
IIIII
I
IIII
II
I
I
I
III
I
I
I
I
LL
L
L
L
I
I
I
I
SECOND
HALF
SORTED
RESULT
LLLLLL
L
L
L
L
II
II
II
II
II
IIIIILIL
I
II
I
IIL
O
O
I
I
I
I
I
I
I
I
I
I
I
I
II
II
I
I
I
I
I
I
I
I
I
I
IIII
VISUAL
TRACE
OF
TOP
DOWN
MERGESORT
WITH
CUTOFF
FOR
SMALL
SUBARRAYS
IT
IS
APPROPRIATE
TO
REPEAT
HERE
A
POINT
RAISED
IN
CHAPTER
THAT
IS
EASILY
FORGOTTEN
AND
NEEDS
REEMPHASIS
LOCALLY
WE
TREAT
EACH
ALGORITHM
IN
THIS
BOOK
AS
IF
IT
WERE
CRITICAL
IN
SOME
APPLICATION
GLOBALLY
WE
TRY
TO
REACH
GENERAL
CONCLUSIONS
ABOUT
WHICH
APPROACH
TO
RECOMMEND
OUR
DISCUSSION
OF
SUCH
IMPROVEMENTS
IS
NOT
NECESSARILY
A
RECOMMEN
DATION
TO
ALWAYS
IMPLEMENT
THEM
RATHER
A
WARNING
NOT
TO
DRAW
ABSOLUTE
CONCLUSIONS
ABOUT
PERFORMANCE
FROM
INITIAL
IMPLEMENTATIONS
WHEN
ADDRESSING
A
NEW
PROBLEM
YOUR
BEST
BET
IS
TO
USE
THE
SIMPLEST
IMPLEMENTATION
WITH
WHICH
YOU
ARE
COMFORTABLE
AND
THEN
REFINE
IT
IF
IT
BECOMES
A
BOTTLENECK
ADDRESSING
IMPROVEMENTS
THAT
DECREASE
RUNNING
TIME
JUST
BY
A
CONSTANT
FACTOR
MAY
NOT
OTHERWISE
BE
WORTHWHILE
YOU
NEED
TO
TEST
THE
EFFECTIVENESS
OF
SPECIFIC
IMPROVEMENTS
BY
RUNNING
EXPERIMENTS
AS
WE
INDICATE
IN
EXERCISES
THROUGHOUT
IN
THE
CASE
OF
MERGESORT
THE
THREE
IMPROVEMENTS
JUST
LISTED
ARE
SIMPLE
TO
IMPLEMENT
AND
ARE
OF
INTEREST
WHEN
MERGESORT
IS
THE
METHOD
OF
CHOICE
FOR
EXAMPLE
IN
SITUATIONS
DISCUSSED
AT
THE
END
OF
THIS
CHAPTER
BOTTOM
UP
MERGESORT
THE
RECURSIVE
IMPLEMENTATION
OF
MERGESORT
IS
PROTOTYPI
CAL
OF
THE
DIVIDE
AND
CONQUER
ALGORITHM
DESIGN
PARADIGM
WHERE
WE
SOLVE
A
LARGE
PROB
LEM
BY
DIVIDING
IT
INTO
PIECES
SOLVING
THE
SUBPROBLEMS
THEN
USING
THE
SOLUTIONS
FOR
THE
PIECES
TO
SOLVE
THE
WHOLE
PROBLEM
EVEN
THOUGH
WE
ARE
THINKING
IN
TERMS
OF
MERGING
TOGETHER
TWO
LARGE
SUBARRAYS
THE
FACT
IS
THAT
MOST
MERGES
ARE
MERGING
TOGETHER
TINY
SUBARRAYS
ANOTHER
WAY
TO
IMPLEMENT
MERGESORT
IS
TO
ORGANIZE
THE
MERGES
SO
THAT
WE
DO
ALL
THE
MERGES
OF
TINY
SUBARRAYS
ON
ONE
PASS
THEN
DO
A
SECOND
PASS
TO
MERGE
THOSE
SUB
ARRAYS
IN
PAIRS
AND
SO
FORTH
CONTINUING
UNTIL
WE
DO
A
MERGE
THAT
ENCOMPASSES
THE
WHOLE
ARRAY
THIS
METHOD
REQUIRES
EVEN
LESS
CODE
THAN
THE
STANDARD
RECURSIVE
IMPLEMENTATION
WE
START
BY
DOING
A
PASS
OF
BY
MERGES
CONSIDERING
INDIVIDUAL
ITEMS
AS
SUBARRAYS
OF
SIZE
THEN
A
PASS
OF
BY
MERGES
MERGE
SUBARRAYS
OF
SIZE
TO
MAKE
SUBARRAYS
OF
SIZE
THEN
BY
MERGES
AND
SO
FORTH
THE
SEC
OND
SUBARRAY
MAY
BE
SMALLER
THAN
THE
FIRST
IN
THE
LAST
MERGE
ON
EACH
PASS
WHICH
IS
NO
PROBLEM
FOR
MERGE
BUT
OTHERWISE
ALL
MERGES
INVOLVE
SUBAR
RAYS
OF
EQUAL
SIZE
DOUBLING
THE
SORTED
SUBARRAY
SIZE
FOR
THE
NEXT
PASS
SZ
VISUAL
TRACE
OF
BOTTOM
UP
MERGESORT
BOTTOM
UP
MERGESORT
PUBLIC
CLASS
MERGEBU
PRIVATE
STATIC
COMPARABLE
AUX
AUXILIARY
ARRAY
FOR
MERGES
SEE
PAGE
FOR
MERGE
CODE
PUBLIC
STATIC
VOID
SORT
COMPARABLE
A
DO
LG
N
PASSES
OF
PAIRWISE
MERGES
INT
N
A
LENGTH
AUX
NEW
COMPARABLE
N
FOR
INT
SZ
SZ
N
SZ
SZ
SZ
SZ
SUBARRAY
SIZE
FOR
INT
LO
LO
N
SZ
LO
SZ
SZ
LO
SUBARRAY
INDEX
MERGE
A
LO
LO
SZ
MATH
MIN
LO
SZ
SZ
N
BOTTOM
UP
MERGESORT
CONSISTS
OF
A
SEQUENCE
OF
PASSES
OVER
THE
WHOLE
ARRAY
DOING
SZ
BY
SZ
MERGES
STARTING
WITH
SZ
EQUAL
TO
AND
DOUBLING
SZ
ON
EACH
PASS
THE
FINAL
SUBARRAY
IS
OF
SIZE
SZ
ONLY
WHEN
THE
ARRAY
SIZE
IS
AN
EVEN
MULTIPLE
OF
SZ
OTHERWISE
IT
IS
LESS
THAN
SZ
A
I
SZ
M
E
R
G
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
M
R
G
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
T
E
X
A
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
E
T
X
A
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
E
T
A
X
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
E
T
A
X
M
P
L
E
MERGE
A
E
M
G
R
E
O
R
E
T
A
X
M
P
E
L
SZ
MERGE
A
E
G
M
R
E
O
R
E
T
A
X
M
P
E
L
MERGE
A
E
G
M
R
E
O
R
E
T
A
X
M
P
E
L
MERGE
A
E
G
M
R
E
O
R
A
E
T
X
M
P
E
L
MERGE
A
E
G
M
R
E
O
R
A
E
T
X
E
L
M
P
SZ
MERGE
A
E
E
G
M
O
R
R
A
E
T
X
E
L
M
P
MERGE
A
E
E
G
M
O
R
R
A
E
E
L
M
P
T
X
SZ
MERGE
A
A
E
E
E
E
G
L
M
M
O
P
R
R
T
X
TRACE
OF
MERGE
RESULTS
FOR
BOTTOM
UP
MERGESORT
WHEN
THE
ARRAY
LENGTH
IS
A
POWER
OF
TOP
DOWN
AND
BOTTOM
UP
MERGESORT
PER
FORM
PRECISELY
THE
SAME
COMPARES
AND
ARRAY
ACCESSES
JUST
IN
A
DIFFERENT
ORDER
WHEN
THE
ARRAY
LENGTH
IS
NOT
A
POWER
OF
THE
SEQUENCE
OF
COMPARES
AND
ARRAY
ACCESSES
FOR
THE
TWO
ALGORITHMS
WILL
BE
DIFFERENT
SEE
EXERCISE
A
VERSION
OF
BOTTOM
UP
MERGESORT
IS
THE
METHOD
OF
CHOICE
FOR
SORTING
DATA
ORGA
NIZED
IN
A
LINKED
LIST
CONSIDER
THE
LIST
TO
BE
SORTED
SUBLISTS
OF
SIZE
THEN
PASS
THROUGH
TO
MAKE
SORTED
SUBARRAYS
OF
SIZE
LINKED
TOGETHER
THEN
SIZE
AND
SO
FORTH
THIS
METHOD
REARRANGES
THE
LINKS
TO
SORT
THE
LIST
IN
PLACE
WITHOUT
CREATING
ANY
NEW
LIST
NODES
BOTH
THE
TOP
DOWN
AND
BOTTOM
UP
APPROACHES
TO
IMPLEMENTING
A
DIVIDE
AND
CONQUER
ALGORITHM
ARE
INTUITIVE
THE
LESSON
THAT
YOU
CAN
TAKE
FROM
MERGESORT
IS
THIS
WHENEVER
YOU
ENCOUNTER
AN
ALGORITHM
BASED
ON
ONE
OF
THESE
APPROACHES
IT
IS
WORTH
CONSIDERING
THE
OTHER
DO
YOU
WANT
TO
SOLVE
THE
PROBLEM
BY
BREAKING
IT
UP
INTO
SMALLER
PROBLEMS
AND
SOLVING
THEM
RECURSIVELY
AS
IN
MERGE
SORT
OR
BY
BUILDING
SMALL
SOLU
TIONS
INTO
LARGER
ONES
AS
IN
MERGEBU
SORT
THE
COMPLEXITY
OF
SORTING
ONE
IMPORTANT
REASON
TO
KNOW
ABOUT
MERGESORT
IS
THAT
WE
USE
IT
AS
THE
BASIS
FOR
PROVING
A
FUNDAMENTAL
RESULT
IN
THE
FIELD
OF
COMPUTATIONAL
COMPLEXITY
THAT
HELPS
US
UNDERSTAND
THE
INTRINSIC
DIFFICULTY
OF
SORTING
IN
GENERAL
COM
PUTATIONAL
COMPLEXITY
PLAYS
AN
IMPORTANT
ROLE
IN
THE
DESIGN
OF
ALGORITHMS
AND
THIS
RESULT
IN
PARTICULAR
IS
DIRECTLY
RELEVANT
TO
THE
DESIGN
OF
SORTING
ALGORITHMS
SO
WE
NEXT
CONSIDER
IT
IN
DETAIL
THE
FIRST
STEP
IN
A
STUDY
OF
COMPLEXITY
IS
TO
ESTABLISH
A
MODEL
OF
COMPUTATION
GEN
ERALLY
RESEARCHERS
STRIVE
TO
UNDERSTAND
THE
SIMPLEST
MODEL
RELEVANT
TO
A
PROBLEM
FOR
SORTING
WE
STUDY
THE
CLASS
OF
COMPARE
BASED
ALGORITHMS
THAT
MAKE
THEIR
DECISIONS
ABOUT
ITEMS
ONLY
ON
THE
BASIS
OF
COMPARING
KEYS
A
COMPARE
BASED
ALGORITHM
CAN
DO
AN
AR
BITRARY
AMOUNT
OF
COMPUTATION
BETWEEN
COMPARES
BUT
CANNOT
GET
ANY
INFORMATION
ABOUT
A
KEY
EXCEPT
BY
COMPARING
IT
WITH
ANOTHER
ONE
BECAUSE
OF
OUR
RESTRICTION
TO
THE
COMPARABLE
API
ALL
OF
THE
ALGORITHMS
IN
THIS
CHAPTER
ARE
IN
THIS
CLASS
NOTE
THAT
WE
ARE
IGNORING
THE
COST
OF
ARRAY
ACCESSES
AS
ARE
MANY
ALGORITHMS
THAT
WE
MIGHT
IMAGINE
IN
CHAPTER
WE
CONSIDER
ALGORITHMS
THAT
ARE
NOT
RESTRICTED
TO
COMPARABLE
ITEMS
PROPOSITION
I
NO
COMPARE
BASED
SORTING
ALGORITHM
CAN
GUARANTEE
TO
SORT
N
ITEMS
WITH
FEWER
THAN
LG
N
N
LG
N
COMPARES
PROOF
FIRST
WE
ASSUME
THAT
THE
KEYS
ARE
ALL
DISTINCT
SINCE
ANY
ALGORITHM
MUST
BE
ABLE
TO
SORT
SUCH
INPUTS
NOW
WE
USE
A
BINARY
TREE
TO
DESCRIBE
THE
SEQUENCE
OF
COM
PARES
EACH
NODE
IN
THE
TREE
IS
EITHER
A
LEAF
IN
THAT
INDICATES
THAT
THE
SORT
IS
COMPLETE
AND
HAS
DISCOVERED
THAT
THE
ORIGINAL
INPUTS
WERE
IN
THE
ORDER
A
A
A
IN
OR
AN
INTERNAL
NODE
I
J
THAT
CORRESPONDS
TO
A
COM
PARE
OPERATION
BETWEEN
A
I
AND
A
J
WITH
A
LEFT
SUBTREE
CORRESPONDING
TO
THE
SEQUENCE
OF
COMPARES
IN
THE
CASE
THAT
A
I
IS
LESS
THAN
A
J
AND
A
RIGHT
SUBTREE
CORRESPONDING
TO
WHAT
HAPPENS
IF
A
I
IS
GREATER
THAN
A
J
EACH
PATH
FROM
THE
ROOT
TO
A
LEAF
CORRESPONDS
TO
THE
SEQUENCE
OF
COMPARES
THAT
THE
ALGORITHM
USES
TO
ESTABLISH
THE
ORDERING
GIVEN
IN
THE
LEAF
FOR
EXAMPLE
HERE
IS
A
COMPARE
TREE
FOR
N
WE
NEVER
EXPLICITLY
CONSTRUCT
SUCH
A
TREE
IT
IS
A
MATHEMATICAL
DEVICE
FOR
DESCRIB
ING
THE
COMPARES
USED
BY
ANY
ALGORITHM
THE
FIRST
KEY
OBSERVATION
IN
THE
PROOF
IS
THAT
THE
TREE
MUST
HAVE
AT
LEAST
N
LEAVES
BECAUSE
THERE
ARE
N
DIFFERENT
PERMUTATIONS
OF
N
DISTINCT
KEYS
IF
THERE
ARE
FEWER
THAN
N
LEAVES
THEN
SOME
PERMUTATION
IS
MISSING
FROM
THE
LEAVES
AND
THE
ALGO
RITHM
WOULD
FAIL
FOR
THAT
PERMUTATION
THE
NUMBER
OF
INTERNAL
NODES
ON
A
PATH
FROM
THE
ROOT
TO
A
LEAF
IN
THE
TREE
IS
THE
NUMBER
OF
COMPARES
USED
BY
THE
ALGORITHM
FOR
SOME
INPUT
WE
ARE
INTERESTED
IN
THE
LENGTH
OF
THE
LONGEST
SUCH
PATH
IN
THE
TREE
KNOWN
AS
THE
TREE
HEIGHT
SINCE
IT
MEA
SURES
THE
WORST
CASE
NUMBER
OF
COMPARES
USED
BY
THE
ALGORITHM
NOW
IT
IS
A
BASIC
COMBINATORIAL
PROPERTY
OF
BINARY
TREES
THAT
A
TREE
OF
HEIGHT
H
HAS
NO
MORE
THAN
LEAVES
THE
TREE
OF
HEIGHT
H
WITH
THE
MAXIMUM
NUMBER
OF
LEAVES
IS
PERFECTLY
BAL
ANCED
OR
COMPLETE
AN
EXAMPLE
FOR
H
IS
DIAGRAMMED
ON
THE
NEXT
PAGE
THIS
RESULT
SERVES
AS
A
GUIDE
FOR
US
TO
KNOW
WHEN
DESIGNING
A
SORTING
ALGORITHM
HOW
WELL
WE
CAN
EXPECT
TO
DO
FOR
EXAMPLE
WITHOUT
SUCH
A
RESULT
ONE
MIGHT
SET
OUT
TO
TRY
TO
DESIGN
A
COMPARE
BASED
SORTING
ALGORITHM
THAT
USES
HALF
AS
MANY
COMPARES
AS
DOES
MERGESORT
IN
THE
WORST
CASE
THE
LOWER
BOUND
IN
PROPOSITION
I
SAYS
THAT
SUCH
AN
EFFORT
IS
FUTILE
NO
SUCH
ALGORITHM
EXISTS
IT
IS
AN
EXTREMELY
STRONG
STATEMENT
THAT
APPLIES
TO
ANY
CONCEIVABLE
COMPARE
BASED
ALGORITHM
PROPOSITION
H
ASSERTS
THAT
THE
NUMBER
OF
COMPARES
USED
BY
MERGESORT
IN
THE
WORST
CASE
IS
N
LG
N
THIS
RESULT
IS
AN
UPPER
BOUND
ON
THE
DIFFICULTY
OF
THE
SORTING
PROBLEM
IN
THE
SENSE
THAT
A
BETTER
ALGORITHM
WOULD
HAVE
TO
GUARANTEE
TO
USE
A
SMALLER
NUMBER
OF
COMPARES
PROPOSITION
I
ASSERTS
THAT
NO
SORTING
ALGORITHM
CAN
GUARANTEE
TO
USE
FEWER
THAN
N
LG
N
COMPARES
IT
IS
A
LOWER
BOUND
ON
THE
DIFFICULTY
OF
THE
SORTING
PROBLEM
IN
THE
SENSE
THAT
EVEN
THE
BEST
POSSIBLE
ALGORITHM
MUST
USE
AT
LEAST
THAT
MANY
COMPARES
IN
THE
WORST
CASE
TOGETHER
THEY
IMPLY
IT
IS
IMPORTANT
TO
NOTE
THAT
LIKE
THE
MODEL
OF
COMPUTATION
WE
NEED
TO
PRECISELY
DEFINE
WHAT
WE
MEAN
BY
AN
OPTIMAL
ALGORITHM
FOR
EXAMPLE
WE
MIGHT
TIGHTEN
THE
DEFINITION
OF
OPTIMALITY
AND
INSIST
THAT
AN
OPTIMAL
ALGORITHM
FOR
SORTING
IS
ONE
THAT
USES
PRECISELY
LG
N
COMPARES
WE
DO
NOT
DO
SO
BECAUSE
WE
COULD
NOT
NOTICE
THE
DIFFERENCE
BETWEEN
SUCH
AN
ALGORITHM
AND
FOR
EXAMPLE
MERGESORT
FOR
LARGE
N
OR
WE
MIGHT
BROADEN
THE
DEFINITION
OF
OPTIMALITY
TO
INCLUDE
ANY
SORTING
ALGORITHM
WHOSE
WORST
CASE
NUMBER
OF
COMPARES
IS
WITHIN
A
CONSTANT
FACTOR
OF
N
LG
N
WE
DO
NOT
DO
SO
BECAUSE
WE
MIGHT
VERY
WELL
NOTICE
THE
DIFFERENCE
BETWEEN
SUCH
AN
ALGORITHM
AND
MERGESORT
FOR
LARGE
N
COMPUTATIONAL
COMPLEXITY
MAY
SEEM
RATHER
ABSTRACT
BUT
FUNDAMENTAL
RE
SEARCH
ON
THE
INTRINSIC
DIFFICULTY
OF
SOLVING
COMPUTATIONAL
PROBLEMS
HARDLY
NEEDS
JUS
TIFICATION
MOREOVER
WHEN
IT
DOES
APPLY
IT
IS
EMPHATICALLY
THE
CASE
THAT
COMPUTATIONAL
COMPLEXITY
AFFECTS
THE
DEVELOPMENT
OF
GOOD
SOFTWARE
FIRST
GOOD
UPPER
BOUNDS
ALLOW
SOFTWARE
ENGINEERS
TO
PROVIDE
PERFORMANCE
GUARANTEES
THERE
ARE
MANY
DOCUMENTED
INSTANCES
WHERE
POOR
PERFORMANCE
HAS
BEEN
TRACED
TO
SOMEONE
USING
A
QUADRATIC
SORT
INSTEAD
OF
A
LINEARITHMIC
ONE
SECOND
GOOD
LOWER
BOUNDS
SPARE
US
THE
EFFORT
OF
SEARCH
ING
FOR
PERFORMANCE
IMPROVEMENTS
THAT
ARE
NOT
ATTAINABLE
BUT
THE
OPTIMALITY
OF
MERGESORT
IS
NOT
THE
END
OF
THE
STORY
AND
SHOULD
NOT
BE
MIS
USED
TO
INDICATE
THAT
WE
NEED
NOT
CONSIDER
OTHER
METHODS
FOR
PRACTICAL
APPLICATIONS
THAT
IS
NOT
THE
CASE
BECAUSE
THE
THEORY
IN
THIS
SECTION
HAS
A
NUMBER
OF
LIMITATIONS
FOR
EXAMPLE
MERGESORT
IS
NOT
OPTIMAL
WITH
RESPECT
TO
SPACE
USAGE
THE
WORST
CASE
MAY
NOT
BE
LIKELY
IN
PRACTICE
OPERATIONS
OTHER
THAN
COMPARES
SUCH
AS
ARRAY
ACCESSES
MAY
BE
IMPORTANT
ONE
CAN
SORT
CERTAIN
DATA
WITHOUT
USING
ANY
COMPARES
THUS
WE
SHALL
BE
CONSIDERING
SEVERAL
OTHER
SORTING
METHODS
IN
THIS
BOOK
Q
IS
MERGESORT
FASTER
THAN
SHELLSORT
A
IN
PRACTICE
THEIR
RUNNING
TIMES
ARE
WITHIN
A
SMALL
CONSTANT
FACTOR
OF
ONE
ANOTHER
WHEN
SHELLSORT
IS
USING
A
WELL
TESTED
INCREMENT
SEQUENCE
LIKE
THE
ONE
IN
ALGORITHM
SO
COMPARATIVE
PERFORMANCE
DEPENDS
ON
THE
IMPLEMENTATIONS
JAVA
SORTCOMPARE
MERGE
SHELL
FOR
RANDOM
DOUBLE
VALUES
MERGE
IS
TIMES
FASTER
THAN
SHELL
IN
THEORY
NO
ONE
HAS
BEEN
ABLE
TO
PROVE
THAT
SHELLSORT
IS
LINEARITHMIC
FOR
RANDOM
DATA
SO
THERE
REMAINS
THE
POSSIBILITY
THAT
THE
ASYMPTOTIC
GROWTH
OF
THE
AVERAGE
CASE
PERFOR
MANCE
OF
SHELLSORT
IS
HIGHER
SUCH
A
GAP
HAS
BEEN
PROVEN
FOR
WORST
CASE
PERFORMANCE
BUT
IT
IS
NOT
RELEVANT
IN
PRACTICE
Q
WHY
NOT
MAKE
THE
AUX
ARRAY
LOCAL
TO
MERGE
A
TO
AVOID
THE
OVERHEAD
OF
CREATING
AN
ARRAY
FOR
EVERY
MERGE
EVEN
THE
TINY
ONES
THIS
COST
WOULD
DOMINATE
THE
RUNNING
TIME
OF
MERGESORT
SEE
EXERCISE
A
MORE
PROPER
SOLUTION
WHICH
WE
AVOID
IN
THE
TEXT
TO
REDUCE
CLUTTER
IN
THE
CODE
IS
TO
MAKE
AUX
LOCAL
TO
SORT
AND
PASS
IT
AS
AN
ARGUMENT
TO
MERGE
SEE
EXERCISE
Q
HOW
DOES
MERGESORT
FARE
WHEN
THERE
ARE
DUPLICATE
VALUES
IN
THE
ARRAY
A
IF
ALL
THE
ITEMS
HAVE
THE
SAME
VALUE
THE
RUNNING
TIME
IS
LINEAR
WITH
THE
EXTRA
TEST
TO
SKIP
THE
MERGE
WHEN
THE
ARRAY
IS
SORTED
BUT
IF
THERE
IS
MORE
THAN
ONE
DUPLICATE
VALUE
THIS
PERFORMANCE
GAIN
IS
NOT
NECESSARILY
REALIZED
FOR
EXAMPLE
SUPPOSE
THAT
THE
INPUT
ARRAY
CONSISTS
OF
N
ITEMS
WITH
ONE
VALUE
IN
ODD
POSITIONS
AND
N
ITEMS
WITH
ANOTHER
VALUE
IN
EVEN
POSITIONS
THE
RUNNING
TIME
IS
LINEARITHMIC
FOR
SUCH
AN
ARRAY
IT
SATISFIES
THE
SAME
RECURRENCE
AS
FOR
ITEMS
WITH
DISTINCT
VALUES
NOT
LINEAR
GIVE
A
TRACE
IN
THE
STYLE
OF
THE
TRACE
GIVEN
AT
THE
BEGINNING
OF
THIS
SECTION
SHOW
ING
HOW
THE
KEYS
A
E
Q
U
Y
E
I
N
O
T
ARE
MERGED
WITH
THE
ABSTRACT
IN
PLACE
MERGE
METHOD
GIVE
TRACES
IN
THE
STYLE
OF
THE
TRACE
GIVEN
WITH
ALGORITHM
SHOWING
HOW
THE
KEYS
E
A
Y
Q
U
E
T
I
O
N
ARE
SORTED
WITH
TOP
DOWN
MERGESORT
ANSWER
EXERCISE
FOR
BOTTOM
UP
MERGESORT
DOES
THE
ABSTRACT
IN
PLACE
MERGE
PRODUCE
PROPER
OUTPUT
IF
AND
ONLY
IF
THE
TWO
INPUT
SUBARRAYS
ARE
IN
SORTED
ORDER
PROVE
YOUR
ANSWER
OR
PROVIDE
A
COUNTEREXAMPLE
GIVE
THE
SEQUENCE
OF
SUBARRAY
SIZES
IN
THE
MERGES
PERFORMED
BY
BOTH
THE
TOP
DOWN
AND
THE
BOTTOM
UP
MERGESORT
ALGORITHMS
FOR
N
WRITE
A
PROGRAM
TO
COMPUTE
THE
EXACT
VALUE
OF
THE
NUMBER
OF
ARRAY
ACCESSES
USED
BY
TOP
DOWN
MERGESORT
AND
BY
BOTTOM
UP
MERGESORT
USE
YOUR
PROGRAM
TO
PLOT
THE
VAL
UES
FOR
N
FROM
TO
AND
TO
COMPARE
THE
EXACT
VALUES
WITH
THE
UPPER
BOUND
LG
N
SHOW
THAT
THE
NUMBER
OF
COMPARES
USED
BY
MERGESORT
IS
MONOTONICALLY
INCREAS
ING
C
N
C
N
FOR
ALL
N
SUPPOSE
THAT
ALGORITHM
IS
MODIFIED
TO
SKIP
THE
CALL
ON
MERGE
WHENEVER
A
MID
A
MID
PROVE
THAT
THE
NUMBER
OF
COMPARES
USED
TO
MERGESORT
A
SORTED
ARRAY
IS
LINEAR
USE
OF
A
STATIC
ARRAY
LIKE
AUX
IS
INADVISABLE
IN
LIBRARY
SOFTWARE
BECAUSE
MULTIPLE
CLIENTS
MIGHT
USE
THE
CLASS
CONCURRENTLY
GIVE
AN
IMPLEMENTATION
OF
MERGE
THAT
DOES
NOT
USE
A
STATIC
ARRAY
DO
NOT
MAKE
AUX
LOCAL
TO
MERGE
SEE
THE
Q
A
FOR
THIS
SECTION
HINT
PASS
THE
AUXILIARY
ARRAY
AS
AN
ARGUMENT
TO
THE
RECURSIVE
SORT
FASTER
MERGE
IMPLEMENT
A
VERSION
OF
MERGE
THAT
COPIES
THE
SECOND
HALF
OF
A
TO
AUX
IN
DECREASING
ORDER
AND
THEN
DOES
THE
MERGE
BACK
TO
A
THIS
CHANGE
AL
LOWS
YOU
TO
REMOVE
THE
CODE
TO
TEST
THAT
EACH
OF
THE
HALVES
HAS
BEEN
EXHAUSTED
FROM
THE
INNER
LOOP
NOTE
THE
RESULTING
SORT
IS
NOT
STABLE
SEE
PAGE
IMPROVEMENTS
IMPLEMENT
THE
THREE
IMPROVEMENTS
TO
MERGESORT
THAT
ARE
DE
SCRIBED
IN
THE
TEXT
ON
PAGE
ADD
A
CUTOFF
FOR
SMALL
SUBARRAYS
TEST
WHETHER
THE
ARRAY
IS
ALREADY
IN
ORDER
AND
AVOID
THE
COPY
BY
SWITCHING
ARGUMENTS
IN
THE
RECURSIVE
CODE
SUBLINEAR
EXTRA
SPACE
DEVELOP
A
MERGE
IMPLEMENTATION
THAT
REDUCES
THE
EXTRA
SPACE
REQUIREMENT
TO
MAX
M
N
M
BASED
ON
THE
FOLLOWING
IDEA
DIVIDE
THE
ARRAY
INTO
N
M
BLOCKS
OF
SIZE
M
FOR
SIMPLICITY
IN
THIS
DESCRIPTION
ASSUME
THAT
N
IS
A
MULTIPLE
OF
M
THEN
I
CONSIDERING
THE
BLOCKS
AS
ITEMS
WITH
THEIR
FIRST
KEY
AS
THE
SORT
KEY
SORT
THEM
USING
SELECTION
SORT
AND
II
RUN
THROUGH
THE
ARRAY
MERGING
THE
FIRST
BLOCK
WITH
THE
SECOND
THEN
THE
SECOND
BLOCK
WITH
THE
THIRD
AND
SO
FORTH
LOWER
BOUND
FOR
AVERAGE
CASE
PROVE
THAT
THE
EXPECTED
NUMBER
OF
COMPARES
USED
BY
ANY
COMPARE
BASED
SORTING
ALGORITHM
MUST
BE
AT
LEAST
N
LG
N
ASSUMING
THAT
ALL
POSSIBLE
ORDERINGS
OF
THE
INPUT
ARE
EQUALLY
LIKELY
HINT
THE
EXPECTED
NUMBER
OF
COM
PARES
IS
AT
LEAST
THE
EXTERNAL
PATH
LENGTH
OF
THE
COMPARE
TREE
THE
SUM
OF
THE
LENGTHS
OF
THE
PATHS
FROM
THE
ROOT
TO
ALL
LEAVES
WHICH
IS
MINIMIZED
WHEN
IT
IS
BALANCED
MERGING
SORTED
QUEUES
DEVELOP
A
STATIC
METHOD
THAT
TAKES
TWO
QUEUES
OF
SORTED
ITEMS
AS
ARGUMENTS
AND
RETURNS
A
QUEUE
THAT
RESULTS
FROM
MERGING
THE
QUEUES
INTO
SORTED
ORDER
BOTTOM
UP
QUEUE
MERGESORT
DEVELOP
A
BOTTOM
UP
MERGESORT
IMPLEMENTATION
BASED
ON
THE
FOLLOWING
APPROACH
GIVEN
N
ITEMS
CREATE
N
QUEUES
EACH
CONTAINING
ONE
OF
THE
ITEMS
CREATE
A
QUEUE
OF
THE
N
QUEUES
THEN
REPEATEDLY
APPLY
THE
MERGING
OPERA
TION
OF
EXERCISE
TO
THE
FIRST
TWO
QUEUES
AND
REINSERT
THE
MERGED
QUEUE
AT
THE
END
REPEAT
UNTIL
THE
QUEUE
OF
QUEUES
CONTAINS
ONLY
ONE
QUEUE
NATURAL
MERGESORT
WRITE
A
VERSION
OF
BOTTOM
UP
MERGESORT
THAT
TAKES
ADVAN
TAGE
OF
ORDER
IN
THE
ARRAY
BY
PROCEEDING
AS
FOLLOWS
EACH
TIME
IT
NEEDS
TO
FIND
TWO
ARRAYS
TO
MERGE
FIND
A
SORTED
SUBARRAY
BY
INCREMENTING
A
POINTER
UNTIL
FINDING
AN
ENTRY
THAT
IS
SMALLER
THAN
ITS
PREDECESSOR
IN
THE
ARRAY
THEN
FIND
THE
NEXT
THEN
MERGE
THEM
ANA
LYZE
THE
RUNNING
TIME
OF
THIS
ALGORITHM
IN
TERMS
OF
THE
ARRAY
SIZE
AND
THE
NUMBER
OF
CREATIVE
PROBLEMS
CONTINUED
MAXIMAL
INCREASING
SEQUENCES
IN
THE
ARRAY
LINKED
LIST
SORT
IMPLEMENT
A
NATURAL
MERGESORT
FOR
LINKED
LISTS
THIS
IS
THE
METHOD
OF
CHOICE
FOR
SORTING
LINKED
LISTS
BECAUSE
IT
USES
NO
EXTRA
SPACE
AND
IS
GUARANTEED
TO
BE
LINEARITHMIC
SHUFFLING
A
LINKED
LIST
DEVELOP
AND
IMPLEMENT
A
DIVIDE
AND
CONQUER
ALGO
RITHM
THAT
RANDOMLY
SHUFFLES
A
LINKED
LIST
IN
LINEARITHMIC
TIME
AND
LOGARITHMIC
EXTRA
SPACE
INVERSIONS
DEVELOP
AND
IMPLEMENT
A
LINEARITHMIC
ALGORITHM
FOR
COMPUTING
THE
NUMBER
OF
INVERSIONS
IN
A
GIVEN
ARRAY
THE
NUMBER
OF
EXCHANGES
THAT
WOULD
BE
PERFORMED
BY
INSERTION
SORT
FOR
THAT
ARRAY
SEE
SECTION
THIS
QUANTITY
IS
RELATED
TO
THE
KENDALL
TAU
DISTANCE
SEE
SECTION
INDIRECT
SORT
DEVELOP
AND
IMPLEMENT
A
VERSION
OF
MERGESORT
THAT
DOES
NOT
RE
ARRANGE
THE
ARRAY
BUT
RETURNS
AN
INT
ARRAY
PERM
SUCH
THAT
PERM
I
IS
THE
INDEX
OF
THE
I
TH
SMALLEST
ENTRY
IN
THE
ARRAY
TRIPLICATES
GIVEN
THREE
LISTS
OF
N
NAMES
EACH
DEVISE
A
LINEARITHMIC
ALGORITHM
TO
DETERMINE
IF
THERE
IS
ANY
NAME
COMMON
TO
ALL
THREE
LISTS
AND
IF
SO
RETURN
THE
FIRST
SUCH
NAME
WAY
MERGESORT
SUPPOSE
INSTEAD
OF
DIVIDING
IN
HALF
AT
EACH
STEP
YOU
DIVIDE
INTO
THIRDS
SORT
EACH
THIRD
AND
COMBINE
USING
A
WAY
MERGE
WHAT
IS
THE
ORDER
OF
GROWTH
OF
THE
OVERALL
RUNNING
TIME
OF
THIS
ALGORITHM
IMPROVEMENTS
RUN
EMPIRICAL
STUDIES
TO
EVALUATE
THE
EFFECTIVENESS
OF
EACH
OF
THE
THREE
IMPROVEMENTS
TO
MERGESORT
THAT
ARE
DESCRIBED
IN
THE
TEXT
SEE
EXERCISE
ALSO
COMPARE
THE
PERFORMANCE
OF
THE
MERGE
IMPLEMENTATION
GIVEN
IN
THE
TEXT
WITH
THE
MERGE
DESCRIBED
IN
EXERCISE
IN
PARTICULAR
EMPIRICALLY
DETERMINE
THE
BEST
VALUE
OF
THE
PARAMETER
THAT
DECIDES
WHEN
TO
SWITCH
TO
INSERTION
SORT
FOR
SMALL
SUBARRAYS
SORT
TEST
IMPROVEMENT
RUN
EMPIRICAL
STUDIES
FOR
LARGE
RANDOMLY
ORDERED
AR
RAYS
TO
STUDY
THE
EFFECTIVENESS
OF
THE
MODIFICATION
DESCRIBED
IN
EXERCISE
FOR
RAN
DOM
DATA
IN
PARTICULAR
DEVELOP
A
HYPOTHESIS
ABOUT
THE
AVERAGE
NUMBER
OF
TIMES
THE
TEST
WHETHER
AN
ARRAY
IS
SORTED
SUCCEEDS
AS
A
FUNCTION
OF
N
THE
ORIGINAL
ARRAY
SIZE
FOR
THE
SORT
MULTIWAY
MERGESORT
DEVELOP
A
MERGESORT
IMPLEMENTATION
BASED
ON
THE
IDEA
OF
DOING
K
WAY
MERGES
RATHER
THAN
WAY
MERGES
ANALYZE
YOUR
ALGORITHM
DEVELOP
A
HY
POTHESIS
REGARDING
THE
BEST
VALUE
OF
K
AND
RUN
EXPERIMENTS
TO
VALIDATE
YOUR
HYPOTHESIS
ARRAY
CREATION
USE
SORTCOMPARE
TO
GET
A
ROUGH
IDEA
OF
THE
EFFECT
ON
PERFOR
MANCE
ON
YOUR
MACHINE
OF
CREATING
AUX
IN
MERGE
RATHER
THAN
IN
SORT
SUBARRAY
LENGTHS
RUN
MERGESORT
FOR
LARGE
RANDOM
ARRAYS
AND
MAKE
AN
EMPIRI
CAL
DETERMINATION
OF
THE
AVERAGE
LENGTH
OF
THE
OTHER
SUBARRAY
WHEN
THE
FIRST
SUBARRAY
EXHAUSTS
AS
A
FUNCTION
OF
N
THE
SUM
OF
THE
TWO
SUBARRAY
SIZES
FOR
A
GIVEN
MERGE
TOP
DOWN
VERSUS
BOTTOM
UP
USE
SORTCOMPARE
TO
COMPARE
TOP
DOWN
AND
BOT
TOM
UP
MERGESORT
FOR
N
AND
NATURAL
MERGESORT
DETERMINE
EMPIRICALLY
THE
NUMBER
OF
PASSES
NEEDED
IN
A
NATURAL
MERGESORT
SEE
EXERCISE
FOR
RANDOM
LONG
KEYS
WITH
N
AND
HINT
YOU
DO
NOT
NEED
TO
IMPLEMENT
A
SORT
OR
EVEN
GENERATE
FULL
BIT
KEYS
TO
COMPLETE
THIS
EXERCISE
THE
SUBJECT
OF
THIS
SECTION
IS
THE
SORTING
ALGORITHM
THAT
IS
PROBABLY
USED
MORE
WIDELY
THAN
ANY
OTHER
QUICKSORT
QUICKSORT
IS
POPULAR
BECAUSE
IT
IS
NOT
DIFFICULT
TO
IMPLEMENT
WORKS
WELL
FOR
A
VARIETY
OF
DIFFERENT
KINDS
OF
INPUT
DATA
AND
IS
SUBSTANTIALLY
FASTER
THAN
ANY
OTHER
SORTING
METHOD
IN
TYPICAL
APPLICATIONS
THE
QUICKSORT
ALGORITHM
DESIRABLE
FEATURES
ARE
THAT
IT
IS
IN
PLACE
USES
ONLY
A
SMALL
AUXILIARY
STACK
AND
THAT
IT
REQUIRES
TIME
PROPORTIONAL
TO
N
LOG
N
ON
THE
AVERAGE
TO
SORT
AN
ARRAY
OF
LENGTH
N
NONE
OF
THE
ALGORITHMS
THAT
WE
HAVE
SO
FAR
CONSIDERED
COMBINE
THESE
TWO
PROPERTIES
FURTHERMORE
QUICKSORT
HAS
A
SHORTER
INNER
LOOP
THAN
MOST
OTHER
SORTING
ALGORITHMS
WHICH
MEANS
THAT
IT
IS
FAST
IN
PRACTICE
AS
WELL
AS
IN
THEORY
ITS
PRIMARY
DRAWBACK
IS
THAT
IT
IS
FRAGILE
IN
THE
SENSE
THAT
SOME
CARE
IS
INVOLVED
IN
THE
IMPLEMENTATION
TO
BE
SURE
TO
AVOID
BAD
PERFORMANCE
NUMEROUS
EXAMPLES
OF
MISTAKES
LEADING
TO
QUADRATIC
PERFOR
MANCE
IN
PRACTICE
ARE
DOCUMENTED
IN
THE
LITERATURE
FORTUNATELY
THE
LESSONS
LEARNED
FROM
THESE
MISTAKES
HAVE
LED
TO
VARIOUS
IMPROVEMENTS
TO
THE
ALGORITHM
THAT
MAKE
IT
OF
EVEN
BROADER
UTILITY
AS
WE
SHALL
SEE
THE
BASIC
ALGORITHM
QUICKSORT
IS
A
DIVIDE
AND
CONQUER
METHOD
FOR
SORTING
IT
WORKS
BY
PARTITIONING
AN
ARRAY
INTO
TWO
SUBARRAYS
THEN
SORTING
THE
SUBARRAYS
INDEPEN
DENTLY
QUICKSORT
IS
COMPLEMENTARY
TO
MERGESORT
FOR
MERGESORT
WE
BREAK
THE
ARRAY
INTO
TWO
SUBARRAYS
TO
BE
SORTED
AND
THEN
COMBINE
THE
ORDERED
SUBARRAYS
TO
MAKE
THE
WHOLE
ORDERED
ARRAY
FOR
QUICKSORT
WE
REARRANGE
THE
ARRAY
SUCH
THAT
WHEN
THE
TWO
SUBARRAYS
ARE
SORTED
THE
WHOLE
ARRAY
IS
ORDERED
IN
THE
FIRST
INSTANCE
WE
DO
THE
TWO
RECURSIVE
CALLS
BEFORE
WORKING
ON
THE
WHOLE
ARRAY
IN
THE
SECOND
INSTANCE
WE
DO
THE
TWO
RECURSIVE
CALLS
AFTER
WORKING
ON
THE
WHOLE
ARRAY
FOR
MERGESORT
THE
ARRAY
IS
DIVIDED
IN
HALF
FOR
QUICKSORT
THE
POSITION
OF
THE
PARTITION
DEPENDS
ON
THE
CONTENTS
OF
THE
ARRAY
THIS
CODE
PARTITIONS
ON
THE
ITEM
V
IN
A
LO
THE
MAIN
LOOP
EXITS
WHEN
THE
SCAN
INDICES
I
AND
J
CROSS
WITHIN
THE
LOOP
WE
INCREMENT
I
WHILE
A
I
IS
LESS
THAN
V
AND
DECREMENT
J
WHILE
A
J
IS
GREATER
THAN
V
THEN
DO
AN
EXCHANGE
TO
MAINTAIN
THE
INVARIANT
PROPERTY
THAT
NO
ENTRIES
TO
THE
LEFT
OF
I
ARE
GREATER
THAN
V
AND
NO
ENTRIES
TO
THE
RIGHT
OF
J
ARE
SMALLER
THAN
V
ONCE
THE
INDICES
MEET
WE
COMPLETE
THE
PARTITIONING
BY
EXCHANGING
A
LO
WITH
A
J
THUS
LEAVING
THE
PARTITIONING
VALUE
IN
A
J
PARTITIONING
TRACE
ARRAY
CONTENTS
BEFORE
AND
AFTER
EACH
EXCHANGE
PARTITIONING
IN
PLACE
IF
WE
USE
AN
EXTRA
ARRAY
PARTITIONING
IS
EASY
TO
IMPLEMENT
BUT
NOT
SO
MUCH
EASIER
THAT
IT
IS
WORTH
THE
EXTRA
COST
OF
COPYING
THE
PARTITIONED
VERSION
BACK
INTO
THE
ORIGINAL
A
NOVICE
JAVA
PROGRAMMER
MIGHT
EVEN
CREATE
A
NEW
SPARE
ARRAY
WITHIN
THE
RECURSIVE
METHOD
FOR
EACH
PARTITION
WHICH
WOULD
DRASTICALLY
SLOW
DOWN
THE
SORT
STAYING
IN
BOUNDS
IF
THE
SMALLEST
ITEM
OR
THE
LARGEST
ITEM
IN
THE
ARRAY
IS
THE
PARTITION
ING
ITEM
WE
HAVE
TO
TAKE
CARE
THAT
THE
POINTERS
DO
NOT
RUN
OFF
THE
LEFT
OR
RIGHT
ENDS
OF
THE
ARRAY
RESPECTIVELY
OUR
PARTITION
IMPLEMENTATION
HAS
EXPLICIT
TESTS
TO
GUARD
AGAINST
THIS
CIRCUMSTANCE
THE
TEST
J
LO
IS
REDUNDANT
SINCE
THE
PARTITIONING
ITEM
IS
AT
A
LO
AND
NOT
LESS
THAN
ITSELF
WITH
A
SIMILAR
TECHNIQUE
ON
THE
RIGHT
IT
IS
NOT
DIF
FICULT
TO
ELIMINATE
BOTH
TESTS
SEE
EXERCISE
PRESERVING
RANDOMNESS
THE
RANDOM
SHUFFLE
PUTS
THE
ARRAY
IN
RANDOM
ORDER
SINCE
IT
TREATS
ALL
ITEMS
IN
THE
SUBARRAYS
UNIFORMLY
ALGORITHM
HAS
THE
PROPERTY
THAT
ITS
TWO
SUBARRAYS
ARE
ALSO
IN
RANDOM
ORDER
THIS
FACT
IS
CRUCIAL
TO
THE
PREDICTABILITY
OF
THE
ALGO
RITHM
RUNNING
TIME
AN
ALTERNATE
WAY
TO
PRESERVE
RANDOMNESS
IS
TO
CHOOSE
A
RANDOM
ITEM
FOR
PARTITIONING
WITHIN
PARTITION
TERMINATING
THE
LOOP
EXPERIENCED
PROGRAMMERS
KNOW
TO
TAKE
SPECIAL
CARE
TO
ENSURE
THAT
ANY
LOOP
MUST
ALWAYS
TERMINATE
AND
THE
PARTITIONING
LOOP
FOR
QUICKSORT
IS
NO
EX
CEPTION
PROPERLY
TESTING
WHETHER
THE
POINTERS
HAVE
CROSSED
IS
A
BIT
TRICKIER
THAN
IT
MIGHT
SEEM
AT
FIRST
GLANCE
A
COMMON
ERROR
IS
TO
FAIL
TO
TAKE
INTO
ACCOUNT
THAT
THE
ARRAY
MIGHT
CONTAIN
OTHER
ITEMS
WITH
THE
SAME
KEY
VALUE
AS
THE
PARTITIONING
ITEM
HANDLING
ITEMS
WITH
KEYS
EQUAL
TO
THE
PARTITIONING
ITEM
KEY
IT
IS
BEST
TO
STOP
THE
LEFT
SCAN
FOR
ITEMS
WITH
KEYS
GREATER
THAN
OR
EQUAL
TO
THE
PARTITIONING
ITEM
KEY
AND
THE
RIGHT
SCAN
FOR
ITEMS
WITH
KEY
LESS
THAN
OR
EQUAL
TO
THE
PARTITIONING
ITEM
KEY
AS
IN
ALGORITHM
EVEN
THOUGH
THIS
POLICY
MIGHT
SEEM
TO
CREATE
UNNECESSARY
EXCHANGES
INVOLVING
ITEMS
WITH
KEYS
EQUAL
TO
THE
PARTITIONING
ITEM
KEY
IT
IS
CRUCIAL
TO
AVOIDING
QUADRATIC
RUNNING
TIME
IN
CERTAIN
TYPICAL
APPLICATIONS
SEE
EXERCISE
LATER
WE
DISCUSS
A
BETTER
STRATEGY
FOR
THE
CASE
WHEN
THE
ARRAY
CONTAINS
A
LARGE
NUMBER
OF
ITEMS
WITH
EQUAL
KEYS
TERMINATING
THE
RECURSION
EXPERIENCED
PROGRAMMERS
ALSO
KNOW
TO
TAKE
SPECIAL
CARE
TO
ENSURE
THAT
ANY
RECURSIVE
METHOD
MUST
ALWAYS
TERMINATE
AND
QUICKSORT
IS
AGAIN
NO
EXCEPTION
FOR
INSTANCE
A
COMMON
MISTAKE
IN
IMPLEMENTING
QUICKSORT
INVOLVES
NOT
ENSURING
THAT
ONE
ITEM
IS
ALWAYS
PUT
INTO
POSITION
THEN
FALLING
INTO
AN
INFINITE
RECURSIVE
LOOP
WHEN
THE
PARTITIONING
ITEM
HAPPENS
TO
BE
THE
LARGEST
OR
SMALLEST
ITEM
IN
THE
ARRAY
PERFORMANCE
CHARACTERISTICS
QUICKSORT
HAS
BEEN
SUBJECTED
TO
VERY
THOROUGH
MATHEMATICAL
ANALYSIS
SO
THAT
WE
CAN
MAKE
PRECISE
STATEMENTS
ABOUT
ITS
PERFORMANCE
THE
ANALYSIS
HAS
BEEN
VALIDATED
THROUGH
EXTENSIVE
EMPIRICAL
EXPERIENCE
AND
IS
A
USEFUL
TOOL
IN
TUNING
THE
ALGORITHM
FOR
OPTIMUM
PERFORMANCE
THE
INNER
LOOP
OF
QUICKSORT
IN
THE
PARTITIONING
METHOD
INCREMENTS
AN
INDEX
AND
COMPARES
AN
ARRAY
ENTRY
AGAINST
A
FIXED
VALUE
THIS
SIMPLICITY
IS
ONE
FACTOR
THAT
MAKES
QUICKSORT
QUICK
IT
IS
HARD
TO
ENVISION
A
SHORTER
INNER
LOOP
IN
A
SORTING
ALGORITHM
FOR
EXAMPLE
MERGESORT
AND
SHELLSHORT
ARE
TYPICALLY
SLOWER
THAN
QUICKSORT
BECAUSE
THEY
ALSO
DO
DATA
MOVEMENT
WITHIN
THEIR
INNER
LOOPS
THE
SECOND
FACTOR
THAT
MAKES
QUICKSORT
QUICK
IS
THAT
IT
USES
FEW
COMPARES
ULTI
MATELY
THE
EFFICIENCY
OF
THE
SORT
DEPENDS
ON
HOW
WELL
THE
PARTITIONING
DIVIDES
THE
ARRAY
WHICH
IN
TURN
DEPENDS
ON
THE
VALUE
OF
THE
PARTITIONING
ITEM
KEY
PARTITIONING
DIVIDES
A
LARGE
RANDOMLY
ORDERED
ARRAY
INTO
TWO
SMALLER
RANDOMLY
ORDERED
SUBARRAYS
BUT
THE
ACTUAL
SPLIT
IS
EQUALLY
LIKELY
FOR
DISTINCT
KEYS
TO
BE
ANYWHERE
IN
THE
ARRAY
NEXT
WE
CONSIDER
THE
ANALYSIS
OF
THE
ALGORITHM
WHICH
ALLOWS
US
TO
SEE
HOW
THIS
CHOICE
COMPARES
TO
THE
IDEAL
CHOICE
THE
BEST
CASE
FOR
QUICKSORT
IS
WHEN
EACH
PARTITIONING
STAGE
DIVIDES
THE
ARRAY
EXACTLY
IN
HALF
THIS
CIRCUMSTANCE
WOULD
MAKE
THE
NUMBER
OF
COMPARES
USED
BY
QUICKSORT
SATISFY
THE
DIVIDE
AND
CONQUER
RECURRENCE
CN
N
THE
TERM
COVERS
THE
COST
OF
SORTING
THE
TWO
SUBARRAYS
THE
N
IS
THE
COST
OF
EXAMINING
EACH
ENTRY
USING
ONE
PARTITIONING
INDEX
OR
THE
OTHER
AS
IN
THE
PROOF
OF
PROPOSITION
F
FOR
MERGESORT
WE
KNOW
THAT
THIS
RECURRENCE
HAS
THE
SOLUTION
CN
N
LG
N
ALTHOUGH
THINGS
DO
NOT
ALWAYS
GO
THIS
WELL
IT
IS
TRUE
THAT
THE
PARTITION
FALLS
IN
THE
MIDDLE
ON
THE
AVERAGE
TAKING
INTO
ACCOUNT
THE
PRECISE
PROBABILITY
OF
EACH
PARTITION
POSITION
MAKES
THE
RECURRENCE
MORE
COMPLICATED
AND
MORE
DIFFICULT
TO
SOLVE
BUT
THE
FINAL
RESULT
IS
SIMILAR
THE
PROOF
OF
THIS
RESULT
IS
THE
BASIS
FOR
OUR
CONFIDENCE
IN
QUICKSORT
IF
YOU
ARE
NOT
MATHEMATICALLY
INCLINED
YOU
MAY
WISH
TO
SKIP
AND
TRUST
IT
IF
YOU
ARE
MATHEMATICALLY
INCLINED
YOU
MAY
FIND
IT
INTRIGUING
WARMUP
INTERACTIVE
PROOFS
WITH
A
DETERMINISTIC
VERIFIER
LET
US
CONSIDER
WHAT
HAPPENS
WHEN
WE
INTRODUCE
INTERACTION
INTO
THE
NP
SCENARIO
THAT
IS
WE
D
HAVE
AN
INTERROGATION
STYLE
PROOF
SYSTEM
WHERE
RATHER
THAN
THE
PROVER
SEND
A
WRITTEN
PROOF
TO
THE
VERIFIER
THE
PROVER
AND
VERIFIER
INTERACT
WITH
THE
VERIFIER
ASKING
QUESTIONS
AND
THE
PROVER
RESPONDING
WHERE
AT
THE
END
THE
VERIFIER
DECIDES
WHETHER
OR
NOT
TO
ACCEPT
THE
INPUT
OF
COURSE
BOTH
VERIFIER
AND
PROVER
CAN
KEEP
STATE
DURING
THE
INTERACTION
OR
EQUIVALENTLY
THE
MESSAGE
A
PARTY
SENDS
AT
ANY
WARMUP
INTERACTIVE
PROOFS
WITH
A
DETERMINISTIC
VERIFIER
POINT
IN
THE
INTERACTION
CAN
BE
A
FUNCTION
OF
ALL
MESSAGES
SENT
AND
RECEIVED
SO
FAR
FORMALLY
WE
MAKE
THE
FOLLOWING
DEFINITION
DEFINITION
INTERACTION
OF
DETERMINISTIC
FUNCTIONS
LET
F
G
BE
FUNCTIONS
A
K
ROUND
INTERACTION
OF
F
AND
G
ON
INPUT
X
DENOTED
BY
F
G
X
IS
THE
SEQUENCE
OF
THE
FOLLOWING
STRINGS
AK
DEFINED
AS
FOLLOWS
F
X
G
X
F
X
G
X
WHERE
WE
CONSIDER
A
SUITABLE
ENCODING
OF
I
TUPLES
OF
STRINGS
TO
STRINGS
THE
OUTPUT
OF
F
RESP
G
AT
THE
END
OF
THE
INTERACTION
DENOTED
OUTF
F
G
X
RESP
OUTG
F
G
X
IS
DEFINED
TO
BE
F
X
AK
RESP
G
X
AK
DEFINITION
DETERMINISTIC
PROOF
SYSTEMS
WE
SAY
THAT
A
LANGUAGE
L
HAS
A
K
ROUND
DETERMINISTIC
INTERACTIVE
PROOF
SYSTEM
IF
THERE
A
DETER
MINISTIC
TM
V
THAT
ON
INPUT
X
AI
RUNS
IN
TIME
POLYNOMIAL
IN
X
SATISFYING
COMPLETENESS
X
L
P
OUTV
V
P
X
SOUNDNESS
X
L
P
OUTV
V
P
X
THE
CLASS
DIP
CONTAINS
ALL
LANGUAGES
WITH
A
K
N
ROUND
DETERMINISTIC
INTERACTIVE
PROOF
SYSTEMS
WITH
K
N
POLYNOMIAL
IN
N
IT
TURNS
OUT
THIS
ACTUALLY
DOES
NOT
CHANGE
THE
CLASS
OF
LANGUAGES
WE
CAN
PROVE
THEOREM
DIP
NP
PROOF
CLEARLY
EVERY
NP
LANGUAGE
HAS
A
ROUND
PROOF
SYSTEM
NOW
WE
PROVE
THAT
IF
A
L
HAS
AN
INTERACTIVE
PROOF
SYSTEM
OF
THIS
TYPE
THEN
L
NP
THE
CERTIFICATE
FOR
MEMBERSHIP
IS
JUST
THE
TRANSCRIPT
AK
CAUSING
THE
VERIFIER
TO
ACCEPT
TO
VERIFY
THIS
TRANSCRIPT
CHECK
THAT
INDEED
V
X
V
X
AND
V
X
AK
IF
X
L
THEN
THERE
INDEED
EXISTS
SUCH
A
TRANSCRIPT
IF
THERE
EXISTS
SUCH
A
TRANSCRIPT
AK
THEN
WE
CAN
DEFINE
A
PROVER
FUNCTION
P
TO
SATISFY
P
X
P
X
ETC
WE
SEE
THAT
OUTV
V
P
X
AND
HENCE
X
L
DRAFT
WEB
DRAFT
THE
CLASS
IP
THE
CLASS
IP
IN
ORDER
TO
REALIZE
THE
FULL
POTENTIAL
OF
INTERACTION
WE
NEED
TO
LET
THE
VERIFIER
BE
PROBABILISTIC
THE
IDEA
IS
THAT
SIMILAR
TO
PROBABILISTIC
ALGORITHMS
THE
VERIFIER
WILL
BE
ALLOWED
TO
COME
TO
A
WRONG
CONCLUSION
E
G
ACCEPT
A
PROOF
FOR
A
WRONG
STATEMENT
WITH
SOME
SMALL
PROBABILITY
HOWEVER
AS
IN
THE
CASE
OF
PROBABILISTIC
ALGORITHMS
THIS
PROBABILITY
IS
OVER
THE
VERIFIER
COINS
AND
THE
VERIFIER
WILL
REJECT
PROOFS
FOR
A
WRONG
STATEMENT
WITH
GOOD
PROBABILITY
REGARDLESS
OF
THE
STRATEGY
THE
PROVER
USES
IT
TURNS
OUT
THAT
THE
COMBINATION
OF
INTERACTION
AND
RANDOMIZATION
HAS
A
HUGE
EFFECT
AS
WE
WILL
SEE
THE
SET
OF
LANGUAGES
WHICH
HAVE
INTERACTIVE
PROOF
SYSTEMS
NOW
JUMPS
FROM
NP
TO
PSPACE
EXAMPLE
AS
AN
EXAMPLE
FOR
A
PROBABILISTIC
INTERACTIVE
PROOF
SYSTEM
CONSIDER
THE
FOLLOWING
SCENARIO
MARLA
CLAIMS
TO
ARTHUR
THAT
SHE
CAN
DISTINGUISH
BETWEEN
THE
TASTE
OF
COKE
COCA
COLA
AND
PEPSI
TO
VERIFY
THIS
STATEMENT
MARLA
AND
ARTHUR
REPEAT
THE
FOLLOWING
EXPERIMENT
TIMES
MARLA
TURNS
HER
BACK
TO
ARTHUR
AS
HE
PLACES
COKE
IN
ONE
UNMARKED
CUP
AND
PEPSI
IN
ANOTHER
CHOOSING
RANDOMLY
WHETHER
COKE
WILL
BE
IN
THE
CUP
ON
THE
LEFT
OR
ON
THE
RIGHT
THEN
MARLA
TASTES
BOTH
CUPS
AND
STATES
WHICH
ONE
CONTAINED
WHICH
DRINKS
WHILE
REGARDLESS
OF
HER
TASTING
ABILITIES
MARLA
CAN
ANSWER
CORRECTLY
WITH
PROBABILITY
BY
A
RANDOM
GUESS
IF
SHE
MANAGES
TO
ANSWER
CORRECTLY
FOR
ALL
THE
REPETITIONS
ARTHUR
CAN
INDEED
BE
CONVINCED
THAT
SHE
CAN
TELL
APART
PEPSI
AND
COKE
TO
FORMALLY
DEFINE
THIS
WE
EXTEND
THE
NOTION
OF
INTERACTION
TO
PROBABILISTIC
FUNCTIONS
ACTUALLY
WE
ONLY
NEED
TO
DO
SO
FOR
THE
VERIFIER
TO
MODEL
AN
INTERACTION
BETWEEN
F
AND
G
WHERE
F
IS
PROBABILISTIC
WE
ADD
AN
ADDITIONAL
M
BIT
INPUT
R
TO
THE
FUNCTION
F
IN
THAT
IS
HAVING
F
X
R
F
X
R
ETC
THE
INTERACTION
F
G
X
IS
NOW
A
RANDOM
VARIABLE
OVER
R
R
M
SIMILARLY
THE
OUTPUT
OUTF
F
G
X
IS
ALSO
A
RANDOM
VARIABLE
DEFINITION
IP
LET
K
N
N
BE
SOME
FUNCTION
WITH
K
N
COMPUTABLE
IN
POLY
N
TIME
A
LANGUAGE
L
IS
IN
IP
K
IF
THERE
IS
A
TURING
MACHINE
V
SUCH
THAT
ON
INPUTS
X
R
AI
V
RUNS
IN
TIME
POLYNOMIAL
IN
X
AND
SUCH
THAT
COMPLETENESS
X
L
P
PR
OUTV
V
P
X
SOUNDNESS
X
L
P
PR
OUTV
V
P
X
WE
DEFINE
IP
C
NC
REMARK
THE
FOLLOWING
OBSERVATIONS
ON
THE
CLASS
IP
ARE
LEFT
AS
AN
EXERCISE
EXERCISE
ALLOWING
THE
PROVER
TO
BE
PROBABILISTIC
I
E
THE
ANSWER
FUNCTION
AI
DEPENDS
UPON
SOME
RANDOM
STRING
USED
BY
THE
PROVER
DOES
NOT
CHANGE
THE
CLASS
IP
THE
REASON
IS
THAT
FOR
ANY
LANGUAGE
L
IF
A
PROBABILISTIC
PROVER
P
RESULTS
IN
MAKING
VERIFIER
V
ACCEPT
WITH
SOME
PROBABILITY
THEN
AVERAGING
IMPLIES
THERE
IS
A
DETERMINISTIC
PROVER
WHICH
MAKES
V
ACCEPT
WITH
THE
SAME
PROBABILITY
WEB
DRAFT
PROVING
THAT
GRAPHS
ARE
NOT
ISOMORPHIC
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
TWO
ISOMORPHIC
GRAPHS
SINCE
THE
PROVER
CAN
USE
AN
ARBITRARY
FUNCTION
IT
CAN
IN
PRINCIPLE
USE
UNBOUNDED
COMPUTA
TIONAL
POWER
OR
EVEN
COMPUTE
UNDECIDABLE
FUNCTIONS
HOWEVER
ONE
CAN
SHOW
THAT
GIVEN
ANY
VERIFIER
V
WE
CAN
COMPUTE
THE
OPTIMUM
PROVER
WHICH
GIVEN
X
MAXIMIZES
THE
VERIFIER
AC
CEPTANCE
PROBABILITY
USING
POLY
X
SPACE
AND
HENCE
X
TIME
THUS
IP
PSPACE
THE
PROBABILITIES
OF
CORRECTLY
CLASSIFYING
AN
INPUT
CAN
BE
MADE
ARBITRARILY
CLOSE
TO
BY
USING
THE
SAME
BOOSTING
TECHNIQUE
WE
USED
FOR
BPP
SEE
SECTION
TO
REPLACE
BY
EXP
M
SEQUENTIALLY
REPEAT
THE
PROTOCOL
M
TIMES
AND
TAKE
THE
MAJORITY
ANSWER
IN
FACT
USING
A
MORE
COMPLICATED
PROOF
IT
CAN
BE
SHOWN
THAT
WE
CAN
DECREASE
THE
PROBABILITY
WITHOUT
INCREASING
THE
NUMBER
OF
ROUNDS
USING
PARALLEL
REPETITION
I
E
THE
PROVER
AND
VERIFIER
WILL
RUN
M
EXECUTIONS
OF
THE
PROTOCOL
IN
PARALLEL
WE
NOTE
THAT
THE
PROOF
IS
EASIER
FOR
THE
CASE
OF
PUBLIC
COIN
PROOFS
WHICH
WILL
BE
DEFINED
BELOW
REPLACING
THE
CONSTANT
IN
THE
COMPLETENESS
REQUIREMENT
BY
DOES
NOT
CHANGE
THE
CLASS
IP
THIS
IS
A
NONTRIVIAL
FACT
IT
WAS
ORIGINALLY
PROVED
IN
A
COMPLICATED
WAY
BUT
TODAY
CAN
BE
PROVED
USING
OUR
CHARACTERIZATION
OF
IP
LATER
IN
SECTION
IN
CONTRAST
REPLACING
THE
CONSTANT
BY
IN
THE
SOUNDNESS
CONDITION
IS
EQUIVALENT
TO
HAVING
A
DETERMINISTIC
VERIFIER
AND
HENCE
REDUCES
THE
CLASS
IP
TO
NP
WE
EMPHASIZE
THAT
THE
PROVER
FUNCTIONS
DO
NOT
DEPEND
UPON
THE
VERIFIER
RANDOM
STRINGS
BUT
ONLY
ON
THE
MESSAGES
QUESTIONS
THE
VERIFIER
SENDS
IN
OTHER
WORDS
THE
VERIFIER
RANDOM
STRING
IS
PRIVATE
OFTEN
THESE
ARE
CALLED
PRIVATE
COIN
INTERACTIVE
PROOFS
LATER
WE
WILL
ALSO
CONSIDER
THE
MODEL
WHERE
ALL
THE
VERIFIER
QUESTIONS
ARE
SIMPLY
OBTAINED
BY
TOSSING
COINS
AND
REVEALING
THEM
TO
THE
PROVER
THIS
IS
KNOWN
AS
PUBLIC
COINS
OR
ARTHUR
MERLIN
PROOFS
PROVING
THAT
GRAPHS
ARE
NOT
ISOMORPHIC
WE
LL
NOW
SEE
AN
EXAMPLE
OF
A
LANGUAGE
IN
IP
THAT
IS
NOT
KNOWN
TO
BE
IN
NP
RECALL
THAT
THE
USUAL
WAYS
OF
REPRESENTING
GRAPHS
ADJACENCY
LISTS
ADJACENCY
MATRICES
INVOLVE
A
NUMBERING
OF
THE
VERTICES
WE
SAY
TWO
GRAPHS
AND
ARE
ISOMORPHIC
IF
THEY
ARE
THE
SAME
UP
TO
A
RENUMBERING
OF
VERTICES
IN
OTHER
WORDS
IF
THERE
IS
A
PERMUTATION

OF
THE
LABELS
OF
THE
NODES
OF
SUCH
THAT

THE
GRAPHS
IN
FIGURE
FOR
EXAMPLE
ARE
ISOMORPHIC
WITH

THAT
IS
AND
ARE
MAPPED
TO
EACH
OTHER
TO
TO
TO
AND
TO
IF
AND
ARE
ISOMORPHIC
WE
WRITE
THE
GI
PROBLEM
IS
THE
FOLLOWING
GIVEN
TWO
GRAPHS
SAY
IN
ADJACENCY
MATRIX
REPRESENTATION
DECIDE
IF
THEY
ARE
ISOMORPHIC
NOTE
THAT
CLEARLY
GI
NP
SINCE
A
CERTIFICATE
IS
SIMPLY
THE
DESCRIPTION
OF
THE
PERMUTATION

THE
GRAPH
ISOMORPHISM
PROBLEM
IS
IMPORTANT
IN
A
VARIETY
OF
FIELDS
AND
HAS
A
RICH
HISTORY
SEE
ALONG
WITH
THE
FACTORING
PROBLEM
IT
IS
THE
MOST
FAMOUS
NP
PROBLEM
THAT
IS
NOT
KNOWN
TO
BE
DRAFT
WEB
DRAFT
PUBLIC
COINS
AND
AM
EITHER
IN
P
OR
NP
COMPLETE
THE
RESULTS
OF
THIS
SECTION
SHOW
THAT
GI
IS
UNLIKELY
TO
BE
NP
COMPLETE
UNLESS
THE
POLYNOMIAL
HIERARCHY
COLLAPSES
THIS
WILL
FOLLOW
FROM
THE
EXISTENCE
OF
THE
FOLLOWING
PROOF
SYSTEM
FOR
THE
COMPLEMENT
OF
GI
THE
PROBLEM
GNI
OF
DECIDING
WHETHER
TWO
GIVEN
GRAPHS
ARE
NOT
ISOMORPHIC
TO
SEE
THAT
DEFINITION
IS
SATISFIED
BY
THE
ABOVE
PROTOCOL
NOTE
THAT
IF
THEN
THERE
EXISTS
A
PROVER
SUCH
THAT
PR
V
ACCEPTS
BECAUSE
IF
THE
GRAPHS
ARE
NON
ISOMORPHIC
AN
ALL
POWERFUL
PROVER
CAN
CERTAINLY
TELL
WHICH
ONE
OF
THE
TWO
IS
ISOMORPHIC
TO
H
ON
THE
OTHER
HAND
IF
THE
BEST
ANY
PROVER
CAN
DO
IS
TO
RANDOMLY
GUESS
BECAUSE
A
RANDOM
PERMUTATION
OF
LOOKS
EXACTLY
LIKE
A
RANDOM
PERMUTATION
OF
THUS
IN
THIS
CASE
FOR
EVERY
PROVER
PR
V
ACCEPTS
THIS
PROBABILITY
CAN
BE
REDUCED
TO
BY
SEQUENTIAL
OR
PARALLEL
REPETITION
PUBLIC
COINS
AND
AM
ALLOWING
THE
PROVER
FULL
ACCESS
TO
THE
VERIFIER
RANDOM
STRING
LEADS
TO
THE
MODEL
OF
INTERACTIVE
PROOFS
WITH
PUBLIC
COINS
DEFINITION
AM
MA
FOR
EVERY
K
WE
DENOTE
BY
AM
K
THE
CLASS
OF
LANGUAGES
THAT
CAN
BE
DECIDED
BY
A
K
ROUND
INTERACTIVE
PROOF
IN
WHICH
EACH
VERIFIER
MESSAGE
CONSISTS
OF
SENDING
A
RANDOM
STRING
OF
POLYNOMIAL
LENGTH
AND
THESE
MESSAGES
COMPRISE
OF
ALL
THE
COINS
TOSSED
BY
THE
VERIFIER
A
PROOF
OF
THIS
FORM
IS
CALLED
A
PUBLIC
COIN
PROOF
IT
IS
SOMETIMES
ALSO
KNOWN
AN
ARTHUR
MERLIN
PROOF
WE
DEFINE
BY
AM
THE
CLASS
AM
THAT
IS
AM
IS
THE
CLASS
OF
LANGUAGES
WITH
AN
INTERACTIVE
PROOF
THAT
CONSIST
OF
THE
VERIFIER
SENDING
A
RANDOM
STRING
THE
PROVER
RESPONDING
WITH
A
MESSAGE
AND
WHERE
THE
DECISION
TO
ACCEPT
IS
OBTAINED
BY
APPLYING
A
DETERMINISTIC
POLYNOMIAL
TIME
FUNCTION
TO
THE
TRANSCRIPT
THE
CLASS
MA
DENOTES
THE
CLASS
OF
LANGUAGES
WITH
ROUND
PUBLIC
COINS
INTERACTIVE
PROOF
WITH
THE
PROVER
SENDING
THE
FIRST
MESSAGE
THAT
IS
L
MA
IF
THERE
A
PROOF
SYSTEM
FOR
L
THAT
CONSISTS
OF
THE
PROVER
FIRST
SENDING
A
MESSAGE
AND
THEN
THE
VERIFIER
TOSSING
COINS
AND
APPLYING
A
POLYNOMIAL
TIME
PREDICATE
TO
THE
INPUT
THE
PROVER
MESSAGE
AND
THE
COINS
WAS
A
FAMOUS
KING
OF
MEDIEVAL
ENGLAND
AND
MERLIN
WAS
HIS
COURT
MAGICIAN
BABAI
NAMED
THESE
CLASSES
BY
DRAWING
AN
ANALOGY
BETWEEN
THE
PROVER
INFINITE
POWER
AND
MERLIN
MAGIC
ONE
JUSTIFICATION
FOR
THIS
MODEL
IS
THAT
WHILE
MERLIN
CANNOT
PREDICT
THE
COINS
THAT
ARTHUR
WILL
TOSS
IN
THE
FUTURE
ARTHUR
HAS
NO
WAY
OF
HIDING
FROM
MERLIN
MAGIC
THE
RESULTS
OF
THE
COINS
HE
TOSSED
IN
THE
PAST
THAT
AM
AM
WHILE
IP
IP
POLY
WHILE
THIS
IS
INDEED
SOMEWHAT
INCONSISTENT
THIS
IS
THE
STANDARD
NOTATION
USED
IN
THE
LITERATURE
WE
NOTE
THAT
SOME
SOURCES
DENOTE
THE
CLASS
AM
BY
AMA
THE
CLASS
AM
BY
AMAM
ETC
WEB
DRAFT
PUBLIC
COINS
AND
AM
NOTE
THAT
CLEARLY
FOR
EVERY
K
AM
K
IP
K
THE
INTERACTIVE
PROOF
FOR
GNI
SEEMED
TO
CRUCIALLY
DEPEND
UPON
THE
FACT
THAT
P
CANNOT
SEE
THE
RANDOM
BITS
OF
V
IF
P
KNEW
THOSE
BITS
P
WOULD
KNOW
I
AND
SO
COULD
TRIVIALLY
ALWAYS
GUESS
CORRECTLY
THUS
IT
MAY
SEEM
THAT
ALLOWING
THE
VERIFIER
TO
KEEP
ITS
COINS
PRIVATE
ADDS
SIGNIFICANT
POWER
TO
INTERACTIVE
PROOFS
AND
SO
THE
FOLLOWING
RESULT
SHOULD
BE
QUITE
SURPRISING
THEOREM
FOR
EVERY
K
N
N
WITH
K
N
COMPUTABLE
IN
POLY
N
IP
K
AM
K
THE
CENTRAL
IDEA
OF
THE
PROOF
OF
THEOREM
CAN
BE
GLEANED
FROM
THE
PROOF
FOR
THE
SPECIAL
CASE
OF
GNI
THEOREM
GNI
AM
K
FOR
SOME
CONSTANT
K
THE
KEY
IDEA
IN
THE
PROOF
OF
THEOREM
IS
TO
LOOK
AT
GRAPH
NONISOMORPHISM
IN
A
DIFFERENT
MORE
QUANTITATIVE
WAY
ASIDE
THIS
IS
A
GOOD
EXAMPLE
OF
HOW
NONTRIVIAL
INTERACTIVE
PROOFS
CAN
BE
DESIGNED
BY
RECASTING
THE
PROBLEM
CONSIDER
THE
SET
H
H
OR
H
NOTE
THAT
IT
IS
EASY
TO
PROVE
THAT
A
GRAPH
H
IS
A
MEMBER
OF
BY
PROVIDING
THE
PERMUTATION
MAPPING
EITHER
OR
TO
H
THE
SIZE
OF
THIS
SET
DEPENDS
ON
WHETHER
IS
ISOMORPHIC
TO
AN
N
VERTEX
GRAPH
G
HAS
AT
MOST
N
EQUIVALENT
GRAPHS
IF
AND
HAVE
EACH
EXACTLY
N
EQUIVALENT
GRAPHS
THIS
WILL
HAPPEN
IF
FOR
I
THERE
NO
NON
IDENTITY
PERMUTATION

SUCH
THAT

GI
GI
WE
LL
HAVE
THAT
IF
THEN
IF
THEN
N
TO
HANDLE
THE
GENERAL
CASE
THAT
OR
MAY
HAVE
LESS
THAN
N
EQUIVALENT
GRAPHS
WE
ACTUALLY
CHANGE
THE
DEFINITION
OF
TO
H

H
OR
H
AND

AUT
H
WHERE

AUT
H
IF

H
H
IT
IS
CLEARLY
EASY
TO
PROVE
MEMBERSHIP
IN
THE
SET
AND
IT
CAN
BE
VERIFIED
THAT
SATISFIES
AND
THUS
TO
CONVINCE
THE
VERIFIER
THAT
THE
PROVER
HAS
TO
CONVINCE
THE
VERIFIER
THAT
CASE
HOLDS
RATHER
THAN
THIS
IS
DONE
BY
USING
A
SET
LOWER
BOUND
PROTOCOL
SET
LOWER
BOUND
PROTOCOL
IN
A
SET
LOWER
BOUND
PROTOCOL
THE
PROVER
PROVES
TO
THE
VERIFIER
THAT
A
GIVEN
SET
WHERE
MEMBERSHIP
IN
IS
EFFICIENTLY
VERIFIABLE
HAS
CARDINALITY
AT
LEAST
K
UP
TO
ACCURACY
OF
SAY
FACTOR
OF
THAT
IS
IF
K
THEN
THE
PROVER
CAN
CAUSE
THE
VERIFIER
TO
ACCEPT
WITH
HIGH
PROBABILITY
WHILE
IF
K
THEN
THE
VERIFIER
WILL
REJECT
WITH
HIGH
PROBABILITY
NO
MATTER
WHAT
THE
PROVER
DOES
BY
THE
OBSERVATIONS
ABOVE
SUCH
A
PROTOCOL
SUFFICES
TO
COMPLETE
THE
PROOF
OF
THEOREM
DRAFT
WEB
DRAFT
PUBLIC
COINS
AND
AM
TOOL
PAIRWISE
INDEPENDENT
HASH
FUNCTIONS
THE
MAIN
TOOL
WE
USE
FOR
THE
SET
LOWER
BOUND
PROTOCOL
IS
A
PAIRWISE
INDEPENDENT
HASH
FUNCTION
COLLECTION
THIS
IS
A
SIMPLE
BUT
INCREDIBLY
USEFUL
TOOL
THAT
HAS
FOUND
NUMEROUS
APPLICATIONS
IN
COMPLEXITY
THEORY
AND
COMPUTER
SCIENCE
AT
LARGE
SEE
NOTE
NOTE
THAT
AN
EQUIVALENT
FORMULATION
IS
THAT
FOR
EVERY
TWO
DISTINCT
STRINGS
X
XI
N
THE
RANDOM
VARIABLE
H
X
H
XI
FOR
H
CHOSEN
AT
RANDOM
FROM
HN
K
IS
DISTRIBUTED
ACCORDING
TO
THE
UNIFORM
DISTRIBUTION
ON
K
K
RECALL
THAT
WE
CAN
IDENTIFY
THE
ELEMENTS
OF
N
WITH
THE
FINITE
FIELD
SEE
SECTION
A
IN
THE
APPENDIX
DENOTED
GF
CONTAINING
ELEMENTS
WHOSE
ADDITION
AND
MULTIPLICATION
OPERATIONS
SATISFY
THE
USUAL
COMMUTATIVE
AND
DISTRIBUTIVE
LAWS
WHERE
AND
EVERY
ELEMENT
X
HAS
AN
ADDITIVE
INVERSE
DENOTED
BY
X
AND
IF
NONZERO
A
MULTIPLICATIVE
INVERSE
DENOTED
BY
X
THE
FOLLOWING
THEOREM
PROVIDES
A
CONSTRUCTION
OF
AN
EFFICIENTLY
COMPUTABLE
PAIRWISE
INDEPENDENT
HASH
FUNCTIONS
SEE
ALSO
EXERCISE
FOR
A
DIFFERENT
CONSTRUCTION
THEOREM
EFFICIENT
PAIRWISE
INDEPENDENT
HASH
FUNCTIONS
FOR
EVERY
N
DEFINE
THE
COLLECTION
HN
N
TO
BE
HA
B
A
B
GF
WHERE
FOR
EVERY
A
B
GF
THE
FUNC
TION
HA
B
GF
GF
MAPS
X
TO
AX
B
THEN
HN
N
IS
A
COLLECTION
OF
PAIRWISE
INDEPENDENT
HASH
FUNCTIONS
REMARK
THEOREM
IMPLIES
THE
EXISTENCE
OF
AN
EFFICIENTLY
COMPUTABLE
PAIRWISE
INDEPENDENT
HASH
FUNCTIONS
N
K
FOR
EVERY
N
K
IF
K
N
WE
CAN
USE
THE
COLLECTION
K
K
AND
REDUCE
THE
SIZE
OF
THE
INPUT
TO
N
BY
PADDING
IT
WITH
ZEROS
IF
K
N
THEN
WE
CAN
USE
THE
COLLECTION
N
N
AND
TRUNCATE
THE
LAST
N
K
BITS
OF
THE
OUTPUT
PROOF
FOR
EVERY
X
XI
GF
AND
Y
YI
GF
HA
B
X
Y
AND
HA
B
XI
YI
IFF
A
B
SATISFY
THE
EQUATIONS
A
X
B
Y
A
XI
B
YI
THESE
IMPLY
A
X
XI
Y
YI
OR
A
Y
YI
X
XI
SINCE
B
Y
A
X
THE
PAIR
A
B
IS
COMPLETELY
DETERMINED
BY
THESE
EQUATIONS
AND
SO
THE
PROBABILITY
THAT
THIS
HAPPENS
OVER
THE
CHOICE
OF
A
B
IS
EXACTLY
ONE
OVER
THE
NUMBER
OF
POSSIBLE
PAIRS
WHICH
INDEED
EQUALS
WEB
DRAFT
PUBLIC
COINS
AND
AM
NOTE
THE
HASHING
PARADIGM
A
HASH
FUNCTION
COLLECTION
IS
A
COLLECTION
OF
FUNCTIONS
MAPPING
A
LARGE
UNI
VERSE
SAY
N
TO
A
SMALLER
UNIVERSE
SAY
K
FOR
K
N
TYPICALLY
WE
REQUIRE
OF
SUCH
A
COLLECTION
THAT
IT
MAPS
ITS
INPUT
IN
A
FAIRLY
UNIFORM
WAY
TO
THE
OUTPUT
RANGE
FOR
EXAMPLE
IF
IS
A
SUBSET
OF
N
THEN
WE
WISH
THAT
IF
H
IS
CHOSEN
AT
RANDOM
FROM
THE
COLLECTION
THEN
MOST
ELEMENTS
OF
K
HAVE
ROUGHLY
K
PREIMAGES
IN
WHICH
IS
THE
EXPECTED
NUMBER
IF
H
WAS
A
COMPLETELY
RANDOM
FUNCTION
IN
PARTICULAR
IF
HAS
SIZE
ROUGHLY
THEN
WE
EXPECT
THE
MAPPING
TO
BE
ONE
TO
ONE
OR
ALMOST
ONE
TO
ONE
AND
SO
THERE
SHOULD
BE
A
RELATIVELY
SMALL
NUMBER
OF
COLLISIONS
PAIRS
X
XI
SUCH
THAT
H
X
H
XI
THEREFORE
THE
IMAGE
OF
UNDER
H
SHOULD
LOOK
LIKE
THIS
N
H
K
K
IN
DATABASES
HASH
FUNCTIONS
ARE
USED
TO
MAINTAIN
VERY
EFFICIENT
DATABASES
THAT
ALLOW
FAST
MEMBERSHIP
QUERIES
TO
A
SUBSET
N
OF
SIZE
RE
QUIRING
ONLY
AS
OPPOSED
TO
BITS
OF
STORAGE
IN
THEORETICAL
COMPUTER
SCIENCE
HASH
FUNCTIONS
HAVE
A
VARIETY
OF
USES
AN
EXAMPLE
IS
LEMMA
OF
THE
NEXT
CHAPTER
THAT
SHOWS
THAT
IF
THE
COLLECTION
IS
PAIRWISE
INDEPENDENT
AND
N
HAS
SIZE
ROUGHLY
THEN
WITH
GOOD
PROBABILITY
THE
VALUE
WILL
HAVE
EXACTLY
ONE
PREIMAGE
IN
IN
ALL
THESE
CASES
IT
IS
IMPORTANT
THAT
THE
HASH
FUNCTION
IS
CHOSEN
AT
RANDOM
FROM
SOME
COLLECTION
INDEPENDENTLY
OF
THE
CHOICE
OF
SET
IT
IS
EASY
TO
SEE
THAT
IF
K
IS
SMALL
ENOUGH
E
G
K
N
THEN
FOR
EVERY
H
N
K
THERE
IS
A
SET
N
OF
SIZE
THAT
IS
VERY
BAD
FOR
H
IN
THE
SENSE
THAT
ALL
THE
MEMBERS
OF
MAP
TO
THE
SAME
ELEMENT
UNDER
H
PAIRWISE
INDEPENDENT
HASH
FUNCTIONS
ARE
BUT
ONE
EXAMPLE
OF
A
HASH
FUNC
TION
COLLECTION
SEVERAL
TYPES
OF
SUCH
COLLECTIONS
ARE
KNOWN
IN
THE
LITERATURE
FEATURING
VARIOUS
TRADEOFFS
BETWEEN
EFFICIENCY
AND
UNIFORMITY
OF
OUTPUT
DRAFT
WEB
DRAFT
PUBLIC
COINS
AND
AM
THE
LOWER
BOUND
PROTOCOL
THE
LOWER
BOUND
PROTOCOL
IS
AS
FOLLOWS
K
LET
P
K
IF
K
THEN
CLEARLY
H
AND
SO
THE
VERIFIER
WILL
ACCEPT
WITH
PROBABILITY
P
AT
MOST
THE
MAIN
CHALLENGE
IS
TO
SHOW
THAT
IF
K
THEN
THE
VERIFIER
WILL
ACCEPT
WITH
PROBABILITY
NOTICEABLY
LARGER
THAN
P
THE
GAP
BETWEEN
THE
PROBABILITIES
CAN
THEN
BE
AMPLIFIED
USING
REPETITION
THAT
IS
IT
SUFFICES
TO
PROVE
CLAIM
LET
M
SATISFY
THEN
H
R
PR
HM
K
Y
R
X
SH
X
Y
PROOF
FOR
EVERY
Y
M
WE
LL
PROVE
THE
CLAIM
BY
SHOWING
THAT
PR
H
RHM
K
X
SH
X
Y
P
WHERE
P
INDEED
FOR
EVERY
X
DEFINE
THE
EVENT
EX
TO
HOLD
IF
H
X
Y
THEN
PR
X
SH
X
Y
PR
X
SEX
BUT
BY
THE
INCLUSION
EXCLUSION
PRINCIPLE
THIS
IS
AT
LEAST
X
X
X
PR
EX
EXI
HOWEVER
BY
PAIRWISE
INDEPENDENCE
IF
X
XI
THEN
PR
EX
K
AND
PR
EX
EXI
AND
SO
THIS
PROBABILITY
IS
AT
LEAST
P
WEB
DRAFT
PUBLIC
COINS
AND
AM
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
AM
K
LOOKS
LIKE
TLP
WITH
THE
QUANTIFIER
REPLACED
BY
PROBABILITIC
CHOICE
PROVING
THEOREM
THE
PUBLIC
COIN
INTERACTIVE
PROOF
SYSTEM
FOR
GNI
CONSISTS
OF
THE
VERIFIER
AND
PROVER
RUNNING
SEVERAL
ITERATIONS
OF
THE
SET
LOWER
BOUND
PROTOCOL
FOR
THE
SET
AS
DEFINED
ABOVE
WHERE
THE
VERIFIER
ACCEPTS
IFF
THE
FRACTION
OF
ACCEPTING
ITERATIONS
WAS
AT
LEAST
NOTE
THAT
BOTH
PARTIES
CAN
COMPUTE
P
USING
THE
CHERNOFF
BOUND
THEOREM
A
IT
CAN
BE
EASILY
SEEN
THAT
A
CONSTANT
NUMBER
OF
ITERATION
WILL
SUFFICES
TO
ENSURE
COMPLETENESS
PROBABILITY
AT
LEAST
AND
SOUNDNESS
ERROR
AT
MOST
REMARK
HOW
DOES
THIS
PROTOCOL
RELATE
TO
THE
PRIVATE
COIN
PROTOCOL
OF
SECTION
THE
SET
ROUGHLY
CORRESPONDS
TO
THE
SET
OF
POSSIBLE
MESSAGES
SENT
BY
THE
VERIFIER
IN
THE
PROTOCOL
WHERE
THE
VERIFIER
MESSAGE
IS
A
RANDOM
ELEMENT
IN
IF
THE
TWO
GRAPHS
ARE
ISOMORPHIC
THEN
THE
VERIFIER
MESSAGE
COMPLETELY
HIDES
ITS
CHOICE
OF
A
RANDOM
I
R
WHILE
IF
THEY
RE
NOT
THEN
IT
COMPLETELY
REVEALS
IT
AT
LEAST
TO
A
PROVER
THAT
HAS
UNBOUNDED
COMPUTATION
TIME
THUS
ROUGHLY
SPEAKING
IN
THE
FORMER
CASE
THE
MAPPING
FROM
THE
VERIFIER
COINS
TO
THE
MESSAGE
IS
TO
WHILE
IN
THE
LATTER
CASE
IT
IS
TO
RESULTING
IN
A
SET
THAT
IS
TWICE
AS
LARGE
INDEED
WE
CAN
VIEW
THE
PROVER
IN
THE
PUBLIC
COIN
PROTOCOL
AS
CONVINCING
THE
VERIFIER
THAT
ITS
PROBABILITY
OF
CONVINCING
THE
PRIVATE
COIN
VERIFIER
IS
LARGE
WHILE
THERE
ARE
SEVERAL
ADDITIONAL
INTRICACIES
TO
HANDLE
THIS
IS
THE
IDEA
BEHIND
THE
GENERALIZATION
OF
THIS
PROOF
TO
SHOW
THAT
IP
K
AM
K
REMARK
NOTE
THAT
UNLIKE
THE
PRIVATE
COINS
PROTOCOL
THE
PUBLIC
COINS
PROTOCOL
OF
THEOREM
DOES
NOT
ENJOY
PERFECT
COMPLETENESS
SINCE
THE
SET
LOWERBOUND
PROTOCOL
DOES
NOT
SATISFY
THIS
PROPERTY
HOWEVER
WE
CAN
CONSTRUCT
A
PERFECTLY
COMPLETE
PUBLIC
COINS
SET
LOWERBOUND
PROTOCOL
SEE
EXERCISE
THUS
IMPLYING
A
PERFECTLY
COMPLETE
PUBLIC
COINS
PROOF
FOR
GNI
AGAIN
THIS
CAN
BE
GENERALIZED
TO
SHOW
THAT
ANY
PRIVATE
COINS
PROOF
SYSTEM
EVEN
ONE
NOT
SATISFYING
PERFECT
COMPLETENESS
CAN
BE
TRANSFORMED
INTO
A
PERFECTLY
COMPLETE
PUBLIC
COINS
SYSTEM
WITH
A
SIMILAR
NUMBER
OF
ROUNDS
SOME
PROPERTIES
OF
IP
AND
AM
WE
STATE
THE
FOLLOWING
PROPERTIES
OF
IP
AND
AM
WITHOUT
PROOF
EXERCISE
AM
BP
NP
WHERE
BP
NP
IS
THE
CLASS
IN
DEFINITION
IN
PARTICULAR
IT
FOLLOWS
THATAM
P
EXERCISE
FOR
CONSTANTS
K
WE
HAVE
AM
K
AM
THIS
COLLAPSE
IS
SOMEWHAT
SURPRISING
BECAUSE
AM
K
AT
FIRST
GLANCE
SEEMS
SIMILAR
TO
PH
WITH
THE
QUANTIFIERS
CHANGED
TO
PROBABILISTIC
QUANTIFIERS
WHERE
MOST
OF
THE
BRANCHES
LEAD
TO
ACCEPTANCE
SEE
FIGURE
IT
IS
OPEN
WHETHER
THERE
IS
ANY
NICE
CHARACTERIZATION
OF
AM

N
WHERE

N
IS
A
SUITABLY
SLOW
GROWING
FUNCTION
OF
N
SUCH
AS
LOG
LOG
N
DRAFT
WEB
DRAFT
IP
PSPACE
CAN
GI
BE
NP
COMPLETE
WE
NOW
PROVE
THAT
IF
GI
IS
NP
COMPLETE
THEN
THE
POLYNOMIAL
HIERARCHY
COLLAPSES
THEOREM
IF
GI
IS
NP
COMPLETE
THEN
PROOF
IF
GI
IS
NP
COMPLETE
THEN
GNI
IS
CONP
COMPLETE
WHICH
IMPLIES
THAT
THERE
EXISTS
A
FUNCTION
F
SUCH
THAT
FOR
EVERY
N
VARIABLE
FORMULA

Y
Y
HOLDS
IFF
F

GNI
LET

X
N
Y
N

X
Y
BE
A
FORMULA
WE
HAVE
THAT

IS
EQUIVALENT
TO
X
N
G
X
GNI
WHERE
G
X
F
USING
REMARK
AND
THE
COMMENTS
OF
SECTION
WE
HAVE
THAT
GNI
HAS
A
TWO
ROUND
AM
PROOF
WITH
PERFECT
COMPLETENESS
AND
AFTER
APPROPRIATE
AMPLIFICATION
SOUNDNESS
ERROR
LESS
THAN
N
LET
V
BE
THE
VERIFIER
ALGORITHM
FOR
THIS
PROOF
SYSTEM
AND
DENOTE
BY
M
THE
LENGTH
OF
THE
VERIFIER
RANDOM
TAPE
AND
BY
MI
THE
LENGTH
OF
THE
PROVER
MESSAGE
AND
WE
CLAIM
THAT

IS
EQUIVALENT
TO

R
M
X
N
A
M
V
G
X
R
A
INDEED
BY
PERFECT
COMPLETENESS
IF

IS
SATISFIABLE
THEN

IS
SATISFIABLE
IF

IS
NOT
SATISFIABLE
THEN
BY
THE
FACT
THAT
THE
SOUNDNESS
ERROR
IS
AT
MOST
N
WE
HAVE
THAT
THERE
EXISTS
A
SINGLE
STRING
R
M
SUCH
THAT
FOR
EVERY
X
WITH
G
X
GNI
THERE
NO
A
SUCH
THAT
V
G
X
R
A
AND
SO

IS
NOT
SATISFIABLE
SINCE

CAN
EASILY
BE
REDUCED
TO
A
FORMULA
WE
GET
THAT
IMPLYING
SINCE
THAT
IP
PSPACE
IN
THIS
SECTION
WE
SHOW
A
SURPRISING
CHARACTERIZATION
OF
THE
SET
OF
LANGUAGES
THAT
HAVE
INTERACTIVE
PROOFS
THEOREM
LFKN
SHAMIR
IP
PSPACE
NOTE
THAT
THIS
IS
INDEED
QUITE
SURPRISING
WE
ALREADY
SAW
THAT
INTERACTION
ALONE
DOES
NOT
INCREASE
THE
LANGUAGES
WE
CAN
PROVE
BEYOND
NP
AND
WE
TEND
TO
THINK
OF
RANDOMIZATION
AS
NOT
ADDING
SIGNIFICANT
POWER
TO
COMPUTATION
E
G
WE
LL
SEE
IN
CHAPTER
THAT
UNDER
REASONABLE
CONJECTURES
BPP
P
AS
NOTED
IN
SECTION
WE
EVEN
KNOW
THAT
LANGUAGES
WITH
CONSTANT
ROUND
INTERACTIVE
PROOFS
HAVE
A
TWO
ROUND
PUBLIC
COINS
PROOF
AND
ARE
IN
PARTICULAR
CONTAINED
IN
THE
POLYNOMIAL
HIERARCHY
WHICH
IS
BELIEVED
TO
BE
A
PROPER
SUBSET
OF
PSPACE
NONETHELESS
IT
TURNS
OUT
THAT
THE
COMBINATION
OF
SUFFICIENT
INTERACTION
AND
RANDOMNESS
IS
QUITE
POWERFUL
WEB
DRAFT
IP
PSPACE
BY
OUR
EARLIER
REMARK
WE
NEED
ONLY
SHOW
THE
DIRECTION
PSPACE
IP
TO
DO
SO
WE
LL
SHOW
THAT
TQBF
IP
POLY
N
THIS
IS
SUFFICIENT
BECAUSE
EVERY
L
PSPACE
IS
POLYTIME
REDUCIBLE
TO
TQBF
WE
NOTE
THAT
OUR
PROTOCOL
FOR
TQBF
WILL
USE
PUBLIC
COINS
AND
ALSO
HAS
THE
PROPERTY
THAT
IF
THE
INPUT
IS
IN
TQBF
THEN
THERE
IS
A
PROVER
WHICH
MAKES
THE
VERIFIER
ACCEPT
WITH
PROBABILITY
RATHER
THAN
TACKLE
THE
JOB
OF
DESIGNING
A
PROTOCOL
FOR
TQBF
RIGHT
AWAY
LET
US
FIRST
THINK
ABOUT
HOW
TO
DESIGN
ONE
FOR
HOW
CAN
THE
PROVER
CONVINCE
THE
VERIFIER
THAN
A
GIVEN
FORMULA
HAS
NO
SATISFYING
ASSIGNMENT
WE
SHOW
HOW
TO
PROVE
SOMETHING
EVEN
MORE
GENERAL
THE
PROVER
CAN
PROVE
TO
THE
VERIFIER
WHAT
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
IS
IN
OTHER
WORDS
WE
WILL
DESIGN
A
PROVER
FOR
SAT
THE
IDEA
OF
ARITHMETIZATION
INTRODUCED
IN
THIS
PROOF
WILL
ALSO
PROVE
USEFUL
IN
OUR
PROTOCOL
FOR
TQBF
ARITHMETIZATION
THE
KEY
IDEA
WILL
BE
TO
TAKE
AN
ALGEBRAIC
VIEW
OF
BOOLEAN
FORMULAE
BY
REPRESENTING
THEM
AS
POLYNO
MIALS
NOTE
THAT
CAN
BE
THOUGHT
OF
BOTH
AS
TRUTH
VALUES
AND
AS
ELEMENTS
OF
SOME
FINITE
FIELD
F
THUS
WE
HAVE
THE
FOLLOWING
CORRESPONDENCE
BETWEEN
FORMULAS
AND
POLYNOMIALS
WHEN
THE
VARIABLES
TAKE
VALUES
X
Y
X
Y
X
X
X
Y
X
Y
X
Y
Z
X
Y
Z
GIVEN
ANY
FORMULA

XN
WITH
M
CLAUSES
WE
CAN
WRITE
SUCH
A
DEGREE
POLYNO
MIAL
FOR
EACH
CLAUSE
MULTIPLYING
THESE
POLYNOMIALS
WE
OBTAIN
A
DEGREE
MULTIVARIATE
POLYNOMIAL
P
XN
THAT
EVALUATES
TO
FOR
SATISFYING
ASSIGNMENTS
AND
EVALUATES
TO
FOR
UNSATIS
FYING
ASSIGNMENTS
NOTE
WE
REPRESENT
SUCH
A
POLYNOMIAL
AS
A
MULTIPLICATION
OF
ALL
THE
DEGREE
POLYNOMIALS
WITHOUT
OPENING
UP
THE
PARENTHESIS
AND
SO
P
XN
HAS
A
REPRESENTATION
OF
SIZE
O
M
THIS
CONVERSION
OF

TO
P
IS
CALLED
ARITHMETIZATION
ONCE
WE
HAVE
WRITTEN
SUCH
A
POLYNOMIAL
NOTHING
STOPS
US
FROM
GOING
AHEAD
AND
AND
EVALUATING
THE
POLYNOMIAL
WHEN
THE
VARIABLES
TAKE
ARBITRARY
VALUES
FROM
THE
FIELD
F
INSTEAD
OF
JUST
AS
WE
WILL
SEE
THIS
GIVES
THE
VERIFIER
UNEXPECTED
POWER
OVER
THE
PROVER
INTERACTIVE
PROTOCOL
FOR
SATD
TO
DESIGN
A
PROTOCOL
FOR
WE
GIVE
A
PROTOCOL
FOR
SATD
WHICH
IS
A
DECISION
VERSION
OF
THE
COUNTING
PROBLEM
SAT
WE
SAW
IN
CHAPTER
SATD

K
K
IS
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
OF

AND

IS
A
FORMULA
OF
N
VARIABLES
AND
M
CLAUSES
THEOREM
SATD
IP
DRAFT
WEB
DRAFT
IP
PSPACE
PROOF
GIVEN
INPUT

K
WE
CONSTRUCT
BY
ARITHMETIZATION
P
THE
NUMBER
OF
SATISFYING
AS
SIGNMENTS

OF

IS

P
BN
TO
START
THE
PROVER
SENDS
TO
THE
VERIFIER
A
PRIME
P
IN
THE
INTERVAL
THE
VERIFIER
CAN
CHECK
THAT
P
IS
PRIME
USING
A
PROBABILISTIC
OR
DETERMINISTIC
PRIMALITY
TESTING
ALGORITHM
ALL
COMPUTATIONS
DESCRIBED
BELOW
ARE
DONE
IN
THE
FIELD
F
FP
OF
NUMBERS
MODULO
P
NOTE
THAT
SINCE
THE
SUM
IN
IS
BETWEEN
AND
THIS
EQUATION
IS
TRUE
OVER
THE
INTEGERS
IFF
IT
IS
TRUE
MODULO
P
THUS
FROM
NOW
ON
WE
CONSIDER
AS
AN
EQUATION
IN
THE
FIELD
FP
WE
LL
PROVE
THE
THEOREM
BY
SHOWING
A
GENERAL
PROTOCOL
SUMCHECK
FOR
VERIFYING
EQUATIONS
SUCH
AS
SUMCHECK
PROTOCOL
GIVEN
A
DEGREE
D
POLYNOMIAL
G
XN
AN
INTEGER
K
AND
A
PRIME
P
WE
PRESENT
AN
INTERACTIVE
PROOF
FOR
THE
CLAIM
K
G
XN
WHERE
ALL
COMPUTATIONS
ARE
MODULO
P
TO
EXECUTE
THE
PROTOCOL
V
WILL
NEED
TO
BE
ABLE
TO
EVALUATE
THE
POLYNOMIAL
G
FOR
ANY
SETTING
OF
VALUES
TO
THE
VARIABLES
NOTE
THAT
THIS
CLEARLY
HOLDS
IN
THE
CASE
G
P
FOR
EACH
SEQUENCE
OF
VALUES
BN
TO
XN
NOTE
THAT
G
BN
IS
A
UNIVARIATE
DEGREE
D
POLYNOMIAL
IN
THE
VARIABLE
THUS
THE
FOLLOWING
IS
ALSO
A
UNIVARIATE
DEGREE
D
POLYNOMIAL
H
G
BN
BN
IF
CLAIM
IS
TRUE
THEN
WE
HAVE
H
H
K
CONSIDER
THE
FOLLOWING
PROTOCOL
PROTOCOL
SUMCHECK
PROTOCOL
TO
CHECK
CLAIM
V
IF
N
CHECK
THAT
G
G
K
IF
SO
ACCEPT
OTHERWISE
REJECT
IF
N
ASK
P
TO
SEND
H
AS
DEFINED
ABOVE
P
SENDS
SOME
POLYNOMIAL
IF
THE
PROVER
IS
NOT
CHEATING
THEN
WE
LL
HAVE
H
V
REJECT
IF
K
OTHERWISE
PICK
A
RANDOM
A
RECURSIVELY
USE
THE
SAME
PROTOCOL
TO
CHECK
THAT
A
B
WEB
DRAFT
BN
G
A
BN
IP
PSPACE
IF
CLAIM
IS
TRUE
THE
PROVER
THAT
ALWAYS
RETURNS
THE
CORRECT
POLYNOMIAL
WILL
ALWAYS
CONVINCE
V
IF
IS
FALSE
THEN
WE
PROVE
THAT
V
REJECTS
WITH
HIGH
PROBABILITY
PR
V
REJECTS
K
G
N
P
WITH
OUR
CHOICE
OF
P
THE
RIGHT
HAND
SIDE
IS
ABOUT
DN
P
WHICH
IS
VERY
CLOSE
TO
SINCE
D
AND
P
ASSUME
THAT
IS
FALSE
WE
PROVE
BY
INDUCTION
ON
N
FOR
N
V
SIMPLY
EVALUATES
G
G
AND
REJECTS
WITH
PROBABILITY
IF
THEIR
SUM
IS
NOT
K
ASSUME
THE
HYPOTHESIS
IS
TRUE
FOR
DEGREE
D
POLYNOMIALS
IN
N
VARIABLES
IN
THE
FIRST
ROUND
THE
PROVER
P
IS
SUPPOSED
TO
RETURN
THE
POLYNOMIAL
H
IF
IT
INDEED
RETURNS
H
THEN
SINCE
H
H
K
BY
ASSUMPTION
V
WILL
IMMEDIATELY
REJECT
I
E
WITH
PROBABILITY
SO
ASSUME
THAT
THE
PROVER
RETURNS
SOME
DIFFERENT
FROM
H
SINCE
THE
DEGREE
D
NONZERO
POLYNOMIAL
H
HAS
AT
MOST
D
ROOTS
THERE
ARE
AT
MOST
D
VALUES
A
SUCH
THAT
A
H
A
THUS
WHEN
V
PICKS
A
RANDOM
A
PR
A
H
A
D
IF
A
H
A
THEN
THE
PROVER
IS
LEFT
WITH
AN
INCORRECT
CLAIM
TO
PROVE
IN
THE
RECURSIVE
STEP
BY
THE
INDUCTION
HYPOTHESIS
THE
PROVER
FAILS
TO
PROVE
THIS
FALSE
CLAIM
WITH
PROBABILITY
AT
LEAST
D
N
THUS
WE
HAVE
PR
V
REJECTS
THIS
FINISHES
THE
INDUCTION
D
N
P
N
P
PROTOCOL
FOR
TQBF
PROOF
OF
THEOREM
WE
USE
A
VERY
SIMILAR
IDEA
TO
OBTAIN
A
PROTOCOL
FOR
TQBF
GIVEN
A
QUANTIFIED
BOOLEAN
FORMULA

XN
XN
WE
USE
ARITHMETIZATION
TO
CONSTRUCT
THE
POLYNOMIAL
P
WE
HAVE
THAT

TQBF
IF
AND
ONLY
IF
FL
FL
P
BN
A
FIRST
THOUGHT
IS
THAT
WE
COULD
USE
THE
SAME
PROTOCOL
AS
IN
THE
SATD
CASE
EXCEPT
CHECK
THAT
K
WHEN
YOU
HAVE
A
BUT
ALAS
MULTIPLICATION
UNLIKE
ADDITION
INCREASES
THE
DEGREE
OF
THE
POLYNOMIAL
AFTER
K
STEPS
THE
DEGREE
COULD
BE
SUCH
POLYNOMIALS
MAY
HAVE
COEFFICIENTS
AND
CANNOT
EVEN
BE
TRANSMITTED
IN
POLYNOMIAL
TIME
IF
K
LOG
N
THE
SOLUTION
IS
TO
LOOK
MORE
CLOSELY
AT
THE
POLYNOMIALS
THAT
ARE
ARE
TRANSMITTED
AND
THEIR
RELATION
TO
THE
ORIGINAL
FORMULA
WE
LL
CHANGE

INTO
A
LOGICALLY
EQUIVALENT
FORMULA
WHOSE
ARITHMETIZATION
DRAFT
WEB
DRAFT
THE
POWER
OF
THE
PROVER
DOES
NOT
CAUSE
THE
DEGREES
OF
THE
POLYNOMIALS
TO
BE
SO
LARGE
THE
IDEA
IS
SIMILAR
TO
THE
WAY
CIRCUITS
ARE
REDUCED
TO
FORMULAS
IN
THE
COOK
LEVIN
THEOREM
WE
LL
ADD
AUXILIARY
VARIABLES
SPECIFICALLY
WE
LL
CHANGE

TO
AN
EQUIVALENT
FORMULA
I
THAT
IS
NOT
IN
PRENEX
FORM
IN
THE
FOLLOWING
WAY
WORK
FROM
RIGHT
TO
LEFT
AND
WHENEVER
ENCOUNTERING
A
QUANTIFIER
ON
A
VARIABLE
XI
THAT
IS
WHEN
CONSIDERING
A
POSTFIX
OF
THE
FORM
XI

XI
WHERE

MAY
CONTAIN
QUANTIFIERS
OVER
ADDITIONAL
VARIABLES
XI
XN
ENSURE
THAT
THE
VARIABLES
XI
NEVER
APPEAR
TO
THE
RIGHT
OF
ANOTHER
QUANTIFIER
IN

BY
CHANGING
THE
POSTFIX
TO
XI
XII
XII
XI

XN
CONTINUING
THIS
WAY
WE
LL
OBTAIN
THE
FORMULA
I
WHICH
WILL
HAVE
O
VARIABLES
AND
WILL
BE
AT
MOST
O
LARGER
THAN

IT
CAN
BE
SEEN
THAT
THE
NATURAL
ARITHMETIZATION
FOR
I
WILL
LEAD
TO
THE
POLYNOMIALS
TRANSMITTED
IN
THE
SUMCHECK
PROTOCOL
NEVER
HAVING
DEGREE
MORE
THAN
NOTE
THAT
THE
PROVER
NEEDS
TO
PROVE
THAT
THE
ARITHMETIZATION
OF
I
LEADS
TO
A
NUMBER
K
DIFFERENT
THAN
BUT
BECAUSE
OF
THE
MULTIPLICATIONS
THIS
NUMBER
CAN
BE
AS
LARGE
AS
NEVERTHELESS
THE
PROVER
CAN
FIND
A
PRIME
P
BETWEEN
AND
SUCH
THAT
K
MOD
P
IN
FACT
AS
WE
SAW
IN
CHAPTER
A
RANDOM
PRIME
WILL
DO
THIS
FINISHES
THE
PROOF
OF
THEOREM
REMARK
AN
ALTERNATIVE
WAY
TO
OBTAIN
THE
SAME
RESULT
OR
MORE
ACCURATELY
AN
ALTERNATIVE
WAY
TO
DESCRIBE
THE
SAME
PROTOCOL
IS
TO
NOTICE
THAT
FOR
X
XK
X
FOR
ALL
K
THUS
IN
PRINCIPLE
WE
CAN
CONVERT
ANY
POLYNOMIAL
P
XN
INTO
A
MULTILINEAR
POLYNOMIAL
Q
XN
I
E
THE
DEGREE
OF
Q
IN
ANY
VARIABLE
XI
IS
AT
MOST
ONE
THAT
AGREES
WITH
P
ON
ALL
XN
SPECIFICALLY
FOR
ANY
POLYNOMIAL
P
LET
LI
P
BE
THE
POLYNOMIAL
DEFINED
AS
FOLLOWS
LI
P
XN
XIP
XI
XI
XN
XI
P
XI
XI
XN
THEN
LN
P
IS
SUCH
A
MULTILINEAR
POLYNOMIAL
AGREEING
WITH
P
ON
ALL
VALUES
IN
WE
CAN
THUS
USE
O
INVOCATIONS
OPERATOR
TO
CONVERT
INTO
AN
EQUIVALENT
FORM
WHERE
ALL
THE
INTERMEDIATE
POLYNOMIALS
SENT
IN
THE
SUMCHECK
PROTOCOL
ARE
MULTILINEAR
WE
LL
USE
THIS
EQUIVALENT
FORM
TO
RUN
THE
SUMCHECK
PROTOCOL
WHERE
IN
ADDITION
TO
HAVING
ROUND
FOR
A
OR
OPERATOR
WE
LL
ALSO
HAVE
A
ROUND
FOR
EACH
APPLICATION
OF
THE
OPERATOR
L
IN
SUCH
ROUNDS
THE
PROVER
WILL
SEND
A
POLYNOMIAL
OF
DEGREE
AT
MOST
THE
POWER
OF
THE
PROVER
A
CURIOUS
FEATURE
OF
MANY
KNOWN
INTERACTIVE
PROOF
SYSTEMS
IS
THAT
IN
ORDER
TO
PROVE
MEMBERSHIP
IN
LANGUAGE
L
THE
PROVER
NEEDS
TO
DO
MORE
POWERFUL
COMPUTATION
THAN
JUST
DECIDING
MEMBERSHIP
IN
L
WE
GIVE
SOME
EXAMPLES
THE
PUBLIC
COIN
SYSTEM
FOR
GRAPH
NONISOMORPHISM
IN
THEOREM
REQUIRES
THE
PROVER
TO
PRODUCE
FOR
SOME
RANDOMLY
CHOSEN
HASH
FUNCTION
H
AND
A
RANDOM
ELEMENT
Y
IN
THE
RANGE
OF
H
A
GRAPH
H
SUCH
THAT
H
H
IS
ISOMORPHIC
TO
EITHER
OR
AND
H
X
Y
THIS
SEEMS
HARDER
THAN
JUST
SOLVING
GRAPH
NON
ISOMORPHISM
WEB
DRAFT
PROGRAM
CHECKING
THE
INTERACTIVE
PROOF
FOR
A
LANGUAGE
IN
CONP
REQUIRES
THE
PROVER
TO
DO
P
COMPU
TATIONS
DOING
SUMMATIONS
OF
EXPONENTIALLY
MANY
TERMS
RECALL
THAT
ALL
OF
PH
IS
IN
P
P
IN
BOTH
CASES
IT
IS
AN
OPEN
PROBLEM
WHETHER
THE
PROTOCOL
CAN
BE
REDESIGNED
TO
USE
A
WEAKER
PROVER
NOTE
THAT
THE
PROTOCOL
FOR
TQBF
IS
DIFFERENT
IN
THAT
THE
PROVER
REPLIES
CAN
BE
COMPUTED
IN
PSPACE
AS
WELL
THIS
OBSERVATION
UNDERLIES
THE
FOLLOWING
RESULT
WHICH
IS
IN
THE
SAME
SPIRIT
AS
THE
KARP
LIPTON
RESULTS
DESCRIBED
IN
CHAPTER
EXCEPT
THE
CONCLUSION
IS
STRONGER
SINCE
MA
IS
CONTAINED
IN
INDEED
A
PERFECTLY
COMPLETE
MA
PROOF
SYSTEM
FOR
L
TRIVIALLY
IMPLIES
THAT
L
THEOREM
IF
PSPACE
P
POLY
THEN
PSPACE
MA
PROOF
IF
PSPACE
P
POLY
THEN
THE
PROVER
IN
OUR
TQBF
PROTOCOL
CAN
BE
REPLACED
BY
A
CIRCUIT
OF
POLYNOMIAL
SIZE
MERLIN
THE
PROVER
CAN
JUST
GIVE
THIS
CIRCUIT
TO
ARTHUR
THE
VERIFIER
IN
ROUND
WHO
THEN
RUNS
THE
INTERACTIVE
PROOF
USING
THIS
PROVER
NO
MORE
INTERACTION
IS
NEEDED
NOTE
THAT
THERE
IS
NO
NEED
FOR
ARTHUR
TO
PUT
BLIND
TRUST
IN
MERLIN
CIRCUIT
SINCE
THE
CORRECTNESS
PROOF
OF
THE
TQBF
PROTOCOL
SHOWS
THAT
IF
THE
FORMULA
IS
NOT
TRUE
THEN
NO
PROVER
CAN
MAKE
ARTHUR
ACCEPT
WITH
HIGH
PROBABILITY
IN
FACT
USING
THE
KARP
LIPTON
THEOREM
ONE
CAN
PROVE
A
STRONGER
STATEMENT
SEE
LEMMA
BELOW
PROGRAM
CHECKING
THE
DISCOVERY
OF
THE
INTERACTIVE
PROTOCOL
FOR
THE
PERMANENT
PROBLEM
WAS
TRIGGERED
BY
A
FIELD
CALLED
PROGRAM
CHECKING
BLUM
AND
KANNAN
MOTIVATION
FOR
INTRODUCING
THIS
FIELD
WAS
THE
FACT
THAT
PROGRAM
VERIFICATION
DECIDING
WHETHER
OR
NOT
A
GIVEN
PROGRAM
SOLVES
A
CERTAIN
COMPUTATIONAL
TASK
IS
UNDECIDABLE
THEY
OBSERVED
THAT
IN
MANY
CASES
WE
CAN
GUARANTEE
A
WEAKER
GUARANTEE
OF
THE
PROGRAM
CORRECTNESS
ON
AN
INSTANCE
BY
INSTANCE
BASIS
THIS
IS
ENCAPSULATED
IN
THE
NOTION
OF
A
PROGRAM
CHECKER
A
CHECKER
C
FOR
A
PROGRAM
P
IS
ITSELF
ANOTHER
PROGRAM
THAT
MAY
RUN
P
AS
A
SUBROUTINE
WHENEVER
P
IS
RUN
ON
AN
INPUT
X
C
JOB
IS
TO
DETECT
IF
P
ANSWER
IS
INCORRECT
BUGGY
ON
THAT
PARTICULAR
INSTANCE
X
TO
DO
THIS
THE
CHECKER
MAY
ALSO
COMPUTE
P
ANSWER
ON
SOME
OTHER
INPUTS
PROGRAM
CHECKING
IS
SOMETIMES
ALSO
CALLED
INSTANCE
CHECKING
PERHAPS
A
MORE
ACCURATE
NAME
SINCE
THE
FACT
THAT
THE
CHECKER
DID
NOT
DETECT
A
BUG
DOES
NOT
MEAN
THAT
P
IS
A
CORRECT
PROGRAM
IN
GENERAL
BUT
ONLY
THAT
P
ANSWER
ON
X
IS
CORRECT
DEFINITION
LET
P
BE
A
CLAIMED
PROGRAM
FOR
COMPUTATIONAL
TASK
T
A
CHECKER
FOR
T
IS
A
PROBABILISTIC
POLYNOMIAL
TIME
TM
C
THAT
GIVEN
ANY
X
HAS
THE
FOLLOWING
BEHAVIOR
IF
P
IS
A
CORRECT
PROGRAM
FOR
T
I
E
Y
P
Y
T
Y
THEN
P
CP
ACCEPTS
P
X
IF
P
X
T
X
THEN
P
CP
ACCEPTS
P
X
DRAFT
WEB
DRAFT
PROGRAM
CHECKING
NOTE
THAT
IN
THE
CASE
THAT
P
IS
CORRECT
ON
X
I
E
P
X
C
X
BUT
THE
PROGRAM
P
IS
NOT
CORRECT
EVERYWHERE
THERE
IS
NO
GUARANTEE
ON
THE
OUTPUT
OF
THE
CHECKER
SURPRISINGLY
FOR
MANY
PROBLEMS
CHECKING
SEEMS
EASIER
THAN
ACTUALLY
COMPUTING
THE
PROBLEM
BLUM
AND
KANNAN
SUGGESTION
WAS
TO
BUILD
CHECKERS
INTO
THE
SOFTWARE
WHENEVER
THIS
IS
TRUE
THE
OVERHEAD
INTRODUCED
BY
THE
CHECKER
WOULD
BE
NEGLIGIBLE
EXAMPLE
CHECKER
FOR
GRAPH
NON
ISOMORPHISM
THE
INPUT
FOR
THE
PROBLEM
OF
GRAPH
NON
ISOMORPHISM
IS
A
PAIR
OF
LABELLED
GRAPHS
AND
THE
PROBLEM
IS
TO
DECIDE
WHETHER
AS
NOTED
WE
DO
NOT
KNOW
OF
AN
EFFICIENT
ALGORITHM
FOR
THIS
PROBLEM
BUT
IT
HAS
AN
EFFICIENT
CHECKER
THERE
ARE
TWO
TYPES
OF
INPUTS
DEPENDING
UPON
WHETHER
OR
NOT
THE
PROGRAM
CLAIMS
IF
IT
CLAIMS
THAT
THEN
ONE
CAN
CHANGE
THE
GRAPH
LITTLE
BY
LITTLE
AND
USE
THE
PROGRAM
TO
ACTUALLY
OBTAIN
THE
PERMUTATION

WE
NOW
SHOW
HOW
TO
CHECK
THE
CLAIM
THAT
USING
OUR
EARLIER
INTERACTIVE
PROOF
OF
GRAPH
NON
ISOMORPHISM
RECALL
THE
IP
FOR
GRAPH
NON
ISOMORPHISM
IN
CASE
PROVER
ADMITS
REPEAT
K
TIMES
CHOOSE
I
R
PERMUTE
GI
RANDOMLY
INTO
H
ASK
THE
PROVER
H
H
AND
CHECK
TO
SEE
IF
THE
PROVER
FIRST
ANSWER
IS
CONSISTENT
GIVEN
A
COMPUTER
PROGRAM
THAT
SUPPOSEDLY
COMPUTES
GRAPH
ISOMORPHISM
P
HOW
WOULD
WE
CHECK
ITS
CORRECTNESS
THE
PROGRAM
CHECKING
APPROACH
SUGGESTS
TO
USE
AN
IP
WHILE
REGARDING
THE
PROGRAM
AS
THE
PROVER
LET
C
BE
A
PROGRAM
THAT
PERFORMS
THE
ABOVE
PROTOCOL
WITH
P
AS
THE
PROVER
THEN
THEOREM
IF
P
IS
A
CORRECT
PROGRAM
FOR
GRAPH
NON
ISOMORPHISM
THEN
C
OUTPUTS
CORRECT
ALWAYS
OTHERWISE
IF
P
IS
INCORRECT
THEN
P
C
OUTPUTS
CORRECT
K
MOREOVER
C
RUNS
IN
POLYNOMIAL
TIME
LANGUAGES
THAT
HAVE
CHECKERS
WHENEVER
A
LANGUAGE
L
HAS
AN
INTERACTIVE
PROOF
SYSTEM
WHERE
THE
PROVER
CAN
BE
IMPLEMENTED
USING
ORACLE
ACCESS
TO
L
THIS
IMPLIES
THAT
L
HAS
A
CHECKER
THUS
THE
FOLLOWING
THEOREM
IS
A
DIRECT
CONSEQUENCE
OF
THE
INTERACTIVE
PROOFS
WE
HAVE
SEEN
THEOREM
THE
PROBLEMS
GRAPH
ISOMORPHISM
GI
PERMANENT
PERM
AND
TRUE
QUANTIFIED
BOOLEAN
FORMULAE
TQBF
HAVE
CHECKERS
USING
THE
FACT
THAT
P
COMPLETE
LANGUAGES
ARE
REDUCIBLE
TO
EACH
OTHER
VIA
NC
REDUCTIONS
IT
SUFFICES
TO
SHOW
A
CHECKER
IN
NC
FOR
ONE
P
COMPLETE
LANGUAGE
AS
WAS
SHOWN
BY
BLUM
KANNAN
TO
OBTAIN
THE
FOLLOWING
INTERESTING
FACT
WEB
DRAFT
MULTIPROVER
INTERACTIVE
PROOFS
MIP
THEOREM
FOR
ANY
P
COMPLETE
LANGUAGE
THERE
EXISTS
A
PROGRAM
CHECKER
IN
NC
SINCE
WE
BELIEVE
THAT
P
COMPLETE
LANGUAGES
CANNOT
BE
COMPUTED
IN
NC
THIS
PROVIDES
ADDITIONAL
EVIDENCE
THAT
CHECKING
IS
EASIER
THAN
ACTUAL
COMPUTATION
MULTIPROVER
INTERACTIVE
PROOFS
MIP
IT
IS
ALSO
POSSIBLE
TO
DEFINE
INTERACTIVE
PROOFS
THAT
INVOLVE
MORE
THAN
ONE
PROVER
THE
IMPORTANT
ASSUMPTION
IS
THAT
THE
PROVERS
DO
NOT
COMMUNICATE
WITH
EACH
OTHER
DURING
THE
PROTOCOL
THEY
MAY
COMMUNICATE
BEFORE
THE
PROTOCOL
STARTS
AND
IN
PARTICULAR
AGREE
UPON
A
SHARED
STRATEGY
FOR
ANSWERING
QUESTIONS
THE
ANALOGY
OFTEN
GIVEN
IS
THAT
OF
THE
POLICE
INTERROGATING
TWO
SUSPECTS
IN
SEPARATE
ROOMS
THE
SUSPECTS
MAY
BE
ACCOMPLICES
WHO
HAVE
DECIDED
UPON
A
COMMON
STORY
TO
TELL
THE
POLICE
BUT
SINCE
THEY
ARE
INTERROGATED
SEPARATELY
THEY
MAY
INADVERTENTLY
REVEAL
AN
INCONSISTENCY
IN
THE
STORY
THE
SET
OF
LANGUAGES
WITH
MULTIPROVER
INTERACTIVE
PROVERS
IS
CALL
MIP
THE
FORMAL
DEFINITION
IS
ANALOGOUS
TO
DEFINITION
WE
ASSUME
THERE
ARE
TWO
PROVERS
THOUGH
ONE
CAN
ALSO
STUDY
THE
CASE
OF
POLYNOMIALLY
MANY
PROVERS
SEE
THE
EXERCISES
AND
IN
EACH
ROUND
THE
VERIFIER
SENDS
A
QUERY
TO
EACH
OF
THEM
THE
TWO
QUERIES
NEED
NOT
BE
THE
SAME
EACH
PROVER
SENDS
A
RESPONSE
IN
EACH
ROUND
CLEARLY
IP
MIP
SINCE
WE
CAN
ALWAYS
SIMPLY
IGNORE
ONE
PROVER
HOWEVER
IT
TURNS
OUT
THAT
MIP
IS
PROBABLY
STRICTLY
LARGER
THAN
IP
UNLESS
PSPACE
NEXP
THAT
IS
WE
HAVE
THEOREM
NEXP
MIP
WE
WILL
OUTLINE
A
PROOF
OF
THIS
THEOREM
IN
CHAPTER
ONE
THING
THAT
WE
CAN
DO
USING
TWO
ROUNDS
IS
TO
FORCE
NON
ADAPTIVITY
THAT
IS
CONSIDER
THE
INTERACTIVE
PROOF
AS
AN
INTERROGATION
WHERE
THE
VERIFIER
ASKS
QUESTIONS
AND
GETS
BACK
ANSWERS
FROM
THE
PROVER
IF
THE
VERIFIER
WANTS
TO
ENSURE
THAT
THE
ANSWER
OF
A
PROVER
TO
THE
QUESTION
Q
IS
A
FUNCTION
ONLY
OF
Q
AND
DOES
NOT
DEPEND
ON
THE
PREVIOUS
QUESTIONS
THE
PROVER
HEARD
THE
PROVER
CAN
ASK
THE
SECOND
PROVER
THE
QUESTION
Q
AND
ACCEPT
ONLY
IF
BOTH
ANSWERS
AGREE
WITH
ONE
ANOTHER
THIS
TECHNIQUE
WAS
USED
TO
SHOW
THAT
MULTI
PROVER
INTERACTIVE
PROOFS
CAN
BE
USED
TO
IMPLEMENT
AND
IN
FACT
ARE
EQUIVALENT
TO
A
MODEL
OF
A
PROBABILISTICALLY
CHECKABLE
PROOF
IN
THE
SKY
IN
THIS
MODEL
WE
GO
BACK
TO
AN
NP
LIKE
NOTION
OF
A
PROOF
AS
A
STATIC
STRING
BUT
THIS
STRING
MAY
BE
HUGE
AND
SO
IS
BEST
THOUGHT
OF
AS
A
HUGE
TABLE
CONSISTING
OF
THE
PROVER
ANSWERS
TO
ALL
THE
POSSIBLE
VERIFIER
QUESTIONS
THE
VERIFIER
CHECKS
THE
PROOF
BY
LOOKING
AT
ONLY
A
FEW
ENTRIES
IN
THIS
TABLE
THAT
ARE
CHOSEN
RANDOMLY
FROM
SOME
DISTRIBUTION
IF
WE
LET
THE
CLASS
PCP
R
Q
BE
THE
SET
OF
LANGUAGES
THAT
CAN
BE
PROVEN
USING
A
TABLE
OF
SIZE
AND
Q
QUERIES
TO
THIS
TABLE
THEN
THEOREM
CAN
BE
RESTATED
AS
THEOREM
THEOREM
RESTATED
NEXP
PCP
POLY
POLY
CPCP
NC
NC
IT
TURNS
OUT
THEOREM
CAN
BE
SCALED
DOWN
TO
TO
OBTAIN
NP
PCP
POLYLOG
POLYLOG
IN
FACT
WITH
A
LOT
OF
WORK
THE
FOLLOWING
IS
KNOWN
DRAFT
WEB
DRAFT
MULTIPROVER
INTERACTIVE
PROOFS
MIP
THEOREM
THE
PCP
THEOREM
ALM
NP
PCP
O
LOG
N
O
THIS
THEOREM
WHICH
WILL
BE
PROVEN
IN
CHAPTER
HAS
HAD
MANY
APPLICATIONS
IN
COMPLEXITY
AND
IN
PARTICULAR
ESTABLISHING
THAT
FOR
MANY
NP
COMPLETE
OPTIMIZATION
PROBLEMS
OBTAINING
AN
APPROXIMATELY
OPTIMAL
SOLUTION
IS
AS
HARD
AS
COMING
UP
WITH
THE
OPTIMAL
SOLUTION
ITSELF
THUS
IT
SEEMS
THAT
COMPLEXITY
THEORY
HAS
GONE
A
FULL
CIRCLE
WITH
INTERACTIVE
PROOFS
BY
ADDING
INTERACTION
RANDOMIZATION
AND
MULTIPLE
PROVERS
AND
GETTING
TO
CLASSES
AS
HIGH
AS
NEXP
WE
HAVE
GAINED
NEW
AND
FUNDAMENTAL
INSIGHTS
ON
THE
CLASS
NP
THE
REPRESENTS
STATIC
DETERMINISTIC
PROOFS
OR
EQUIVALENTLY
EFFICIENTLY
VERIFIABLE
SEARCH
PROBLEMS
CHAPTER
NOTES
AND
HISTORY
INTERACTIVE
PROOFS
WERE
DEFINED
IN
BY
GOLDWASSER
MICALI
RACKOFF
FOR
CRYPTOGRAPHIC
APPLICATIONS
AND
INDEPENDENTLY
AND
USING
THE
PUBLIC
COIN
DEFINITION
BY
BABAI
AND
MORAN
THE
PRIVATE
COINS
INTERACTIVE
PROOF
FOR
GRAPH
NON
ISOMORPHISM
WAS
GIVEN
BY
GOLDREICH
MICALI
AND
WIGDERSON
SIMULATIONS
OF
PRIVATE
COINS
BY
PUBLIC
COINS
WE
GIVEN
BY
GOLDWASSER
AND
SIPSER
THE
GENERAL
FEELING
AT
THE
TIME
WAS
THAT
INTERACTIVE
PROOFS
ARE
ONLY
A
SLIGHT
EXTENSION
OF
NP
AND
THAT
NOT
EVEN
HAS
INTERACTIVE
PROOFS
THE
RESULT
IP
PSPACE
WAS
A
BIG
SURPRISE
AND
THE
STORY
OF
ITS
DISCOVERY
IS
VERY
INTERESTING
IN
THE
LATE
BLUM
AND
KANNAN
INTRODUCED
THE
NOTION
OF
PROGRAM
CHECKING
AROUND
THE
SAME
TIME
MANUSCRIPTS
OF
BEAVER
AND
FEIGENBAUM
AND
LIPTON
APPEARED
IN
SPIRED
BY
SOME
OF
THESE
DEVELOPMENTS
NISAN
PROVED
IN
DECEMBER
THAT
SAT
HAS
MULTIPROVER
INTERACTIVE
PROOFS
HE
ANNOUNCED
HIS
PROOF
IN
AN
EMAIL
TO
SEVERAL
COLLEAGUES
AND
THEN
LEFT
ON
VA
CATION
TO
SOUTH
AMERICA
THIS
EMAIL
MOTIVATED
A
FLURRY
OF
ACTIVITY
IN
RESEARCH
GROUPS
AROUND
THE
WORLD
LUND
FORTNOW
KARLOFF
SHOWED
THAT
SAT
IS
IN
IP
THEY
ADDED
NISAN
AS
A
COAUTHOR
AND
THE
FINAL
PAPER
IS
THEN
SHAMIR
SHOWED
THAT
IP
PSPACE
AND
BABAI
FORTNOW
AND
LUND
SHOWED
MIP
NEXP
THE
ENTIRE
STORY
AS
WELL
AS
RELATED
DEVELOPMENTS
ARE
DESCRIBED
IN
BABAI
ENTERTAINING
SURVEY
VADHAN
EXPLORES
SOME
QUESTIONS
RELATED
TO
THE
POWER
OF
THE
PROVER
WEB
DRAFT
MULTIPROVER
INTERACTIVE
PROOFS
MIP
THE
RESULT
THAT
APPROXIMATING
THE
SHORTEST
VECTOR
IS
PROBABLY
NOT
NP
HARD
AS
MENTIONED
IN
THE
INTRODUCTION
IS
DUE
TO
GOLDREICH
AND
GOLDWASSER
EXERCISES
PROVE
THE
ASSERTIONS
IN
REMARK
THAT
IS
PROVE
A
LET
IPI
DENOTE
THE
CLASS
OBTAINED
BY
ALLOWING
THE
PROVER
TO
BE
PROBABILISTIC
IN
DEFINI
TION
THAT
IS
THE
PROVER
STRATEGY
CAN
BE
CHOSEN
AT
RANDOM
FROM
SOME
DISTRIBUTION
ON
FUNCTIONS
PROVE
THAT
IPI
IP
B
PROVE
THAT
IP
PSPACE
C
LET
IPI
DENOTE
THE
CLASS
OBTAINED
BY
CHANGING
THE
CONSTANT
IN
AND
TO
X
PROVE
THAT
IPI
IP
D
LET
IPI
DENOTE
THE
CLASS
OBTAINED
BY
CHANGING
THE
CONSTANT
IN
TO
PROVE
THAT
IPI
IP
E
LET
IPI
DENOTE
THE
CLASS
OBTAINED
BY
CHANGING
THE
CONSTANT
IN
TO
PROVE
THAT
IPI
NP
WE
SAY
INTEGER
Y
IS
A
QUADRATIC
RESIDUE
MODULO
M
IF
THERE
IS
AN
INTEGER
X
SUCH
THAT
Y
MOD
M
SHOW
THAT
THE
FOLLOWING
LANGUAGE
IS
IN
IP
QNR
Y
M
Y
IS
NOT
A
QUADRATIC
RESIDUE
MODULO
M
PROVE
THAT
THERE
EXISTS
A
PERFECTLY
COMPLETE
AM
O
PROTOCOL
FOR
THE
PROVING
A
LOWERBOUND
ON
SET
SIZE
PROVE
THAT
FOR
EVERY
CONSTANT
K
AM
K
AM
K
SHOW
THAT
AM
BP
NP
SHOW
THAT
IF
EXP
P
POLY
THEN
EXP
MA
DRAFT
WEB
DRAFT
A
INTERACTIVE
PROOF
FOR
THE
PERMANENT
SHOW
THAT
THE
PROBLEM
GI
IS
DOWNWARD
SELF
REDUCIBLE
THAT
IS
PROVE
THAT
GIVEN
TWO
GRAPHS
ON
N
VERTICES
AND
ACCESS
TO
A
SUBROUTINE
P
THAT
SOLVES
THE
GI
PROBLEM
ON
GRAPHS
WITH
UP
TO
N
VERTICES
WE
CAN
DECIDE
WHETHER
OR
NOT
AND
ARE
ISOMORPHIC
IN
POLYNOMIAL
TIME
PROVE
THAT
IN
THE
CASE
THAT
AND
ARE
ISOMORPHIC
WE
CAN
OBTAIN
THE
PERMUTATION

MAPPING
TO
USING
THE
PROCEDURE
OF
THE
ABOVE
EXERCISE
USE
THIS
TO
COMPLETE
THE
PROOF
IN
EXAMPLE
AND
SHOW
THAT
GRAPH
ISOMORPHISM
HAS
A
CHECKER
SPECIFICALLY
YOU
HAVE
TO
SHOW
THAT
IF
THE
PROGRAM
CLAIMS
THAT
THEN
WE
CAN
DO
SOME
FURTHER
INVESTIGATION
INCLUDING
CALLING
THE
PROGRAMS
ON
OTHER
INPUTS
AND
WITH
HIGH
PROBABILITY
CONCLUDE
THAT
EITHER
A
CONCLUDE
THAT
THE
PROGRAM
WAS
RIGHT
ON
THIS
INPUT
OR
B
THE
PROGRAM
IS
WRONG
ON
SOME
INPUT
AND
HENCE
IS
NOT
A
CORRECT
PROGRAM
FOR
GRAPH
ISOMORPHISM
DEFINE
A
LANGUAGE
L
TO
BE
DOWNWARD
SELF
REDUCIBLE
THERE
A
POLYNOMIAL
TIME
ALGORITHM
R
THAT
FOR
ANY
N
AND
X
N
RLN
X
L
X
WHERE
BY
LK
WE
DENOTE
AN
ORACLE
THAT
SOLVES
L
ON
INPUTS
OF
SIZE
AT
MOST
K
PROVE
THAT
IF
L
IS
DOWNWARD
SELF
REDUCIBLE
THAN
L
PSPACE
SHOW
THAT
MIP
NEXP
SHOW
THAT
IF
WE
REDEFINE
MULTIPROVER
INTERACTIVE
PROOFS
TO
ALLOW
INSTEAD
OF
TWO
PROVERS
AS
MANY
AS
M
N
POLY
N
PROVERS
ON
INPUTS
OF
SIZE
N
THEN
THE
CLASS
MIP
IS
UNCHANGED
A
INTERACTIVE
PROOF
FOR
THE
PERMANENT
THE
PERMANENT
IS
DEFINED
AS
FOLLOWS
DEFINITION
LET
A
F
N
N
BE
A
MATRIX
OVER
THE
FIELD
F
THE
PERMANENT
OF
A
IS
N
PERM
A
AI

I

SN
I
THE
PROBLEM
OF
CALCULATING
THE
PERMANENT
IS
CLEARLY
IN
PSPACE
IN
CHAPTER
WE
WILL
SEE
THAT
IF
THE
PERMANENT
CAN
BE
COMPUTED
IN
POLYNOMIAL
TIME
THEN
P
NP
AND
HENCE
THIS
PROBLEM
LIKELY
DOES
NOT
HAVE
A
POLYNOMIAL
TIME
ALGORITHM
ALTHOUGH
THE
EXISTENCE
OF
AN
INTERACTIVE
PROOF
FOR
THE
PERMANENT
FOLLOWS
FROM
THAT
FOR
SAT
AND
TQBF
WE
DESCRIBE
A
SPECIALIZED
PROTOCOL
AS
WELL
THIS
IS
BOTH
FOR
HISTORICAL
CONTEXT
THIS
PROTOCOL
WAS
DISCOVERED
BEFORE
THE
OTHER
TWO
PROTOCOLS
AND
ALSO
BECAUSE
THIS
PROTOCOL
MAY
BE
HELPFUL
FOR
FURTHER
RESEARCH
ONE
EXAMPLE
WILL
APPEAR
IN
A
LATER
CHAPTER
WEB
DRAFT
A
INTERACTIVE
PROOF
FOR
THE
PERMANENT
WE
USE
THE
FOLLOWING
OBSERVATION
N
F
XN
PERM
N
IS
A
DEGREE
N
POLYNOMIAL
SINCE
XN
XN
XN
N
N
F
XN
XI

I

SN
I
WE
NOW
SHOW
TWO
PROPERTIES
OF
THE
PERMANENT
PROBLEM
THE
FIRST
IS
RANDOM
SELF
REDUCIBILITY
EARLIER
ENCOUNTERED
IN
SECTION
THEOREM
LIPTON
THERE
IS
A
RANDOMIZED
ALGORITHM
THAT
GIVEN
AN
ORACLE
THAT
CAN
COMPUTE
THE
PERMANENT
ON
FRACTION
OF
THE
INPUTS
IN
F
N
N
WHERE
THE
FINITE
FIELD
F
HAS
SIZE
CAN
COMPUTE
THE
PERMANENT
ON
ALL
INPUTS
CORRECTLY
WITH
HIGH
PROBABILITY
PROOF
LET
A
BE
SOME
INPUT
MATRIX
PICK
A
RANDOM
MATRIX
R
R
F
N
N
AND
LET
B
X
A
X
R
FOR
A
VARIABLE
X
NOTICE
THAT
F
X
PERM
B
IS
A
DEGREE
N
UNIVARIATE
POLYNOMIAL
FOR
ANY
FIXED
B
B
B
IS
A
RANDOM
MATRIX
HENCE
THE
PROBABILITY
THAT
ORACLE
COMPUTES
PERM
B
B
CORRECTLY
IS
AT
LEAST
NOW
THE
ALGORITHM
FOR
COMPUTING
THE
PERMANENT
OF
A
IS
STRAIGHTFORWARD
QUERY
ORACLE
ON
ALL
MATRICES
B
I
I
N
ACCORDING
TO
THE
UNION
BOUND
WITH
PROBABILITY
OF
AT
LEAST
N
THE
ORACLE
WILL
COMPUTE
THE
PERMANENT
CORRECTLY
ON
ALL
MATRICES
RECALL
THE
FACT
SEE
SECTION
IN
APPENDIX
A
THAT
GIVEN
N
POINT
VALUE
PAIRS
AI
BI
I
N
THERE
EXISTS
A
UNIQUE
A
DEGREE
N
POLYNOMIAL
P
THAT
SATISFIES
I
P
AI
BI
THEREFORE
GIVEN
THAT
THE
VALUES
B
I
ARE
CORRECT
THE
ALGORITHM
CAN
INTERPOLATE
THE
POLYNOMIAL
B
X
AND
COMPUTE
B
A
NOTE
THE
ABOVE
THEOREM
CAN
BE
STRENGTHENED
TO
BE
BASED
ON
THE
ASSUMPTION
THAT
THE
ORACLE
CAN
COMPUTE
THE
PERMANENT
ON
A
FRACTION
OF

FOR
ANY
CONSTANT

OF
THE
INPUTS
THE
OBSERVATION
IS
THAT
NOT
ALL
VALUES
OF
THE
POLYNOMIAL
MUST
BE
CORRECT
FOR
UNIQUE
INTERPOLATION
SEE
CHAPTER
ANOTHER
PROPERTY
OF
THE
PERMANENT
PROBLEM
IS
DOWNWARD
SELF
REDUCIBILITY
ENCOUNTERED
EARLIER
IN
CONTEXT
OF
SAT
N
PERM
A
I
I
WHERE
I
IS
A
N
N
SUB
MATRIX
OF
A
OBTAINED
BY
REMOVING
THE
ST
ROW
AND
I
TH
COLUMN
OF
A
RECALL
THE
ANALOGOUS
FORMULA
FOR
THE
DETERMINANT
USES
ALTERNATING
SIGNS
DRAFT
WEB
DRAFT
A
INTERACTIVE
PROOF
FOR
THE
PERMANENT
DEFINITION
DEFINE
A
N
N
MATRIX
DA
X
SUCH
THAT
EACH
ENTRY
CONTAINS
A
DEGREE
N
POLYNOMIAL
THIS
POLYNOMIAL
IS
UNIQUELY
DEFINED
BY
THE
VALUES
OF
THE
MATRICES
I
I
N
THAT
IS
I
N
DA
I
I
WHERE
DA
I
IS
THE
MATRIX
DA
X
WITH
I
SUBSTITUTED
FOR
X
NOTICE
THAT
THESE
EQUALITIES
FORCE
N
POINTS
AND
VALUES
ON
THEM
FOR
EACH
POLYNOMIAL
AT
A
CERTAIN
ENTRY
OF
DA
X
AND
HENCE
ACCORDING
TO
THE
PREVIOUSLY
MENTIONED
FACT
DETERMINE
THIS
POLYNOMIAL
UNIQUELY
OBSERVATION
PERM
DA
X
IS
A
DEGREE
N
N
POLYNOMIAL
IN
X
A
THE
PROTOCOL
WE
NOW
SHOW
AN
INTERACTIVE
PROOF
FOR
THE
PERMANENT
THE
DECISION
PROBLEM
IS
WHETHER
PERM
A
K
FOR
SOME
VALUE
K
ROUND
PROVER
SENDS
TO
VERIFIER
A
POLYNOMIAL
G
X
OF
DEGREE
N
N
WHICH
IS
SUPPOSEDLY
PERM
DA
X
ROUND
VERIFIER
CHECKS
WHETHER
M
K
IG
I
I
IF
NOT
REJECTS
AT
ONCE
OTHERWISE
VERIFIER
PICKS
A
RANDOM
ELEMENT
OF
THE
FIELD
R
F
AND
ASKS
THE
PROVER
TO
PROVE
THAT
G
PERM
DA
THIS
REDUCES
THE
MATRIX
DIMENSION
TO
N
N
ROUND
N
PROVER
SENDS
TO
VERIFIER
A
POLYNOMIAL
OF
DEGREE
WHICH
IS
SUPPOSEDLY
THE
PERMANENT
OF
A
MATRIX
ROUND
N
VERIFIER
IS
LEFT
WITH
A
MATRIX
AND
CALCULATES
THE
PERMANENT
OF
THIS
MATRIX
AND
DECIDES
APPROPRIATELY
CLAIM
THE
ABOVE
PROTOCOL
IS
INDEED
AN
INTERACTIVE
PROOF
FOR
PERM
PROOF
IF
PERM
A
K
THEN
THERE
EXISTS
A
PROVER
THAT
MAKES
THE
VERIFIER
ACCEPT
WITH
PROBABILITY
THIS
PROVER
JUST
RETURNS
THE
CORRECT
VALUES
OF
THE
POLYNOMIALS
ACCORDING
TO
DEFINITION
ON
THE
OTHER
HAND
SUPPOSE
THAT
PERM
A
K
IF
ON
THE
FIRST
ROUND
THE
POLYNOMIAL
G
X
SENT
IS
THE
CORRECT
POLYNOMIAL
DA
X
THEN
K
IG
I
PERM
A
WEB
DRAFT
A
INTERACTIVE
PROOF
FOR
THE
PERMANENT
AND
THE
VERIFIER
WOULD
REJECT
HENCE
G
X
DA
X
ACCORDING
TO
THE
FACT
ON
POLYNOMIALS
STATED
ABOVE
THESE
POLYNOMIALS
CAN
AGREE
ON
AT
MOST
N
N
POINTS
HENCE
THE
PROBABILITY
THAT
THEY
WOULD
AGREE
ON
THE
RANDOMLY
CHOSEN
POINT
IS
AT
MOST
N
N
THE
SAME
CONSIDERATIONS
APPLY
TO
ALL
SUBSEQUENT
ROUNDS
IF
EXIST
AND
THE
OVERALL
PROBABILITY
THAT
THE
VERIFIER
WILL
NOT
ACCEPTS
IS
THUS
ASSUMING
F
AND
SUFFICIENTLY
LARGE
N
P
R
N
N
N
N
F
N
N
F
F
F
DRAFT
WEB
DRAFT
CHAPTER
COMPLEXITY
OF
COUNTING
IT
IS
AN
EMPIRICAL
FACT
THAT
FOR
MANY
COMBINATORIAL
PROBLEMS
THE
DETECTION
OF
THE
EXISTENCE
OF
A
SOLUTION
IS
EASY
YET
NO
COMPUTATIONALLY
EFFICIENT
METHOD
IS
KNOWN
FOR
COUNTING
THEIR
NUMBER
FOR
A
VARIETY
OF
PROBLEMS
THIS
PHENOMENON
CAN
BE
EXPLAINED
L
VALIANT
THE
CLASS
NP
CAPTURES
THE
DIFFICULTY
OF
FINDING
CERTIFICATES
HOWEVER
IN
MANY
CONTEXTS
ONE
IS
INTERESTED
NOT
JUST
IN
A
SINGLE
CERTIFICATE
BUT
ACTUALLY
COUNTING
THE
NUMBER
OF
CERTIFICATES
THIS
CHAPTER
STUDIES
P
PRONOUNCED
SHARP
P
A
COMPLEXITY
CLASS
THAT
CAPTURES
THIS
NOTION
COUNTING
PROBLEMS
ARISE
IN
DIVERSE
FIELDS
OFTEN
IN
SITUATIONS
HAVING
TO
DO
WITH
ESTIMATIONS
OF
PROBABILITY
EXAMPLES
INCLUDE
STATISTICAL
ESTIMATION
STATISTICAL
PHYSICS
NETWORK
DESIGN
AND
MORE
COUNTING
PROBLEMS
ARE
ALSO
STUDIED
IN
A
FIELD
OF
MATHEMATICS
CALLED
ENUMERATIVE
COMBINATORICS
WHICH
TRIES
TO
OBTAIN
CLOSED
FORM
MATHEMATICAL
EXPRESSIONS
FOR
COUNTING
PROBLEMS
TO
GIVE
AN
EXAMPLE
IN
THE
CENTURY
KIRCHOFF
SHOWED
HOW
TO
COUNT
THE
NUMBER
OF
SPANNING
TREES
IN
A
GRAPH
USING
A
SIMPLE
DETERMINANT
COMPUTATION
RESULTS
IN
THIS
CHAPTER
WILL
SHOW
THAT
FOR
MANY
NATURAL
COUNTING
PROBLEMS
SUCH
EFFICIENTLY
COMPUTABLE
EXPRESSIONS
ARE
UNLIKELY
TO
EXIST
HERE
IS
AN
EXAMPLE
THAT
SUGGESTS
HOW
COUNTING
PROBLEMS
CAN
ARISE
IN
ESTIMATIONS
OF
PROBABILITY
EXAMPLE
IN
THE
GRAPHRELIABILITY
PROBLEM
WE
ARE
GIVEN
A
DIRECTED
GRAPH
ON
N
NODES
SUPPOSE
WE
ARE
TOLD
THAT
EACH
NODE
CAN
FAIL
WITH
PROBABILITY
AND
WANT
TO
COMPUTE
THE
PROBABILITY
THAT
NODE
HAS
A
PATH
TO
N
A
MOMENT
THOUGHT
SHOWS
THAT
UNDER
THIS
SIMPLE
EDGE
FAILURE
MODEL
THE
REMAINING
GRAPH
IS
UNIFORMLY
CHOSEN
AT
RANDOM
FROM
ALL
SUBGRAPHS
OF
THE
ORIGINAL
GRAPH
THUS
THE
CORRECT
ANSWER
IS
NUMBER
OF
SUBGRAPHS
IN
WHICH
NODE
HAS
A
PATH
TO
N
WE
CAN
VIEW
THIS
AS
A
COUNTING
VERSION
OF
THE
PATH
PROBLEM
DRAFT
THE
CLASS
P
IN
THE
REST
OF
THE
CHAPTER
WE
STUDY
THE
COMPLEXITY
CLASS
P
A
CLASS
CONTAINING
THE
GRAPHRELIABILITY
PROBLEM
AND
MANY
OTHER
INTERESTING
COUNTING
PROBLEMS
WE
WILL
SHOW
THAT
IT
HAS
A
NATURAL
AND
IMPORTANT
COMPLETE
PROBLEM
NAMELY
THE
PROBLEM
OF
COMPUTING
THE
PERMANENT
OF
A
GIVEN
MATRIX
WE
ALSO
SHOW
A
SURPRISING
CONNECTION
BETWEEN
PH
AND
P
CALLED
TODA
THEOREM
ALONG
THE
WAY
WE
ENCOUNTER
RELATED
COMPLEXITY
CLASSES
SUCH
AS
PP
AND
P
THE
CLASS
P
WE
NOW
DEFINE
THE
CLASS
P
NOTE
THAT
IT
CONTAINS
FUNCTIONS
WHOSE
OUTPUT
IS
A
NATURAL
NUMBER
AND
NOT
JUST
REMARK
AS
IN
THE
CASE
OF
NP
WE
CAN
ALSO
DEFINE
P
USING
NON
DETERMINISTIC
TMS
THAT
IS
P
CONSISTS
OF
ALL
FUNCTIONS
F
SUCH
THAT
F
X
IS
EQUAL
TO
THE
NUMBER
OF
PATHS
FROM
THE
INITIAL
CONFIGURATION
TO
AN
ACCEPTING
CONFIGURATION
IN
THE
CONFIGURATION
GRAPH
GM
X
OF
A
POLYNOMIAL
TIME
NDTM
M
THE
BIG
OPEN
QUESTION
REGARDING
P
IS
WHETHER
ALL
PROBLEMS
IN
THIS
CLASS
ARE
EFFICIENTLY
SOLVABLE
IN
OTHER
WORDS
WHETHER
P
FP
RECALL
THAT
FP
IS
THE
ANALOG
OF
THE
CLASS
P
FOR
FUNCTIONS
WITH
MORE
THAN
ONE
BIT
OF
OUTPUT
THAT
IS
FP
IS
THE
SET
OF
FUNCTIONS
FROM
TO
COMPUTABLE
BY
A
DETERMINISTIC
POLYNOMIAL
TIME
TURING
MACHINE
THINKING
OF
THE
OUTPUT
AS
THE
BINARY
REPRESENTATION
OF
AN
INTEGER
WE
CAN
IDENTIFY
SUCH
FUNCTIONS
WITH
FUNCTIONS
FROM
TO
N
SINCE
COMPUTING
THE
NUMBER
OF
CERTIFICATES
IS
AT
LEAST
AS
HARD
AS
FINDING
OUT
WHETHER
A
CERTIFICATE
EXISTS
IF
P
FP
THEN
NP
P
WE
DO
NOT
KNOW
WHETHER
THE
OTHER
DIRECTION
ALSO
HOLDS
WHETHER
NP
P
IMPLIES
THAT
P
FP
WE
DO
KNOW
THAT
IF
PSPACE
P
THEN
P
FP
SINCE
COUNTING
THE
NUMBER
OF
CERTIFICATES
CAN
BE
DONE
IN
POLYNOMIAL
SPACE
HERE
ARE
TWO
MORE
EXAMPLES
FOR
PROBLEMS
IN
P
SAT
IS
THE
PROBLEM
OF
COMPUTING
GIVEN
A
BOOLEAN
FORMULA

THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
FOR

CYCLE
IS
THE
PROBLEM
OF
COMPUTING
GIVEN
A
DIRECTED
GRAPH
G
THE
NUMBER
OF
SIMPLE
CYCLES
IN
G
A
SIMPLE
CYCLE
IS
ONE
THAT
DOES
NOT
VISIT
ANY
VERTEX
TWICE
CLEARLY
IF
SAT
FP
THEN
SAT
P
AND
SO
P
NP
THUS
PRESUMABLY
SAT
FP
HOW
ABOUT
CYCLE
THE
CORRESPONDING
DECISION
PROBLEM
GIVEN
A
DIRECTED
GRAPH
DECIDE
IF
IT
HAS
A
DRAFT
WEB
DRAFT
THE
CLASS
P
CYCLE
CAN
BE
SOLVED
IN
LINEAR
TIME
BY
BREADTH
FIRST
SEARCH
THE
NEXT
THEOREM
SUGGESTS
THAT
THE
COUNTING
PROBLEM
MAY
BE
MUCH
HARDER
U
V
M
FIGURE
REDUCING
HAM
TO
CYCLE
BY
REPLACING
EVERY
EDGE
IN
G
WITH
THE
ABOVE
GADGET
TO
OBTAIN
G
EVERY
SIMPLE
CYCLE
OF
LENGTH
IN
G
BECOMES
SIMPLE
CYCLES
IN
G
THEOREM
IF
CYCLE
FP
THEN
P
NP
PROOF
WE
SHOW
THAT
IF
CYCLE
CAN
BE
COMPUTED
IN
POLYNOMIAL
TIME
THEN
HAM
P
WHERE
HAM
IS
THE
NP
COMPLETE
PROBLEM
OF
DECIDING
WHETHER
OR
NOT
A
GIVEN
DIGRAPH
HAS
A
HAMILTONIAN
CYCLE
I
E
A
SIMPLE
CYCLE
THAT
VISITS
ALL
THE
VERTICES
IN
THE
GRAPH
GIVEN
A
GRAPH
G
WITH
N
VERTICES
WE
CONSTRUCT
A
GRAPH
GI
SUCH
THAT
G
HAS
A
HAMILTONIAN
CYCLE
IFF
GI
HAS
AT
LEAST
CYCLES
TO
OBTAIN
GI
REPLACE
EACH
EDGE
U
V
IN
G
BY
THE
GADGET
SHOWN
IN
FIGURE
THE
GADGET
HAS
M
N
LOG
N
LEVELS
IT
IS
AN
ACYCLIC
DIGRAPH
SO
CYCLES
IN
GI
CORRESPOND
TO
CYCLES
IN
G
FURTHERMORE
THERE
ARE
DIRECTED
PATHS
FROM
U
TO
V
IN
THE
GADGET
SO
A
SIMPLE
CYCLE
OF
LENGTH
IN
G
YIELDS
C
SIMPLE
CYCLES
IN
GI
NOTICE
IF
G
HAS
A
HAMILTONIAN
CYCLE
THEN
GI
HAS
AT
LEAST
N
CYCLES
IF
G
HAS
NO
HAMILTONIAN
CYCLE
THEN
THE
LONGEST
CYCLE
IN
G
HAS
LENGTH
AT
MOST
N
THE
NUMBER
OF
CYCLES
IS
BOUNDED
ABOVE
BY
NN
SO
GI
CAN
HAVE
AT
MOST
N
NN
NN
CYCLES
THE
CLASS
PP
DECISION
PROBLEM
ANALOG
FOR
P
SIMILAR
TO
THE
CASE
OF
SEARCH
PROBLEMS
EVEN
WHEN
STUDYING
COUNTING
COMPLEXITY
WE
CAN
OFTEN
RESTRICT
OUR
ATTENTION
TO
DECISION
PROBLEMS
THE
REASON
IS
THAT
THERE
EXISTS
A
CLASS
OF
DECISION
PROBLEMS
PP
SUCH
THAT
PP
P
P
FP
INTUITIVELY
PP
CORRESPONDS
TO
COMPUTING
THE
MOST
SIGNIFICANT
BIT
OF
FUNCTIONS
IN
P
THAT
IS
L
IS
IN
PP
IF
THERE
EXISTS
A
POLYNOMIAL
TIME
TM
M
AND
A
POLYNOMIAL
P
N
N
SUCH
THAT
FOR
EVERY
X
X
L
P
X
M
X
Y
X
YOU
ARE
ASKED
TO
PROVE
THE
NON
TRIVIAL
DIRECTION
OF
IN
EXERCISE
IT
IS
INSTRUCTIVE
TO
COMPARE
THE
CLASS
PP
WHICH
WE
BELIEVE
CONTAINS
PROBLEM
REQUIRING
EXPONENTIAL
TIME
TO
SOLVE
WITH
THE
CLASS
BPP
WHICH
ALTHOUGH
IT
HAS
A
SEEMINGLY
SIMILAR
DEFINITION
CAN
IN
FACT
BE
SOLVED
EFFICIENTLY
USING
PROBABILISTIC
ALGORITHMS
AND
PERHAPS
EVEN
ALSO
USING
DETERMINISTIC
ALGORITHMS
SEE
CHAPTER
NOTE
THAT
WE
DO
NOT
KNOW
WHETHER
THIS
HOLDS
ALSO
FOR
THE
CLASS
OF
DECISION
PROBLEMS
CORRESPONDING
TO
THE
LEAST
SIGNIFICANT
BIT
OF
P
NAMELY
P
SEE
DEFINITION
BELOW
WEB
DRAFT
P
COMPLETENESS
P
COMPLETENESS
NOW
WE
DEFINE
P
COMPLETENESS
LOOSELY
SPEAKING
A
FUNCTION
F
IS
P
COMPLETE
IF
IT
IS
IN
P
AND
A
POLYNOMIAL
TIME
ALGORITHM
FOR
F
IMPLIES
THAT
P
FP
TO
FORMALLY
DEFINE
P
COMPLETENESS
WE
USE
THE
NOTION
OF
ORACLE
TMS
AS
DEFINED
IN
SECTION
RECALL
THAT
A
TM
M
HAS
ORACLE
ACCESS
TO
A
LANGUAGE
O
IF
IT
CAN
MAKE
QUERIES
OF
THE
FORM
IS
Q
O
IN
ONE
COMPUTATIONAL
STEP
WE
GENERALIZE
THIS
TO
NON
BOOLEAN
FUNCTIONS
BY
SAYING
THAT
M
HAS
ORACLE
ACCESS
TO
A
FUNCTION
F
IF
IT
IS
GIVEN
ACCESS
TO
THE
LANGUAGE
O
X
I
F
X
I
WE
USE
THE
SAME
NOTATION
FOR
FUNCTIONS
MAPPING
TO
N
IDENTIFYING
NUMBERS
WITH
THEIR
BINARY
REPRESENTATION
AS
STRINGS
FOR
A
FUNCTION
F
WE
DEFINE
FPF
TO
BE
THE
SET
OF
FUNCTIONS
THAT
ARE
COMPUTABLE
BY
POLYNOMIAL
TIME
TMS
THAT
HAVE
ACCESS
TO
AN
ORACLE
FOR
F
DEFINITION
A
FUNCTION
F
IS
P
COMPLETE
IF
IT
IS
IN
P
AND
EVERY
G
P
IS
IN
FPF
IF
F
FP
THEN
FPF
FP
THUS
THE
FOLLOWING
IS
IMMEDIATE
PROPOSITION
IF
F
IS
P
COMPLETE
AND
F
FP
THEN
FP
P
COUNTING
VERSIONS
OF
MANY
NP
COMPLETE
LANGUAGES
SUCH
AS
HAM
AND
CLIQUE
NATURALLY
LEAD
TO
P
COMPLETE
PROBLEMS
WE
DEMONSTRATE
THIS
WITH
SAT
THEOREM
SAT
IS
P
COMPLETE
PROOF
CONSIDER
THE
COOK
LEVIN
REDUCTION
FROM
ANY
L
IN
NP
TO
SAT
WE
SAW
IN
SECTION
THIS
IS
A
POLYNOMIAL
TIME
COMPUTABLE
FUNCTION
F
SUCH
THAT
FOR
EVERY
X
X
L
F
X
SAT
HOWEVER
THE
PROOF
THAT
THE
REDUCTION
WORKS
ACTUALLY
GAVE
US
MORE
INFORMATION
THAN
THAT
IT
PROVIDED
A
LEVIN
REDUCTION
BY
WHICH
WE
MEAN
THE
PROOF
SHOWED
A
WAY
TO
TRANSFORM
A
CERTIFICATE
THAT
X
IS
IN
L
INTO
A
CERTIFICATE
I
E
SATISFYING
ASSIGNMENT
SHOWING
THAT
F
X
SAT
AND
ALSO
VICE
VERSA
TRANSFORMING
A
SATISFYING
ASSIGNMENT
FOR
F
X
INTO
A
WITNESS
THAT
X
L
IN
PARTICULAR
IT
MEANS
THAT
THE
MAPPING
FROM
THE
CERTIFICATES
OF
X
TO
THE
ASSIGNMENTS
OF
F
X
WAS
INVERTIBLE
AND
HENCE
ONE
TO
ONE
THUS
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
FOR
F
X
IS
EQUAL
TO
THE
NUMBER
OF
CERTIFICATES
FOR
X
AS
SHOWN
BELOW
THERE
ARE
P
COMPLETE
PROBLEMS
FOR
WHICH
THE
CORRESPONDING
DECISION
PROBLEMS
ARE
IN
FACT
IN
P
PERMANENT
AND
VALIANT
THEOREM
NOW
WE
STUDY
ANOTHER
PROBLEM
THE
PERMANENT
OF
AN
N
N
MATRIX
A
IS
DEFINED
AS
PERM
A
FL
AI

I
DRAFT

SN
I
WEB
DRAFT
P
COMPLETENESS
WHERE
SN
DENOTES
THE
SET
OF
ALL
PERMUTATIONS
OF
N
ELEMENTS
RECALL
THAT
THE
EXPRESSION
FOR
THE
DETERMINANT
IS
SIMILAR
DET
A
SGN

FL
AI
I
EXCEPT
FOR
AN
ADDITIONAL
SIGN
TERM
THIS
SIMILARITY
DOES
NOT
TRANSLATE
INTO
COMPUTATIONAL
EQUIV
ALENCE
THE
DETERMINANT
CAN
BE
COMPUTED
IN
POLYNOMIAL
TIME
WHEREAS
COMPUTING
THE
PERMANENT
SEEMS
MUCH
HARDER
AS
WE
SEE
BELOW
THE
PERMANENT
FUNCTION
CAN
ALSO
BE
INTERPRETED
COMBINATORIALLY
FIRST
SUPPOSE
THE
MATRIX
A
HAS
EACH
ENTRY
IN
IT
MAY
BE
VIEWED
AS
THE
ADJACENCY
MATRIX
OF
A
BIPARTITE
GRAPH
G
X
Y
E
WITH
X
XN
Y
YN
AND
XI
YJ
E
IFF
AI
J
THEN
THE
TERM
TLN
AI
I
IS
IFF

IS
A
PERFECT
MATCHING
WHICH
IS
A
SET
OF
N
EDGES
SUCH
THAT
EVERY
NODE
IS
IN
EXACTLY
ONE
EDGE
THUS
IF
A
IS
A
MATRIX
THEN
PERM
A
IS
SIMPLY
THE
NUMBER
OF
PERFECT
MATCHINGS
IN
THE
CORRESPONDING
G
AND
IN
R
PERM
A
IS
P
IF
A
IS
A
MATRIX
SAT
ORACLE
TO
COMPUTE
PERM
A
IN
FACT
ONE
CAN
SHOW
FOR
GENERAL
INTEGER
MATRICES
THAT
COMPUTING
THE
PERMANENT
IS
IN
FP
SAT
SEE
EXERCISE
THE
NEXT
THEOREM
CAME
AS
A
SURPRISE
TO
RESEARCHERS
IN
THE
SINCE
IT
IMPLIES
THAT
IF
PERM
FP
THEN
P
NP
THUS
UNLESS
P
NP
COMPUTING
THE
PERMANENT
IS
MUCH
MORE
DIFFICULT
THEN
COMPUTING
THE
DETERMINANT
BEFORE
PROVING
THEOREM
WE
INTRODUCE
YET
ANOTHER
WAY
TO
LOOK
AT
THE
PERMANENT
CONSIDER
MATRIX
A
AS
THE
THE
ADJACENCY
MATRIX
OF
A
WEIGHTED
N
NODE
DIGRAPH
WITH
POSSIBLE
SELF
LOOPS
THEN
THE
EXPRESSION
TLN
AI

I
IS
NONZERO
IFF

IS
A
CYCLE
COVER
OF
A
A
CYCLE
COVER
IS
A
SUBGRAPH
IN
WHICH
EACH
NODE
HAS
IN
DEGREE
AND
OUT
DEGREE
SUCH
A
SUBGRAPH
MUST
BE
COMPOSED
OF
CYCLES
WE
DEFINE
THE
WEIGHT
OF
THE
CYCLE
COVER
TO
BE
THE
PRODUCT
OF
THE
WEIGHTS
OF
THE
EDGES
IN
IT
THUS
PERM
A
IS
EQUAL
TO
THE
SUM
OF
WEIGHTS
OF
ALL
POSSIBLE
CYCLE
COVERS
EXAMPLE
CONSIDER
THE
GRAPH
IN
FIGURE
EVEN
WITHOUT
KNOWING
WHAT
THE
SUBGRAPH
GI
IS
WE
SHOW
THAT
THE
PERMANENT
OF
THE
WHOLE
GRAPH
IS
FOR
EACH
CYCLE
COVER
IN
GI
OF
WEIGHT
W
THERE
ARE
EXACTLY
TWO
CYCLE
COVERS
FOR
THE
THREE
NODES
ONE
WITH
WEIGHT
W
AND
ONE
WITH
WEIGHT
W
ANY
NON
ZERO
WEIGHT
CYCLE
COVER
OF
THE
WHOLE
GRAPH
IS
COMPOSED
OF
A
CYCLE
COVER
FOR
GI
AND
ONE
OF
THESE
TWO
CYCLE
COVERS
THUS
THE
SUM
OF
THE
WEIGHTS
OF
ALL
CYCLE
COVERS
OF
G
IS
IS
KNOWN
THAT
EVERY
PERMUTATION

SN
CAN
BE
REPRESENTED
AS
A
COMPOSITION
OF
TRANSPOSITIONS
WHERE
A
TRANSPOSITION
IS
A
PERMUTATION
THAT
ONLY
SWITCHES
BETWEEN
TWO
ELEMENTS
IN
N
AND
LEAVES
THE
OTHER
ELEMENTS
INTACT
ONE
PROOF
FOR
THIS
STATEMENT
IS
THE
BUBBLESORT
ALGORITHM
IF
M
IS
A
SEQUENCE
OF
TRANSPOSITIONS
SUCH
THAT
THEIR
COMPOSITION
EQUALS

THEN
THE
SIGN
OF

IS
EQUAL
TO
IF
M
IS
EVEN
AND
IF
M
IS
ODD
IT
CAN
BE
SHOWN
THAT
THE
SIGN
IS
WELL
DEFINED
IN
THE
SENSE
THAT
IT
DOES
NOT
DEPEND
ON
THE
REPRESENTATION
OF

AS
A
COMPOSITION
OF
TRANSPOSITIONS
WEB
DRAFT
P
COMPLETENESS
FIGURE
THE
ABOVE
GRAPH
G
HAS
CYCLE
COVER
WEIGHT
ZERO
REGARDLESS
OF
THE
CHOICE
OF
G
SINCE
FOR
EVERY
CYCLE
COVER
OF
WEIGHT
W
IN
G
THERE
EXIST
TWO
COVERS
OF
WEIGHT
W
AND
W
IN
THE
GRAPH
G
UNMARKED
EDGES
HAVE
WEIGHT
WE
FOLLOW
THIS
CONVENTION
THROUGH
OUT
THIS
CHAPTER
PROOF
OF
VALIANT
THEOREM
THEOREM
WE
REDUCE
THE
P
COMPLETE
PROBLEM
TO
PERM
GIVEN
A
BOOLEAN
FORMULA

WITH
N
VARIABLES
AND
M
CLAUSES
FIRST
WE
SHALL
SHOW
HOW
TO
CONSTRUCT
AN
INTEGER
MATRIX
AI
WITH
NEGATIVE
ENTRIES
SUCH
THAT
PERM
AI


STANDS
FOR
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
OF

LATER
WE
SHALL
SHOW
HOW
TO
TO
GET
A
MATRIX
A
FROM
AI
SUCH
THAT
KNOWING
PERM
A
ALLOWS
US
TO
COMPUTE
PERM
AI
THE
MAIN
IDEA
IS
THAT
OUR
CONSTRUCTION
WILL
RESULT
IN
TWO
KINDS
OF
CYCLE
COVERS
IN
THE
DIGRAPH
GI
ASSOCIATED
WITH
AI
THOSE
THAT
CORRESPOND
TO
SATISFYING
ASSIGNMENTS
WE
WILL
MAKE
THIS
PRECISE
AND
THOSE
THAT
DON
T
WE
WILL
USE
NEGATIVE
WEIGHTS
TO
ENSURE
THAT
THE
CONTRIBUTION
OF
THE
CYCLE
COVERS
THAT
DO
NOT
CORRESPOND
TO
SATISFYING
ASSIGNMENTS
CANCELS
OUT
THIS
IS
SIMILAR
REASONING
TO
THE
ONE
USED
IN
EXAMPLE
ON
THE
OTHER
HAND
WE
WILL
SHOW
THAT
EACH
SATISFYING
ASSIGNMENT
CONTRIBUTES
TO
PERM
AI
AND
SO
PERM
AI

TO
CONSTRUCT
GI
FROM

WE
COMBINE
THE
FOLLOWING
THREE
KINDS
OF
GADGETS
SHOWN
IN
FIGURE
VARIABLE
GADGET
THE
VARIABLE
GADGET
HAS
TWO
POSSIBLE
CYCLE
COVERS
CORRESPONDING
TO
AN
ASSIGN
MENT
OF
OR
TO
THAT
VARIABLE
ASSIGNING
CORRESPONDS
TO
A
SINGLE
CYCLE
TAKING
ALL
THE
EXTERNAL
EDGES
TRUE
EDGES
AND
ASSIGNING
CORRESPOND
TO
TAKING
ALL
THE
SELF
LOOPS
AND
TAKING
THE
FALSE
EDGE
EACH
EXTERNAL
EDGE
OF
A
VARIABLE
IS
ASSOCIATED
WITH
A
CLAUSE
IN
WHICH
THE
VARIABLE
APPEARS
CLAUSE
GADGET
THE
CLAUSE
GADGET
IS
SUCH
THAT
THE
ONLY
POSSIBLE
CYCLE
COVERS
EXCLUDE
AT
LEAST
ONE
EXTERNAL
EDGE
ALSO
FOR
A
GIVEN
PROPER
SUBSET
OF
EXTERNAL
EDGES
USED
THERE
IS
A
UNIQUE
CYCLE
COVER
OF
WEIGHT
EACH
EXTERNAL
EDGE
IS
ASSOCIATED
WITH
A
VARIABLE
APPEARING
IN
THE
CLAUSE
XOR
GADGET
WE
ALSO
USE
A
GRAPH
CALLED
THE
XOR
GADGET
WHOSE
PURPOSE
IS
TO
ENSURE
THAT
FOR
SOME
PAIR
OF
EDGES
U
UI
AND
V
VI
EXACTLY
ONE
OF
THESE
EDGES
IS
PRESENT
IN
ANY
CYCLE
COVER
THAT
COUNTS
TOWARDS
THE
FINAL
SUM
SUPPOSE
THAT
WE
REPLACE
A
PAIR
OF
EDGES
U
UI
AND
V
VI
IN
SOME
GRAPH
G
WITH
THE
XOR
GADGET
AS
DESCRIBED
IN
FIGURE
COUNT
FIG
VALIANTGAD
TO
OBTAIN
SOME
GRAPH
GI
THEN
VIA
SIMILAR
REASONING
TO
EXAMPLE
EVERY
CYCLE
COVER
OF
G
OF
WEIGHT
W
THAT
USES
EXACTLY
ONE
OF
THE
EDGES
U
UI
AND
DRAFT
WEB
DRAFT
P
COMPLETENESS
GADGET
SYMBOLIC
DESCRIPTION
VARIABLE
GADGET
FALSE
EDGE
EXTERNAL
TRUE
EDGES
ONE
PER
CLAUSE
VARIABLE
GADGET
EXTERNAL
EDGES
CLAUSE
GADGET
EXTERNAL
EDGES
ONE
PER
VARIABLE
EXTERNAL
EDGES
CLAUSE
GADGET
XOR
GADGET
U
U
U
U
V
V
V
V
THE
OVERALL
CONSTRUCTION
VARIABLE
GADGET
FOR
EVERY
VARIABLE
CLAUSE
GADGET
FOR
EVERY
CLAUSE
CONNECT
VIA
XOR
EXTERNAL
EDGES
OF
GADGETS
FOR
VARIABLES
THAT
APPEAR
IN
CLAUSES
FIGURE
THE
GADGETS
USED
IN
THE
PROOF
OF
VALIANT
THEOREM
WEB
DRAFT
P
COMPLETENESS
V
VI
IS
MAPPED
TO
A
SET
OF
CYCLE
COVERS
IN
GI
WHOSE
TOTAL
WEIGHT
IS
I
E
THE
SET
OF
COVERS
THAT
ENTER
THE
GADGET
AT
U
AND
EXIT
AT
UI
OR
ENTER
IT
AT
V
AND
EXIT
IT
AT
VI
WHILE
ALL
THE
OTHER
CYCLE
COVERS
OF
GI
HAVE
TOTAL
WEIGHT
EXERCISE
FOR
THIS
REASON
WHENEVER
WE
REPLACE
EDGES
U
UI
AND
V
VI
WITH
A
XOR
GADGET
WE
CAN
CONSIDER
IN
THE
ANALYSIS
ONLY
CYCLE
COVERS
THAT
USE
EXACTLY
ONE
OF
THESE
EDGES
AS
THE
OTHER
COVERS
DO
NOT
CONTRIBUTE
ANYTHING
TO
THE
TOTAL
SUM
THE
XOR
GADGETS
ARE
USED
TO
CONNECT
THE
VARIABLE
GADGETS
TO
THE
CORRESPONDING
CLAUSE
GADGETS
SO
THAT
ONLY
CYCLE
COVERS
CORRESPONDING
TO
A
SATISFYING
ASSIGNMENT
WILL
BE
COUNTED
TOWARDS
THE
TOTAL
NUMBER
OF
CYCLE
COVERS
CONSIDER
A
CLAUSE
AND
A
VARIABLE
APPEARING
IN
IT
EACH
HAS
AN
EXTERNAL
EDGE
CORRESPONDING
TO
THE
OTHER
CONNECTED
BY
AN
XOR
GADGET
IF
THE
EXTERNAL
EDGE
IN
THE
CLAUSE
IS
NOT
TAKEN
THEN
BY
THE
ANALYSIS
OF
THE
XOR
GADGET
THE
EXTERNAL
EDGE
IN
THE
VARIABLE
MUST
BE
TAKEN
AND
HENCE
THE
VARIABLE
IS
TRUE
SINCE
AT
LEAST
ONE
EXTERNAL
EDGE
OF
EACH
CLAUSE
GADGET
HAS
TO
BE
OMITTED
EACH
CYCLE
COVER
THAT
IS
COUNTED
TOWARDS
THE
SUM
CORRESPONDS
TO
A
SATISFYING
ASSIGNMENT
CONVERSELY
FOR
EACH
SATISFYING
ASSIGNMENT
THERE
IS
A
A
SET
OF
CYCLE
COVERS
WITH
TOTAL
WEIGHT
SINCE
THEY
PASSES
THROUGH
THE
XOR
GADGET
EXACTLY
TIMES
SO
PERM
GI

REDUCING
TO
THE
CASE
MATRICES
FINALLY
WE
HAVE
TO
REDUCE
FINDING
PERM
GI
TO
FINDING
PERM
G
WHERE
G
IS
AN
UNWEIGHTED
GRAPH
OR
EQUIVALENTLY
ITS
ADJACENCY
MATRIX
HAS
ONLY
ENTRIES
WE
START
BY
REDUCING
TO
THE
CASE
THAT
ALL
EDGES
HAVE
WEIGHTS
IN
FIRST
NOTE
THAT
REPLACING
AN
EDGE
OF
WEIGHT
K
BY
K
PARALLEL
EDGES
OF
WEIGHT
DOES
NOT
CHANGE
THE
PERMANENT
PARALLEL
EDGES
ARE
NOT
ALLOWED
BUT
WE
CAN
MAKE
EDGES
NON
PARALLEL
BY
CUTTING
EACH
EDGE
U
V
IN
TWO
AND
INSERTING
A
NEW
NODE
W
WITH
AN
EDGE
FROM
U
TO
W
W
TO
V
AND
A
SELF
LOOP
AT
W
TO
GET
RID
OF
THE
NEGATIVE
WEIGHTS
NOTE
THAT
THE
PERMANENT
OF
AN
N
VERTEX
GRAPH
WITH
EDGE
WEIGHTS
IN
IS
A
NUMBER
X
IN
N
N
AND
HENCE
THIS
PERMANENT
CAN
BE
COMPUTED
FROM
Y
X
MOD
WHERE
M
IS
SUFFICIENTLY
LARGE
E
G
M
WILL
DO
BUT
TO
COMPUTE
Y
IT
IS
ENOUGH
TO
COMPUTE
THE
PERMANENT
OF
THE
GRAPH
WHERE
ALL
WEIGHT
EDGES
ARE
REPLACED
WITH
EDGES
OF
WEIGHT
SUCH
EDGES
CAN
BE
CONVERTED
TO
M
EDGES
OF
WEIGHT
IN
SERIES
WHICH
AGAIN
CAN
BE
TRANSFORMED
TO
PARALLEL
EDGES
OF
WEIGHT
AS
ABOVE
APPROXIMATE
SOLUTIONS
TO
P
PROBLEMS
SINCE
COMPUTING
EXACT
SOLUTIONS
TO
P
COMPLETE
PROBLEMS
IS
PRESUMABLY
DIFFICULT
A
NATURAL
QUES
TION
IS
WHETHER
WE
CAN
APPROXIMATE
THE
NUMBER
OF
CERTIFICATES
IN
THE
SENSE
OF
THE
FOLLOWING
DEFINITION
DEFINITION
LET
F
N
AND

AN
ALGORITHM
A
IS
AN

APPROXIMATION
FOR
F
IF
FOR
EVERY
X
F
X
A
X
F
X

NOT
ALL
P
PROBLEMS
BEHAVE
IDENTICALLY
WITH
RESPECT
TO
THIS
NOTION
APPROXIMATING
CERTAIN
PROBLEMS
WITHIN
ANY
CONSTANT
FACTOR

IS
NP
HARD
SEE
EXERCISE
FOR
OTHER
PROBLEMS
SUCH
AS
PERMANENT
THERE
IS
A
FULLY
POLYNOMIAL
RANDOMIZED
APPROXIMATION
SCHEME
FPRAS
WHICH
IS
AN
ALGORITHM
WHICH
FOR
ANY
E

APPROXIMATES
THE
FUNCTION
WITHIN
A
FACTOR
E
ITS
ANSWER
MAY
BE
INCORRECT
WITH
PROBABILITY

IN
TIME
POLY
N
LOG

LOG
E
SUCH
APPROXIMATION
OF
COUNTING
PROBLEMS
IS
SUFFICIENT
FOR
MANY
APPLICATIONS
IN
PARTICULAR
THOSE
WHERE
COUNTING
IS
NEEDED
TO
OBTAIN
DRAFT
WEB
DRAFT
TODA
THEOREM
PH
P
SAT
ESTIMATES
FOR
THE
PROBABILITIES
OF
CERTAIN
EVENTS
E
G
SEE
OUR
DISCUSSION
OF
THE
GRAPH
RELIABILITY
PROBLEM
THE
APPROXIMATION
ALGORITHM
FOR
THE
PERMANENT
AS
WELL
AS
OTHER
SIMILAR
ALGORITHMS
FOR
A
HOST
OF
P
COMPLETE
PROBLEMS
USE
THE
MONTE
CARLO
MARKOV
CHAIN
TECHNIQUE
THE
RESULT
THAT
SPURRED
THIS
DEVELOPMENT
IS
DUE
TO
VALIANT
AND
VAZIRANI
AND
IT
SHOWS
THAT
UNDER
FAIRLY
GENERAL
CONDITIONS
APPROXIMATELY
COUNTING
THE
NUMBER
OF
ELEMENTS
IN
A
SET
MEMBERSHIP
IN
WHICH
IS
TESTABLE
IN
POLYNOMIAL
TIME
IS
EQUIVALENT
IN
THE
SENSE
THAT
THE
PROBLEMS
ARE
INTERREDUCIBLE
VIA
POLYNOMIAL
TIME
RANDOMIZED
REDUCTIONS
TO
THE
PROBLEM
OF
GENERATING
A
RANDOM
SAMPLE
FROM
THE
SET
WE
WILL
NOT
DISCUSS
THIS
INTERESTING
AREA
ANY
FURTHER
INTERESTINGLY
IF
P
NP
THEN
EVERY
P
PROBLEM
HAS
AN
FPRAS
AND
IN
FACT
AN
FPTAS
I
E
A
DETERMINISTIC
POLYNOMIAL
TIME
APPROXIMATION
SCHEME
SEE
EXERCISE
TODA
THEOREM
PH
P
SAT
AN
IMPORTANT
QUESTION
IN
THE
WAS
THE
RELATIVE
POWER
OF
THE
POLYNOMIAL
HIERARCHY
PH
AND
THE
CLASS
OF
COUNTING
PROBLEMS
P
BOTH
ARE
NATURAL
GENERALIZATIONS
OF
NP
BUT
IT
SEEMED
THAT
THEIR
FEATURES
ALTERNATION
AND
THE
ABILITY
TO
COUNT
CERTIFICATES
RESPECTIVELY
ARE
NOT
DIRECTLY
COMPARABLE
TO
EACH
OTHER
THUS
IT
CAME
AS
BIG
SURPRISE
WHEN
IN
TODA
SHOWED
THAT
IS
WE
CAN
SOLVE
ANY
PROBLEM
IN
THE
POLYNOMIAL
HIERARCHY
GIVEN
AN
ORACLE
TO
A
P
COMPLETE
PROBLEM
REMARK
NOTE
THAT
WE
ALREADY
KNOW
EVEN
WITHOUT
TODA
THEOREM
THAT
IF
P
FP
THEN
NP
P
AND
SO
PH
P
HOWEVER
THIS
DOES
NOT
IMPLY
THAT
ANY
PROBLEM
IN
PH
CAN
BE
COMPUTED
IN
POLYNOMIAL
TIME
USING
AN
ORACLE
TO
SAT
FOR
EXAMPLE
ONE
IMPLICATION
OF
TODA
THEOREM
IS
THAT
A
SUBEXPONENTIAL
I
E
TIME
ALGORITHM
FOR
SAT
WILL
IMPLY
SUCH
AN
ALGORITHM
FOR
ANY
PROBLEM
IN
PH
SUCH
AN
IMPLICATION
IS
NOT
KNOWN
TO
HOLD
FROM
A
TIME
ALGORITHM
FOR
SAT
THE
CLASS
P
AND
HARDNESS
OF
SATISFIABILITY
WITH
UNIQUE
SOLUTIONS
THE
FOLLOWING
COMPLEXITY
CLASS
WILL
BE
USED
IN
THE
PROOF
DEFINITION
A
LANGUAGE
L
IN
THE
CLASS
P
PRONOUNCED
PARITY
P
IFF
THERE
EXISTS
A
POLYNOMIAL
TIME
NTM
M
SUCH
THAT
X
L
IFF
THE
NUMBER
OF
ACCEPTING
PATHS
OF
M
ON
INPUT
X
IS
ODD
THUS
P
CAN
BE
CONSIDERED
AS
THE
CLASS
OF
DECISION
PROBLEMS
CORRESPONDING
TO
THE
LEAST
SIG
NIFICANT
BIT
OF
A
P
PROBLEM
AS
IN
THE
PROOF
OF
THEOREM
THE
FACT
THAT
THE
STANDARD
NP
COMPLETENESS
REDUCTION
IS
PARSIMONIOUS
IMPLIES
THE
FOLLOWING
PROBLEM
SAT
IS
P
COMPLETE
UNDER
MANY
TO
ONE
KARP
REDUCTIONS
WEB
DRAFT
TODA
THEOREM
PH
P
SAT
DEFINITION
DEFINE
THE
QUANTIFIER
AS
FOLLOWS
FOR
EVERY
BOOLEAN
FORMULA

ON
N
VARIABLES
X
N

X
IS
TRUE
IF
THE
NUMBER
OF
SUCH
THAT
IS
TRUE
IS
ODD
THE
LANGUAGE
CONSISTS
OF
ALL
THE
TRUE
QUANTIFIED
BOOLEAN
FORMULA
OF
THE
FORM
X
N

X
WHERE

IS
AN
UNQUANTIFIED
BOOLEAN
FORMULA
NOT
NECESSARILY
IN
CNF
FORM
UNLIKE
THE
CLASS
P
IT
IS
NOT
KNOWN
THAT
A
POLYNOMIAL
TIME
ALGORITHM
FOR
P
IMPLIES
THAT
NP
P
HOWEVER
SUCH
AN
ALGORITHM
DOES
IMPLY
THAT
NP
RP
SINCE
NP
CAN
BE
PROBABILISTICALLY
REDUCED
TO
SAT
TO
PROVE
THEOREM
WE
USE
THE
FOLLOWING
LEMMA
ON
PAIRWISE
INDEPENDENT
HASH
FUNCTIONS
LEMMA
VALIANT
VAZIRANI
LEMMA
LET
HN
K
BE
A
PAIRWISE
INDEPENDENT
HASH
FUNCTION
COLLECTION
FROM
N
TO
K
AND
N
SUCH
THAT
THEN
PR
H
RHN
K
H
X
PROOF
FOR
EVERY
X
LET
P
K
BE
THE
PROBABILITY
THAT
H
X
WHEN
H
R
HN
K
NOTE
THAT
FOR
EVERY
X
XI
PR
H
X
H
XI
LET
N
BE
THE
RANDOM
VARIABLE
DENOTING
THE
NUMBER
OF
X
SATISFYING
H
X
NOTE
THAT
E
N
P
BY
THE
INCLUSION
EXCLUSION
PRINCIPLE
PR
N
PR
H
X
PR
H
X
H
XI
P
X
X
X
AND
BY
THE
UNION
BOUND
WE
GET
THAT
PR
N
THUS
PR
N
PR
N
PR
N
P
P
WHERE
THE
LAST
INEQUALITY
IS
OBTAINED
USING
THE
FACT
THAT
P
THAT
IF
WE
IDENTIFY
TRUE
WITH
AND
WITH
FALSE
THEN
N

X
N

X
MOD
ALSO
NOTE
THAT
X
N

X
XN

XN
X
X
WEB
DRAFT
TODA
THEOREM
PH
P
SAT
PROOF
OF
THEOREM
WE
NOW
USE
LEMMA
TO
PROVE
THEOREM
GIVEN
A
FORMULA

ON
N
VARIABLES
OUR
PROBABILISTIC
ALGORITHM
A
CHOOSES
K
AT
RANDOM
FROM
N
AND
A
RANDOM
HASH
FUNCTION
H
R
N
K
IT
THEN
USES
THE
COOK
LEVIN
REDUCTION
TO
COMPUTE
A
FORMULA

ON
VARIABLES
X
N
Y
M
FOR
M
POLY
N
SUCH
THAT
H
X
IF
AND
ONLY
IF
THERE
EXISTS
A
UNIQUE
Y
SUCH
THAT

X
Y
THE
OUTPUT
OF
A
IF
THE
FORMULA

X
N
Y
M

X

X
Y
IT
IS
EQUIVALENT
TO
THE
STATEMENT
X
N

X
H
X
IF

IS
UNSATISFIABLE
THEN

IS
FALSE
SINCE
WE
LL
HAVE
NO
X
SATISFYING
THE
INNER
FORMULA
AND
ZERO
IS
AN
EVEN
NUMBER
IF

IS
SATISFIABLE
WE
LET
BE
THE
SET
OF
ITS
SATISFYING
ASSIGNMENTS
WITH
PROBABILITY
N
K
SATISFIES
CONDITIONED
ON
WHICH
WITH
PROBABILITY
THERE
IS
A
UNIQUE
X
SUCH
THAT

X
H
X
SINCE
ONE
HAPPENS
TO
BE
AN
ODD
NUMBER
THIS
IMPLIES
THAT

IS
TRUE
REMARK
HARDNESS
OF
UNIQUE
SATISFIABILITY
THE
PROOF
OF
THEOREM
IMPLIES
THE
FOLLOWING
STRONGER
STATEMENT
THE
EXISTENCE
OF
AN
ALGORITHM
TO
DISTINGUISH
BETWEEN
AN
UNSATISFIABLE
BOOLEAN
FORMULA
AND
A
FORMULA
WITH
EXACTLY
ONE
SATISFYING
ASSIGNMENT
IMPLIES
THE
EXISTENCE
OF
A
PROBABILISTIC
POLYNOMIAL
TIME
ALGORITHM
FOR
ALL
OF
NP
THUS
THE
GUARANTEE
THAT
A
PARTICULAR
SEARCH
PROBLEM
HAS
EITHER
NO
SOLUTIONS
OR
A
UNIQUE
SOLUTION
DOES
NOT
NECESSARILY
MAKE
THE
PROBLEM
EASIER
TO
SOLVE
STEP
RANDOMIZED
REDUCTION
FROM
PH
TO
P
WE
NOW
GO
BEYOND
NP
THAT
IS
TO
SAY
THE
VALIANT
VAZIRANI
THEOREM
AND
SHOW
THAT
WE
CAN
ACTUALLY
REDUCE
ANY
LANGUAGE
IN
THE
POLYNOMIAL
HIERARCHY
TO
SAT
LEMMA
LET
C
N
BE
SOME
CONSTANT
THERE
EXISTS
A
PROBABILISTIC
POLYNOMIAL
TIME
ALGORITHM
A
SUCH
THAT
FOR
EVERY

A
QUANTIFIED
BOOLEAN
FORMULA
WITH
C
LEVELS
OF
ALTERNATIONS

IS
TRUE
PR
A

SAT

IS
FALSE
PR
A

SAT
BEFORE
PROVING
THE
LEMMA
LET
US
MAKE
A
FEW
NOTATIONS
AND
OBSERVATIONS
FOR
A
BOOLEAN
FORMULA

ON
N
VARIABLES
LET

DENOTE
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
OF

WE
CONSIDER
ALSO
FORMULAE

THAT
ARE
PARTIALLY
QUANTIFIED
THAT
IS
IN
ADDITION
TO
THE
N
VARIABLES

TAKES
AS
INPUT
SOME
IMPLEMENTATIONS
OF
HASH
FUNCTIONS
SUCH
AS
THE
ONE
DESCRIBED
IN
EXERCISE
ONE
CAN
CONSTRUCT
DIRECTLY
WITHOUT
GOING
THROUGH
THE
COOK
LEVIN
REDUCTION
SUCH
A
FORMULA

THAT
DOES
NOT
USE
THE
Y
VARIABLES
WEB
DRAFT
TODA
THEOREM
PH
P
SAT
IT
MAY
ALSO
HAVE
OTHER
VARIABLES
THAT
ARE
BOUND
BY
A
OR
QUANTIFIERS
FOR
EXAMPLE

CAN
BE
OF
THE
FORM

XN
Y
N

XN
Y
WHERE

IS
SAY
A
BOOLEAN
FORMULA
GIVEN
TWO
POSSIBLY
PARTIALLY
QUANTIFIED
FORMULAE


ON
VARIABLES
X
N
Y
M
WE
CAN
CONSTRUCT
IN
POLYNOMIAL
TIME
AN
N
M
VARIABLE
FORMULA


AND
A
MAX
N
M
VARIABLE
FORMULA


SUCH
THAT




AND




INDEED
TAKE


X
Y

X

Y


Z

ZN

ZM
FOR
A
FORMULA

WE
USE
THE
NOTATION

TO
DENOTE
THE
FORMULA


WHERE

IS
SOME
CANONICAL
FORMULA
WITH
A
SINGLE
SATISFYING
ASSIGNMENT
SINCE
THE
PRODUCT
OF
NUMBERS
IS
EVEN
IFF
ONE
OF
THE
NUMBERS
IS
EVEN
AND
SINCE
ADDING
ONE
TO
A
NUMBER
FLIPS
THE
PARITY
FOR
EVERY
TWO
FORMULAE


AS
ABOVE

X

Y


X
Y

X

X
Z

X

Y


X
Y
Z
PROOF
OF
LEMMA
RECALL
THAT
MEMBERSHIP
IN
A
PH
LANGUAGE
CAN
BE
REDUCED
TO
DECIDING
THE
TRUTH
OF
A
QUANTIFIED
BOOLEAN
FORMULA
WITH
A
CONSTANT
NUMBER
OF
ALTERNATING
QUANTIFIERS
THE
IDEA
BEHIND
THE
PROOF
IS
TO
REPLACE
ONE
BY
ONE
EACH
QUANTIFIERS
WITH
A
QUANTIFIER
LET

BE
A
FORMULA
WITH
C
LEVELS
OF
ALTERNATING
QUANTIFIERS
POSSIBLY
WITH
AN
INITIAL
QUANTIFIER
WE
TRANSFORM

IN
PROBABILISTIC
POLYNOMIAL
TIME
TO
A
FORMULA
I
SUCH
THAT
I
HAS
ONLY
C
LEVELS
OF
ALTERNATING
QUANTIFIERS
AN
INITIAL
QUANTIFIER
SATISFYING
IF

IS
FALSE
THEN
SO
IS
I
AND
IF

IS
TRUE
THEN
WITH
PROBABILITY
AT
LEAST
I
IS
TRUE
AS
WELL
THE
LEMMA
FOLLOWS
BY
REPEATING
THIS
STEP
C
TIMES
FOR
EASE
OF
NOTATION
WE
DEMONSTRATE
THE
PROOF
FOR
THE
CASE
THAT

HAS
A
SINGLE
QUANTIFIER
AND
TWO
ADDITIONAL
QUANTIFIERS
WE
CAN
ASSUME
WITHOUT
LOSS
OF
GENERALITY
THAT

IS
OF
THE
FORM

Z
X
N
W
K

Z
X
W
AS
OTHERWISE
WE
CAN
USE
THE
IDENTITIES
XP
X
X
P
X
AND
TO
TRANSFORM

INTO
THIS
FORM
THE
PROOF
OF
THEOREM
PROVIDES
FOR
EVERY
N
A
PROBABILISTIC
ALGORITHM
THAT
OUTPUTS
A
FOR
MULA

ON
VARIABLES
X
N
AND
Y
M
SUCH
THAT
FOR
EVERY
NONEMPTY
SET
N
PR
X
N
Y
M

X
Y
RUN
THIS
ALGORITHM
T
LOG
N
TIMES
TO
OBTAIN
THE
FOR
MULAE
T
THEN
FOR
EVERY
NONEMPTY
SET
N
THE
PROBABILITY
THAT
THERE
DOES
NOT
EXIST
I
T
SUCH
THAT
X
N
Y
M

X
Y
IS
TRUE
IS
LESS
THAN
C
WE
CLAIM
THAT
THIS
IMPLIES
THAT
WITH
PROBABILITY
AT
LEAST
THE
FOLLOWING
FORMULA
IS
EQUIVALENT
TO

WHERE
Z

Z

Z
T
X
N
Y
M
W
K
I
X
Y

X
Z
W
WEB
DRAFT
TODA
THEOREM
PH
P
SAT
INDEED
FOR
EVERY
Z
C
DEFINE
SZ
JX
N
K

X
Z
W
L
THEN

IS
EQUIVALENT
W
TO
Z
SZ
IS
NONEMPTY
BUT
BY
THE
UNION
BOUND
WITH
PROBABILITY
AT
LEAST
IT
HOLDS
THAT
FOR
EVERY
Z
SUCH
THAT
SZ
IS
NONEMPTY
THERE
EXISTS
I
SATISFYING
X
YI
X
Y
THIS
MEANS
THAT
FOR
EVERY
SUCH
Z

Z
IS
TRUE
ON
THE
OTHER
HAND
IF
SZ
IS
EMPTY
THEN
CERTAINLY

Z
IS
FALSE
IMPLYING
THAT
INDEED

IS
EQUIVALENT
TO
BY
APPLYING
THE
IDENTITY
WE
CAN
TRANSFORM
INTO
AN
EQUIVALENT
FORMULA
OF
THE
DESIRED
FORM
Z
X
Y
W
WI
X
Y
Z
W
FOR
SOME
UNQUANTIFIED
POLYNOMIAL
SIZE
FORMULA
I
STEP
MAKING
THE
REDUCTION
DETERMINISTIC
TO
COMPLETE
THE
PROOF
OF
TODA
THEOREM
THEOREM
WE
PROVE
THE
FOLLOWING
LEMMA
LEMMA
THERE
IS
A
DETERMINISTIC
POLYNOMIAL
TIME
TRANSFORMATION
T
THAT
FOR
EVERY
FORMULA

THAT
IS
AN
INPUT
FOR
SAT
T

IS
AN
UNQUANTIFIED
BOOLEAN
FORMULA
AND

SAT

MOD

SAT

MOD
PROOF
OF
THEOREM
USING
LEMMAS
AND
LET
L
P
H
WE
SHOW
THAT
WE
CAN
DECIDE
WHETHER
AN
INPUT
X
L
BY
ASKING
A
SINGLE
QUESTION
TO
A
SAT
ORACLE
FOR
EVERY
X
N
LEMMAS
AND
TOGETHER
IMPLY
THERE
EXISTS
A
POLYNOMIAL
TIME
TM
M
SUCH
THAT
X
L
PR
R
M
X
R
MOD
X
L
R
R
M
M
X
R
MOD
M
WHERE
M
IS
THE
POLYNOMIAL
IN
N
NUMBER
OF
RANDOM
BITS
USED
BY
THE
PROCEDURE
DESCRIBED
IN
THAT
LEMMA
FURTHERMORE
EVEN
IN
THE
CASE
X
L
WE
ARE
GUARANTEED
THAT
FOR
EVERY
R
M
M
X
R
MOD
CONSIDER
THE
FUNCTION
THAT
MAPS
TWO
STRINGS
R
U
INTO
THE
EVALUATION
OF
THE
FORMULA
M
X
R
ON
THE
ASSIGNMENT
U
SINCE
THIS
FUNCTION
IS
COMPUTABLE
IN
POLYNOMIAL
TIME
THE
COOK
LEVIN
TRANSFORMATION
IMPLIES
THAT
WE
CAN
OBTAIN
IN
POLYNOMIAL
TIME
A
CNF
FORMULA
X
ON
VARIABLES
R
U
Y
SUCH
THAT
FOR
EVERY
R
U
M
X
R
IS
SATISFIED
BY
U
IF
AND
ONLY
IF
THERE
EXIST
A
UNIQUE
Y
SUCH
THAT
X
R
U
Y
IS
TRUE
LET
FX
R
BE
THE
NUMBER
OF
U
Y
SUCH
THAT
X
R
U
Y
IS
TRUE
THEN
X
R
M
FX
R
BUT
IF
X
L
THEN
FX
R
MOD
FOR
EVERY
R
AND
HENCE
X
MOD
ON
THE
OTHER
HAND
IF
X
L
THEN
FX
R
MOD
FOR
BETWEEN
AND
VALUES
OF
R
AND
IS
WEB
DRAFT
OPEN
PROBLEMS
EQUAL
TO
ON
THE
OTHER
VALUES
AND
HENCE
X
MOD
WE
SEE
THAT
DECIDING
WHETHER
X
L
CAN
BE
DONE
BY
COMPUTING
X
PROOF
OF
LEMMA
FOR
EVERY
PAIR
OF
FORMULAE


RECALL
THAT
WE
DEFINED
FORMULAS


AND


SATISFYING




AND




AND
NOTE
THAT
THESE
FORMULAE
ARE
OF
SIZE
AT
MOST
A
CONSTANT
FACTOR
LARGER
THAN


CONSIDER
THE
FORMULA
WHERE

FOR
EXAMPLE
IS
SHORTHAND
FOR



ONE
CAN
EASILY
CHECK
THAT

MOD
MOD

MOD
MOD
LET

AND
I
LET

ILOG
M
L
REPEATED
USE
OF
EQUATIONS
SHOWS
THAT
IF

IS
ODD
THEN

MOD
AND
IF

IS
EVEN
THEN

MOD
ALSO
THE
SIZE
OF

IS
ONLY
POLYNOMIALLY
LARGER
THAN
SIZE
OF

OPEN
PROBLEMS
WHAT
IS
THE
EXACT
POWER
OF
SAT
AND
SAT
WHAT
IS
THE
AVERAGE
CASE
COMPLEXITY
OF
N
N
PERMANENT
MODULO
SMALL
PRIME
SAY
OR
NOTE
THAT
FOR
A
PRIME
P
N
RANDOM
SELF
REDUCIBILITY
OF
PERMANENT
IMPLIES
THAT
IF
PERMANENT
IS
HARD
TO
COMPUTE
ON
AT
LEAST
ONE
INPUT
THEN
IT
IS
HARD
TO
COMPUTE
ON
O
P
N
FRACTION
OF
INPUTS
I
E
HARD
TO
COMPUTE
ON
AVERAGE
SEE
THEOREM
DRAFT
WEB
DRAFT
OPEN
PROBLEMS
CHAPTER
NOTES
AND
HISTORY
THE
DEFINITION
OF
P
AS
WELL
AS
SEVERAL
INTERESTING
EXAMPLES
OF
P
PROBLEMS
APPEARED
IN
VALIANT
SEMINAL
PAPER
THE
P
COMPLETENESS
OF
THE
PERMANENT
IS
FROM
HIS
OTHER
PAPER
TODA
THEOREM
IS
PROVED
IN
THE
PROOF
GIVEN
HERE
FOLLOWS
THE
PROOF
OF
ALTHOUGH
WE
USE
FORMULAS
WHERE
THEY
USED
CIRCUITS
FOR
AN
INTRODUCTION
TO
FPRAS
FOR
COMPUTING
APPROXIMATIONS
TO
MANY
COUNTING
PROBLEMS
SEE
THE
RELEVANT
CHAPTER
IN
VAZIRANI
AN
EXCELLENT
RESOURCE
ON
APPROXIMATION
ALGORITHMS
IN
GENERAL
EXERCISES
LET
F
P
SHOW
A
POLYNOMIAL
TIME
ALGORITHM
TO
COMPUTE
F
GIVEN
ACCESS
TO
AN
ORACLE
FOR
SOME
LANGUAGE
L
PP
SEE
REMARK
SHOW
THAT
COMPUTING
THE
PERMANENT
FOR
MATRICES
WITH
INTEGER
ENTRIES
IS
IN
FP
SAT
COMPLETE
THE
ANALYSIS
OF
THE
XOR
GADGET
IN
THE
PROOF
OF
THEOREM
LET
G
BE
ANY
WEIGHTED
GRAPH
CONTAINING
A
PAIR
OF
EDGES
U
UI
AND
V
VI
AND
LET
GI
BE
THE
GRAPH
OBTAINED
BY
REPLACING
THESE
EDGES
WITH
THE
XOR
GADGET
PROVE
THAT
EVERY
CYCLE
COVER
OF
G
OF
WEIGHT
W
THAT
USES
EXACTLY
ONE
OF
THE
EDGES
U
UI
IS
MAPPED
TO
A
SET
OF
CYCLE
COVERS
IN
GI
WHOSE
TOTAL
WEIGHT
IS
AND
ALL
THE
OTHER
CYCLE
COVERS
OF
GI
HAVE
TOTAL
WEIGHT
LET
K
N
PROVE
THAT
THE
FOLLOWING
FAMILY
HN
K
IS
A
COLLECTION
OF
PAIRWISE
INDEPENDENT
FUNCTIONS
FROM
N
TO
K
IDENTIFY
WITH
THE
FIELD
GF
FOR
EVERY
K
N
MATRIX
A
WITH
ENTRIES
IN
GF
AND
K
LENGTH
VECTOR
B
GF
N
HN
K
CONTAINS
THE
FUNCTION
HA
B
GF
N
GF
K
DEFINED
AS
FOLLOWS
HA
B
X
AX
B
SHOW
THAT
IF
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
THAT
APPROXIMATES
CYCLE
WITHIN
A
FACTOR
THEN
P
NP
SHOW
THAT
IF
NP
P
THEN
FOR
EVERY
F
P
AND
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
THAT
APPROXIMATES
F
WITHIN
A
FACTOR
OF
CAN
YOU
SHOW
THE
SAME
FOR
A
FACTOR
OF
E
FOR
ARBITRARILY
SMALL
CONSTANT
E
CAN
YOU
MAKE
THESE
ALGORITHMS
DETERMINISTIC
WEB
DRAFT
OPEN
PROBLEMS
NOTE
THAT
WE
DO
NOT
KNOW
WHETHER
P
NP
IMPLIES
THAT
EXACT
COMPUTATION
OF
FUNCTIONS
IN
P
CAN
BE
DONE
IN
POLYNOMIAL
TIME
SHOW
THAT
EVERY
FOR
EVERY
LANGUAGE
IN
THERE
IS
A
DEPTH
CIRCUIT
OF
NPOLY
LOG
N
SIZE
THAT
DECIDES
IT
ON
POLY
N
FRACTION
OF
INPUTS
AND
LOOKS
AS
FOLLOWS
IT
HAS
A
SINGLE
GATE
AT
THE
TOP
AND
THE
OTHER
GATES
ARE
OF
FANIN
AT
MOST
POLY
LOG
N
DRAFT
WEB
DRAFT
CHAPTER
CRYPTOGRAPHY
FROM
TIMES
IMMEMORIAL
HUMANITY
HAS
GOTTEN
FREQUENT
OFTEN
CRUEL
REMINDERS
THAT
MANY
THINGS
ARE
EASIER
TO
DO
THAN
TO
REVERSE
L
LEVIN
LEV
SOMEWHAT
ROUGH
STILL
THE
IMPORTANCE
OF
CRYPTOGRAPHY
IN
TODAY
ONLINE
WORLD
NEEDS
NO
INTRODUCTION
HERE
WE
FOCUS
ON
THE
COMPLEXITY
ISSUES
THAT
UNDERLIE
THIS
FIELD
THE
TRADITIONAL
TASK
OF
CRYPTOGRAPHY
WAS
TO
ALLOW
TWO
PARTIES
TO
ENCRYPT
THEIR
MESSAGES
SO
THAT
EAVESDROPPERS
GAIN
NO
INFORMATION
ABOUT
THE
MESSAGE
SEE
FIGURE
VARIOUS
ENCRYPTION
TECHNIQUES
HAVE
BEEN
INVENTED
THROUGHOUT
HISTORY
WITH
ONE
COMMON
CHARACTERISTIC
SOONER
OR
LATER
THEY
WERE
BROKEN
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
PEOPLE
SENDING
MESSAGES
OVER
A
PUBLIC
CHANNEL
E
G
THE
INTERNET
WISH
TO
USE
ENCRYPTION
SO
THAT
EAVESDROPPERS
LEARN
NOTHING
IN
THE
POST
NP
COMPLETENESS
ERA
A
CRUCIAL
NEW
IDEA
WAS
PRESENTED
THE
CODE
BREAKER
SHOULD
BE
THOUGHT
OF
AS
A
RESOURCE
BOUNDED
COMPUTATIONAL
DEVICE
HENCE
THE
SECURITY
OF
ENCRYPTION
SCHEMES
OUGHT
TO
BE
PROVED
BY
REDUCING
THE
TASK
OF
BREAKING
THE
SCHEME
INTO
THE
TASK
OF
SOLVING
SOME
COMPUTATIONALLY
INTRACTABLE
PROBLEM
SAY
REQUIRING
EXPONENTIAL
TIME
COMPLEXITY
OR
CIRCUIT
SIZE
THUS
ONE
COULD
HOPE
TO
DESIGN
ENCRYPTION
SCHEMES
THAT
ARE
EFFICIENT
ENOUGH
TO
BE
USED
IN
PRACTICE
BUT
WHOSE
BREAKING
WILL
REQUIRE
SAY
MILLIONS
OF
YEARS
OF
COMPUTATION
TIME
EARLY
RESEARCHERS
TRIED
TO
BASE
THE
SECURITY
OF
ENCYPTION
METHODS
UPON
THE
PRESUMED
IN
TRACTABILITY
OF
NP
COMPLETE
PROBLEMS
THIS
EFFORT
HAS
NOT
SUCCEEDED
TO
DATE
SEEMINGLY
BECAUSE
NP
COMPLETENESS
CONCERNS
THE
INTRACTABILITY
OF
PROBLEMS
IN
THE
WORST
CASE
WHEREAS
CRYPTOGRAPHY
SEEMS
TO
NEED
PROBLEMS
THAT
ARE
INTRACTABLE
ON
MOST
INSTANCES
AFTER
ALL
WHEN
WE
ENCRYPT
EMAIL
WE
REQUIRE
THAT
DECRYPTION
SHOULD
BE
DIFFICULT
FOR
AN
EAVESDROPPER
FOR
ALL
OR
ALMOST
ALL
MESSAGES
NOT
JUST
FOR
A
FEW
MESSAGES
THUS
THE
CONCEPT
MOST
USEFUL
IN
THIS
CHAPTER
WILL
BE
AVERAGE
CASE
WE
WILL
SEE
A
CLASS
OF
FUNCTIONS
CALLED
ONE
WAY
FUNCTIONS
THAT
ARE
EASY
TO
COMPUTE
PROBLEM
AVERAGE
CASE
AND
WORST
CASE
COMPLEXITIES
CAN
DIFFER
RADICALLY
FOR
INSTANCE
IS
NP
COMPLETE
HARD
ON
AVERAGE
PROBLEMS
AND
ONE
WAY
FUNCTIONS
BUT
HARD
TO
INVERT
FOR
MOST
INPUTS
THEY
ARE
ALLUDED
TO
IN
LEVIN
QUOTE
ABOVE
SUCH
FUNCTIONS
EXIST
UNDER
A
VARIETY
OF
ASSUMPTIONS
INCLUDING
THE
FAMOUS
ASSUMPTION
THAT
FACTORING
INTEGERS
RE
QUIRES
TIME
SUPER
POLYNOMIAL
TIME
IN
THE
INTEGER
BIT
LENGTH
TO
SOLVE
IN
THE
AVERAGE
CASE
E
G
FOR
A
PRODUCT
OF
TWO
RANDOM
PRIMES
FURTHERMORE
IN
THE
PAST
TWO
DECADES
CRYPTOGRAPHERS
HAVE
TAKEN
ON
TASKS
ABOVE
AND
BEYOND
THE
BASIC
TASK
OF
ENCRYPTION
FROM
IMPLEMENTING
DIGITAL
CASH
TO
MAINTAINING
THE
PRIVACY
OF
INDIVIDUALS
IN
PUBLIC
DATABASES
WE
SURVEY
SOME
APPLICATIONS
IN
SECTION
SURPRISINGLY
MANY
OF
THESE
TASKS
CAN
BE
ACHIEVED
USING
THE
SAME
COMPUTATIONAL
ASSUMPTIONS
USED
FOR
ENCRYPTION
A
CRUCIAL
INGREDIENT
IN
THESE
DEVELOPMENTS
TURNS
OUT
TO
BE
AN
ANSWER
TO
THE
QUESTION
WHAT
IS
A
RANDOM
STRING
AND
HOW
CAN
WE
GENERATE
ONE
THE
COMPLEXITY
THEORETIC
ANSWER
TO
THIS
QUESTION
LEADS
TO
THE
NOTION
OF
A
PSEUDORANDOM
GENERATOR
WHICH
IS
A
CENTRAL
OBJECT
SEE
SECTION
THIS
NOTION
IS
VERY
USEFUL
IN
ITSELF
AND
IS
ALSO
A
TEMPLATE
FOR
SEVERAL
OTHER
KEY
DEFINITIONS
IN
CRYPTOGRAPHY
INCLUDING
THAT
OF
ENCRYPTION
SEE
SECTION
PRIVATE
KEY
VERSUS
PUBLIC
KEY
SOLUTIONS
TO
THE
ENCRYPTION
PROBLEM
TODAY
COME
IN
TWO
DISTINCT
FLAVORS
IN
PRIVATE
KEY
CRYPTOGRAPHY
ONE
ASSUMES
THAT
THE
TWO
OR
MORE
PARTIES
PARTICIPATING
IN
THE
PROTOCOL
SHARE
A
PRIVATE
KEY
NAMELY
A
STATISTICALLY
RANDOM
STRING
OF
MODEST
SIZE
THAT
IS
NOT
KNOWN
TO
THE
IN
A
PUBLIC
KEY
ENCRYPTION
SYSTEM
A
CONCEPT
INTRODUCED
BY
DIFFIE
AND
HELLMAN
IN
WE
DROP
THIS
ASSUMPTION
INSTEAD
A
PARTY
P
PICKS
A
PAIR
OF
KEYS
AN
ENCRYPTION
KEY
AND
DECRYPTION
KEY
BOTH
CHOSEN
AT
RANDOM
FROM
SOME
CORRELATED
DISTRIBUTION
THE
ENCRYPTION
KEY
WILL
BE
USED
TO
ENCRYPT
MESSAGES
TO
P
AND
IS
CONSIDERED
PUBLIC
I
E
PUBLISHED
AND
KNOWN
TO
EVERYBODY
INCLUDING
THE
EAVESDROPPER
THE
DECRYPTION
KEY
IS
KEPT
SECRET
BY
P
AND
IS
USED
TO
DECRYPT
MESSAGES
A
FAMOUS
PUBLIC
KEY
ENCRYPTION
SCHEME
IS
BASED
UPON
THE
RSA
FUNCTION
OF
EXAMPLE
AT
THE
MOMENT
WE
DO
NOT
KNOW
HOW
TO
BASE
PUBLIC
KEY
ENCRYPTION
ON
THE
SOLE
ASSUMPTION
THAT
ONE
WAY
FUNCTIONS
EXIST
AND
CURRENT
CONSTRUCTIONS
REQUIRE
THE
ASSUMPTION
THAT
THERE
EXIST
ONE
WAY
FUNCTIONS
WITH
SOME
SPECIAL
STRUCTURE
SUCH
AS
RSA
FACTORING
BASED
AND
LATTICE
BASED
ONE
WAY
FUNCTIONS
MOST
TOPICS
DESCRIBED
IN
THIS
CHAPTER
ARE
TRADITIONALLY
LABELED
PRIVATE
KEY
CRYPTOGRAPHY
HARD
ON
AVERAGE
PROBLEMS
AND
ONE
WAY
FUNCTIONS
A
BASIC
CRYPTOGRAPHIC
PRIMITIVE
IS
A
ONE
WAY
FUNCTION
ROUGHLY
SPEAKING
THIS
IS
A
FUNCTION
F
THAT
IS
EASY
TO
COMPUTE
BUT
HARD
TO
INVERT
NOTICE
THAT
IF
F
IS
NOT
ONE
TO
ONE
THEN
THE
INVERSE
F
X
MAY
NOT
BE
UNIQUE
IN
SUCH
CASES
INVERTING
MEANS
THAT
GIVEN
F
X
THE
ALGORITHM
IS
ABLE
TO
PRODUCE
SOME
PREIMAGE
NAMELY
ANY
ELEMENT
OF
F
F
X
WE
SAY
THAT
THE
FUNCTION
IS
ONE
WAY
FUNCTION
IF
INVERSION
IS
DIFFICULT
FOR
THE
AVERAGE
OR
MANY
X
NOW
WE
DEFINE
THIS
FORMALLY
A
DISCUSSION
OF
THIS
DEFINITION
APPEARS
BELOW
IN
SECTION
A
FUNCTION
FAMILY
GN
IS
A
FAMILY
OF
FUNCTIONS
WHERE
GN
TAKES
N
BIT
INPUTS
IT
IS
POLYNOMIAL
TIME
COMPUTABLE
IF
THERE
IS
A
POLYNOMIAL
TIME
TM
THAT
GIVEN
AN
INPUT
X
COMPUTES
G
X
X
ON
GENERAL
GRAPHS
BUT
ON
MOST
N
NODE
GRAPHS
IS
SOLVABLE
IN
QUADRATIC
TIME
OR
LESS
A
DEEPER
STUDY
OF
AVERAGE
CASE
COMPLEXITY
APPEARS
IN
CHAPTER
THIS
COULD
BE
ENSURED
WITH
A
FACE
TO
FACE
MEETING
THAT
MIGHT
OCCUR
LONG
BEFORE
THE
TRANSMISSION
OF
MESSAGES
WEB
DRAFT
HARD
ON
AVERAGE
PROBLEMS
AND
ONE
WAY
FUNCTIONS
DEFINITION
ONE
WAY
FUNCTION
A
FAMILY
OF
FUNCTIONS
FN
N
M
N
IS
E
N
ONE
WAY
WITH
SECURITY
N
IF
IT
IS
POLYNOMIAL
TIME
COMPUTABLE
AND
FURTHERMORE
FOR
EVERY
ALGORITHM
A
THAT
RUNS
IN
TIME
N
PRX
N
A
INVERTS
FN
X
E
N
NOW
WE
GIVE
A
FEW
EXAMPLES
AND
DISCUSS
THE
EVIDENCE
THAT
THEY
ARE
HARD
TO
INVERT
ON
AVERAGE
INPUTS
EXAMPLE
THE
FIRST
EXAMPLE
IS
MOTIVATED
BY
THE
FACT
THAT
FINDING
THE
PRIME
FACTORS
OF
A
GIVEN
INTEGER
IS
THE
FAMOUS
FACTORING
PROBLEM
FOR
WHICH
THE
BEST
CURRENT
ALGORITHM
HAS
RUNNING
TIME
ABOUT
AND
EVEN
THAT
BOUNDS
RELIES
ON
THE
TRUTH
OF
SOME
UNPROVEN
CONJECTURES
IN
NUMBER
THEORY
THE
HARDEST
INPUTS
FOR
CURRENT
ALGORITHMS
APPEAR
TO
BE
OF
THE
TYPE
X
Y
WHERE
X
Y
ARE
RANDOM
PRIMES
OF
ROUGHLY
EQUAL
SIZE
HERE
IS
A
FIRST
ATTEMPT
TO
DEFINE
A
ONE
WAY
FUNCTION
USING
THIS
OBSERVATION
LET
FN
BE
A
FAMILY
OF
FUNCTIONS
WHERE
FN
N
N
IS
DEFINED
AS
FN
X
Y
X
Y
IF
X
AND
Y
ARE
PRIMES
WHICH
BY
THE
PRIME
NUMBER
THEOREM
HAPPENS
WITH
PROBABILITY

WHEN
X
Y
ARE
RANDOM
N
BIT
INTEGERS
THEN
FN
SEEMS
HARD
TO
INVERT
IT
IS
WIDELY
BELIEVED
THAT
THERE
ARE
F
C
F
SUCH
THAT
FAMILY
FN
IS
NC
ONE
WAY
WITH
SECURITY
PARAMETER
AN
EVEN
HARDER
VERSION
OF
THE
ABOVE
FUNCTION
IS
OBTAINED
BY
USING
THE
EXISTENCE
OF
A
RANDOMIZED
POLYNOMIAL
TIME
ALGORITHM
A
WHICH
WE
DO
NOT
DESCRIBE
THAT
GIVEN
GENERATES
A
RANDOM
N
BIT
PRIME
NUMBER
SUPPOSE
A
USES
M
RANDOM
BITS
WHERE
M
POLY
N
THEN
A
MAY
BE
SEEN
AS
A
DETERMINISTIC
MAPPING
FROM
M
BIT
STRINGS
TO
N
BIT
PRIMES
NOW
LET
FUNCTION
F
M
MAP
TO
A
A
WHERE
A
A
ARE
THE
PRIMES
OUTPUT
BY
A
USING
RANDOM
STRINGS
RESPECTIVELY
THIS
FUNCTION
SEEMS
HARD
TO
INVERT
FOR
ALMOST
ALL
NOTE
THAT
ANY
INVERSE
FOR
F
M
ALLOWS
US
TO
FACTOR
THE
INTEGER
A
A
SINCE
UNIQUE
FACTORIZATION
IMPLIES
THAT
THE
PRIME
PAIR
A
A
MUST
BE
THE
SAME
AS
A
A
IT
IS
WIDELY
CONJECTURE
THAT
THERE
ARE
C
F
SUCH
THAT
F
N
IS
NC
ONE
WAY
WITH
SECURITY
PARAMETER
F
THE
FACTORING
PROBLEM
A
MAINSTAY
OF
MODERN
CRYPTOGRAPHY
IS
OF
COURSE
THE
INVERSE
OF
MULTIPLICATION
WHO
WOULD
HAVE
THOUGHT
THAT
THE
HUMBLE
MULTIPLICATION
TAUGHT
TO
CHILDREN
IN
SECOND
GRADE
COULD
BE
THE
SOURCE
OF
SUCH
POWER
THE
NEXT
TWO
EXAMPLES
ALSO
RELY
ON
ELEMENTARY
MATHEMATICAL
OPERATIONS
SUCH
AS
EXPONENTIATION
ALBEIT
WITH
MODULAR
ARITHMETIC
EXAMPLE
LET
BE
A
SEQUENCE
OF
PRIMES
WHERE
PI
HAS
I
BITS
LET
GI
BE
THE
GENERATOR
OF
THE
GROUP
ZP
I
THE
SET
OF
NUMBERS
THAT
ARE
NONZERO
MOD
PI
THEN
FOR
EVERY
Y
PI
THERE
IS
A
UNIQUE
X
P
SUCH
THAT
GX
Y
MOD
PI
WEB
DRAFT
HARD
ON
AVERAGE
PROBLEMS
AND
ONE
WAY
FUNCTIONS
THEN
X
GX
MOD
PI
IS
A
PERMUTATION
ON
PI
AND
IS
CONJECTURED
TO
BE
ONE
WAY
THE
INVERSION
PROBLEM
IS
CALLED
THE
DISCRETE
LOG
PROBLEM
WE
SHOW
BELOW
USING
RANDOM
SELF
REDUCIBILITY
THAT
IF
IT
IS
HARD
ON
WORST
CASE
INPUTS
THEN
IT
IS
HARD
ON
AVERAGE
WE
LIST
SOME
MORE
CONJECTURED
ONE
WAY
FUNCTIONS
EXAMPLE
RSA
FUNCTION
LET
M
PQ
WHERE
P
Q
ARE
LARGE
RANDOM
PRIMES
AND
E
BE
A
RANDOM
NUMBER
COPRIME
TO

M
P
Q
LET
ZM
BE
THE
SET
OF
INTEGERS
IN
M
COPRIME
TO
M
THEN
THE
FUNCTION
IS
DEFINED
TO
BE
FP
Q
E
X
XE
MOD
M
THIS
FUNCTION
IS
USED
IN
THE
FAMOUS
RSA
PUBLIC
KEY
CRYPTOSYSTEM
RABIN
FUNCTION
FOR
A
COMPOSITE
NUMBER
M
DEFINE
FM
X
MOD
M
IF
WE
CAN
INVERT
THIS
FUNCTION
ON
A
POLY
LOG
M
FRACTION
OF
INPUTS
THEN
WE
CAN
FACTOR
M
IN
POLY
LOG
M
TIME
SEE
EXERCISES
BOTH
THE
RSA
AND
RABIN
FUNCTIONS
ARE
USEFUL
IN
PUBLIC
KEY
CRYPTOGRAPHY
THEY
ARE
EXAMPLES
OF
TRAPDOOR
ONE
WAY
FUNCTIONS
IF
THE
FACTORS
OF
M
THE
TRAPDOOR
INFORMATION
ARE
GIVEN
AS
WELL
THEN
IT
IS
EASY
TO
INVERT
THE
ABOVE
FUNCTIONS
TRAPDOOR
FUNCTIONS
ARE
FASCINATING
OBJECTS
BUT
WILL
NOT
BE
STUDIED
FURTHER
HERE
RANDOM
SUBSET
SUM
LET
M
LET
THE
INPUTS
TO
F
BE
N
POSITIVE
M
BIT
INTEGERS
AN
AND
A
SUBSET
OF
N
ITS
OUTPUT
IS
AN
I
AI
NOTE
THAT
F
MAPS
N
M
BIT
INPUTS
TO
NM
M
BITS
WHEN
THE
INPUTS
ARE
RANDOMLY
CHOSEN
THIS
FUNCTION
SEEMS
HARD
TO
INVERT
IT
IS
CONJECTURED
THAT
THERE
IS
C
D
SUCH
THAT
THIS
FUNCTION
IS
NC
ONE
WAY
WITH
SECURITY
DISCUSSION
OF
THE
DEFINITION
OF
ONE
WAY
FUNCTION
WE
WILL
ALWAYS
ASSUME
THAT
THE
THE
ONE
WAY
FUNCTION
UNDER
CONSIDERATION
IS
SUCH
THAT
THE
SECURITY
PARAMETER
N
IS
SUPERPOLYNOMIAL
I
E
LARGER
THAN
NK
FOR
EVERY
K
THE
FUNCTIONS
DESCRIBED
EARLIER
ARE
ACTUALLY
BELIEVED
TO
BE
ONE
WAY
WITH
A
LARGER
SECURITY
PARAMETER
FOR
SOME
FIXED
E
OF
GREATER
INTEREST
IS
THE
ERROR
PARAMETER
E
N
SINCE
IT
DETERMINES
THE
FRACTION
OF
INPUTS
FOR
WHICH
INVERSION
IS
EASY
CLEARLY
A
CONTINUUM
OF
VALUES
IS
POSSIBLE
BUT
TWO
IMPORTANT
CASES
TO
CONSIDER
ARE
I
E
N
NC
FOR
SOME
FIXED
C
IN
OTHER
WORDS
THE
FUNCTION
IS
DIFFICULT
TO
INVERT
ON
AT
LEAST
NC
FRACTION
OF
INPUTS
SUCH
A
FUNCTION
IS
OFTEN
CALLED
A
WEAK
ONE
WAY
FUNCTION
THE
SIMPLE
ONE
WAY
FUNCTION
FN
OF
EXAMPLE
IS
CONJECTURED
TO
BE
OF
THIS
TYPE
II
E
N
NK
FOR
EVERY
K
SUCH
A
FUNCTION
IS
CALLED
A
STRONG
ONE
WAY
FUNCTION
YAO
SHOWED
THAT
IF
WEAK
ONE
WAY
FUNCTIONS
EXIST
THEN
SO
DO
STRONG
ONE
WAY
FUNCTIONS
WE
WILL
PROVE
THIS
SURPRISING
THEOREM
ACTUALLY
SOMETHING
CLOSE
TO
IT
IN
CHAPTER
WE
WILL
NOT
USE
IT
IN
THIS
CHAPTER
EXCEPT
AS
A
JUSTIFICATION
FOR
OUR
INTUITION
THAT
STRONG
ONE
WAY
FUNCTIONS
EXIST
DRAFT
WEB
DRAFT
WHAT
IS
A
RANDOM
ENOUGH
STRING
ANOTHER
JUSTIFICATION
IS
OF
COURSE
THE
EMPIRICAL
OBSERVATION
THAT
THE
CANDIDATE
ONE
WAY
FUNCTIONS
MENTIONED
ABOVE
DO
SEEM
APPEAR
DIFFICULT
TO
INVERT
ON
MOST
INPUTS
RANDOM
SELF
REDUCIBILITY
ROUGHLY
SPEAKING
A
PROBLEM
IS
RANDOM
SELF
REDUCIBLE
IF
SOLVING
THE
PROBLEM
ON
ANY
INPUT
X
REDUCES
TO
SOLVING
THE
PROBLEM
ON
A
SEQUENCE
OF
RANDOM
INPUTS
WHERE
EACH
YI
IS
UNIFORMLY
DISTRIBUTED
AMONG
ALL
INPUTS
TO
PUT
IT
MORE
INTUITIVELY
THE
WORST
CASE
CAN
BE
REDUCED
TO
THE
AVERAGE
CASE
HENCE
THE
PROBLEM
IS
EITHER
EASY
ON
ALL
INPUTS
OR
HARD
ON
MOST
INPUTS
IN
OTHER
WORDS
WE
CAN
EXCLUDE
THE
POSSIBILITY
THAT
PROBLEM
IS
EASY
ON
ALMOST
ALL
THE
INPUTS
BUT
NOT
ALL
IF
A
FUNCTION
IS
ONE
WAY
AND
ALSO
RANDOMLY
SELF
REDUCIBLE
THEN
IT
MUST
BE
A
STRONG
ONE
WAY
FUNCTION
THIS
IS
BEST
ILLUSTRATED
WITH
AN
EXAMPLE
THEOREM
SUPPOSE
A
IS
AN
ALGORITHM
WITH
RUNNING
TIME
T
N
THAT
GIVEN
A
PRIME
P
A
GENERATOR
G
FOR
Z
P
AND
AN
INPUT
GX
MOD
P
MANAGES
TO
FIND
X
FOR

FRACTION
OF
X
Z
P
THEN
THERE
IS
A
RANDOMIZED
ALGORITHM
AI
WITH
RUNNING
TIME
O
T
N
POLY
N
THAT
SOLVES
DISCRETE
LOG
ON
EVERY
INPUT
WITH
PROBABILITY
AT
LEAST
E
PROOF
SUPPOSE
WE
ARE
GIVEN
Y
GX
MOD
P
AND
WE
ARE
TRYING
TO
FIND
X
REPEAT
THE
FOLLOWING
TRIAL
O

LOG
E
TIMES
RANDOMLY
PICK
R
P
AND
USE
A
TO
TRY
TO
COMPUTE
THE
LOGARITHM
OF
Y
GR
MODP
SUPPOSE
A
OUTPUTS
Z
CHECK
IF
GZ
R
MODP
IS
Y
AND
IF
SO
OUTPUT
Z
R
MOD
P
AS
THE
ANSWER
THE
MAIN
OBSERVATION
IS
THAT
IF
R
IS
RANDOMLY
CHOSEN
THEN
Y
GR
MOD
P
IS
RANDOMLY
DISTRIBUTED
IN
Z
P
AND
HENCE
THE
HYPOTHESIS
IMPLIES
THAT
A
HAS
A

CHANCE
OF
FINDING
ITS
DISCRETE
LOG
AFTER
O

LOG
E
TRIALS
THE
PROBABILITY
THAT
A
FAILED
EVERY
TIME
IS
AT
MOST
E
COROLLARY
IF
FOR
ANY
INFINITE
SEQUENCE
OF
PRIMES
DISCRETE
LOG
MOD
PI
IS
HARD
ON
WORST
CASE
X
Z
PI
THEN
IT
IS
HARD
FOR
ALMOST
ALL
X
LATER
AS
PART
OF
THE
PROOF
OF
THEOREM
WE
GIVE
ANOTHER
EXAMPLE
OF
RANDOM
SELF
REDUCIBILITY
LINEAR
FUNCTIONS
OVER
GF
WHAT
IS
A
RANDOM
ENOUGH
STRING
CRYPTOGRAPHY
OFTEN
BECOMES
MUCH
EASIER
IF
WE
HAVE
AN
ABUNDANT
SUPPLY
OF
RANDOM
BITS
HERE
IS
AN
EXAMPLE
EXAMPLE
ONE
TIME
PAD
SUPPOSE
THE
MESSAGE
SENDER
AND
RECEIVER
SHARE
A
LONG
STRING
R
OF
RANDOM
BITS
THAT
IS
NOT
AVAILABLE
TO
EAVESDROPPERS
THEN
SECURE
COMMUNICATION
IS
EASY
TO
ENCODE
MESSAGE
M
N
TAKE
THE
FIRST
N
BITS
OF
R
SAY
THE
STRING
INTERPRET
BOTH
STRINGS
AS
VECTORS
IN
GF
N
AND
ENCRYPT
M
BY
THE
VECTOR
M
THE
RECEIVER
DECRYPTS
THIS
MESSAGE
BY
ADDING
TO
IT
NOTE
THAT
IN
GF
N
WEB
DRAFT
WHAT
IS
A
RANDOM
ENOUGH
STRING
IF
IS
STATISTICALLY
RANDOM
THEN
SO
IS
M
HENCE
THE
EAVESDROPPER
PROVABLY
CANNOT
OBTAIN
EVEN
A
SINGLE
BIT
OF
INFORMATION
ABOUT
M
REGARDLESS
OF
HOW
MUCH
COMPUTATIONAL
POWER
HE
EXPENDS
NOTE
THAT
REUSING
IS
A
STRICT
NO
NO
HENCE
THE
NAME
ONE
TIME
PAD
IF
THE
SENDER
EVER
REUSES
TO
ENCRYPT
ANOTHER
MESSAGE
MI
THEN
THE
EAVESDROPPER
CAN
ADD
THE
TWO
VECTORS
TO
OBTAIN
M
MI
M
MI
WHICH
IS
SOME
NONTRIVIAL
INFORMATION
ABOUT
THE
TWO
MESSAGES
OF
COURSE
THE
ONE
TIME
PAD
IS
JUST
A
MODERN
VERSION
OF
THE
OLD
IDEA
OF
USING
CODEBOOKS
WITH
A
NEW
KEY
PRESCRIBED
FOR
EACH
DAY
ONE
TIME
PADS
ARE
CONCEPTUALLY
SIMPLE
BUT
IMPRACTICAL
TO
USE
BECAUSE
THE
USERS
NEED
TO
AGREE
IN
ADVANCE
ON
A
SECRET
PAD
THAT
IS
LARGE
ENOUGH
TO
BE
USED
FOR
ALL
THEIR
FUTURE
COMMUNICATIONS
IT
IS
ALSO
HARD
TO
GENERATE
BECAUSE
SOURCES
OF
QUALITY
RANDOM
BITS
E
G
THOSE
BASED
UPON
QUANTUM
PHENOMENA
ARE
OFTEN
TOO
SLOW
CRYPTOGRAPHY
SUGGESTED
SOLUTION
TO
SUCH
PROBLEMS
IS
TO
USE
A
PSEUDORANDOM
GENERATOR
THIS
IS
A
DETERMINISTICALLY
COMPUTABLE
FUNCTION
G
N
NC
FOR
SOME
C
SUCH
THAT
IF
X
N
IS
RANDOMLY
CHOSEN
THEN
G
X
LOOKS
RANDOM
THUS
SO
LONG
AS
USERS
HAVE
BEEN
PROVIDED
A
COMMON
N
BIT
RANDOM
STRING
THEY
CAN
USE
THE
GENERATOR
TO
PRODUCE
NC
RANDOM
LOOKING
BITS
WHICH
CAN
BE
USED
TO
ENCRYPT
NC
MESSAGES
OF
LENGTH
N
IN
CRYPTOGRAPHY
THIS
IS
CALLED
A
STREAM
CIPHER
CLEARLY
AT
THIS
POINT
WE
NEED
AN
ANSWER
TO
THE
QUESTION
POSED
IN
THE
SECTION
TITLE
PHILOSOPHERS
AND
STATISTICIANS
HAVE
LONG
STRUGGLED
WITH
THIS
QUESTION
EXAMPLE
WHAT
IS
A
RANDOM
ENOUGH
STRING
HERE
IS
KOLMOGOROV
DEFINITION
A
STRING
OF
LENGTH
N
IS
RANDOM
IF
NO
TURING
MACHINE
WHOSE
DESCRIPTION
LENGTH
IS
SAY
OUTPUTS
THIS
STRING
WHEN
STARTED
ON
AN
EMPTY
TAPE
THIS
DEFINITION
IS
THE
RIGHT
DEFINITION
IN
SOME
PHILOSOPHICAL
AND
TECHNICAL
SENSE
WHICH
WE
WILL
NOT
GET
INTO
HERE
BUT
IS
NOT
VERY
USEFUL
IN
THE
COMPLEXITY
SETTING
BECAUSE
CHECKING
IF
A
STRING
IS
RANDOM
ACCORDING
TO
THIS
DEFINITION
IS
UNDECIDABLE
STATISTICIANS
HAVE
ALSO
ATTEMPTED
DEFINITIONS
WHICH
BOIL
DOWN
TO
CHECKING
IF
THE
STRING
HAS
THE
RIGHT
NUMBER
OF
PATTERNS
THAT
ONE
WOULD
EXPECT
BY
THE
LAWS
OF
STATISTICS
E
G
THE
NUMBER
OF
TIMES
APPEARS
AS
A
SUBSTRING
SEE
KNUTH
VOLUME
FOR
A
COMPREHENSIVE
DISCUSSION
IT
TURNS
OUT
THAT
SUCH
DEFINITIONS
ARE
TOO
WEAK
IN
THE
CRYPTOGRAPHIC
SETTING
ONE
CAN
FIND
A
DISTRIBUTION
THAT
PASSES
THESE
STATISTICAL
TESTS
BUT
STILL
WILL
BE
COMPLETELY
INSECURE
IF
USED
TO
GENERATE
THE
PAD
FOR
THE
ONE
TIME
PAD
ENCRYPTION
SCHEME
BLUM
MICALI
AND
YAO
DEFINITIONS
NOW
WE
INTRODUCE
TWO
COMPLEXITY
THEORETIC
DEFINITIONS
OF
PSEUDORANDOMNESS
DUE
TO
BLUM
MICALI
AND
YAO
IN
THE
EARLY
FOR
A
STRING
Y
N
AND
N
WE
LET
Y
DENOTE
THE
PROJECTION
OF
Y
TO
THE
COORDINATES
OF
IN
PARTICULAR
Y
I
DENOTES
THE
FIRST
I
BITS
OF
Y
DRAFT
WEB
DRAFT
WHAT
IS
A
RANDOM
ENOUGH
STRING
THE
BLUM
MICALI
DEFINITION
IS
MOTIVATED
BY
THE
OBSERVATION
THAT
ONE
PROPERTY
IN
FACT
THE
DEFIN
ING
PROPERTY
OF
A
STATISTICALLY
RANDOM
SEQUENCE
OF
BITS
Y
IS
THAT
GIVEN
Y
I
WE
CANNOT
PREDICT
YI
WITH
ODDS
BETTER
THAN
REGARDLESS
OF
THE
COMPUTATIONAL
POWER
AVAILABLE
TO
US
THUS
ONE
COULD
DEFINE
A
PSEUDORANDOM
STRING
BY
CONSIDERING
PREDICTORS
THAT
HAVE
LIMITED
COMPUTATIONAL
RESOURCES
AND
TO
SHOW
THAT
THEY
CANNOT
ACHIEVE
ODDS
MUCH
BETTER
THAN
IN
PREDICTING
YI
FROM
Y
I
OF
COURSE
THIS
DEFINITION
HAS
THE
SHORTCOMING
THAT
ANY
SINGLE
FINITE
STRING
WOULD
BE
PREDICTABLE
FOR
A
TRIVIAL
REASON
IT
COULD
BE
HARDWIRED
INTO
THE
PROGRAM
OF
THE
PREDICTOR
TURING
MACHINE
TO
GET
AROUND
THIS
DIFFICULTY
THE
BLUM
MICALI
DEFINITION
AND
ALSO
YAO
DEFINITION
BELOW
DEFINES
PSEUDORANDOMNESS
FOR
DISTRIBUTIONS
OF
STRINGS
RATHER
THAN
FOR
INDIVIDUAL
STRINGS
FURTHER
MORE
THE
DEFINITION
CONCERNS
AN
INFINITE
SEQUENCE
OF
DISTRIBUTIONS
ONE
FOR
EACH
INPUT
SIZE
DEFINITION
BLUM
MICALI
LET
GN
BE
A
POLYNOMIAL
TIME
COMPUTABLE
FAMILY
OF
FUNCTIONS
WHERE
GN
N
M
AND
M
M
N
N
WE
SAY
THE
FAMILY
IS
E
N
T
N
UNPREDICTABLE
IF
FOR
EVERY
PROBABILISTIC
POLYNOMIAL
TIME
ALGORITHM
A
THAT
RUNS
IN
TIME
T
N
AND
EVERY
LARGE
ENOUGH
INPUT
SIZE
N
PR
A
G
X
I
G
X
I
E
N
WHERE
THE
PROBABILITY
IS
OVER
THE
CHOICE
OF
X
N
I
N
AND
THE
RANDOMNESS
USED
BY
A
IF
FOR
EVERY
FIXED
K
THE
FAMILY
GN
IS
NC
NK
UNPREDICTABLE
FOR
EVERY
C
THEN
WE
SAY
IN
SHORT
THAT
IT
IS
UNPREDICTABLE
BY
POLYNOMIAL
TIME
ALGORITHMS
REMARK
ALLOWING
THE
TESTER
TO
BE
AN
ARBITRARY
POLYNOMIAL
TIME
MACHINE
MAKES
PERFECT
SENSE
IN
A
CRYPTO
GRAPHIC
SETTING
WHERE
WE
WISH
TO
ASSUME
NOTHING
ABOUT
THE
ADVERSARY
EXCEPT
AN
UPPERBOUND
ON
HER
COMPUTATIONAL
POWER
PSEUDORANDOM
GENERATORS
PROPOSED
IN
THE
PRE
COMPLEXITY
ERA
SUCH
AS
THE
POPULAR
LINEAR
OR
QUADTRATIC
CONGRUENTIAL
GENERATORS
DO
NOT
SATISFY
THE
BLUM
MICALI
DEFINITION
BECAUSE
BIT
PREDICTION
CAN
IN
FACT
BE
DONE
IN
POLYNOMIAL
TIME
YAO
GAVE
AN
ALTERNATIVE
DEFINITION
IN
WHICH
THE
TESTER
MACHINE
IS
GIVEN
ACCESS
TO
THE
ENTIRE
STRING
AT
ONCE
THIS
DEFINITION
IMPLICITLY
SETS
UP
A
TEST
OF
RANDOMNESS
ANALOGOUS
TO
THE
MORE
FAMOUS
TURING
TEST
FOR
INTELLIGENCE
SEE
FIGURE
THE
TESTER
MACHINE
A
IS
GIVEN
A
STRING
Y
NC
THAT
IS
PRODUCED
IN
ONE
OF
TWO
WAYS
IT
IS
EITHER
DRAWN
FROM
THE
UNIFORM
DISTRIBUTION
ON
NC
OR
GENERATED
BY
TAKING
A
RANDOM
STRING
X
N
AND
STRETCHING
IT
USING
A
DETERMINISTIC
FUNCTION
G
N
NC
THE
TESTER
IS
ASKED
TO
OUTPUT
IF
THE
STRING
LOOKS
RANDOM
TO
IT
AND
OTHERWISE
WE
SAY
THAT
G
IS
A
PSEUDORANDOM
GENERATOR
IF
NO
POLYNOMIAL
TIME
TESTER
MACHINE
A
HAS
A
GREAT
CHANCE
OF
BEING
ABLE
TO
DETERMINE
WHICH
OF
THE
TWO
DISTRIBUTIONS
THE
STRING
CAME
FROM
DEFINITION
LET
GN
BE
A
POLYNOMIAL
TIME
COMPUTABLE
FAMILY
OF
FUNCTIONS
WHERE
GN
N
M
AND
M
M
N
N
WE
SAY
IT
IS
A

N
N
PSEUDORANDOM
GENERATOR
IF
FOR
EVERY
PROBABILISTIC
ALGORITHM
A
RUNNING
IN
TIME
N
AND
FOR
ALL
LARGE
ENOUGH
N
PRY
NC
A
Y
PRX
N
A
GN
X

N
WEB
DRAFT
WHAT
IS
A
RANDOM
ENOUGH
STRING
WE
CALL

N
THE
DISTINGUISHING
PROBABILITY
AND
N
THE
SECURITY
PARAMETER
IF
FOR
EVERY
CI
K
THE
FAMILY
IS
NC
NK
PSEUDORANDOM
THEN
WE
SAY
IN
SHORT
THAT
IT
IS
A
PSEUDORANDOM
GENERATOR
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
YAO
DEFINITION
IF
C
THEN
G
N
NC
IS
A
PSEUDORANDOM
GENERATOR
IF
NO
POLYNOMIAL
TIME
TESTER
HAS
A
GOOD
CHANCE
OF
DISTINGUISHING
BETWEEN
TRULY
RANDOM
STRINGS
OF
LENGTH
N
AND
STRINGS
GENERATED
BY
APPLYING
G
ON
RANDOM
N
BIT
STRINGS
EQUIVALENCE
OF
THE
TWO
DEFINITIONS
YAO
SHOWED
THAT
THE
ABOVE
TWO
DEFINITIONS
ARE
EQUIVALENT
UP
TO
MINOR
CHANGES
IN
THE
SECURITY
PARAMETER
A
FAMILY
IS
A
PSEUDORANDOM
GENERATOR
IFF
IT
IS
BITWISE
UNPREDICTABLE
THE
HYBRID
ARGUMENT
USED
IN
THIS
PROOF
HAS
BECOME
A
CENTRAL
IDEA
OF
CRYPTOGRAPHY
AND
COMPLEXITY
THEORY
THE
NONTRIVIAL
DIRECTION
OF
THE
EQUIVALENCE
IS
TO
SHOW
THAT
PSEUDORANDOMNESS
OF
THE
BLUM
MICALI
TYPE
IMPLIES
PSEUDORANDOMNESS
OF
THE
YAO
TYPE
NOT
SURPRISINGLY
THIS
DIRECTION
IS
ALSO
MORE
IMPORTANT
IN
A
PRACTICAL
SENSE
DESIGNING
PSEUDORANDOM
GENERATORS
SEEMS
EASIER
FOR
THE
BLUM
MICALI
DEFINITION
AS
ILLUSTRATED
BY
THE
GOLDREICH
LEVIN
CONSTRUCTION
BELOW
WHEREAS
YAO
DEFINITION
SEEMS
MORE
POWERFUL
FOR
APPLICATIONS
SINCE
IT
ALLOWS
THE
ADVERSARY
UNRESTRICTED
ACCESS
TO
THE
PSEUDORANDOM
STRING
THUS
YAO
THEOREM
PROVIDES
A
BRIDGE
BETWEEN
WHAT
WE
CAN
PROVE
AND
WHAT
WE
NEED
PROOF
THE
CONVERSE
PART
IS
TRIVIAL
SINCE
A
BIT
PREDICTION
ALGORITHM
CAN
IN
PARTICULAR
BE
USED
TO
DISTINGUISH
G
X
FROM
RANDOM
STRINGS
OF
THE
SAME
LENGTH
IT
IS
LEFT
TO
THE
READER
LET
N
BE
SHORTHAND
FOR
N
N
SUPPOSE
G
IS
NOT
E
N
T
N
PSEUDORANDOM
AND
A
IS
A
DISTIN
GUISHING
ALGORITHM
THAT
RUNS
IN
T
N
TIME
AND
SATISFIES
PRN
A
G
X
PR
A
Y
E
N
N
B
Y
BY
CONSIDERING
EITHER
A
OR
THE
ALGORITHM
THAT
IS
A
WITH
THE
ANSWER
FLIPPED
WE
CAN
ASSUME
THAT
THE
CAN
BE
REMOVED
AND
IN
FACT
PR
A
G
X
PR
DRAFT
A
Y
E
N
N
WHAT
IS
A
RANDOM
ENOUGH
STRING
CONSIDER
B
THE
FOLLOWING
BIT
PREDICTION
ALGORITHM
LET
ITS
INPUT
BE
G
X
I
WHERE
X
N
AND
I
N
ARE
CHOSEN
UNIFORMLY
AT
RANDOM
B
PROGRAM
IS
PICK
BITS
UI
UI
UN
RANDOMLY
AND
RUN
A
ON
THE
INPUT
G
X
IUI
UN
IF
A
OUTPUTS
OUTPUT
UI
ELSE
OUTPUT
UI
CLEARLY
B
RUNS
IN
TIME
LESS
THAN
T
N
O
N
N
N
TO
COMPLETE
THE
PROOF
WE
SHOW
THAT
B
PREDICTS
G
X
I
CORRECTLY
WITH
PROBABILITY
AT
LEAST
E
N
N
CONSIDER
A
SEQUENCE
OF
N
DISTRIBUTIONS
THROUGH
DN
DEFINED
AS
FOLLOWS
IN
ALL
CASES
X
N
AND
UN
ARE
ASSUMED
TO
BE
CHOSEN
RANDOMLY
UN
G
X
UN
DI
G
X
IUI
UN
DN
G
X
X
G
X
N
FURTHERMORE
WE
DENOTE
BY
DI
THE
DISTRIBUTION
OBTAINED
FROM
DI
BY
FLIPPING
THE
ITH
BIT
I
E
REPLACING
G
X
I
BY
G
X
I
IF
D
IS
ANY
OF
THESE
N
DISTRIBUTIONS
THEN
WE
DENOTE
PRY
D
A
Y
BY
Q
D
WITH
THIS
NOTATION
WE
REWRITE
AS
Q
DN
Q
E
N
FURTHERMORE
IN
DI
THE
I
TH
BIT
IS
EQUALLY
LIKELY
TO
BE
G
X
I
AND
G
X
I
SO
Q
DI
Q
DI
Q
DI
NOW
WE
ANALYZE
THE
PROBABILITY
THAT
B
PREDICTS
G
X
I
CORRECTLY
SINCE
I
IS
PICKED
RANDOMLY
WE
HAVE
PR
B
IS
CORRECT
N
PR
B
GUESS
FOR
G
X
I
IS
CORRECT
UI
G
X
I
I
X
N
I
X
U
PR
B
GUESS
FOR
G
X
I
IS
CORRECT
UI
G
X
I
X
U
SINCE
B
GUESS
IS
UI
IFF
A
OUTPUTS
THIS
IS
N
I
I
Q
D
I
N
WEB
DRAFT
ONE
WAY
FUNCTIONS
AND
PSEUDORANDOM
NUMBER
GENERATORS
FROM
Q
DI
Q
DI
Q
DI
Q
DI
SO
THIS
BECOMES
N
N
Q
DN
Q
THIS
FINISHES
OUR
PROOF
E
N
N
ONE
WAY
FUNCTIONS
AND
PSEUDORANDOM
NUMBER
GENERATORS
DO
PSEUDORANDOM
GENERATORS
EXIST
SURPRISINGLY
THE
ANSWER
THOUGH
WE
WILL
NOT
PROVE
IT
IN
FULL
GENERALITY
IS
THAT
THEY
DO
IF
AND
ONLY
IF
ONE
WAY
FUNCTIONS
EXIST
THEOREM
ONE
WAY
FUNCTIONS
EXIST
IFF
PSEUDORANDOM
GENERATORS
DO
SINCE
WE
HAD
SEVERAL
PLAUSIBLE
CANDIDATES
FOR
ONE
WAY
FUNCTIONS
IN
SECTION
THIS
RESULT
HELPS
US
DESIGN
PSEUDORANDOM
GENERATORS
USING
THOSE
CANDIDATE
ONE
WAY
FUNCTIONS
IF
THE
PSEUDORANDOM
GENERATORS
ARE
EVER
PROVED
TO
BE
INSECURE
THEN
THE
CANDIDATE
ONE
WAY
FUNCTIONS
WERE
IN
FACT
NOT
ONE
WAY
AND
SO
WE
WOULD
OBTAIN
AMONG
OTHER
THINGS
EFFICIENT
ALGORITHMS
FOR
FACTORING
AND
DISCRETE
LOG
THE
IF
DIRECTION
OF
THEOREM
IS
TRIVIAL
IF
G
IS
A
PSEUDORANDOM
GENERATOR
THEN
IT
MUST
ALSO
BE
A
ONE
WAY
FUNCTION
SINCE
OTHERWISE
THE
ALGORITHM
THAT
INVERTS
G
WOULD
BE
ABLE
TO
DISTINGUISH
ITS
OUTPUTS
FROM
RANDOM
STRINGS
THE
ONLY
IF
DIRECTION
IS
MORE
DIFFICULT
AND
INVOLVES
USING
A
ONE
WAY
FUNCTION
TO
EXPLICITLY
CONSTRUCT
A
PSEUDORANDOM
GENERATOR
WE
WILL
DO
THIS
ONLY
FOR
THE
SPECIAL
CASE
OF
ONE
WAY
FUNCTIONS
THAT
ARE
PERMUTATIONS
NAMELY
THEY
MAP
N
TO
N
IN
A
ONE
TO
ONE
AND
ONTO
FASHION
AS
A
FIRST
STEP
WE
DESCRIBE
THE
GOLDREICH
LEVIN
THEOREM
WHICH
GIVES
AN
EASY
WAY
TO
PRODUCE
ONE
PSEUDORANDOM
BIT
AND
THEN
DESCRIBE
HOW
TO
PRODUCE
NC
PSEUDORANDOM
BITS
GOLDREICH
LEVIN
HARDCORE
BIT
LET
FN
BE
A
ONE
WAY
PERMUTATION
WHERE
FN
N
N
CLEARLY
THE
FUNCTION
G
N
N
DEFINED
AS
G
X
R
F
X
R
IS
ALSO
A
ONE
WAY
PERMUTATION
GOLDREICH
AND
LEVIN
SHOWED
THAT
GIVEN
F
X
R
IT
IS
DIFFICULT
FOR
A
POLYNOMIAL
TIME
ALGORITHM
TO
PREDICT
X
R
THE
SCALAR
PRODUCT
OF
X
AND
R
MOD
THUS
EVEN
THOUGH
THE
STRING
F
X
R
IN
PRINCIPLE
CONTAINS
ALL
THE
INFORMATION
REQUIRED
TO
EXTRACT
X
R
IT
IS
COMPUTATIONALLY
DIFFICULT
TO
EXTRACT
EVEN
THE
SINGLE
BIT
X
R
THIS
BIT
IS
CALLED
A
HARDCORE
BIT
FOR
THE
PERMUTATION
PRIOR
TO
THE
GOLDREICH
LEVIN
RESULT
WE
KNEW
OF
HARDCORE
BITS
FOR
SOME
SPECIFIC
CONJECTURED
ONE
WAY
PERMUTATIONS
NOT
ALL
DRAFT
WEB
DRAFT
ONE
WAY
FUNCTIONS
AND
PSEUDORANDOM
NUMBER
PROOF
SUP
POSE
THAT
SOME
ALGORITHM
A
CAN
PREDICT
X
R
WITH
PROBABILITY

IN
TIME
T
N
WE
SHOW
HOW
TO
INVERT
FN
X
FOR
O

FRACTION
OF
THE
INPUTS
IN
O
N
TIME
FROM
WHICH
THE
THEOREM
FOLLOWS
CLAIM
SUPPOSE
THAT
PRX
R
N
A
FN
X
R
X
R

THEN
FOR
AT
LEAST

FRACTION
OF
X

PRR
N
A
FN
X
R
X
R
PROOF
WE
USE
AN
AVERAGING
ARGUMENT
SUPPOSE
THAT
P
IS
THE
FRACTION
OF
X
SATISFYING
WE
HAVE
P
P


SOLVING
THIS
WITH
RESPECT
TO
P
WE
OBTAIN

P


WE
DESIGN
AN
INVERSION
ALGORITHM
THAT
GIVEN
FN
X
WHERE
X
R
N
WILL
TRY
TO
RECOVER
X
IT
SUCCEEDS
WITH
HIGH
PROBABILITY
IF
X
IS
SUCH
THAT
HOLDS
IN
OTHER
WORDS
FOR
AT
LEAST

FRACTION
OF
X
NOTE
THAT
THE
ALGORITHM
CAN
ALWAYS
CHECK
THE
CORRECTNESS
OF
ITS
ANSWER
SINCE
IT
HAS
FN
X
AVAILABLE
TO
IT
AND
IT
CAN
APPLY
FN
TO
ITS
ANSWER
AND
SEE
IF
FN
X
IS
OBTAINED
WARMUP
RECONSTRUCTION
WHEN
THE
PROBABILITY
IN
IS

LET
P
BE
ANY
PROGRAM
THAT
COMPUTES
SOME
UNKNOWN
LINEAR
FUNCTION
OVER
GF
N
BUT
ERRS
ON
SOME
INPUTS
SPECIFICALLY
THERE
IS
AN
UNKNOWN
VECTOR
X
GF
N
SUCH
THAT
PR
P
R
X
R

R
THEN
WE
SHOW
TO
ADD
A
SIMPLE
CORRECTION
PROCEDURE
TO
TURN
P
INTO
A
PROBABILISTIC
PROGRAM
P
I
SUCH
THAT
R
PR
P
I
R
X
R
ONCE
WE
KNOW
HOW
TO
COMPUTE
X
R
FOR
EVERY
R
WITH
HIGH
PROBABILITY
IT
IS
EASY
TO
RECOVER
X
BIT
BY
BIT
USING
THE
OBSERVATION
THAT
IF
EI
IS
THE
N
BIT
VECTOR
THAT
IS
IN
THE
ITH
POSITION
AND
ZERO
ELSEWHERE
THEN
X
EI
AI
THE
ITH
BIT
OF
A
WEB
DRAFT
ONE
WAY
FUNCTIONS
AND
PSEUDORANDOM
NUMBER
GENERATORS
ON
INPUT
R
REPEAT
THE
FOLLOWING
TRIAL
O
LOG
N
TIMES
PICK
Y
RANDOMLY
FROM
GF
N
AND
COMPUTE
THE
BIT
P
R
Y
P
Y
AT
THE
END
OUTPUT
THE
MAJORITY
VALUE
THE
MAIN
OBSERVATION
IS
THAT
WHEN
Y
IS
RANDOMLY
PICKED
FROM
GF
N
THEN
R
Y
AND
Y
ARE
BOTH
RANDOMLY
DISTRIBUTED
IN
GF
N
AND
HENCE
THE
PROBABILITY
THAT
P
R
Y
A
R
Y
OR
P
Y
A
Y
IS
AT
MOST

THUS
WITH
PROBABILITY
AT
LEAST
EACH
TRIAL
PRODUCES
THE
CORRECT
BIT
THEN
CHERNOFF
BOUNDS
IMPLY
THAT
PROBABILITY
IS
AT
LEAST
THAT
THE
FINAL
MAJORITY
IS
CORRECT
GENERAL
CASE
THE
IDEA
FOR
THE
GENERAL
CASE
IS
VERY
SIMILAR
THE
ONLY
DIFFERENCE
BEING
THAT
THIS
TIME
WE
WANT
TO
PICK
RM
SO
THAT
WE
ALREADY
KNOW
X
RI
THE
PRECEDING
STATEMENT
MAY
APPEAR
RIDICULOUS
SINCE
KNOWING
THE
INNER
PRODUCT
OF
X
WITH
M
N
RANDOM
VECTORS
IS
WITH
HIGH
PROBABILITY
ENOUGH
TO
RECONSTRUCT
X
SEE
EXERCISES
THE
EXPLANATION
IS
THAT
THE
RI
WILL
NOT
BE
COMPLETELY
RANDOM
INSTEAD
THEY
WILL
BE
PAIRWISE
INDEPENDENT
RECALL
THE
FOLLOWING
CONSTRUCTION
OF
A
SET
OF
PAIRWISE
INDEPENDENT
VECTORS
PICK
K
RANDOM
VECTORS
TK
GF
N
AND
FOR
EACH
NONEMPTY
K
YS
I
TI
YS
YS
ARE
INDEPENDENT
OF
EACH
OTHER
NOW
LET
US
DESCRIBE
THE
OBSERVATION
AT
THE
HEART
OF
THE
PROOF
SUPPOSE
AND
OUR
RANDOM
STRINGS
RM
ARE
YS
FROM
THE
PREVIOUS
PARAGRAPH
THEN
X
YS
X
I
TI
ACTUALLY
KNOW
X
TI
FOR
I
K
SINCE
X
IS
UNKNOWN
AND
THE
TI
ARE
RANDOM
VECTORS
BUT
WE
CAN
JUST
TRY
ALL
POSSIBILITIES
FOR
THE
VECTOR
X
TI
I
K
AND
RUN
THE
REST
OF
THE
ALGORITHM
FOR
EACH
OF
THEM
WHENEVER
OUR
GUESS
FOR
THESE
INNERPRODUCTS
IS
CORRECT
THE
ALGORITHM
SUCCEEDS
IN
PRODUCING
X
AND
THIS
ANSWER
CAN
BE
CHECKED
BY
APPLYING
FN
ON
IT
AS
ALREADY
NOTED
THUS
THE
GUESSING
MULTIPLIES
THE
RUNNING
TIME
BY
A
FACTOR
WHICH
IS
ONLY
M
THIS
IS
WHY
WE
CAN
ASSUME
THAT
WE
KNOW
X
YS
FOR
EACH
SUBSET
THE
DETAILS
OF
THE
REST
OF
THE
ALGORITHM
ARE
SIMILAR
TO
BEFORE
PICK
M
PAIRWISE
INDEPENDENT
VECTORS
YS
SUCH
THAT
AS
DESCRIBED
ABOVE
WE
KNOW
X
YS
FOR
ALL
FOR
EACH
I
N
AND
EACH
RUN
A
ON
THE
INPUT
FN
X
YS
EI
WHERE
YS
EI
IS
YS
WITH
ITS
ITH
ENTRY
FLIPPED
COMPUTE
THE
MAJORITY
VALUE
OF
A
FN
X
YS
EI
X
YS
AMONG
ALL
AND
USE
IT
AS
YOUR
GUESS
FOR
XI
SUPPOSE
X
GF
N
SATISFIES
WE
WILL
SHOW
THAT
THIS
ALGORITHM
PRODUCES
ALL
N
BITS
OF
X
WITH
PROBABILITY
AT
LEAST
FIX
I
FOR
EACH
I
THE
GUESS
FOR
XI
IS
A
MAJORITY
OF
M
BITS
THE
EXPECTED
NUMBER
OF
BITS
AMONG
THESE
THAT
AGREE
WITH
XI
IS
M

SO
FOR
THE
MAJORITY
VOTE
TO
RESULT
IN
THE
INCORRECT
ANSWER
IT
MUST
BE
THE
CASE
THAT
THE
NUMBER
OF
INCORRECT
VALUES
DEVIATES
FROM
ITS
EXPECTATION
BY
MORE
THAN
M
NOW
WE
CAN
BOUND
THE
VARIANCE
OF
THIS
RANDOM
VARIABLE
AND
APPLY
CHEBYSHEV
INEQUALITY
LEMMA
A
IN
APPENDIX
A
TO
CONCLUDE
THAT
THE
PROBABILITY
M
HERE
IS
THE
CALCULATION
USING
CHEBYSHEV
INEQUALITY
LET
S
DENOTE
THE
EVENT
THAT
A
PRODUCES
THE
CORRECT
ANSWER
ON
FN
X
YS
EI
SINCE
X
SATISFIES
AND
YS
EI
IS
RANDOMLY
DISTRIBUTED
OVER
GF
E
S

V
AR
S
E
S
E
S

S
NUMBER
OF
CORRECT
ANSWERS
ON
A
SAMPLE
OF
SIZE
M
BY
LINEARITY
OF
EXPECTATION
E

M

FURTHERMORE
THE
YS
ARE
PAIRWISE
INDEPENDENT
WHICH
IMPLIES
THAT
THE
SAME
IS
TRUE
FOR
THE
OUTPUTS
S
PRODUCED
BY
THE
ALGORITHM
A
ON
THEM
HENCE
BY
PAIRWISE
INDEPENDENCE
V
AR

M
NOW
BY
DRAFT
WEB
DRAFT
APPLICATIONS
CHEBYSHEV
INEQUALITY
THE
PROBABILITY
THAT
THE
MAJORITY
VOTE
IS
INCORRECT
IS
AT
MOST
AR

FINALLY
SETTING
M
THE
PROBABILITY
OF
GUESSING
THE
ITH
BIT
INCORRECTLY
IS
AT
MOST
BY
THE
UNION
BOUND
THE
PROBABILITY
OF
GUESSING
THE
WHOLE
WORD
INCORRECTLY
IS
AT
MOST
HENCE
FOR
EVERY
X
SATISFYING
WE
CAN
FIND
THE
PREIMAGE
OF
F
X
WITH
PROBABILITY
AT
LEAST
WHICH
MAKES
THE
OVERALL
PROBABILITY
OF
INVERSION
AT
LEAST

THE
RUNNING
TIME
IS
ABOUT
RUNNING
TIME
OF
A
WHICH
IS
T
N
AS
WE
HAD
CLAIMED
PSEUDORANDOM
NUMBER
GENERATION
WE
SAW
THAT
IF
F
IS
A
ONE
WAY
PERMUTATION
THEN
G
X
R
F
X
R
X
R
IS
A
PSEUDORANDOM
GENERATOR
THAT
STRETCHES
BITS
TO
BITS
STRETCHING
TO
EVEN
MORE
BITS
IS
EASY
TOO
AS
WE
NOW
SHOW
LET
FI
X
DENOTE
THE
I
TH
ITERATE
OF
F
ON
X
I
E
F
F
F
F
X
WHERE
F
IS
APPLIED
I
TIMES
THEOREM
IF
F
IS
A
ONE
WAY
PERMUTATION
THEN
GN
X
R
R
X
R
F
X
R
F
X
R
F
N
X
R
IS
A
PSEUDORANDOM
GENERATOR
FOR
N
N
FOR
ANY
CONSTANT
C
PROOF
SINCE
ANY
DISTINGUISHING
MACHINE
COULD
JUST
REVERSE
THE
STRING
AS
A
FIRST
STEP
IT
CLEARLY
SUFFICES
TO
SHOW
THAT
THE
STRING
R
F
N
X
R
F
N
X
R
F
X
R
X
R
LOOKS
PSEUDORANDOM
BY
YAO
THEOREM
THEOREM
IT
SUFFICES
TO
SHOW
THE
DIFFICULTY
OF
BIT
PREDICTION
FOR
CONTRA
DICTION
SAKE
ASSUME
THERE
IS
A
PPT
MACHINE
A
SUCH
THAT
WHEN
X
R
N
AND
I
N
ARE
RANDOMLY
CHOSEN
PR
A
PREDICTS
FI
X
R
GIVEN
R
F
N
X
R
F
N
X
R
FI
X
R
E
WE
DESCRIBE
AN
ALGORITHM
B
THAT
GIVEN
F
Z
R
WHERE
Z
R
N
ARE
RANDOMLY
CHOSEN
PREDICTS
THE
HARDCORE
BIT
Z
R
WITH
REASONABLE
PROBABILITY
WHICH
CONTRADICTS
THEOREM
ALGORITHM
B
PICKS
I
N
RANDOMLY
LET
X
N
BE
SUCH
THAT
FI
X
Z
THERE
IS
OF
COURSE
NO
EFFICIENT
WAY
FOR
B
TO
FIND
X
BUT
FOR
ANY
L
B
CAN
EFFICIENTLY
COMPUTE
FI
L
X
FL
F
Z
SO
IT
PRODUCES
THE
STRING
R
F
N
X
R
F
N
X
R
FI
X
R
AND
USES
IT
AS
INPUT
TO
A
BY
ASSUMPTION
A
PREDICTS
FI
X
R
Z
R
WITH
GOOD
ODDS
THUS
WE
HAVE
DERIVED
A
CONTRADICTION
TO
THEOREM
APPLICATIONS
NOW
WE
GIVE
SOME
APPLICATIONS
OF
THE
IDEAS
INTRODUCED
IN
THE
CHAPTER
PSEUDORANDOM
FUNCTIONS
PSEUDORANDOM
FUNCTIONS
ARE
A
NATURAL
GENERALIZATION
OF
AND
ARE
EASILY
CONSTRUCTED
USING
PSEUDO
RANDOM
GENERATORS
THIS
IS
A
FUNCTION
G
M
N
M
FOR
EACH
K
M
WE
DENOTE
BY
G
K
THE
FUNCTION
FROM
N
TO
M
DEFINED
BY
G
K
X
G
K
X
THUS
THE
FAMILY
CONTAINS
FUNCTIONS
FROM
N
TO
M
ONE
FOR
EACH
K
WEB
DRAFT
APPLICATIONS
WE
SAY
G
IS
A
PSEUDORANDOM
FUNCTION
GENERATOR
IF
IT
PASSES
A
TURING
TEST
OF
RANDOMNESS
ANALOGOUS
TO
THAT
IN
YAO
DEFINITION
OF
A
PSEUDORANDOM
GENERATOR
DEFINITION
RECALL
THAT
THE
SET
OF
ALL
FUNCTIONS
FROM
N
TO
M
DENOTED
N
M
HAS
CARDINALITY
THE
PPT
MACHINE
IS
PRESENTED
WITH
AN
ORACLE
FOR
A
FUNCTION
FROM
N
TO
N
THE
FUNCTION
IS
ONE
OF
TWO
TYPES
EITHER
A
FUNCTION
CHOSEN
RANDOMLY
FROM
N
M
OR
A
FUNCTION
F
K
WHERE
K
M
IS
RANDOMLY
CHOSEN
THE
PPT
MACHINE
IS
ALLOWED
TO
QUERY
THE
ORACLE
IN
ANY
POINTS
OF
ITS
CHOOSING
WE
SAY
F
K
IS
A
PSEUDORANDOM
FUNCTION
GENERATOR
IF
FOR
ALL
C
THE
PPT
HAS
PROBABILITY
LESS
THAN
N
C
OF
DETECTING
WHICH
OF
THE
TWO
CASES
HOLDS
A
COMPLETELY
FORMAL
DEFINITION
WOULD
RESEMBLE
DEFINITION
AND
TALK
ABOUT
A
FAMILY
OF
GENERATORS
ONE
FOR
EACH
N
THEN
M
IS
SOME
FUNCTION
OF
N
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
CONSTRUCTING
A
PSEUDORANDOM
FUNCTION
FROM
N
TO
M
USING
A
RANDOM
KEY
K
M
AND
A
LENGTH
DOUBLING
PSEUDORANDOM
GENERATOR
G
NOW
WE
DESCRIBE
A
CONSTRUCTION
OF
A
PSEUDORANDOM
FUNCTION
GENERATOR
G
FROM
A
LENGTH
DOUBLING
PSEUDORANDOM
GENERATOR
F
M
FOR
ANY
K
M
LET
TK
BE
A
COMPLETE
BINARY
TREE
OF
DEPTH
N
WHOSE
EACH
NODE
IS
LABELLED
WITH
AN
M
BIT
STRING
THE
ROOT
IS
LABELLED
K
IF
A
NODE
IN
THE
TREE
HAS
LABEL
Y
THEN
ITS
LEFT
CHILD
IS
LABELLED
WITH
THE
FIRST
M
BITS
OF
F
Y
AND
THE
RIGHT
CHILD
IS
LABELLED
WITH
THE
LAST
M
BITS
OF
F
Y
NOW
WE
DEFINE
G
K
X
FOR
ANY
X
N
INTERPRET
X
AS
A
LABEL
FOR
A
PATH
FROM
ROOT
TO
LEAF
IN
TK
IN
THE
OBVIOUS
WAY
AND
OUTPUT
THE
LABEL
AT
THE
LEAF
SEE
FIGURE
WE
LEAVE
IT
AS
AN
EXERCISE
TO
PROVE
THAT
THIS
CONSTRUCTION
IS
CORRECT
A
PSEUDORANDOM
FUNCTION
GENERATOR
IS
A
WAY
TO
TURN
A
RANDOM
STRING
K
INTO
AN
IMPLICIT
DE
SCRIPTION
OF
AN
EXPONENTIALLY
LARGER
RANDOM
LOOKING
STRING
NAMELY
THE
TABLE
OF
ALL
VALUES
OF
THE
FUNCTION
G
K
THIS
HAS
PROVED
A
POWERFUL
PRIMITIVE
IN
CRYPTOGRAPHY
SEE
THE
NEXT
SECTION
FURTHER
MORE
PSEUDORANDOM
FUNCTION
GENERATORS
HAVE
ALSO
FIGURED
IN
A
VERY
INTERESTING
EXPLANATION
OF
WHY
CURRENT
LOWERBOUND
TECHNIQUES
HAVE
BEEN
UNABLE
TO
SEPARATE
P
FROM
NP
SEE
CHAPTER
PRIVATE
KEY
ENCRYPTION
DEFINITION
OF
SECURITY
WE
HINTED
AT
A
TECHNIQUE
FOR
PRIVATE
KEY
ENCRYPTION
IN
OUR
DISCUSSION
OF
A
ONE
TIME
PAD
INCLUDING
THE
PSEUDORANDOM
VERSION
AT
THE
START
OF
SECTION
BUT
THAT
DISCUSSION
COMPLETELY
OMITTED
WHAT
THE
DESIGN
GOALS
OF
THE
ENCRYPTION
SCHEME
WERE
THIS
IS
AN
IMPORTANT
POINT
DESIGN
OF
INSECURE
SYSTEMS
OFTEN
TRACES
TO
A
MISUNDERSTANDING
ABOUT
THE
TYPE
OF
SECURITY
ENSURED
OR
NOT
ENSURED
BY
AN
UNDERLYING
PROTOCOL
THE
MOST
BASIC
TYPE
OF
SECURITY
THAT
A
PRIVATE
KEY
ENCRYPTION
SHOULD
ENSURE
IS
SEMANTIC
SECURITY
INFORMALLY
SPEAKING
THIS
MEANS
THAT
WHATEVER
CAN
BE
COMPUTED
FROM
THE
ENCRYPTED
MESSAGE
IS
ALSO
COMPUTABLE
WITHOUT
ACCESS
TO
THE
ENCRYPTED
MESSAGE
AND
KNOWING
ONLY
THE
LENGTH
OF
THE
MESSAGE
THE
FORMAL
DEFINITION
IS
OMITTED
HERE
BUT
IT
HAS
TO
EMPHASIZE
THE
FACTS
THAT
WE
ARE
TALKING
ABOUT
AN
ENSEMBLE
OF
ENCRYPTION
FUNCTIONS
ONE
FOR
EACH
MESSAGE
SIZE
AS
IN
DEFINITION
AND
THAT
THE
ENCRYPTION
AND
DECRYPTION
IS
DONE
BY
PROBABILISTIC
ALGORITHMS
THAT
USE
A
SHARED
PRIVATE
KEY
AND
DRAFT
WEB
DRAFT
APPLICATIONS
THAT
FOR
EVERY
MESSAGE
THE
GUARANTEE
OF
SECURITY
HOLDS
WITH
HIGH
PROBABILITY
WITH
RESPECT
TO
THE
CHOICE
OF
THIS
PRIVATE
KEY
NOW
WE
DESCRIBE
AN
ENCRYPTION
SCHEME
THAT
IS
SEMANTICALLY
SECURE
LET
F
N
N
N
BE
A
PSEUDORANDOM
FUNCTION
GENERATOR
THE
TWO
PARTIES
SHARE
A
SECRET
RANDOM
KEY
K
WHEN
ONE
OF
THEM
WISHES
TO
SEND
A
MESSAGE
X
TO
THE
OTHER
SHE
PICKS
A
RANDOM
STRING
R
N
AND
TRANSMITS
R
X
FK
R
TO
DECRYPT
THE
OTHER
PARTY
COMPUTES
FK
R
AND
THEN
XORS
THIS
STRING
WITH
THE
LAST
N
BITS
IN
THE
RECEIVED
TEXT
WE
LEAVE
IT
AS
AN
EXERCISE
TO
SHOW
THAT
THIS
SCHEME
IS
SEMANTICALLY
SECURE
DERANDOMIZATION
THE
EXISTENCE
OF
PSEUDORANDOM
GENERATORS
IMPLIES
SUBEXPONENTIAL
DETERMINISTIC
ALGORITHMS
FOR
BPP
THIS
IS
USUALLY
REFERRED
TO
AS
DERANDOMIZATION
OF
BPP
IN
THIS
CASE
THE
DERANDOMIZATION
IS
ONLY
PARTIAL
SINCE
IT
RESULTS
IN
A
SUBEXPONENTIAL
DETERMINISTIC
ALGORITHM
STRONGER
COMPLEXITY
ASSUMPTIONS
IMPLY
A
FULL
DERANDOMIZATION
OF
BPP
AS
WE
WILL
SEE
IN
CHAPTER
THEOREM
IF
FOR
EVERY
C
THERE
IS
A
PSEUDORANDOM
GENERATOR
THAT
IS
SECURE
AGAINST
CIRCUITS
OF
SIZE
NC
THEN
BPP

DTIME
PROOF
LET
US
FIX
AN

AND
SHOW
THAT
BPP
DTIME
SUPPOSE
THAT
M
IS
A
BPP
MACHINE
RUNNING
IN
NK
TIME
WE
CAN
BUILD
ANOTHER
PROBABILISTIC
MACHINE
M
I
THAT
TAKES
N
RANDOM
BITS
STRECHES
THEM
TO
NK
BITS
USING
THE
PSEUDORANDOM
GENERATOR
AND
THEN
SIMULATES
M
USING
THIS
NK
BITS
AS
A
RANDOM
STRING
OBVIOUSLY
M
I
CAN
BE
SIMULATED
BY
GOING
OVER
ALL
BINARY
STRINGS
N
RUNNING
M
I
ON
EACH
OF
THEM
AND
TAKING
THE
MAJORITY
VOTE
IT
REMAINS
TO
PROVE
THAT
M
AND
M
I
ACCEPT
THE
SAME
LANGUAGE
SUPPOSE
OTHERWISE
THEN
THERE
EXISTS
AN
INFINITE
SEQUENCE
OF
INPUTS
XN
ON
WHICH
M
DISTINGUISHES
A
TRULY
RANDOM
STRING
FROM
A
PSEUDORANDOM
STRING
WITH
A
HIGH
PROBABILITY
BECAUSE
FOR
M
AND
M
I
TO
PRODUCE
DIFFERENT
RESULTS
THE
PROBABILITY
OF
ACCEPTANCE
SHOULD
DROP
FROM
TO
BELOW
HENCE
WE
CAN
BUILD
A
DISTINGUISHER
SIMILAR
TO
THE
ONE
DESCRIBED
IN
THE
PREVIOUS
THEOREM
BY
HARDWIRING
THESE
INPUTS
INTO
A
CIRCUIT
FAMILY
THE
ABOVE
THEOREM
SHOWS
THAT
THE
EXISTENCE
OF
HARD
PROBLEMS
IMPLIES
THAT
WE
CAN
REDUCE
THE
RANDOMNESS
REQUIREMENT
OF
ALGORITHMS
THIS
HARDNESS
VERSUS
RANDOMNESS
TRADEOFF
IS
STUDIED
MORE
DEEPLY
IN
CHAPTER
REMARK
THERE
IS
AN
INTERESTING
CONNECTION
TO
DISCREPANCY
THEORY
A
FIELD
OF
MATHEMATICS
LET
BE
A
SET
OF
SUBSETS
OF
N
SUBSET
A
N
HAS
DISCREPANCY
E
WITH
RESPECT
TO
IF
FOR
EVERY
OUR
EARLIER
RESULT
THAT
BPP
P
POLY
SHOWED
THE
EXISTENCE
OF
POLYNOMIAL
SIZE
SETS
A
THAT
HAVE
LOW
DISCREPANCY
FOR
ALL
SETS
DEFINED
BY
POLYNOMIAL
TIME
TURING
MACHINES
WE
ONLY
DESCRIBED
DIS
CREPANCY
FOR
THE
UNIVERSE
N
BUT
ONE
CAN
DEFINE
IT
FOR
ALL
INPUT
SIZES
USING
LIM
SUP
THE
GOAL
OF
DERANDOMIZATION
IS
TO
EXPLICITLY
CONSTRUCT
SUCH
SETS
SEE
CHAPTER
WEB
DRAFT
APPLICATIONS
TOSSING
COINS
OVER
THE
PHONE
AND
BIT
COMMITMENT
HOW
CAN
TWO
PARTIES
A
AND
B
TOSS
A
FAIR
RANDOM
COIN
OVER
THE
PHONE
MANY
CRYPTOGRAPHIC
PROTOCOLS
REQUIRE
THIS
BASIC
PRIMITIVE
IF
ONLY
ONE
OF
THEM
ACTUALLY
TOSSES
A
COIN
THERE
IS
NOTHING
TO
PREVENT
HIM
FROM
LYING
ABOUT
THE
RESULT
THE
FOLLOWING
FIX
SUGGESTS
ITSELF
BOTH
PLAYERS
TOSS
A
COIN
AND
THEY
TAKE
THE
XOR
AS
THE
SHARED
COIN
EVEN
IF
B
DOES
NOT
TRUST
A
TO
USE
A
FAIR
COIN
HE
KNOWS
THAT
AS
LONG
AS
HIS
BIT
IS
RANDOM
THE
XOR
IS
ALSO
RANDOM
UNFORTUNATELY
THIS
IDEA
ALSO
DOES
NOT
WORK
BECAUSE
THE
PLAYER
WHO
REVEALS
HIS
BIT
FIRST
IS
AT
A
DISADVANTAGE
THE
OTHER
PLAYER
COULD
JUST
ADJUST
HIS
ANSWER
TO
GET
THE
DESIRED
FINAL
COIN
TOSS
THIS
PROBLEM
IS
ADDRESSED
BY
THE
FOLLOWING
SCHEME
WHICH
ASSUMES
THAT
A
AND
B
ARE
POLYNOMIAL
TIME
TURING
MACHINES
THAT
CANNOT
INVERT
ONE
WAY
PERMUTATIONS
THE
PROTOCOL
ITSELF
IS
CALLED
BIT
COMMITMENT
FIRST
A
CHOOSES
TWO
STRINGS
XA
AND
RA
OF
LENGTH
N
AND
SENDS
A
MESSAGE
FN
XA
RA
WHERE
FN
IS
A
ONE
WAY
PERMUTATION
THIS
WAY
A
COMMITS
THE
STRING
XA
WITHOUT
REVEALING
IT
NOW
B
SELECTS
A
RANDOM
BIT
B
AND
CONVEYS
IT
THEN
A
REVEALS
XA
AND
THEY
AGREE
TO
USE
THE
XOR
OF
B
AND
XA
RA
AS
THEIR
COIN
TOSS
NOTE
THAT
B
CAN
VERIFY
THAT
XA
IS
THE
SAME
AS
IN
THE
FIRST
MESSAGE
BY
APPLYING
FN
THEREFORE
A
CANNOT
CHANGE
HER
MIND
AFTER
LEARNING
B
BIT
ON
THE
OTHER
HAND
BY
THE
GOLDREICH
LEVIN
THEOREM
B
CANNOT
PREDICT
XA
RA
FROM
A
FIRST
MESSAGE
SO
THIS
SCHEME
IS
SECURE
SECURE
MULTIPARTY
COMPUTATIONS
THIS
CONCERNS
A
VAST
GENERALIZATION
OF
THE
SETTING
IN
SECTION
THERE
ARE
K
PARTIES
AND
THE
ITH
PARTY
HOLDS
A
STRING
XI
N
THEY
WISH
TO
COMPUTE
F
XK
WHERE
F
NK
IS
A
POLYNOMIAL
TIME
COMPUTABLE
FUNCTION
KNOWN
TO
ALL
OF
THEM
THE
SETTING
IN
SECTION
IS
A
SUBCASE
WHEREBY
EACH
XI
IS
A
BIT
RANDOMLY
CHOSEN
AS
IT
HAPPENS
AND
F
IS
XOR
CLEARLY
THE
PARTIES
CAN
JUST
EXCHANGE
THEIR
INPUTS
SUITABLY
ENCRYPTED
IF
NEED
BE
SO
THAT
UNAUTHORIZED
EAVESDROPPERS
LEARN
NOTHING
AND
THEN
EACH
OF
THEM
CAN
COMPUTE
F
ON
HIS
HER
OWN
HOWEVER
THIS
LEADS
TO
ALL
OF
THEM
KNOWING
EACH
OTHER
INPUT
WHICH
MAY
NOT
BE
DESIRABLE
IN
MANY
SITUATIONS
FOR
INSTANCE
WE
MAY
WISH
TO
COMPUTE
STATISTICS
SUCH
AS
THE
AVERAGE
ON
THE
COMBINATION
OF
SEVERAL
MEDICAL
DATABASES
THAT
ARE
HELD
BY
DIFFERENT
HOSPITALS
STRICT
PRIVACY
AND
NONDISCLOSURE
LAWS
MAY
FORBID
HOSPITALS
FROM
SHARING
INFORMATION
ABOUT
INDIVIDUAL
PATIENTS
THE
ORIGINAL
EXAMPLE
YAO
GAVE
IN
INTRODUCING
THE
PROBLEM
WAS
OF
K
PEOPLE
WHO
WISH
TO
COMPUTE
THE
AVERAGE
OF
THEIR
SALARIES
WITHOUT
REVEALING
THEIR
SALARIES
TO
EACH
OTHER
WE
SAY
THAT
A
MULTIPARTY
PROTOCOL
FOR
COMPUTING
F
IS
SECURE
IF
AT
THE
END
NO
PARTY
LEARNS
ANYTHING
NEW
APART
FROM
THE
VALUE
OF
F
XK
THE
FORMAL
DEFINITION
IS
INSPIRED
BY
THE
DEFINITION
OF
A
PSEUDORANDOM
GENERATOR
AND
STATES
THAT
FOR
EACH
I
THE
BITS
RECEIVED
BY
PARTY
I
DURING
THE
PROTOCOL
SHOULD
BE
COMPUTATIONALLY
INDISTINGUISHABLE
FROM
COMPLETELY
RANDOM
IT
IS
COMPLETELY
NONOBVIOUS
WHY
SUCH
PROTOCOLS
MUST
EXIST
YAO
PROVED
EXISTENCE
FOR
K
AND
GOLDREICH
MICALI
WIGDERSON
PROVED
EXISTENCE
FOR
GENERAL
K
WE
WILL
NOT
TO
OUR
MEDICAL
DATABASE
EXAMPLE
WE
SEE
THAT
THE
HOSPITALS
CAN
INDEED
COMPUTE
STATISTICS
ON
THEIR
COMBINED
DATABASES
WITHOUT
REVEALING
ANY
INFORMATION
TO
EACH
OTHER
AT
LEAST
ANY
INFORMATION
THAT
CAN
BE
EXTRACTED
FEASIBLY
NEVETHELESS
IT
IS
UNCLEAR
IF
CURRENT
PRIVACY
LAWS
ALLOW
HOSPITALS
TO
PERFORM
SUCH
SECURE
MULTIPARTY
PROTOCOLS
USING
PATIENT
DATA
AN
EXAMPLE
OF
THE
LAW
LAGGING
BEHIND
SCIENTIFIC
PROGRESS
WEB
DRAFT
RECENT
DEVELOPMENTS
DESCRIBE
THIS
PROTOCOL
IN
ANY
DETAIL
HERE
EXCEPT
TO
MENTION
THAT
IT
INVOLVES
SCRAMBLING
THE
CIRCUIT
THAT
COMPUTES
F
LOWERBOUNDS
FOR
MACHINE
LEARNING
IN
MACHINE
LEARNING
THE
GOAL
IS
TO
LEARN
A
SUCCINCT
FUNCTION
F
N
FROM
A
SEQUENCE
OF
TYPE
F
F
WHERE
THE
XI
ARE
RANDOMLY
CHOSEN
INPUTS
CLEARLY
THIS
IS
IMPOSSIBLE
IN
GENERAL
SINCE
A
RANDOM
FUNCTION
HAS
NO
SUCCINCT
DESCRIPTION
BUT
SUPPOSE
F
HAS
A
SUCCINCT
DESCRIPTION
E
G
AS
A
SMALL
CIRCUIT
CAN
WE
LEARN
F
IN
THAT
CASE
THE
EXISTENCE
OF
PSEUDORANDOM
FUNCTIONS
IMPLIES
THAT
EVEN
THOUGH
A
FUNCTION
MAY
BE
POLYNOMIAL
TIME
COMPUTABLE
THERE
IS
NO
WAY
TO
LEARN
IT
FROM
EXAMPLES
IN
POLYNOMIAL
TIME
IN
FACT
IT
IS
POSSIBLE
TO
EXTEND
THIS
IMPOSSIBILITY
RESULT
THOUGH
WE
DO
NOT
ATTEMPT
IT
TO
MORE
RESTRICTED
FUNCTION
FAMILIES
SUCH
AS
SEE
KEARNS
AND
VALIANT
RECENT
DEVELOPMENTS
THE
EARLIEST
CRYPTOSYSTEMS
WERE
DESIGNED
USING
THE
SUBSET
SUM
PROBLEM
THEY
WERE
ALL
SHOWN
TO
BE
INSECURE
BY
THE
EARLY
IN
THE
LAST
FEW
YEARS
INTEREST
IN
SUCH
PROBLEMS
AND
ALSO
THE
RELATED
PROBLEMS
OF
COMPUTING
APPROXIMATE
SOLUTIONS
TO
THE
SHORTEST
AND
NEAREST
LATTICE
VECTOR
PROBLEMS
HAS
REVIVED
THANKS
TO
A
ONE
WAY
FUNCTION
DESCRIBED
IN
AJTAI
AND
A
PUBLIC
KEY
CRYPTOSYSTEM
DESCRIBED
IN
AJTAI
AND
DWORK
AND
IMPROVED
ON
SINCE
THEN
BY
OTHER
RESEARCHERS
THESE
CONSTRUCTIONS
ARE
SECURE
ON
MOST
INSTANCES
IFF
THEY
ARE
SECURE
ON
WORST
CASE
INSTANCES
THE
IDEA
USED
IS
A
VARIANT
OF
RANDOM
SELF
REDUCIBILITY
ALSO
THERE
HAS
BEEN
A
LOT
OF
EXPLORATION
OF
THE
EXACT
NOTION
OF
SECURITY
THAT
ONE
NEEDS
FOR
VARIOUS
CRYPTOGRAPHIC
TASKS
FOR
INSTANCE
THE
NOTION
OF
SEMANTIC
SECURITY
IN
SECTION
MAY
SEEM
QUITE
STRONG
BUT
RESEARCHERS
SUBSEQUENTLY
REALIZED
THAT
IT
LEAVES
OPEN
THE
POSSIBILITY
OF
SOME
OTHER
KINDS
OF
ATTACKS
INCLUDING
CHOSEN
CIPHERTEXT
ATTACKS
OR
ATTACKS
BASED
UPON
CONCURRENT
EXECUTION
OF
SEVERAL
COPIES
OF
THE
PROTOCOL
ACHIEVING
SECURITY
AGAINST
SUCH
EXOTIC
ATTACKS
CALLS
FOR
MANY
IDEAS
MOST
NOTABLY
ZERO
KNOWLEDGE
A
BRIEF
INTRODUCTION
TO
THIS
CONCEPT
APPEARS
IN
SECTION
CHAPTER
NOTES
AND
HISTORY
IN
THE
SHANNON
SPECULATED
ABOUT
TOPICS
REMINISCENT
OF
COMPLEXITY
BASED
CRYPTOGRAPHY
THE
FIRST
CONCRETE
PROPOSAL
WAS
MADE
BY
DIFFIE
AND
HELLMAN
THOUGH
THEIR
CRYPTOSYSTEM
WAS
LATER
BROKEN
THE
INVENTION
OF
THE
RSA
CRYPTOSYSTEM
NAMED
AFTER
ITS
INVENTORS
RON
RIVEST
ADI
SHAMIR
AND
LEN
ADLEMAN
BROUGHT
ENORMOUS
ATTENTION
TO
THIS
TOPIC
IN
SHAMIR
SUGGESTED
THE
IDEA
OF
REPLACING
A
ONE
TIME
PAD
BY
A
PSEUDORANDOM
STRING
HE
ALSO
EXHIBITED
A
WEAK
PSEUDORANDOM
GENERATOR
ASSUMING
THE
AVERAGE
CASE
INTRACTABILITY
OF
THE
RSA
FUNCTION
THE
MORE
FAMOUS
PAPERS
OF
BLUM
AND
MICALI
AND
THEN
YAO
LAID
THE
INTELLECTUAL
FOUNDATIONS
OF
PRIVATE
KEY
CRYPTOGRAPHY
THE
HYBRID
ARGUMENT
USED
BY
YAO
IS
A
STRONGER
VERSION
OF
ONE
IN
AN
EARLIER
IMPORTANT
MANUSCRIPT
OF
GOLDWASSER
AND
MICALI
THAT
PROPOSED
PROBABILISTIC
ENCRYPTION
SCHEMES
THE
CONSTRUCTION
OF
PSEUDORANDOM
FUNCTIONS
IN
SECTION
IS
DUE
TO
GOLDREICH
GOLDWASSER
AND
MICALI
THE
QUESTION
ABOUT
TOSSING
COINS
OVER
A
TELEPHONE
WEB
DRAFT
RECENT
DEVELOPMENTS
WAS
RAISED
IN
AN
INFLUENTIAL
PAPER
OF
BLUM
TODAY
COMPLEXITY
BASED
CRYPTOGRAPHY
IS
A
VAST
FIELD
WITH
SEVERAL
DEDICATED
CONFERENCES
GOLDREICH
TWO
VOLUME
BOOK
GIVES
A
DEFINITIVE
ACCOUNT
A
SCHOLARLY
EXPOSITION
OF
NUMBER
THEORETIC
ALGORITHMS
INCLUDING
GENERATING
RANDOM
PRIMES
AND
FACTORING
INTEGERS
APPEARS
IN
VICTOR
SHOUP
RECENT
BOOK
AND
THE
BOOK
OF
BACH
AND
SHAL
LIT
THEOREM
AND
ITS
VERY
TECHNICAL
PROOF
IS
IN
HA
STAD
ET
AL
THE
RELEVANT
CONFERENCE
PUBLICATIONS
ARE
A
DECADE
OLDER
OUR
PROOF
OF
THE
GOLDREICH
LEVIN
THEOREM
IS
USUALLY
ATTRIBUTED
TO
RACKOFF
UNPUBLISHED
EXERCISES
SHOW
THAT
IF
P
NP
THEN
ONE
WAY
FUNCTIONS
AND
PSEUDORANDOM
GENERATORS
DO
NOT
EXIST
REQUIRES
JUST
A
LITTLE
NUMBER
THEORY
PROVE
THAT
IF
SOME
ALGORITHM
INVERTS
THE
RABIN
FUNC
TION
FM
X
MOD
M
ON
A
POLY
LOG
M
FRACTION
OF
INPUTS
THEN
WE
CAN
FACTOR
M
IN
POLY
LOG
M
TIME
SHOW
THAT
IF
F
IS
A
ONE
WAY
PERMUTATION
THEN
SO
IS
FK
NAMELY
F
F
F
F
X
WHERE
F
IS
APPLIED
K
TIMES
WHERE
K
NC
FOR
SOME
FIXED
C
ASSUMING
ONE
WAY
FUNCTIONS
EXIST
SHOW
THAT
THE
ABOVE
FAILS
FOR
ONE
WAY
FUNCTIONS
SUPPOSE
A
GF
M
IS
AN
UNKNOWN
VECTOR
LET
RM
GF
M
BE
RANDOMLY
CHOSEN
AND
A
RI
REVEALED
TO
US
FOR
ALL
I
M
DESCRIBE
A
DETERMINISTIC
ALGORITHM
TO
RECONSTRUCT
A
FROM
THIS
INFORMATION
AND
SHOW
THAT
THE
PROBABILITY
OVER
THE
CHOICE
OF
THE
RI
IS
AT
LEAST
THAT
IT
WORKS
THIS
SHOWS
THAT
THE
TRICK
IN
GOLDREICH
LEVIN
PROOF
IS
NECESSARY
SUPPOSE
SOMEBODY
HOLDS
AN
UNKNOWN
N
BIT
VECTOR
A
WHENEVER
YOU
PRESENT
A
RANDOMLY
CHOSEN
SUBSET
OF
INDICES
N
THEN
WITH
PROBABILITY
AT
LEAST
E
SHE
TELLS
YOU
THE
PARITY
OF
THE
ALL
THE
BITS
IN
A
INDEXED
BY
DESCRIBE
A
GUESSING
STRATEGY
THAT
ALLOWS
YOU
TO
GUESS
A
AN
N
BIT
STRING
WITH
PROBABILITY
AT
LEAST
E
C
FOR
SOME
CONSTANT
C
SUPPOSE
G
N
N
IS
ANY
PSEUDORANDOM
GENERATOR
THEN
USE
G
TO
DESCRIBE
A
PSEUDORANDOM
GENERATOR
THAT
STRETCHES
N
BITS
TO
NK
FOR
ANY
CONSTANT
K
SHOW
THE
CORRECTNESS
OF
THE
PSEUDORANDOM
FUNCTION
GENERATOR
IN
SECTION
DRAFT
WEB
DRAFT
HINT
FIRST
SHOW
THAT
FOR
ALL
MESSAGE
PAIRS
X
Y
THEIR
ENCRYPTIONS
ARE
INDISTINGUISHABLE
BY
POLYNOMIAL
TIME
ALGORITHMS
WHY
DOES
THIS
SUFFICE
HINT
USE
A
HYBRID
ARGUMENT
WHICH
REPLACES
THE
LABELS
ON
THE
FIRST
K
LEVELS
OF
THE
TREE
BY
COMPLETELY
RANDOM
STRINGS
NOTE
THAT
THE
RANDOM
LABELS
DO
NOT
NEED
TO
BE
ASSIGNED
AHEAD
OF
TIME
THIS
WOULD
TAKE
AT
LEAST
TIME
BUT
CAN
BE
ASSIGNED
ON
THE
FLY
WHENEVER
THEY
ARE
NEEDED
BY
THE
DISTINGUISHING
ALGORITHM
RECENT
DEVELOPMENTS
DRAFT
WEB
DRAFT
PART
II
LOWERBOUNDS
FOR
CONCRETE
COMPUTATIONAL
MODELS
WEB
DRAFT
COMPLEXITY
THEORY
A
MODERN
APPROACH
SANJEEV
ARORA
AND
BOAZ
BARAK
REFERENCES
AND
ATTRIBUTIONS
ARE
STILL
INCOMPLETE
DRAFT
IN
THE
NEXT
FEW
CHAPTERS
THE
TOPIC
WILL
BE
CONCRETE
COMPLEXITY
THE
STUDY
OF
LOWERBOUNDS
ON
MODELS
OF
COMPUTATION
SUCH
AS
DECISION
TREES
COMMUNICATION
GAMES
CIRCUITS
ETC
ALGORITHMS
OR
DEVICES
CONSIDERED
IN
THIS
LECTURE
TAKE
INPUTS
OF
A
FIXED
SIZE
N
AND
WE
STUDY
THE
COMPLEXITY
OF
THESE
DEVICES
AS
A
FUNCTION
OF
N
WEB
DRAFT
DRAFT
WEB
DRAFT
CHAPTER
DECISION
TREES
A
DECISION
TREE
IS
A
MODEL
OF
COMPUTATION
USED
TO
STUDY
THE
NUMBER
OF
BITS
OF
AN
INPUT
THAT
NEED
TO
BE
EXAMINED
IN
ORDER
TO
COMPUTE
SOME
FUNCTION
ON
THIS
INPUT
CONSIDER
A
FUNCTION
F
N
A
DECISION
TREE
FOR
F
IS
A
TREE
FOR
WHICH
EACH
NODE
IS
LABELLED
WITH
SOME
XI
AND
HAS
TWO
OUTGOING
EDGES
LABELLED
AND
EACH
TREE
LEAF
IS
LABELLED
WITH
AN
OUTPUT
VALUE
OR
THE
COMPUTATION
ON
INPUT
X
XN
PROCEEDS
AT
EACH
NODE
BY
INSPECTING
THE
INPUT
BIT
XI
INDICATED
BY
THE
NODE
LABEL
IF
XI
THE
COMPUTATION
CONTINUES
IN
THE
SUBTREE
REACHED
BY
TAKING
THE
EDGE
THE
EDGE
IS
TAKEN
IF
THE
BIT
IS
THUS
INPUT
X
FOLLOWS
A
PATH
THROUGH
THE
TREE
THE
OUTPUT
VALUE
AT
THE
LEAF
IS
F
X
AN
EXAMPLE
OF
A
SIMPLE
DECISION
TREE
FOR
THE
MAJORITY
FUNCTION
IS
GIVEN
IN
FIGURE
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
A
DECISION
TREE
FOR
COMPUTING
THE
MAJORITY
FUNCTION
M
AJ
ON
THREE
BITS
OUTPUTS
IF
AT
LEAST
TWO
INPUT
BITS
ARE
ELSE
OUTPUTS
RECALL
THE
USE
OF
DECISION
TREES
IN
THE
PROOF
OF
THE
LOWER
BOUND
FOR
COMPARISON
BASED
SORTING
ALGORITHMS
THAT
STUDY
CAN
BE
RECAST
IN
THE
ABOVE
FRAMEWORK
BY
THINKING
OF
THE
INPUT
WHICH
CONSISTED
OF
N
NUMBERS
AS
CONSISTING
OF
N
BITS
EACH
GIVING
THE
OUTCOME
OF
A
PAIRWISE
COMPARISON
BETWEEN
TWO
NUMBERS
WE
CAN
NOW
DEFINE
TWO
USEFUL
DECISION
TREE
METRICS
DEFINITION
THE
COST
OF
TREE
T
ON
INPUT
X
COST
T
X
IS
THE
NUMBER
OF
BITS
OF
X
EXAMINED
BY
T
DEFINITION
THE
DECISION
TREE
COMPLEXITY
OF
FUNCTION
F
D
F
IS
DEFINED
AS
FOLLOWS
WHERE
T
BELOW
REFERS
TO
THE
SET
OF
DECISION
TREES
THAT
DECIDE
F
D
F
MIN
MAX
COST
T
X
T
T
X
N
THE
DECISION
TREE
COMPLEXITY
OF
A
FUNCTION
IS
THE
NUMBER
OF
BITS
EXAMINED
BY
THE
MOST
EFFICIENT
DECISION
TREE
ON
THE
WORST
CASE
INPUT
TO
THAT
TREE
WE
ARE
NOW
READY
TO
CONSIDER
SEVERAL
EXAMPLES
DRAFT
EXAMPLE
GRAPH
CONNECTIVITY
GIVEN
A
GRAPH
G
AS
INPUT
IN
ADJACENCY
MATRIX
FORM
WE
WOULD
LIKE
TO
KNOW
HOW
MANY
BITS
OF
THE
ADJACENCY
MATRIX
A
DECISION
TREE
ALGORITHM
MIGHT
HAVE
TO
INSPECT
IN
ORDER
TO
DETERMINE
WHETHER
G
IS
CONNECTED
WE
HAVE
THE
FOLLOWING
RESULT
THEOREM
LET
F
BE
A
FUNCTION
THAT
COMPUTES
THE
CONNECTIVITY
OF
INPUT
GRAPHS
WITH
M
VERTICES
THEN
D
F
M
THE
IDEA
OF
THE
PROOF
OF
THIS
THEOREM
IS
TO
IMAGINE
AN
ADVERSARY
THAT
CONSTRUCTS
A
GRAPH
EDGE
BY
EDGE
IN
RESPONSE
TO
THE
QUERIES
OF
A
DECISION
TREE
FOR
EVERY
DECISION
TREE
THAT
DECIDES
CONNECTIVITY
THE
STRATEGY
IMPLICITLY
PRODUCES
AN
INPUT
GRAPH
WHICH
REQUIRES
THE
DECISION
TREE
TO
INSPECT
EACH
OF
THE
M
POSSIBLE
EDGES
IN
A
GRAPH
OF
M
VERTICES
ADVERSARY
STRATEGY
WHENEVER
THE
DECISION
TREE
ALGORITHM
ASKS
ABOUT
EDGE
EI
ANSWER
NO
UNLESS
THIS
WOULD
FORCE
THE
GRAPH
TO
BE
DISCONNECTED
AFTER
I
QUERIES
LET
NI
BE
THE
SET
OF
EDGES
FOR
WHICH
THE
ADVERSARY
HAS
REPLIED
NO
YI
THE
SET
OF
EDGES
FOR
WHICH
THE
ADVERSARY
HAS
REPLIED
YES
AND
EI
THE
SET
OF
EDGES
NOT
YET
QUERIED
THE
ADVERSARY
STRATEGY
MAINTAINS
THE
INVARIANT
THAT
YI
IS
A
DISCONNECTED
FOREST
FOR
I
M
AND
YI
EI
IS
CONNECTED
THIS
ENSURES
THAT
THE
DECISION
TREE
WILL
NOT
KNOW
WHETHER
THE
GRAPH
IS
CONNECTED
UNTIL
IT
QUERIES
EVERY
EDGE
EXAMPLE
OR
FUNCTION
LET
F
XN
N
XI
HERE
WE
CAN
USE
AN
ADVERSARY
ARGUMENT
TO
SHOW
THAT
D
F
N
FOR
ANY
DECISION
TREE
QUERY
OF
AN
INPUT
BIT
XI
THE
ADVERSARY
RESPONDS
THAT
XI
EQUALS
FOR
THE
FIRST
N
QUERIES
SINCE
F
IS
THE
OR
FUNCTION
THE
DECISION
TREE
WILL
BE
IN
SUSPENSE
UNTIL
THE
VALUE
OF
THE
NTH
BIT
IS
REVEALED
THUS
D
F
IS
N
EXAMPLE
CONSIDER
THE
AND
OR
FUNCTION
WITH
N
WE
DEFINE
FK
AS
FOLLOWS
FK
XN
FK
FK
IF
K
AND
IS
ODD
XI
IF
K
A
DIAGRAM
OF
A
CIRCUIT
THAT
COMPUTES
THE
AND
OR
FUNCTION
IS
SHOWN
IN
FIGURE
IT
IS
LEFT
AS
AN
EXERCISE
TO
PROVE
USING
INDUCTION
THAT
D
FK
DRAFT
WEB
DRAFT
CERTIFICATE
COMPLEXITY
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
A
CIRCUIT
SHOWING
THE
COMPUTATION
OF
THE
AND
OR
FUNCTION
THE
CIRCUIT
HAS
K
LAYERS
OF
ALTERNATING
GATES
WHERE
N
CERTIFICATE
COMPLEXITY
WE
NOW
INTRODUCE
THE
NOTION
OF
CERTIFICATE
COMPLEXITY
WHICH
IN
A
MANNER
ANALOGOUS
TO
DECISION
TREE
COMPLEXITY
ABOVE
TELLS
US
THE
MINIMUM
AMOUNT
OF
INFORMATION
NEEDED
TO
BE
CONVINCED
OF
THE
VALUE
OF
A
FUNCTION
F
ON
INPUT
X
DEFINITION
CONSIDER
A
FUNCTION
F
N
IF
F
X
THEN
A
CERTIFICATE
FOR
X
IS
A
SEQUENCE
OF
BITS
IN
X
THAT
PROVES
F
X
IF
F
X
THEN
A
CERTIFICATE
IS
A
SEQUENCE
OF
BITS
IN
X
THAT
PROVES
F
X
DEFINITION
THE
CERTIFICATE
COMPLEXITY
C
F
OF
F
IS
DEFINED
AS
FOLLOWS
C
F
MAX
X
INPUT
NUMBER
OF
BITS
IN
THE
SMALLEST
OR
CERTIFICATE
FOR
X
EXAMPLE
IF
F
IS
A
FUNCTION
THAT
DECIDES
CONNECTIVITY
OF
A
GRAPH
A
CERTIFICATE
FOR
AN
INPUT
MUST
PROVE
THAT
SOME
CUT
IN
THE
GRAPH
HAS
NO
EDGES
HENCE
IT
HAS
TO
CONTAIN
ALL
THE
POSSIBLE
EDGES
OF
A
CUT
OF
THE
GRAPH
WHEN
THESE
EDGES
DO
NOT
EXIST
THE
GRAPH
IS
DISCONNECTED
SIMILARLY
A
CERTIFICATE
IS
THE
EDGES
OF
A
SPANNING
TREE
THUS
FOR
THOSE
INPUTS
THAT
REPRESENT
A
CONNECTED
GRAPH
THE
MINIMUM
SIZE
OF
A
CERTIFICATE
IS
THE
NUMBER
OF
EDGES
IN
A
SPANNING
TREE
N
FOR
THOSE
THAT
REPRESENT
A
DISCONNECTED
GRAPH
A
CERTIFICATE
IS
THE
SET
OF
EDGES
IN
A
CUT
THE
SIZE
OF
A
CERTIFICATE
IS
AT
MOST
N
AND
THERE
ARE
GRAPHS
SUCH
AS
THE
GRAPH
CONSISTING
OF
TWO
DISJOINT
CLIQUES
OF
SIZE
N
IN
WHICH
NO
SMALLER
CERTIFICATE
EXISTS
THUS
C
F
EXAMPLE
WE
SHOW
THAT
THE
CERTIFICATE
COMPLEXITY
OF
THE
AND
OR
FUNCTION
FK
OF
EXAMPLE
IS
RECALL
THAT
FK
IS
DEFINED
USING
A
CIRCUIT
OF
K
LAYERS
EACH
LAYER
CONTAINS
ONLY
OR
GATES
OR
ONLY
AND
GATES
AND
THE
LAYERS
HAVE
ALTERNATIVE
GATE
TYPES
THE
BOTTOM
LAYER
RECEIVES
THE
BITS
OF
INPUT
X
AS
INPUT
AND
THE
SINGLE
TOP
LAYER
GATE
OUTPUTS
THE
ANSWER
FK
X
IF
F
X
WE
CAN
CONSTRUCT
A
CERTIFICATE
AS
FOLLOWS
FOR
EVERY
AND
GATE
IN
THE
TREE
OF
GATES
WE
HAVE
TO
PROVE
THAT
BOTH
ITS
CHILDREN
EVALUATE
TO
WHEREAS
FOR
EVERY
OR
GATE
WE
ONLY
NEED
TO
PROVE
THAT
SOME
CHILD
EVALUATES
TO
THUS
THE
CERTIFICATE
IS
A
SUBTREE
IN
WHICH
THE
AND
GATES
HAVE
TWO
CHILDREN
BUT
THE
OR
GATES
ONLY
HAVE
ONE
EACH
THUS
THE
SUBTREE
ONLY
NEEDS
TO
INVOLVE
INPUT
BITS
IF
F
X
A
SIMILAR
WEB
DRAFT
CERTIFICATE
COMPLEXITY
ARGUMENT
APPLIES
BUT
THE
ROLE
OF
OR
GATES
AND
AND
GATES
AND
VALUES
AND
ARE
REVERSED
THE
RESULT
IS
THAT
THE
CERTIFICATE
COMPLEXITY
OF
FK
IS
OR
ABOUT
N
THE
FOLLOWING
IS
A
ROUGH
WAY
TO
THINK
ABOUT
THESE
CONCEPTS
IN
ANALOGY
TO
TURING
MACHINE
COMPLEXITY
AS
WE
HAVE
STUDIED
IT
LOW
DECISION
TREE
COMPLEXITY
P
LOW
CERTIFICATE
COMPLEXITY
NP
LOW
CERTIFICATE
COMPLEXITY
CONP
THE
FOLLOWING
RESULT
SHOWS
HOWEVER
THAT
THE
ANALOGY
MAY
NOT
BE
EXACT
SINCE
IN
THE
DECISION
TREE
WORLD
P
NP
CONP
IT
SHOULD
BE
NOTED
THAT
THE
RESULT
IS
TIGHT
FOR
EXAMPLE
FOR
THE
AND
OR
FUNCTION
THEOREM
FOR
FUNCTION
F
D
F
C
F
PROOF
LET
BE
THE
SET
OF
MINIMAL
CERTIFICATES
AND
CERTIFICATES
RESPECTIVELY
FOR
F
LET
K
C
F
SO
EACH
CERTIFICATE
HAS
AT
MOST
K
BITS
REMARK
NOTE
THAT
EVERY
CERTIFICATE
MUST
SHARE
A
BIT
POSITION
WITH
EVERY
CERTIFICATE
AND
FURTHERMORE
ASSIGN
THIS
BIT
DIFFERENTLY
IF
THIS
WERE
NOT
THE
CASE
THEN
IT
WOULD
BE
POSSIBLE
FOR
BOTH
A
CERTIFICATE
AND
CERTIFICATE
TO
BE
ASSERTED
AT
THE
SAME
TIME
WHICH
IS
IMPOSSIBLE
THE
FOLLOWING
DECISION
TREE
ALGORITHM
THEN
DETERMINES
THE
VALUE
OF
F
IN
AT
MOST
QUERIES
ALGORITHM
REPEAT
UNTIL
THE
VALUE
OF
F
IS
DETERMINED
CHOOSE
A
REMAINING
CERTIFICATE
FROM
AND
QUERY
ALL
THE
BITS
IN
IT
IF
THE
BITS
ARE
THE
VALUES
THAT
PROVE
THE
F
TO
BE
THEN
STOP
OTHERWISE
WE
CAN
PRUNE
THE
SET
OF
REMAINING
CERTIFICATES
AS
FOLLOWS
SINCE
ALL
CERTIFICATES
MUST
INTERSECT
THE
CHOSEN
CERTIFICATE
FOR
ANY
ONE
BIT
IN
MUST
HAVE
BEEN
QUERIED
HERE
ELIMINATE
FROM
CONSIDERATION
IF
THE
CERTIFYING
VALUE
OF
AT
AT
LOCATION
IS
DIFFERENT
FROM
THE
ACTUAL
VALUE
FOUND
OTHERWISE
WE
ONLY
NEED
TO
CONSIDER
THE
REMAINING
K
BITS
OF
THIS
ALGORITHM
CAN
REPEAT
AT
MOST
K
TIMES
FOR
EACH
ITERATION
THE
UNFIXED
LENGTHS
OF
THE
UNELIMINATED
CERTIFICATES
DECREASES
BY
ONE
THIS
IS
BECAUSE
ONCE
SOME
VALUES
OF
THE
INPUT
HAVE
BEEN
FIXED
DUE
TO
QUERIES
FOR
ANY
CERTIFICATE
IT
REMAINS
TRUE
THAT
ALL
CERTIFICATES
MUST
INTERSECT
IT
IN
AT
LEAST
ONE
LOCATION
THAT
HAS
NOT
BEEN
FIXED
OTHERWISE
IT
WOULD
BE
POSSIBLE
FOR
BOTH
A
CERTIFICATE
AND
A
CERTIFICATE
TO
BE
ASSERTED
WITH
AT
MOST
K
QUERIES
FOR
AT
MOST
K
ITERATIONS
A
TOTAL
OF
QUERIES
IS
USED
DRAFT
WEB
DRAFT
RANDOMIZED
DECISION
TREES
RANDOMIZED
DECISION
TREES
THERE
ARE
TWO
EQUIVALENT
WAYS
TO
LOOK
AT
RANDOMIZED
DECISION
TREES
WE
CAN
CONSIDER
DECISION
TREES
IN
WHICH
THE
BRANCH
TAKEN
AT
EACH
NODE
IS
DETERMINED
BY
THE
QUERY
VALUE
AND
BY
A
RANDOM
COIN
FLIP
WE
CAN
ALSO
CONSIDER
PROBABILITY
DISTRIBUTIONS
OVER
DETERMINISTIC
DECISION
TREES
THE
ANALYSIS
THAT
FOLLOWS
USES
THE
LATTER
MODEL
WE
WILL
CALL
A
PROBABILITY
DISTRIBUTION
OVER
A
SET
OF
DECISION
TREES
THAT
COMPUTE
A
PARTICULAR
FUNCTION
IS
THEN
THE
PROBABILITY
THAT
TREE
T
IS
CHOSEN
FROM
THE
DISTRIBUTION
FOR
A
PARTICULAR
INPUT
X
THEN
WE
DEFINE
C
X
TIN
T
COST
T
X
C
X
IS
THUS
THE
EXPECTED
NUMBER
OF
QUERIES
A
TREE
CHOSEN
FROM
WILL
MAKE
ON
INPUT
X
WE
CAN
THEN
CHARACTERIZE
HOW
WELL
RANDOMIZED
DECISION
TREES
CAN
OPERATE
ON
A
PARTICULAR
PROBLEM
DEFINITION
THE
RANDOMIZED
DECISION
TREE
COMPLEXITY
R
F
OF
F
IS
DEFINED
AS
FOLLOWS
R
F
MIN
MAX
C
P
X
P
X
THE
RANDOMIZED
DECISION
TREE
COMPLEXITY
THUS
EXPRESSES
HOW
WELL
THE
BEST
POSSIBLE
PROBABILITY
DISTRIBUTION
OF
TREES
WILL
DO
AGAINST
THE
WORST
POSSIBLE
INPUT
FOR
A
PARTICULAR
PROBABILITY
DISTRIBUTION
OF
TREES
WE
CAN
OBSERVE
IMMEDIATELY
THAT
F
C
F
THIS
IS
BECAUSE
C
F
IS
A
MINIMUM
VALUE
OF
COST
T
X
SINCE
F
IS
JUST
AN
EXPECTED
VALUE
FOR
A
PARTICULAR
PROBABILITY
DISTRIBUTION
OF
THESE
COST
VALUES
THE
MINIMUM
SUCH
VALUE
CAN
BE
NO
GREATER
THAN
THE
EXPECTED
VALUE
EXAMPLE
CONSIDER
THE
MAJORITY
FUNCTION
F
M
AJ
IT
IS
STRAIGHTFORWARD
TO
SEE
THAT
D
F
WE
SHOW
THAT
F
LET
BE
A
UNIFORM
DISTRIBUTION
OVER
THE
SIX
WAYS
OF
ORDERING
THE
QUERIES
OF
THE
THREE
INPUT
BITS
NOW
IF
ALL
THREE
BITS
ARE
THE
SAME
THEN
REGARDLESS
OF
THE
ORDER
CHOSEN
THE
DECISION
TREE
WILL
PRODUCE
THE
CORRECT
ANSWER
AFTER
TWO
QUERIES
FOR
SUCH
X
C
X
IF
TWO
OF
THE
BITS
ARE
THE
SAME
AND
THE
THIRD
IS
DIFFERENT
THEN
THERE
IS
A
PROBABILITY
THAT
THE
CHOSEN
DECISION
TREE
WILL
CHOOSE
THE
TWO
SIMILAR
BITS
TO
QUERY
FIRST
AND
THUS
A
PROBABILITY
THAT
THE
COST
WILL
BE
THERE
THUS
REMAINS
A
PROBABILITY
THAT
ALL
THREE
BITS
WILL
NEED
TO
BE
INSPECTED
FOR
SUCH
X
THEN
C
P
X
THEREFORE
R
F
IS
AT
MOST
HOW
CAN
WE
PROVE
LOWERBOUNDS
ON
RANDOMIZED
COMPLEXITY
FOR
THIS
WE
NEED
ANOTHER
CONCEPT
LOWERBOUNDS
ON
RANDOMIZED
COMPLEXITY
NEEDS
CLEANUP
NOW
TO
PROVE
LOWERBOUNDS
ON
RANDOMIZED
COMPLEXITY
IT
SUFFICES
BY
YAO
LEMMA
SEE
SECTION
TO
PROVE
LOWERBOUNDS
ON
DISTRIBUTIONAL
COMPLEXITY
WHERE
RANDOMIZED
COMPLEXITY
EXPLORES
DISTRIBU
TIONS
OVER
THE
SPACE
OF
DECISION
TREES
FOR
A
PROBLEM
DISTRIBUTIONAL
COMPLEXITY
CONSIDERS
PROBABILITY
DISTRIBUTIONS
ON
INPUTS
IT
IS
UNDER
SUCH
CONSIDERATIONS
THAT
WE
CAN
SPEAK
OF
AVERAGE
CASE
ANALYSIS
WEB
DRAFT
LOWERBOUNDS
ON
RANDOMIZED
COMPLEXITY
LET
BE
A
PROBABILITY
DISTRIBUTION
OVER
THE
SPACE
OF
INPUT
STRINGS
OF
LENGTH
N
THEN
IF
A
IS
A
DETERMINISTIC
ALGORITHM
SUCH
AS
A
DECISION
TREE
FOR
A
FUNCTION
THEN
WE
DEFINE
THE
DISTRIBUTIONAL
COMPLEXITY
OF
A
ON
A
FUNCTION
F
WITH
INPUTS
DISTRIBUTED
ACCORDING
TO
AS
THE
EXPECTED
COST
FOR
ALGORITHM
A
TO
COMPUTE
F
WHERE
THE
EXPECTATION
IS
OVER
THE
DISTRIBUTION
OF
INPUTS
DEFINITION
THE
DISTRIBUTIONAL
COMPLEXITY
D
A
OF
ALGORITHM
A
GIVEN
INPUTS
DISTRIBUTED
ACCORDING
TO
IS
DEFINED
AS
D
A
D
X
INPUT
D
X
COST
A
X
EX
D
COST
A
X
FROM
THIS
WE
CAN
CHARACTERIZE
DISTRIBUTIONAL
COMPLEXITY
AS
A
FUNCTION
OF
A
SINGLE
FUNCTION
F
ITSELF
DEFINITION
THE
DISTRIBUTIONAL
DECISION
TREE
COMPLEXITY
F
OF
FUNCTION
F
IS
DEFINED
AS
F
MAX
MIN
D
A
D
D
A
WHERE
A
ABOVE
RUNS
OVER
THE
SET
OF
DECISION
TREES
THAT
ARE
DECIDERS
FOR
F
SO
THE
DISTRIBUTIONAL
DECISION
TREE
COMPLEXITY
MEASURES
THE
EXPECTED
EFFICIENCY
OF
THE
MOST
EFFICIENT
DECISION
TREE
ALGORITHM
WORKS
GIVEN
THE
WORST
CASE
DISTRIBUTION
OF
INPUTS
THE
FOLLOWING
THEOREM
FOLLOWS
FROM
YAO
LEMMA
THEOREM
R
F
F
SO
IN
ORDER
TO
FIND
A
LOWER
BOUND
ON
SOME
RANDOMIZED
ALGORITHM
IT
SUFFICES
TO
FIND
A
LOWER
BOUND
ON
F
SUCH
A
LOWER
BOUND
CAN
BE
FOUND
BY
POSTULATING
AN
INPUT
DISTRIBUTION
AND
SEEING
WHETHER
EVERY
ALGORITHM
HAS
EXPECTED
COST
AT
LEAST
EQUAL
TO
THE
DESIRED
LOWER
BOUND
EXAMPLE
WE
RETURN
TO
CONSIDERING
THE
MAJORITY
FUNCTION
AND
WE
SEEK
TO
FIND
A
LOWER
BOUND
ON
F
CONSIDER
A
DISTRIBUTION
OVER
INPUTS
SUCH
THAT
INPUTS
IN
WHICH
ALL
THREE
BITS
MATCH
NAMELY
AND
OCCUR
WITH
PROBABILITY
ALL
OTHER
INPUTS
OCCUR
WITH
PROBABILITY
FOR
ANY
DECISION
TREE
THAT
IS
FOR
ANY
ORDER
IN
WHICH
THE
THREE
BITS
ARE
EXAMINED
THERE
IS
EXACTLY
A
PROBABILITY
THAT
THE
FIRST
TWO
BITS
EXAMINED
WILL
BE
THE
SAME
VALUE
AND
THUS
THERE
IS
A
PROBABILITY
THAT
THE
COST
IS
THERE
IS
THEN
A
PROBABILITY
THAT
THE
COST
IS
THUS
THE
OVERALL
EXPECTED
COST
FOR
THIS
DISTRIBUTION
IS
THIS
IMPLIES
THAT
F
AND
IN
TURN
THAT
R
F
SO
F
R
F
DRAFT
WEB
DRAFT
SOME
TECHNIQUES
FOR
DECISION
TREE
LOWERBOUNDS
SOME
TECHNIQUES
FOR
DECISION
TREE
LOWERBOUNDS
DEFINITION
SENSITIVITY
IF
F
N
IS
A
FUNCTION
AND
X
N
THEN
THE
SENSITIVITY
OF
F
ON
X
DENOTED
SX
F
IS
THE
NUMBER
OF
BIT
POSITIONS
I
SUCH
THAT
F
X
F
XI
WHERE
XI
IS
X
WITH
ITS
ITH
BIT
FLIPPED
THE
SENSITIVITY
OF
F
DENOTED
F
IS
MAXX
SX
F
THE
BLOCK
SENSITIVITY
OF
F
ON
X
DENOTED
BSX
F
IS
THE
MAXIMUM
NUMBER
B
SUCH
THAT
THERE
ARE
DISJOINT
BLOCKS
OF
BIT
POSITIONS
BB
SUCH
THAT
F
X
F
XBI
WHERE
XBI
IS
X
WITH
ALL
ITS
BITS
FLIPPED
IN
BLOCK
BI
THE
BLOCK
SENSITIVITY
OF
F
DENOTED
BS
F
IS
MAXX
BSX
F
IT
IS
CONJECTURED
THAT
THERE
IS
A
CONSTANT
C
AS
LOW
AS
SUCH
THAT
BS
F
O
F
C
FOR
ALL
F
BUT
THIS
IS
WIDE
OPEN
THE
FOLLOWING
EASY
OBSERVATION
IS
LEFT
AS
AN
EXERCISE
LEMMA
FOR
ANY
FUNCTION
F
BS
F
D
F
THEOREM
NISAN
C
F
F
BS
F
PROOF
FOR
ANY
INPUT
X
N
WE
DESCRIBE
A
CERTIFICATE
FOR
X
OF
SIZE
F
BS
F
THIS
CERTIFICATE
IS
OBTAINED
BY
CONSIDERING
THE
LARGEST
NUMBER
OF
DISJOINT
BLOCKS
OF
VARIABLES
BB
THAT
ACHIEVE
B
BSX
F
BS
F
WE
CLAIM
THAT
SETTING
THESE
VARIABLES
ACCORDING
TO
X
CONSTITUTES
A
CERTIFICATE
FOR
X
SUPPOSE
NOT
AND
LET
XI
BE
AN
INPUT
THAT
IS
CONSISTENT
WITH
THE
ABOVE
CERTIFICATE
LET
BB
BE
A
BLOCK
OF
VARIABLES
SUCH
THAT
XI
XBB
THEN
BB
MUST
BE
DISJOINT
FROM
BB
WHICH
CONTRADICTS
B
BSX
F
NOTE
THAT
EACH
OF
BB
HAS
SIZE
AT
MOST
F
BY
DEFINITION
OF
F
AND
HENCE
THE
SIZE
OF
THE
CERTIFICATE
WE
HAVE
EXHIBITED
IS
AT
MOST
F
BS
F
RECENT
WORK
ON
DECISION
TREE
LOWERBOUNDS
HAS
USED
POLYNOMIAL
REPRESENTATIONS
OF
BOOLEAN
FUNC
TIONS
RECALL
THAT
A
MULTILINEAR
POLYNOMIAL
IS
A
POLYNOMIAL
WHOSE
DEGREE
IN
EACH
VARIABLE
IS
DEFINITION
AN
N
VARIATE
POLYNOMIAL
P
XN
REPRESENTS
F
N
IF
P
X
F
X
FOR
ALL
X
THE
DEGREE
OF
F
DENOTED
DEG
F
IS
THE
DEGREE
OF
THE
MULTILINEAR
POLYNOMIAL
THAT
REPRESENTS
F
THE
EXERCISES
ASK
YOU
TO
SHOW
THAT
THE
MULTILINEAR
POLYNOMIAL
REPRESENTATION
IS
UNIQUE
SO
DEG
F
IS
WELL
DEFINED
EXAMPLE
THE
AND
OF
N
VARIABLES
XN
IS
REPRESENTED
BY
THE
MULTILINEAR
POLYNOMIAL
N
XI
AND
WEB
DRAFT
COMPARISON
TREES
AND
SORTING
LOWERBOUNDS
THE
DEGREE
OF
AND
AND
OR
IS
N
AND
SO
IS
THEIR
DECISION
TREE
COMPLEXITY
THERE
IS
A
SIMILAR
CONNECTION
FOR
OTHER
PROBLEMS
TOO
BUT
IT
IS
NOT
AS
TIGHT
THE
FIRST
PART
OF
THE
NEXT
THEOREM
IS
AN
EASY
EXERCISE
THE
SECOND
PART
IS
NONTRIVIAL
THEOREM
DEG
F
D
F
NISAN
SMOLENSKY
D
F
DEG
F
F
O
DEG
F
COMPARISON
TREES
AND
SORTING
LOWERBOUNDS
TO
BE
WRITTEN
YAO
MINMAX
LEMMA
THIS
SECTION
PRESENTS
YAO
MINMAX
LEMMA
WHICH
IS
USED
IN
A
VARIETY
OF
SETTINGS
TO
PROVE
LOWER
BOUNDS
ON
RANDOMIZED
ALGORITHMS
THEREFORE
WE
PRESENT
IT
IN
A
VERY
GENERAL
SETTING
LET
X
BE
A
FINITE
SET
OF
INPUTS
AND
A
BE
A
FINITE
SET
OF
ALGORITHMS
THAT
SOLVE
SOME
COMPUTATIONAL
PROBLEM
ON
THESE
INPUTS
FOR
X
X
A
A
WE
DENOTE
BY
COST
A
X
THE
COST
INCURRED
BY
ALGORITHM
A
ON
INPUT
X
A
RANDOMIZED
ALGORITHM
IS
A
PROBABILITY
DISTRIBUTION
R
ON
A
THE
COST
OF
R
ON
INPUT
X
DENOTED
COST
R
X
IS
EA
R
COST
A
X
THE
RANDOMIZED
COMPLEXITY
OF
THE
PROBLEM
IS
MIN
MAX
COST
R
X
R
X
X
LET
D
BE
A
DISTRIBUTION
ON
INPUTS
FOR
ANY
DETERMINISTIC
ALGORITHM
A
THE
COST
INCURRED
BY
IT
ON
D
DENOTED
COST
A
D
IS
EX
D
COST
A
X
THE
DISTRIBUTIONAL
COMPLEXITY
OF
THE
PROBLEM
IS
MAX
MIN
COST
A
D
D
A
A
YAO
LEMMA
SAYS
THAT
THESE
TWO
QUANTITITIES
ARE
THE
SAME
IT
IS
EASILY
DERIVED
FROM
VON
NEU
MANN
MINMAX
THEOREM
FOR
ZERO
SUM
GAMES
OR
WITH
A
LITTLE
MORE
WORK
FROM
LINEAR
PROGRAMMING
DUALITY
YAO
LEMMA
IS
TYPICALLY
USED
TO
LOWERBOUND
RANDOMIZED
COMPLEXITY
TO
DO
SO
ONE
DEFINES
USING
SOME
INSIGHT
AND
SOME
LUCK
A
SUITABLE
DISTRIBUTION
ON
THE
INPUTS
THEN
ONE
PROVES
THAT
EVERY
DETERMINISTIC
ALGORITHM
INCURS
HIGH
COST
SAY
C
ON
THIS
DISTRIBUTION
BY
YAO
LEMMA
IT
FOLLOWS
THAT
THE
RANDOMIZED
COMPLEXITY
THEN
IS
AT
LEAST
C
EXERCISES
SUPPOSE
F
IS
ANY
FUNCTION
THAT
DEPENDS
ON
ALL
ITS
BITS
IN
OTHER
WORDS
FOR
EACH
BIT
POSITION
I
THERE
IS
AN
INPUT
X
SUCH
THAT
F
X
F
XI
SHOW
THAT
F

LOG
N
CONSIDER
AN
DEFINED
AS
FOLLOWS
THE
BIT
INPUT
IS
PARTITIONED
INTO
BLOCKS
OF
SIZE
ABOUT
N
THE
FUNCTION
IS
IFF
THERE
IS
AT
LEAST
ONE
BLOCK
IN
WHICH
TWO
CONSECUTIVE
BITS
ARE
AND
THE
REMAINING
BITS
IN
THE
BLOCK
ARE
ESTIMATE
F
BS
F
C
F
D
F
FOR
THIS
FUNCTION
DRAFT
WEB
DRAFT
YAO
MINMAX
LEMMA
SHOW
THAT
THERE
IS
A
UNIQUE
MULTILINEAR
POLYNOMIAL
THAT
REPRESENTS
F
N
USE
THIS
FACT
TO
FIND
THE
MULTILINEAR
REPRESENTATION
OF
THE
PARITY
OF
N
VARIABLES
SHOW
THAT
DEG
F
D
F
CHAPTER
NOTES
AND
HISTORY
THE
RESULT
THAT
THE
DECISION
TREE
COMPLEXITY
OF
CONNECTIVITY
AND
MANY
OTHER
PROBLEMS
IS
N
HAS
MOTIVATED
THE
FOLLOWING
CONJECTURE
ATRIBUTED
VARIOUSLY
TO
ANDERAA
KARP
YAO
N
HERE
MONOTONE
MEANS
THAT
ADDING
EDGES
TO
THE
GRAPH
CANNOT
MAKE
IT
GO
FROM
HAVING
THE
PROPERTY
TO
NOT
HAVING
THE
PROPERTY
E
G
CONNECTIVITY
GRAPH
PROPERTY
MEANS
THAT
THE
PROPERTY
DOES
NOT
DEPEND
UPON
THE
VERTEX
INDICES
E
G
THE
PROPERTY
THAT
VERTEX
AND
VERTEX
HAVE
AN
EDGE
BETWEEN
THEM
THIS
CONJECTURE
IS
KNOWN
TO
BE
TRUE
UP
TO
A
O
FACTOR
THE
PROOF
USES
TOPOLOGY
AND
IS
EXCELLENTLY
DESCRIBED
IN
DU
AND
KO
A
MORE
AMBITIOUS
CONJECTURE
IS
THAT
EVEN
THE
RANDOMIZED
DECISION
TREE
COMPLEXITY
OF
MONOTONE
GRAPH
PROPERTIES
IS

BUT
HERE
THE
BEST
LOWERBOUND
IS
CLOSE
TO
THE
POLYNOMIAL
METHOD
FOR
DECISION
TREE
LOWERBOUNDS
IS
SURVEYED
IN
BUHRMAN
AND
DE
WOLF
THE
METHOD
CAN
BE
USED
TO
LOWERBOUND
RANDOMIZED
DECISION
TREE
COMPLEXITY
AND
MORE
RECENTLY
QUANTUM
DECISION
TREE
COMPLEXITY
BUT
THEN
ONE
NEEDS
TO
CONSIDER
POLYNOMIALS
THAT
APPROXIMATELY
REPRESENT
THE
FUNCTION
WEB
DRAFT
YAO
MINMAX
LEMMA
DRAFT
WEB
DRAFT
CHAPTER
COMMUNICATION
COMPLEXITY
COMMUNICATION
COMPLEXITY
CONCERNS
THE
FOLLOWING
SCENARIO
THERE
ARE
TWO
PLAYERS
WITH
UNLIMITED
COMPUTATIONAL
POWER
EACH
OF
WHOM
HOLDS
AN
N
BIT
INPUT
SAY
X
AND
Y
NEITHER
KNOWS
THE
OTHER
INPUT
AND
THEY
WISH
TO
COLLABORATIVELY
COMPUTE
F
X
Y
WHERE
FUNCTION
F
N
N
IS
KNOWN
TO
BOTH
FURTHERMORE
THEY
HAD
FORESEEN
THIS
SITUATION
E
G
ONE
OF
THE
PARTIES
COULD
BE
A
SPACECRAFT
AND
THE
OTHER
COULD
BE
THE
BASE
STATION
ON
EARTH
SO
THEY
HAD
ALREADY
BEFORE
THEY
KNEW
THEIR
INPUTS
X
Y
AGREED
UPON
A
PROTOCOL
FOR
THE
COST
OF
THIS
PROTOCOL
IS
THE
NUMBER
OF
BITS
COMMUNICATED
BY
THE
PLAYERS
FOR
THE
WORST
CASE
CHOICE
OF
X
Y
RESEARCHERS
HAVE
STUDIED
MANY
MODIFICATIONS
OF
THE
ABOVE
BASIC
SCENARIO
INCLUDING
RANDOMIZED
PROTOCOLS
NONDETERMINISTIC
PROTOCOLS
AVERAGE
CASE
PROTOCOLS
WHERE
X
Y
ARE
ASSUMED
TO
COME
FROM
A
DISTRIBUTION
MULTIPARTY
PROTOCOLS
ETC
TRULY
THIS
IS
A
SELF
CONTAINED
MINI
WORLD
WITHIN
COM
PLEXITY
THEORY
FURTHERMORE
LOWERBOUNDS
ON
COMMUNICATION
COMPLEXITY
HAVE
USES
IN
A
VARIETY
OF
AREAS
INCLUDING
LOWERBOUNDS
FOR
PARALLEL
AND
VLSI
COMPUTATION
CIRCUIT
LOWERBOUNDS
POLYHEDRAL
THEORY
DATA
STRUCTURE
LOWERBOUNDS
ETC
WE
GIVE
A
VERY
RUDIMENTARY
INTRODUCTION
TO
THIS
AREA
AN
EXCELLENT
AND
DETAILED
TREATMENT
CAN
BE
FOUND
IN
THE
BOOK
BY
KUSHILEVITZ
AND
NISAN
DEFINITION
NOW
WE
FORMALIZE
THE
INFORMAL
DESCRIPTION
OF
COMMUNICATION
COMPLEXITY
GIVEN
ABOVE
A
T
ROUND
COMMUNICATION
PROTOCOL
FOR
F
IS
A
SEQUENCE
OF
FUNCTION
PAIRS
ST
CT
THE
INPUT
OF
SI
IS
THE
COMMUNICATION
PATTERN
OF
THE
FIRST
I
ROUNDS
AND
THE
OUTPUT
IS
FROM
INDICATING
WHICH
PLAYER
WILL
COMMUNICATE
IN
THE
ITH
ROUND
THE
INPUT
OF
CI
IS
THE
INPUT
STRING
OF
THIS
SELECTED
PLAYER
AS
WELL
AS
THE
COMMUNICATION
PATTERN
OF
THE
FIRST
I
ROUNDS
THE
OUTPUT
OF
CI
IS
THE
BIT
THAT
THIS
PLAYER
WILL
COMMUNICATE
IN
THE
ITH
ROUND
FINALLY
ARE
VALUED
FUNC
TIONS
THAT
THE
PLAYERS
APPLY
AT
THE
END
OF
THE
PROTOCOL
TO
THEIR
INPUTS
AS
WELL
AS
THE
COMMUNICATION
PATTERN
IN
THE
T
ROUNDS
IN
ORDER
TO
COMPUTE
THE
OUTPUT
THESE
TWO
OUTPUTS
MUST
BE
F
X
Y
THE
NOT
CONFUSE
THIS
SITUATION
WITH
INFORMATION
THEORY
WHERE
AN
ALGORITHM
IS
GIVEN
MESSAGES
THAT
HAVE
TO
BE
TRANSMITTED
OVER
A
NOISY
CHANNEL
AND
THE
GOAL
IS
TO
TRANSMIT
THEM
ROBUSTLY
WHILE
MINIMIZING
THE
AMOUNT
OF
COM
MUNICATION
IN
COMMUNICATION
COMPLEXITY
THE
CHANNEL
IS
NOT
NOISY
AND
THE
PLAYERS
DETERMINE
WHAT
MESSAGES
TO
SEND
WEB
DRAFT
COMPLEXITY
THEORY
A
MODERN
APPROACH
SANJEEV
ARORA
AND
BOAZ
BARAK
REFERENCES
AND
ATTRIBUTIONS
ARE
STILL
INCOMPLETE
LOWERBOUND
METHODS
COMMUNICATION
COMPLEXITY
OF
F
IS
C
F
MIN
PROTOCOLS
P
MAX
X
Y
NUMBER
OF
BITS
EXCHANGED
BY
P
ON
X
Y
NOTICE
C
F
N
SINCE
THE
TRIVIAL
PROTOCOL
IS
FOR
ONE
PLAYER
TO
COMMUNICATE
HIS
ENTIRE
INPUT
WHEREUPON
THE
SECOND
PLAYER
COMPUTES
F
X
Y
AND
COMMUNICATES
THAT
SINGLE
BIT
TO
THE
FIRST
CAN
THEY
MANAGE
WITH
LESS
COMMUNICATION
EXAMPLE
PARITY
SUPPOSE
THE
FUNCTION
F
X
Y
IS
THE
PARITY
OF
ALL
THE
BITS
IN
X
Y
WE
CLAIM
THAT
C
F
CLEARLY
C
F
SINCE
THE
FUNCTION
DEPENDS
NONTRIVIALLY
ON
EACH
INPUT
SO
EACH
PLAYER
MUST
TRANSMIT
AT
LEAST
ONE
BIT
NEXT
C
F
SINCE
IT
SUFFICES
FOR
EACH
PLAYER
TO
TRANSMIT
THE
PARITY
OF
ALL
THE
BITS
IN
HIS
POSSESSION
THEN
BOTH
KNOW
THE
PARITY
OF
ALL
THE
BITS
REMARK
SOMETIMES
STUDENTS
ASK
WHETHER
A
PLAYER
CAN
COMMUNICATE
BY
NOT
SAYING
ANYTHING
AFTER
ALL
THEY
HAVE
THREE
OPTIONS
SEND
A
OR
OR
NOT
SAY
ANYTHING
IN
THAT
ROUND
WE
CAN
REGARD
SUCH
PROTOCOLS
AS
COMMUNICATING
WITH
A
TERNARY
NOT
BINARY
ALPHABET
AND
ANALYZE
THEM
ANALOGOUSLY
LOWERBOUND
METHODS
NOW
WE
DISCUSS
METHODS
FOR
PROVING
LOWERBOUNDS
ON
COMMUNICATION
COMPLEXITY
AS
A
RUNNING
EXAMPLE
IN
THIS
CHAPTER
WE
WILL
USE
THE
EQUALITY
FUNCTION
EQ
X
Y
IF
X
Y
OTHERWISE
WE
WILL
SEE
THAT
C
EQ
N
FOOLING
SET
WE
SHOW
C
EQ
N
FOR
CONTRADICTION
SAKE
SUPPOSE
A
PROTOCOL
EXISTS
WHOSE
COMPLEXITY
IS
AT
MOST
N
THEN
THERE
ARE
ONLY
COMMUNICATION
PATTERNS
POSSIBLE
BETWEEN
THE
PLAYERS
CONSIDER
THE
SET
OF
ALL
PAIRS
X
X
USING
THE
PIGEONHOLE
PRINCIPLE
WE
CONCLUDE
THERE
EXIST
TWO
PAIRS
X
X
AND
XI
XI
ON
WHICH
THE
COMMUNICATION
PATTERN
IS
THE
SAME
OF
COURSE
THUS
FAR
WE
HAVE
NOTHING
TO
OBJECT
TO
SINCE
THE
ANSWERS
EQ
X
X
AND
EQ
XI
XI
ON
BOTH
PAIRS
ARE
HOWEVER
NOW
IMAGINE
GIVING
ONE
PLAYER
X
AND
THE
OTHER
PLAYER
XI
AS
INPUTS
A
MOMENT
THOUGHT
SHOWS
THAT
THE
COMMUNICATION
PATTERN
WILL
BE
THE
SAME
AS
THE
ONE
ON
X
X
AND
XI
XI
FORMALLY
THIS
CAN
BE
SHOWN
BY
INDUCTION
IF
PLAYER
COMMUNICATES
A
BIT
IN
THE
FIRST
ROUND
THEN
CLEARLY
THIS
BIT
IS
THE
SAME
WHETHER
HIS
INPUT
IS
X
OR
XI
IF
PLAYER
COMMUNICATES
IN
THE
ROUND
THEN
HIS
BIT
MUST
ALSO
BE
THE
SAME
ON
BOTH
INPUTS
SINCE
HE
RECEIVES
THE
SAME
BIT
FROM
PLAYER
AND
SO
ON
DRAFT
WEB
DRAFT
LOWERBOUND
METHODS
HENCE
THE
PLAYER
ANSWER
ON
X
X
MUST
AGREE
WITH
THEIR
ANSWER
ON
X
XI
BUT
THEN
THE
PROTOCOL
MUST
BE
INCORRECT
SINCE
EQ
X
XI
EQ
X
X
THE
LOWERBOUND
ARGUMENT
ABOVE
IS
CALLED
A
FOOLING
SET
ARGUMENT
IT
IS
FORMALIZED
AS
FOLLOWS
DEFINITION
A
FOOLING
SET
FOR
F
N
N
IS
A
SET
N
N
AND
A
VALUE
B
FOR
EVERY
X
Y
F
X
Y
B
FOR
EVERY
TWO
DISTINCT
PAIRS
EITHER
F
B
OR
F
B
LEMMA
IF
F
HAS
A
FOOLING
SET
WITH
M
PAIRS
THEN
C
F
M
EXAMPLE
DISJOINTNESS
LET
X
Y
BE
INTERPRETED
AS
CHARACTERISTIC
VECTORS
OF
SUBSETS
OF
N
LET
DISJ
X
Y
IF
THESE
TWO
SUBSETS
ARE
DISJOINT
OTHERWISE
DISJ
X
Y
THEN
C
DISJ
N
SINCE
THE
FOLLOWING
PAIRS
CONSTITUTE
A
FOOLING
SET
A
A
A
N
THE
TILING
LOWERBOUND
THE
TILING
LOWERBOUND
TAKES
A
MORE
GLOBAL
VIEW
OF
F
CONSIDER
THE
MATRIX
OF
F
DENOTED
M
F
WHICH
IS
A
MATRIX
WHOSE
X
Y
TH
ENTRY
IS
F
X
Y
SEE
FIGURE
WE
VISUALIZE
THE
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
MATRIX
M
F
FOR
THE
EQUALITY
FUNCTION
WHEN
THE
INPUTS
TO
THE
PLAYERS
HAVE
BITS
THE
NUMBERS
IN
THE
MATRIX
ARE
VALUES
OF
F
COMMUNICATION
PROTOCOL
IN
TERMS
OF
THIS
MATRIX
A
COMBINATORIAL
RECTANGLE
OR
JUST
RECTANGLE
IN
THE
MATRIX
IS
A
SUBMATRIX
CORRESPONDING
TO
A
B
WHERE
A
N
B
N
IF
THE
PROTOCOL
BEGINS
WITH
THE
FIRST
PLAYER
SENDING
A
BIT
THEN
M
F
PARTITIONS
INTO
TWO
RECTANGLES
OF
THE
TYPE
N
BN
WHERE
AB
IS
THE
SUBSET
OF
STRINGS
FOR
WHICH
THE
FIRST
PLAYER
COMMUNICATES
BIT
B
NOTICE
N
IF
THE
NEXT
BIT
IS
SENT
BY
THE
SECOND
PLAYER
THEN
EACH
OF
THE
TWO
RECTANGLES
ABOVE
IS
FURTHER
PARTITIONED
INTO
TWO
SMALLER
RECTANGLES
DEPENDING
UPON
WHAT
THIS
BIT
WAS
IF
THE
PROTOCOL
CONTINUES
FOR
K
STEPS
THE
MATRIX
GETS
PARTITIONED
INTO
RECTANGLES
NOTE
THAT
EACH
RECTANGLE
IN
THE
PARTITION
CORRESPONDS
TO
A
SUBSET
OF
INPUT
PAIRS
FOR
WHICH
THE
COMMUNICATION
SEQUENCE
THUS
FAR
HAS
BEEN
IDENTICAL
SEE
FIGURE
FOR
AN
EXAMPLE
WEB
DRAFT
LOWERBOUND
METHODS
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
TWO
WAY
COMMUNICATION
MATRIX
AFTER
TWO
STEPS
THE
LARGE
NUMBER
LABELS
ARE
THE
CONCATENATION
OF
THE
BIT
SENT
BY
THE
FIRST
PLAYER
WITH
THE
BIT
SENT
BY
THE
SECOND
PLAYER
IF
THE
PROTOCOL
STOPS
THEN
THE
VALUE
OF
F
IS
DETERMINED
WITHIN
EACH
RECTANGLE
AND
THUS
MUST
BE
THE
SAME
FOR
ALL
PAIRS
X
Y
IN
THAT
RECTANGLE
THUS
THE
SET
OF
ALL
COMMUNICATION
PATTERNS
MUST
LEAD
TO
A
PARTITION
OF
THE
MATRIX
INTO
MONOCHROMATIC
RECTANGLES
A
RECTANGLE
A
B
IS
MONOCHROMATIC
IF
FOR
ALL
X
IN
A
AND
Y
IN
B
F
X
Y
IS
THE
SAME
DEFINITION
A
MONOCHROMATIC
TILING
OF
M
F
IS
A
PARTITION
OF
M
F
INTO
DISJOINT
MONOCHROMATIC
RECTANGLES
WE
DENOTE
BY

F
THE
MINIMUM
NUMBER
OF
RECTANGLES
IN
ANY
MONOCHROMATIC
TILING
OF
M
F
THE
FOLLOWING
THEOREM
IS
IMMEDIATE
FROM
OUR
DISCUSSION
ABOVE
THEOREM
IF
F
HAS
COMMUNICATION
COMPLEXITY
C
THEN
IT
HAS
A
MONOCHROMATIC
TILING
WITH
AT
MOST
RECTANGLES
CONSEQUENTLY
C

F
THE
FOLLOWING
OBSERVATION
SHOWS
THAT
THE
TILING
BOUND
SUBSUMES
THE
FOOLING
SET
BOUND
LEMMA
IF
F
HAS
A
FOOLING
SET
WITH
M
PAIRS
THEN

F
M
PROOF
IF
AND
ARE
TWO
OF
THE
PAIRS
IN
THE
FOOLING
SET
THEN
THEY
CANNOT
BE
IN
A
MONOCHROMATIC
RECTANGLE
SINCE
NOT
ALL
OF
HAVE
THE
SAME
F
VALUE
RANK
LOWERBOUND
NOW
WE
INTRODUCE
AN
ALGEBRAIC
METHOD
TO
LOWERBOUND

F
AND
HENCE
COMMUNICATION
COMPLEXITY
RECALL
THE
HIGH
SCHOOL
NOTION
OF
RANK
OF
A
SQUARE
MATRIX
IT
IS
THE
SIZE
OF
THE
LARGEST
SUBSET
OF
ROWS
COLUMS
THAT
ARE
INDEPENDENT
THE
FOLLOWING
IS
ANOTHER
DEFINITION
DEFINITION
IF
A
MATRIX
HAS
ENTRIES
FROM
A
FIELD
F
THEN
THE
RANK
OF
AN
N
N
MATRIX
M
IS
THE
MINIMUM
VALUE
OF
L
SUCH
THAT
M
CAN
BE
EXPRESSED
AS
L
M
IBI
I
WHERE
I
F
AND
EACH
BI
IS
AN
N
N
MATRIX
OF
RANK
NOTE
THAT
ARE
ELEMENTS
OF
EVERY
FIELD
SO
WE
CAN
COMPUTE
THE
RANK
OVER
ANY
FIELD
WE
LIKE
THE
CHOICE
OF
FIELD
CAN
BE
CRUCIAL
SEE
PROBLEM
IN
THE
EXERCISES
THE
FOLLOWING
THEOREM
IS
TRIVIAL
SINCE
EACH
MONOCHROMATIC
RECTANGLE
CAN
BE
VIEWED
BY
FILLING
OUT
ENTRIES
OUTSIDE
THE
RECTANGLE
WITH
AS
A
MATRIX
OF
RANK
AT
MOST
THEOREM
FOR
EVERY
FUNCTION
F

F
RANK
M
F
DRAFT
WEB
DRAFT
LOWERBOUND
METHODS
DISCREPANCY
THE
DISCREPANCY
OF
A
RECTANGLE
A
B
IN
M
F
IS
NUMBER
OF
IN
A
B
NUMBER
OF
IN
A
B
THE
DISCREPANCY
OF
THE
MATRIX
M
F
DENOTE
DISC
F
IS
THE
LARGEST
DISCREPANCY
AMONG
ALL
RECTANGLES
THE
FOLLOWING
LEMMA
RELATES
IT
TO

F
LEMMA

F
DISC
F
PROOF
FOR
A
MONOCHROMATIC
RECTANGLE
THE
DISCREPANCY
IS
ITS
SIZE
DIVIDED
BY
THE
TOTAL
NUMBER
OF
ENTRIES
IN
THE
MATRIX
IS
THE
BOUND
FOLLOWS
EXAMPLE
LEMMA
CAN
BE
VERY
LOOSE
FOR
THE
EQ
FUNCTION
THE
DISCREPANCY
IS
AT
LEAST
N
NAMELY
THE
DISCREPANCY
OF
THE
ENTIRE
MATRIX
WHICH
WOULD
ONLY
GIVE
A
LOWERBOUND
OF
FOR

F
HOWEVER

F
IS
AT
LEAST
AS
ALREADY
NOTED
NOW
WE
DESCRIBE
A
METHOD
TO
UPPERBOUND
THE
DISCREPANCY
USING
EIGENVALUES
LEMMA
EIGENVALUE
BOUND
FOR
ANY
MATRIX
M
THE
DISCREPANCY
OF
A
RECTANGLE
A
B
IS
AT
MOST
MAX
M
A
B
WHERE
MAX
M
IS
THE
MAGNITUDE
OF
THE
LARGEST
EIGENVALUE
OF
M
PROOF
LET
RN
DENOTE
THE
CHARACTERISTIC
VECTORS
OF
A
B
THEN
I
A
A
THE
DISCREPANCY
OF
THE
RECTANGLE
A
B
IS
M

M

M
J
A
B
A
B
MAX
A
B
MAX
EXPLAIN
THIS
EXAMPLE
THE
MOD
INNER
PRODUCT
FUNCTION
DEFINED
AS
F
X
Y
X
Y
I
XIYI
HAS
BEEN
ENCOUN
TERED
A
FEW
TIMES
IN
THIS
BOOK
TO
BOUND
ITS
DISCREPANCY
WE
CONSIDER
THE
MATRIX
F
THIS
TRANSFORMATION
MAKES
THE
RANGE
OF
THE
FUNCTION
AND
WILL
BE
USEFUL
AGAIN
LATER
LET
THIS
NEW
WEB
DRAFT
LOWERBOUND
METHODS
MATRIX
BE
DENOTED
N
IT
IS
EASILY
CHECKED
THAT
EVERY
TWO
DISTINCT
ROWS
COLUMNS
OF
N
ARE
ORTHOG
ONAL
EVERY
ROW
HAS
NORM
AND
THAT
N
T
N
THUS
WE
CONCLUDE
THAT
N
WHERE
I
IS
THAT
THE
DISCREPANCY
OF
A
RECTANGLE
A
B
IS
AT
MOST
AT
MOST
SINCE
A
B
A
B
AND
THE
OVERALL
DISCREPANCY
IS
A
TECHNIQUE
FOR
UPPERBOUNDING
THE
DISCREPANCY
NOW
WE
DESCRIBE
AN
UPPERBOUND
TECHNIQUE
FOR
THE
DISCREPANCY
THAT
WILL
LATER
BE
USEFUL
IN
THE
MULTIPARTY
SETTING
SECTION
FOR
EASE
OF
NOTATION
IN
THIS
SECTION
WE
CHANGE
THE
RANGE
OF
F
TO
BY
REPLACING
IN
M
F
WITH
AND
REPLACING
WITH
NOTE
THAT
NOW
DISC
F
MAX
F
A
B
DEFINITION
E
F
I
J
F
AI
BJ
NOTE
THAT
E
F
CAN
BE
COMPUTED
LIKE
THE
RANK
IN
POLYNOMIAL
TIME
GIVEN
THE
M
F
AS
INPUT
LEMMA
PROOF
THE
PROOF
FOLLOWS
IN
TWO
STEPS
DISC
F
E
F
CLAIM
FOR
EVERY
FUNCTION
H
N
N
H
EA
B
F
A
B
WE
WILL
USE
THE
CAUCHY
SCHWARTZ
INEQUALITY
SPECIFICALLY
THE
VERSION
ACCORDING
TO
WHICH
E
E
Z
FOR
EVERY
RANDOM
VARIABLE
Z
E
H
FL
FL
H
AI
BJ
I
J
EB
H
B
H
B
EB
H
B
H
B
CAUCHY
SCHWARTZ
EA
B
H
A
B
REPEATING
PREV
TWO
STEPS
CLAIM
FOR
EVERY
FUNCTION
F
THERE
IS
A
FUNCTION
H
SUCH
THAT
F
H
AND
EA
B
H
A
B
DISC
F
DRAFT
WEB
DRAFT
LOWERBOUND
METHODS
FIRST
WE
NOTE
THAT
FOR
EVERY
TWO
FUNCTIONS
N
IF
WE
DEFINE
H
F
H
A
B
F
A
B
A
B
THEN
E
F
E
H
THE
REASON
IS
THAT
FOR
ALL
FL
FL
H
AI
BJ
FL
FL
F
AI
BJ
I
J
AND
THE
SQUARE
OF
ANY
VALUE
OF
IS
I
J
NOW
WE
PROVE
CLAIM
USING
THE
PROBABILISTIC
METHOD
DEFINE
TWO
RANDOM
FUNCTIONS
N
AS
FOLLOWS
G
A
IF
A
A
RA
RA
IS
RANDOMLY
CHOSEN
G
B
IF
B
B
SB
SB
IS
RANDOMLY
CHOSEN
LET
H
F
AND
THEREFORE
E
H
E
F
FURTHERMORE
EA
B
H
A
B
EA
B
F
A
B
A
B
A
A
B
B
F
A
B
DISC
F
WHERE
THE
SECOND
LINE
FOLLOWS
FROM
THE
FACT
THAT
A
B
FOR
A
A
AND
B
B
THUS
IN
PARTICULAR
THERE
EXIST
SUCH
THAT
EA
B
H
A
B
DISC
F
COMPARISON
OF
THE
LOWERBOUND
METHODS
AS
ALREADY
NOTED
DISCREPANCY
UPPERBOUNDS
IMPLY
LOWERBOUNDS
ON

F
OF
THE
OTHER
THREE
METH
ODS
THE
TILING
ARGUMENT
IS
THE
STRONGEST
SINCE
IT
SUBSUMES
THE
OTHER
TWO
THE
RANK
METHOD
IS
THE
WEAKEST
SINCE
THE
RANK
LOWERBOUND
ALWAYS
IMPLIES
A
TILING
LOWERBOUND
AND
A
FOOLING
SET
LOWERBOUND
THE
LATTER
FOLLOWS
FROM
PROBLEM
IN
THE
EXERCISES
ALSO
WE
CAN
SEPARATE
THE
POWER
OF
THESE
LOWERBOUND
ARGUMENTS
FOR
INSTANCE
WE
KNOW
FUNCTIONS
FOR
WHICH
THERE
IS
A
SIGNIFICANT
GAP
BETWEEN
LOG

F
AND
LOG
RANK
M
F
HOWEVER
THE
FOLLOWING
CONJECTURE
WE
ONLY
STATE
ONE
FORM
OF
IT
SAYS
THAT
ALL
THREE
METHODS
EXCEPT
DISCREPANCY
WHICH
AS
ALREADY
NOTED
CAN
BE
ARBITRARILY
FAR
FROM

F
GIVE
THE
SAME
BOUND
UP
TO
A
POLYNOMIAL
FACTOR
CONJECTURE
LOG
RANK
CONJECTURE
THERE
IS
A
CONSTANT
C
SUCH
THAT
C
F
O
LOG
RANK
M
F
C
FOR
ALL
F
AND
ALL
INPUT
SIZES
N
WEB
DRAFT
MULTIPARTY
COMMUNICATION
COMPLEXITY
MULTIPARTY
COMMUNICATION
COMPLEXITY
THERE
IS
MORE
THAN
ONE
WAY
TO
GENERALIZE
COMMUNICATION
COMPLEXITY
TO
A
MULTIPLAYER
SETTING
THE
MOST
INTERESTING
MODEL
IS
THE
NUMBER
ON
THE
FOREHEAD
MODEL
OFTEN
ENCOUNTERED
IN
MATH
PUZZLES
THAT
INVOLVE
PEOPLE
IN
A
ROOM
EACH
PERSON
HAVING
A
BIT
ON
THEIR
HEAD
WHICH
EVERYBODY
ELSE
CAN
SEE
BUT
THEY
CANNOT
MORE
FORMALLY
THERE
IS
SOME
FUNCTION
F
N
K
AND
THE
INPUT
IS
XK
WHERE
EACH
XI
N
THE
ITH
PLAYER
CAN
SEE
ALL
THE
XJ
SUCH
THAT
J
I
AS
IN
THE
PLAYER
CASE
THE
K
PLAYERS
HAVE
AN
AGREED
UPON
PROTOCOL
FOR
COMMUNICATION
AND
ALL
THIS
COMMUNICATION
IS
POSTED
ON
A
PUBLIC
BLACKBOARD
AT
THE
END
OF
THE
PROTOCOL
ALL
PARTIES
MUST
KNOW
F
XK
EXAMPLE
CONSIDER
COMPUTING
THE
FUNCTION
N
F
MAJ
I
IN
THE
PARTY
MODEL
WHERE
ARE
N
BIT
STRINGS
THE
COMMUNICATION
COMPLEXITY
OF
THIS
FUNCTION
IS
EACH
PLAYER
COUNTS
THE
NUMBER
OF
I
SUCH
THAT
SHE
CAN
DETERMINE
THE
MAJORITY
OF
BY
EXAMINING
THE
BITS
AVAILABLE
TO
HER
SHE
WRITES
THE
PARITY
OF
THIS
NUMBER
ON
THE
BLACKBOARD
AND
THE
FINAL
ANSWER
IS
THE
PARITY
OF
THE
PLAYERS
BITS
THIS
PROTOCOL
IS
CORRECT
BECAUSE
THE
MAJORITY
FOR
EACH
ROW
IS
KNOWN
BY
EITHER
OR
PLAYERS
AND
BOTH
ARE
ODD
NUMBERS
EXAMPLE
GENERALIZED
INNER
PRODUCT
THE
GENERALIZED
INNER
PRODUCT
FUNCTION
GIPK
N
MAPS
NK
BITS
TO
BIT
AS
FOLLOWS
N
K
F
XK
XIJ
I
J
NOTICE
FOR
K
THIS
REDUCES
TO
THE
MOD
INNER
PRODUCT
OF
EXAMPLE
IN
THE
PARTY
MODEL
WE
INTRODUCED
THE
NOTION
OF
A
MONOCHROMATIC
RECTANGLE
IN
ORDER
TO
PROVE
LOWER
BOUNDS
FOR
THE
K
PARTY
CASE
WE
WILL
USE
CYLINDER
INTERSECTIONS
A
CYLINDER
IN
DIMEN
SION
I
IS
A
SUBSET
OF
THE
INPUTS
SUCH
THAT
IF
XK
THEN
FOR
ALL
XII
WE
HAVE
THAT
XI
XII
XI
XK
ALSO
A
CYLINDER
INTERSECTION
IS
K
TI
WHERE
TI
IS
A
CYLINDER
IN
DIMENSION
I
AS
NOTED
IN
THE
PARTY
CASE
A
COMMUNICATION
PROTOCOL
CAN
BE
VIEWED
AS
A
WAY
OF
PARTITIONING
THE
MATRIX
M
F
HERE
M
F
IS
A
K
DIMENSIONAL
CUBE
AND
PLAYER
I
COMMUNICATION
DOES
NOT
DEPEND
UPON
XI
THUS
WE
CONCLUDE
THAT
IF
F
HAS
A
MULTIPARTY
PROTOCOL
THAT
COMMUNICATES
C
BITS
THEN
ITS
MATRIX
HAS
A
TILING
USING
AT
MOST
MONOCHROMATIC
CYLINDER
INTERSECTIONS
DRAFT
WEB
DRAFT
MULTIPARTY
COMMUNICATION
COMPLEXITY
LEMMA
IF
EVERY
PARTITION
OF
M
F
INTO
MONOCHROMATIC
CYLINDER
INTERSECTIONS
REQUIRES
AT
LEAST
R
CYLINDER
INTERSECTIONS
THEN
THE
K
PARTY
COMMUNICATION
COMPLEXITY
ISAT
LEAST
R
DISCREPANCY
BASED
LOWERBOUND
IN
THIS
SECTION
WE
WILL
ASSUME
AS
IN
OUR
EARLIER
DISCUSSION
OF
DISCREPANCY
THAT
THE
RANGE
OF
THE
FUNCTION
F
IS
WE
DEFINE
THE
K
PARTY
DISCREPANCY
OF
F
BY
ANALOGY
TO
THE
PARTY
CASE
DISC
F
MAX
F
A
A
A
WHERE
T
RANGES
OVER
ALL
CYLINDER
INTERSECTIONS
TO
UPPERBOUND
THE
DISCREPANCY
WE
INTRODUCE
THE
K
PARTY
ANALOGUE
OF
E
F
LET
A
CUBE
BE
A
SET
D
IN
NK
OF
POINTS
OF
THE
FORM
K
K
WHERE
EACH
AI
J
N
E
F
ED
R
F
A
A
D
NOTICE
THAT
THE
DEFINITION
OF
FOR
THE
PARTY
CASE
IS
RECOVERED
WHEN
K
THE
NEXT
LEMMA
IS
ALSO
AN
EASY
GENERALIZATION
LEMMA
DISC
F
E
F
PROOF
THE
PROOF
IS
ANALOGOUS
TO
LEMMA
AND
LEFT
AS
AN
EXERCISE
THE
ONLY
DIFFERENCE
IS
THAT
INSTEAD
OF
DEFINING
RANDOM
FUNCTIONS
WE
NEED
TO
DEFINE
K
RANDOM
FUNCTIONS
GK
NK
WHERE
GI
DEPENDS
ON
EVERY
ONE
OF
THE
K
COORDINATES
EXCEPT
THE
ITH
NOW
WE
CAN
PROVE
A
LOWERBOUND
FOR
THE
GENERALIZED
INNER
PRODUCT
FUNCTION
NOTE
THAT
SINCE
WE
CHANGED
THE
RANGE
TO
IT
IS
NOW
DEFINED
AS
GIPK
N
XK
I
N
TLJ
K
XIJ
THEOREM
THE
FUNCTION
GIPK
N
HAS
K
PARTY
COMMUNICATION
COMPLEXITY

N
AS
N
GROWS
LARGER
PROOF
WE
USE
INDUCTION
ON
K
FOR
K
LET
K
BE
DEFINED
USING
AND
K
K
WE
CLAIM
THAT
E
GIPK
N
N
WEB
DRAFT
PROBABILISTIC
COMMUNICATION
COMPLEXITY
ASSUMING
TRUTH
FOR
K
WE
PROVE
FOR
K
A
RANDOM
CUBE
D
IN
NK
IS
PICKED
BY
PICKING
N
AND
THEN
PICKING
A
RANDOM
CUBE
DI
IN
K
N
E
GIPK
N
ED
A
D
GIPK
N
A
THE
PROOF
PROCEEDS
BY
CONSIDERING
THE
NUMBER
OF
COORDINATES
WHERE
STRINGS
AND
ARE
IDENTICAL
EXAMINING
THE
EXPRESSION
FOR
GIPK
N
IN
WE
SEE
THAT
THESE
COORDINATES
CONTRIBUTE
NOTHING
ONCE
WE
MULTIPLY
ALL
THE
TERMS
IN
THE
CUBE
SINCE
THEIR
CONTRIBUTIONS
GET
SQUARED
AND
THUS
BECOME
THE
COORDINATES
THAT
CONTRIBUTE
ARE
TO
BE
COMPLETED
PROBABILISTIC
COMMUNICATION
COMPLEXITY
WILL
DEFINE
THE
MODEL
GIVE
THE
PROTOCOL
FOR
EQ
AND
DESCRIBE
THE
DISCREPANCY
BASED
LOWERBOUND
OVERVIEW
OF
OTHER
COMMUNICATION
MODELS
WE
OUTLINE
SOME
OF
THE
ALTERNATIVE
SETTINGS
IN
WHICH
COMMUNICATION
COMPLEXITY
HAS
BEEN
STUDIED
NONDETERMINISTIC
PROTOCOLS
THESE
ARE
DEFINED
BY
ANALOGY
TO
NP
IN
A
NONDETERMINISTIC
PRO
TOCOL
THE
PLAYERS
ARE
BOTH
PROVIDED
AN
ADDITIONAL
THIRD
INPUT
Z
NONDETERMINISTIC
GUESS
APART
FROM
THIS
GUESS
THE
PROTOCOL
IS
DETERMINISTIC
THE
COST
INCURRED
ON
X
Y
IS
MIN
Z
Z
NUMBER
OF
BITS
EXCHANGED
BY
PROTOCOL
WHEN
GUESS
IS
Z
THE
NONDETERMINISTIC
COMMUNICATION
COMPLEXITY
OF
F
IS
THE
MINIMUM
K
SUCH
THAT
THERE
IS
A
NONDETERMINISTIC
PROTOCOL
WHOSE
COST
FOR
ALL
INPUT
PAIRS
IS
AT
MOST
K
IN
GENERAL
ONE
CAN
CONSIDER
COMMUNICATION
PROTOCOLS
ANALOGOUS
TO
NP
CONP
PH
ETC
RANDOMIZED
PROTOCOLS
THESE
ARE
DEFINED
BY
ANALOGY
TO
RP
BPP
THE
PLAYERS
ARE
PROVIDED
WITH
AN
ADDITIONAL
INPUT
R
THAT
IS
CHOSEN
UNIFORMLY
AT
RANDOM
FROM
M
BIT
STRINGS
FOR
SOME
M
RANDOMIZATION
CAN
SIGNIFICANTLY
REDUCE
THE
NEED
FOR
COMMUNICATION
FOR
INSTANCE
WE
CAN
USE
FINGERPRINTING
WITH
RANDOM
PRIMES
EXPLORED
IN
CHAPTER
TO
COMPUTE
THE
EQUALITY
FUNCTION
BY
EXCHANGING
O
LOG
N
BITS
THE
PLAYERS
JUST
PICK
A
RANDOM
PRIME
P
OF
O
LOG
N
BITS
AND
EXCHANGE
X
MOD
P
AND
Y
MOD
P
AVERAGE
CASE
PROTOCOLS
JUST
AS
WE
CAN
STUDY
AVERAGE
CASE
COMPLEXITY
IN
THE
TURING
MACHINE
MODEL
WE
CAN
STUDY
COMMUNICATION
COMPLEXITY
WHEN
THE
INPUTS
ARE
CHOSEN
FROM
A
DISTRIBU
TION
D
THIS
IS
DEFINED
AS
CD
F
MIN
PR
X
Y
D
NUMBER
OF
BITS
EXCHANGED
BY
P
ON
X
Y
PROTOCOLS
DRAFT
WEB
DRAFT
APPLICATIONS
OF
COMMUNICATION
COMPLEXITY
COMPUTING
A
NON
BOOLEAN
FUNCTION
HERE
THE
FUNCTION
OUTPUT
IS
NOT
JUST
BUT
AN
M
BIT
NUMBER
FOR
SOME
M
WE
DISCUSS
ONE
EXAMPLE
IN
THE
EXERCISES
ASYMMETRIC
COMMUNICATION
THE
COST
OF
COMMUNICATION
IS
ASYMMETRIC
THERE
IS
SOME
B
SUCH
THAT
IT
COSTS
THE
FIRST
PLAYER
B
TIMES
AS
MUCH
TO
TRANSMIT
A
BIT
THAN
IT
DOES
THE
SECOND
PLAYER
THE
GOAL
IS
TO
MINIMIZE
THE
TOTAL
COST
MULTIPARTY
SETTINGS
THE
MOST
OBVIOUS
GENERALIZATION
TO
MULTIPARTY
SETTINGS
IS
WHEREBY
F
HAS
K
ARGUMENTS
XK
AND
PLAYER
I
GETS
XI
AT
THE
END
ALL
PLAYERS
MUST
KNOW
F
XK
THIS
IS
NOT
AS
INTERESTING
AS
THE
SO
CALLED
NUMBER
OF
THE
FOREHEAD
WHERE
PLAYER
I
CAN
SEE
ALL
OF
THE
INPUT
EXCEPT
FOR
XI
WE
DISCUSS
IT
IN
SECTION
TOGETHER
WITH
SOME
APPLICATIONS
COMPUTING
A
RELATION
THERE
IS
A
RELATION
R
N
N
M
AND
GIVEN
X
Y
BN
THE
PLAYERS
SEEK
TO
AGREE
ON
ANY
B
M
SUCH
THAT
X
Y
B
R
SEE
SECTION
THESE
AND
MANY
OTHER
SETTINGS
ARE
DISCUSSED
IN
APPLICATIONS
OF
COMMUNICATION
COMPLEXITY
WE
BRIEFLY
DISCUSSED
PARALLEL
COMPUTATION
IN
CHAPTER
YAO
INVENTED
COMMUNICATION
COM
PLEXITY
AS
A
WAY
TO
LOWERBOUND
THE
RUNNING
TIME
OF
PARALLEL
COMPUTERS
FOR
CERTAIN
TASKS
THE
IDEA
IS
THAT
THE
INPUT
IS
DISTRIBUTED
AMONG
MANY
PROCESSORS
AND
IF
WE
PARTITION
THESE
PROCESSORS
INTO
TWO
HALVES
WE
MAY
LOWERBOUND
THE
COMPUTATION
TIME
BY
CONSIDERING
THE
AMOUNT
OF
COMMUNICATION
THAT
MUST
NECESSARILY
HAPPEN
BETWEEN
THE
TWO
HALVES
A
SIMILAR
IDEA
IS
USED
TO
PROVE
TIME
SPACE
LOWERBOUNDS
FOR
VLSI
CIRCUITS
FOR
INSTANCE
IN
A
VLSI
CHIP
THAT
IS
AN
M
M
GRID
IF
THE
COMMUNI
CATION
COMPLEXITY
FOR
A
FUNCTION
IS
GREATER
THAN
C
THEN
THE
TIME
REQUIRED
TO
COMPUTE
IT
IS
AT
LEAST
C
M
COMMUNICATION
COMPLEXITY
IS
ALSO
USEFUL
IN
TIME
SPACE
LOWERBOUNDS
FOR
TURING
MACHINES
SEE
PROBLEM
IN
EXERCISES
AND
CIRCUIT
LOWERBOUNDS
SEE
CHAPTER
DATA
STRUCTURES
SUCH
AS
HEAPS
SORTED
ARRAYS
LISTS
ETC
ARE
BASIC
OBJECTS
IN
ALGORITHM
DESIGN
OFTEN
ALGORITHM
DESIGNERS
WISH
TO
DETERMINE
IF
THE
DATA
STRUCTURE
THEY
HAVE
DESIGNED
IS
THE
BEST
POSSIBLE
COMMUNICATION
COMPLEXITY
LOWERBOUNDS
CAN
BE
USED
TO
ESTABLISH
SUCH
RESULTS
SEE
YANNAKAKIS
HAS
SHOWN
HOW
TO
USE
COMMUNICATION
COMPLEXITY
LOWERBOUNDS
TO
PROVE
LOWERBOUNDS
ON
THE
SIZE
OF
POLYTOPES
REPRESENTING
NP
COMPLETE
PROBLEMS
SOLVING
THE
OPEN
PROB
LEM
MENTIONED
IN
PROBLEM
IN
THE
EXERCISES
WOULD
PROVE
A
LOWERBOUND
FOR
THE
POLYTOPE
REPRESENTING
VERTEX
COVER
EXERCISES
IF
N
N
SHOW
THAT
A
SPACE
N
TM
TAKES
AT
LEAST

N
N
STEPS
TO
DECIDE
THE
LANGUAGE
X
X
X
SHOW
THAT
THE
HIGH
SCHOOL
DEFINITION
OF
RANK
THE
SIZE
OF
THE
LARGEST
SET
OF
INDEPENDENT
ROWS
OR
COLUMNS
IS
EQUIVALENT
TO
THAT
IN
DEFINITION
WEB
DRAFT
APPLICATIONS
OF
COMMUNICATION
COMPLEXITY
GIVE
A
FOOLING
SET
ARGUMENT
THAT
PROVES
THAT
C
F
ILOG
RANK
M
F
L
SHOW
THAT
C
F
RANK
M
F
CONSIDER
X
Y
AS
VECTORS
OVER
GF
N
AND
LET
F
X
Y
BE
THEIR
INNER
PRODUCT
MOD
PROVE
THAT
THE
COMMUNICATION
COMPLEXITY
IS
N
WHAT
FIELD
SHOULD
YOU
USE
TO
COMPUTE
THE
RANK
DOES
IT
MATTER
LET
F
N
N
BE
SUCH
THAT
ALL
ROWS
OF
M
F
ARE
DISTINCT
SHOW
THAT
C
F
LOG
N
AHO
ULLMAN
YANNAKAKIS
SHOW
THAT
C
F
O

F
FOR
ANY
GRAPH
G
WITH
N
VERTICES
CONSIDER
THE
FOLLOWING
COMMUNICATION
PROBLEM
PLAYER
RECEIVES
A
CLIQUE
C
IN
G
AND
PLAYER
RECEIVES
AN
INDEPENDENT
SET
I
THEY
HAVE
TO
COM
MUNICATE
IN
ORDER
TO
DETERMINE
C
I
NOTE
THAT
THIS
NUMBER
IS
EITHER
OR
PROVE
AN
O
N
UPPERBOUND
ON
THE
COMMUNICATION
COMPLEXITY
CAN
YOU
IMPROVE
YOUR
UPPERBOUND
OR
PROVE
A
LOWER
BOUND
BETTER
THAN

LOG
N
OPEN
QUESTION
PROVE
LEMMA
USING
THE
HINT
GIVEN
THERE
KARCHMER
WIGDERSON
CONSIDER
THE
FOLLOWING
PROBLEM
ABOUT
COMPUTING
A
RELATION
ASSOCIATE
THE
FOLLOWING
COMMUNICATION
PROBLEM
WITH
ANY
FUNCTION
F
N
PLAYER
GETS
ANY
INPUT
X
SUCH
THAT
F
X
AND
PLAYER
GETS
ANY
INPUT
Y
SUCH
THAT
F
Y
THEY
HAVE
TO
COMMUNICATE
IN
ORDER
TO
DETERMINE
A
BIT
POSITION
I
SUCH
THAT
XI
YI
SHOW
THAT
THE
COMMUNICATION
COMPLEXITY
OF
THIS
PROBLEM
IS
EXACTLY
THE
MINIXMUM
DEPTH
OF
ANY
CIRCUIT
THAT
COMPUTES
F
THE
MAXIMUM
FANIN
OF
EACH
GATE
IS
USE
THE
PREVIOUS
QUESTION
TO
SHOW
THAT
COMPUTING
THE
PARITY
OF
N
BITS
REQUIRES
DEPTH
AT
LEAST
LOG
N
SHOW
THAT
THE
FOLLOWING
COMPUTATIONAL
PROBLEM
IS
IN
EXP
GIVEN
THE
MATRIX
M
F
OF
A
BOOLEAN
FUNCTION
AND
A
NUMBER
K
DECIDE
IF
C
F
K
OPEN
SINCE
YAO
CAN
YOU
SHOW
THIS
PROBLEM
IS
COMPLETE
FOR
SOME
COMPLEXITY
CLASS
DRAFT
WEB
DRAFT
APPLICATIONS
OF
COMMUNICATION
COMPLEXITY
CHAPTER
NOTES
AND
HISTORY
COMMUNICATION
COMPLEXITY
WAS
FIRST
DEFINED
BY
YAO
OTHER
EARLY
PAPERS
THAT
FOUNDED
THE
FIELD
WERE
PAPADIMITRIOU
AND
SIPSER
MEHLHORN
AND
SCHMIDT
WHO
INTRODUCED
THE
RANK
LOWERBOUND
AND
AHO
ULLMAN
AND
YANNAKAKIS
THE
ORIGINAL
LOG
RANK
CONJECTURE
WAS
THAT
C
F
O
RANK
M
F
BUT
THIS
WAS
DISPROVED
BY
RAZ
AND
SPIEKER
THE
BOOK
BY
NISAN
AND
KUSHILEVITZ
IS
HIGHLY
RECOMMENDED
WEB
DRAFT
APPLICATIONS
OF
COMMUNICATION
COMPLEXITY
DRAFT
WEB
DRAFT
CHAPTER
CIRCUIT
LOWERBOUNDS
COMPLEXITY
THEORY
WATERLOO
WE
BELIEVE
THAT
NP
DOES
NOT
HAVE
POLYNOMIAL
SIZED
CIRCUITS
WE
VE
SEEN
THAT
IF
TRUE
THIS
IMPLIES
THAT
NP
P
IN
THE
AND
MANY
RESEARCHERS
CAME
TO
BELIEVE
THAT
THE
ROUTE
TO
RESOLVING
P
VERSUS
NP
SHOULD
GO
VIA
CIRCUIT
LOWERBOUNDS
SINCE
CIRCUITS
SEEM
EASIER
TO
REASON
ABOUT
THAN
TURING
MACHINES
THE
SUCCESS
IN
THIS
ENDEAVOR
WAS
MIXED
PROGRESS
ON
GENERAL
CIRCUITS
HAS
BEEN
ALMOST
NONEXISTENT
A
LOWERBOUND
OF
N
IS
TRIVIAL
FOR
ANY
FUNCTION
THAT
DEPENDS
ON
ALL
ITS
INPUT
BITS
WE
ARE
UNABLE
TO
PROVE
EVEN
A
SUPERLINEAR
CIRCUIT
LOWERBOUND
FOR
ANY
NP
PROBLEM
THE
BEST
WE
CAN
DO
AFTER
YEARS
OF
EFFORT
IS
O
N
TO
MAKE
LIFE
COMPARATIVELY
EASIER
RESEARCHERS
FOCUSSED
ON
RESTRICTED
CIRCUIT
CLASSES
AND
WERE
SUCCESSFUL
IN
PROVING
SOME
DECENT
LOWERBOUNDS
WE
PROVE
SOME
OF
THE
MAJOR
RESULTS
OF
THIS
AREA
AND
INDICATE
WHERE
RESEARCHERS
ARE
CURRENTLY
STUCK
IN
CHAPTER
WE
LL
EXPLAIN
SOME
OF
THE
INHERENT
OBSTACLES
THAT
NEED
TO
BE
OVERCOME
TO
MAKE
FURTHER
PROGRESS
AND
H
ASTAD
SWITCHING
LEMMA
AS
WE
SAW
IN
CHAPTER
IS
THE
CLASS
OF
LANGUAGES
COMPUTABLE
BY
CIRCUIT
FAMILIES
OF
CONSTANT
DEPTH
POLYNOMIAL
SIZE
AND
WHOSE
GATES
HAVE
UNBOUNDED
FANIN
CONSTANT
DEPTH
CIRCUITS
WITH
FANIN
CAN
ONLY
COMPUTE
FUNCTIONS
DEPENDING
ON
A
CONSTANT
NUMBER
OF
INPUT
BITS
THE
BURNING
QUESTION
IN
THE
LATE
WAS
WHETHER
PROBLEMS
LIKE
CLIQUE
AND
TSP
HAVE
CIRCUITS
HOWEVER
IN
FURST
SAXE
AND
SIPSER
AND
INDEPENDENTLY
AJTAI
PROVED
A
LOWERBOUND
FOR
A
MUCH
SIMPLER
FUNCTION
THEOREM
LET
BE
THE
PARITY
FUNCTION
THAT
IS
FOR
EVERY
X
N
XN
N
XI
MOD
OFTEN
COURSES
IN
DIGITAL
LOGIC
DESIGN
TEACH
STUDENTS
HOW
TO
DO
CIRCUIT
MINIMIZATION
USING
KARNAUGH
MAPS
NOTE
THAT
CIRCUITS
TALKED
ABOUT
IN
THOSE
COURSES
ARE
DEPTH
CIRCUITS
I
E
CNF
OR
DNF
INDEED
IT
IS
EASY
TO
SHOW
USING
FOR
EXAMPLE
THE
KARNAUGH
MAP
TECHNIQUE
STUDIED
IN
LOGIC
AND
H
ASTAD
SWITCHING
LEMMA
DESIGN
THAT
THE
PARITY
FUNCTION
REQUIRES
EXPONENTIALLY
MANY
GATES
IF
THE
DEPTH
IS
TWO
HOWEVER
THOSE
SIMPLE
IDEAS
DO
NOT
SEEM
TO
GENERALIZE
TO
EVEN
DEPTH
CIRCUITS
THE
MAIN
TOOL
IN
THE
PROOF
OF
THEOREM
IS
THE
CONCEPT
OF
RANDOM
RESTRICTIONS
LET
F
BE
A
FUNCTION
COMPUTABLE
BY
A
DEPTH
D
CIRCUIT
AND
SUPPOSE
THAT
WE
CHOOSE
AT
RANDOM
A
VAST
MAJORITY
I
E
N
NE
FOR
SOME
CONSTANT
E
DEPENDING
ON
D
OF
THE
INPUT
VARIABLES
AND
ASSIGN
TO
EACH
SUCH
VARIABLE
EITHER
OR
AT
RANDOM
WE
LL
PROVE
THAT
WITH
POSITIVE
PROBABILITY
THE
FUNCTION
F
SUBJECT
TO
THIS
RESTRICTION
IS
CONSTANT
I
E
EITHER
ALWAYS
ZERO
OR
ALWAYS
ONE
SINCE
THE
PARITY
FUNCTION
CANNOT
BE
MADE
A
CONSTANT
BY
FIXING
VALUES
TO
A
SUBSET
OF
THE
VARIABLES
IT
FOLLOWS
THAT
IT
CANNOT
BE
COMPUTED
BY
A
CONSTANT
DEPTH
CIRCUIT
THE
SWITCHING
LEMMA
NOW
WE
PROVE
THE
MAIN
LEMMA
ABOUT
HOW
A
CIRCUIT
SIMPLIFIES
UNDER
A
RANDOM
RESTRICTION
A
K
DNF
RESP
K
CNF
FORMULA
IS
AN
OR
OF
AND
RESP
AND
OR
OR
WHERE
EACH
AND
RESP
OR
INVOLVES
AT
MOST
K
VARIABLES
LEMMA
H
ASTAD
SWITCHING
LEMMA
SUPPOSE
F
IS
EXPRESSIBLE
AS
A
K
DNF
AND
LET

DENOTE
A
RANDOM
RESTRICTION
THAT
ASSIGNS
RANDOM
VALUES
TO
T
RANDOMLY
SELECTED
INPUT
BITS
THEN
FOR
EVERY
N
T
WHERE
F

DENOTES
THE
FUNCTION
F
RESTRICTED
TO
THE
PARTIAL
ASSIGNMENT

WE
LL
TYPICALLY
USE
THIS
LEMMA
WITH
K
CONSTANT
AND
T
N
N
IN
WHICH
CASE
THE
GUARANTEED
BOUND
ON
THE
PROBABILITY
WILL
BE
N
C
FOR
SOME
CONSTANT
C
NOTE
THAT
BY
APPLYING
THE
LEMMA
TO
THE
FUNCTION
F
WE
CAN
GET
THE
SAME
RESULT
WITH
THE
TERMS
DNF
AND
CNF
INTERCHANGED
PROVING
THEOREM
FROM
LEMMA
NOW
WE
SHOW
HOW
H
ASTAD
LEMMA
IMPLIES
THAT
PARITY
IS
NOT
IN
WE
START
WITH
ANY
CIRCUIT
AND
ASSUME
THAT
THE
CIRCUIT
HAS
BEEN
SIMPLIFIED
AS
FOLLOWS
THE
SIMPLIFICATIONS
ARE
STRAIGHTFORWARD
TO
DO
AND
ARE
LEFT
AS
EXERCISES
AND
A
ALL
FANOUTS
ARE
THE
CIRCUIT
IS
A
TREE
B
ALL
NOT
GATES
TO
THE
INPUT
LEVEL
OF
THE
CIRCUIT
EQUIVALENTLY
THE
CIRCUIT
HAS
INPUT
WIRES
WITH
THE
LAST
N
OF
THEM
BEING
THE
NEGATIONS
OF
THE
FIRST
N
C
AND
GATES
ALTERNATE
AT
WORST
THIS
ASSUMPTION
DOUBLES
THE
DEPTH
OF
THE
CIRCUIT
D
THE
BOTTOM
LEVEL
HAS
GATES
OF
FANIN
WE
RANDOMLY
RESTRICT
MORE
AND
MORE
VARIABLES
WHERE
EACH
STEP
WITH
HIGH
PROBABILITY
WILL
REDUCE
THE
DEPTH
OF
THE
CIRCUIT
BY
AND
WILL
KEEP
THE
BOTTOM
LEVEL
AT
A
CONSTANT
FANIN
SPECIFICALLY
LETTING
NI
STAND
FOR
THE
NUMBER
OF
UNRESTRICTED
VARIABLES
AFTER
STEP
I
WE
RESTRICT
NI
NI
VARIABLES
AT
STEP
I
I
SINCE
N
WE
HAVE
NI
LET
NB
DENOTE
AN
UPPER
BOUND
ON
THE
NUMBER
OF
GATES
IN
THE
CIRCUIT
AND
LET
KI
WE
LL
SHOW
THAT
WITH
HIGH
PROBABILITY
AFTER
THE
ITH
RESTRICTION
WE
RE
LEFT
WITH
A
DEPTH
D
I
CIRCUIT
WITH
AT
MOST
KI
FANIN
IN
THE
BOTTOM
LEVEL
INDEED
SUPPOSE
THAT
THE
BOTTOM
LEVEL
CONTAINS
GATES
AND
THE
LEVEL
ABOVE
IT
CONTAINS
GATES
THE
FUNCTION
EACH
SUCH
GATE
COMPUTES
IS
A
K
DNF
AND
HENCE
BY
LEMMA
WITH
PROBABILITY
KI
WHICH
DRAFT
WEB
DRAFT
AND
H
ASTAD
SWITCHING
LEMMA
IS
AT
LEAST
FOR
LARGE
ENOUGH
N
THE
FUNCTION
SUCH
A
GATE
COMPUTES
WILL
BE
EXPRESSIBLE
AS
A
KI
CNF
WE
CAN
THEN
MERGE
THIS
CNF
WITH
THE
GATE
ABOVE
IT
REDUCING
THE
DEPTH
OF
THE
CIRCUIT
BY
ONE
SEE
FIGURES
AND
THE
SYMMETRIC
REASONING
APPLIES
IN
THE
CASE
THE
BOTTOM
LEVEL
CONSISTS
OF
GATES
IN
THIS
CASE
WE
USE
THE
LEMMA
TO
TRANSFORM
THE
KI
CNF
OF
THE
LEVEL
ABOVE
IT
INTO
A
KI
DNF
NOTE
THAT
WE
APPLY
THE
LEMMA
AT
MOST
ONCE
PER
EACH
OF
THE
AT
MOST
NB
GATES
OF
THE
ORIGINAL
CIRCUIT
BY
THE
UNION
BOUND
WITH
PROBABILITY
IF
WE
CONTINUE
THIS
PROCESS
FOR
D
STEPS
WE
LL
GET
A
DEPTH
TWO
CIRCUIT
WITH
FANIN
K
KD
AT
BOTTOM
LEVEL
I
E
A
K
CNF
OR
K
DNF
FORMULA
IF
WE
THEN
CHOOSE
TO
RESTRICT
EACH
VARIABLE
WITH
PROBABILITY
HALF
I
E
RESTRICT
ABOUT
HALF
OF
THE
VARIABLES
TO
A
RANDOM
VALUE
THIS
CIRCUIT
WILL
BE
REDUCED
TO
A
CONSTANT
FUNCTION
WITH
PROBABILITY
AT
LEAST
K
SINCE
THE
PARITY
FUNCTION
IS
NOT
CONSTANT
UNDER
ANY
RESTRICTION
OF
LESS
THAN
N
VARIABLES
THIS
PROVES
THEOREM
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
CIRCUIT
BEFORE
H
ASTAD
SWITCHING
TRANSFORMATION
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
CIRCUIT
AFTER
H
ASTAD
SWITCHING
TRANSFORMATION
NOTICE
THAT
THE
NEW
LAYER
OF
GATES
CAN
BE
COLLAPSED
WITH
THE
SINGLE
PARENT
GATE
TO
REDUCE
THE
NUMBER
OF
LEVELS
BY
ONE
PROOF
OF
THE
SWITCHING
LEMMA
LEMMA
NOW
WE
PROVE
THE
SWITCHING
LEMMA
THE
ORIGINAL
PROOF
WAS
MORE
COMPLICATED
THIS
ONE
IS
DUE
TO
RAZBOROV
LET
F
BE
EXPRESSIBLE
AS
A
K
DNF
ON
N
VARIABLES
LET
T
BE
AS
IN
THE
LEMMA
AND
LET
DENOTE
THE
SET
OF
ALL
RESTRICTIONS
TO
VARIABLES
NOTE
WE
CAN
ASSUME
WE
HAVE
THAT
RT
N
LET
KT
DENOTE
THE
SET
OF
RESTRICTIONS

SUCH
THAT
F

IS
NOT
A
CNF
WE
NEED
TO
BOUND
KT
RT
BY
THE
RIGHT
HAND
SIDE
OF
TO
PROVE
THE
LEMMA
WE
LL
DO
THAT
BY
SHOWING
A
ONE
TO
ONE
FUNCTION
MAPPING
KT
INTO
THE
SET
Z
WHERE
Z
IS
THE
SET
OF
RESTRICTIONS
OF
AT
LEAST
T
VARIABLES
I
E
Z
T
T
SRT
AND
IS
SOME
SET
OF
SIZE
THIS
WILL
PROVE
THE
LEMMA
SINCE
AT
HE
RANGE
TI
N
N
N
AND
HENCE
Z
WILL
BE
OF
SIZE
BOUNDED
BY
ROUGHLY
N
T
R
WE
LEAVE
VERIFYING
THE
EXACT
BOUND
AS
EXERCISE
MAPPING
KT
INTO
Z
LET

KT
BE
A
RESTRICTION
FIXING
T
VARIABLES
SUCH
THAT
F

IS
NOT
AN
CNF
WE
NEED
TO
MAP

IN
A
ONE
TO
ONE
WAY
INTO
SOME
RESTRICTION

OF
AT
LEAST
T
VARIABLES
AND
SOME
ADDITIONAL
ELEMENT
IN
A
SET
OF
SIZE
AT
MOST
SPECIAL
CASE
EACH
TERM
HAS
AT
MOST
ONE
LIVE
VARIABLE
TO
GET
SOME
INTUITION
FOR
THE
PROOF
CONSIDER
FIRST
THE
CASE
THAT
FOR
EACH
TERM
T
IN
THE
K
DNF
FORMULA
FOR
F

EITHER
FIXED
T
TO
THE
VALUE
OR
LEFT
A
SINGLE
UNASSIGNED
VARIABLE
IN
T
IN
WHICH
CASE
WE
SAY
THAT
TIS
VALUE
IS

CAN
T
FIX
A
TERM
TO
THE
VALUE
SINCE
WE
ASSUME
F

IS
NOT
CONSTANT
WE
DENOTE
BY
XS
DENOTE
THE
WEB
DRAFT
AND
H
ASTAD
SWITCHING
LEMMA
FIRST
SUCH
UNASSIGNED
VARIABLES
ACCORDING
TO
SOME
CANONICAL
ORDERING
OF
THE
TERMS
FOR
THE
K
DNF
FORMULA
OF
F
THERE
ARE
MORE
THAN
SINCE
OTHERWISE
F

WOULD
BE
EXPRESSIBLE
AS
AN
CNF
FOR
EACH
SUCH
VARIABLE
XI
LET
TERMI
BE
THE
VALUED
TERM
IN
WHICH
XI
APPEARS
LET
RI
BE
THE
OPERATION
OF
SETTING
XI
TO
THE
VALUE
THAT
ENSURES
TERMI
IS
TRUE
WE
LL
MAP

TO
RS
THAT
IS
APPLY
RS
TO

THEN
APPLY
RK
TO

THEN
APPLY
TO

THE
CRUCIAL
INSIGHT
IS
THAT
GIVEN
ONE
CAN
DEDUCE
THIS
IS
THE
FIRST
TERM
THAT
IS
TRUE
IN
F
ONE
MIGHT
THINK
THAT
THE
SECOND
TERM
THAT
IS
TRUE
IN
F
IS
BUT
THAT
NOT
NECESSARILY
THE
CASE
SINCE
THE
VARIABLE
MAY
HAVE
APPEARED
SEVERAL
TIMES
AND
SO
SETTING
IT
TO
MAY
HAVE
SET
OTHER
TERMS
TO
TRUE
IT
COULD
NOT
HAVE
SET
OTHER
TERMS
TO
FALSE
SINCE
THIS
WOULD
IMPLY
THAT
F

INCLUDES
AN
OR
OF
XI
AND
XI
AND
HENCE
IS
THE
CONSTANT
ONE
FUNCTION
WE
THUS
SUPPLY
AS
PART
OF
THE
MAPPING
A
STRING
THAT
TELLS
US
THE
ASSIGNMENT
OF
THE
K
VARIABLES
OF
IN
RS
GIVEN
THAT
INFORMATION
WE
CAN
UNDO
AND
MOVE
FROM
TO
NOW
IN
IS
THE
FIRST
SATISFIED
TERM
CONTINUING
ON
THIS
WAY
WE
SEE
THAT
FROM
WHICH
IS
AN
ASSIGNMENT
OF
AT
LEAST
T
VARIABLES
AND
STRINGS
WS
THAT
ARE
DEFINED
AS
ABOVE
WE
CAN
RECOVER

IMPLYING
THAT
WE
HAVE
A
ONE
TO
ONE
MAPPING
THAT
TAKES

INTO
AN
ASSIGNMENT
OF
AT
LEAST
T
VARIABLES
AND
A
SEQUENCE
IN
KS
THE
GENERAL
CASE
WE
NOW
CONSIDER
THE
GENERAL
CASE
WHERE
SOME
TERMS
MIGHT
HAVE
MORE
THAN
ONE
UNASSIGNED
VARIABLE
IN
THEM
WE
LET
BE
THE
FIRST
VALUED
TERM
IN
F

AND
LET
BE
THE
FIRST
UNASSIGNED
VARIABLE
IN
ONCE
AGAIN
WE
HAVE
AN
OPERATION
THAT
WILL
MAKE
TRUE
ALTHOUGH
THIS
TIME
WE
THINK
OF
AS
ASSIGNING
TO
ALL
THE
K
VARIABLES
IN
THE
UNIQUE
VALUE
THAT
MAKES
THE
TERM
TRUE
WE
ALSO
HAVE
AN
OPERATION
ASSIGNING
A
VALUE
TO
SUCH
THAT
F
CANNOT
BE
EXPRESSED
BY
AN
CNF
INDEED
IF
FOR
BOTH
POSSIBLE
ASSIGNMENTS
TO
WE
GET
AN
CNF
THEN
F

IS
AN
CNF
WE
NOTE
THAT
IT
NOT
NECESSARILY
THE
CASE
THAT
VALUE
UNDER
IS
DIFFERENT
FROM
ITS
VALUE
UNDER
BUT
IT
IS
THE
CASE
THAT
VALUE
IS
EITHER
OR
FALSE
UNDER
SINCE
OTHERWISE
F
WOULD
BE
CONSTANT
WE
LET
BE
THE
FIRST
VALUED
TERM
IN
F
NOTE
THAT
AND
LET
BE
THE
FIRST
UNASSIGNED
VARIABLE
IN
ONCE
AGAIN
WE
HAVE
AN
OPERATION
SUCH
THAT
IS
THE
FIRST
TRUE
TERM
IN
F
AND
OPERATION
SUCH
THAT
F
IS
NOT
A
CNF
CONTINUING
IN
THIS
WAY
WE
COME
UP
WITH
OPERATIONS
LS
RS
SUCH
THAT
IF
WE
LET
I
BE
THE
ASSIGNMENT
LI
WITH

THEN
FOR
I
TERMI
IS
THE
FIRST
VALUED
TERM
IN
F
I
TERMI
IS
THE
FIRST
TRUE
VALUED
TERM
IN
F
RII
LI
AGREES
WITH
I
ON
ALL
VARIABLES
ASSIGNED
A
VALUE
BY
I
RI
AGREES
WITH
I
ON
ALL
VARIABLES
ASSIGNED
A
VALUE
BY
I
FOR
I
DEFINE
I
TO
BE
RIRI
RSS
AND
DEFINE
S
S
WE
HAVE
THAT
TERMI
IS
THE
FIRST
TRUE
TERM
IN
F
I
INDEED
ALL
THE
OPERATIONS
IN
I
DO
NOT
CHANGE
VARIABLES
ASSIGNED
VALUES
BY
I
AND
THERE
TERMI
IS
THE
FIRST
VALUED
TERM
THUS
I
CANNOT
MAKE
ANY
EARLIER
TERM
TRUE
HOWEVER
SINCE
THE
LAST
OPERATION
APPLIED
IS
RI
TERMI
IS
TRUE
IN
F
I
LET
ZS
AND
WS
BE
STRINGS
IN
DEFINED
AS
FOLLOWS
ZI
DESCRIBES
THE
VALUES
ASSIGNED
TO
THE
K
VARIABLES
APPEARING
IN
TERMI
BY
I
AND
WI
DESCRIBES
THE
VALUE
ASSIGNED
TO
TERMI
VARIABLES
BY
I
CLEARLY
FROM
TERMI
ZI
AND
THE
ASSIGNMENT
I
ONE
CAN
COMPUTE
I
AND
DRAFT
WEB
DRAFT
CIRCUITS
WITH
COUNTERS
ACC
FROM
TERMI
WI
AND
THE
ASSIGNMENT
I
ONE
CAN
COMPUTE
I
WE
LL
MAP

TO
AND
THE
SEQUENCE
ZS
WS
NOTE
THAT
DOES
ASSIGN
VALUES
TO
AT
LEAST
VARIABLES
NOT
ASSIGNED
BY

AND
THAT
FROM
WE
CAN
FIND
AS
THIS
IS
THE
FIRST
TRUE
TERM
IN
F
AND
THEN
USING
RECOVER
AND
CONTINUE
IN
THIS
WAY
UNTIL
WE
RECOVER
THE
ORIGINAL
ASSIGNMENT

THUS
THIS
MAPPING
IS
A
ONE
TO
ONE
MAP
FROM
TT
TO
Z
CIRCUITS
WITH
COUNTERS
ACC
ONE
WAY
TO
EXTEND
THE
LOWERBOUNDS
OF
THE
PREVIOUS
SECTION
WAS
TO
DEFINE
A
MORE
GENERAL
CLASS
OF
CIRCUITS
WHAT
IF
WE
ALLOW
MORE
GENERAL
GATES
THE
SIMPLEST
EXAMPLE
IS
A
PARITY
GATE
CLEARLY
AN
CIRCUIT
PROVIDED
WITH
PARITY
GATES
CAN
CAN
COMPUTE
THE
PARITY
FUNCTION
BUT
ARE
THERE
STILL
OTHER
FUNCTIONS
THAT
IT
CANNOT
COMPUTE
RAZBOROV
PROVED
THE
FIRST
SUCH
LOWERBOUND
USING
HIS
METHOD
OF
APPROXIMATIONS
SMOLENSKY
LATER
EXTENDED
THIS
WORK
AND
CLARIFIED
THIS
METHOD
FOR
THE
CIRCUIT
CLASS
CONSIDERED
HERE
NORMALLY
WE
THINK
OF
A
MODULAR
COMPUTATION
AS
WORKING
WITH
NUMBERS
RATHER
THAN
BIT
BUT
IT
IS
SUFFICIENT
TO
CONSIDER
MODULAR
GATES
WHOSE
OUTPUT
IS
ALWAYS
DEFINITION
MODULAR
GATES
FOR
ANY
INTEGER
M
THE
M
ODM
GATE
OUTPUTS
IF
THE
SUM
OF
ITS
INPUTS
IS
MODULO
M
AND
OTHERWISE
DEFINITION
ACC
FOR
INTEGERS
MK
WE
SAY
A
LANGUAGE
L
IS
IN
MK
IF
THERE
EXISTS
A
CIRCUIT
FAMILY
CN
WITH
CONSTANT
DEPTH
AND
POLYNOMIAL
SIZE
AND
UNBOUNDED
FAN
IN
CONSISTING
OF
AND
M
M
ODMK
GATES
ACCEPTING
L
THE
CLASS
CONTAINS
EVERY
LANGUAGE
THAT
IS
IN
MK
FOR
SOME
K
AND
MK
GOOD
LOWERBOUNDS
ARE
KNOWN
ONLY
WHEN
THE
CIRCUIT
HAS
ONE
KIND
OF
MODULAR
GATE
THEOREM
RAZBOROV
SMOLENSKY
FOR
DISTINCT
PRIMES
P
AND
Q
THE
FUNCTION
M
ODP
IS
NOT
IN
Q
WE
EXHIBIT
THE
MAIN
IDEA
OF
THIS
RESULT
BY
PROVING
THAT
THE
PARITY
FUNCTION
CANNOT
BE
COMPUTED
BY
AN
CIRCUIT
PROOF
THE
PROOF
PROCEEDS
IN
TWO
STEPS
STEP
IN
THE
FIRST
STEP
WE
SHOW
USING
INDUCTION
ON
H
THAT
FOR
ANY
DEPTH
H
M
CIRCUIT
ON
N
INPUTS
AND
SIZE
THERE
IS
A
POLYNOMIAL
OF
DEGREE
H
WHICH
AGREES
WITH
THE
CIRCUIT
ON
FRACTION
OF
THE
INPUTS
IF
OUR
CIRCUIT
C
HAS
DEPTH
D
THEN
WE
SET
TO
OBTAIN
A
DEGREE
N
POLYNOMIAL
THAT
AGREES
WITH
C
ON
FRACTION
OF
INPUTS
STEP
WE
SHOW
THAT
NO
POLYNOMIAL
OF
DEGREE
N
AGREES
WITH
M
ON
MORE
THAN
FRACTION
OF
INPUTS
WEB
DRAFT
CIRCUITS
WITH
COUNTERS
ACC
TOGETHER
THE
TWO
STEPS
IMPLY
THAT
FOR
ANY
DEPTH
D
CIRCUIT
COMPUTING
M
OD
THUS
PROVING
THE
THEOREM
NOW
WE
GIVE
DETAILS
STEP
CONSIDER
A
NODE
G
IN
THE
CIRCUIT
AT
A
DEPTH
H
THE
INPUT
IS
ASSUMED
TO
HAVE
DEPTH
IF
G
XN
IS
THE
FUNCTION
COMPUTED
AT
THIS
NODE
WE
DESIRE
A
POLYNOMIAL
G
XN
OVER
GF
WITH
DEGREE
H
SUCH
THAT
G
XN
G
XN
FOR
MOST
XN
WE
WILL
ALSO
ENSURE
THAT
ON
EVERY
INPUT
IN
N
GF
POLYNOMIAL
G
TAKES
A
VALUE
IN
THIS
IS
WITHOUT
LOSS
OF
GENERALITY
SINCE
WE
CAN
JUST
SQUARE
THE
POLYNOMIAL
RECALL
THAT
THE
ELEMENTS
OF
GF
ARE
AND
AND
WE
CONSTRUCT
THE
APPROXIMATOR
POLYNOMIAL
BY
INDUCTION
WHEN
H
THE
GATE
IS
AN
INPUT
WIRE
XI
WHICH
IS
EXACTLY
REPRESENTED
BY
THE
DEGREE
POLYNOMIAL
XI
SUPPOSE
WE
HAVE
CONSTRUCTED
APPROXIMATORS
FOR
ALL
NODES
UP
TO
HEIGHT
H
AND
G
IS
A
GATE
AT
HEIGHT
H
IF
G
IS
A
NOT
GATE
THEN
G
FOR
SOME
OTHER
GATE
THAT
IS
AT
HEIGHT
H
OR
LESS
THE
INDUCTIVE
HYPOTHESIS
GIVES
AN
APPROXIMATOR
F
FOR
THEN
WE
USE
G
F
AS
THE
APPROXIMATOR
POLYNOMIAL
FOR
G
THIS
HAS
THE
SAME
DEGREE
AS
F
WHENEVER
F
THEN
G
G
SO
WE
INTRODUCED
NO
NEW
ERROR
IF
G
IS
A
M
GATE
WITH
INPUTS
FK
WE
USE
THE
APPROXIMATION
G
K
F
I
THE
DEGREE
INCREASES
TO
AT
MOST
H
H
SINCE
AND
WE
INTRODUCED
NO
NEW
ERROR
IF
G
IS
AN
AND
OR
AN
OR
GATE
WE
NEED
TO
BE
MORE
CAREFUL
SUPPOSE
G
K
FI
THE
NAIVE
APPROACH
WOULD
BE
TO
REPLACE
G
WITH
THE
POLYNOMIAL
I
IF
I
FOR
AN
OR
GATE
G
K
FI
DE
MORGAN
LAW
GIVES
A
SIMILAR
NAIVE
APPROXIMATOR
TL
I
THESE
MULTIPLY
THE
DEGREE
BY
K
THE
FANIN
OF
THE
GATE
WHICH
COULD
GREATLY
EXCEED
THE
CORRECT
SOLUTION
INVOLVES
INTRODUCING
SOME
ERROR
WE
GIVE
THE
SOLUTION
FOR
OR
DE
MOR
GAN
LAW
ALLOWS
AND
GATES
TO
BE
HANDLED
SIMILARLY
IF
G
K
FI
THEN
G
IF
AND
ONLY
IF
AT
LEAST
ONE
OF
THE
FI
FURTHERMORE
BY
THE
RANDOM
SUBSUM
PRINCIPLE
SEE
SECTION
IN
APPENDIX
A
IF
ANY
OF
THE
FI
THEN
THE
SUM
OVER
GF
OF
A
RANDOM
SUBSET
OF
FI
IS
NONZERO
WITH
PROBABILITY
AT
LEAST
RANDOMLY
PICK
L
SUBSETS
SL
OF
K
COMPUTE
THE
L
POLYNOMIALS
J
SI
FJ
EACH
OF
WHICH
HAS
DEGREE
AT
MOST
TWICE
THAT
OF
THE
LARGEST
INPUT
POLYNOMIAL
COMPUTE
THE
OR
OF
THESE
L
TERMS
USING
THE
NAIVE
APPROACH
WE
GET
A
POLYNOMIAL
OF
DEGREE
AT
MOST
H
H
FOR
ANY
X
THE
PROBABILITY
OVER
THE
CHOICE
OF
SUBSETS
THAT
THIS
POLYNOMIAL
DIFFERS
FROM
OR
F
F
K
IS
AT
MOST
SO
BY
THE
PROBABILISTIC
METHOD
THERE
EXISTS
A
CHOICE
FOR
THE
L
SUBSETS
SUCH
THAT
THE
PROBABILITY
OVER
THE
CHOICE
OF
X
THAT
THIS
POLYNOMIAL
DIFFERS
FROM
OR
F
F
K
IS
AT
MOST
WE
USE
THIS
CHOICE
OF
THE
SUBSETS
TO
CONSTRUCT
THE
APPROXIMATOR
APPLYING
THE
ABOVE
PROCEDURE
FOR
EACH
GATE
GIVES
AN
APPROXIMATOR
FOR
THE
OUTPUT
GATE
OF
DEGREE
D
WHERE
D
IS
DEPTH
OF
THE
ENTIRE
CIRCUIT
EACH
OPERATION
OF
REPLACING
THE
GATE
BY
ITS
APPROXIMATOR
POLYNOMIAL
INTRODUCES
ERROR
ON
AT
MOST
FRACTION
OF
ALL
INPUTS
SO
THE
OVERALL
FRACTION
OF
ERRONEOUS
INPUTS
FOR
THE
APPROXIMATOR
IS
AT
MOST
NOTE
THAT
ERRORS
AT
DIFFERENT
GATES
MAY
AFFECT
EACH
OTHER
ERROR
INTRODUCED
AT
ONE
GATE
MAY
BE
CANCELLED
OUT
BY
ERRORS
AT
ANOTHER
GATE
HIGHER
UP
WE
DRAFT
WEB
DRAFT
CIRCUITS
WITH
COUNTERS
ACC
ARE
BEING
PESSIMISTIC
IN
APPLYING
THE
UNION
BOUND
TO
UPPERBOUND
THE
PROBABILITY
THAT
ANY
OF
THE
APPROXIMATOR
POLYNOMIALS
ANYWHERE
IN
THE
CIRCUIT
MISCOMPUTES
STEP
SUPPOSE
THAT
A
POLYNOMIAL
F
AGREES
WITH
THE
M
FUNCTION
FOR
ALL
INPUTS
IN
A
SET
GI
IF
THE
DEGREE
OF
F
IS
BOUNDED
BY
N
THEN
WE
SHOW
GI
CONSIDER
THE
CHANGE
OF
VARIABLES
YI
XI
MOD
THUS
AND
THEN
GI
BECOMES
SOME
SUBSET
OF
N
AND
BECOMES
SOME
OTHER
POLYNOMIAL
SAY
WHICH
STILL
HAS
DEGREE
N
MOREOVER
M
XN
N
I
N
I
YI
YI
THUS
G
YN
A
DEGREE
N
POLYNOMIAL
AGREES
WITH
N
YI
ON
G
THIS
IS
DECIDEDLY
ODD
AND
WE
SHOW
THAT
ANY
SUCH
G
MUST
BE
SMALL
SPECIFICALLY
LET
FG
BE
THE
SET
OF
ALL
FUNCTIONS
G
CLEARLY
FG
G
AND
WE
WILL
SHOW
FG
WHENCE
STEP
FOLLOWS
LEMMA
FOR
EVERY
FG
THERE
EXISTS
A
POLYNOMIAL
GS
WHICH
IS
A
SUM
OF
MONOMIALS
AI
TLI
I
YI
WHERE
PROOF
LET
S
GF
N
GF
BE
ANY
FUNCTION
WHICH
AGREES
WITH
ON
G
THEN
S
CAN
BE
WRITTEN
AS
A
POLYNOMIAL
IN
THE
VARIABLES
YI
HOWEVER
WE
ARE
ONLY
INTERESTED
IN
ITS
VALUES
ON
YN
N
WHEN
AND
SO
EVERY
MONOMIAL
I
IYRI
HAS
WITHOUT
LOSS
OF
GENERALITY
RI
THUS
S
IS
A
POLYNOMIAL
OF
DEGREE
AT
MOST
N
NOW
CONSIDER
ANY
OF
ITS
MONOMIAL
TERMS
I
IYI
OF
DEGREE
I
N
WE
CAN
REWRITE
IT
AS
I
IYI
N
YI
I
I
YI
WHICH
TAKES
THE
SAME
VALUES
AS
G
YN
I
I
YI
OVER
N
THUS
EVERY
MONOMIAL
IN
S
TO
CONCLUDE
WE
BOUND
THE
NUMBER
OF
POLYNOMIALS
WHOSE
EVERY
MONOMIAL
WITH
A
DEGREE
AT
MOST
N
N
CLEARLY
THIS
NUMBER
IS
POLYNOMIALS
MONOMIALS
AND
MONOMIALS
N
N
N
N
N
I
I
N
USING
KNOWLEDGE
OF
THE
TAILS
OF
A
BINOMIAL
DISTRIBUTION
OR
ALTERNATIVELY
DIRECT
CALCULATION
N
WEB
DRAFT
LOWERBOUNDS
FOR
MONOTONE
CIRCUITS
LOWERBOUNDS
FOR
MONOTONE
CIRCUITS
A
BOOLEAN
CIRCUIT
IS
MONOTONE
IF
IT
CONTAINS
ONLY
AND
AND
OR
GATES
AND
NO
NOT
GATES
SUCH
A
CIRCUIT
CAN
ONLY
COMPUTE
MONOTONE
FUNCTIONS
DEFINED
AS
FOLLOWS
DEFINITION
FOR
X
Y
N
WE
DENOTE
X
Y
IF
EVERY
BIT
THAT
IS
IN
X
IS
ALSO
IN
Y
A
FUNCTION
F
N
IS
MONOTONE
IF
F
X
F
Y
FOR
EVERY
X
Y
REMARK
AN
ALTERNATIVE
CHARACTERIZATION
IS
THAT
F
IS
MONOTONE
IF
FOR
EVERY
INPUT
X
CHANGING
A
BIT
IN
X
FROM
TO
CANNOT
CHANGE
THE
VALUE
OF
THE
FUNCTION
FROM
TO
IT
IS
EASY
TO
CHECK
THAT
EVERY
MONOTONE
CIRCUIT
COMPUTES
A
MONOTONE
FUNCTION
AND
EVERY
MONO
TONE
FUNCTION
CAN
BE
COMPUTED
BY
A
SUFFICIENTLY
LARGE
MONOTONE
CIRCUIT
CLIQUE
IS
A
MONOTONE
FUNCTION
SINCE
ADDING
AN
EDGE
TO
THE
GRAPH
CANNOT
DESTROY
ANY
CLIQUE
THAT
EXISTED
IN
IT
IN
THIS
SECTION
WE
SHOW
THAT
THE
CLIQUE
FUNCTION
CAN
NOT
BE
COMPUTED
BY
POLYNOMIAL
AND
IN
FACT
EVEN
SUBEXPONENTIAL
SIZED
MONOTONE
CIRCUITS
THEOREM
DENOTE
BY
CLIQUE
K
N
N
BE
THE
FUNCTION
THAT
ON
INPUT
AN
ADJACENCY
MATRIX
OF
AN
N
VERTEX
GRAPH
G
OUTPUTS
IFF
G
CONTAINS
A
K
VERTEX
CLIQUE
THERE
EXISTS
SOME
CONSTANT
E
SUCH
THAT
FOR
EVERY
K
THERE
NO
MONOTONE
CIRCUIT
OF
SIZE
LESS
THAN
K
THAT
COMPUTES
CLIQUEK
N
WE
BELIEVE
CLIQUE
DOES
NOT
HAVE
POLYNOMIAL
SIZE
CIRCUITS
EVEN
ALLOWING
NOT
GATES
I
E
THAT
NP
R
P
POLY
IN
FACT
A
SEEMINGLY
PLAUSIBLE
APPROACH
TO
PROVING
THIS
MIGHT
BE
TO
SHOW
THAT
FOR
EVERY
MONOTONE
FUNCTION
F
THE
MONOTONE
CIRCUIT
COMPLEXITY
OF
F
IS
POLYNOMIALLY
RELATED
TO
THE
GENERAL
NON
MONOTONE
CIRCUIT
COMPLEXITY
ALAS
THIS
CONJECTURE
WAS
REFUTED
BY
RAZBOROV
SEE
ALSO
PROVING
THEOREM
CLIQUE
INDICATORS
TO
GET
SOME
INTUITION
WHY
THIS
THEOREM
MIGHT
BE
TRUE
LETS
SHOW
THAT
CLIQUEK
N
CAN
T
BE
COMPUTED
OR
EVEN
APPROXIMATED
BY
SUBEXPONENTIAL
MONOTONE
CIRCUITS
OF
A
VERY
SPECIAL
FORM
FOR
EVERY
N
LET
CS
DENOTE
THE
FUNCTION
ON
THAT
OUTPUTS
ON
A
GRAPH
G
IFF
THE
SET
IS
A
CLIQUE
N
IN
G
WE
CALL
CS
THE
CLIQUE
INDICATOR
OF
NOTE
THAT
CLIQUEK
N
CS
WE
LL
NOW
PROVE
THAT
CLIQUEK
N
CAN
T
BE
COMPUTED
BY
AN
OR
OF
LESS
THAN
N
K
CLIQUE
INDICATORS
LET
Y
BE
THE
FOLLOWING
DISTRIBUTION
ON
N
VERTEX
GRAPHS
CHOOSE
A
SET
K
N
WITH
K
K
AT
RANDOM
AND
OUTPUT
THE
GRAPH
THAT
HAS
A
CLIQUE
ON
K
AND
NO
OTHER
EDGES
LET
N
BE
THE
FOLLOWING
DISTRIBUTION
ON
N
VERTEX
GRAPHS
CHOOSE
A
FUNCTION
C
N
K
AT
RANDOM
AND
PLACE
AN
EDGE
BETWEEN
U
AND
V
IFF
C
U
C
V
WITH
PROBABILITY
ONE
CLIQUEN
K
Y
AND
CLIQUEN
K
N
THE
FACT
THAT
CLIQUEN
K
REQUIRES
AN
OR
OF
AT
LEAST
N
CLIQUE
INDICATORS
FOLLOWS
IMMEDIATELY
FROM
THE
FOLLOWING
LEMMA
DRAFT
WEB
DRAFT
LOWERBOUNDS
FOR
MONOTONE
CIRCUITS
LEMMA
LET
N
BE
SUFFICIENTLY
LARGE
K
AND
N
THEN
EITHER
PR
CS
N
OR
PR
CS
Y
N
K
PROOF
LET
K
IF
THEN
BY
THE
BIRTHDAY
BOUND
WE
EXPECT
A
RANDOM
F
K
TO
HAVE
LESS
THAN
COLLISIONS
AND
HENCE
BY
MARKOV
THE
PROBABILITY
F
IS
ONE
TO
ONE
IS
AT
LEAST
THIS
IMPLIES
THAT
PR
CS
N
IF
THEN
PR
CS
Y
IS
EQUAL
TO
THE
PROBABILITY
THAT
K
FOR
A
RANDOM
K
N
OF
SIZE
K
THIS
PROBABILITY
IS
EQUAL
TO
N
C
N
WHICH
IS
AT
MOST
N
N
WHICH
BY
THE
FORMULA
FOR
THE
BINOMIAL
COEFFICIENTS
IS
LESS
THAN
K
C
N
C
N
K
FOR
SUFFICIENTLY
LARGE
N
APPROXIMATION
BY
CLIQUE
INDICATORS
TOGETHER
WITH
LEMMA
THE
FOLLOWING
LEMMA
IMPLIES
THEOREM
LEMMA
LET
C
BE
A
MONOTONE
CIRCUIT
OF
SIZE
LET
M
N
K
SUCH
THAT
K
THEN
THERE
EXIST
SETS
SM
WITH
PRG
RY
CSI
G
C
G
PRG
RN
CSI
G
C
G
I
PROOF
SET
K
P
K
LOG
N
AND
M
P
C
NOTE
THAT
M
N
K
WE
CAN
THINK
OF
THE
CIRCUIT
C
AS
THE
SEQUENCE
OF
MONOTONE
FUNCTIONS
F
F
FROM
N
TO
WHERE
EACH
FUNCTION
FK
IS
EITHER
THE
AND
OR
OR
OF
TWO
FUNCTIONS
FK
FK
FOR
KI
KII
K
OR
IS
THE
VALUE
OF
AN
INPUT
VARIABLE
XU
V
FOR
U
V
N
I
E
FK
C
U
V
THE
FUNCTION
THAT
C
COMPUTES
IS
FS
WE
LL
SHOW
A
SEQUENCE
OF
FUNCTIONS
F
SUCH
THAT
EACH
FUNCTION
F
K
IS
AN
OR
OF
AT
MOST
M
CLIQUE
INDICATORS
CS
CS
WITH
SI
AND
F
K
APPROXIMATES
FK
IN
THE
SENSE
OF
AND
WE
CALL
A
FUNCTION
F
K
SATISFYING
AN
M
FUNCTION
THE
RESULT
WILL
FOLLOW
BY
CONSIDERING
THE
FUNCTION
F
WE
CONSTRUCT
THE
FUNCTIONS
F
F
BY
INDUCTION
FOR
K
IF
FK
IS
AN
INPUT
VARIABLE
THEN
WE
LET
F
K
FK
IF
FK
FK
FK
THEN
WE
LET
F
K
LJ
F
K
AND
IF
FK
FK
FK
THEN
WE
LET
F
K
N
F
K
WHERE
THE
OPERATIONS
LJ
N
WILL
BE
DEFINED
BELOW
WE
LL
PROVE
THAT
FOR
EVERY
F
G
N
A
IF
F
AND
G
ARE
M
FUNCTIONS
THEN
SO
IS
F
LJ
G
RESP
F
N
G
AND
B
PRG
RY
F
LJG
G
F
G
G
RESP
PRG
RY
F
G
G
F
G
G
AND
PRG
RN
F
G
G
F
G
G
RESP
PRG
F
G
G
F
G
G
THE
LEMMA
WILL
THEN
FOLLOW
BY
SHOWING
USING
THE
UNION
BOUND
THAT
WITH
PROBABILITY
THE
EQUATIONS
OF
CONDITION
B
HOLD
FOR
ALL
F
F
WE
LL
NOW
DESCRIBE
THE
TWO
OPERATIONS
CONDITION
A
WILL
FOLLOW
FROM
THE
DEFINITION
OF
THE
OPERATIONS
WHILE
CONDITION
B
WILL
REQUIRE
A
PROOF
WEB
DRAFT
LOWERBOUNDS
FOR
MONOTONE
CIRCUITS
THE
OPERATION
F
LJ
G
LET
F
G
BE
TWO
M
FUNCTIONS
THAT
IS
F
VM
CS
AND
G
VM
CT
I
J
IF
F
OR
G
IS
THE
OR
OF
LESS
THAN
M
CLIQUE
INDICATORS
WE
CAN
ADD
DUPLICATE
SETS
TO
MAKE
THE
NUMBER
M
CONSIDER
THE
FUNCTION
H
WHERE
ZI
SI
AND
ZM
J
TJ
FOR
I
J
M
THE
FUNCTION
H
IS
NOT
AN
M
FUNCTION
SINCE
IT
IS
THE
OR
OF
CLIQUE
INDICATORS
WE
MAKE
IT
INTO
AN
M
FUNCTION
IN
THE
FOLLOWING
WAY
AS
LONG
AS
THERE
ARE
MORE
THAN
M
DISTINCT
SETS
FIND
P
SUBSETS
ZIP
THAT
ARE
IN
A
SUNFLOWER
FORMATION
THAT
IS
THERE
EXISTS
A
SET
Z
N
SUCH
THAT
FOR
EVERY
J
JI
P
ZIJ
ZI
J
Z
REPLACE
THE
FUNCTIONS
CZI
CZIP
IN
THE
FUNCTION
H
WITH
THE
FUNCTION
CZ
ONCE
WE
OBTAIN
AN
M
FUNCTION
HI
WE
DEFINE
F
G
TO
BE
HI
WE
WON
T
GET
STUCK
BECAUSE
OF
THE
FOLLOWING
LEMMA
WHOSE
PROOF
WE
DEFER
LEMMA
SUNFLOWER
LEMMA
LET
Z
BE
A
COLLECTION
OF
DISTINCT
SETS
EACH
OF
CARDINALITY
AT
MOST
IF
Z
P
C
THEN
THERE
EXIST
P
SETS
ZP
Z
AND
SET
Z
SUCH
THAT
ZI
ZJ
Z
FOR
EVERY
I
J
P
THE
OPERATION
F
N
G
LET
F
G
BE
TWO
M
FUNCTIONS
THAT
IS
F
VM
CS
AND
G
VM
CT
LET
BE
THE
FUNCTION
V
I
I
J
J
FUNCTION
CZ
FOR
Z
REDUCE
THE
NUMBER
OF
FUNCTIONS
TO
M
BY
APPLYING
THE
SUNFLOWER
LEMMA
AS
ABOVE
PROVING
CONDITION
B
TO
COMPLETE
THE
PROOF
OF
THE
LEMMA
WE
PROVE
THE
FOLLOWING
FOUR
EQUATIONS
PRG
RY
F
LJG
G
F
G
G
IF
Z
ZP
THEN
FOR
EVERY
I
CZI
G
IMPLIES
THAT
CZ
G
AND
HENCE
THE
OPERATION
F
G
CAN
T
INTRODUCE
ANY
FALSE
NEGATIVES
PRG
RN
F
LJG
G
F
G
G
WE
CAN
INTRODUCE
A
FALSE
POSITIVE
ON
A
GRAPH
G
ONLY
IF
WHEN
WE
REPLACE
THE
CLIQUE
INDICATORS
FOR
A
SUNFLOWER
ZP
WITH
THE
CLIQUE
INDICATOR
FOR
THE
COMMON
INTERSECTION
Z
IT
IS
THE
CASE
THAT
CZ
G
HOLDS
EVEN
THOUGH
CZI
G
IS
FALSE
FOR
EVERY
I
RECALL
THAT
WE
CHOOSE
G
R
N
BY
CHOOSING
A
RANDOM
FUNCTION
C
N
K
AND
ADDING
AN
EDGE
FOR
EVERY
TWO
VERTICES
U
V
WITH
C
U
C
V
THUS
WE
GET
A
FALSE
POSITIVE
IF
C
IS
ONE
TO
ONE
ON
Z
WE
DENOTE
THIS
EVENT
BY
B
BUT
NOT
ONE
TO
ONE
ON
ZI
FOR
EVERY
I
P
WE
DENOTE
THESE
EVENTS
BY
AP
WE
LL
SHOW
THAT
THE
INTERSECTION
OF
B
AND
AP
HAPPENS
WITH
PROBABILITY
AT
MOST
P
WHICH
BY
THE
CHOICE
OF
P
IS
LESS
THAN
SINCE
WE
APPLY
THE
REDUCTION
STEP
AT
MOST
M
TIMES
THE
EQUATION
WILL
FOLLOW
SINCE
K
FOR
EVERY
I
PR
AI
B
THE
PROBABILITY
THAT
THERE
LL
BE
A
COLLISION
ON
THE
AT
MOST
ELEMENTS
OF
ZI
Z
IS
LESS
THAN
HALF
CONDITIONED
ON
B
THE
EVENTS
AP
ARE
INDEPENDENT
SINCE
THEY
DEPEND
ON
THE
VALUES
OF
C
ON
DISJOINT
SETS
AND
HENCE
WE
HAVE
THAT
PR
AP
B
PR
AP
B
TLP
PR
AP
B
P
PRG
RY
F
NG
G
F
G
G
BY
THE
DISTRIBUTIVE
LAW
F
G
I
J
CSI
CTJ
A
GRAPH
G
IN
THE
SUPPORT
OF
Y
CONSISTS
OF
A
CLIQUE
OVER
SOME
SET
K
FOR
SUCH
A
GRAPH
CSI
CTJ
HOLDS
IFF
SI
TJ
K
AND
THUS
CSI
CTJ
HOLDS
DRAFT
WEB
DRAFT
CIRCUIT
COMPLEXITY
THE
FRONTIER
IFF
CSI
TJ
HOLDS
WE
CAN
INTRODUCE
A
FALSE
NEGATIVE
WHEN
WE
DISCARD
FUNCTIONS
OF
THE
FORM
CZ
FOR
Z
BUT
BY
LEMMA
FOR
SUCH
SETS
Z
PR
CZ
N
K
THE
EQUATION
FOLLOWS
SINCE
WE
DISCARD
AT
MOST
SUCH
SETS
PRG
RN
F
NG
G
F
G
G
SINCE
IMPLIES
BOTH
AND
WE
CAN
T
INTRODUCE
FALSE
POSITIVES
BY
MOVING
FROM
TO
I
J
CSI
TJ
WE
CAN
T
INTRODUCE
FALSE
POSITIVES
BY
DISCARDING
FUNCTIONS
FROM
THE
OR
THUS
THE
ONLY
PLACE
WHERE
WE
CAN
INTRODUCE
FALSE
POSITIVES
IS
WHERE
WE
REPLACE
THE
CLIQUE
INDICATORS
OF
A
SUNFLOWER
WITH
THE
CLIQUE
INDICATOR
OF
THE
COMMON
INTERSECTION
WE
BOUND
THIS
PROBABILITY
IN
THE
SAME
WAY
AS
THIS
WAS
DONE
FOR
THE
LJ
OPERATOR
PROOF
OF
THE
SUNFLOWER
LEMMA
LEMMA
THE
PROOF
IS
BY
INDUCTION
ON
THE
CASE
IS
TRIVIAL
SINCE
DISTINCT
SETS
OF
SIZE
MUST
BE
DISJOINT
FOR
LET
M
BE
A
MAXIMAL
SUBCOLLECTION
OF
Z
CONTAINING
ONLY
DISJOINT
SETS
BECAUSE
OF
M
MAXIMALITY
FOR
EVERY
Z
Z
THERE
EXISTS
X
M
MM
SUCH
THAT
X
Z
IF
P
WE
RE
DONE
SINCE
SUCH
A
COLLECTION
IS
ALREADY
A
SUNFLOWER
OTHERWISE
SINCE
P
BY
AVERAGING
THERE
AN
X
THAT
APPEARS
IN
AT
LEAST
A
FRACTION
OF
THE
SETS
IN
LET
Z
Z
BE
THE
SETS
CONTAINING
X
AND
NOTE
THAT
C
P
THUS
BY
INDUCTION
THERE
ARE
SETS
AMONG
THE
SIZED
SETS
X
ZK
X
THAT
FORM
A
SUNFLOWER
ADDING
BACK
X
WE
GET
THE
DESIRED
SUNFLOWER
AMONG
THE
ORIGINAL
SETS
NOTE
THAT
THE
STATEMENT
AND
PROOF
ASSUME
NOTHING
ABOUT
THE
SIZE
OF
THE
UNIVERSE
THE
SETS
IN
Z
LIVE
IN
CIRCUIT
COMPLEXITY
THE
FRONTIER
NOW
WE
SKETCH
THE
FRONTIER
OF
CIRCUIT
LOWERBOUNDS
NAMELY
THE
DIVIDING
LINE
BETWEEN
WHAT
WE
CAN
PROVE
AND
WHAT
WE
CANNOT
ALONG
THE
WAY
WE
ALSO
DEFINE
MULTI
PARTY
COMMUNICATION
SINCE
IT
MAY
PROVE
USEFUL
FOR
PROVING
SOME
NEW
CIRCUIT
LOWERBOUNDS
CIRCUIT
LOWERBOUNDS
USING
DIAGONALIZATION
WE
ALREADY
MENTIONED
THAT
THE
BEST
LOWERBOUND
ON
CIRCUIT
SIZE
FOR
AN
NP
PROBLEM
IS
O
N
FOR
PH
BETTER
LOWERBOUNDS
ARE
KNOWN
ONE
OF
THE
EXERCISES
IN
CHAPTER
ASKED
YOU
TO
SHOW
THAT
SOME
FOR
EVERY
K
SOME
LANGUAGE
IN
PH
IN
FACT
IN
P
REQUIRES
CIRCUITS
OF
SIZE

NK
THE
LATTER
LOWERBOUND
USES
DIAGONALIZATION
AND
ONE
IMAGINES
THAT
CLASSES
HIGHER
UP
THAN
PH
SHOULD
HAVE
EVEN
HARDER
LANGUAGES
FRONTIER
DOES
NEXP
HAVE
LANGUAGES
THAT
REQUIRE
SUPER
POLYNOMIAL
SIZE
CIRCUITS
IF
WE
GO
A
LITTLE
ABOVE
NEXP
WE
CAN
ACTUALLY
PROVE
A
SUPER
POLYNOMIAL
LOWERBOUND
WE
KNOW
THAT
MAEXP
R
P
POLY
WHERE
MAEXP
IS
THE
SET
OF
LANGUAGES
ACCEPTED
BY
A
ONE
ROUND
PROOF
WITH
AN
ALL
POWERFUL
PROVER
AND
AN
EXPONENTIAL
TIME
PROBABILISTIC
VERIFIER
THIS
FOLLOWS
FROM
THE
FACT
WEB
DRAFT
CIRCUIT
COMPLEXITY
THE
FRONTIER
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
THE
DEPTH
CIRCUIT
WITH
A
SYMMETRIC
OUTPUT
GATE
FROM
THEOREM
THAT
IF
MAEXP
P
POLY
THEN
IN
PARTICULAR
PSPACE
P
POLY
HOWEVER
BY
IP
PSPACE
THEOREM
WE
HAVE
THAT
IN
THIS
CASE
PSPACE
MA
THE
PROVER
CAN
SEND
IN
ONE
ROUND
THE
CIRCUIT
FOR
COMPUTING
THE
PROVER
STRATEGY
IN
THE
INTERACTIVE
PROOF
HOWEVER
BY
SIMPLE
PADDING
THIS
IMPLIES
THAT
MAEXP
EQUALS
THE
CLASS
OF
LANGUAGES
IN
EXPONENTIAL
SPACE
WHICH
CAN
BE
DIRECTLY
SHOWN
TO
NOT
CONTAIN
P
POLY
USING
DIAGONALIZATION
INTERESTINGLY
THIS
LOWER
BOUND
DOES
NOT
RELATIVIZE
I
E
THERE
AN
ORACLE
UNDER
WHICH
MANEXP
P
POLY
STATUS
OF
ACC
VERSUS
P
THE
RESULT
THAT
PARITY
IS
NOT
IN
SEPARATES
FROM
THE
NEXT
LOGICAL
STEP
WOULD
BE
TO
SEPARATE
FROM
LESS
AMBITIOUSLY
WE
WOULD
LIKE
TO
SHOW
EVEN
A
FUNCTION
IN
P
OR
NP
THAT
IS
NOT
IN
THE
RAZBOROV
SMOLENKSY
METHOD
SEEMS
TO
FAIL
WHEN
WE
ALLOW
THE
CIRCUIT
EVEN
TWO
TYPES
OF
MODULAR
GATES
SAY
M
AND
M
IN
FACT
IF
WE
ALLOW
THE
BOUNDED
DEPTH
CIRCUIT
MODULAR
GATES
THAT
DO
ARITHMETIC
MOD
Q
WHEN
Q
IS
NOT
A
PRIME
A
PRIME
POWER
TO
BE
EXACT
WE
REACH
THE
LIMITS
OF
OUR
KNOWLEDGE
THE
EXERCISES
ASK
YOU
TO
FIGURE
OUT
WHY
THE
PROOF
OF
THEOREM
DOES
NOT
SEEM
TO
APPLY
WHEN
THE
MODULUS
IS
A
COMPOSITE
NUMBER
TO
GIVE
ONE
EXAMPLE
IT
IT
IS
CONSISTENT
WITH
CURRENT
KNOWLEDGE
THAT
THE
MAJORITY
OF
N
BITS
CAN
BE
COMPUTED
BY
LINEAR
SIZE
CIRCUITS
OF
CONSTANT
DEPTH
CONSISTING
ENTIRELY
OF
M
GATES
THE
PROBLEM
SEEMS
TO
BE
THAT
LOW
DEGREE
POLYNOMIALS
MODULO
M
WHERE
M
IS
COMPOSITE
ARE
SURPRISINGLY
EXPRESSIVE
FRONTIER
SHOW
CLIQUE
IS
NOT
IN
OR
EVEN
LESS
AMBITIOUSLY
FRONTIER
EXHIBIT
A
LANGUAGE
IN
NEXP
THAT
IS
NOT
IN
IT
IS
WORTH
NOTING
THAT
THUS
FAR
WE
ARE
TALKING
ABOUT
NONUNIFORM
CIRCUITS
TO
WHICH
THEOREM
ALSO
APPLIES
STRONGER
LOWER
BOUNDS
ARE
KNOWN
FOR
UNIFORM
CIRCUITS
ALLENDER
AND
GORE
HAVE
SHOWN
THAT
A
DECISION
VERSION
OF
THE
PERMANENT
AND
HENCE
THE
PERMANENT
ITSELF
REQUIRES
EXPONENTIAL
SIZE
DLOGTIME
UNIFORM
CIRCUITS
A
CIRCUIT
FAMILY
CN
IS
DLOGTIME
UNIFORM
IF
THERE
EXISTS
A
DETERMINISTIC
TURING
MACHINE
M
THAT
GIVEN
A
TRIPLE
N
G
H
DETERMINES
IN
LINEAR
TIME
I
E
O
LOG
N
TIME
WHEN
G
H
POLY
N
WHAT
TYPES
OF
GATES
G
AND
H
ARE
AND
WHETHER
G
IS
H
PARENT
IN
CN
BUT
GOING
BACK
TO
NONUNIFORM
WE
WISH
TO
MENTION
AN
ALTERNATIVE
REPRESENTATION
OF
CIRCUITS
THAT
MAY
BE
USEFUL
IN
FURTHER
LOWERBOUNDS
LET
A
SYMMETRIC
GATE
BE
A
GATE
WHOSE
OUTPUT
DEPENDS
ONLY
ON
THE
NUMBER
OF
INPUTS
THAT
ARE
FOR
EXAMPLE
MAJORITY
AND
MOD
GATES
ARE
SYMMETRIC
YAO
HAS
SHOWN
THAT
CIRCUITS
CAN
BE
SIMPLIFIED
TO
GIVE
AN
EQUIVALENT
DEPTH
CIRCUITS
WITH
A
SYMMETRIC
GATE
AT
THE
OUTPUT
FIGURE
BEIGEL
AND
TARUI
SUBSEQUENTLY
IMPROVED
YAO
RESULT
DRAFT
WEB
DRAFT
CIRCUIT
COMPLEXITY
THE
FRONTIER
THEOREM
YAO
BEIGEL
AND
TARUI
IF
F
THEN
F
CAN
BE
COMPUTED
BY
A
DEPTH
CIRCUIT
C
WITH
A
SYMMETRIC
GATE
WITH
QUASIPOLYNOMIAL
I
E
N
FAN
IN
AT
THE
OUTPUT
LEVEL
AND
GATES
WITH
POLYLOGARITHMIC
FAN
IN
AT
THE
INPUT
LEVEL
WE
WILL
REVISIT
THIS
THEOREM
BELOW
IN
SECTION
LINEAR
CIRCUITS
WITH
LOGARITHMIC
DEPTH
WHEN
WE
RESTRICT
CIRCUITS
TO
HAVE
BOUNDED
FANIN
WE
NECESSARILY
NEED
TO
ALLOW
THEM
TO
HAVE
NON
CONSTANT
IN
FACT

LOG
N
DEPTH
TO
HAVE
ANY
REASONABLE
POWER
WITH
THIS
IN
MIND
THE
SIMPLEST
INTERESTING
CIRCUIT
CLASS
SEEMS
TO
BE
ONE
OF
CIRCUITS
WTH
LINEAR
SIZE
AND
LOGARITHMIC
DEPTH
FRONTIER
FIND
AN
EXPLICIT
FUNCTION
THAT
CANNOT
BE
COMPUTED
BY
CIRCUITS
OF
LINEAR
SIZE
AND
LOGARITHMIC
DEPTH
NOTE
THAT
BY
COUNTING
ONE
CAN
EASILY
SHOW
THAT
SOME
FUNCTION
ON
N
BITS
REQUIRES
SUPERPOLY
NOMIAL
SIZE
CIRCUITS
AND
HENCE
BOUNDED
FAN
IN
CIRCUITS
WITH
MORE
THAN
LOGARITHMIC
DEPTH
SEE
THE
EXERCISES
ON
THE
CHAPTER
ON
CIRCUITS
HENCE
WE
WANT
TO
SHOW
THIS
FOR
AN
EXPLICIT
FUNCTION
E
G
CLIQUE
VALIANT
THOUGHT
ABOUT
THIS
PROBLEM
IN
THE
HIS
INITIAL
CANDIDATES
FOR
LOWERBOUNDS
BOILED
DOWN
TO
SHOWING
THAT
A
CERTAIN
GRAPH
CALLED
A
SUPERCONCENTRATOR
NEEDED
TO
HAVE
SUPERLINEAR
SIZE
HE
FAILED
TO
PROVE
THISAND
INSTEAD
ENDED
UP
PROVING
THAT
SUCH
SUPERCONCENTRATORS
DO
EXIST
ANOTHER
SIDEPRODUCT
OF
VALIANT
INVESTIGATIONS
WAS
THE
FOLLOWING
IMPORTANT
LEMMA
CONCERNING
DEPTH
REDUCTION
FOR
SUCH
CIRCUITS
LEMMA
VALIANT
IN
ANY
CIRCUIT
WITH
M
EDGES
AND
DEPTH
D
THERE
ARE
KM
LOG
D
EDGES
WHOSE
REMOVAL
LEAVES
A
CIRCUIT
WITH
DEPTH
AT
MOST
D
THIS
LEMMA
CAN
BE
APPLIED
AS
FOLLOWS
SUPPOSE
WE
HAVE
A
CIRCUIT
C
OF
DEPTH
C
LOG
N
WITH
N
INPUTS
XN
AND
N
OUTPUTS
YN
AND
SUPPOSE
C
E
WHERE
E
IS
ARBITRARILY
SMALL
REMOVING
O
N
LOG
LOG
N
EDGES
FROM
C
THEN
RESULTS
IN
A
CIRCUIT
WITH
DEPTH
AT
MOST
E
LOG
N
BUT
THEN
SINCE
C
HAS
BOUNDED
FAN
IN
WE
MUST
HAVE
THAT
EACH
OUTPUT
YI
IS
CONNECTED
TO
AT
MOST
LOG
N
NE
INPUTS
SO
EACH
OUTPUT
YI
IN
C
IS
COMPLETELY
DETERMINED
BY
NE
INPUTS
AND
THE
VALUES
OF
THE
OMITTED
EDGES
SO
WE
HAVE
A
DENSE
ENCODING
FOR
THE
FUNCTION
FI
XN
YI
WE
DO
NOT
EXPECT
THIS
TO
BE
THE
CASE
FOR
ANY
REASONABLY
DIFFICULT
FUNCTION
BRANCHING
PROGRAMS
JUST
AS
CIRCUITS
ARE
USED
TO
INVESTIGATE
TIME
REQUIREMENTS
OF
TURING
MACHINES
BRANCHING
PROGRAMS
ARE
USED
TO
INVESTIGATE
SPACE
COMPLEXITY
A
BRANCHING
PROGRAM
ON
N
INPUT
VARIABLES
XN
IS
A
DIRECTED
ACYCLIC
GRAPH
ALL
OF
WHOSE
NODES
OF
NONZERO
OUTDEGREE
ARE
LABELED
WITH
A
VARIABLE
XI
IT
HAS
TWO
NODES
OF
OUTDEGREE
ZERO
THAT
ARE
LABELED
WITH
AN
OUTPUT
VALUE
ACCEPT
OR
REJECT
THE
EDGES
ARE
LABELED
BY
OR
ONE
OF
THE
NODES
IS
DESIGNATED
THE
START
NODE
A
SETTING
OF
THE
INPUT
VARIABLES
DETERMINES
A
WAY
TO
WALK
WEB
DRAFT
APPROACHES
USING
COMMUNICATION
COMPLEXITY
ON
THE
DIRECTED
GRAPH
FROM
THE
START
NODE
TO
AN
OUTPUT
NODE
AT
ANY
STEP
IF
THE
CURRENT
NODE
HAS
LABEL
XI
THEN
WE
TAKE
AN
EDGE
GOING
OUT
OF
THE
NODE
WHOSE
LABEL
AGREES
WITH
THE
VALUE
OF
XI
THE
BRANCHING
PROGRAM
IS
DETERMINISTIC
IF
EVERY
NONOUTPUT
NODE
HAS
EXACTLY
ONE
EDGE
AND
ONE
EDGE
LEAVING
IT
OTHERWISE
IT
IS
NONDETERMINISTIC
THE
SIZE
OF
THE
BRANCHING
PROGRAM
IS
THE
NUMBER
OF
NODES
IN
IT
THE
BRANCHING
PROGRAM
COMPLEXITY
OF
A
LANGUAGE
IS
DEFINED
ANALOGOUSLY
WITH
CIRCUIT
COMPLEXITY
SOMETIMES
ONE
MAY
ALSO
REQUIRE
THE
BRANCHING
PROGRAM
TO
BE
LEVELED
WHEREBY
NODES
ARE
ARRANGED
INTO
A
SEQUENCE
OF
LEVELS
WITH
EDGES
GOING
ONLY
FROM
ONE
LEVEL
TO
THE
NEXT
THEN
THE
WIDTH
IS
THE
SIZE
OF
THE
LARGEST
LEVEL
THEOREM
IF
N
LOG
N
AND
L
SPACE
N
THEN
L
HAS
BRANCHING
PROGRAM
COMPLEXITY
AT
MOST
CS
N
FOR
SOME
CONSTANT
C
PROOF
ESSENTIALLY
MIMICS
OUR
PROOF
OF
THEOREM
THAT
SPACE
N
DTIME
N
THE
NODES
OF
THE
BRANCHING
PROGRAM
CORRESPOND
TO
THE
CONFIGURATIONS
OF
THE
SPACE
BOUNDED
TM
AND
IT
IS
LABELED
WITH
VARIABLE
XI
IF
THE
CONFIGURATION
SHOWS
THE
TM
READING
THE
ITH
BIT
IN
THE
INPUT
OF
COURSE
A
SIMILAR
THEOREM
IS
TRUE
ABOUT
NDTMS
AND
NONDETERMINISTIC
BRANCHING
PROGRAM
COMPLEXITY
FRONTIER
DESCRIBE
A
PROBLEM
IN
P
OR
EVEN
NP
THAT
REQUIRES
BRANCHING
PROGRAMS
OF
SIZE
GREATER
THAN
E
FOR
SOME
CONSTANT
E
THERE
IS
SOME
EVIDENCE
THAT
BRANCHING
PROGRAMS
ARE
MORE
POWERFUL
THAN
ONE
MAY
IMAGINE
FOR
INSTANCE
BRANCHING
PROGRAMS
OF
CONSTANT
WIDTH
REMINISCENT
OF
A
TM
WITH
O
BITS
OF
MEMORY
SEEM
INHERENTLY
WEAK
THUS
THE
NEXT
RESULT
IS
UNEXPECTED
THEOREM
BARRINGTON
A
LANGUAGE
HAS
POLYNOMIAL
SIZE
WIDTH
BRANCHING
PROGRAMS
IFF
IT
IS
IN
APPROACHES
USING
COMMUNICATION
COMPLEXITY
HERE
WE
OUTLINE
A
CONCRETE
APPROACH
RATHER
A
SETTING
IN
WHICH
BETTER
LOWERBOUNDS
MAY
LEAD
TO
A
RESOLUTION
OF
SOME
OF
THE
QUESTIONS
ABOVE
IT
RELATES
TO
GENERALIZATIONS
OF
COMMUNICATION
COMPLEXITY
INTRODUCED
EARLIER
MOSTLY
WE
WILL
USE
MULTIPARTY
COMMUNICATION
COMPLEXITY
THOUGH
SECTION
WILL
USE
COMMUNICATION
COMPLEXITY
OF
A
RELATION
CONNECTION
TO
CIRCUITS
SUPPOSE
F
XK
HAS
A
DEPTH
CIRCUIT
WITH
A
SYMMETRIC
GATE
WITH
FAN
IN
N
AT
THE
OUTPUT
AND
GATES
WITH
FAN
IN
K
AT
THE
INPUT
LEVEL
FIGURE
THE
CLAIM
IS
THAT
F
K
PARTY
COMMUNICATION
COMPLEXITY
IS
AT
MOST
K
LOG
N
THIS
OBSERVATION
IS
DUE
TO
RAZBOROV
AND
WIGDERSON
TO
SEE
THE
CLAIM
FIRST
PARTITION
THE
GATES
AMONGST
THE
PLAYERS
EACH
BIT
IS
NOT
KNOWN
TO
EXACTLY
ONE
PLAYER
SO
THE
INPUT
BITS
OF
EACH
GATE
ARE
KNOWN
TO
AT
LEAST
ONE
PLAYER
ASSIGN
THE
GATE
TO
SUCH
A
PLAYER
WITH
THE
LOWEST
INDEX
PLAYERS
THEN
BROADCAST
HOW
MANY
OF
THEIR
GATES
OUTPUT
SINCE
THIS
NUMBER
HAS
AT
MOST
LOG
N
BITS
THE
CLAIM
FOLLOWS
DRAFT
WEB
DRAFT
APPROACHES
USING
COMMUNICATION
COMPLEXITY
FIGURE
UNAVAILABLE
IN
PDF
FILE
FIGURE
IF
F
IS
COMPUTED
BY
THE
ABOVE
CIRCUIT
THEN
F
HAS
A
K
PARTY
PROTOCOL
OF
COMPLEXITY
K
LOG
N
OUR
HOPE
IS
TO
EMPLOY
THIS
CONNECTION
WITH
COMMUNICATION
COMPLEXITY
IN
CONJUNCTION
WITH
THEOREM
TO
OBTAIN
LOWER
BOUNDS
ON
CIRCUITS
FOR
EXAMPLE
NOTE
THAT
THE
FUNCTION
IN
EXAMPLE
ABOVE
CANNOT
HAVE
K
LOG
N
HOWEVER
THIS
IS
NOT
ENOUGH
TO
OBTAIN
A
LOWER
BOUND
ON
CIRCUITS
SINCE
WE
NEED
TO
SHOW
THAT
K
IS
NOT
POLYLOGARITHMIC
TO
EMPLOY
THEOREM
THUS
A
STRENGTHENING
OF
THE
BABAI
NISAN
SZEGEDY
LOWERBOUND
TO

N
POLY
K
FOR
SAY
THE
CLIQUE
FUNCTION
WOULD
CLOSE
FRONTIER
CONNECTION
TO
LINEAR
SIZE
LOGARITHMIC
DEPTH
CIRCUITS
SUPPOSE
THAT
F
N
LOG
N
N
HAS
BOUNDED
FAN
IN
CIRCUITS
OF
LINEAR
SIZE
AND
LOGARITHMIC
DEPTH
IF
F
X
J
I
DENOTES
THE
ITH
BIT
OF
F
X
J
THEN
VALIANT
LEMMA
IMPLIES
THAT
F
X
J
I
HAS
A
SIMULTANEOUS
PARTY
PROTOCOL
THAT
IS
A
PROTOCOL
WHERE
ALL
PARTIES
SPEAK
ONLY
ONCE
AND
WRITE
SIMULTANEOUSLY
ON
THE
BLACKBOARD
I
E
NON
ADAPTIVELY
WHERE
X
J
PLAYER
SENDS
N
LOG
LOG
N
BITS
X
I
PLAYER
SENDS
NE
BITS
AND
I
J
PLAYER
SENDS
O
LOG
N
BITS
SO
IF
WE
CAN
SHOW
THAT
A
FUNCTION
DOES
NOT
HAVE
SUCH
A
PROTOCOL
THEN
WE
WOULD
HAVE
A
LOWER
BOUND
FOR
THE
FUNCTION
ON
LINEAR
SIZE
LOGARITHMIC
DEPTH
CIRCUITS
WITH
BOUNDED
FAN
IN
CONJECTURE
THE
FUNCTION
F
X
J
I
XJ
I
WHERE
J
I
IS
THE
BITWISE
XOR
IS
CONJECTURED
TO
BE
HARD
I
E
F
SHOULD
NOT
HAVE
A
COMPACT
REPRESENTATION
CONNECTION
TO
BRANCHING
PROGRAMS
THE
NOTION
OF
MULTIPARTY
COMMUNICATION
COMPLEXITY
AT
LEAST
THE
NUMBER
ON
THE
FOREHEAD
MODEL
DISCUSSED
HERE
WAS
INVENTED
BY
CHANDRA
FURST
AND
LIPTON
FOR
PROVING
LOWERBOUNDS
ON
BRANCHING
PROGRAMS
ESPECIALLY
CONSTANT
WIDTH
BRANCHING
PROGRAMS
DISCUSSED
IN
SECTION
KARCHMER
WIGDERSON
COMMUNICATION
GAMES
AND
DEPTH
LOWERBOUNDS
THE
RESULT
THAT
PARITY
IS
NOT
IN
SEPARATES
FROM
THE
NEXT
STEP
WOULD
BE
TO
SEPARATE
FROM
OF
COURSE
IGNORING
FOR
THE
MOMENT
THE
ISSUE
OF
SEPARATING
FROM
KARCHMER
AND
WIGDERSON
DESCRIBED
HOW
COMMUNICATION
COMPLEXITY
CAN
BE
USED
TO
PROVE
LOWERBOUNDS
ON
THE
MINIMUM
DEPTH
REQUIRED
TO
COMPUTE
A
FUNCTION
THEY
SHOWED
THE
FOLLOWING
RESULT
ABOUT
MONOTONE
CIRCUITS
WHICH
WE
WILL
NOT
PROVE
THIS
RESULT
THEOREM
DETECTING
WHETHER
A
GRAPH
HAS
A
PERFECT
MATCHING
IS
IMPOSSIBLE
WITH
MONOTONE
CIRCUITS
OF
DEPTH
O
LOG
N
WEB
DRAFT
APPROACHES
USING
COMMUNICATION
COMPLEXITY
HOWEVER
WE
DO
DESCRIBE
THE
BASIC
KARCHMER
WIGDERSON
GAME
USED
TO
PROVE
THE
ABOVE
RESULT
SINCE
IT
IS
RELEVANT
FOR
NONMONOTONE
CIRCUITS
AS
WELL
FOR
A
FUNCTION
F
N
THIS
GAME
IS
DEFINED
AS
FOLLOWS
THERE
ARE
TWO
PLAYERS
ZERO
AND
ONE
PLAYER
ZERO
RECEIVES
AN
INPUT
X
SUCH
THAT
F
X
AND
PLAYER
ONE
RECEIVES
AN
INPUT
Y
SUCH
THAT
F
Y
THEY
COMMUNICATE
BITS
TO
EACH
OTHER
UNTIL
THEY
CAN
AGREE
ON
AN
I
N
SUCH
THAT
XI
YI
THE
MECHANISM
OF
COMMUNICATION
IS
DEFINED
SIMILARLY
AS
IN
CHAPTER
THERE
IS
A
PROTOCOL
THAT
THE
PLAYERS
AGREE
ON
IN
ADVANCE
BEFORE
RECEIVING
THE
INPUT
NOTE
THAT
THE
KEY
DIFFERENCE
FROM
THE
SCENARIO
IN
CHAPTER
IS
THAT
THE
FINAL
ANSWER
IS
NOT
A
SINGLE
BIT
AND
FURTHERMORE
THE
FINAL
ANSWER
IS
NOT
UNIQUE
THE
NUMBER
OF
ACCEPTABLE
ANSWERS
IS
EQUAL
TO
THE
NUMBER
OF
BITS
THAT
X
Y
DIFFER
ON
SOMETIMES
THIS
IS
DESCRIBED
AS
COMPUTING
A
RELATION
THE
RELATION
IN
THIS
CASE
CONSISTS
OF
ALL
TRIPLES
X
Y
I
SUCH
THAT
F
X
F
Y
AND
XI
YI
WE
DEFINE
CKW
F
AS
THE
COMMUNICATION
COMPLEXITY
OF
THE
ABOVE
GAME
NAMELY
THE
MAXIMUM
OVER
ALL
X
F
Y
F
OF
THE
NUMBER
OF
BITS
EXCHANGED
IN
COMPUTING
AN
ANSWER
FOR
X
Y
THE
NEXT
THEOREM
SHOWS
THAT
THIS
PARAMETER
HAS
A
SUPRISING
ALTERNATIVE
CHARACTERIZATION
IT
ASSUMES
THAT
CIRCUITS
DON
T
HAVE
NOT
GATES
AND
INSTEAD
THE
NOT
GATES
ARE
PUSHED
DOWN
TO
THE
INPUTS
USING
DE
MORGAN
LAW
IN
OTHER
WORDS
THE
INPUTS
MAY
BE
VIEWED
AS
XN
XN
FURTHERMORE
AND
AND
OR
GATES
HAVE
FANIN
NONE
OF
THESE
ASSUMPTIONS
IS
CRUCIAL
AND
AFFECTS
THE
THEOREM
ONLY
MARGINALLY
THEOREM
CKW
F
IS
EXACTLY
THE
MINIMUM
DEPTH
AMONG
ALL
CIRCUITS
THAT
COMPUTE
F
PROOF
FIRST
WE
SHOW
THAT
IF
THERE
IS
A
CIRCUIT
OF
DEPTH
K
THAT
COMPUTES
F
THEN
CKW
F
K
EACH
PLAYER
HAS
A
COPY
OF
AND
EVALUATES
THIS
CIRCUIT
ON
THE
INPUT
GIVEN
TO
HIM
OF
COURSE
IT
EALUATES
TO
FOR
PLAYER
ZERO
AND
TO
FOR
PLAYER
ONE
SUPPOSE
THE
TOP
GATE
IS
AN
OR
THEN
AT
LEAST
ONE
OF
THE
TWO
INCOMING
WIRES
TO
THIS
GATE
MUST
BE
AND
IN
THE
FIRST
ROUND
PLAYER
ONE
SENDS
ONE
BIT
COMMUNICATING
WHICH
OF
THESE
WIRES
IT
WAS
NOTE
THAT
THIS
WIRE
IS
FOR
PLAYER
ZERO
IN
THE
NEXT
ROUND
THE
PLAYERS
FOCUS
ON
THE
GATE
THAT
PRODUCED
THE
VALUE
ON
THIS
WIRE
IF
THE
TOP
GATE
IS
AN
AND
ON
THE
OTHER
HAND
THEN
IN
THE
FIRST
ROUND
PLAYER
ZERO
SPEAKS
CONVEYING
WHICH
OF
THE
TWO
INCOMING
WIRES
WAS
THIS
WIRE
WILL
BE
FOR
PLAYER
ONE
THIS
GOES
ON
AND
THE
PLAYERS
GO
DEEPER
DOWN
THE
CIRCUIT
ALWAYS
MAINTAINING
THE
INVARIANT
THAT
THE
CURRENT
GATE
HAS
VALUE
FOR
PLAYER
ONE
AND
FOR
PLAYER
ZERO
FINALLY
AFTER
AT
MOST
K
STEPS
THEY
ARRIVE
AT
AN
INPUT
BIT
ACCORDING
TO
THE
INVARIANT
BEING
MAINTAINED
THIS
BIT
MUST
BE
FOR
PLAYER
ONE
AND
FOR
PLAYER
ZERO
THUS
THEY
BOTH
KNOW
AN
INDEX
I
THAT
IS
A
VALID
ANSWER
FOR
THE
REVERSE
DIRECTION
WE
HAVE
TO
SHOW
THAT
IF
CKW
F
K
THEN
THERE
IS
A
CIRCUIT
OF
DEPTH
AT
MOST
K
THAT
COMPUTES
F
WE
PROVE
A
MORE
GENERAL
RESULT
FOR
ANY
TWO
DISJOINT
NONEMPTY
SUBSETS
A
F
AND
B
F
LET
CKW
A
B
BE
THE
COMMUNICATION
COMPLEXITY
OF
THE
KARCHMER
WIGDERSON
GAME
WHEN
X
ALWAYS
LIES
IN
A
AND
Y
IN
B
WE
SHOW
THAT
THERE
IS
A
CIRCUIT
OF
DEPTH
CKW
A
B
THAT
OUTPUTS
ON
EVERY
INPUT
FROM
A
AND
ON
EVERY
INPUT
FROM
B
SUCH
A
CIRCUIT
IS
CALLED
A
DISTINGUISHER
FOR
SETS
A
B
THE
PROOF
IS
BY
INDUCTION
ON
K
CKW
A
B
THE
BASE
CASE
K
IS
TRIVIAL
SINCE
THIS
MEANS
THE
PLAYERS
DO
NOT
HAVE
TO
COMMUNICATE
AT
ALL
TO
AGREE
ON
AN
ANSWER
SAY
I
HENCE
XI
YI
FOR
ALL
X
A
Y
B
WHICH
IMPLIES
THAT
EITHER
A
XI
FOR
DRAFT
WEB
DRAFT
APPROACHES
USING
COMMUNICATION
COMPLEXITY
EVERY
X
A
AND
YI
FOR
EVERY
Y
B
OR
B
XI
FOR
EVERY
X
A
AND
YI
FOR
EVERY
Y
B
IN
CASE
A
WE
CAN
USE
THE
DEPTH
CIRCUIT
XI
AND
IN
CASE
B
WE
CAN
USE
THE
CIRCUIT
XI
TO
DISTINGUISH
A
B
FOR
THE
INDUCTIVE
STEP
SUPPOSE
CKW
A
B
K
AND
AT
THE
FIRST
ROUND
PLAYER
ZERO
SPEAKS
THEN
A
IS
THE
DISJOINT
UNION
OF
TWO
SETS
WHERE
AB
IS
THE
SET
OF
INPUTS
IN
A
FOR
WHICH
PLAYER
ZERO
SENDS
BIT
B
THEN
CKW
AB
B
K
FOR
EACH
B
AND
THE
INDUCTIVE
HYPOTHESIS
GIVES
A
CIRCUIT
CB
OF
DEPTH
AT
MOST
K
THAT
DISTINGUISHES
AB
B
WE
CLAIM
THAT
DISTINGUISHES
A
B
NOTE
THAT
IT
HAS
DEPTH
AT
MOST
K
THE
REASON
IS
THAT
Y
Y
FOR
EVERY
Y
B
WHEREAS
FOR
EVERY
X
A
X
X
SINCE
IF
X
AB
THEN
CB
X
THUS
WE
HAVE
THE
FOLLOWING
FRONTIER
FRONTIER
SHOW
THAT
SOME
FUNCTION
F
IN
P
OR
EVEN
NEXP
HAS
CKW
F

LOG
N
LOG
LOG
N
KARCHMER
RAZ
AND
WIGDERSON
DESCRIBE
A
CANDIDATE
FUNCTION
THAT
MAY
WORK
IT
USES
THE
FACT
A
FUNCTION
ON
K
BITS
HAS
A
TRUTH
TABLE
OF
SIZE
AND
THAT
MOST
FUNCTIONS
ON
K
BITS
ARE
HARD
E
G
REQUIRE
CIRCUIT
SIZE

K
CIRCUIT
DEPTH

K
ETC
THEY
DEFINE
THE
FUNCTION
BY
ASSUMING
THAT
PART
OF
THE
N
BIT
INPUT
ENCODES
A
VERY
HARD
FUNCTION
AND
THIS
HARD
FUNCTION
IS
APPLIED
TO
THE
REMAINING
INPUT
IN
A
TREE
FASHION
FOR
ANY
FUNCTION
G
K
AND
DEFINE
G
K
AS
FOLLOWS
IF
THEN
G
G
OTHERWISE
EXPRESS
THE
INPUT
X
KS
AS
X
X
X
X
AND
DEFINE
XK
WHERE
EACH
I
G
XK
G
G
G
G
XK
CLEARLY
IF
G
CAN
BE
COMPUTED
IN
DEPTH
D
THEN
G
CAN
BE
COMPUTED
IN
DEPTH
SD
FURTHERMORE
IF
ONE
FAILS
TO
SEE
HOW
ONE
COULD
REDUCE
THE
DEPTH
FOR
AN
ARBITRARY
FUNCTION
NOW
WE
DESCRIBE
THE
KRW
CANDIDATE
FUNCTION
F
N
LET
K
ILOG
N
L
AND
BE
THE
LARGEST
INTEGER
SUCH
THAT
KS
N
THUS

LOG
N
FOR
ANY
N
BIT
INPUT
X
LET
GX
BE
THE
FUNCTION
WHOSE
TRUTH
TABLE
IS
THE
FIRST
BITS
OF
X
LET
X
BE
THE
STRING
OF
THE
LAST
KS
BITS
OF
X
THEN
F
X
G
X
ACCORDING
TO
OUR
EARLIER
INTUITION
WHEN
THE
FIRST
BITS
OF
X
REPRESENT
A
REALLY
HARD
FUNCTION
AS
THEY
MUST
FOR
MANY
CHOICES
OF
THE
INPUT
THEN
G
X
SHOULD
REQUIRE
DEPTH

SK

N
X
OF
COURSE
PROVING
THIS
SEEMS
DIFFICULT
LOG
LOG
N
THIS
TYPE
OF
COMPLEXITY
QUESTIONS
WHEREBY
WE
ARE
ASKING
WHETHER
INSTANCES
OF
A
PROBLEM
ARE
TIMES
AS
HARD
AS
A
SINGLE
INSTANCE
ARE
CALLED
DIRECT
SUM
QUESTIONS
SIMILAR
QUESTIONS
HAVE
BEEN
STUDIED
IN
A
VARIETY
OF
COMPUTATIONAL
MODELS
AND
SOMETIMES
COUNTERINTUITIVE
RESULTS
HAVE
BEEN
PROVEN
FOR
THEM
ONE
EXAMPLE
IS
THAT
BY
A
COUNTING
ARGUMENT
THERE
EXISTS
AN
N
N
MATRIX
A
OVER
N
SUCH
THAT
THE
SMALLEST
CIRCUIT
COMPUTING
THE
LINEAR
FUNCTION
V
AV
FOR
V
IS
OF
SIZE

HOWEVER
COMPUTING
THIS
FUNCTION
ON
N
INSTANCES
VN
CAN
BE
DONE
SIGNIFICANTLY
FASTER
THAN
STEPS
USING
FAST
MATRIX
MULTIPLICATION
THE
CURRENT
RECORD
IS
ROUGHLY
O
WEB
DRAFT
APPROACHES
USING
COMMUNICATION
COMPLEXITY
CHAPTER
NOTES
AND
HISTORY
SHANNON
DEFINED
CIRCUIT
COMPLEXITY
INCLUDING
MONOTONE
CIRCUIT
COMPLEXITY
IN
THE
TOPIC
WAS
STUDIED
IN
RUSSIA
SINCE
THE
SEE
TRAKHTENBROT
FOR
SOME
REFERENCES
SAVAGE
WAS
THE
FIRST
TO
OBSERVE
THE
CLOSE
RELATIONSHIP
BETWEEN
TIME
REQUIRED
TO
DECIDE
A
LANGUAGE
ON
A
TM
AND
ITS
CIRCUIT
COMPLEXITY
AND
TO
SUGGEST
CIRCUIT
LOWERBOUNDS
AS
A
WAY
TO
SEPARATE
COMPLEXITY
CLASSES
A
BURST
OF
RESULTS
IN
THE
SUCH
AS
THE
SEPARATION
OF
P
FROM
AND
RAZBOROV
SEPARATION
OF
MONOTONE
NP
FROM
MONOTONE
P
POLY
RAISED
HOPES
THAT
A
RESOLUTION
OF
P
VERSUS
NP
MIGHT
BE
NEAR
THESE
HOPES
WERE
DASHED
BY
RAZBOROV
HIMSELF
WHEN
HE
SHOWED
THAT
HIS
METHOD
OF
APPROXIMATIONS
WAS
UNLIKELY
TO
APPLY
TO
NONMONOTONE
CIRCUITS
LATER
RAZBOROV
AND
RUDICH
FORMALIZED
WHAT
THEY
CALLED
NATURAL
PROOFS
TO
SHOW
THAT
ALL
LINES
OF
ATTACK
CONSIDERED
UP
TO
THAT
POINT
WERE
UNLIKELY
TO
WORK
SEE
CHAPTER
OUR
PRESENTATION
IN
SECTIONS
AND
CLOSELY
FOLLOWS
THAT
IN
BOPPANA
AND
SIPSER
EXCELLENT
SURVEY
OF
CIRCUIT
COMPLEXITY
WHICH
IS
STILL
USEFUL
AND
CURRENT
YEARS
LATER
IT
OMITS
DISCUSSION
OF
LOWERBOUNDS
ON
ALGEBRAIC
CIRCUITS
SEE
FOR
A
RECENT
RESULT
H
ASTAD
SWITCHING
LEMMA
IS
A
STRONGER
FORM
OF
RESULTS
FROM
THE
RAZBOROV
SMOLENSKY
METHOD
OF
USING
APPROXIMATOR
POLYNOMIALS
IS
FROM
STRENGTH
ENED
IN
VALIANT
OBSERVATIONS
ABOUT
SUPERLINEAR
CIRCUIT
LOWERBOUNDS
ARE
FROM
A
PAPER
AND
AN
UNPUBLISHED
MANUSCRIPT
LACK
OF
PROGRESS
ON
THIS
BASIC
PROBLEM
GETS
MORE
EMBARRASSING
BY
THE
DAY
THE
O
N
LOWERBOUND
ON
GENERAL
CIRCUITS
IS
FROM
LACHISH
RAZ
EXERCISES
SUPPOSE
THAT
F
IS
COMPUTABLE
BY
AN
AC
CIRCUIT
C
OF
DEPTH
D
AND
SIZE
PROVE
THAT
F
IS
COMPUTABLE
BY
AN
AC
CIRCUIT
CI
OF
SIZE
AND
DEPTH
D
THAT
DOES
NOT
CONTAIN
NOT
GATES
BUT
INSTEAD
HAS
N
ADDITIONAL
INPUTS
THAT
ARE
NEGATIONS
OF
THE
ORIGINAL
N
INPUTS
SUPPOSE
THAT
F
IS
COMPUTABLE
BY
AN
AC
CIRCUIT
C
OF
DEPTH
D
AND
SIZE
PROVE
THAT
F
IS
COMPUTABLE
BY
AN
CI
CIRCUIT
OF
SIZE
D
AND
DEPTH
D
WHERE
EACH
GATE
HAS
FANOUT
PROVE
THAT
FOR
T
N
N
N
N
K
USE
THIS
TO
COMPLETE
THE
PROOF
OF
LEMMA
SHOW
THAT
IDENTIFY
REASONS
WHY
THE
RAZBOROV
SMOLENSKY
METHOD
DOES
NOT
WORK
WHEN
THE
CIRCUIT
HAS
MODM
GATES
WHERE
M
IS
A
COMPOSITE
NUMBER
SHOW
THAT
REPRESENTING
THE
OR
OF
N
VARIABLES
XN
EXACTLY
WITH
A
POLYNOMIAL
OVER
GF
Q
WHERE
Q
IS
PRIME
REQUIRES
DEGREE
EXACTLY
N
DRAFT
WEB
DRAFT
APPROACHES
USING
COMMUNICATION
COMPLEXITY
THE
KARCHMER
WIGDERSON
GAME
CAN
BE
USED
TO
PROVE
UPPERBOUNDS
AND
NOT
JUST
LOWERBOUNDS
SHOW
USING
THIS
GAME
THAT
PARITY
AND
MAJORITY
ARE
IN
SHOW
THAT
IF
A
LANGUAGE
IS
COMPUTED
BY
A
POLYNOMIAL
SIZE
BRANCHING
PROGRAM
OF
WIDTH
THEN
IT
IS
IN
PROVE
VALIANT
LEMMA
LEMMA
WEB
DRAFT
APPROACHES
USING
COMMUNICATION
COMPLEXITY
DRAFT
WEB
DRAFT
CHAPTER
ALGEBRAIC
COMPUTATION
MODELS
THE
TURING
MACHINE
MODEL
CAPTURES
COMPUTATIONS
ON
BITS
EQUIVALENTLY
INTEGERS
BUT
IT
DOES
NOT
ALWAYS
CAPTURE
THE
SPIRIT
OF
ALGORITHMS
WHICH
OPERATE
ON
SAY
THE
REAL
NUMBERS
R
OR
COMPLEX
NUM
BERS
C
SUCH
ALGORITHMS
ARISE
IN
A
VARIETY
OF
APPLICATIONS
SUCH
AS
NUMERICAL
ANALYSIS
COMPUTATIONAL
GEOMETRY
ROBOTICS
AND
SYMBOLIC
ALGEBRA
A
SIMPLE
EXAMPLE
IS
NEWTON
METHOD
FOR
FINDING
ROOTS
OF
A
GIVEN
REAL
VALUED
FUNCTION
FUNCTION
F
IT
ITERATIVELY
PRODUCES
A
SEQUENCE
OF
CANDIDATE
SOLUTIONS
R
WHERE
XI
XI
F
XI
F
I
XI
UNDER
APPROPRIATE
CONDITIONS
THIS
SEQUENCE
CAN
BE
SHOWN
TO
CONVERGE
TO
A
ROOT
OF
F
OF
COURSE
A
PERFECTLY
DEFENSIBLE
POSITION
TO
TAKE
IS
THAT
EVEN
THE
BEHAVIOR
OF
SUCH
ALGORITHMS
SHOULD
BE
STUDIED
USING
TMS
SINCE
THEY
WILL
BE
RUN
ON
REAL
LIFE
COMPUTERS
WHICH
REPRESENT
REAL
NUMBERS
USING
FINITE
PRECISION
IN
THIS
CHAPTER
THOUGH
WE
TAKE
A
DIFFERENT
APPROACH
AND
STUDY
MODELS
WHICH
DO
ALLOW
ARITHMETIC
OPERATIONS
ON
REAL
NUMBERS
OR
NUMBERS
FROM
FIELDS
OTHER
THAN
R
SUCH
AN
IDEALIZED
MODEL
MAY
NOT
BE
IMPLEMENTABLE
STRICTLY
SPEAKING
BUT
IT
PROVIDES
A
USEFUL
APPROXIMATION
TO
THE
ASYMPTOTIC
BEHAVIOR
AS
COMPUTERS
ARE
ALLOWED
TO
USE
MORE
AND
MORE
PRECISION
IN
THEIR
COMPUTATIONS
FURTHERMORE
ONE
MAY
BE
ABLE
TO
PROVE
NONTRIVIAL
LOWERBOUNDS
FOR
THESE
MODELS
USING
TECHNIQUES
FROM
WELL
DEVELOPED
AREAS
OF
MATHEMATICS
SUCH
AS
ALGEBRAIC
GEOMETRY
AND
TOPOLOGY
BY
CONTRAST
BOOLEAN
CIRCUIT
LOWERBOUNDS
HAVE
PROVEN
VERY
DIFFICULT
HOWEVER
COMING
UP
WITH
A
MEANINGFUL
WELL
BEHAVED
MODEL
OF
ALGEBRAIC
COMPUTATION
IS
NOT
AN
EASY
TASK
AS
THE
FOLLOWING
EXAMPLE
SUGGESTS
EXAMPLE
PITFALLS
AWAITING
DESIGNERS
OF
SUCH
MODELS
A
REAL
NUMBER
CAN
ENCODE
INFINITE
AMOUNT
OF
INFORMATION
FOR
EXAMPLE
A
SINGLE
REAL
NUMBER
IS
ENOUGH
TO
ENCODE
THE
ANSWER
TO
EVERY
INSTANCE
OF
SAT
OR
ANY
OTHER
LANGUAGE
IN
GENERAL
THUS
A
MODEL
THAT
CAN
STORE
ANY
REAL
NUMBER
WITH
INFINITE
PRECISION
MAY
NOT
BE
REALISTIC
SHAMIR
HAS
SHOWN
HOW
TO
FACTOR
ANY
INTEGER
N
IN
POLY
LOG
N
TIME
ON
A
COMPUTER
THAT
CAN
DO
REAL
ARITHMETIC
WITH
ARBITRARY
PRECISION
THE
USUAL
WAY
TO
AVOID
THIS
PITFALL
IS
TO
RESTRICT
THE
ALGORITHMS
ABILITY
TO
ACCESS
INDIVIDUAL
BITS
E
G
THE
MACHINE
MAY
REQUIRE
MORE
THAN
POLYNOMIAL
TIME
TO
EXTRACT
A
PARTICULAR
DIGIT
FROM
ALGEBRAIC
CIRCUITS
A
REAL
NUMBER
OR
SOMETIMES
AS
IN
CASE
OF
ALGEBRAIC
COMPUTATION
TREES
IT
IS
OK
TO
CONSIDER
UNREALISTICALLY
POWERFUL
MODELS
SINCE
THE
GOAL
IS
TO
PROVE
NONTRIVIAL
LOWERBOUNDS
SAY
SUPERLINEAR
OR
QUADRATIC
RATHER
THAN
ARBITRARY
POLYNOMIAL
LOWERBOUNDS
AFTER
ALL
LOWERBOUNDS
FOR
UNREALIS
TICALLY
POWERFUL
MODELS
WILL
APPLY
TO
MORE
REALISTIC
AND
WEAKER
MODELS
AS
WELL
THIS
CHAPTER
IS
A
SKETCHY
INTRODUCTION
TO
ALGEBRAIC
COMPLEXITY
IT
INTRODUCES
THREE
ALGEBRAIC
COMPUTATION
MODELS
ALGEBRAIC
CIRCUITS
ALGEBRAIC
COMPUTATION
TREES
AND
ALGEBRAIC
TURING
MA
CHINES
THE
ALGEBRAIC
TM
IS
CLOSELY
RELATED
TO
THE
STANDARD
TURING
MACHINE
MODEL
AND
ALLOWS
US
TO
STUDY
SIMILAR
QUESTIONS
FOR
ARBITRARY
FIELDS
INCLUDING
DECIDABILITY
AND
COMPLEXITY
THAT
WE
EARLIER
STUDIED
FOR
STRINGS
OVER
WE
INTRODUCE
AN
UNDECIDABLE
PROBLEM
NAMELY
DECIDING
MEMBERSHIP
IN
THE
MANDELBROT
SET
AND
AND
AN
NP
COMPLETE
PROBLEM
DECISION
VERSION
OF
HILBERT
NULLSTELLENSATZ
IN
THIS
MODEL
ALGEBRAIC
CIRCUITS
AN
ALGEBRAIC
CIRCUIT
OVER
A
FIELD
F
IS
DEFINED
BY
ANALOGY
WITH
A
BOOLEAN
CIRCUIT
IT
CONSISTS
OF
A
DIRECTED
ACYCLIC
GRAPH
THE
LEAVES
ARE
CALLED
INPUT
NODES
AND
LABELED
XN
EXCEPT
THESE
TAKE
VALUES
IN
A
FIELD
F
RATHER
THAN
BOOLEAN
VARIABLES
THERE
ARE
ALSO
SPECIAL
INPUT
NODES
LABELED
WITH
THE
CONSTANTS
AND
WHICH
ARE
FIELD
ELEMENTS
EACH
INTERNAL
NODE
CALLED
A
GATE
IS
LABELED
WITH
ONE
OF
THE
ARITHMETIC
OPERATIONS
RATHER
THAN
WITH
THE
BOOLEAN
OPERATIONS
USED
IN
BOOLEAN
CIRCUITS
THERE
IS
ONLY
OUTPUT
NODE
WE
RESTRICT
INDEGREE
OF
EACH
GATE
TO
THE
SIZE
OF
THE
CIRCUIT
IS
THE
NUMBER
OF
GATES
IN
IT
ONE
CAN
ALSO
CONSIDER
ALGEBRAIC
CIRCUITS
THAT
ALLOW
DIVISION
AT
THE
GATES
ONE
CAN
ALSO
STUDY
CIRCUITS
THAT
HAVE
ACCESS
TO
CONSTANTS
OTHER
THAN
THOUGH
TYPICALLY
ONE
ASSUMES
THAT
THIS
SET
IS
FIXED
AND
INDEPENDENT
OF
THE
INPUT
SIZE
N
FINALLY
AS
IN
THE
BOOLEAN
CASE
IF
EACH
GATE
HAS
OUTDEGREE
WE
CALL
IT
AN
ARITHMETIC
FORMULA
A
GATE
OPERATION
CONSISTS
OF
PERFORMING
THE
OPERATION
IT
IS
LABELED
WITH
ON
THE
NUMBERS
PRESENT
ON
THE
INCOMING
WIRES
AND
THEN
PASSING
THIS
OUTPUT
TO
ALL
ITS
OUTGOING
WIRES
AFTER
EACH
GATE
HAS
PERFORMED
ITS
OPERATION
AN
OUTPUT
APPEARS
ON
THE
CIRCUIT
LONE
OUTPUT
NODE
THUS
THE
CIRCUIT
MAY
BE
VIEWED
AS
A
COMPUTING
A
FUNCTION
F
XN
OF
THE
INPUT
VARIABLES
AND
SIMPLE
INDUCTION
SHOWS
THAT
THIS
OUTPUT
FUNCTION
IS
A
MULTIVARIATE
POLYNOMIAL
IN
XN
IF
WE
ALLOW
GATES
TO
ALSO
BE
LABELED
WITH
THE
DIVISION
OPERATION
DENOTED
THEN
THE
FUNCTION
IS
A
RATIONAL
FUNCTION
OF
XN
IN
OTHER
WORDS
FUNCTIONS
OF
THE
TYPE
XN
XN
WHERE
ARE
POLYNOMIALS
OF
COURSE
IF
THE
INPUTS
COME
FROM
A
FIELD
SUCH
AS
R
THEN
RATIONAL
FUNCTIONS
CAN
BE
USED
TO
APPROXIMATE
VIA
TAYLOR
SERIES
EXPANSION
ALL
SMOOTH
REAL
VALUED
FUNCTIONS
AS
USUAL
WE
ARE
INTERESTED
IN
THE
ASYMPTOTIC
SIZE
AS
A
FUNCTION
OF
N
OF
THE
SMALLEST
FAMILY
OF
ALGEBRAIC
CIRCUITS
THAT
COMPUTES
A
FAMILY
OF
POLYNOMIALS
FN
WHERE
FN
IS
A
POLYNOMIAL
IN
N
VARIABLES
THE
EXERCISES
ASK
YOU
TO
SHOW
THAT
CIRCUITS
OVER
GF
WITH
NO
ARE
EQUIVALENT
TO
BOOLEAN
CIRCUITS
AND
THE
SAME
IS
TRUE
FOR
CIRCUITS
OVER
ANY
FINITE
FIELD
SO
THE
CASE
WHEN
F
IS
INFINITE
IS
USUALLY
OF
GREATEST
INTEREST
COURSE
DESCRIPTION
CMPT
MACHINES
AND
ALGORITHMS
CLASS
TIME
AND
LOCATION
TUESDAY
AND
THURSDAY
IN
ARTS
BRIEF
LEARNING
OBJECTIVES
TO
LEARN
THE
MAJOR
METHODS
FOR
DESIGNING
ALGORITHMS
AND
THE
MAJOR
MATHEMATICAL
MODELS
OF
COMPUTATION
STUDENT
EVALUATION
GRADING
SCHEME
ASSIGNMENTS
MIDTERM
FINAL
EXAMINATION
NOTE
ALL
STUDENTS
MUST
BE
PROPERLY
REGISTERED
IN
ORDER
TO
ATTEND
LECTURES
AND
RECEIVE
CREDIT
FOR
THIS
COURSE
FINAL
EXAM
SCHEDULING
THE
REGISTRAR
SCHEDULES
ALL
FINAL
EXAMINATIONS
INCLUDING
DEFERRED
AND
SUPPLEMENTAL
EXAMINATIONS
STUDENTS
ARE
ADVISED
NOT
TO
MAKE
TRAVEL
ARRANGEMENTS
FOR
THE
EXAM
PERIOD
UNTIL
THE
OFFICIAL
EXAM
SCHEDULE
HAS
BEEN
POSTED
NOTE
ALL
STUDENTS
MUST
BE
PROPERLY
REGISTERED
IN
ORDER
TO
ATTEND
LECTURES
AND
RECEIVE
CREDIT
FOR
THIS
COURSE
TEXTBOOK
INFORMATION
REQUIRED
TEXT
ALGORITHM
DESIGN
BY
KLEINBERG
AND
TARDOS
RECOMMENDED
TEXTS
ELEMENTS
OF
THE
THEORY
OF
COMPUTATION
PAPADIMITRIOU
LECTURE
TOPICS
I
ALGORITHMS
O
GRAPH
ALGORITHMS
O
GREEDY
ALGORITHMS
O
DIVIDE
AND
CONQUER
O
DYNAMIC
PROGRAMMING
O
NP
COMPLETENESS
AND
COMPUTATIONAL
INTRACTABILITY
O
HANDLING
HARD
PROBLEMS
II
MACHINES
O
FINITE
AUTOMATA
O
NONDETERMINISTIC
FINITE
AUTOMATA
O
REGULAR
LANGUAGES
O
CONTEXT
FREE
LANGUAGES
O
PUSHDOWN
AUTOMATA
O
TURING
MACHINES
POLICIES
MISSED
EXAMINATIONS
STUDENTS
WHO
HAVE
MISSED
AN
EXAM
OR
ASSIGNMENT
MUST
CONTACT
THEIR
INSTRUCTOR
AS
SOON
AS
POSSIBLE
ARRANGEMENTS
TO
MAKE
UP
THE
EXAM
MAY
BE
ARRANGED
WITH
THE
INSTRUCTOR
MISSED
EXAMS
THROUGHOUT
THE
YEAR
ARE
LEFT
UP
TO
THE
DISCRETION
OF
THE
INSTRUCTOR
IF
A
STUDENT
MAY
MAKE
UP
THE
EXAM
OR
WRITE
AT
A
DIFFERENT
TIME
IF
A
STUDENT
KNOWS
PRIOR
TO
THE
EXAM
THAT
SHE
HE
WILL
NOT
BE
ABLE
TO
ATTEND
THEY
SHOULD
LET
THE
INSTRUCTOR
KNOW
BEFORE
THE
EXAM
FINAL
EXAMS
A
STUDENT
WHO
IS
ABSENT
FROM
A
FINAL
EXAMINATION
THROUGH
NO
FAULT
OF
HIS
OR
HER
OWN
FOR
MEDICAL
OR
OTHER
VALID
REASONS
MAY
APPLY
TO
THE
COLLEGE
OF
ARTS
AND
SCIENCE
DEAN
OFFICE
THE
APPLICATION
MUST
BE
MADE
WITHIN
THREE
DAYS
OF
THE
MISSED
EXAMINATION
ALONG
WITH
SUPPORTING
DOCUMENTARY
EVIDENCE
DEFERRED
EXAMS
ARE
WRITTEN
DURING
THE
FEBRUARY
MID
TERM
BREAK
FOR
TERM
COURSES
AND
IN
EARLY
JUNE
FOR
TERM
AND
FULL
YEAR
COURSES
HTTP
WWW
ARTS
USASK
CA
STUDENTS
TRANSITION
TIPS
PHP
INCOMPLETE
COURSE
WORK
AND
FINAL
GRADES
WHEN
A
STUDENT
HAS
NOT
COMPLETED
THE
REQUIRED
COURSE
WORK
WHICH
INCLUDES
ANY
ASSIGNMENT
OR
EXAMINATION
INCLUDING
THE
FINAL
EXAMINATION
BY
THE
TIME
OF
SUBMISSION
OF
THE
FINAL
GRADES
THEY
MAY
BE
GRANTED
AN
EXTENSION
TO
PERMIT
COMPLETION
OF
AN
ASSIGNMENT
OR
GRANTED
A
DEFERRED
EXAMINATION
IN
THE
CASE
OF
ABSENCE
FROM
A
FINAL
EXAMINATION
EXTENSIONS
FOR
THE
COMPLETION
OF
ASSIGNMENTS
MUST
BE
APPROVED
BY
THE
DEPARTMENT
HEAD
OR
DEAN
IN
NON
DEPARTMENTALIZED
COLLEGES
AND
MAY
EXCEED
THIRTY
DAYS
ONLY
IN
UNUSUAL
CIRCUMSTANCES
THE
STUDENT
MUST
APPLY
TO
THE
INSTRUCTOR
FOR
SUCH
AN
EXTENSION
AND
FURNISH
SATISFACTORY
REASONS
FOR
THE
DEFICIENCY
DEFERRED
FINAL
EXAMINATIONS
ARE
GRANTED
AS
PER
COLLEGE
POLICY
IN
THE
INTERIM
THE
INSTRUCTOR
WILL
SUBMIT
A
COMPUTED
PERCENTILE
GRADE
FOR
THE
COURSE
WHICH
FACTORS
IN
THE
INCOMPLETE
COURSE
WORK
AS
A
ZERO
ALONG
WITH
A
GRADE
COMMENT
OF
INF
INCOMPLETE
FAILURE
IF
A
FAILING
GRADE
IN
THE
CASE
WHERE
THE
INSTRUCTOR
HAS
INDICATED
IN
THE
COURSE
OUTLINE
THAT
FAILURE
TO
COMPLETE
THE
REQUIRED
COURSE
WORK
WILL
RESULT
IN
FAILURE
IN
THE
COURSE
AND
THE
STUDENT
HAS
A
COMPUTED
PASSING
PERCENTILE
GRADE
A
FINAL
GRADE
OF
WILL
BE
SUBMITTED
ALONG
WITH
A
GRADE
COMMENT
OF
INF
INCOMPLETE
FAILURE
IF
AN
EXTENSION
IS
GRANTED
AND
THE
REQUIRED
ASSIGNMENT
IS
SUBMITTED
WITHIN
THE
ALLOTTED
TIME
OR
IF
A
DEFERRED
EXAMINATION
IS
GRANTED
AND
WRITTEN
IN
THE
CASE
OF
ABSENCE
FROM
THE
FINAL
EXAMINATION
THE
INSTRUCTOR
WILL
SUBMIT
A
REVISED
COMPUTED
FINAL
PERCENTAGE
GRADE
THE
GRADE
CHANGE
WILL
REPLACE
THE
PREVIOUS
GRADE
AND
ANY
GRADE
COMMENT
OF
INF
INCOMPLETE
FAILURE
WILL
BE
REMOVED
FOR
PROVISIONS
GOVERNING
EXAMINATIONS
AND
GRADING
STUDENTS
ARE
REFERRED
TO
THE
UNIVERSITY
COUNCIL
REGULATIONS
ON
EXAMINATIONS
SECTION
OF
THE
CALENDAR
UNIVERSITY
OF
SASKATCHEWAN
CALENDAR
ACADEMIC
COURSES
POLICY
ACADEMIC
HONESTY
THE
UNIVERSITY
OF
SASKATCHEWAN
IS
COMMITTED
TO
THE
HIGHEST
STANDARDS
OF
ACADEMIC
INTEGRITY
AND
HONESTY
STUDENTS
ARE
EXPECTED
TO
BE
FAMILIAR
WITH
THESE
STANDARDS
REGARDING
ACADEMIC
HONESTY
AND
TO
UPHOLD
THE
POLICIES
OF
THE
UNIVERSITY
IN
THIS
RESPECT
STUDENTS
ARE
PARTICULARLY
URGED
TO
FAMILIARIZE
THEMSELVES
WITH
THE
PROVISIONS
OF
THE
STUDENT
CONDUCT
APPEALS
SECTION
OF
THE
UNIVERSITY
SECRETARY
WEBSITE
AND
AVOID
ANY
BEHAVIOR
THAT
COULD
POTENTIALLY
RESULT
IN
SUSPICIONS
OF
CHEATING
PLAGIARISM
MISREPRESENTATION
OF
FACTS
AND
OR
PARTICIPATION
IN
AN
OFFENCE
ACADEMIC
DISHONESTY
IS
A
SERIOUS
OFFENCE
AND
CAN
RESULT
IN
SUSPENSION
OR
EXPULSION
FROM
THE
UNIVERSITY
ALL
STUDENTS
SHOULD
READ
AND
BE
FAMILIAR
WITH
THE
REGULATIONS
ON
ACADEMIC
STUDENT
MISCONDUCT
HTTP
WWW
USASK
CA
SECRETARIAT
STUDENT
CONDUCT
APPEALS
STUDENTACADEMICMISCONDUCT
PDF
AS
WELL
AS
THE
STANDARD
OF
STUDENT
CONDUCT
IN
NON
ACADEMIC
MATTERS
AND
PROCEDURES
FOR
RESOLUTION
OF
COMPLAINTS
AND
APPEALS
HTTP
WWW
USASK
CA
SECRETARIAT
STUDENT
CONDUCT
APPEALS
STUDENTNON
ACADEMICMISCONDUCT
PDF
ACADEMIC
HONESTY
IS
ALSO
DEFINED
AND
DESCRIBED
IN
THE
DEPARTMENT
OF
COMPUTER
SCIENCE
STATEMENT
ON
ACADEMIC
HONESTY
HTTP
WWW
CS
USASK
CA
UNDERGRAD
HONESTY
PHP
FOR
MORE
INFORMATION
ON
WHAT
ACADEMIC
INTEGRITY
MEANS
FOR
STUDENTS
SEE
THE
STUDENT
CONDUCT
APPEALS
SECTION
OF
THE
UNIVERSITY
SECRETARY
WEBSITE
AT
HTTP
WWW
USASK
CA
SECRETARIAT
STUDENT
CONDUCT
APPEALS
FORMS
INTEGRITYDEFINED
PDF
EXAMINATIONS
WITH
DISABILITY
SERVICES
FOR
STUDENTS
DSS
STUDENTS
WHO
HAVE
DISABILITIES
LEARNING
MEDICAL
PHYSICAL
OR
MENTAL
HEALTH
ARE
STRONGLY
ENCOURAGED
TO
REGISTER
WITH
DISABILITY
SERVICES
FOR
STUDENTS
DSS
IF
THEY
HAVE
NOT
ALREADY
DONE
SO
STUDENTS
WHO
SUSPECT
THEY
MAY
HAVE
DISABILITIES
SHOULD
CONTACT
DSS
FOR
ADVICE
AND
REFERRALS
IN
ORDER
TO
ACCESS
DSS
PROGRAMS
AND
SUPPORTS
STUDENTS
MUST
FOLLOW
DSS
POLICY
AND
PROCEDURES
FOR
MORE
INFORMATION
CHECK
HTTP
WWW
STUDENTS
USASK
CA
DISABILITY
OR
CONTACT
DSS
AT
OR
DSS
USASK
CA
STUDENTS
REGISTERED
WITH
DSS
MAY
REQUEST
ALTERNATIVE
ARRANGEMENTS
FOR
MID
TERM
AND
FINAL
EXAMINATIONS
STUDENTS
MUST
ARRANGE
SUCH
ACCOMMODATIONS
THROUGH
DSS
BY
THE
STATED
DEADLINES
INSTRUCTORS
SHALL
PROVIDE
THE
EXAMINATIONS
FOR
STUDENTS
WHO
ARE
BEING
ACCOMMODATED
BY
THE
DEADLINES
ESTABLISHED
BY
DSS
COURSE
DESCRIPTION
CMPT
ADVANCED
ALGORITHMS
CLASS
TIME
AND
LOCATION
MWF
IN
GEOLOGY
BRIEF
LEARNING
OBJECTIVES
TO
LEARN
AND
BE
ABLE
TO
APPLY
NETWORK
WORK
FLOW
ALGORITHMS
TO
LEARN
AND
BE
ABLE
TO
CREATE
COMPUTATIONAL
GEOMETRY
ALGORITHMS
TO
LEARN
AND
BE
ABLE
TO
APPLY
AND
CREATE
SOME
ADVANCED
GRAPH
ALGORITHMS
TO
LEARN
AND
BE
ABLE
TO
APPLY
SOME
PARALLEL
ALGORITHMS
STUDENT
EVALUATION
GRADING
SCHEME
ASSIGNMENTS
PROJECT
CMPT
FINAL
EXAMINATION
CMPT
NOTE
ALL
STUDENTS
MUST
BE
PROPERLY
REGISTERED
IN
ORDER
TO
ATTEND
LECTURES
AND
RECEIVE
CREDIT
FOR
THIS
COURSE
FINAL
EXAM
SCHEDULING
THE
REGISTRAR
SCHEDULES
ALL
FINAL
EXAMINATIONS
INCLUDING
DEFERRED
AND
SUPPLEMENTAL
EXAMINATIONS
STUDENTS
ARE
ADVISED
NOT
TO
MAKE
TRAVEL
ARRANGEMENTS
FOR
THE
EXAM
PERIOD
UNTIL
THE
OFFICIAL
EXAM
SCHEDULE
HAS
BEEN
POSTED
NOTE
ALL
STUDENTS
MUST
BE
PROPERLY
REGISTERED
IN
ORDER
TO
ATTEND
LECTURES
AND
RECEIVE
CREDIT
FOR
THIS
COURSE
TEXTBOOK
INFORMATION
TEXTBOOK
COMPUTATIONAL
GEOMETRY
ALGORITHMS
AND
APPLICATIONS
ED
DE
BERG
CHEONG
VAN
KREVELD
OVERMARS
THIS
BOOK
IS
AVAILABLE
AS
AN
ONLINE
BOOK
THROUGH
THE
LIBRARY
WEBSITE
OUTLINE
AUGMENTING
ALGORITHMS
O
NETWORK
FLOW
ALGORITHMS
O
MATCHING
COMPUTATIONAL
GEOMETRY
O
CONVEX
HULLS
O
LINE
SEGMENT
INTERSECTION
O
TRIANGULATIONS
O
LINEAR
PROGRAMMING
O
ORTHOGONAL
RANGE
SEARCHING
O
POINT
LOCATION
O
VORONOI
DIAGRAMS
O
ARRANGEMENTS
AND
DUALITY
O
DELAUNAY
TRIANGULATIONS
O
GEOMETRIC
DATA
STRUCTURES
GRAPH
ALGORITHMS
O
ALGORITHMS
ON
SPECIAL
CLASSES
OF
GRAPHS
PARALLEL
ALGORITHMS
STUDENT
PRESENTATIONS
POLICIES
MISSED
EXAMINATIONS
STUDENTS
WHO
HAVE
MISSED
AN
EXAM
OR
ASSIGNMENT
MUST
CONTACT
THEIR
INSTRUCTOR
AS
SOON
AS
POSSIBLE
ARRANGEMENTS
TO
MAKE
UP
THE
EXAM
MAY
BE
ARRANGED
WITH
THE
INSTRUCTOR
MISSED
EXAMS
THROUGHOUT
THE
YEAR
ARE
LEFT
UP
TO
THE
DISCRETION
OF
THE
INSTRUCTOR
IF
A
STUDENT
MAY
MAKE
UP
THE
EXAM
OR
WRITE
AT
A
DIFFERENT
TIME
IF
A
STUDENT
KNOWS
PRIOR
TO
THE
EXAM
THAT
SHE
HE
WILL
NOT
BE
ABLE
TO
ATTEND
THEY
SHOULD
LET
THE
INSTRUCTOR
KNOW
BEFORE
THE
EXAM
FINAL
EXAMS
A
STUDENT
WHO
IS
ABSENT
FROM
A
FINAL
EXAMINATION
THROUGH
NO
FAULT
OF
HIS
OR
HER
OWN
FOR
MEDICAL
OR
OTHER
VALID
REASONS
MAY
APPLY
TO
THE
COLLEGE
OF
ARTS
AND
SCIENCE
DEAN
OFFICE
THE
APPLICATION
MUST
BE
MADE
WITHIN
THREE
DAYS
OF
THE
MISSED
EXAMINATION
ALONG
WITH
SUPPORTING
DOCUMENTARY
EVIDENCE
DEFERRED
EXAMS
ARE
WRITTEN
DURING
THE
FEBRUARY
MID
TERM
BREAK
FOR
TERM
COURSES
AND
IN
EARLY
JUNE
FOR
TERM
AND
FULL
YEAR
COURSES
HTTP
ARTSANDSCIENCE
USASK
CA
UNDERGRADUATE
ADVISING
STRATEGIES
PHP
INCOMPLETE
COURSE
WORK
AND
FINAL
GRADES
WHEN
A
STUDENT
HAS
NOT
COMPLETED
THE
REQUIRED
COURSE
WORK
WHICH
INCLUDES
ANY
ASSIGNMENT
OR
EXAMINATION
INCLUDING
THE
FINAL
EXAMINATION
BY
THE
TIME
OF
SUBMISSION
OF
THE
FINAL
GRADES
THEY
MAY
BE
GRANTED
AN
EXTENSION
TO
PERMIT
COMPLETION
OF
AN
ASSIGNMENT
OR
GRANTED
A
DEFERRED
EXAMINATION
IN
THE
CASE
OF
ABSENCE
FROM
A
FINAL
EXAMINATION
EXTENSIONS
FOR
THE
COMPLETION
OF
ASSIGNMENTS
MUST
BE
APPROVED
BY
THE
DEPARTMENT
HEAD
OR
DEAN
IN
NON
DEPARTMENTALIZED
COLLEGES
AND
MAY
EXCEED
THIRTY
DAYS
ONLY
IN
UNUSUAL
CIRCUMSTANCES
THE
STUDENT
MUST
APPLY
TO
THE
INSTRUCTOR
FOR
SUCH
AN
EXTENSION
AND
FURNISH
SATISFACTORY
REASONS
FOR
THE
DEFICIENCY
DEFERRED
FINAL
EXAMINATIONS
ARE
GRANTED
AS
PER
COLLEGE
POLICY
IN
THE
INTERIM
THE
INSTRUCTOR
WILL
SUBMIT
A
COMPUTED
PERCENTILE
GRADE
FOR
THE
COURSE
WHICH
FACTORS
IN
THE
INCOMPLETE
COURSE
WORK
AS
A
ZERO
ALONG
WITH
A
GRADE
COMMENT
OF
INF
INCOMPLETE
FAILURE
IF
A
FAILING
GRADE
IN
THE
CASE
WHERE
THE
INSTRUCTOR
HAS
INDICATED
IN
THE
COURSE
OUTLINE
THAT
FAILURE
TO
COMPLETE
THE
REQUIRED
COURSE
WORK
WILL
RESULT
IN
FAILURE
IN
THE
COURSE
AND
THE
STUDENT
HAS
A
COMPUTED
PASSING
PERCENTILE
GRADE
A
FINAL
GRADE
OF
WILL
BE
SUBMITTED
ALONG
WITH
A
GRADE
COMMENT
OF
INF
INCOMPLETE
FAILURE
IF
AN
EXTENSION
IS
GRANTED
AND
THE
REQUIRED
ASSIGNMENT
IS
SUBMITTED
WITHIN
THE
ALLOTTED
TIME
OR
IF
A
DEFERRED
EXAMINATION
IS
GRANTED
AND
WRITTEN
IN
THE
CASE
OF
ABSENCE
FROM
THE
FINAL
EXAMINATION
THE
INSTRUCTOR
WILL
SUBMIT
A
REVISED
COMPUTED
FINAL
PERCENTAGE
GRADE
THE
GRADE
CHANGE
WILL
REPLACE
THE
PREVIOUS
GRADE
AND
ANY
GRADE
COMMENT
OF
INF
INCOMPLETE
FAILURE
WILL
BE
REMOVED
FOR
PROVISIONS
GOVERNING
EXAMINATIONS
AND
GRADING
STUDENTS
ARE
REFERRED
TO
THE
UNIVERSITY
COUNCIL
REGULATIONS
ON
EXAMINATIONS
SECTION
OF
THE
CALENDAR
UNIVERSITY
OF
SASKATCHEWAN
CALENDAR
ACADEMIC
COURSES
POLICY
ACADEMIC
HONESTY
THE
UNIVERSITY
OF
SASKATCHEWAN
IS
COMMITTED
TO
THE
HIGHEST
STANDARDS
OF
ACADEMIC
INTEGRITY
AND
HONESTY
STUDENTS
ARE
EXPECTED
TO
BE
FAMILIAR
WITH
THESE
STANDARDS
REGARDING
ACADEMIC
HONESTY
AND
TO
UPHOLD
THE
POLICIES
OF
THE
UNIVERSITY
IN
THIS
RESPECT
STUDENTS
ARE
PARTICULARLY
URGED
TO
FAMILIARIZE
THEMSELVES
WITH
THE
PROVISIONS
OF
THE
STUDENT
CONDUCT
APPEALS
SECTION
OF
THE
UNIVERSITY
SECRETARY
WEBSITE
AND
AVOID
ANY
BEHAVIOR
THAT
COULD
POTENTIALLY
RESULT
IN
SUSPICIONS
OF
CHEATING
PLAGIARISM
MISREPRESENTATION
OF
FACTS
AND
OR
PARTICIPATION
IN
AN
OFFENCE
ACADEMIC
DISHONESTY
IS
A
SERIOUS
OFFENCE
AND
CAN
RESULT
IN
SUSPENSION
OR
EXPULSION
FROM
THE
UNIVERSITY
ALL
STUDENTS
SHOULD
READ
AND
BE
FAMILIAR
WITH
THE
REGULATIONS
ON
ACADEMIC
STUDENT
MISCONDUCT
HTTP
WWW
USASK
CA
SECRETARIAT
STUDENT
CONDUCT
APPEALS
STUDENTACADEMICMISCONDUCT
PDF
AS
WELL
AS
THE
STANDARD
OF
STUDENT
CONDUCT
IN
NON
ACADEMIC
MATTERS
AND
PROCEDURES
FOR
RESOLUTION
OF
COMPLAINTS
AND
APPEALS
HTTP
WWW
USASK
CA
SECRETARIAT
STUDENT
CONDUCT
APPEALS
STUDENTNON
ACADEMICMISCONDUCT
PDF
ACADEMIC
HONESTY
IS
ALSO
DEFINED
AND
DESCRIBED
IN
THE
DEPARTMENT
OF
COMPUTER
SCIENCE
STATEMENT
ON
ACADEMIC
HONESTY
HTTP
WWW
CS
USASK
CA
UNDERGRAD
HONESTY
PHP
FOR
MORE
INFORMATION
ON
WHAT
ACADEMIC
INTEGRITY
MEANS
FOR
STUDENTS
SEE
THE
STUDENT
CONDUCT
APPEALS
SECTION
OF
THE
UNIVERSITY
SECRETARY
WEBSITE
AT
HTTP
WWW
USASK
CA
SECRETARIAT
STUDENT
CONDUCT
APPEALS
FORMS
INTEGRITYDEFINED
PDF
EXAMINATIONS
WITH
DISABILITY
SERVICES
FOR
STUDENTS
DSS
STUDENTS
WHO
HAVE
DISABILITIES
LEARNING
MEDICAL
PHYSICAL
OR
MENTAL
HEALTH
ARE
STRONGLY
ENCOURAGED
TO
REGISTER
WITH
DISABILITY
SERVICES
FOR
STUDENTS
DSS
IF
THEY
HAVE
NOT
ALREADY
DONE
SO
STUDENTS
WHO
SUSPECT
THEY
MAY
HAVE
DISABILITIES
SHOULD
CONTACT
DSS
FOR
ADVICE
AND
REFERRALS
IN
ORDER
TO
ACCESS
DSS
PROGRAMS
AND
SUPPORTS
STUDENTS
MUST
FOLLOW
DSS
POLICY
AND
PROCEDURES
FOR
MORE
INFORMATION
CHECK
HTTP
WWW
STUDENTS
USASK
CA
DISABILITY
OR
CONTACT
DSS
AT
OR
DSS
USASK
CA
STUDENTS
REGISTERED
WITH
DSS
MAY
REQUEST
ALTERNATIVE
ARRANGEMENTS
FOR
MID
TERM
AND
FINAL
EXAMINATIONS
STUDENTS
MUST
ARRANGE
SUCH
ACCOMMODATIONS
THROUGH
DSS
BY
THE
STATED
DEADLINES
INSTRUCTORS
SHALL
PROVIDE
THE
EXAMINATIONS
FOR
STUDENTS
WHO
ARE
BEING
ACCOMMODATED
BY
THE
DEADLINES
ESTABLISHED
BY
DSS
COMPUTATIONAL
GEOMETRY
INTRODUCTION
IMAGINE
YOU
ARE
WALKING
ON
THE
CAMPUS
OF
A
UNIVERSITY
AND
SUDDENLY
YOU
REALIZE
YOU
HAVE
TO
MAKE
AN
URGENT
PHONE
CALL
THERE
ARE
MANY
PUBLIC
PHONES
ON
CAMPUS
AND
OF
COURSE
YOU
WANT
TO
GO
TO
THE
NEAREST
ONE
BUT
WHICH
ONE
IS
THE
NEAREST
IT
WOULD
BE
HELPFUL
TO
HAVE
A
MAP
ON
WHICH
YOU
COULD
LOOK
UP
THE
NEAREST
PUBLIC
PHONE
WHEREVER
ON
CAMPUS
YOU
ARE
THE
MAP
SHOULD
SHOW
A
SUBDIVISION
OF
THE
CAMPUS
INTO
REGIONS
AND
FOR
EACH
REGION
INDICATE
THE
NEAREST
PUBLIC
PHONE
WHAT
WOULD
THESE
REGIONS
LOOK
LIKE
AND
HOW
COULD
WE
COMPUTE
THEM
EVEN
THOUGH
THIS
IS
NOT
SUCH
A
TERRIBLY
IMPORTANT
ISSUE
IT
DESCRIBES
THE
BASICS
OF
A
FUNDAMENTAL
GEOMETRIC
CONCEPT
WHICH
PLAYS
A
ROLE
IN
MANY
APPLICATIONS
THE
SUBDIVISION
OF
THE
CAMPUS
IS
A
SO
CALLED
VORONOI
DIAGRAM
AND
IT
WILL
BE
STUDIED
IN
CHAPTER
IN
THIS
BOOK
IT
CAN
BE
USED
TO
MODEL
TRADING
AREAS
OF
DIFFERENT
CITIES
TO
GUIDE
ROBOTS
AND
EVEN
TO
DESCRIBE
AND
SIMULATE
THE
GROWTH
OF
CRYSTALS
COMPUTING
A
GEOMETRIC
STRUCTURE
LIKE
A
VORONOI
DIAGRAM
REQUIRES
GEOMETRIC
ALGORITHMS
SUCH
ALGORITHMS
FORM
THE
TOPIC
OF
THIS
BOOK
A
SECOND
EXAMPLE
ASSUME
YOU
LOCATED
THE
CLOSEST
PUBLIC
PHONE
WITH
A
CAMPUS
MAP
IN
HAND
YOU
WILL
PROBABLY
HAVE
LITTLE
PROBLEM
IN
GETTING
TO
THE
PHONE
ALONG
A
REASONABLY
SHORT
PATH
WITHOUT
HITTING
WALLS
AND
OTHER
OBJECTS
BUT
PROGRAMMING
A
ROBOT
TO
PERFORM
THE
SAME
TASK
IS
A
LOT
MORE
DIFFICULT
AGAIN
THE
HEART
OF
THE
PROBLEM
IS
GEOMETRIC
GIVEN
A
COLLECTION
OF
GEOMETRIC
OBSTACLES
WE
HAVE
TO
FIND
A
SHORT
CONNECTION
BETWEEN
TWO
POINTS
AVOIDING
COLLISIONS
WITH
THE
OBSTACLES
SOLVING
THIS
SO
CALLED
MOTION
PLANNING
PROBLEM
IS
OF
CRUCIAL
IMPORTANCE
IN
ROBOTICS
CHAPTERS
AND
DEAL
WITH
GEOMETRIC
ALGORITHMS
REQUIRED
FOR
MOTION
PLANNING
A
THIRD
EXAMPLE
ASSUME
YOU
DON
T
HAVE
ONE
MAP
BUT
TWO
ONE
WITH
A
DESCRIPTION
OF
THE
VARIOUS
BUILDINGS
INCLUDING
THE
PUBLIC
PHONES
AND
ONE
INDICATING
THE
ROADS
ON
THE
CAMPUS
TO
PLAN
A
MOTION
TO
THE
PUBLIC
PHONE
WE
HAVE
TO
OVERLAY
THESE
MAPS
THAT
IS
WE
HAVE
TO
COMBINE
THE
INFORMATION
IN
THE
TWO
MAPS
OVERLAYING
MAPS
IS
ONE
OF
THE
BASIC
OPERATIONS
OF
GEOGRAPHIC
INFORMATION
SYSTEMS
IT
INVOLVES
LOCATING
THE
POSITION
OF
OBJECTS
FROM
ONE
MAP
IN
THE
OTHER
COMPUTING
THE
INTERSECTION
OF
VARIOUS
FEATURES
AND
SO
ON
CHAPTER
DEALS
WITH
THIS
PROBLEM
CHAPTER
COMPUTATIONAL
GEOMETRY
CONVEX
NOT
CONVEX
THESE
ARE
JUST
THREE
EXAMPLES
OF
GEOMETRIC
PROBLEMS
REQUIRING
CAREFULLY
DE
SIGNED
GEOMETRIC
ALGORITHMS
FOR
THEIR
SOLUTION
IN
THE
THE
FIELD
OF
COMPU
TATIONAL
GEOMETRY
EMERGED
DEALING
WITH
SUCH
GEOMETRIC
PROBLEMS
IT
CAN
BE
DEFINED
AS
THE
SYSTEMATIC
STUDY
OF
ALGORITHMS
AND
DATA
STRUCTURES
FOR
GEOMETRIC
OBJECTS
WITH
A
FOCUS
ON
EXACT
ALGORITHMS
THAT
ARE
ASYMPTOTICALLY
FAST
MANY
RESEARCHERS
WERE
ATTRACTED
BY
THE
CHALLENGES
POSED
BY
THE
GEOMETRIC
PROBLEMS
THE
ROAD
FROM
PROBLEM
FORMULATION
TO
EFFICIENT
AND
ELEGANT
SOLUTIONS
HAS
OFTEN
BEEN
LONG
WITH
MANY
DIFFICULT
AND
SUB
OPTIMAL
INTERMEDIATE
RESULTS
TODAY
THERE
IS
A
RICH
COLLECTION
OF
GEOMETRIC
ALGORITHMS
THAT
ARE
EFFICIENT
AND
RELATIVELY
EASY
TO
UNDERSTAND
AND
IMPLEMENT
THIS
BOOK
DESCRIBES
THE
MOST
IMPORTANT
NOTIONS
TECHNIQUES
ALGORITHMS
AND
DATA
STRUCTURES
FROM
COMPUTATIONAL
GEOMETRY
IN
A
WAY
THAT
WE
HOPE
WILL
BE
ATTRACTIVE
TO
READERS
WHO
ARE
INTERESTED
IN
APPLYING
RESULTS
FROM
COMPUTATIONAL
GEOMETRY
EACH
CHAPTER
IS
MOTIVATED
WITH
A
REAL
COMPUTATIONAL
PROBLEM
THAT
REQUIRES
GEOMETRIC
ALGORITHMS
FOR
ITS
SOLUTION
TO
SHOW
THE
WIDE
APPLICABILITY
OF
COMPUTATIONAL
GEOMETRY
THE
PROBLEMS
WERE
TAKEN
FROM
VARIOUS
APPLICATION
AREAS
ROBOTICS
COMPUTER
GRAPHICS
CAD
CAM
AND
GEOGRAPHIC
INFORMATION
SYSTEMS
YOU
SHOULD
NOT
EXPECT
READY
TO
IMPLEMENT
SOFTWARE
SOLUTIONS
FOR
MAJOR
PROBLEMS
IN
THE
APPLICATION
AREAS
EVERY
CHAPTER
DEALS
WITH
A
SINGLE
CONCEPT
IN
COMPUTATIONAL
GEOMETRY
THE
APPLICATIONS
ONLY
SERVE
TO
INTRODUCE
AND
MOTIVATE
THE
CONCEPTS
THEY
ALSO
ILLUSTRATE
THE
PROCESS
OF
MODELING
AN
ENGINEERING
PROBLEM
AND
FINDING
AN
EXACT
SOLUTION
AN
EXAMPLE
CONVEX
HULLS
GOOD
SOLUTIONS
TO
ALGORITHMIC
PROBLEMS
OF
A
GEOMETRIC
NATURE
ARE
MOSTLY
BASED
ON
TWO
INGREDIENTS
ONE
IS
A
THOROUGH
UNDERSTANDING
OF
THE
GEOMETRIC
PROPERTIES
OF
THE
PROBLEM
THE
OTHER
IS
A
PROPER
APPLICATION
OF
ALGORITHMIC
TECHNIQUES
AND
DATA
STRUCTURES
IF
YOU
DON
T
UNDERSTAND
THE
GEOMETRY
OF
THE
PROBLEM
ALL
THE
ALGORITHMS
OF
THE
WORLD
WON
T
HELP
YOU
TO
SOLVE
IT
EFFICIENTLY
ON
THE
OTHER
HAND
EVEN
IF
YOU
PERFECTLY
UNDERSTAND
THE
GEOMETRY
OF
THE
PROBLEM
IT
IS
HARD
TO
SOLVE
IT
EFFECTIVELY
IF
YOU
DON
T
KNOW
THE
RIGHT
ALGORITHMIC
TECHNIQUES
THIS
BOOK
WILL
GIVE
YOU
A
THOROUGH
UNDERSTANDING
OF
THE
MOST
IMPORTANT
GEOMETRIC
CONCEPTS
AND
ALGORITHMIC
TECHNIQUES
TO
ILLUSTRATE
THE
ISSUES
THAT
ARISE
IN
DEVELOPING
A
GEOMETRIC
ALGORITHM
THIS
SECTION
DEALS
WITH
ONE
OF
THE
FIRST
PROBLEMS
THAT
WAS
STUDIED
IN
COMPUTATIONAL
GEOMETRY
THE
COMPUTATION
OF
PLANAR
CONVEX
HULLS
WE
LL
SKIP
THE
MOTIVATION
FOR
THIS
PROBLEM
HERE
IF
YOU
ARE
INTERESTED
YOU
CAN
READ
THE
INTRODUCTION
TO
CHAPTER
WHERE
WE
STUDY
CONVEX
HULLS
IN
DIMENSIONAL
SPACE
A
SUBSET
OF
THE
PLANE
IS
CALLED
CONVEX
IF
AND
ONLY
IF
FOR
ANY
PAIR
OF
POINTS
P
Q
THE
LINE
SEGMENT
PQ
IS
COMPLETELY
CONTAINED
IN
THE
CONVEX
HULL
CH
OF
A
SET
IS
THE
SMALLEST
CONVEX
SET
THAT
CONTAINS
TO
BE
MORE
PRECISE
IT
IS
THE
INTERSECTION
OF
ALL
CONVEX
SETS
THAT
CONTAIN
WE
WILL
STUDY
THE
PROBLEM
OF
COMPUTING
THE
CONVEX
HULL
OF
A
FINITE
SET
P
OF
N
POINTS
IN
THE
PLANE
WE
CAN
VISUALIZE
WHAT
THE
CONVEX
HULL
LOOKS
LIKE
BY
A
THOUGHT
EXPERIMENT
IMAGINE
THAT
THE
POINTS
ARE
NAILS
STICKING
OUT
OF
THE
PLANE
TAKE
AN
ELASTIC
RUBBER
BAND
HOLD
IT
AROUND
THE
NAILS
AND
LET
IT
GO
IT
WILL
SNAP
AROUND
THE
NAILS
MINIMIZING
ITS
LENGTH
THE
AREA
ENCLOSED
BY
THE
RUBBER
BAND
IS
THE
CONVEX
HULL
OF
P
THIS
LEADS
TO
AN
ALTERNATIVE
DEFINITION
OF
THE
CONVEX
HULL
OF
A
FINITE
SET
P
OF
POINTS
IN
THE
PLANE
IT
IS
THE
UNIQUE
CONVEX
POLYGON
WHOSE
VERTICES
ARE
POINTS
FROM
P
AND
THAT
CONTAINS
ALL
POINTS
OF
P
OF
COURSE
WE
SHOULD
PROVE
RIGOROUSLY
THAT
THIS
IS
WELL
DEFINED
THAT
IS
THAT
THE
POLYGON
IS
UNIQUE
AND
THAT
THE
DEFINITION
IS
EQUIVALENT
TO
THE
ONE
GIVEN
EARLIER
BUT
LET
SKIP
THAT
IN
THIS
INTRODUCTORY
CHAPTER
HOW
DO
WE
COMPUTE
THE
CONVEX
HULL
BEFORE
WE
CAN
ANSWER
THIS
QUESTION
WE
MUST
ASK
ANOTHER
QUESTION
WHAT
DOES
IT
MEAN
TO
COMPUTE
THE
CONVEX
HULL
AS
WE
HAVE
SEEN
THE
CONVEX
HULL
OF
P
IS
A
CONVEX
POLYGON
A
NATURAL
WAY
TO
REPRESENT
A
POLYGON
IS
BY
LISTING
ITS
VERTICES
IN
CLOCKWISE
ORDER
STARTING
WITH
AN
ARBITRARY
ONE
SO
THE
PROBLEM
WE
WANT
TO
SOLVE
IS
THIS
GIVEN
A
SET
P
PN
OF
POINTS
IN
THE
PLANE
COMPUTE
A
LIST
THAT
CONTAINS
THOSE
POINTS
FROM
P
THAT
ARE
THE
VERTICES
OF
CH
P
LISTED
IN
CLOCKWISE
ORDER
SECTION
AN
EXAMPLE
CONVEX
HULLS
INPUT
SET
OF
POINTS
OUTPUT
REPRESENTATION
OF
THE
CONVEX
HULL
FIGURE
COMPUTING
A
CONVEX
HULL
THE
FIRST
DEFINITION
OF
CONVEX
HULLS
IS
OF
LITTLE
HELP
WHEN
WE
WANT
TO
DESIGN
AN
ALGORITHM
TO
COMPUTE
THE
CONVEX
HULL
IT
TALKS
ABOUT
THE
INTERSECTION
OF
ALL
CONVEX
SETS
CONTAINING
P
OF
WHICH
THERE
ARE
INFINITELY
MANY
THE
OBSERVATION
THAT
CH
P
IS
A
CONVEX
POLYGON
IS
MORE
USEFUL
LET
SEE
WHAT
THE
EDGES
OF
CH
P
ARE
BOTH
ENDPOINTS
P
AND
Q
OF
SUCH
AN
EDGE
ARE
POINTS
OF
P
AND
IF
WE
DIRECT
THE
LINE
THROUGH
P
AND
Q
SUCH
THAT
CH
P
LIES
TO
THE
RIGHT
THEN
ALL
THE
POINTS
OF
P
MUST
LIE
TO
THE
RIGHT
OF
THIS
LINE
THE
REVERSE
IS
ALSO
TRUE
IF
ALL
POINTS
OF
P
P
Q
LIE
TO
THE
RIGHT
OF
THE
DIRECTED
LINE
THROUGH
P
AND
Q
THEN
PQ
IS
AN
EDGE
OF
CH
P
NOW
THAT
WE
UNDERSTAND
THE
GEOMETRY
OF
THE
PROBLEM
A
LITTLE
BIT
BETTER
WE
CAN
DEVELOP
AN
ALGORITHM
WE
WILL
DESCRIBE
IT
IN
A
STYLE
OF
PSEUDOCODE
WE
WILL
USE
THROUGHOUT
THIS
BOOK
ALGORITHM
SLOWCONVEXHULL
P
INPUT
A
SET
P
OF
POINTS
IN
THE
PLANE
OUTPUT
A
LIST
L
CONTAINING
THE
VERTICES
OF
CH
P
IN
CLOCKWISE
ORDER
E
FOR
ALL
ORDERED
PAIRS
P
Q
P
P
WITH
P
NOT
EQUAL
TO
Q
DO
VALID
TRUE
CHAPTER
COMPUTATIONAL
GEOMETRY
FOR
ALL
POINTS
R
P
NOT
EQUAL
TO
P
OR
Q
DO
IF
R
LIES
TO
THE
LEFT
OF
THE
DIRECTED
LINE
FROM
P
TO
Q
THEN
VALID
FALSE
DESTINATION
OF
ORIGIN
OF
IF
VALID
THEN
ADD
THE
DIRECTED
EDGE
PQ
TO
E
FROM
THE
SET
E
OF
EDGES
CONSTRUCT
A
LIST
L
OF
VERTICES
OF
CH
P
SORTED
IN
CLOCKWISE
ORDER
TWO
STEPS
IN
THE
ALGORITHM
ARE
PERHAPS
NOT
ENTIRELY
CLEAR
THE
FIRST
ONE
IS
LINE
HOW
DO
WE
TEST
WHETHER
A
POINT
LIES
TO
THE
LEFT
OR
TO
THE
RIGHT
OF
A
DIRECTED
LINE
THIS
IS
ONE
OF
THE
PRIMITIVE
OPERATIONS
REQUIRED
IN
MOST
GEOMETRIC
ALGORITHMS
THROUGHOUT
THIS
BOOK
WE
ASSUME
THAT
SUCH
OPERATIONS
ARE
AVAILABLE
IT
IS
CLEAR
THAT
THEY
CAN
BE
PERFORMED
IN
CONSTANT
TIME
SO
THE
ACTUAL
IMPLEMENTATION
WILL
NOT
AFFECT
THE
ASYMPTOTIC
RUNNING
TIME
IN
ORDER
OF
MAGNITUDE
THIS
IS
NOT
TO
SAY
THAT
SUCH
PRIMITIVE
OPERATIONS
ARE
UNIMPORTANT
OR
TRIVIAL
THEY
ARE
NOT
EASY
TO
IMPLEMENT
CORRECTLY
AND
THEIR
IMPLEMENTATION
WILL
AFFECT
THE
ACTUAL
RUNNING
TIME
OF
THE
ALGORITHM
FORTUNATELY
SOFTWARE
LIBRARIES
CONTAINING
SUCH
PRIMITIVE
OPERATIONS
ARE
NOWADAYS
AVAILABLE
WE
CONCLUDE
THAT
WE
DON
T
HAVE
TO
WORRY
ABOUT
THE
TEST
IN
LINE
WE
MAY
ASSUME
THAT
WE
HAVE
A
FUNCTION
AVAILABLE
PERFORMING
THE
TEST
FOR
US
IN
CONSTANT
TIME
THE
OTHER
STEP
OF
THE
ALGORITHM
THAT
REQUIRES
SOME
EXPLANATION
IS
THE
LAST
ONE
IN
THE
LOOP
OF
LINES
WE
DETERMINE
THE
SET
E
OF
CONVEX
HULL
EDGES
FROM
E
WE
CAN
CONSTRUCT
THE
LIST
L
AS
FOLLOWS
THE
EDGES
IN
E
ARE
DIRECTED
SO
WE
CAN
SPEAK
ABOUT
THE
ORIGIN
AND
THE
DESTINATION
OF
AN
EDGE
BECAUSE
THE
EDGES
ARE
DIRECTED
SUCH
THAT
THE
OTHER
POINTS
LIE
TO
THEIR
RIGHT
THE
DESTINATION
OF
AN
EDGE
COMES
AFTER
ITS
ORIGIN
WHEN
THE
VERTICES
ARE
LISTED
IN
CLOCKWISE
ORDER
NOW
REMOVE
AN
ARBITRARY
EDGE
FROM
E
PUT
THE
ORIGIN
OF
AS
THE
FIRST
POINT
INTO
L
AND
THE
DESTINATION
AS
THE
SECOND
POINT
FIND
THE
EDGE
IN
E
WHOSE
ORIGIN
IS
THE
DESTINATION
OF
REMOVE
IT
FROM
E
AND
APPEND
ITS
DESTINATION
TO
L
NEXT
FIND
THE
EDGE
WHOSE
ORIGIN
IS
THE
DESTINATION
OF
REMOVE
IT
FROM
E
AND
APPEND
ITS
DESTINATION
TO
L
WE
CONTINUE
IN
THIS
MANNER
UNTIL
THERE
IS
ONLY
ONE
EDGE
LEFT
IN
E
THEN
WE
ARE
DONE
THE
DESTINATION
OF
THE
REMAINING
EDGE
IS
NECESSARILY
THE
ORIGIN
OF
WHICH
IS
ALREADY
THE
FIRST
POINT
IN
L
A
SIMPLE
IMPLEMENTATION
OF
THIS
PROCEDURE
TAKES
O
TIME
THIS
CAN
EASILY
BE
IMPROVED
TO
O
N
LOG
N
BUT
THE
TIME
REQUIRED
FOR
THE
REST
OF
THE
ALGORITHM
DOMINATES
THE
TOTAL
RUNNING
TIME
ANYWAY
ANALYZING
THE
TIME
COMPLEXITY
OF
SLOWCONVEXHULL
IS
EASY
WE
CHECK
N
PAIRS
OF
POINTS
FOR
EACH
PAIR
WE
LOOK
AT
THE
N
OTHER
POINTS
TO
SEE
WHETHER
THEY
ALL
LIE
ON
THE
RIGHT
SIDE
THIS
WILL
TAKE
O
TIME
IN
TOTAL
THE
FINAL
STEP
TAKES
O
TIME
SO
THE
TOTAL
RUNNING
TIME
IS
O
AN
ALGORITHM
WITH
A
CUBIC
RUNNING
TIME
IS
TOO
SLOW
TO
BE
OF
PRACTICAL
USE
FOR
ANYTHING
BUT
THE
SMALLEST
INPUT
SETS
THE
PROBLEM
IS
THAT
WE
DID
NOT
USE
ANY
CLEVER
ALGORITHMIC
DESIGN
TECHNIQUES
WE
JUST
TRANSLATED
THE
GEOMETRIC
INSIGHT
INTO
AN
ALGORITHM
IN
A
BRUTE
FORCE
MANNER
BUT
BEFORE
WE
TRY
TO
DO
BETTER
IT
IS
USEFUL
TO
MAKE
SEVERAL
OBSERVATIONS
ABOUT
THIS
ALGORITHM
WE
HAVE
BEEN
A
BIT
CARELESS
WHEN
DERIVING
THE
CRITERION
OF
WHEN
A
PAIR
P
Q
DEFINES
AN
EDGE
OF
CH
P
A
POINT
R
DOES
NOT
ALWAYS
LIE
TO
THE
RIGHT
OR
TO
THE
LEFT
OF
THE
LINE
THROUGH
P
AND
Q
IT
CAN
ALSO
HAPPEN
THAT
IT
LIES
ON
THIS
LINE
WHAT
SHOULD
WE
DO
THEN
THIS
IS
WHAT
WE
CALL
A
DEGENERATE
CASE
ORA
DEGENERACY
FOR
SHORT
WE
PREFER
TO
IGNORE
SUCH
SITUATIONS
WHEN
WE
FIRST
THINK
ABOUT
A
PROBLEM
SO
THAT
WE
DON
T
GET
CONFUSED
WHEN
WE
TRY
TO
FIGURE
OUT
THE
GEOMETRIC
PROPERTIES
OF
A
PROBLEM
HOWEVER
THESE
SITUATIONS
DO
ARISE
IN
PRACTICE
FOR
INSTANCE
IF
WE
CREATE
THE
POINTS
BY
CLICKING
ON
A
SCREEN
WITH
A
MOUSE
ALL
POINTS
WILL
HAVE
SMALL
INTEGER
COORDINATES
AND
IT
IS
QUITE
LIKELY
THAT
WE
WILL
CREATE
THREE
POINTS
ON
A
LINE
TO
MAKE
THE
ALGORITHM
CORRECT
IN
THE
PRESENCE
OF
DEGENERACIES
WE
MUST
REFORMULATE
THE
CRITERION
ABOVE
AS
FOLLOWS
A
DIRECTED
EDGE
P
Q
IS
AN
EDGE
OF
CH
P
IF
AND
ONLY
IF
ALL
OTHER
POINTS
R
P
LIE
EITHER
STRICTLY
TO
THE
RIGHT
OF
THE
DIRECTED
LINE
THROUGH
P
AND
Q
OR
THEY
LIE
ON
THE
OPEN
LINE
SEGMENT
PQ
WE
ASSUME
THAT
THERE
ARE
NO
COINCIDING
POINTS
IN
P
SO
WE
HAVE
TO
REPLACE
LINE
OF
THE
ALGORITHM
BY
THIS
MORE
COMPLICATED
TEST
WE
HAVE
BEEN
IGNORING
ANOTHER
IMPORTANT
ISSUE
THAT
CAN
INFLUENCE
THE
CORRECTNESS
OF
THE
RESULT
OF
OUR
ALGORITHM
WE
IMPLICITLY
ASSUMED
THAT
WE
CAN
SOMEHOW
TEST
EXACTLY
WHETHER
A
POINT
LIES
TO
THE
RIGHT
OR
TO
THE
LEFT
OF
A
GIVEN
LINE
THIS
IS
NOT
NECESSARILY
TRUE
IF
THE
POINTS
ARE
GIVEN
IN
FLOATING
POINT
COORDINATES
AND
THE
COMPUTATIONS
ARE
DONE
USING
FLOATING
POINT
ARITHMETIC
THEN
THERE
WILL
BE
ROUNDING
ERRORS
THAT
MAY
DISTORT
THE
OUTCOME
OF
TESTS
IMAGINE
THAT
THERE
ARE
THREE
POINTS
P
Q
AND
R
THAT
ARE
NEARLY
COLLINEAR
AND
THAT
ALL
OTHER
POINTS
LIE
FAR
TO
THE
RIGHT
OF
THEM
OUR
ALGORITHM
TESTS
THE
PAIRS
P
Q
R
Q
AND
P
R
SINCE
THESE
POINTS
ARE
NEARLY
COLLINEAR
IT
IS
POSSIBLE
THAT
THE
ROUNDING
ERRORS
LEAD
US
TO
DECIDE
THAT
R
LIES
TO
THE
RIGHT
OF
THE
LINE
FROM
P
TO
Q
THAT
P
LIES
TO
THE
RIGHT
OF
THE
LINE
FROM
R
TO
Q
AND
THAT
Q
LIES
TO
THE
RIGHT
OF
THE
LINE
FROM
P
TO
R
OF
COURSE
THIS
IS
GEOMETRICALLY
IMPOSSIBLE
BUT
THE
FLOATING
POINT
ARITHMETIC
DOESN
T
KNOW
THAT
IN
THIS
CASE
THE
ALGORITHM
WILL
ACCEPT
ALL
THREE
EDGES
EVEN
WORSE
ALL
THREE
TESTS
COULD
GIVE
THE
OPPOSITE
ANSWER
IN
WHICH
CASE
THE
ALGORITHM
REJECTS
ALL
THREE
EDGES
LEADING
TO
A
GAP
IN
THE
BOUNDARY
OF
THE
CONVEX
HULL
AND
THIS
LEADS
TO
A
SERIOUS
PROBLEM
WHEN
WE
TRY
TO
CONSTRUCT
THE
SORTED
LIST
OF
CONVEX
HULL
VERTICES
IN
THE
LAST
STEP
OF
OUR
ALGORITHM
THIS
STEP
ASSUMES
THAT
THERE
IS
EXACTLY
ONE
EDGE
STARTING
IN
EVERY
CONVEX
HULL
VERTEX
AND
EXACTLY
ONE
EDGE
ENDING
THERE
DUE
TO
THE
ROUNDING
ERRORS
THERE
CAN
SUDDENLY
BE
TWO
OR
NO
EDGES
STARTING
IN
VERTEX
P
THIS
CAN
CAUSE
THE
PROGRAM
IMPLEMENTING
OUR
SIMPLE
ALGORITHM
TO
CRASH
SINCE
THE
LAST
STEP
HAS
NOT
BEEN
DESIGNED
TO
DEAL
WITH
SUCH
INCONSISTENT
DATA
ALTHOUGH
WE
HAVE
PROVEN
THE
ALGORITHM
TO
BE
CORRECT
AND
TO
HANDLE
ALL
SPECIAL
CASES
IT
IS
NOT
ROBUST
SMALL
ERRORS
IN
THE
COMPUTATIONS
CAN
MAKE
IT
FAIL
IN
COMPLETELY
UNEXPECTED
WAYS
THE
PROBLEM
IS
THAT
WE
HAVE
PROVEN
THE
CORRECTNESS
ASSUMING
THAT
WE
CAN
COMPUTE
EXACTLY
WITH
REAL
NUMBERS
SECTION
AN
EXAMPLE
CONVEX
HULLS
Q
R
P
Q
R
P
WE
HAVE
DESIGNED
OUR
FIRST
GEOMETRIC
ALGORITHM
IT
COMPUTES
THE
CONVEX
HULL
OF
A
SET
OF
POINTS
IN
THE
PLANE
HOWEVER
IT
IS
QUITE
SLOW
ITS
RUNNING
TIME
IS
O
IT
DEALS
WITH
DEGENERATE
CASES
IN
AN
AWKWARD
WAY
AND
IT
IS
NOT
ROBUST
WE
SHOULD
TRY
TO
DO
BETTER
CHAPTER
COMPUTATIONAL
GEOMETRY
UPPER
HULL
PN
LOWER
HULL
I
POINTS
DELETED
TO
THIS
END
WE
APPLY
A
STANDARD
ALGORITHMIC
DESIGN
TECHNIQUE
WE
WILL
DEVELOP
AN
INCREMENTAL
ALGORITHM
THIS
MEANS
THAT
WE
WILL
ADD
THE
POINTS
IN
P
ONE
BY
ONE
UPDATING
OUR
SOLUTION
AFTER
EACH
ADDITION
WE
GIVE
THIS
INCREMENTAL
APPROACH
A
GEOMETRIC
FLAVOR
BY
ADDING
THE
POINTS
FROM
LEFT
TO
RIGHT
SO
WE
FIRST
SORT
THE
POINTS
BY
X
COORDINATE
OBTAINING
A
SORTED
SEQUENCE
PN
AND
THEN
WE
ADD
THEM
IN
THAT
ORDER
BECAUSE
WE
ARE
WORKING
FROM
LEFT
TO
RIGHT
IT
WOULD
BE
CONVENIENT
IF
THE
CONVEX
HULL
VERTICES
WERE
ALSO
ORDERED
FROM
LEFT
TO
RIGHT
AS
THEY
OCCUR
ALONG
THE
BOUNDARY
BUT
THIS
IS
NOT
THE
CASE
THEREFORE
WE
FIRST
COMPUTE
ONLY
THOSE
CONVEX
HULL
VERTICES
THAT
LIE
ON
THE
UPPER
HULL
WHICH
IS
THE
PART
OF
THE
CONVEX
HULL
RUNNING
FROM
THE
LEFTMOST
POINT
TO
THE
RIGHTMOST
POINT
PN
WHEN
THE
VERTICES
ARE
LISTED
IN
CLOCKWISE
ORDER
IN
OTHER
WORDS
THE
UPPER
HULL
CONTAINS
THE
CONVEX
HULL
EDGES
BOUNDING
THE
CONVEX
HULL
FROM
ABOVE
IN
A
SECOND
SCAN
WHICH
IS
PERFORMED
FROM
RIGHT
TO
LEFT
WE
COMPUTE
THE
REMAINING
PART
OF
THE
CONVEX
HULL
THE
LOWER
HULL
THE
BASIC
STEP
IN
THE
INCREMENTAL
ALGORITHM
IS
THE
UPDATE
OF
THE
UPPER
HULL
AFTER
ADDING
A
POINT
PI
IN
OTHER
WORDS
GIVEN
THE
UPPER
HULL
OF
THE
POINTS
PI
WE
HAVE
TO
COMPUTE
THE
UPPER
HULL
OF
PI
THIS
CAN
BE
DONE
AS
FOLLOWS
WHEN
WE
WALK
AROUND
THE
BOUNDARY
OF
A
POLYGON
IN
CLOCKWISE
ORDER
WE
MAKE
A
TURN
AT
EVERY
VERTEX
FOR
AN
ARBITRARY
POLYGON
THIS
CAN
BE
BOTH
A
RIGHT
TURN
AND
A
LEFT
TURN
BUT
FOR
A
CONVEX
POLYGON
EVERY
TURN
MUST
BE
A
RIGHT
TURN
THIS
SUGGESTS
HANDLING
THE
ADDITION
OF
PI
IN
THE
FOLLOWING
WAY
LET
LUPPER
BE
A
LIST
THAT
STORES
THE
UPPER
VERTICES
IN
LEFT
TO
RIGHT
ORDER
WE
FIRST
APPEND
PI
TO
LUPPER
THIS
IS
CORRECT
BECAUSE
PI
IS
THE
RIGHTMOST
POINT
OF
THE
ONES
ADDED
SO
FAR
SO
IT
MUST
BE
ON
THE
UPPER
HULL
NEXT
WE
CHECK
WHETHER
THE
LAST
THREE
POINTS
IN
LUPPER
MAKE
A
RIGHT
TURN
IF
THIS
IS
THE
CASE
THERE
IS
NOTHING
MORE
TO
DO
LUPPER
CONTAINS
THE
VERTICES
OF
THE
UPPER
HULL
OF
PI
AND
WE
CAN
PROCEED
TO
THE
NEXT
POINT
PI
BUT
IF
THE
LAST
THREE
POINTS
MAKE
A
LEFT
TURN
WE
HAVE
TO
DELETE
THE
MIDDLE
ONE
FROM
THE
UPPER
HULL
IN
THIS
CASE
WE
ARE
NOT
FINISHED
YET
IT
COULD
BE
THAT
THE
NEW
LAST
THREE
POINTS
STILL
DO
NOT
MAKE
A
RIGHT
TURN
IN
WHICH
CASE
WE
AGAIN
HAVE
TO
DELETE
THE
MIDDLE
ONE
WE
CONTINUE
IN
THIS
MANNER
UNTIL
THE
LAST
THREE
POINTS
MAKE
A
RIGHT
TURN
OR
UNTIL
THERE
ARE
ONLY
TWO
POINTS
LEFT
WE
NOW
GIVE
THE
ALGORITHM
IN
PSEUDOCODE
THE
PSEUDOCODE
COMPUTES
BOTH
THE
UPPER
HULL
AND
THE
LOWER
HULL
THE
LATTER
IS
DONE
BY
TREATING
THE
POINTS
FROM
RIGHT
TO
LEFT
ANALOGOUS
TO
THE
COMPUTATION
OF
THE
UPPER
HULL
ALGORITHM
CONVEXHULL
P
INPUT
A
SET
P
OF
POINTS
IN
THE
PLANE
OUTPUT
A
LIST
CONTAINING
THE
VERTICES
OF
CH
P
IN
CLOCKWISE
ORDER
SORT
THE
POINTS
BY
X
COORDINATE
RESULTING
IN
A
SEQUENCE
PN
PUT
THE
POINTS
AND
IN
A
LIST
LUPPER
WITH
AS
THE
FIRST
POINT
FOR
I
TO
N
DO
APPEND
PI
TO
LUPPER
WHILE
LUPPER
CONTAINS
MORE
THAN
TWO
POINTS
AND
THE
LAST
THREE
POINTS
IN
LUPPER
DO
NOT
MAKE
A
RIGHT
TURN
DO
DELETE
THE
MIDDLE
OF
THE
LAST
THREE
POINTS
FROM
LUPPER
PUT
THE
POINTS
PN
AND
PN
IN
A
LIST
LLOWER
WITH
PN
AS
THE
FIRST
POINT
FOR
I
N
DOWNTO
DO
APPEND
PI
TO
LLOWER
WHILE
LLOWER
CONTAINS
MORE
THAN
POINTS
AND
THE
LAST
THREE
POINTS
IN
LLOWER
DO
NOT
MAKE
A
RIGHT
TURN
DO
DELETE
THE
MIDDLE
OF
THE
LAST
THREE
POINTS
FROM
LLOWER
REMOVE
THE
FIRST
AND
THE
LAST
POINT
FROM
LLOWER
TO
AVOID
DUPLICATION
OF
THE
POINTS
WHERE
THE
UPPER
AND
LOWER
HULL
MEET
APPEND
LLOWER
TO
LUPPER
AND
CALL
THE
RESULTING
LIST
L
RETURN
L
ONCE
AGAIN
WHEN
WE
LOOK
CLOSER
WE
REALIZE
THAT
THE
ABOVE
ALGORITHM
IS
NOT
CORRECT
WITHOUT
MENTIONING
IT
WE
MADE
THE
ASSUMPTION
THAT
NO
TWO
POINTS
HAVE
THE
SAME
X
COORDINATE
IF
THIS
ASSUMPTION
IS
NOT
VALID
THE
ORDER
ON
X
COORDINATE
IS
NOT
WELL
DEFINED
FORTUNATELY
THIS
TURNS
OUT
NOT
TO
BE
A
SERIOUS
PROBLEM
WE
ONLY
HAVE
TO
GENERALIZE
THE
ORDERING
IN
A
SUITABLE
WAY
RATHER
THAN
USING
ONLY
THE
X
COORDINATE
OF
THE
POINTS
TO
DEFINE
THE
ORDER
WE
USE
THE
LEXICOGRAPHIC
ORDER
THIS
MEANS
THAT
WE
FIRST
SORT
BY
X
COORDINATE
AND
IF
POINTS
HAVE
THE
SAME
X
COORDINATE
WE
SORT
THEM
BY
Y
COORDINATE
ANOTHER
SPECIAL
CASE
WE
HAVE
IGNORED
IS
THAT
THE
THREE
POINTS
FOR
WHICH
WE
HAVE
TO
DETERMINE
WHETHER
THEY
MAKE
A
LEFT
OR
A
RIGHT
TURN
LIE
ON
A
STRAIGHT
LINE
IN
THIS
CASE
THE
MIDDLE
POINT
SHOULD
NOT
OCCUR
ON
THE
CONVEX
HULL
SO
COLLINEAR
POINTS
MUST
BE
TREATED
AS
IF
THEY
MAKE
A
LEFT
TURN
IN
OTHER
WORDS
WE
SHOULD
USE
A
TEST
THAT
RETURNS
TRUE
IF
THE
THREE
POINTS
MAKE
A
RIGHT
TURN
AND
FALSE
OTHERWISE
NOTE
THAT
THIS
IS
SIMPLER
THAN
THE
TEST
REQUIRED
IN
THE
PREVIOUS
ALGORITHM
WHEN
THERE
WERE
COLLINEAR
POINTS
WITH
THESE
MODIFICATIONS
THE
ALGORITHM
CORRECTLY
COMPUTES
THE
CONVEX
HULL
THE
FIRST
SCAN
COMPUTES
THE
UPPER
HULL
WHICH
IS
NOW
DEFINED
AS
THE
PART
OF
THE
CONVEX
HULL
RUNNING
FROM
THE
LEXICOGRAPHICALLY
SMALLEST
VERTEX
TO
THE
LEXICO
GRAPHICALLY
LARGEST
VERTEX
AND
THE
SECOND
SCAN
COMPUTES
THE
REMAINING
PART
OF
THE
CONVEX
HULL
WHAT
DOES
OUR
ALGORITHM
DO
IN
THE
PRESENCE
OF
ROUNDING
ERRORS
IN
THE
FLOATING
POINT
ARITHMETIC
WHEN
SUCH
ERRORS
OCCUR
IT
CAN
HAPPEN
THAT
A
POINT
IS
REMOVED
FROM
THE
CONVEX
HULL
ALTHOUGH
IT
SHOULD
BE
THERE
OR
THAT
A
POINT
INSIDE
THE
REAL
CONVEX
HULL
IS
NOT
REMOVED
BUT
THE
STRUCTURAL
INTEGRITY
OF
THE
ALGORITHM
IS
UNHARMED
IT
WILL
COMPUTE
A
CLOSED
POLYGONAL
CHAIN
AFTER
ALL
THE
OUTPUT
IS
A
LIST
OF
POINTS
THAT
WE
CAN
INTERPRET
AS
THE
CLOCKWISE
LISTING
OF
THE
VERTICES
OF
A
POLYGON
AND
ANY
THREE
CONSECUTIVE
POINTS
FORM
A
RIGHT
TURN
OR
BECAUSE
OF
THE
ROUNDING
ERRORS
THEY
ALMOST
FORM
A
RIGHT
TURN
MOREOVER
NO
POINT
IN
P
CAN
BE
FAR
OUTSIDE
THE
COMPUTED
HULL
THE
ONLY
PROBLEM
THAT
CAN
STILL
OCCUR
IS
THAT
WHEN
THREE
POINTS
LIE
VERY
CLOSE
TOGETHER
A
TURN
THAT
IS
ACTUALLY
A
SHARP
LEFT
TURN
CAN
BE
INTERPRETATED
AS
A
RIGHT
TURN
THIS
MIGHT
RESULT
IN
A
DENT
IN
THE
RESULTING
POLYGON
A
WAY
OUT
OF
THIS
IS
TO
MAKE
SURE
THAT
POINTS
IN
THE
INPUT
THAT
ARE
VERY
CLOSE
TOGETHER
ARE
CONSIDERED
AS
BEING
THE
SAME
POINT
FOR
EXAMPLE
BY
ROUNDING
HENCE
ALTHOUGH
THE
RESULT
NEED
NOT
BE
EXACTLY
CORRECT
BUT
THEN
WE
CANNOT
HOPE
FOR
AN
EXACT
RESULT
IF
WE
USE
INEXACT
ARITHMETIC
IT
DOES
MAKE
SENSE
FOR
MANY
APPLICATIONS
THIS
IS
GOOD
ENOUGH
STILL
IT
IS
WISE
TO
BE
CAREFUL
SECTION
AN
EXAMPLE
CONVEX
HULLS
NOT
A
RIGHT
TURN
IN
THE
IMPLEMENTATION
OF
THE
BASIC
TEST
TO
AVOID
ERRORS
AS
MUCH
AS
POSSIBLE
CHAPTER
COMPUTATIONAL
GEOMETRY
PI
WE
CONCLUDE
WITH
THE
FOLLOWING
THEOREM
THEOREM
THE
CONVEX
HULL
OF
A
SET
OF
N
POINTS
IN
THE
PLANE
CAN
BE
COMPUTED
IN
O
N
LOG
N
TIME
PROOF
WE
WILL
PROVE
THE
CORRECTNESS
OF
THE
COMPUTATION
OF
THE
UPPER
HULL
THE
LOWER
HULL
COMPUTATION
CAN
BE
PROVED
CORRECT
USING
SIMILAR
ARGUMENTS
THE
PROOF
IS
BY
INDUCTION
ON
THE
NUMBER
OF
POINT
TREATED
BEFORE
THE
FOR
LOOP
STARTS
THE
LIST
LUPPER
CONTAINS
THE
POINTS
AND
WHICH
TRIVIALLY
FORM
THE
UPPER
HULL
OF
NOW
SUPPOSE
THAT
LUPPER
CONTAINS
THE
UPPER
HULL
VERTICES
OF
PI
AND
CONSIDER
THE
ADDITION
OF
PI
AFTER
THE
EXECUTION
OF
THE
WHILE
LOOP
AND
BECAUSE
OF
THE
INDUCTION
HYPOTHESIS
WE
KNOW
THAT
THE
POINTS
IN
LUPPER
FORM
A
CHAIN
THAT
ONLY
MAKES
RIGHT
TURNS
MOREOVER
THE
CHAIN
STARTS
AT
THE
LEXICOGRAPHICALLY
SMALLEST
POINT
OF
PI
AND
ENDS
AT
THE
LEXICOGRAPHICALLY
LARGEST
POINT
NAMELY
PI
IF
WE
CAN
SHOW
THAT
ALL
POINTS
OF
PI
THAT
ARE
NOT
IN
LUPPER
ARE
BELOW
THE
CHAIN
THEN
LUPPER
CONTAINS
THE
CORRECT
POINTS
BY
INDUCTION
WE
KNOW
THERE
IS
NO
POINT
ABOVE
THE
CHAIN
THAT
WE
HAD
BEFORE
PI
WAS
ADDED
SINCE
THE
OLD
CHAIN
LIES
BELOW
THE
NEW
CHAIN
THE
ONLY
POSSIBILITY
FOR
A
POINT
TO
LIE
ABOVE
THE
NEW
CHAIN
IS
IF
IT
LIES
IN
THE
VERTICAL
SLAB
BETWEEN
PI
AND
PI
BUT
THIS
IS
NOT
POSSIBLE
SINCE
SUCH
A
POINT
WOULD
BE
IN
BETWEEN
PI
AND
PI
IN
THE
LEXICOGRAPHICAL
ORDER
YOU
SHOULD
VERIFY
THAT
A
SIMILAR
ARGUMENT
HOLDS
IF
PI
AND
PI
OR
ANY
OTHER
POINTS
HAVE
THE
SAME
X
COORDINATE
TO
PROVE
THE
TIME
BOUND
WE
NOTE
THAT
SORTING
THE
POINTS
LEXICOGRAPHICALLY
CAN
BE
DONE
IN
O
N
LOG
N
TIME
NOW
CONSIDER
THE
COMPUTATION
OF
THE
UPPER
HULL
THE
FOR
LOOP
IS
EXECUTED
A
LINEAR
NUMBER
OF
TIMES
THE
QUESTION
THAT
REMAINS
IS
HOW
OFTEN
THE
WHILE
LOOP
INSIDE
IT
IS
EXECUTED
FOR
EACH
EXECUTION
OF
THE
FOR
LOOP
THE
WHILE
LOOP
IS
EXECUTED
AT
LEAST
ONCE
FOR
ANY
EXTRA
EXECUTION
A
POINT
IS
DELETED
FROM
THE
CURRENT
HULL
AS
EACH
POINT
CAN
BE
DELETED
ONLY
ONCE
DURING
THE
CONSTRUCTION
OF
THE
UPPER
HULL
THE
TOTAL
NUMBER
OF
EXTRA
EXECUTIONS
OVER
ALL
FOR
LOOPS
IS
BOUNDED
BY
N
SIMILARLY
THE
COMPUTATION
OF
THE
LOWER
HULL
TAKES
O
N
TIME
DUE
TO
THE
SORTING
STEP
THE
TOTAL
TIME
REQUIRED
FOR
COMPUTING
THE
CONVEX
HULL
IS
O
N
LOG
N
THE
FINAL
CONVEX
HULL
ALGORITHM
IS
SIMPLE
TO
DESCRIBE
AND
EASY
TO
IMPLEMENT
IT
ONLY
REQUIRES
LEXICOGRAPHIC
SORTING
AND
A
TEST
WHETHER
THREE
CONSECUTIVE
POINTS
MAKE
A
RIGHT
TURN
FROM
THE
ORIGINAL
DEFINITION
OF
THE
PROBLEM
IT
WAS
FAR
FROM
OBVIOUS
THAT
SUCH
AN
EASY
AND
EFFICIENT
SOLUTION
WOULD
EXIST
DEGENERACIES
AND
ROBUSTNESS
AS
WE
HAVE
SEEN
IN
THE
PREVIOUS
SECTION
THE
DEVELOPMENT
OF
A
GEOMETRIC
ALGORITHM
OFTEN
GOES
THROUGH
THREE
PHASES
IN
THE
FIRST
PHASE
WE
TRY
TO
IGNORE
EVERYTHING
THAT
WILL
CLUTTER
OUR
UNDERSTANDING
OF
THE
GEOMETRIC
CONCEPTS
WE
ARE
DEALING
WITH
SOMETIMES
COLLINEAR
POINTS
ARE
A
NUISANCE
SOMETIMES
VERTICAL
LINE
SEGMENTS
ARE
WHEN
FIRST
TRYING
TO
DESIGN
OR
UNDERSTAND
AN
ALGORITHM
IT
IS
OFTEN
HELPFUL
TO
IGNORE
THESE
DEGENERATE
CASES
IN
THE
SECOND
PHASE
WE
HAVE
TO
ADJUST
THE
ALGORITHM
DESIGNED
IN
THE
FIRST
PHASE
TO
BE
CORRECT
IN
THE
PRESENCE
OF
DEGENERATE
CASES
BEGINNERS
TEND
TO
DO
THIS
BY
ADDING
A
HUGE
NUMBER
OF
CASE
DISTINCTIONS
TO
THEIR
ALGORITHMS
IN
MANY
SITUATIONS
THERE
IS
A
BETTER
WAY
BY
CONSIDERING
THE
GEOMETRY
OF
THE
PROBLEM
AGAIN
ONE
CAN
OFTEN
INTEGRATE
SPECIAL
CASES
WITH
THE
GENERAL
CASE
FOR
EXAMPLE
IN
THE
CONVEX
HULL
ALGORITHM
WE
ONLY
HAD
TO
USE
THE
LEXICOGRAPHICAL
ORDER
INSTEAD
OF
THE
ORDER
ON
X
COORDINATE
TO
DEAL
WITH
POINTS
WITH
EQUAL
X
COORDINATE
FOR
MOST
ALGORITHMS
IN
THIS
BOOK
WE
HAVE
TRIED
TO
TAKE
THIS
INTEGRATED
APPROACH
TO
DEAL
WITH
SPECIAL
CASES
STILL
IT
IS
EASIER
NOT
TO
THINK
ABOUT
SUCH
CASES
UPON
FIRST
READING
ONLY
AFTER
UNDERSTANDING
HOW
THE
ALGORITHM
WORKS
IN
THE
GENERAL
CASE
SHOULD
YOU
THINK
ABOUT
DEGENERACIES
IF
YOU
STUDY
THE
COMPUTATIONAL
GEOMETRY
LITERATURE
YOU
WILL
FIND
THAT
MANY
AUTHORS
IGNORE
SPECIAL
CASES
OFTEN
BY
FORMULATING
SPECIFIC
ASSUMPTIONS
ON
THE
INPUT
FOR
EXAMPLE
IN
THE
CONVEX
HULL
PROBLEM
WE
COULD
HAVE
IGNORED
SPECIAL
CASES
BY
SIMPLY
STATING
THAT
WE
ASSUME
THAT
THE
INPUT
IS
SUCH
THAT
NO
THREE
POINTS
ARE
COLLINEAR
AND
NO
TWO
POINTS
HAVE
THE
SAME
X
COORDINATE
FROM
A
THEORETICAL
POINT
OF
VIEW
SUCH
ASSUMPTIONS
ARE
USUALLY
JUSTIFIED
THE
GOAL
IS
THEN
TO
ESTABLISH
THE
COMPUTATIONAL
COMPLEXITY
OF
A
PROBLEM
AND
ALTHOUGH
IT
IS
TEDIOUS
TO
WORK
OUT
THE
DETAILS
DEGENERATE
CASES
CAN
ALMOST
ALWAYS
BE
HANDLED
WITHOUT
INCREASING
THE
ASYMPTOTIC
COMPLEXITY
OF
THE
ALGORITHM
BUT
SPECIAL
CASES
DEFINITELY
INCREASE
THE
COMPLEXITY
OF
THE
IMPLEMENTATIONS
MOST
RESEARCHERS
IN
COMPUTATIONAL
GEOMETRY
TODAY
ARE
AWARE
THAT
THEIR
GENERAL
POSITION
ASSUMPTIONS
ARE
NOT
SATISFIED
IN
PRACTICAL
APPLICATIONS
AND
THAT
AN
INTEGRATED
TREATMENT
OF
THE
SPECIAL
CASES
IS
NORMALLY
THE
BEST
WAY
TO
HANDLE
THEM
FURTHERMORE
THERE
ARE
GENERAL
TECHNIQUES
SO
CALLED
SYMBOLIC
PERTURBATION
SCHEMES
THAT
ALLOW
ONE
TO
IGNORE
SPECIAL
CASES
DURING
THE
DESIGN
AND
IMPLEMENTATION
AND
STILL
HAVE
AN
ALGORITHM
THAT
IS
CORRECT
IN
THE
PRESENCE
OF
DEGENERACIES
THE
THIRD
PHASE
IS
THE
ACTUAL
IMPLEMENTATION
NOW
ONE
NEEDS
TO
THINK
ABOUT
THE
PRIMITIVE
OPERATIONS
LIKE
TESTING
WHETHER
A
POINT
LIES
TO
THE
LEFT
TO
THE
RIGHT
OR
ON
A
DIRECTED
LINE
IF
YOU
ARE
LUCKY
YOU
HAVE
A
GEOMETRIC
SOFTWARE
LIBRARY
AVAILABLE
THAT
CONTAINS
THE
OPERATIONS
YOU
NEED
OTHERWISE
YOU
MUST
IMPLEMENT
THEM
YOURSELF
ANOTHER
ISSUE
THAT
ARISES
IN
THE
IMPLEMENTATION
PHASE
IS
THAT
THE
ASSUMPTION
OF
DOING
EXACT
ARITHMETIC
WITH
REAL
NUMBERS
BREAKS
DOWN
AND
IT
IS
NECESSARY
TO
UNDERSTAND
THE
CONSEQUENCES
ROBUSTNESS
PROBLEMS
ARE
OFTEN
A
CAUSE
OF
FRUSTRATION
WHEN
IMPLEMENTING
GEOMETRIC
ALGORITHMS
SOLVING
ROBUSTNESS
PROB
LEMS
IS
NOT
EASY
ONE
SOLUTION
IS
TO
USE
A
PACKAGE
PROVIDING
EXACT
ARITHMETIC
USING
INTEGERS
RATIONALS
OR
EVEN
ALGEBRAIC
NUMBERS
DEPENDING
ON
THE
TYPE
OF
PROBLEM
BUT
THIS
WILL
BE
SLOW
ALTERNATIVELY
ONE
CAN
ADAPT
THE
ALGORITHM
TO
DETECT
INCONSISTENCIES
AND
TAKE
APPROPRIATE
ACTIONS
TO
AVOID
CRASHING
THE
PROGRAM
IN
THIS
CASE
IT
IS
NOT
GUARANTEED
THAT
THE
ALGORITHM
PRODUCES
THE
CORRECT
OUTPUT
AND
IT
IS
IMPORTANT
TO
ESTABLISH
THE
EXACT
PROPERTIES
THAT
THE
OUTPUT
HAS
THIS
IS
WHAT
WE
DID
IN
THE
PREVIOUS
SECTION
WHEN
WE
DEVELOPED
THE
CONVEX
HULL
ALGORITHM
THE
RESULT
MIGHT
NOT
BE
A
CONVEX
POLYGON
BUT
WE
KNOW
THAT
THE
STRUCTURE
OF
THE
OUTPUT
IS
CORRECT
AND
THAT
THE
OUTPUT
POLYGON
IS
VERY
CLOSE
TO
THE
SECTION
DEGENERACIES
AND
ROBUSTNESS
CONVEX
HULL
FINALLY
IT
IS
POSSIBLE
TO
PREDICT
BASED
ON
THE
INPUT
THE
PRECISION
IN
CHAPTER
COMPUTATIONAL
GEOMETRY
THE
NUMBER
REPRESENTATION
REQUIRED
TO
SOLVE
THE
PROBLEM
CORRECTLY
WHICH
APPROACH
IS
BEST
DEPENDS
ON
THE
APPLICATION
IF
SPEED
IS
NOT
AN
ISSUE
EXACT
ARITHMETIC
IS
PREFERRED
IN
OTHER
CASES
IT
IS
NOT
SO
IMPORTANT
THAT
THE
RESULT
OF
THE
ALGORITHM
IS
PRECISE
FOR
EXAMPLE
WHEN
DISPLAYING
THE
CONVEX
HULL
OF
A
SET
OF
POINTS
IT
IS
MOST
LIKELY
NOT
NOTICEABLE
WHEN
THE
POLYGON
DEVIATES
SLIGHTLY
FROM
THE
TRUE
CONVEX
HULL
IN
THIS
CASE
WE
CAN
USE
A
CAREFUL
IMPLEMENTATION
BASED
ON
FLOATING
POINT
ARITHMETIC
IN
THE
REST
OF
THIS
BOOK
WE
FOCUS
ON
THE
DESIGN
PHASE
OF
GEOMETRIC
ALGORITHMS
WE
WON
T
SAY
MUCH
ABOUT
THE
PROBLEMS
THAT
ARISE
IN
THE
IMPLEMENTATION
PHASE
APPLICATION
DOMAINS
AS
INDICATED
BEFORE
WE
HAVE
CHOSEN
A
MOTIVATING
EXAMPLE
APPLICATION
FOR
EVERY
GEOMETRIC
CONCEPT
ALGORITHM
OR
DATA
STRUCTURE
INTRODUCED
IN
THIS
BOOK
MOST
OF
THE
APPLICATIONS
STEM
FROM
THE
AREAS
OF
COMPUTER
GRAPHICS
ROBOTICS
GEOGRAPHIC
INFORMATION
SYSTEMS
AND
CAD
CAM
FOR
THOSE
NOT
FAMILIAR
WITH
THESE
FIELDS
WE
GIVE
A
BRIEF
DESCRIPTION
OF
THE
AREAS
AND
INDICATE
SOME
OF
THE
GEOMETRIC
PROBLEMS
THAT
ARISE
IN
THEM
COMPUTER
GRAPHICS
COMPUTER
GRAPHICS
IS
CONCERNED
WITH
CREATING
IMAGES
OF
MODELED
SCENES
FOR
DISPLAY
ON
A
COMPUTER
SCREEN
A
PRINTER
OR
OTHER
OUTPUT
DEVICE
THE
SCENES
VARY
FROM
SIMPLE
TWO
DIMENSIONAL
DRAWINGS
CONSISTING
OF
LINES
POLYGONS
AND
OTHER
PRIMITIVE
OBJECTS
TO
REALISTIC
LOOKING
DIMENSIONAL
SCENES
INCLUDING
LIGHT
SOURCES
TEXTURES
AND
SO
ON
THE
LATTER
TYPE
OF
SCENE
CAN
EASILY
CONTAIN
OVER
A
MILLION
POLYGONS
OR
CURVED
SURFACE
PATCHES
BECAUSE
SCENES
CONSIST
OF
GEOMETRIC
OBJECTS
GEOMETRIC
ALGORITHMS
PLAY
AN
IMPORTANT
ROLE
IN
COMPUTER
GRAPHICS
FOR
DIMENSIONAL
GRAPHICS
TYPICAL
QUESTIONS
INVOLVE
THE
INTERSECTION
OF
CERTAIN
PRIMITIVES
DETERMINING
THE
PRIMITIVE
POINTED
TO
WITH
THE
MOUSE
OR
DETER
MINING
THE
SUBSET
OF
PRIMITIVES
THAT
LIE
WITHIN
A
PARTICULAR
REGION
CHAPTERS
AND
DESCRIBE
TECHNIQUES
USEFUL
FOR
SOME
OF
THESE
PROBLEMS
WHEN
DEALING
WITH
DIMENSIONAL
PROBLEMS
THE
GEOMETRIC
QUESTIONS
BE
COME
MORE
COMPLEX
A
CRUCIAL
STEP
IN
DISPLAYING
A
DIMENSIONAL
SCENE
IS
HIDDEN
SURFACE
REMOVAL
DETERMINE
THE
PART
OF
A
SCENE
VISIBLE
FROM
A
PARTICULAR
VIEWPOINT
OR
IN
OTHER
WORDS
DISCARD
THE
PARTS
THAT
LIE
BEHIND
OTHER
OBJECTS
IN
CHAPTER
WE
STUDY
ONE
APPROACH
TO
THIS
PROBLEM
TO
CREATE
REALISTIC
LOOKING
SCENES
WE
HAVE
TO
TAKE
LIGHT
INTO
ACCOUNT
THIS
CREATES
MANY
NEW
PROBLEMS
SUCH
AS
THE
COMPUTATION
OF
SHADOWS
HENCE
REALISTIC
IMAGE
SYNTHESIS
REQUIRES
COMPLICATED
DISPLAY
TECHNIQUES
LIKE
RAY
TRACING
AND
RADIOSITY
WHEN
DEALING
WITH
MOVING
OBJECTS
AND
IN
VIRTUAL
REALITY
APPLICATIONS
IT
IS
IMPORTANT
TO
DETECT
COLLISIONS
BETWEEN
OBJECTS
ALL
THESE
SITUATIONS
INVOLVE
GEOMETRIC
PROBLEMS
ROBOTICS
THE
FIELD
OF
ROBOTICS
STUDIES
THE
DESIGN
AND
USE
OF
ROBOTS
AS
ROBOTS
ARE
GEOMETRIC
OBJECTS
THAT
OPERATE
IN
A
DIMENSIONAL
SPACE
THE
REAL
WORLD
IT
IS
OBVIOUS
THAT
GEOMETRIC
PROBLEMS
ARISE
AT
MANY
PLACES
AT
THE
BEGINNING
OF
THIS
CHAPTER
WE
ALREADY
INTRODUCED
THE
MOTION
PLANNING
PROBLEM
WHERE
A
ROBOT
HAS
TO
FIND
A
PATH
IN
AN
ENVIRONMENT
WITH
OBSTACLES
IN
CHAPTERS
AND
WE
STUDY
SOME
SIMPLE
CASES
OF
MOTION
PLANNING
MOTION
PLANNING
IS
ONE
ASPECT
OF
THE
MORE
GENERAL
PROBLEM
OF
TASK
PLANNING
ONE
WOULD
LIKE
TO
GIVE
A
ROBOT
HIGH
LEVEL
TASKS
VACUUM
THE
ROOM
AND
LET
THE
ROBOT
FIGURE
OUT
THE
BEST
WAY
TO
EXECUTE
THE
TASK
THIS
INVOLVES
PLANNING
MOTIONS
PLANNING
THE
ORDER
IN
WHICH
TO
PERFORM
SUBTASKS
AND
SO
ON
OTHER
GEOMETRIC
PROBLEMS
OCCUR
IN
THE
DESIGN
OF
ROBOTS
AND
WORK
CELLS
IN
WHICH
THE
ROBOT
HAS
TO
OPERATE
MOST
INDUSTRIAL
ROBOTS
ARE
ROBOT
ARMS
WITH
A
FIXED
BASE
THE
PARTS
OPERATED
ON
BY
THE
ROBOT
ARM
HAVE
TO
BE
SUPPLIED
IN
SUCH
A
WAY
THAT
THE
ROBOT
CAN
EASILY
GRASP
THEM
SOME
OF
THE
PARTS
MAY
HAVE
TO
BE
IMMOBILIZED
SO
THAT
THE
ROBOT
CAN
WORK
ON
THEM
THEY
MAY
ALSO
HAVE
TO
BE
TURNED
TO
A
KNOWN
ORIENTATION
BEFORE
THE
ROBOT
CAN
WORK
ON
THEM
THESE
ARE
ALL
GEOMETRIC
PROBLEMS
SOMETIMES
WITH
A
KINEMATIC
COMPONENT
SOME
OF
THE
ALGORITHMS
DESCRIBED
IN
THIS
BOOK
ARE
APPLICABLE
IN
SUCH
PROBLEMS
FOR
EXAMPLE
THE
SMALLEST
ENCLOSING
DISC
PROBLEM
TREATED
IN
SECTION
CAN
BE
USED
FOR
OPTIMAL
PLACEMENT
OF
ROBOT
ARMS
SECTION
APPLICATION
DOMAINS
GEOGRAPHIC
INFORMATION
SYSTEMS
A
GEOGRAPHIC
INFORMATION
SYSTEM
OR
GIS
FOR
SHORT
STORES
GEOGRAPHICAL
DATA
LIKE
THE
SHAPE
OF
COUNTRIES
THE
HEIGHT
OF
MOUNTAINS
THE
COURSE
OF
RIVERS
THE
TYPE
OF
VEGETATION
AT
DIFFERENT
LOCATIONS
POPULATION
DENSITY
OR
RAINFALL
THEY
CAN
ALSO
STORE
HUMAN
MADE
STRUCTURES
SUCH
AS
CITIES
ROADS
RAILWAYS
ELECTRICITY
LINES
OR
GAS
PIPES
A
GIS
CAN
BE
USED
TO
EXTRACT
INFORMATION
ABOUT
CERTAIN
REGIONS
AND
IN
PARTICULAR
TO
OBTAIN
INFORMATION
ABOUT
THE
RELATION
BETWEEN
DIFFERENT
TYPES
OF
DATA
FOR
EXAMPLE
A
BIOLOGIST
MAY
WANT
TO
RELATE
THE
AVERAGE
RAINFALL
TO
THE
EXISTENCE
OF
CERTAIN
PLANTS
AND
A
CIVIL
ENGINEER
MAY
NEED
TO
QUERY
A
GIS
TO
DETERMINE
WHETHER
THERE
ARE
ANY
GAS
PIPES
UNDERNEATH
A
LOT
WHERE
EXCAVATION
WORKS
ARE
TO
BE
PERFORMED
AS
MOST
GEOGRAPHIC
INFORMATION
CONCERNS
PROPERTIES
OF
POINTS
AND
REGIONS
ON
THE
EARTH
SURFACE
GEOMETRIC
PROBLEMS
OCCUR
IN
ABUNDANCE
HERE
MOREOVER
THE
AMOUNT
OF
DATA
IS
SO
LARGE
THAT
EFFICIENT
ALGORITHMS
ARE
A
MUST
BELOW
WE
MENTION
THE
GIS
RELATED
PROBLEMS
TREATED
IN
THIS
BOOK
A
FIRST
QUESTION
IS
HOW
TO
STORE
GEOGRAPHIC
DATA
SUPPOSE
THAT
WE
WANT
TO
DEVELOP
A
CAR
GUIDANCE
SYSTEM
WHICH
SHOWS
THE
DRIVER
AT
ANY
MOMENT
WHERE
SHE
IS
THIS
REQUIRES
STORING
A
HUGE
MAP
OF
ROADS
AND
OTHER
DATA
AT
EVERY
MOMENT
WE
HAVE
TO
BE
ABLE
TO
DETERMINE
THE
POSITION
OF
THE
CAR
ON
THE
MAP
AND
TO
QUICKLY
SELECT
A
SMALL
PORTION
OF
THE
MAP
FOR
DISPLAY
ON
THE
ON
BOARD
COMPUTER
EFFICIENT
DATA
STRUCTURES
ARE
NEEDED
FOR
THESE
OPERATIONS
CHAPTERS
AND
DESCRIBE
COMPUTATIONAL
GEOMETRY
SOLUTIONS
TO
THESE
PROBLEMS
THE
INFORMATION
ABOUT
THE
HEIGHT
IN
SOME
MOUNTAINOUS
TERRAIN
IS
USUALLY
ONLY
AVAILABLE
AT
CERTAIN
SAMPLE
POINTS
FOR
OTHER
POSITIONS
WE
HAVE
TO
OBTAIN
THE
HEIGHTS
BY
INTERPOLATING
BETWEEN
NEARBY
SAMPLE
POINTS
BUT
WHICH
SAMPLE
POINTS
SHOULD
WE
CHOOSE
CHAPTER
DEALS
WITH
THIS
PROBLEM
THE
COMBINATION
OF
DIFFERENT
TYPES
OF
DATA
IS
ONE
OF
THE
MOST
IMPORTANT
OPERATIONS
IN
A
GIS
FOR
EXAMPLE
WE
MAY
WANT
TO
CHECK
WHICH
HOUSES
LIE
IN
CHAPTER
COMPUTATIONAL
GEOMETRY
CAFFEINE
A
FOREST
LOCATE
ALL
BRIDGES
BY
CHECKING
WHERE
ROADS
CROSS
RIVERS
OR
DETERMINE
A
GOOD
LOCATION
FOR
A
NEW
GOLF
COURSE
BY
FINDING
A
SLIGHTLY
HILLY
RATHER
CHEAP
AREA
NOT
TOO
FAR
FROM
A
PARTICULAR
TOWN
A
GIS
USUALLY
STORES
DIFFERENT
TYPES
OF
DATA
IN
SEPARATE
MAPS
TO
COMBINE
THE
DATA
WE
HAVE
TO
OVERLAY
DIFFERENT
MAPS
CHAPTER
DEALS
WITH
A
PROBLEM
ARISING
WHEN
WE
WANT
TO
COMPUTE
THE
OVERLAY
FINALLY
WE
MENTION
THE
SAME
EXAMPLE
WE
GAVE
AT
THE
BEGINNING
OF
THIS
CHAPTER
THE
LOCATION
OF
THE
NEAREST
PUBLIC
PHONE
OR
HOSPITAL
OR
ANY
OTHER
FACILITY
THIS
REQUIRES
THE
COMPUTATION
OF
A
VORONOI
DIAGRAM
A
STRUCTURE
STUDIED
IN
DETAIL
IN
CHAPTER
CAD
CAM
COMPUTER
AIDED
DESIGN
CAD
CONCERNS
ITSELF
WITH
THE
DESIGN
OF
PRODUCTS
WITH
A
COMPUTER
THE
PRODUCTS
CAN
VARY
FROM
PRINTED
CIRCUIT
BOARDS
MACHINE
PARTS
OR
FURNITURE
TO
COMPLETE
BUILDINGS
IN
ALL
CASES
THE
RESULTING
PRODUCT
IS
A
GEOMETRIC
ENTITY
AND
HENCE
IT
IS
TO
BE
EXPECTED
THAT
ALL
SORTS
OF
GEOMETRIC
PROBLEMS
APPEAR
INDEED
CAD
PACKAGES
HAVE
TO
DEAL
WITH
INTERSEC
TIONS
AND
UNIONS
OF
OBJECTS
WITH
DECOMPOSING
OBJECTS
AND
OBJECT
BOUNDARIES
INTO
SIMPLER
SHAPES
AND
WITH
VISUALIZING
THE
DESIGNED
PRODUCTS
TO
DECIDE
WHETHER
A
DESIGN
MEETS
THE
SPECIFICATIONS
CERTAIN
TESTS
ARE
NEEDED
OFTEN
ONE
DOES
NOT
NEED
TO
BUILD
A
PROTOTYPE
FOR
THESE
TESTS
AND
A
SIMULATION
SUFFICES
CHAPTER
DEALS
WITH
A
PROBLEM
ARISING
IN
THE
SIMULATION
OF
HEAT
EMISSION
BY
A
PRINTED
CIRCUIT
BOARD
ONCE
AN
OBJECT
HAS
BEEN
DESIGNED
AND
TESTED
IT
HAS
TO
BE
MANUFACTURED
COMPUTER
AIDED
MANUFACTURING
CAM
PACKAGES
CAN
BE
OF
ASSISTANCE
HERE
CAM
INVOLVES
MANY
GEOMETRIC
PROBLEMS
CHAPTER
STUDIES
ONE
OF
THEM
A
RECENT
TREND
IS
DESIGN
FOR
ASSEMBLY
WHERE
ASSEMBLY
DECISIONS
ARE
ALREADY
TAKEN
INTO
ACCOUNT
DURING
THE
DESIGN
STAGE
A
CAD
SYSTEM
SUPPORTING
THIS
WOULD
ALLOW
DESIGNERS
TO
TEST
THEIR
DESIGN
FOR
FEASIBILITY
ANSWERING
QUESTIONS
LIKE
CAN
THE
PRODUCT
BE
BUILT
EASILY
USING
A
CERTAIN
MANUFACTURING
PROCESS
MANY
OF
THESE
QUESTIONS
REQUIRE
GEOMETRIC
ALGORITHMS
TO
BE
ANSWERED
OTHER
APPLICATIONS
DOMAINS
THERE
ARE
MANY
MORE
APPLICATION
DOMAINS
WHERE
GEOMETRIC
PROBLEMS
OCCUR
AND
GEOMETRIC
ALGORITHMS
AND
DATA
STRUCTURES
CAN
BE
USED
TO
SOLVE
THEM
FOR
EXAMPLE
IN
MOLECULAR
MODELING
MOLECULES
ARE
OFTEN
REPRESENTED
BY
COLLECTIONS
OF
INTERSECTING
BALLS
IN
SPACE
ONE
BALL
FOR
EACH
ATOM
TYPICAL
QUESTIONS
ARE
TO
COMPUTE
THE
UNION
OF
THE
ATOM
BALLS
TO
OBTAIN
THE
MOLECULE
SURFACE
OR
TO
COMPUTE
WHERE
TWO
MOLECULES
CAN
TOUCH
EACH
OTHER
ANOTHER
AREA
IS
PATTERN
RECOGNITION
CONSIDER
FOR
EXAMPLE
AN
OPTICAL
CHAR
ACTER
RECOGNITION
SYSTEM
SUCH
A
SYSTEM
SCANS
A
PAPER
WITH
TEXT
ON
IT
WITH
THE
GOAL
OF
RECOGNIZING
THE
TEXT
CHARACTERS
A
BASIC
STEP
IS
TO
MATCH
THE
IMAGE
OF
A
CHARACTER
AGAINST
A
COLLECTION
OF
STORED
CHARACTERS
TO
FIND
THE
ONE
THAT
BEST
FITS
IT
THIS
LEADS
TO
A
GEOMETRIC
PROBLEM
GIVEN
TWO
GEOMETRIC
OBJECTS
DETERMINE
HOW
WELL
THEY
RESEMBLE
EACH
OTHER
EVEN
CERTAIN
AREAS
THAT
AT
FIRST
SIGHT
DO
NOT
SEEM
TO
BE
GEOMETRIC
CAN
BEN
EFIT
FROM
GEOMETRIC
ALGORITHMS
BECAUSE
IT
IS
OFTEN
POSSIBLE
TO
FORMULATE
NON
GEOMETRIC
PROBLEM
IN
GEOMETRIC
TERMS
IN
CHAPTER
FOR
INSTANCE
WE
WILL
SEE
HOW
RECORDS
IN
A
DATABASE
CAN
BE
INTERPRETED
AS
POINTS
IN
A
HIGHER
DIMENSIONAL
SPACE
AND
WE
WILL
PRESENT
A
GEOMETRIC
DATA
STRUCTURE
SUCH
THAT
CERTAIN
QUERIES
ON
THE
RECORDS
CAN
BE
ANSWERED
EFFICIENTLY
WE
HOPE
THAT
THE
ABOVE
COLLECTION
OF
GEOMETRIC
PROBLEMS
MAKES
IT
CLEAR
THAT
COMPUTATIONAL
GEOMETRY
PLAYS
A
ROLE
IN
MANY
DIFFERENT
AREAS
OF
COMPUTER
SCI
ENCE
THE
ALGORITHMS
DATA
STRUCTURES
AND
TECHNIQUES
DESCRIBED
IN
THIS
BOOK
WILL
PROVIDE
YOU
WITH
THE
TOOLS
NEEDED
TO
ATTACK
SUCH
GEOMETRIC
PROBLEMS
SUCCESSFULLY
SECTION
NOTES
AND
COMMENTS
NOTES
AND
COMMENTS
EVERY
CHAPTER
OF
THIS
BOOK
ENDS
WITH
A
SECTION
ENTITLED
NOTES
AND
COMMENTS
THESE
SECTIONS
INDICATE
WHERE
THE
RESULTS
DESCRIBED
IN
THE
CHAPTER
CAME
FROM
INDICATE
GENERALIZATIONS
AND
IMPROVEMENTS
AND
PROVIDE
REFERENCES
THEY
CAN
BE
SKIPPED
BUT
DO
CONTAIN
USEFUL
MATERIAL
FOR
THOSE
WHO
WANT
TO
KNOW
MORE
ABOUT
THE
TOPIC
OF
THE
CHAPTER
MORE
INFORMATION
CAN
ALSO
BE
FOUND
IN
THE
HANDBOOK
OF
COMPUTATIONAL
GEOMETRY
AND
THE
HANDBOOK
OF
DISCRETE
AND
COMPUTATIONAL
GEOMETRY
IN
THIS
CHAPTER
THE
GEOMETRIC
PROBLEM
TREATED
IN
DETAIL
WAS
THE
COMPUTATION
OF
THE
CONVEX
HULL
OF
A
SET
OF
POINTS
IN
THE
PLANE
THIS
IS
A
CLASSIC
TOPIC
IN
COMPUTATIONAL
GEOMETRY
AND
THE
AMOUNT
OF
LITERATURE
ABOUT
IT
IS
HUGE
THE
ALGORITHM
DESCRIBED
IN
THIS
CHAPTER
IS
COMMONLY
KNOWN
AS
GRAHAM
SCAN
AND
IS
BASED
ON
A
MODIFICATION
BY
ANDREW
OF
ONE
OF
THE
EARLIEST
ALGORITHMS
BY
GRAHAM
THIS
IS
ONLY
ONE
OF
THE
MANY
O
N
LOG
N
ALGORITHMS
AVAILABLE
FOR
SOLVING
THE
PROBLEM
A
DIVIDE
AND
CONQUER
APPROACH
WAS
GIVEN
BY
PREPARATA
AND
HONG
ALSO
AN
INCREMENTAL
METHOD
EXISTS
THAT
INSERTS
THE
POINTS
ONE
BY
ONE
IN
O
LOG
N
TIME
PER
INSERTION
OVERMARS
AND
VAN
LEEUWEN
GENERALIZED
THIS
TO
A
METHOD
IN
WHICH
POINTS
COULD
BE
BOTH
INSERTED
AND
DELETED
IN
O
N
TIME
OTHER
RESULTS
ON
DYNAMIC
CONVEX
HULLS
WERE
OBTAINED
BY
HERSHBERGER
AND
SURI
CHAN
AND
BRODAL
AND
JACOB
EVEN
THOUGH
AN

N
LOG
N
LOWER
BOUND
IS
KNOWN
FOR
THE
PROBLEM
MANY
AUTHORS
HAVE
TRIED
TO
IMPROVE
THE
RESULT
THIS
MAKES
SENSE
BECAUSE
IN
MANY
APPLICATIONS
THE
NUMBER
OF
POINTS
THAT
APPEAR
ON
THE
CONVEX
HULL
IS
RELATIVELY
SMALL
WHILE
THE
LOWER
BOUND
RESULT
ASSUMES
THAT
ALMOST
ALL
POINTS
SHOW
UP
ON
THE
CONVEX
HULL
HENCE
IT
IS
USEFUL
TO
LOOK
AT
ALGORITHMS
WHOSE
RUNNING
TIME
DEPENDS
ON
THE
COMPLEXITY
OF
THE
CONVEX
HULL
JARVIS
INTRODUCED
A
WRAPPING
TECHNIQUE
OFTEN
REFERRED
TO
AS
JARVIS
MARCH
THAT
COMPUTES
THE
CONVEX
HULL
IN
O
H
N
TIME
WHERE
H
IS
THE
COMPLEXITY
OF
THE
CONVEX
HULL
THE
SAME
WORST
CASE
PERFORMANCE
IS
ACHIEVED
BY
THE
ALGORITHM
OF
OVERMARS
AND
VAN
LEEUWEN
BASED
ON
EARLIER
WORK
BY
BYKAT
EDDY
AND
GREEN
AND
SILVERMAN
THIS
ALGORITHM
HAS
THE
ADVANTAGE
THAT
ITS
EXPECTED
RUNNING
TIME
IS
LINEAR
FOR
MANY
DISTRIBUTIONS
OF
POINTS
FINALLY
KIRKPATRICK
AND
SEIDEL
IMPROVED
THE
RESULT
TO
O
N
LOG
H
AND
RECENTLY
CHAN
DISCOVERED
A
MUCH
SIMPLER
ALGORITHM
TO
ACHIEVE
THE
SAME
RESULT
CHAPTER
COMPUTATIONAL
GEOMETRY
THE
CONVEX
HULL
CAN
BE
DEFINED
IN
ANY
DIMENSION
CONVEX
HULLS
IN
DIMENSIONAL
SPACE
CAN
STILL
BE
COMPUTED
IN
O
N
LOG
N
TIME
AS
WE
WILL
SEE
IN
CHAPTER
FOR
DIMENSIONS
HIGHER
THAN
HOWEVER
THE
COMPLEXITY
OF
THE
CONVEX
HULL
IS
NO
LONGER
LINEAR
IN
THE
NUMBER
OF
POINTS
SEE
THE
NOTES
AND
COMMENTS
OF
CHAPTER
FOR
MORE
DETAILS
IN
THE
PAST
YEARS
A
NUMBER
OF
GENERAL
METHODS
FOR
HANDLING
SPECIAL
CASES
HAVE
BEEN
SUGGESTED
THESE
SYMBOLIC
PERTURBATION
SCHEMES
PERTURB
THE
INPUT
IN
SUCH
A
WAY
THAT
ALL
DEGENERACIES
DISAPPEAR
HOWEVER
THE
PERTURBATION
IS
ONLY
DONE
SYMBOLICALLY
THIS
TECHNIQUE
WAS
INTRODUCED
BY
EDELSBRUNNER
AND
MU
CKE
AND
LATER
REFINED
BY
YAP
AND
EMIRIS
AND
CANNY
SYMBOLIC
PERTURBATION
RELIEVES
THE
PROGRAMMER
OF
THE
BURDEN
OF
DEGENERACIES
BUT
IT
HAS
SOME
DRAWBACKS
THE
USE
OF
A
SYMBOLIC
PERTURBATION
LIBRARY
SLOWS
DOWN
THE
ALGORITHM
AND
SOMETIMES
ONE
NEEDS
TO
RECOVER
THE
REAL
RESULT
FROM
THE
PERTURBED
RESULT
WHICH
IS
NOT
ALWAYS
EASY
THESE
DRAWBACKS
LED
BURNIKEL
ET
AL
TO
CLAIM
THAT
IT
IS
BOTH
SIMPLER
IN
TERMS
OF
PROGRAMMING
EFFORT
AND
MORE
EFFICIENT
IN
TERMS
OF
RUNNING
TIME
TO
DEAL
DIRECTLY
WITH
DEGENERATE
INPUTS
ROBUSTNESS
IN
GEOMETRIC
ALGORITHMS
IS
A
TOPIC
THAT
HAS
RECENTLY
RECEIVED
A
LOT
OF
INTEREST
MOST
GEOMETRIC
COMPARISONS
CAN
BE
FORMULATED
AS
COMPUTING
THE
SIGN
OF
SOME
DETERMINANT
A
POSSIBLE
WAY
TO
DEAL
WITH
THE
INEXACTNESS
IN
FLOATING
POINT
ARITHMETIC
WHEN
EVALUATING
THIS
SIGN
IS
TO
CHOOSE
A
SMALL
THRESHOLD
VALUE

AND
TO
SAY
THAT
THE
DETERMINANT
IS
ZERO
WHEN
THE
OUTCOME
OF
THE
FLOATING
POINT
COMPUTATION
IS
LESS
THAN

WHEN
IMPLEMENTED
NAIVELY
THIS
CAN
LEAD
TO
INCONSISTENCIES
FOR
INSTANCE
FOR
THREE
POINTS
A
B
C
WE
MAY
DECIDE
THAT
A
B
AND
B
C
BUT
A
C
THAT
CAUSE
THE
PROGRAM
TO
FAIL
GUIBAS
ET
AL
SHOWED
THAT
COMBINING
SUCH
AN
APPROACH
WITH
INTERVAL
ARITHMETIC
AND
BACKWARDS
ERROR
ANALYSIS
CAN
GIVE
ROBUST
ALGORITHMS
ANOTHER
OPTION
IS
TO
USE
EXACT
ARITHMETIC
HERE
ONE
COMPUTES
AS
MANY
BITS
OF
THE
DETERMINANT
AS
ARE
NEEDED
TO
DETERMINE
ITS
SIGN
THIS
WILL
SLOW
DOWN
THE
COMPUTATION
BUT
TECHNIQUES
HAVE
BEEN
DEVELOPED
TO
KEEP
THE
PERFORMANCE
PENALTY
RELATIVELY
SMALL
BESIDES
THESE
GENERAL
APPROACHES
THERE
HAVE
BEEN
A
NUMBER
PAPERS
DEALING
WITH
ROBUST
COMPUTATION
IN
SPECIFIC
PROBLEMS
WE
GAVE
A
BRIEF
OVERVIEW
OF
THE
APPLICATION
DOMAINS
FROM
WHICH
WE
TOOK
OUR
EXAMPLES
WHICH
SERVE
TO
SHOW
THE
MOTIVATION
BEHIND
THE
VARIOUS
GEOMETRIC
NOTIONS
AND
ALGORITHMS
STUDIED
IN
THIS
BOOK
BELOW
ARE
SOME
REFERENCES
TO
TEXTBOOKS
YOU
CAN
CONSULT
IF
YOU
WANT
TO
KNOW
MORE
ABOUT
THE
APPLICATION
DOMAINS
OF
COURSE
THERE
ARE
MANY
MORE
GOOD
BOOKS
ABOUT
THESE
DOMAINS
THAN
THE
FEW
WE
MENTION
THERE
IS
A
LARGE
NUMBER
OF
BOOKS
ON
COMPUTER
GRAPHICS
THE
BOOK
BY
FOLEY
ET
AL
IS
VERY
EXTENSIVE
AND
GENERALLY
CONSIDERED
ONE
OF
THE
BEST
BOOKS
ON
THE
TOPIC
OTHER
GOOD
BOOKS
ARE
THE
ONES
BY
SHIRLEY
ET
AL
AND
WATT
AN
EXTENSIVE
OVERVIEW
OF
ROBOTICS
AND
THE
MOTION
PLANNING
PROBLEM
CAN
BE
FOUND
IN
THE
BOOK
OF
CHOSET
ET
AL
AND
IN
THE
SOMEWHAT
OLDER
BOOKS
OF
LATOMBE
AND
HOPCROFT
SCHWARTZ
AND
SHARIR
MORE
INFORMATION
ON
GEOMETRIC
ASPECTS
OF
ROBOTICS
IS
PROVIDED
BY
THE
BOOK
OF
SELIG
THERE
IS
A
LARGE
COLLECTION
OF
BOOKS
ABOUT
GEOGRAPHIC
INFORMATION
SYSTEMS
BUT
MOST
OF
THEM
DO
NOT
CONSIDER
ALGORITHMIC
ISSUES
IN
MUCH
DETAIL
SOME
GENERAL
TEXTBOOKS
ARE
THE
ONES
BY
DEMERS
LONGLEY
ET
AL
AND
WORBOYS
AND
DUCKHAM
DATA
STRUCTURES
FOR
SPATIAL
DATA
ARE
DESCRIBED
EXTENSIVELY
IN
THE
BOOK
OF
SAMET
THE
BOOKS
BY
FAUX
AND
PRATT
MORTENSON
AND
HOFFMANN
ARE
GOOD
INTRODUCTORY
TEXTS
ON
CAD
CAM
AND
GEOMETRIC
MODELING
EXERCISES
THE
CONVEX
HULL
OF
A
SET
IS
DEFINED
TO
BE
THE
INTERSECTION
OF
ALL
CONVEX
SETS
THAT
CONTAIN
FOR
THE
CONVEX
HULL
OF
A
SET
OF
POINTS
IT
WAS
INDICATED
THAT
THE
CONVEX
HULL
IS
THE
CONVEX
SET
WITH
SMALLEST
PERIMETER
WE
WANT
TO
SHOW
THAT
THESE
ARE
EQUIVALENT
DEFINITIONS
A
PROVE
THAT
THE
INTERSECTION
OF
TWO
CONVEX
SETS
IS
AGAIN
CONVEX
THIS
IMPLIES
THAT
THE
INTERSECTION
OF
A
FINITE
FAMILY
OF
CONVEX
SETS
IS
CONVEX
AS
WELL
B
PROVE
THAT
THE
SMALLEST
PERIMETER
POLYGON
P
CONTAINING
A
SET
OF
POINTS
P
IS
CONVEX
C
PROVE
THAT
ANY
CONVEX
SET
CONTAINING
THE
SET
OF
POINTS
P
CONTAINS
THE
SMALLEST
PERIMETER
POLYGON
P
LET
P
BE
A
SET
OF
POINTS
IN
THE
PLANE
LET
P
BE
THE
CONVEX
POLYGON
WHOSE
VERTICES
ARE
POINTS
FROM
P
AND
THAT
CONTAINS
ALL
POINTS
IN
P
PROVE
THAT
THIS
POLYGON
P
IS
UNIQUELY
DEFINED
AND
THAT
IT
IS
THE
INTERSECTION
OF
ALL
CONVEX
SETS
CONTAINING
P
LET
E
BE
AN
UNSORTED
SET
OF
N
SEGMENTS
THAT
ARE
THE
EDGES
OF
A
CONVEX
POLYGON
DESCRIBE
AN
O
N
LOG
N
ALGORITHM
THAT
COMPUTES
FROM
E
A
LIST
CONTAINING
ALL
VERTICES
OF
THE
POLYGON
SORTED
IN
CLOCKWISE
ORDER
FOR
THE
CONVEX
HULL
ALGORITHM
WE
HAVE
TO
BE
ABLE
TO
TEST
WHETHER
A
POINT
R
LIES
LEFT
OR
RIGHT
OF
THE
DIRECTED
LINE
THROUGH
TWO
POINTS
P
AND
Q
LET
P
PX
PY
Q
QX
QY
AND
R
RX
RY
A
SHOW
THAT
THE
SIGN
OF
THE
DETERMINANT
SECTION
EXERCISES
PX
PY
D
QX
QY
RX
RY
DETERMINES
WHETHER
R
LIES
LEFT
OR
RIGHT
OF
THE
LINE
B
SHOW
THAT
D
IN
FACT
IS
TWICE
THE
SURFACE
OF
THE
TRIANGLE
DETERMINED
BY
P
Q
AND
R
C
WHY
IS
THIS
AN
ATTRACTIVE
WAY
TO
IMPLEMENT
THE
BASIC
TEST
IN
ALGORITHM
CONVEXHULL
GIVE
AN
ARGUMENT
FOR
BOTH
INTEGER
AND
FLOATING
POINT
COORDINATES
CHAPTER
COMPUTATIONAL
GEOMETRY
VERIFY
THAT
THE
ALGORITHM
CONVEXHULL
WITH
THE
INDICATED
MODIFICATIONS
CORRECTLY
COMPUTES
THE
CONVEX
HULL
ALSO
OF
DEGENERATE
SETS
OF
POINTS
CONSIDER
FOR
EXAMPLE
SUCH
NASTY
CASES
AS
A
SET
OF
POINTS
THAT
ALL
LIE
ON
ONE
VERTICAL
LINE
IN
MANY
SITUATIONS
WE
NEED
TO
COMPUTE
CONVEX
HULLS
OF
OBJECTS
OTHER
THAN
POINTS
A
LET
BE
A
SET
OF
N
LINE
SEGMENTS
IN
THE
PLANE
PROVE
THAT
THE
CONVEX
HULL
OF
IS
EXACTLY
THE
SAME
AS
THE
CONVEX
HULL
OF
THE
ENDPOINTS
OF
THE
SEGMENTS
B
LET
P
BE
A
NON
CONVEX
POLYGON
DESCRIBE
AN
ALGORITHM
THAT
COMPUTES
THE
CONVEX
HULL
OF
P
IN
O
N
TIME
HINT
USE
A
VARIANT
OF
ALGORITHM
CONVEXHULL
WHERE
THE
VERTICES
ARE
NOT
TREATED
IN
LEXICOGRAPHICAL
ORDER
BUT
IN
SOME
OTHER
ORDER
CONSIDER
THE
FOLLOWING
ALTERNATIVE
APPROACH
TO
COMPUTING
THE
CONVEX
HULL
OF
A
SET
OF
POINTS
IN
THE
PLANE
WE
START
WITH
THE
RIGHTMOST
POINT
THIS
IS
THE
FIRST
POINT
OF
THE
CONVEX
HULL
NOW
IMAGINE
THAT
WE
START
WITH
A
VERTICAL
LINE
AND
ROTATE
IT
CLOCKWISE
UNTIL
IT
HITS
ANOTHER
POINT
THIS
IS
THE
SECOND
POINT
ON
THE
CONVEX
HULL
WE
CONTINUE
ROTATING
THE
LINE
BUT
THIS
TIME
AROUND
UNTIL
WE
HIT
A
POINT
IN
THIS
WAY
WE
CONTINUE
UNTIL
WE
REACH
AGAIN
A
GIVE
PSEUDOCODE
FOR
THIS
ALGORITHM
B
WHAT
DEGENERATE
CASES
CAN
OCCUR
AND
HOW
CAN
WE
DEAL
WITH
THEM
C
PROVE
THAT
THE
ALGORITHM
CORRECTLY
COMPUTES
THE
CONVEX
HULL
D
PROVE
THAT
THE
ALGORITHM
CAN
BE
IMPLEMENTED
TO
RUN
IN
TIME
O
N
H
WHERE
H
IS
THE
COMPLEXITY
OF
THE
CONVEX
HULL
E
WHAT
PROBLEMS
MIGHT
OCCUR
WHEN
WE
DEAL
WITH
INEXACT
FLOATING
POINT
ARITHMETIC
THE
O
N
LOG
N
ALGORITHM
TO
COMPUTE
THE
CONVEX
HULL
OF
A
SET
OF
N
POINTS
IN
THE
PLANE
THAT
WAS
DESCRIBED
IN
THIS
CHAPTER
IS
BASED
ON
THE
PARADIGM
OF
INCREMENTAL
CONSTRUCTION
ADD
THE
POINTS
ONE
BY
ONE
AND
UPDATE
THE
CONVEX
HULL
AFTER
EACH
ADDITION
IN
THIS
EXERCISE
WE
SHALL
DEVELOP
AN
ALGORITHM
BASED
ON
ANOTHER
PARADIGM
NAMELY
DIVIDE
AND
CONQUER
A
LET
AND
BE
TWO
DISJOINT
CONVEX
POLYGONS
WITH
N
VERTICES
IN
TOTAL
GIVE
AN
O
N
TIME
ALGORITHM
THAT
COMPUTES
THE
CONVEX
HULL
OF
B
USE
THE
ALGORITHM
FROM
PART
A
TO
DEVELOP
AN
O
N
LOG
N
TIME
DIVIDE
AND
CONQUER
ALGORITHM
TO
COMPUTE
THE
CONVEX
HULL
OF
A
SET
OF
N
POINTS
IN
THE
PLANE
SUPPOSE
THAT
WE
HAVE
A
SUBROUTINE
CONVEXHULL
AVAILABLE
FOR
COMPUT
ING
THE
CONVEX
HULL
OF
A
SET
OF
POINTS
IN
THE
PLANE
ITS
OUTPUT
IS
A
LIST
OF
CON
VEX
HULL
VERTICES
SORTED
IN
CLOCKWISE
ORDER
NOW
LET
XN
BE
A
SET
OF
N
NUMBERS
SHOW
THAT
CAN
BE
SORTED
IN
O
N
TIME
PLUS
THE
TIME
NEEDED
FOR
ONE
CALL
TO
CONVEXHULL
SINCE
THE
SORTING
PROBLEM
HAS
AN

N
LOG
N
LOWER
BOUND
THIS
IMPLIES
THAT
THE
CONVEX
HULL
PROBLEM
HAS
AN

N
LOG
N
LOWER
BOUND
AS
WELL
HENCE
THE
ALGORITHM
PRESENTED
IN
THIS
CHAPTER
IS
ASYMPTOTICALLY
OPTIMAL
LET
BE
A
SET
OF
N
POSSIBLY
INTERSECTING
UNIT
CIRCLES
IN
THE
PLANE
WE
WANT
TO
COMPUTE
THE
CONVEX
HULL
OF
A
SHOW
THAT
THE
BOUNDARY
OF
THE
CONVEX
HULL
OF
CONSISTS
OF
STRAIGHT
LINE
SEGMENTS
AND
PIECES
OF
CIRCLES
IN
B
SHOW
THAT
EACH
CIRCLE
CAN
OCCUR
AT
MOST
ONCE
ON
THE
BOUNDARY
OF
THE
CONVEX
HULL
C
LET
SL
BE
THE
SET
OF
POINTS
THAT
ARE
THE
CENTERS
OF
THE
CIRCLES
IN
SHOW
THAT
A
CIRCLE
IN
APPEARS
ON
THE
BOUNDARY
OF
THE
CONVEX
HULL
IF
AND
ONLY
IF
THE
CENTER
OF
THE
CIRCLE
LIES
ON
THE
CONVEX
HULL
OF
SL
D
GIVE
AN
O
N
LOG
N
ALGORITHM
FOR
COMPUTING
THE
CONVEX
HULL
OF
E
GIVE
AN
O
N
LOG
N
ALGORITHM
FOR
THE
CASE
IN
WHICH
THE
CIRCLES
IN
HAVE
DIFFERENT
RADII
SECTION
EXERCISES
LINE
SEGMENT
INTERSECTION
THEMATIC
MAP
OVERLAY
WHEN
YOU
ARE
VISITING
A
COUNTRY
MAPS
ARE
AN
INVALUABLE
SOURCE
OF
INFORMATION
THEY
TELL
YOU
WHERE
TOURIST
ATTRACTIONS
ARE
LOCATED
THEY
INDICATE
THE
ROADS
AND
RAILWAY
LINES
TO
GET
THERE
THEY
SHOW
SMALL
LAKES
AND
SO
ON
UNFORTUNATELY
THEY
CAN
ALSO
BE
A
SOURCE
OF
FRUSTRATION
AS
IT
IS
OFTEN
DIFFICULT
TO
FIND
THE
RIGHT
INFORMATION
EVEN
WHEN
YOU
KNOW
THE
APPROXIMATE
POSITION
OF
A
SMALL
TOWN
IT
CAN
STILL
BE
DIFFICULT
TO
SPOT
IT
ON
THE
MAP
TO
MAKE
MAPS
MORE
READABLE
GEOGRAPHIC
INFORMATION
SYSTEMS
SPLIT
THEM
INTO
SEVERAL
LAYERS
EACH
LAYER
IS
A
THEMATIC
MAP
THAT
IS
IT
STORES
ONLY
ONE
TYPE
OF
INFORMATION
THUS
THERE
WILL
FIGURE
CITIES
RIVERS
RAILROADS
AND
THEIR
OVERLAY
IN
WESTERN
CANADA
BE
A
LAYER
STORING
THE
ROADS
A
LAYER
STORING
THE
CITIES
A
LAYER
STORING
THE
RIVERS
CHAPTER
LINE
SEGMENT
INTERSECTION
GRIZZLY
BEAR
AND
SO
ON
THE
THEME
OF
A
LAYER
CAN
ALSO
BE
MORE
ABSTRACT
FOR
INSTANCE
THERE
COULD
BE
A
LAYER
FOR
THE
POPULATION
DENSITY
FOR
AVERAGE
PRECIPITATION
HABITAT
OF
THE
GRIZZLY
BEAR
OR
FOR
VEGETATION
THE
TYPE
OF
GEOMETRIC
INFORMATION
STORED
IN
A
LAYER
CAN
BE
VERY
DIFFERENT
THE
LAYER
FOR
A
ROAD
MAP
COULD
STORE
THE
ROADS
AS
COLLECTIONS
OF
LINE
SEGMENTS
OR
CURVES
PERHAPS
THE
LAYER
FOR
CITIES
COULD
CONTAIN
POINTS
LABELED
WITH
CITY
NAMES
AND
THE
LAYER
FOR
VEGETATION
COULD
STORE
A
SUBDIVISION
OF
THE
MAP
INTO
REGIONS
LABELED
WITH
THE
TYPE
OF
VEGETATION
USERS
OF
A
GEOGRAPHIC
INFORMATION
SYSTEM
CAN
SELECT
ONE
OF
THE
THEMATIC
MAPS
FOR
DISPLAY
TO
FIND
A
SMALL
TOWN
YOU
WOULD
SELECT
THE
LAYER
STORING
CITIES
AND
YOU
WOULD
NOT
BE
DISTRACTED
BY
INFORMATION
SUCH
AS
THE
NAMES
OF
RIVERS
AND
LAKES
AFTER
YOU
HAVE
SPOTTED
THE
TOWN
YOU
PROBABLY
WANT
TO
KNOW
HOW
TO
GET
THERE
TO
THIS
END
GEOGRAPHIC
INFORMATION
SYSTEMS
ALLOW
USERS
TO
VIEW
AN
OVERLAY
OF
SEVERAL
MAPS
SEE
FIGURE
USING
AN
OVERLAY
OF
THE
ROAD
MAP
AND
THE
MAP
STORING
CITIES
YOU
CAN
NOW
FIGURE
OUT
HOW
TO
GET
TO
THE
TOWN
WHEN
TWO
OR
MORE
THEMATIC
MAP
LAYERS
ARE
SHOWN
TOGETHER
INTERSECTIONS
IN
THE
OVERLAY
ARE
POSITIONS
OF
SPECIAL
INTEREST
FOR
EXAMPLE
WHEN
VIEWING
THE
OVERLAY
OF
THE
LAYER
FOR
THE
ROADS
AND
THE
LAYER
FOR
THE
RIVERS
IT
WOULD
BE
USEFUL
IF
THE
INTERSECTIONS
WERE
CLEARLY
MARKED
IN
THIS
EXAMPLE
THE
TWO
MAPS
ARE
BASICALLY
NETWORKS
AND
THE
INTERSECTIONS
ARE
POINTS
IN
OTHER
CASES
ONE
IS
INTERESTED
IN
THE
INTERSECTION
OF
COMPLETE
REGIONS
FOR
INSTANCE
GEOGRAPHERS
STUDYING
THE
CLIMATE
COULD
BE
INTERESTED
IN
FINDING
REGIONS
WHERE
THERE
IS
PINE
FOREST
AND
THE
ANNUAL
PRECIPITATION
IS
BETWEEN
MM
AND
MM
THESE
REGIONS
ARE
THE
INTERSECTIONS
OF
THE
REGIONS
LABELED
PINE
FOREST
IN
THE
VEGETATION
MAP
AND
THE
REGIONS
LABELED
IN
THE
PRECIPITATION
MAP
LINE
SEGMENT
INTERSECTION
WE
FIRST
STUDY
THE
SIMPLEST
FORM
OF
THE
MAP
OVERLAY
PROBLEM
WHERE
THE
TWO
MAP
LAYERS
ARE
NETWORKS
REPRESENTED
AS
COLLECTIONS
OF
LINE
SEGMENTS
FOR
EXAMPLE
A
MAP
LAYER
STORING
ROADS
RAILROADS
OR
RIVERS
AT
A
SMALL
SCALE
NOTE
THAT
CURVES
CAN
BE
APPROXIMATED
BY
A
NUMBER
OF
SMALL
SEGMENTS
AT
FIRST
WE
WON
T
BE
INTERESTED
IN
THE
REGIONS
INDUCED
BY
THESE
LINE
SEGMENTS
LATER
WE
SHALL
LOOK
AT
THE
MORE
COMPLEX
SITUATION
WHERE
THE
MAPS
ARE
NOT
JUST
NETWORKS
BUT
SUBDIVISIONS
OF
THE
PLANE
INTO
REGIONS
THAT
HAVE
AN
EXPLICIT
MEANING
TO
SOLVE
THE
NETWORK
OVERLAY
PROBLEM
WE
FIRST
HAVE
TO
STATE
IT
IN
A
GEOMETRIC
SETTING
FOR
THE
OVERLAY
OF
TWO
NETWORKS
THE
GEOMETRIC
SITUATION
IS
THE
FOLLOWING
GIVEN
TWO
SETS
OF
LINE
SEGMENTS
COMPUTE
ALL
INTERSECTIONS
BETWEEN
A
SEGMENT
FROM
ONE
SET
AND
A
SEGMENT
FROM
THE
OTHER
THIS
PROBLEM
SPECIFICATION
IS
NOT
QUITE
PRECISE
ENOUGH
YET
AS
WE
DIDN
T
DEFINE
WHEN
TWO
SEGMENTS
INTERSECT
IN
PARTICULAR
DO
TWO
SEGMENTS
INTERSECT
WHEN
AN
ENDPOINT
OF
ONE
OF
THEM
LIES
ON
THE
OTHER
IN
OTHER
WORDS
WE
HAVE
TO
SPECIFY
WHETHER
THE
INPUT
SEGMENTS
ARE
OPEN
OR
CLOSED
TO
MAKE
THIS
DECISION
WE
SHOULD
GO
BACK
TO
THE
APPLICATION
THE
NETWORK
OVERLAY
PROBLEM
ROADS
IN
A
ROAD
MAP
AND
RIVERS
IN
A
RIVER
MAP
ARE
REPRESENTED
BY
CHAINS
OF
SEGMENTS
SO
A
CROSSING
OF
A
ROAD
AND
A
RIVER
CORRESPONDS
TO
THE
INTERIOR
OF
ONE
CHAIN
INTERSECTING
THE
INTERIOR
OF
ANOTHER
CHAIN
THIS
DOES
NOT
MEAN
THAT
THERE
IS
AN
INTERSECTION
BETWEEN
THE
INTERIOR
OF
TWO
SEGMENTS
THE
INTERSECTION
POINT
COULD
HAPPEN
TO
COINCIDE
WITH
AN
ENDPOINT
OF
A
SEGMENT
OF
A
CHAIN
IN
FACT
THIS
SITUATION
IS
NOT
UNCOMMON
BECAUSE
WINDY
RIVERS
ARE
REPRESENTED
BY
MANY
SMALL
SEGMENTS
AND
COORDINATES
OF
ENDPOINTS
MAY
HAVE
BEEN
ROUNDED
WHEN
MAPS
ARE
DIGITIZED
WE
CONCLUDE
THAT
WE
SHOULD
DEFINE
THE
SEGMENTS
TO
BE
CLOSED
SO
THAT
AN
ENDPOINT
OF
ONE
SEGMENT
LYING
ON
ANOTHER
SEGMENT
COUNTS
AS
AN
INTERSECTION
TO
SIMPLIFY
THE
DESCRIPTION
SOMEWHAT
WE
SHALL
PUT
THE
SEGMENTS
FROM
THE
TWO
SETS
INTO
ONE
SET
AND
COMPUTE
ALL
INTERSECTIONS
AMONG
THE
SEGMENTS
IN
THAT
SET
THIS
WAY
WE
CERTAINLY
FIND
ALL
THE
INTERSECTIONS
WE
WANT
WE
MAY
ALSO
FIND
INTERSECTIONS
BETWEEN
SEGMENTS
FROM
THE
SAME
SET
ACTUALLY
WE
CERTAINLY
WILL
BECAUSE
IN
OUR
APPLICATION
THE
SEGMENTS
FROM
ONE
SET
FORM
A
NUMBER
OF
CHAINS
AND
WE
COUNT
COINCIDING
ENDPOINTS
AS
INTERSECTIONS
THESE
OTHER
INTERSECTIONS
CAN
BE
FILTERED
OUT
AFTERWARDS
BY
SIMPLY
CHECKING
FOR
EACH
REPORTED
INTERSECTION
WHETHER
THE
TWO
SEGMENTS
INVOLVED
BELONG
TO
THE
SAME
SET
SO
OUR
PROBLEM
SPECIFICATION
IS
AS
FOLLOWS
GIVEN
A
SET
OF
N
CLOSED
SEGMENTS
IN
THE
PLANE
REPORT
ALL
INTERSECTION
POINTS
AMONG
THE
SEGMENTS
IN
THIS
DOESN
T
SEEM
LIKE
A
CHALLENGING
PROBLEM
WE
CAN
SIMPLY
TAKE
EACH
PAIR
OF
SEGMENTS
COMPUTE
WHETHER
THEY
INTERSECT
AND
IF
SO
REPORT
THEIR
INTERSECTION
POINT
THIS
BRUTE
FORCE
ALGORITHM
CLEARLY
REQUIRES
O
TIME
IN
A
SENSE
THIS
IS
OPTIMAL
WHEN
EACH
PAIR
OF
SEGMENTS
INTERSECTS
ANY
ALGORITHM
MUST
TAKE

TIME
BECAUSE
IT
HAS
TO
REPORT
ALL
INTERSECTIONS
A
SIMILAR
EXAMPLE
CAN
BE
GIVEN
WHEN
THE
OVERLAY
OF
TWO
NETWORKS
IS
CONSIDERED
IN
PRACTICAL
SITUATIONS
HOWEVER
MOST
SEGMENTS
INTERSECT
NO
OR
ONLY
A
FEW
OTHER
SEGMENTS
SO
THE
TOTAL
NUMBER
OF
INTERSECTION
POINTS
IS
MUCH
SMALLER
THAN
QUADRATIC
IT
WOULD
BE
NICE
TO
HAVE
AN
ALGORITHM
THAT
IS
FASTER
IN
SUCH
SITUATIONS
IN
OTHER
WORDS
WE
WANT
AN
ALGORITHM
WHOSE
RUNNING
TIME
DEPENDS
NOT
ONLY
ON
THE
NUMBER
OF
SEGMENTS
IN
THE
INPUT
BUT
ALSO
ON
THE
NUMBER
OF
INTERSECTION
POINTS
SUCH
AN
ALGORITHM
IS
CALLED
AN
OUTPUT
SENSITIVE
ALGORITHM
THE
RUNNING
TIME
OF
THE
ALGORITHM
IS
SENSITIVE
TO
THE
SIZE
OF
THE
OUTPUT
WE
COULD
ALSO
CALL
SUCH
AN
ALGORITHM
INTERSECTION
SENSITIVE
SINCE
THE
NUMBER
OF
INTERSECTIONS
IS
WHAT
DETERMINES
THE
SIZE
OF
THE
OUTPUT
HOW
CAN
WE
AVOID
TESTING
ALL
PAIRS
OF
SEGMENTS
FOR
INTERSECTION
HERE
WE
MUST
MAKE
USE
OF
THE
GEOMETRY
OF
THE
SITUATION
SEGMENTS
THAT
ARE
CLOSE
TOGETHER
ARE
CANDIDATES
FOR
INTERSECTION
UNLIKE
SEGMENTS
THAT
ARE
FAR
APART
BELOW
WE
SHALL
SEE
HOW
WE
CAN
USE
THIS
OBSERVATION
TO
OBTAIN
AN
OUTPUT
SENSITIVE
ALGORITHM
FOR
THE
LINE
SEGMENT
INTERSECTION
PROBLEM
LET
SN
BE
THE
SET
OF
SEGMENTS
FOR
WHICH
WE
WANT
TO
COMPUTE
ALL
INTERSECTIONS
WE
WANT
TO
AVOID
TESTING
PAIRS
OF
SEGMENTS
THAT
ARE
FAR
APART
BUT
HOW
CAN
WE
DO
THIS
LET
FIRST
TRY
TO
RULE
OUT
AN
EASY
CASE
DEFINE
THE
Y
INTERVAL
OF
A
SEGMENT
TO
BE
ITS
ORTHOGONAL
PROJECTION
ONTO
THE
Y
AXIS
WHEN
THE
Y
INTERVALS
OF
A
PAIR
OF
SEGMENTS
DO
NOT
OVERLAP
WE
COULD
SAY
THAT
THEY
ARE
FAR
APART
IN
THE
Y
DIRECTION
THEN
THEY
CANNOT
INTERSECT
HENCE
WE
ONLY
NEED
TO
TEST
PAIRS
OF
SEGMENTS
WHOSE
Y
INTERVALS
OVERLAP
THAT
IS
PAIRS
FOR
WHICH
THERE
EXISTS
A
HORIZONTAL
LINE
THAT
INTERSECTS
BOTH
SEGMENTS
TO
FIND
THESE
PAIRS
WE
IMAGINE
SECTION
LINE
SEGMENT
INTERSECTION
Y
X
SWEEPING
A
LINE
F
DOWNWARDS
OVER
THE
PLANE
STARTING
FROM
A
POSITION
ABOVE
ALL
CHAPTER
LINE
SEGMENT
INTERSECTION
EVENT
POINT
NEW
NEIGHBORS
SEGMENTS
WHILE
WE
SWEEP
THE
IMAGINARY
LINE
WE
KEEP
TRACK
OF
ALL
SEGMENTS
INTERSECTING
IT
THE
DETAILS
OF
THIS
WILL
BE
EXPLAINED
LATER
SO
THAT
WE
CAN
FIND
THE
PAIRS
WE
NEED
THIS
TYPE
OF
ALGORITHM
IS
CALLED
A
PLANE
SWEEP
ALGORITHM
AND
THE
LINE
F
IS
CALLED
THE
SWEEP
LINE
THE
STATUS
OF
THE
SWEEP
LINE
IS
THE
SET
OF
SEGMENTS
INTERSECTING
IT
THE
STATUS
CHANGES
WHILE
THE
SWEEP
LINE
MOVES
DOWNWARDS
BUT
NOT
CONTINUOUSLY
ONLY
AT
PARTICULAR
POINTS
IS
AN
UPDATE
OF
THE
STATUS
REQUIRED
WE
CALL
THESE
POINTS
THE
EVENT
POINTS
OF
THE
PLANE
SWEEP
ALGORITHM
IN
THIS
ALGORITHM
THE
EVENT
POINTS
ARE
THE
ENDPOINTS
OF
THE
SEGMENTS
THE
MOMENTS
AT
WHICH
THE
SWEEP
LINE
REACHES
AN
EVENT
POINT
ARE
THE
ONLY
MOMENTS
WHEN
THE
ALGORITHM
ACTUALLY
DOES
SOMETHING
IT
UPDATES
THE
STATUS
OF
THE
SWEEP
LINE
AND
PERFORMS
SOME
INTERSECTION
TESTS
IN
PARTICULAR
IF
THE
EVENT
POINT
IS
THE
UPPER
ENDPOINT
OF
A
SEGMENT
THEN
A
NEW
SEGMENT
STARTS
INTERSECTING
THE
SWEEP
LINE
AND
MUST
BE
ADDED
TO
THE
STATUS
THIS
SEGMENT
IS
TESTED
FOR
INTERSECTION
AGAINST
THE
ONES
ALREADY
INTERSECTING
THE
SWEEP
LINE
IF
THE
EVENT
POINT
IS
A
LOWER
ENDPOINT
A
SEGMENT
STOPS
INTERSECTING
THE
SWEEP
LINE
AND
MUST
BE
DELETED
FROM
THE
STATUS
THIS
WAY
WE
ONLY
TEST
PAIRS
OF
SEGMENTS
FOR
WHICH
THERE
IS
A
HORIZONTAL
LINE
THAT
INTERSECTS
BOTH
SEGMENTS
UNFORTUNATELY
THIS
IS
NOT
ENOUGH
THERE
ARE
STILL
SITUATIONS
WHERE
WE
TEST
A
QUADRATIC
NUMBER
OF
PAIRS
WHEREAS
THERE
IS
ONLY
A
SMALL
NUMBER
OF
INTERSECTION
POINTS
A
SIMPLE
EXAMPLE
IS
A
SET
OF
VERTICAL
SEGMENTS
THAT
ALL
INTERSECT
THE
X
AXIS
SO
THE
ALGORITHM
IS
NOT
OUTPUT
SENSITIVE
THE
PROBLEM
IS
THAT
TWO
SEGMENTS
THAT
INTERSECT
THE
SWEEP
LINE
CAN
STILL
BE
FAR
APART
IN
THE
HORIZONTAL
DIRECTION
LET
ORDER
THE
SEGMENTS
FROM
LEFT
TO
RIGHT
AS
THEY
INTERSECT
THE
SWEEP
LINE
TO
INCLUDE
THE
IDEA
OF
BEING
CLOSE
IN
THE
HORIZONTAL
DIRECTION
WE
SHALL
ONLY
TEST
SEGMENTS
WHEN
THEY
ARE
ADJACENT
IN
THE
HORIZONTAL
ORDERING
THIS
MEANS
THAT
WE
ONLY
TEST
ANY
NEW
SEGMENT
AGAINST
TWO
SEGMENTS
NAMELY
THE
ONES
IMMEDIATELY
LEFT
AND
RIGHT
OF
THE
UPPER
ENDPOINT
LATER
WHEN
THE
SWEEP
LINE
HAS
MOVED
DOWNWARDS
TO
ANOTHER
POSITION
A
SEGMENT
CAN
BECOME
ADJACENT
TO
OTHER
SEGMENTS
AGAINST
WHICH
IT
WILL
BE
TESTED
OUR
NEW
STRATEGY
SHOULD
BE
REFLECTED
IN
THE
STATUS
OF
OUR
ALGORITHM
THE
STATUS
NOW
CORRESPONDS
TO
THE
ORDERED
SEQUENCE
OF
SEGMENTS
INTERSECTING
THE
SWEEP
LINE
THE
NEW
STATUS
NOT
ONLY
CHANGES
AT
ENDPOINTS
OF
SEGMENTS
IT
ALSO
CHANGES
AT
INTERSECTION
POINTS
WHERE
THE
ORDER
OF
THE
INTERSECTED
SEGMENTS
CHANGES
WHEN
THIS
HAPPENS
WE
MUST
TEST
THE
TWO
SEGMENTS
THAT
CHANGE
POSITION
AGAINST
THEIR
NEW
NEIGHBORS
THIS
IS
A
NEW
TYPE
OF
EVENT
POINT
BEFORE
TRYING
TO
TURN
THESE
IDEAS
INTO
AN
EFFICIENT
ALGORITHM
WE
SHOULD
CONVINCE
OURSELVES
THAT
THE
APPROACH
IS
CORRECT
WE
HAVE
REDUCED
THE
NUMBER
OF
PAIRS
TO
BE
TESTED
BUT
DO
WE
STILL
FIND
ALL
INTERSECTIONS
IN
OTHER
WORDS
IF
TWO
SEGMENTS
SI
AND
J
INTERSECT
IS
THERE
ALWAYS
A
POSITION
OF
THE
SWEEP
LINE
F
WHERE
SI
AND
J
ARE
ADJACENT
ALONG
F
LET
FIRST
IGNORE
SOME
NASTY
CASES
ASSUME
THAT
NO
SEGMENT
IS
HORIZONTAL
THAT
ANY
TWO
SEGMENTS
INTERSECT
IN
AT
MOST
ONE
POINT
THEY
DO
NOT
OVERLAP
AND
THAT
NO
THREE
SEGMENTS
MEET
IN
A
COMMON
POINT
LATER
WE
SHALL
SEE
THAT
THESE
CASES
ARE
EASY
TO
HANDLE
BUT
FOR
NOW
IT
IS
CONVENIENT
TO
FORGET
ABOUT
THEM
THE
INTERSECTIONS
WHERE
AN
ENDPOINT
OF
A
SEGMENT
LIES
ON
ANOTHER
SEGMENT
CAN
EASILY
BE
DETECTED
WHEN
THE
SWEEP
LINE
REACHES
THE
ENDPOINT
SO
THE
ONLY
QUESTION
IS
WHETHER
INTERSECTIONS
BETWEEN
THE
INTERIORS
OF
SEGMENTS
ARE
ALWAYS
DETECTED
LEMMA
LET
SI
AND
J
BE
TWO
NON
HORIZONTAL
SEGMENTS
WHOSE
INTERIORS
INTERSECT
IN
A
SINGLE
POINT
P
AND
ASSUME
THERE
IS
NO
THIRD
SEGMENT
PASSING
THROUGH
P
THEN
THERE
IS
AN
EVENT
POINT
ABOVE
P
WHERE
SI
AND
J
BECOME
ADJACENT
AND
ARE
TESTED
FOR
INTERSECTION
PROOF
LET
F
BE
A
HORIZONTAL
LINE
SLIGHTLY
ABOVE
P
IF
F
IS
CLOSE
ENOUGH
TO
P
THEN
SI
AND
J
MUST
BE
ADJACENT
ALONG
F
TO
BE
PRECISE
WE
SHOULD
TAKE
F
SUCH
THAT
THERE
IS
NO
EVENT
POINT
ON
F
NOR
IN
BETWEEN
F
AND
THE
HORIZONTAL
LINE
THROUGH
P
IN
OTHER
WORDS
THERE
IS
A
POSITION
OF
THE
SWEEP
LINE
WHERE
SI
AND
J
ARE
ADJACENT
ON
THE
OTHER
HAND
SI
AND
J
ARE
NOT
YET
ADJACENT
WHEN
THE
ALGORITHM
STARTS
BECAUSE
THE
SWEEP
LINE
STARTS
ABOVE
ALL
LINE
SEGMENTS
AND
THE
STATUS
IS
EMPTY
HENCE
THERE
MUST
BE
AN
EVENT
POINT
Q
WHERE
SI
AND
J
BECOME
ADJACENT
AND
ARE
TESTED
FOR
INTERSECTION
SECTION
LINE
SEGMENT
INTERSECTION
SI
J
F
P
SO
OUR
APPROACH
IS
CORRECT
AT
LEAST
WHEN
WE
FORGET
ABOUT
THE
NASTY
CASES
MENTIONED
EARLIER
NOW
WE
CAN
PROCEED
WITH
THE
DEVELOPMENT
OF
THE
PLANE
SWEEP
ALGORITHM
LET
BRIEFLY
RECAP
THE
OVERALL
APPROACH
WE
IMAGINE
MOVING
A
HORIZONTAL
SWEEP
LINE
F
DOWNWARDS
OVER
THE
PLANE
THE
SWEEP
LINE
HALTS
AT
CERTAIN
EVENT
POINTS
IN
OUR
CASE
THESE
ARE
THE
ENDPOINTS
OF
THE
SEGMENTS
WHICH
WE
KNOW
BEFOREHAND
AND
THE
INTERSECTION
POINTS
WHICH
ARE
COMPUTED
ON
THE
FLY
WHILE
THE
SWEEP
LINE
MOVES
WE
MAINTAIN
THE
ORDERED
SEQUENCE
OF
SEGMENTS
INTERSECTED
BY
IT
WHEN
THE
SWEEP
LINE
HALTS
AT
AN
EVENT
POINT
THE
SEQUENCE
OF
SEGMENTS
CHANGES
AND
DEPENDING
ON
THE
TYPE
OF
EVENT
POINT
WE
HAVE
TO
TAKE
SEVERAL
ACTIONS
TO
UPDATE
THE
STATUS
AND
DETECT
INTERSECTIONS
WHEN
THE
EVENT
POINT
IS
THE
UPPER
ENDPOINT
OF
A
SEGMENT
THERE
IS
A
NEW
SEGMENT
INTERSECTING
THE
SWEEP
LINE
THIS
SEGMENT
MUST
BE
TESTED
FOR
INTERSECTION
AGAINST
ITS
TWO
NEIGHBORS
ALONG
THE
SWEEP
LINE
ONLY
INTERSECTION
POINTS
BELOW
THE
SWEEP
LINE
ARE
IMPORTANT
THE
ONES
ABOVE
THE
SWEEP
LINE
HAVE
BEEN
DETECTED
ALREADY
FOR
EXAMPLE
IF
SEGMENTS
SI
AND
SK
ARE
ADJACENT
ON
THE
SWEEP
LINE
AND
A
NEW
UPPER
ENDPOINT
OF
A
SEGMENT
J
APPEARS
IN
BETWEEN
THEN
WE
HAVE
TO
TEST
J
FOR
INTERSECTION
WITH
SI
AND
SK
IF
WE
FIND
AN
INTERSECTION
BELOW
THE
SWEEP
LINE
WE
HAVE
FOUND
A
NEW
EVENT
POINT
AFTER
THE
UPPER
ENDPOINT
IS
HANDLED
WE
CONTINUE
TO
THE
NEXT
EVENT
POINT
WHEN
THE
EVENT
POINT
IS
AN
INTERSECTION
THE
TWO
SEGMENTS
THAT
INTERSECT
CHANGE
THEIR
ORDER
EACH
OF
THEM
GETS
AT
MOST
ONE
NEW
NEIGHBOR
AGAINST
WHICH
IT
IS
TESTED
FOR
INTERSECTION
AGAIN
ONLY
INTERSECTIONS
BELOW
THE
SWEEP
LINE
ARE
STILL
INTERESTING
SUPPOSE
THAT
FOUR
SEGMENTS
J
SK
SL
AND
SM
APPEAR
IN
THIS
ORDER
ON
THE
SWEEP
LINE
WHEN
THE
INTERSECTION
POINT
OF
SK
AND
SL
IS
REACHED
THEN
SK
AND
SL
SWITCH
POSITION
AND
WE
MUST
TEST
SL
AND
J
FOR
INTERSECTION
BELOW
THE
SWEEP
LINE
AND
ALSO
SK
AND
SM
THE
NEW
INTERSECTIONS
THAT
WE
FIND
ARE
OF
COURSE
ALSO
EVENT
POINTS
FOR
THE
ALGORITHM
NOTE
HOWEVER
THAT
IT
IS
POSSIBLE
THAT
THESE
EVENTS
HAVE
ALREADY
BEEN
DETECTED
EARLIER
NAMELY
IF
A
PAIR
BECOMING
ADJACENT
SI
SK
J
F
INTERSECTION
DETECTED
HAS
BEEN
ADJACENT
BEFORE
CHAPTER
LINE
SEGMENT
INTERSECTION
WHEN
THE
EVENT
POINT
IS
THE
LOWER
ENDPOINT
OF
A
SEGMENT
ITS
TWO
NEIGHBORS
NOW
BECOME
ADJACENT
AND
MUST
BE
TESTED
FOR
INTERSECTION
IF
THEY
INTERSECT
BELOW
THE
SWEEP
LINE
THEN
THEIR
INTERSECTION
POINT
IS
AN
EVENT
POINT
AGAIN
THIS
EVENT
COULD
HAVE
BEEN
DETECTED
ALREADY
ASSUME
THREE
SEGMENTS
SK
SL
AND
SM
APPEAR
IN
THIS
ORDER
ON
THE
SWEEP
LINE
WHEN
THE
LOWER
ENDPOINT
OF
SL
IS
ENCOUNTERED
THEN
SK
AND
SM
WILL
BECOME
ADJACENT
AND
WE
TEST
THEM
FOR
INTERSECTION
AFTER
WE
HAVE
SWEPT
THE
WHOLE
PLANE
MORE
PRECISELY
AFTER
WE
HAVE
TREATED
THE
LAST
EVENT
POINT
WE
HAVE
COMPUTED
ALL
INTERSECTION
POINTS
THIS
IS
GUARAN
TEED
BY
THE
FOLLOWING
INVARIANT
WHICH
HOLDS
AT
ANY
TIME
DURING
THE
PLANE
SWEEP
ALL
INTERSECTION
POINTS
ABOVE
THE
SWEEP
LINE
HAVE
BEEN
COMPUTED
CORRECTLY
AFTER
THIS
SKETCH
OF
THE
ALGORITHM
IT
TIME
TO
GO
INTO
MORE
DETAIL
IT
ALSO
TIME
TO
LOOK
AT
THE
DEGENERATE
CASES
THAT
CAN
ARISE
LIKE
THREE
OR
MORE
SEGMENTS
MEETING
IN
A
POINT
WE
SHOULD
FIRST
SPECIFY
WHAT
WE
EXPECT
FROM
THE
ALGORITHM
IN
THESE
CASES
WE
COULD
REQUIRE
THE
ALGORITHM
TO
SIMPLY
REPORT
EACH
INTERSECTION
POINT
ONCE
BUT
IT
SEEMS
MORE
USEFUL
IF
IT
REPORTS
FOR
EACH
INTERSECTION
POINT
A
LIST
OF
SEGMENTS
THAT
PASS
THROUGH
IT
OR
HAVE
IT
AS
AN
ENDPOINT
THERE
IS
ANOTHER
SPECIAL
CASE
FOR
WHICH
WE
SHOULD
DEFINE
THE
REQUIRED
OUTPUT
MORE
CAREFULLY
NAMELY
THAT
OF
TWO
PARTIALLY
OVERLAPPING
SEGMENTS
BUT
FOR
SIMPLICITY
WE
SHALL
IGNORE
THIS
CASE
IN
THE
REST
OF
THIS
SECTION
WE
START
BY
DESCRIBING
THE
DATA
STRUCTURES
THE
ALGORITHM
USES
FIRST
OF
ALL
WE
NEED
A
DATA
STRUCTURE
CALLED
THE
EVENT
QUEUE
THAT
STORES
THE
EVENTS
WE
DENOTE
THE
EVENT
QUEUE
BY
Q
WE
NEED
AN
OPERATION
THAT
REMOVES
THE
NEXT
EVENT
THAT
WILL
OCCUR
FROM
Q
AND
RETURNS
IT
SO
THAT
IT
CAN
BE
TREATED
THIS
EVENT
IS
THE
HIGHEST
EVENT
BELOW
THE
SWEEP
LINE
IF
TWO
EVENT
POINTS
HAVE
THE
SAME
Y
COORDINATE
THEN
THE
ONE
WITH
SMALLER
X
COORDINATE
WILL
BE
RETURNED
IN
OTHER
WORDS
EVENT
POINTS
ON
THE
SAME
HORIZONTAL
LINE
ARE
TREATED
FROM
LEFT
TO
RIGHT
THIS
IMPLIES
THAT
WE
SHOULD
CONSIDER
THE
LEFT
ENDPOINT
OF
A
HORIZONTAL
SEGMENT
TO
BE
ITS
UPPER
ENDPOINT
AND
ITS
RIGHT
ENDPOINT
TO
BE
ITS
LOWER
ENDPOINT
YOU
CAN
ALSO
THINK
ABOUT
OUR
CONVENTION
AS
FOLLOWS
INSTEAD
OF
HAVING
A
HORIZONTAL
SWEEP
LINE
IMAGINE
IT
IS
SLOPING
JUST
A
TINY
BIT
UPWARD
AS
A
RESULT
THE
SWEEP
F
LINE
REACHES
THE
LEFT
ENDPOINT
OF
A
HORIZONTAL
SEGMENT
JUST
BEFORE
REACHING
THE
RIGHT
ENDPOINT
THE
EVENT
QUEUE
MUST
ALLOW
INSERTIONS
BECAUSE
NEW
EVENTS
WILL
BE
COMPUTED
ON
THE
FLY
NOTICE
THAT
TWO
EVENT
POINTS
CAN
COINCIDE
FOR
EXAMPLE
THE
UPPER
ENDPOINTS
OF
TWO
DISTINCT
SEGMENTS
MAY
COINCIDE
IT
IS
CONVENIENT
TO
TREAT
THIS
AS
ONE
EVENT
POINT
HENCE
AN
INSERTION
MUST
BE
ABLE
TO
CHECK
WHETHER
AN
EVENT
IS
ALREADY
PRESENT
IN
Q
WE
IMPLEMENT
THE
EVENT
QUEUE
AS
FOLLOWS
DEFINE
AN
ORDER
ON
THE
EVENT
POINTS
THAT
REPRESENTS
THE
ORDER
IN
WHICH
THEY
WILL
BE
HANDLED
HENCE
IF
P
AND
Q
ARE
TWO
EVENT
POINTS
THEN
WE
HAVE
P
Q
IF
AND
ONLY
IF
PY
QY
HOLDS
OR
PY
QY
AND
PX
QX
HOLDS
WE
STORE
THE
EVENT
POINTS
IN
A
BALANCED
BINARY
SEARCH
TREE
ORDERED
ACCORDING
TO
WITH
EACH
EVENT
POINT
P
IN
Q
WE
WILL
STORE
THE
SEGMENTS
STARTING
AT
P
THAT
IS
THE
SEGMENTS
WHOSE
UPPER
ENDPOINT
IS
P
THIS
INFORMATION
WILL
BE
NEEDED
TO
HANDLE
THE
EVENT
BOTH
OPERATIONS
FETCHING
THE
NEXT
EVENT
AND
INSERTING
AN
EVENT
TAKE
O
LOG
M
TIME
WHERE
M
IS
THE
NUMBER
OF
EVENTS
IN
Q
WE
DO
NOT
USE
A
HEAP
TO
IMPLEMENT
THE
EVENT
QUEUE
BECAUSE
WE
HAVE
TO
BE
ABLE
TO
TEST
WHETHER
A
GIVEN
EVENT
IS
ALREADY
PRESENT
IN
Q
SECOND
WE
NEED
TO
MAINTAIN
THE
STATUS
OF
THE
ALGORITHM
THIS
IS
THE
ORDERED
SEQUENCE
OF
SEGMENTS
INTERSECTING
THE
SWEEP
LINE
THE
STATUS
STRUCTURE
DENOTED
BY
T
IS
USED
TO
ACCESS
THE
NEIGHBORS
OF
A
GIVEN
SEGMENT
SO
THAT
THEY
CAN
BE
TESTED
FOR
INTERSECTION
WITH
THE
STATUS
STRUCTURE
MUST
BE
DYNAMIC
AS
SEGMENTS
START
OR
STOP
TO
INTERSECT
THE
SWEEP
LINE
THEY
MUST
BE
INSERTED
INTO
OR
DELETED
FROM
THE
STRUCTURE
BECAUSE
THERE
IS
A
WELL
DEFINED
ORDER
ON
THE
SEGMENTS
IN
THE
STATUS
STRUCTURE
WE
CAN
USE
A
BALANCED
BINARY
SEARCH
TREE
AS
STATUS
STRUCTURE
WHEN
YOU
ARE
ONLY
USED
TO
BINARY
SEARCH
TREES
THAT
STORE
NUMBERS
THIS
MAY
BE
SURPRISING
BUT
BINARY
SEARCH
TREES
CAN
STORE
ANY
SET
OF
ELEMENTS
AS
LONG
AS
THERE
IS
AN
ORDER
ON
THE
ELEMENTS
IN
MORE
DETAIL
WE
STORE
THE
SEGMENTS
INTERSECTING
THE
SWEEP
LINE
ORDERED
IN
THE
LEAVES
OF
A
BALANCED
BINARY
SEARCH
TREE
T
THE
LEFT
TO
RIGHT
ORDER
OF
THE
SEGMENTS
ALONG
THE
SWEEP
LINE
CORRESPONDS
TO
THE
LEFT
TO
RIGHT
ORDER
OF
THE
LEAVES
IN
T
WE
MUST
ALSO
STORE
INFORMATION
IN
THE
INTERNAL
NODES
TO
GUIDE
THE
SEARCH
DOWN
THE
TREE
TO
THE
LEAVES
AT
EACH
INTERNAL
NODE
WE
STORE
THE
SEGMENT
FROM
THE
RIGHTMOST
LEAF
IN
ITS
LEFT
SUBTREE
ALTERNATIVELY
WE
COULD
STORE
THE
SEGMENTS
ONLY
IN
INTERIOR
NODES
THIS
WILL
SAVE
SOME
STORAGE
HOWEVER
IT
IS
CONCEPTUALLY
SIMPLER
TO
THINK
ABOUT
THE
SEGMENTS
IN
INTERIOR
NODES
AS
VALUES
TO
GUIDE
THE
SEARCH
NOT
AS
DATA
ITEMS
STORING
THE
SEGMENTS
IN
THE
LEAVES
ALSO
MAKES
SOME
ALGORITHMS
SIMPLER
TO
DESCRIBE
SUPPOSE
WE
SEARCH
IN
T
FOR
THE
SEGMENT
IMMEDIATELY
TO
THE
LEFT
OF
SOME
POINT
P
THAT
LIES
ON
THE
SWEEP
LINE
AT
EACH
INTERNAL
NODE

WE
TEST
WHETHER
P
LIES
LEFT
OR
RIGHT
OF
THE
SEGMENT
STORED
AT

DEPENDING
ON
THE
OUTCOME
WE
DESCEND
TO
THE
LEFT
OR
RIGHT
SUBTREE
OF

EVENTUALLY
ENDING
UP
IN
A
LEAF
EITHER
THIS
LEAF
OR
THE
LEAF
IMMEDIATELY
TO
THE
LEFT
OF
IT
STORES
THE
SEGMENT
WE
ARE
SEARCHING
FOR
IN
A
SIMILAR
WAY
WE
CAN
FIND
THE
SEGMENT
IMMEDIATELY
TO
THE
RIGHT
OF
P
OR
THE
SEGMENTS
CONTAINING
P
IT
FOLLOWS
THAT
EACH
UPDATE
AND
NEIGHBOR
SEARCH
OPERATION
TAKES
O
LOG
N
TIME
THE
EVENT
QUEUE
Q
AND
THE
STATUS
STRUCTURE
T
ARE
THE
ONLY
TWO
DATA
STRUCTURES
WE
NEED
THE
GLOBAL
ALGORITHM
CAN
NOW
BE
DESCRIBED
AS
FOLLOWS
ALGORITHM
FINDINTERSECTIONS
INPUT
A
SET
OF
LINE
SEGMENTS
IN
THE
PLANE
OUTPUT
THE
SET
OF
INTERSECTION
POINTS
AMONG
THE
SEGMENTS
IN
WITH
FOR
EACH
INTERSECTION
POINT
THE
SEGMENTS
THAT
CONTAIN
IT
INITIALIZE
AN
EMPTY
EVENT
QUEUE
Q
NEXT
INSERT
THE
SEGMENT
ENDPOINTS
INTO
Q
WHEN
AN
UPPER
ENDPOINT
IS
INSERTED
THE
CORRESPONDING
SEGMENT
SHOULD
BE
STORED
WITH
IT
INITIALIZE
AN
EMPTY
STATUS
STRUCTURE
T
WHILE
Q
IS
NOT
EMPTY
DO
DETERMINE
THE
NEXT
EVENT
POINT
P
IN
Q
AND
DELETE
IT
HANDLEEVENTPOINT
P
WE
HAVE
ALREADY
SEEN
HOW
EVENTS
ARE
HANDLED
AT
ENDPOINTS
OF
SEGMENTS
WE
HAVE
TO
INSERT
OR
DELETE
SEGMENTS
FROM
THE
STATUS
STRUCTURE
T
AND
AT
INTERSECTION
POINTS
WE
HAVE
TO
CHANGE
THE
ORDER
OF
TWO
SEGMENTS
IN
BOTH
CASES
WE
ALSO
SECTION
LINE
SEGMENT
INTERSECTION
HAVE
TO
DO
INTERSECTION
TESTS
BETWEEN
SEGMENTS
THAT
BECOME
NEIGHBORS
AFTER
THE
CHAPTER
LINE
SEGMENT
INTERSECTION
EVENT
IN
DEGENERATE
CASES
WHERE
SEVERAL
SEGMENTS
ARE
INVOLVED
IN
ONE
EVENT
POINT
THE
DETAILS
ARE
A
LITTLE
BIT
MORE
TRICKY
THE
NEXT
PROCEDURE
DESCRIBES
HOW
TO
HANDLE
EVENT
POINTS
CORRECTLY
IT
IS
ILLUSTRATED
IN
FIGURE
FIGURE
AN
EVENT
POINT
AND
THE
CHANGES
IN
THE
STATUS
STRUCTURE
HANDLEEVENTPOINT
P
LET
U
P
BE
THE
SET
OF
SEGMENTS
WHOSE
UPPER
ENDPOINT
IS
P
THESE
SEGMENTS
ARE
STORED
WITH
THE
EVENT
POINT
P
FOR
HORIZONTAL
SEGMENTS
THE
UPPER
ENDPOINT
IS
BY
DEFINITION
THE
LEFT
ENDPOINT
FIND
ALL
SEGMENTS
STORED
IN
T
THAT
CONTAIN
P
THEY
ARE
ADJACENT
IN
T
LET
L
P
DENOTE
THE
SUBSET
OF
SEGMENTS
FOUND
WHOSE
LOWER
ENDPOINT
IS
P
AND
LET
C
P
DENOTE
THE
SUBSET
OF
SEGMENTS
FOUND
THAT
CONTAIN
P
IN
THEIR
INTERIOR
IF
L
P
U
P
C
P
CONTAINS
MORE
THAN
ONE
SEGMENT
THEN
REPORT
P
AS
AN
INTERSECTION
TOGETHER
WITH
L
P
U
P
AND
C
P
DELETE
THE
SEGMENTS
IN
L
P
C
P
FROM
T
INSERT
THE
SEGMENTS
IN
U
P
C
P
INTO
T
THE
ORDER
OF
THE
SEGMENTS
IN
T
SHOULD
CORRESPOND
TO
THE
ORDER
IN
WHICH
THEY
ARE
INTERSECTED
BY
A
SWEEP
LINE
JUST
BELOW
P
IF
THERE
IS
A
HORIZONTAL
SEGMENT
IT
COMES
LAST
AMONG
ALL
SEGMENTS
CONTAINING
P
DELETING
AND
RE
INSERTING
THE
SEGMENTS
OF
C
P
REVERSES
THEIR
ORDER
IF
U
P
C
P
THEN
LET
SL
AND
SR
BE
THE
LEFT
AND
RIGHT
NEIGHBORS
OF
P
IN
T
FINDNEWEVENT
SL
SR
P
ELSE
LET
BE
THE
LEFTMOST
SEGMENT
OF
U
P
C
P
IN
T
LET
SL
BE
THE
LEFT
NEIGHBOR
OF
IN
T
FINDNEWEVENT
SL
P
LET
BE
THE
RIGHTMOST
SEGMENT
OF
U
P
C
P
IN
T
LET
SR
BE
THE
RIGHT
NEIGHBOR
OF
IN
T
FINDNEWEVENT
SR
P
NOTE
THAT
IN
LINES
WE
ASSUME
THAT
SL
AND
SR
ACTUALLY
EXIST
IF
THEY
DO
NOT
EXIST
THE
CORRESPONDING
STEPS
SHOULD
OBVIOUSLY
NOT
BE
PERFORMED
THE
PROCEDURES
FOR
FINDING
THE
NEW
INTERSECTIONS
ARE
EASY
THEY
SIMPLY
TEST
TWO
SEGMENTS
FOR
INTERSECTION
THE
ONLY
THING
WE
NEED
TO
BE
CAREFUL
ABOUT
IS
WHEN
WE
FIND
AN
INTERSECTION
WHETHER
THIS
INTERSECTION
HAS
ALREADY
BEEN
HANDLED
EARLIER
OR
NOT
WHEN
THERE
ARE
NO
HORIZONTAL
SEGMENTS
THEN
THE
INTERSECTION
HAS
NOT
BEEN
HANDLED
YET
WHEN
THE
INTERSECTION
POINT
LIES
BELOW
THE
SWEEP
LINE
BUT
HOW
SHOULD
WE
DEAL
WITH
HORIZONTAL
SEGMENTS
RECALL
OUR
CONVENTION
THAT
EVENTS
WITH
THE
SAME
Y
COORDINATE
ARE
TREATED
FROM
LEFT
TO
RIGHT
THIS
IMPLIES
THAT
WE
ARE
STILL
INTERESTED
IN
INTERSECTION
POINTS
LYING
TO
THE
RIGHT
OF
THE
CURRENT
EVENT
POINT
HENCE
THE
PROCEDURE
FINDNEWEVENT
IS
DEFINED
AS
FOLLOWS
FINDNEWEVENT
SL
SR
P
IF
SL
AND
SR
INTERSECT
BELOW
THE
SWEEP
LINE
OR
ON
IT
AND
TO
THE
RIGHT
OF
THE
CURRENT
EVENT
POINT
P
AND
THE
INTERSECTION
IS
NOT
YET
PRESENT
AS
AN
EVENT
IN
Q
THEN
INSERT
THE
INTERSECTION
POINT
AS
AN
EVENT
INTO
Q
SECTION
LINE
SEGMENT
INTERSECTION
WHAT
ABOUT
THE
CORRECTNESS
OF
OUR
ALGORITHM
IT
IS
CLEAR
THAT
FINDINTERSEC
TIONS
ONLY
REPORTS
TRUE
INTERSECTION
POINTS
BUT
DOES
IT
FIND
ALL
OF
THEM
THE
NEXT
LEMMA
STATES
THAT
THIS
IS
INDEED
THE
CASE
LEMMA
ALGORITHM
FINDINTERSECTIONS
COMPUTES
ALL
INTERSECTION
POINTS
AND
THE
SEGMENTS
THAT
CONTAIN
IT
CORRECTLY
PROOF
RECALL
THAT
THE
PRIORITY
OF
AN
EVENT
IS
GIVEN
BY
ITS
Y
COORDINATE
AND
THAT
WHEN
TWO
EVENTS
HAVE
THE
SAME
Y
COORDINATE
THE
ONE
WITH
SMALLER
X
COORDINATE
IS
GIVEN
HIGHER
PRIORITY
WE
SHALL
PROVE
THE
LEMMA
BY
INDUCTION
ON
THE
PRIORITY
OF
THE
EVENT
POINTS
LET
P
BE
AN
INTERSECTION
POINT
AND
ASSUME
THAT
ALL
INTERSECTION
POINTS
Q
WITH
A
HIGHER
PRIORITY
HAVE
BEEN
COMPUTED
CORRECTLY
WE
SHALL
PROVE
THAT
P
AND
THE
SEGMENTS
THAT
CONTAIN
P
ARE
COMPUTED
CORRECTLY
LET
U
P
BE
THE
SET
OF
SEGMENTS
THAT
HAVE
P
AS
THEIR
UPPER
ENDPOINT
OR
FOR
HORIZONTAL
SEGMENTS
THEIR
LEFT
ENDPOINT
LET
L
P
BE
THE
SET
OF
SEGMENTS
HAVING
P
AS
THEIR
LOWER
ENDPOINT
OR
FOR
HORIZONTAL
SEGMENTS
THEIR
RIGHT
ENDPOINT
AND
LET
C
P
BE
THE
SET
OF
SEGMENTS
HAVING
P
IN
THEIR
INTERIOR
FIRST
ASSUME
THAT
P
IS
AN
ENDPOINT
OF
ONE
OR
MORE
OF
THE
SEGMENTS
IN
THAT
CASE
P
IS
STORED
IN
THE
EVENT
QUEUE
Q
AT
THE
START
OF
THE
ALGORITHM
THE
SEGMENTS
FROM
U
P
ARE
STORED
WITH
P
SO
THEY
WILL
BE
FOUND
THE
SEGMENTS
FROM
L
P
AND
C
P
ARE
STORED
IN
T
WHEN
P
IS
HANDLED
SO
THEY
WILL
BE
FOUND
IN
LINE
OF
HANDLEEVENTPOINT
HENCE
P
AND
ALL
THE
SEGMENTS
INVOLVED
ARE
DETERMINED
CORRECTLY
WHEN
P
IS
AN
ENDPOINT
OF
ONE
OR
MORE
OF
THE
SEGMENTS
NOW
ASSUME
THAT
P
IS
NOT
AN
ENDPOINT
OF
A
SEGMENT
ALL
WE
NEED
TO
SHOW
IS
THAT
P
WILL
BE
INSERTED
INTO
Q
AT
SOME
MOMENT
NOTE
THAT
ALL
SEGMENTS
THAT
ARE
INVOLVED
HAVE
P
IN
THEIR
INTERIOR
ORDER
THESE
SEGMENTS
BY
ANGLE
AROUND
P
AND
LET
SI
AND
J
BE
TWO
NEIGHBORING
SEGMENTS
FOLLOWING
THE
PROOF
OF
LEMMA
WE
SEE
THAT
THERE
IS
AN
EVENT
POINT
WITH
A
HIGHER
PRIORITY
THAN
P
SUCH
THAT
SI
AND
J
BECOME
ADJACENT
WHEN
Q
IS
PASSED
IN
LEMMA
WE
ASSUMED
FOR
SIMPLICITY
THAT
SI
AND
J
ARE
NON
HORIZONTAL
BUT
IT
IS
STRAIGHTFORWARD
TO
ADAPT
THE
PROOF
FOR
CHAPTER
LINE
SEGMENT
INTERSECTION
HORIZONTAL
SEGMENTS
BY
INDUCTION
THE
EVENT
POINT
Q
WAS
HANDLED
CORRECTLY
WHICH
MEANS
THAT
P
IS
DETECTED
AND
STORED
INTO
Q
SO
WE
HAVE
A
CORRECT
ALGORITHM
BUT
DID
WE
SUCCEED
IN
DEVELOPING
AN
OUTPUT
SENSITIVE
ALGORITHM
THE
ANSWER
IS
YES
THE
RUNNING
TIME
OF
THE
ALGORITHM
IS
O
N
K
LOG
N
WHERE
K
IS
THE
SIZE
OF
THE
OUTPUT
THE
FOLLOWING
LEMMA
STATES
AN
EVEN
STRONGER
RESULT
THE
RUNNING
TIME
IS
O
N
I
LOG
N
WHERE
I
IS
THE
NUMBER
OF
INTERSECTIONS
THIS
IS
STRONGER
BECAUSE
FOR
ONE
INTERSECTION
POINT
THE
OUTPUT
CAN
CONSIST
OF
A
LARGE
NUMBER
OF
SEGMENTS
NAMELY
IN
THE
CASE
WHERE
MANY
SEGMENTS
INTERSECT
IN
A
COMMON
POINT
LEMMA
THE
RUNNING
TIME
OF
ALGORITHM
FINDINTERSECTIONS
FOR
A
SET
OF
N
LINE
SEGMENTS
IN
THE
PLANE
IS
O
N
LOG
N
I
LOG
N
WHERE
I
IS
THE
NUMBER
OF
INTERSECTION
POINTS
OF
SEGMENTS
IN
PROOF
THE
ALGORITHM
STARTS
BY
CONSTRUCTING
THE
EVENT
QUEUE
ON
THE
SEGMENT
ENDPOINTS
BECAUSE
WE
IMPLEMENTED
THE
EVENT
QUEUE
AS
A
BALANCED
BINARY
SEARCH
TREE
THIS
TAKES
O
N
LOG
N
TIME
INITIALIZING
THE
STATUS
STRUCTURE
TAKES
CONSTANT
TIME
THEN
THE
PLANE
SWEEP
STARTS
AND
ALL
THE
EVENTS
ARE
HANDLED
TO
HANDLE
AN
EVENT
WE
PERFORM
THREE
OPERATIONS
ON
THE
EVENT
QUEUE
Q
THE
EVENT
ITSELF
IS
DELETED
FROM
Q
IN
LINE
OF
FINDINTERSECTIONS
AND
THERE
CAN
BE
ONE
OR
TWO
CALLS
TO
FINDNEWEVENT
WHICH
MAY
CAUSE
AT
MOST
TWO
NEW
EVENTS
TO
BE
INSERTED
INTO
Q
DELETIONS
AND
INSERTIONS
ON
Q
TAKE
O
LOG
N
TIME
EACH
WE
ALSO
PERFORM
OPERATIONS
INSERTIONS
DELETIONS
AND
NEIGHBOR
FINDING
ON
THE
STATUS
STRUCTURE
T
WHICH
TAKE
O
LOG
N
TIME
EACH
THE
NUMBER
OF
OPERATIONS
IS
LINEAR
IN
THE
NUMBER
M
P
CARD
L
P
U
P
C
P
OF
SEGMENTS
THAT
ARE
INVOLVED
IN
THE
EVENT
IF
WE
DENOTE
THE
SUM
OF
ALL
M
P
OVER
ALL
EVENT
POINTS
P
BY
M
THE
RUNNING
TIME
OF
THE
ALGORITHM
IS
O
M
LOG
N
IT
IS
CLEAR
THAT
M
O
N
K
WHERE
K
IS
THE
SIZE
OF
THE
OUTPUT
AFTER
ALL
WHENEVER
M
P
WE
REPORT
ALL
SEGMENTS
INVOLVED
IN
THE
EVENT
AND
THE
ONLY
EVENTS
INVOLVING
ONE
SEGMENT
ARE
THE
ENDPOINTS
OF
SEGMENTS
BUT
WE
WANT
TO
PROVE
THAT
M
O
N
I
WHERE
I
IS
THE
NUMBER
OF
INTERSECTION
POINTS
TO
SHOW
THIS
WE
WILL
INTERPRET
THE
SET
OF
SEGMENTS
AS
A
PLANAR
GRAPH
EMBEDDED
IN
THE
PLANE
IF
YOU
ARE
NOT
FAMILIAR
WITH
PLANAR
GRAPH
TERMINOLOGY
YOU
SHOULD
READ
THE
FIRST
PARAGRAPHS
OF
SECTION
FIRST
ITS
VERTICES
ARE
THE
ENDPOINTS
OF
SEGMENTS
AND
INTERSECTION
POINTS
OF
SEGMENTS
AND
ITS
EDGES
ARE
THE
PIECES
OF
THE
SEGMENTS
CONNECTING
VERTICES
CONSIDER
AN
EVENT
POINT
P
IT
IS
A
VERTEX
OF
THE
GRAPH
AND
M
P
IS
BOUNDED
BY
THE
DEGREE
OF
THE
VERTEX
CONSEQUENTLY
M
IS
BOUNDED
BY
THE
SUM
OF
THE
DEGREES
OF
ALL
VERTICES
OF
OUR
GRAPH
EVERY
EDGE
OF
THE
GRAPH
CONTRIBUTES
ONE
TO
THE
DEGREE
OF
EXACTLY
TWO
VERTICES
ITS
ENDPOINTS
SO
M
IS
BOUNDED
BY
WHERE
NE
IS
THE
NUMBER
OF
EDGES
OF
THE
GRAPH
LET
BOUND
NE
IN
TERMS
OF
N
AND
I
BY
DEFINITION
NV
THE
NUMBER
OF
VERTICES
IS
AT
MOST
I
IT
IS
WELL
KNOWN
THAT
IN
PLANAR
GRAPHS
NE
O
NV
WHICH
PROVES
OUR
CLAIM
BUT
FOR
COMPLETENESS
LET
US
GIVE
THE
ARGUMENT
HERE
EVERY
FACE
OF
THE
PLANAR
GRAPH
IS
BOUNDED
BY
AT
LEAST
THREE
EDGES
PROVIDED
THAT
THERE
ARE
AT
LEAST
THREE
SEGMENTS
AND
AN
EDGE
CAN
BOUND
AT
MOST
TWO
DIFFERENT
FACES
THEREFORE
N
F
THE
NUMBER
OF
FACES
IS
AT
MOST
WE
NOW
USE
EULER
FORMULA
WHICH
STATES
THAT
FOR
ANY
PLANAR
GRAPH
WITH
NV
VERTICES
NE
EDGES
AND
N
F
FACES
THE
FOLLOWING
RELATION
HOLDS
NV
NE
N
F
SECTION
THE
DOUBLY
CONNECTED
EDGE
LIST
EQUALITY
HOLDS
IF
AND
ONLY
IF
THE
GRAPH
IS
CONNECTED
PLUGGING
THE
BOUNDS
ON
NV
AND
N
F
INTO
THIS
FORMULA
WE
GET
I
NE
I
NE
SO
NE
AND
M
AND
THE
BOUND
ON
THE
RUNNING
TIME
FOLLOWS
WE
STILL
HAVE
TO
ANALYZE
THE
OTHER
COMPLEXITY
ASPECT
THE
AMOUNT
OF
STORAGE
USED
BY
THE
ALGORITHM
THE
TREE
T
STORES
A
SEGMENT
AT
MOST
ONCE
SO
IT
USES
O
N
STORAGE
THE
SIZE
OF
Q
CAN
BE
LARGER
HOWEVER
THE
ALGORITHM
INSERTS
INTERSECTION
POINTS
IN
Q
WHEN
THEY
ARE
DETECTED
AND
IT
REMOVES
THEM
WHEN
THEY
ARE
HANDLED
WHEN
IT
TAKES
A
LONG
TIME
BEFORE
INTERSECTIONS
ARE
HANDLED
IT
COULD
HAPPEN
THAT
Q
GETS
VERY
LARGE
OF
COURSE
ITS
SIZE
IS
ALWAYS
BOUNDED
BY
O
N
I
BUT
IT
WOULD
BE
BETTER
IF
THE
WORKING
STORAGE
WERE
ALWAYS
LINEAR
THERE
IS
A
RELATIVELY
SIMPLE
WAY
TO
ACHIEVE
THIS
ONLY
STORE
INTERSECTION
POINTS
OF
PAIRS
OF
SEGMENTS
THAT
ARE
CURRENTLY
ADJACENT
ON
THE
SWEEP
LINE
THE
ALGORITHM
GIVEN
ABOVE
ALSO
STORES
INTERSECTION
POINTS
OF
SEGMENTS
THAT
HAVE
BEEN
HORIZONTALLY
ADJACENT
BUT
AREN
T
ANYMORE
BY
STORING
ONLY
INTERSECTIONS
AMONG
ADJACENT
SEGMENTS
THE
NUMBER
OF
EVENT
POINTS
IN
Q
IS
NEVER
MORE
THAN
LINEAR
THE
MODIFICATION
REQUIRED
IN
THE
ALGORITHM
IS
THAT
THE
INTERSECTION
POINT
OF
TWO
SEGMENTS
MUST
BE
DELETED
WHEN
THEY
STOP
BEING
ADJACENT
THESE
SEGMENTS
MUST
BECOME
ADJACENT
AGAIN
BEFORE
THE
INTERSECTION
POINT
IS
REACHED
SO
THE
INTERSECTION
POINT
WILL
STILL
BE
REPORTED
CORRECTLY
THE
TOTAL
TIME
TAKEN
BY
THE
ALGORITHM
REMAINS
O
N
LOG
N
I
LOG
N
WE
OBTAIN
THE
FOLLOWING
THEOREM
THEOREM
LET
BE
A
SET
OF
N
LINE
SEGMENTS
IN
THE
PLANE
ALL
INTERSECTION
POINTS
IN
WITH
FOR
EACH
INTERSECTION
POINT
THE
SEGMENTS
INVOLVED
IN
IT
CAN
BE
REPORTED
IN
O
N
LOG
N
I
LOG
N
TIME
AND
O
N
SPACE
WHERE
I
IS
THE
NUMBER
OF
INTERSECTION
POINTS
THE
DOUBLY
CONNECTED
EDGE
LIST
WE
HAVE
SOLVED
THE
EASIEST
CASE
OF
THE
MAP
OVERLAY
PROBLEM
WHERE
THE
TWO
MAPS
ARE
NETWORKS
REPRESENTED
AS
COLLECTIONS
OF
LINE
SEGMENTS
IN
GENERAL
MAPS
HAVE
A
MORE
COMPLICATED
STRUCTURE
THEY
ARE
SUBDIVISIONS
OF
THE
PLANE
INTO
LABELED
REGIONS
A
THEMATIC
MAP
OF
FORESTS
IN
CANADA
FOR
INSTANCE
WOULD
BE
A
SUBDIVISION
OF
CANADA
INTO
REGIONS
WITH
LABELS
SUCH
AS
PINE
DECIDUOUS
BIRCH
AND
MIXED
BEFORE
WE
CAN
GIVE
AN
ALGORITHM
FOR
COMPUTING
THE
OVERLAY
OF
TWO
SUBDIVI
SIONS
WE
MUST
DEVELOP
A
SUITABLE
REPRESENTATION
FOR
A
SUBDIVISION
STORING
A
SUBDIVISION
AS
A
COLLECTION
OF
LINE
SEGMENTS
IS
NOT
SUCH
A
GOOD
IDEA
OPERATIONS
LIKE
REPORTING
THE
BOUNDARY
OF
A
REGION
WOULD
BE
RATHER
COMPLICATED
IT
IS
BETTER
CHAPTER
LINE
SEGMENT
INTERSECTION
FIGURE
TYPES
OF
FOREST
IN
CANADA
EDGE
VERTEX
FACE
DISCONNECTED
SUBDIVISION
TO
INCORPORATE
STRUCTURAL
TOPOLOGICAL
INFORMATION
WHICH
SEGMENTS
BOUND
A
GIVEN
REGION
WHICH
REGIONS
ARE
ADJACENT
AND
SO
ON
THE
MAPS
WE
CONSIDER
ARE
PLANAR
SUBDIVISIONS
INDUCED
BY
PLANAR
EMBEDDINGS
OF
GRAPHS
SUCH
A
SUBDIVISION
IS
CONNECTED
IF
THE
UNDERLYING
GRAPH
IS
CONNECTED
THE
EMBEDDING
OF
A
NODE
OF
THE
GRAPH
IS
CALLED
A
VERTEX
AND
THE
EMBEDDING
OF
AN
ARC
IS
CALLED
AN
EDGE
WE
ONLY
CONSIDER
EMBEDDINGS
WHERE
EVERY
EDGE
IS
A
STRAIGHT
LINE
SEGMENT
IN
PRINCIPLE
EDGES
IN
A
SUBDIVISION
NEED
NOT
BE
STRAIGHT
A
SUBDIVISION
NEED
NOT
EVEN
BE
A
PLANAR
EMBEDDING
OF
A
GRAPH
AS
IT
MAY
HAVE
UNBOUNDED
EDGES
IN
THIS
SECTION
HOWEVER
WE
DON
T
CONSIDER
SUCH
MORE
GENERAL
SUBDIVISIONS
WE
CONSIDER
AN
EDGE
TO
BE
OPEN
THAT
IS
ITS
ENDPOINTS
WHICH
ARE
VERTICES
OF
THE
SUBDIVISION
ARE
NOT
PART
OF
IT
A
FACE
OF
THE
SUBDIVISION
IS
A
MAXIMAL
CONNECTED
SUBSET
OF
THE
PLANE
THAT
DOESN
T
CONTAIN
A
POINT
ON
AN
EDGE
OR
A
VERTEX
THUS
A
FACE
IS
AN
OPEN
POLYGONAL
REGION
WHOSE
BOUNDARY
IS
FORMED
BY
EDGES
AND
VERTICES
FROM
THE
SUBDIVISION
THE
COMPLEXITY
OF
A
SUBDIVISION
IS
DEFINED
AS
THE
SUM
OF
THE
NUMBER
OF
VERTICES
THE
NUMBER
OF
EDGES
AND
THE
NUMBER
OF
FACES
IT
CONSISTS
OF
IF
A
VERTEX
IS
THE
ENDPOINT
OF
AN
EDGE
THEN
WE
SAY
THAT
THE
VERTEX
AND
THE
EDGE
ARE
INCIDENT
SIMILARLY
A
FACE
AND
AN
EDGE
ON
ITS
BOUNDARY
ARE
INCIDENT
AND
A
FACE
AND
A
VERTEX
OF
ITS
BOUNDARY
ARE
INCIDENT
WHAT
SHOULD
WE
REQUIRE
FROM
A
REPRESENTATION
OF
A
SUBDIVISION
AN
OPERA
TION
ONE
COULD
ASK
FOR
IS
TO
DETERMINE
THE
FACE
CONTAINING
A
GIVEN
POINT
THIS
IS
DEFINITELY
USEFUL
IN
SOME
APPLICATIONS
INDEED
IN
A
LATER
CHAPTER
WE
SHALL
DESIGN
A
DATA
STRUCTURE
FOR
THIS
BUT
IT
IS
A
BIT
TOO
MUCH
TO
ASK
FROM
A
BASIC
REPRESENTATION
THE
THINGS
WE
CAN
ASK
FOR
SHOULD
BE
MORE
LOCAL
FOR
EXAMPLE
IT
IS
REASONABLE
TO
REQUIRE
THAT
WE
CAN
WALK
AROUND
THE
BOUNDARY
OF
A
GIVEN
FACE
OR
THAT
WE
CAN
ACCESS
ONE
FACE
FROM
AN
ADJACENT
ONE
IF
WE
ARE
GIVEN
A
COMMON
EDGE
ANOTHER
OPERATION
THAT
COULD
BE
USEFUL
IS
TO
VISIT
ALL
THE
EDGES
AROUND
A
GIVEN
VERTEX
THE
REPRESENTATION
THAT
WE
SHALL
DISCUSS
SUPPORTS
THESE
OPERATIONS
IT
IS
CALLED
THE
DOUBLY
CONNECTED
EDGE
LIST
A
DOUBLY
CONNECTED
EDGE
LIST
CONTAINS
A
RECORD
FOR
EACH
FACE
EDGE
AND
VERTEX
OF
THE
SUBDIVISION
BESIDES
THE
GEOMETRIC
AND
TOPOLOGICAL
INFORMATION
TO
BE
DESCRIBED
SHORTLY
EACH
RECORD
MAY
ALSO
STORE
ADDITIONAL
INFORMATION
FOR
INSTANCE
IF
THE
SUBDIVISION
REPRESENTS
A
THEMATIC
MAP
FOR
VEGETATION
THE
DOUBLY
CONNECTED
EDGE
LIST
WOULD
STORE
IN
EACH
FACE
RECORD
THE
TYPE
OF
VEGETATION
OF
THE
CORRESPONDING
REGION
THE
ADDITIONAL
INFORMATION
IS
ALSO
CALLED
ATTRIBUTE
INFORMATION
THE
GEOMETRIC
AND
TOPOLOGICAL
INFORMATION
STORED
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
SHOULD
ENABLE
US
TO
PERFORM
THE
BASIC
OPERATIONS
MENTIONED
EARLIER
TO
BE
ABLE
TO
WALK
AROUND
A
FACE
IN
COUNTERCLOCKWISE
ORDER
WE
STORE
A
POINTER
FROM
EACH
EDGE
TO
THE
NEXT
IT
CAN
ALSO
COME
IN
HANDY
TO
WALK
AROUND
A
FACE
THE
OTHER
WAY
SO
WE
ALSO
STORE
A
POINTER
TO
THE
PREVIOUS
EDGE
AN
EDGE
USUALLY
BOUNDS
TWO
FACES
SO
WE
NEED
TWO
PAIRS
OF
POINTERS
FOR
IT
IT
IS
CONVENIENT
TO
VIEW
THE
DIFFERENT
SIDES
OF
AN
EDGE
AS
TWO
DISTINCT
HALF
EDGES
SO
THAT
WE
HAVE
A
UNIQUE
NEXT
HALF
EDGE
AND
PREVIOUS
HALF
EDGE
FOR
EVERY
HALF
EDGE
THIS
ALSO
MEANS
THAT
A
HALF
EDGE
BOUNDS
ONLY
ONE
FACE
THE
TWO
HALF
EDGES
WE
GET
FOR
A
GIVEN
EDGE
ARE
CALLED
TWINS
DEFINING
THE
NEXT
HALF
EDGE
OF
A
GIVEN
HALF
EDGE
WITH
RESPECT
TO
A
COUNTERCLOCKWISE
TRAVERSAL
OF
A
FACE
INDUCES
AN
ORIENTATION
ON
EACH
HALF
EDGE
IT
IS
ORIENTED
SUCH
THAT
THE
FACE
THAT
IT
BOUNDS
LIES
TO
ITS
LEFT
FOR
AN
OBSERVER
WALKING
ALONG
THE
EDGE
BECAUSE
HALF
EDGES
ARE
ORIENTED
WE
CAN
SPEAK
OF
THE
ORIGIN
AND
THE
DESTINATION
OF
A
HALF
EDGE
IF
A
HALF
EDGE
E
HAS
V
AS
ITS
ORIGIN
AND
W
AS
ITS
DESTINATION
THEN
ITS
TWIN
TWIN
E
HAS
W
AS
ITS
ORIGIN
AND
V
AS
ITS
DESTINATION
TO
REACH
THE
BOUNDARY
OF
A
FACE
WE
JUST
NEED
TO
STORE
ONE
POINTER
IN
THE
FACE
RECORD
TO
AN
ARBITRARY
HALF
EDGE
BOUNDING
THE
FACE
STARTING
FROM
THAT
HALF
EDGE
WE
CAN
STEP
FROM
EACH
HALF
EDGE
TO
THE
NEXT
AND
WALK
AROUND
THE
FACE
WHAT
WE
JUST
SAID
DOES
NOT
QUITE
HOLD
FOR
THE
BOUNDARIES
OF
HOLES
IN
A
FACE
IF
THEY
ARE
TRAVERSED
IN
COUNTERCLOCKWISE
ORDER
THEN
THE
FACE
LIES
TO
THE
RIGHT
IT
WILL
BE
CONVENIENT
TO
ORIENT
HALF
EDGES
SUCH
THAT
THEIR
FACE
ALWAYS
LIES
TO
THE
SAME
SIDE
SO
WE
CHANGE
THE
DIRECTION
OF
TRAVERSAL
FOR
THE
BOUNDARY
OF
A
HOLE
TO
CLOCKWISE
NOW
A
FACE
ALWAYS
LIES
TO
THE
LEFT
OF
ANY
HALF
EDGE
ON
ITS
BOUNDARY
ANOTHER
CONSEQUENCE
IS
THAT
TWIN
HALF
EDGES
ALWAYS
HAVE
OPPOSITE
ORIENTATIONS
THE
PRESENCE
OF
HOLES
IN
A
FACE
ALSO
MEANS
THAT
ONE
POINTER
FROM
THE
FACE
TO
AN
ARBITRARY
HALF
EDGE
ON
ITS
BOUNDARY
IS
NOT
ENOUGH
TO
VISIT
THE
WHOLE
BOUNDARY
WE
NEED
A
POINTER
TO
A
HALF
EDGE
IN
EVERY
BOUNDARY
COMPONENT
IF
A
FACE
HAS
ISOLATED
VERTICES
THAT
DON
T
HAVE
ANY
INCIDENT
EDGE
WE
CAN
STORE
POINTERS
TO
THEM
AS
WELL
FOR
SIMPLICITY
WE
LL
IGNORE
THIS
CASE
LET
SUMMARIZE
THE
DOUBLY
CONNECTED
EDGE
LIST
CONSISTS
OF
THREE
COLLECTIONS
OF
RECORDS
ONE
FOR
THE
VERTICES
ONE
FOR
THE
FACES
AND
ONE
FOR
THE
HALF
EDGES
THESE
RECORDS
STORE
THE
FOLLOWING
GEOMETRIC
AND
TOPOLOGICAL
INFORMATION
THE
VERTEX
RECORD
OF
A
VERTEX
V
STORES
THE
COORDINATES
OF
V
IN
A
FIELD
CALLED
COORDINATES
V
IT
ALSO
STORES
A
POINTER
INCIDENTEDGE
V
TO
AN
ARBITRARY
HALF
EDGE
THAT
HAS
V
AS
ITS
ORIGIN
THE
FACE
RECORD
OF
A
FACE
F
STORES
A
POINTER
OUTERCOMPONENT
F
TO
SOME
HALF
EDGE
ON
ITS
OUTER
BOUNDARY
FOR
THE
UNBOUNDED
FACE
THIS
POINTER
IS
NIL
IT
ALSO
STORES
A
LIST
INNERCOMPONENTS
F
WHICH
CONTAINS
FOR
EACH
HOLE
IN
SECTION
THE
DOUBLY
CONNECTED
EDGE
LIST
V
TWIN
E
THE
FACE
A
POINTER
TO
SOME
HALF
EDGE
ON
THE
BOUNDARY
OF
THE
HOLE
CHAPTER
LINE
SEGMENT
INTERSECTION
ORIGIN
E
INCIDENTFACE
E
THE
HALF
EDGE
RECORD
OF
A
HALF
EDGE
E
STORES
A
POINTER
ORIGIN
E
TO
ITS
ORIGIN
A
POINTER
TWIN
E
TO
ITS
TWIN
HALF
EDGE
AND
A
POINTER
INCIDENTFACE
E
TO
THE
FACE
THAT
IT
BOUNDS
WE
DON
T
NEED
TO
STORE
THE
DESTINATION
OF
AN
EDGE
BECAUSE
IT
IS
EQUAL
TO
ORIGIN
TWIN
E
THE
ORIGIN
IS
CHOSEN
SUCH
THAT
INCIDENTFACE
E
LIES
TO
THE
LEFT
OF
E
WHEN
IT
IS
TRAVERSED
FROM
ORIGIN
TO
DESTINATION
THE
HALF
EDGE
RECORD
ALSO
STORES
POINTERS
NEXT
E
AND
PREV
E
TO
THE
NEXT
AND
PREVIOUS
EDGE
ON
THE
BOUNDARY
OF
INCIDENTFACE
E
THUS
NEXT
E
IS
THE
UNIQUE
HALF
EDGE
ON
THE
BOUNDARY
OF
INCIDENTFACE
E
THAT
HAS
THE
DESTINATION
OF
E
AS
ITS
ORIGIN
AND
PREV
E
IS
THE
UNIQUE
HALF
EDGE
ON
THE
BOUNDARY
OF
INCIDENTFACE
E
THAT
HAS
ORIGIN
E
AS
ITS
DESTINATION
A
CONSTANT
AMOUNT
OF
INFORMATION
IS
USED
FOR
EACH
VERTEX
AND
EDGE
A
FACE
MAY
REQUIRE
MORE
STORAGE
SINCE
THE
LIST
INNERCOMPONENTS
F
HAS
AS
MANY
ELEMENTS
AS
THERE
ARE
HOLES
IN
THE
FACE
BECAUSE
ANY
HALF
EDGE
IS
POINTED
TO
AT
MOST
ONCE
FROM
ALL
INNERCOMPONENTS
F
LISTS
TOGETHER
WE
CONCLUDE
THAT
THE
AMOUNT
OF
STORAGE
IS
LINEAR
IN
THE
COMPLEXITY
OF
THE
SUBDIVISION
AN
EXAMPLE
OF
A
DOUBLY
CONNECTED
EDGE
LIST
FOR
A
SIMPLE
SUBDIVISION
IS
GIVEN
BELOW
THE
TWO
HALF
EDGES
CORRESPONDING
TO
AN
EDGE
EI
ARE
LABELED
EI
AND
EI
VERTEX
COORDINATES
INCIDENTEDGE
FACE
OUTERCOMPONENT
INNERCOMPONENTS
NIL
NIL
HALF
EDGE
ORIGIN
TWIN
INCIDENTFACE
NEXT
PREV
THE
INFORMATION
STORED
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
IS
ENOUGH
TO
PERFORM
THE
BASIC
OPERATIONS
FOR
EXAMPLE
WE
CAN
WALK
AROUND
THE
OUTER
BOUNDARY
OF
A
GIVEN
FACE
F
BY
FOLLOWING
NEXT
E
POINTERS
STARTING
FROM
THE
HALF
EDGE
OUTERCOMPONENT
F
WE
CAN
ALSO
VISIT
ALL
EDGES
INCIDENT
TO
A
VERTEX
V
IT
IS
A
GOOD
EXERCISE
TO
FIGURE
OUT
FOR
YOURSELF
HOW
TO
DO
THIS
WE
DESCRIBED
A
FAIRLY
GENERAL
VERSION
OF
THE
DOUBLY
CONNECTED
EDGE
LIST
IN
APPLICATIONS
WHERE
THE
VERTICES
CARRY
NO
ATTRIBUTE
INFORMATION
WE
COULD
STORE
THEIR
COORDINATES
DIRECTLY
IN
THE
ORIGIN
FIELD
OF
THE
EDGE
THERE
IS
NO
STRICT
NEED
FOR
A
SEPARATE
TYPE
OF
VERTEX
RECORD
EVEN
MORE
IMPORTANT
IS
TO
REALIZE
THAT
IN
MANY
APPLICATIONS
THE
FACES
OF
THE
SUBDIVISION
CARRY
NO
INTERESTING
MEANING
THINK
OF
THE
NETWORK
OF
RIVERS
OR
ROADS
THAT
WE
LOOKED
AT
BEFORE
IF
THAT
IS
THE
CASE
WE
CAN
COMPLETELY
FORGET
ABOUT
THE
FACE
RECORDS
AND
THE
INCIDENTFACE
FIELD
OF
HALF
EDGES
AS
WE
WILL
SEE
THE
ALGORITHM
OF
THE
NEXT
SECTION
DOESN
T
NEED
THESE
FIELDS
AND
IS
ACTUALLY
SIMPLER
TO
IMPLEMENT
IF
WE
DON
T
NEED
TO
UPDATE
THEM
SOME
IMPLEMENTATIONS
OF
DOUBLY
CONNECTED
EDGE
LISTS
MAY
ALSO
INSIST
THAT
THE
GRAPH
FORMED
BY
THE
VERTICES
AND
EDGES
OF
THE
SUBDIVISION
BE
CONNECTED
THIS
CAN
ALWAYS
BE
ACHIEVED
BY
INTRODUCING
DUMMY
EDGES
AND
HAS
TWO
ADVANTAGES
FIRSTLY
A
SIMPLE
GRAPH
TRANSVERSAL
CAN
BE
USED
TO
VISIT
ALL
HALF
EDGES
AND
SECONDLY
THE
INNERCOMPONENTS
LIST
FOR
FACES
IS
NOT
NECESSARY
COMPUTING
THE
OVERLAY
OF
TWO
SUBDIVISIONS
NOW
THAT
WE
HAVE
DESIGNED
A
GOOD
REPRESENTATION
OF
A
SUBDIVISION
WE
CAN
TACKLE
THE
GENERAL
MAP
OVERLAY
PROBLEM
WE
DEFINE
THE
OVERLAY
OF
TWO
SUBDIVISIONS
AND
TO
BE
THE
SUBDIVISION
O
SUCH
THAT
THERE
IS
A
FACE
F
IN
O
IF
AND
ONLY
IF
THERE
ARE
FACES
IN
AND
IN
SUCH
THAT
F
IS
A
MAXIMAL
CONNECTED
SUBSET
OF
THIS
SOUNDS
MORE
COMPLICATED
THAN
IT
IS
WHAT
IT
MEANS
IS
THAT
THE
OVERLAY
IS
THE
SUBDIVISION
OF
THE
PLANE
INDUCED
BY
THE
EDGES
FROM
AND
FIGURE
ILLUSTRATES
THIS
THE
GENERAL
MAP
OVERLAY
PROBLEM
IS
TO
COMPUTE
A
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
GIVEN
THE
DOUBLY
CONNECTED
EDGE
LISTS
OF
AND
WE
REQUIRE
THAT
EACH
FACE
IN
O
BE
LABELED
WITH
THE
LABELS
OF
THE
FACES
IN
AND
THAT
CONTAIN
IT
THIS
WAY
WE
HAVE
ACCESS
TO
THE
ATTRIBUTE
INFORMATION
STORED
FOR
THESE
FACES
IN
AN
OVERLAY
OF
A
VEGETATION
MAP
AND
A
PRECIPITATION
MAP
THIS
WOULD
MEAN
THAT
WE
KNOW
FOR
EACH
REGION
IN
THE
OVERLAY
THE
TYPE
OF
VEGETATION
AND
THE
AMOUNT
OF
PRECIPITATION
SECTION
COMPUTING
THE
OVERLAY
OF
TWO
SUBDIVISIONS
FIGURE
OVERLAYING
TWO
SUBDIVISIONS
LET
FIRST
SEE
HOW
MUCH
INFORMATION
FROM
THE
DOUBLY
CONNECTED
EDGE
LISTS
FOR
AND
WE
CAN
RE
USE
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
CONSIDER
THE
NETWORK
OF
EDGES
AND
VERTICES
OF
THIS
NETWORK
IS
CUT
INTO
PIECES
BY
THE
EDGES
OF
THESE
PIECES
ARE
FOR
A
LARGE
PART
RE
USABLE
ONLY
THE
EDGES
THAT
HAVE
BEEN
CUT
BY
THE
EDGES
OF
SHOULD
BE
RENEWED
BUT
DOES
THIS
ALSO
CHAPTER
LINE
SEGMENT
INTERSECTION
HOLD
FOR
THE
HALF
EDGE
RECORDS
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
THAT
CORRESPOND
TO
THE
PIECES
IF
THE
ORIENTATION
OF
A
HALF
EDGE
WOULD
CHANGE
WE
WOULD
STILL
HAVE
TO
CHANGE
THE
INFORMATION
IN
THESE
RECORDS
FORTUNATELY
THIS
IS
NOT
THE
CASE
THE
HALF
EDGES
ARE
ORIENTED
SUCH
THAT
THE
FACE
THAT
THEY
BOUND
LIES
TO
THE
LEFT
THE
SHAPE
OF
THE
FACE
MAY
CHANGE
IN
THE
OVERLAY
BUT
IT
WILL
REMAIN
TO
THE
SAME
SIDE
OF
THE
HALF
EDGE
HENCE
WE
CAN
RE
USE
HALF
EDGE
RECORDS
CORRESPONDING
TO
EDGES
THAT
ARE
NOT
INTERSECTED
BY
EDGES
FROM
THE
OTHER
MAP
STATED
DIFFERENTLY
THE
ONLY
HALF
EDGE
RECORDS
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
THAT
WE
CANNOT
BORROW
FROM
OR
ARE
THE
ONES
THAT
ARE
INCIDENT
TO
AN
INTERSECTION
BETWEEN
EDGES
FROM
DIFFERENT
MAPS
THIS
SUGGESTS
THE
FOLLOWING
APPROACH
FIRST
COPY
THE
DOUBLY
CONNECTED
EDGE
LISTS
OF
AND
INTO
ONE
NEW
DOUBLY
CONNECTED
EDGE
LIST
THE
NEW
DOUBLY
CONNECTED
EDGE
LIST
IS
NOT
A
VALID
DOUBLY
CONNECTED
EDGE
LIST
OF
COURSE
IN
THE
SENSE
THAT
IT
DOES
NOT
YET
REPRESENT
A
PLANAR
SUBDIVISION
THIS
IS
THE
TASK
OF
THE
OVERLAY
ALGORITHM
IT
MUST
TRANSFORM
THE
DOUBLY
CONNECTED
EDGE
LIST
INTO
A
VALID
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
BY
COMPUTING
THE
INTERSECTIONS
BETWEEN
THE
TWO
NETWORKS
OF
EDGES
AND
LINKING
TOGETHER
THE
APPROPRIATE
PARTS
OF
THE
TWO
DOUBLY
CONNECTED
EDGE
LISTS
WE
DID
NOT
TALK
ABOUT
THE
NEW
FACE
RECORDS
YET
THE
INFORMATION
FOR
THESE
RECORDS
IS
MORE
DIFFICULT
TO
COMPUTE
SO
WE
LEAVE
THIS
FOR
LATER
WE
FIRST
DESCRIBE
IN
A
LITTLE
MORE
DETAIL
HOW
THE
VERTEX
AND
HALF
EDGE
RECORDS
OF
THE
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
ARE
COMPUTED
OUR
ALGORITHM
IS
BASED
ON
THE
PLANE
SWEEP
ALGORITHM
OF
SECTION
FOR
COM
PUTING
THE
INTERSECTIONS
IN
A
SET
OF
LINE
SEGMENTS
WE
RUN
THIS
ALGORITHM
ON
THE
SET
OF
SEGMENTS
THAT
IS
THE
UNION
OF
THE
SETS
OF
EDGES
OF
THE
TWO
SUBDIVISIONS
AND
HERE
WE
CONSIDER
THE
EDGES
TO
BE
CLOSED
RECALL
THAT
THE
ALGORITHM
IS
SUPPORTED
BY
TWO
DATA
STRUCTURES
AN
EVENT
QUEUE
Q
WHICH
STORES
THE
EVENT
POINTS
AND
THE
STATUS
STRUCTURE
T
WHICH
IS
A
BALANCED
BINARY
SEARCH
TREE
STORING
THE
SEGMENTS
INTERSECTING
THE
SWEEP
LINE
ORDERED
FROM
LEFT
TO
RIGHT
WE
NOW
ALSO
MAINTAIN
A
DOUBLY
CONNECTED
EDGE
LIST
D
INITIALLY
D
CONTAINS
A
COPY
OF
THE
DOUBLY
CONNECTED
EDGE
LIST
FOR
AND
A
COPY
OF
THE
DOUBLY
CONNECTED
EDGE
LIST
FOR
DURING
THE
PLANE
SWEEP
WE
SHALL
TRANSFORM
D
TO
A
CORRECT
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
THAT
IS
TO
SAY
AS
FAR
AS
THE
VERTEX
AND
HALF
EDGE
RECORDS
ARE
CONCERNED
THE
FACE
INFORMATION
WILL
BE
COMPUTED
LATER
WE
KEEP
CROSS
POINTERS
BETWEEN
THE
EDGES
IN
THE
STATUS
STRUCTURE
T
AND
THE
HALF
EDGE
RECORDS
IN
D
THAT
CORRESPOND
TO
THEM
THIS
WAY
WE
CAN
ACCESS
THE
PART
OF
D
THAT
NEEDS
TO
BE
CHANGED
WHEN
WE
ENCOUNTER
AN
INTERSECTION
POINT
THE
INVARIANT
THAT
WE
MAINTAIN
IS
THAT
AT
ANY
TIME
DURING
THE
SWEEP
THE
PART
OF
THE
OVERLAY
ABOVE
THE
SWEEP
LINE
HAS
BEEN
COMPUTED
CORRECTLY
NOW
LET
CONSIDER
WHAT
WE
MUST
DO
WHEN
WE
REACH
AN
EVENT
POINT
FIRST
OF
ALL
WE
UPDATE
T
AND
Q
AS
IN
THE
LINE
SEGMENT
INTERSECTION
ALGORITHM
IF
THE
EVENT
INVOLVES
ONLY
EDGES
FROM
ONE
OF
THE
TWO
SUBDIVISIONS
THIS
IS
ALL
THE
EVENT
POINT
IS
A
VERTEX
THAT
CAN
BE
RE
USED
IF
THE
EVENT
INVOLVES
EDGES
FROM
BOTH
SUBDIVISIONS
WE
MUST
MAKE
LOCAL
CHANGES
TO
D
TO
LINK
THE
DOUBLY
CONNECTED
EDGE
LISTS
OF
THE
TWO
ORIGINAL
SUBDIVISIONS
AT
THE
INTERSECTION
POINT
THIS
IS
TEDIOUS
BUT
NOT
DIFFICULT
THE
GEOMETRIC
SITUATION
AND
THE
TWO
DOUBLY
CONNECTED
EDGE
LISTS
BEFORE
HANDLING
THE
INTERSECTION
THE
DOUBLY
CONNECTED
EDGE
LIST
AFTER
HANDLING
THE
INTERSECTION
SECTION
COMPUTING
THE
OVERLAY
OF
TWO
SUBDIVISIONS
WE
DESCRIBE
THE
DETAILS
FOR
ONE
OF
THE
POSSIBLE
CASES
NAMELY
WHEN
AN
EDGE
E
OF
PASSES
THROUGH
A
VERTEX
V
OF
SEE
FIGURE
THE
EDGE
E
MUST
BE
REPLACED
BY
TWO
EDGES
DENOTED
E
AND
E
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
THE
TWO
HALF
EDGES
FOR
E
MUST
BECOME
FOUR
WE
CREATE
TWO
NEW
HALF
EDGE
RECORDS
BOTH
WITH
V
AS
THE
ORIGIN
THE
TWO
EXISTING
HALF
EDGES
FOR
E
KEEP
THE
ENDPOINTS
OF
E
AS
THEIR
ORIGIN
AS
SHOWN
IN
FIGURE
THEN
WE
PAIR
UP
THE
EXISTING
HALF
EDGES
WITH
THE
NEW
HALF
EDGES
BY
SETTING
THEIR
TWIN
POINTERS
SO
E
IS
REPRESENTED
BY
ONE
NEW
AND
ONE
EXISTING
HALF
EDGE
AND
THE
SAME
HOLDS
FOR
E
NOW
WE
MUST
SET
A
NUMBER
OF
PREV
AND
NEXT
POINTERS
WE
FIRST
DEAL
WITH
THE
SITUATION
AROUND
THE
ENDPOINTS
OF
E
LATER
WE
LL
WORRY
ABOUT
THE
SITUATION
AROUND
V
THE
NEXT
POINTERS
OF
THE
TWO
NEW
HALF
EDGES
EACH
COPY
THE
NEXT
POINTER
OF
THE
OLD
HALF
EDGE
THAT
IS
NOT
ITS
TWIN
THE
HALF
EDGES
TO
WHICH
THESE
POINTERS
POINT
MUST
ALSO
UPDATE
THEIR
PREV
POINTER
AND
SET
IT
TO
THE
NEW
HALF
EDGES
THE
CORRECTNESS
OF
THIS
STEP
CAN
BE
VERIFIED
BEST
BY
LOOKING
AT
A
FIGURE
IT
REMAINS
TO
CORRECT
THE
SITUATION
AROUND
VERTEX
V
WE
MUST
SET
THE
NEXT
AND
PREV
POINTERS
OF
THE
FOUR
HALF
EDGES
REPRESENTING
E
AND
E
AND
OF
THE
FOUR
HALF
EDGES
INCIDENT
FROM
TO
V
WE
LOCATE
THESE
FOUR
HALF
EDGES
FROM
BY
TESTING
WHERE
E
AND
E
SHOULD
BE
IN
THE
CYCLIC
ORDER
OF
THE
EDGES
AROUND
VERTEX
V
THERE
ARE
FOUR
PAIRS
OF
HALF
EDGES
THAT
BECOME
LINKED
BY
A
NEXT
POINTER
FROM
THE
ONE
AND
A
PREV
POINTER
FROM
THE
OTHER
CONSIDER
THE
HALF
EDGE
FOR
E
THAT
HAS
V
AS
ITS
DESTINATION
IT
MUST
BE
LINKED
TO
THE
FIRST
HALF
EDGE
SEEN
CLOCKWISE
FROM
E
WITH
V
AS
ITS
ORIGIN
THE
HALF
EDGE
FOR
E
WITH
V
AS
ITS
ORIGIN
MUST
BE
LINKED
TO
THE
FIRST
COUNTERCLOCKWISE
HALF
EDGE
WITH
V
AS
ITS
DESTINATION
THE
SAME
STATEMENTS
HOLD
FOR
E
MOST
OF
THE
STEPS
IN
THE
DESCRIPTION
ABOVE
TAKE
ONLY
CONSTANT
TIME
ONLY
LOCATING
WHERE
E
AND
E
APPEAR
IN
THE
CYCLIC
ORDER
AROUND
V
MAY
TAKE
LONGER
IT
WILL
TAKE
TIME
LINEAR
IN
THE
DEGREE
OF
V
THE
OTHER
CASES
THAT
CAN
ARISE
CROSSINGS
OF
TWO
EDGES
FROM
DIFFERENT
MAPS
AND
COINCIDING
VERTICES
ARE
NOT
MORE
DIFFICULT
THAN
THE
CASE
WE
JUST
DISCUSSED
THESE
CASES
ALSO
TAKE
TIME
O
M
WHERE
M
IS
THE
NUMBER
OF
EDGES
INCIDENT
TO
THE
EVENT
POINT
THIS
MEANS
THAT
UPDATING
D
DOES
NOT
INCREASE
THE
RUNNING
TIME
OF
THE
LINE
SEGMENT
INTERSECTION
ALGORITHM
ASYMPTOTICALLY
NOTICE
THAT
EVERY
INTERSECTION
THAT
WE
FIND
IS
A
VERTEX
OF
THE
OVERLAY
IT
FOLLOWS
THAT
THE
VERTEX
RECORDS
AND
THE
HALF
EDGE
RECORDS
OF
THE
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
CAN
BE
COMPUTED
IN
O
N
LOG
N
K
LOG
N
TIME
WHERE
N
DENOTES
THE
SUM
OF
THE
COMPLEXITIES
OF
AND
AND
K
IS
THE
FIGURE
AN
EDGE
OF
ONE
SUBDIVISION
PASSING
THROUGH
A
VERTEX
OF
THE
OTHER
FIRST
CLOCKWISE
HALF
EDGE
FROM
E
WITH
V
AS
ITS
ORIGIN
COMPLEXITY
OF
THE
OVERLAY
CHAPTER
LINE
SEGMENT
INTERSECTION
AFTER
THE
FIELDS
INVOLVING
VERTEX
AND
HALF
EDGE
RECORDS
HAVE
BEEN
SET
IT
REMAINS
TO
COMPUTE
THE
INFORMATION
ABOUT
THE
FACES
OF
O
MORE
PRECISELY
WE
HAVE
TO
CREATE
A
FACE
RECORD
FOR
EACH
FACE
F
IN
O
WE
HAVE
TO
MAKE
OUTERCOMPONENT
F
POINT
TO
A
HALF
EDGE
ON
THE
OUTER
BOUNDARY
OF
F
AND
WE
HAVE
TO
MAKE
A
LIST
INNERCOMPONENTS
F
OF
POINTERS
TO
HALF
EDGES
ON
THE
BOUND
ARIES
OF
THE
HOLES
INSIDE
F
FURTHERMORE
WE
MUST
SET
THE
INCIDENTFACE
FIELDS
OF
THE
HALF
EDGES
ON
THE
BOUNDARY
OF
F
SO
THAT
THEY
POINT
TO
THE
FACE
RECORD
OF
F
FINALLY
EACH
OF
THE
NEW
FACES
MUST
BE
LABELED
WITH
THE
NAMES
OF
THE
FACES
IN
THE
OLD
SUBDIVISIONS
THAT
CONTAIN
IT
HOW
MANY
FACE
RECORDS
WILL
THERE
BE
WELL
EXCEPT
FOR
THE
UNBOUNDED
FACE
EVERY
FACE
HAS
A
UNIQUE
OUTER
BOUNDARY
SO
THE
NUMBER
OF
FACE
RECORDS
WE
HAVE
TO
CREATE
IS
EQUAL
TO
THE
NUMBER
OF
OUTER
BOUNDARIES
PLUS
ONE
FROM
THE
PART
OF
THE
DOUBLY
CONNECTED
EDGE
LIST
WE
HAVE
CONSTRUCTED
SO
FAR
WE
CAN
EASILY
EXTRACT
ALL
BOUNDARY
CYCLES
BUT
HOW
DO
WE
KNOW
WHETHER
A
CYCLE
IS
AN
OUTER
BOUNDARY
OR
THE
BOUNDARY
OF
A
HOLE
IN
A
FACE
THIS
CAN
BE
DECIDED
BY
LOOKING
AT
THE
LEFTMOST
VERTEX
V
OF
THE
CYCLE
OR
IN
CASE
OF
TIES
AT
THE
LOWEST
OF
THE
LEFTMOST
ONES
RECALL
THAT
HALF
EDGES
ARE
DIRECTED
IN
SUCH
A
WAY
THAT
THEIR
INCIDENT
FACE
LOCALLY
LIES
TO
THE
LEFT
CONSIDER
THE
TWO
HALF
EDGES
OF
THE
CYCLE
THAT
ARE
INCIDENT
TO
V
BECAUSE
WE
KNOW
THAT
THE
INCIDENT
FACE
LIES
TO
THE
LEFT
WE
CAN
COMPUTE
THE
ANGLE
THESE
TWO
HALF
EDGES
MAKE
INSIDE
THE
INCIDENT
FACE
IF
THIS
ANGLE
IS
SMALLER
THAN
THEN
THE
CYCLE
IS
AN
OUTER
BOUNDARY
AND
OTHERWISE
IT
IS
THE
BOUNDARY
OF
A
HOLE
THIS
PROPERTY
HOLDS
FOR
THE
LEFTMOST
VERTEX
OF
A
CYCLE
BUT
NOT
NECESSARILY
FOR
OTHER
VERTICES
OF
THAT
CYCLE
TO
DECIDE
WHICH
BOUNDARY
CYCLES
BOUND
THE
SAME
FACE
WE
CONSTRUCT
A
GRAPH
G
FOR
EVERY
BOUNDARY
CYCLE
INNER
AND
OUTER
THERE
IS
A
NODE
IN
G
THERE
IS
ALSO
ONE
NODE
FOR
THE
IMAGINARY
OUTER
BOUNDARY
OF
THE
UNBOUNDED
FACE
THERE
IS
AN
ARC
BETWEEN
TWO
CYCLES
IF
AND
ONLY
IF
ONE
OF
THE
CYCLES
IS
THE
BOUNDARY
OF
A
HOLE
AND
THE
OTHER
CYCLE
HAS
A
HALF
EDGE
IMMEDIATELY
TO
THE
LEFT
OF
THE
LEFTMOST
VERTEX
OF
THAT
HOLE
CYCLE
IF
THERE
IS
NO
HALF
EDGE
TO
THE
LEFT
OF
THE
LEFTMOST
VERTEX
OF
A
CYCLE
THEN
THE
NODE
REPRESENTING
THE
CYCLE
IS
LINKED
TO
THE
NODE
OF
THE
UNBOUNDED
FACE
FIGURE
GIVES
AN
EXAMPLE
THE
DOTTED
SEGMENTS
IN
THE
FIGURE
INDICATE
THE
LINKING
OF
THE
HOLE
CYCLES
TO
OTHER
CYCLES
THE
GRAPH
CORRESPONDING
TO
THE
SUBDIVISION
IS
ALSO
SHOWN
IN
THE
FIGURE
THE
HOLE
CYCLES
ARE
SHOWN
AS
SINGLE
CIRCLES
AND
THE
OUTER
BOUNDARY
CYCLES
ARE
SHOWN
AS
DOUBLE
CIRCLES
OBSERVE
THAT
AND
ARE
IN
THE
SAME
CONNECTED
COMPONENT
AS
THIS
INDICATES
THAT
AND
ARE
HOLE
CYCLES
IN
THE
FACE
WHOSE
OUTER
BOUNDARY
IS
IF
THERE
IS
ONLY
ONE
HOLE
IN
A
FACE
F
THEN
THE
GRAPH
G
LINKS
THE
BOUNDARY
CYCLE
OF
THE
HOLE
TO
THE
OUTER
BOUNDARY
OF
F
IN
GENERAL
THIS
NEED
NOT
BE
THE
CASE
A
HOLE
CAN
ALSO
BE
LINKED
TO
ANOTHER
HOLE
AS
YOU
CAN
SEE
IN
FIGURE
THIS
HOLE
WHICH
LIES
IN
THE
SAME
FACE
F
MAY
BE
LINKED
TO
THE
OUTER
BOUNDARY
OF
F
OR
IT
MAY
BE
LINKED
TO
YET
ANOTHER
HOLE
BUT
EVENTUALLY
WE
MUST
END
UP
LINKING
A
HOLE
TO
THE
OUTER
BOUNDARY
AS
THE
NEXT
LEMMA
SHOWS
LEMMA
EACH
CONNECTED
COMPONENT
OF
THE
GRAPH
G
CORRESPONDS
EXACTLY
TO
THE
SET
OF
CYCLES
INCIDENT
TO
ONE
FACE
PROOF
CONSIDER
A
CYCLE
C
BOUNDING
A
HOLE
IN
A
FACE
F
BECAUSE
F
LIES
LOCALLY
TO
THE
LEFT
OF
THE
LEFTMOST
VERTEX
OF
C
C
MUST
BE
LINKED
TO
ANOTHER
CYCLE
THAT
ALSO
SECTION
COMPUTING
THE
OVERLAY
OF
TWO
SUBDIVISIONS
G
FIGURE
A
SUBDIVISION
AND
THE
CORRESPONDING
GRAPH
G
BOUNDS
F
IT
FOLLOWS
THAT
CYCLES
IN
THE
SAME
CONNECTED
COMPONENT
OF
G
BOUND
THE
SAME
FACE
TO
FINISH
THE
PROOF
WE
SHOW
THAT
EVERY
CYCLE
BOUNDING
A
HOLE
IN
F
IS
IN
THE
SAME
CONNECTED
COMPONENT
AS
THE
OUTER
BOUNDARY
OF
F
SUPPOSE
THERE
IS
A
CYCLE
FOR
WHICH
THIS
IS
NOT
THE
CASE
LET
C
BE
THE
LEFTMOST
SUCH
CYCLE
THAT
IS
THE
ONE
WHOSE
THE
LEFTMOST
VERTEX
IS
LEFTMOST
BY
DEFINITION
THERE
IS
AN
ARC
BETWEEN
THE
C
AND
ANOTHER
CYCLE
C
THAT
LIES
PARTLY
TO
THE
LEFT
OF
THE
LEFTMOST
VERTEX
OF
C
HENCE
C
IS
IN
THE
SAME
CONNECTED
COMPONENT
AS
C
WHICH
IS
NOT
THE
COMPONENT
OF
THE
OUTER
BOUNDARY
OF
F
THIS
CONTRADICTS
THE
DEFINITION
OF
C
LEMMA
SHOWS
THAT
ONCE
WE
HAVE
THE
GRAPH
G
WE
CAN
CREATE
A
FACE
RECORD
FOR
EVERY
COMPONENT
THEN
WE
CAN
SET
THE
INCIDENTFACE
POINTERS
OF
THE
HALF
EDGES
THAT
BOUND
EACH
FACE
F
AND
WE
CAN
CONSTRUCT
THE
LIST
INNERCOMPONENTS
F
AND
THE
SET
OUTERCOMPONENT
F
HOW
CAN
WE
CONSTRUCT
G
RECALL
THAT
IN
THE
PLANE
SWEEP
ALGORITHM
FOR
LINE
SEGMENT
INTERSECTION
WE
ALWAYS
LOOKED
FOR
THE
SEGMENTS
IMMEDIATELY
TO
THE
LEFT
OF
AN
EVENT
POINT
THEY
HAD
TO
BE
TESTED
FOR
INTERSECTION
AGAINST
THE
LEFTMOST
EDGE
THROUGH
THE
EVENT
POINT
HENCE
THE
INFORMATION
WE
NEED
TO
CONSTRUCT
G
IS
DETERMINED
DURING
THE
PLANE
SWEEP
SO
TO
CONSTRUCT
G
WE
FIRST
MAKE
A
NODE
FOR
EVERY
CYCLE
TO
FIND
THE
ARCS
OF
G
WE
CONSIDER
THE
LEFTMOST
VERTEX
V
OF
EVERY
CYCLE
BOUNDING
A
HOLE
IF
E
IS
THE
HALF
EDGE
IMMEDIATELY
LEFT
OF
V
THEN
WE
ADD
AN
ARC
BETWEEN
THE
TWO
NODES
IN
G
REPRESENTING
THE
CYCLE
CONTAINING
E
AND
THE
HOLE
CYCLE
OF
WHICH
V
IS
THE
LEFTMOST
VERTEX
TO
FIND
THESE
NODES
IN
G
EFFICIENTLY
WE
NEED
POINTERS
FROM
EVERY
HALF
EDGE
RECORD
TO
THE
NODE
IN
G
REPRESENTING
THE
CYCLE
IT
IS
IN
SO
THE
FACE
INFORMATION
OF
THE
DOUBLY
CONNECTED
EDGE
LIST
CAN
BE
SET
IN
O
N
K
ADDITIONAL
NEW
ARC
TIME
AFTER
THE
PLANE
SWEEP
CHAPTER
LINE
SEGMENT
INTERSECTION
ONE
THING
REMAINS
EACH
FACE
F
IN
THE
OVERLAY
MUST
BE
LABELED
WITH
THE
NAMES
OF
THE
FACES
IN
THE
OLD
SUBDIVISIONS
THAT
CONTAINED
IT
TO
FIND
THESE
FACES
CONSIDER
AN
ARBITRARY
VERTEX
V
OF
F
IF
V
IS
THE
INTERSECTION
OF
AN
EDGE
FROM
AND
AN
EDGE
FROM
THEN
WE
CAN
DECIDE
WHICH
FACES
OF
AND
CONTAIN
F
BY
LOOKING
AT
THE
INCIDENTFACE
POINTER
OF
THE
APPROPRIATE
HALF
EDGES
CORRESPONDING
TO
AND
IF
V
IS
NOT
AN
INTERSECTION
BUT
A
VERTEX
OF
SAY
THEN
WE
ONLY
KNOW
THE
FACE
OF
CONTAINING
F
TO
FIND
THE
FACE
OF
CONTAINING
F
WE
HAVE
TO
DO
SOME
MORE
WORK
WE
HAVE
TO
DETERMINE
THE
FACE
OF
THAT
CONTAINS
V
IN
OTHER
WORDS
IF
WE
KNEW
FOR
EACH
VERTEX
OF
IN
WHICH
FACE
OF
IT
LAY
AND
VICE
VERSA
THEN
WE
COULD
LABEL
THE
FACES
OF
O
CORRECTLY
HOW
CAN
WE
COMPUTE
THIS
INFORMATION
THE
SOLUTION
IS
TO
APPLY
THE
PARADIGM
THAT
HAS
BEEN
INTRODUCED
IN
THIS
CHAPTER
PLANE
SWEEP
ONCE
MORE
HOWEVER
WE
WON
T
EXPLAIN
THIS
FINAL
STEP
HERE
IT
IS
A
GOOD
EXERCISE
TO
TEST
YOUR
UNDERSTANDING
OF
THE
PLANE
SWEEP
APPROACH
TO
DESIGN
THE
ALGORITHM
YOURSELF
IN
FACT
IT
IS
NOT
NECESSARY
TO
COMPUTE
THIS
INFORMATION
IN
A
SEPARATE
PLANE
SWEEP
IT
CAN
ALSO
BE
DONE
IN
THE
SWEEP
THAT
COMPUTES
THE
INTERSECTIONS
PUTTING
EVERYTHING
TOGETHER
WE
GET
THE
FOLLOWING
ALGORITHM
ALGORITHM
MAPOVERLAY
INPUT
TWO
PLANAR
SUBDIVISIONS
AND
STORED
IN
DOUBLY
CONNECTED
EDGE
LISTS
OUTPUT
THE
OVERLAY
OF
AND
STORED
IN
A
DOUBLY
CONNECTED
EDGE
LIST
D
COPY
THE
DOUBLY
CONNECTED
EDGE
LISTS
FOR
AND
TO
A
NEW
DOUBLY
CONNECTED
EDGE
LIST
D
COMPUTE
ALL
INTERSECTIONS
BETWEEN
EDGES
FROM
AND
WITH
THE
PLANE
SWEEP
ALGORITHM
OF
SECTION
IN
ADDITION
TO
THE
ACTIONS
ON
T
AND
Q
REQUIRED
AT
THE
EVENT
POINTS
DO
THE
FOLLOWING
UPDATE
D
AS
EXPLAINED
ABOVE
IF
THE
EVENT
INVOLVES
EDGES
OF
BOTH
AND
THIS
WAS
EXPLAINED
FOR
THE
CASE
WHERE
AN
EDGE
OF
PASSES
THROUGH
A
VERTEX
OF
STORE
THE
HALF
EDGE
IMMEDIATELY
TO
THE
LEFT
OF
THE
EVENT
POINT
AT
THE
VERTEX
IN
D
REPRESENTING
IT
NOW
D
IS
THE
DOUBLY
CONNECTED
EDGE
LIST
FOR
O
EXCEPT
THAT
THE
INFORMATION
ABOUT
THE
FACES
HAS
NOT
BEEN
COMPUTED
YET
DETERMINE
THE
BOUNDARY
CYCLES
IN
O
BY
TRAVERSING
D
CONSTRUCT
THE
GRAPH
G
WHOSE
NODES
CORRESPOND
TO
BOUNDARY
CYCLES
AND
WHOSE
ARCS
CONNECT
EACH
HOLE
CYCLE
TO
THE
CYCLE
TO
THE
LEFT
OF
ITS
LEFTMOST
VER
TEX
AND
COMPUTE
ITS
CONNECTED
COMPONENTS
THE
INFORMATION
TO
DETERMINE
THE
ARCS
OF
G
HAS
BEEN
COMPUTED
IN
LINE
SECOND
ITEM
FOR
EACH
CONNECTED
COMPONENT
IN
G
DO
LET
C
BE
THE
UNIQUE
OUTER
BOUNDARY
CYCLE
IN
THE
COMPONENT
AND
LET
F
DENOTE
THE
FACE
BOUNDED
BY
THE
CYCLE
CREATE
A
FACE
RECORD
FOR
F
SET
OUTERCOMPONENT
F
TO
SOME
HALF
EDGE
OF
C
AND
CONSTRUCT
THE
LIST
INNERCOMPONENTS
F
CONSISTING
OF
POINTERS
TO
ONE
HALF
EDGE
IN
EACH
HOLE
CYCLE
IN
THE
COMPONENT
LET
THE
INCIDENTFACE
POINTERS
OF
ALL
HALF
EDGES
IN
THE
CYCLES
POINT
TO
THE
FACE
RECORD
OF
F
LABEL
EACH
FACE
OF
O
WITH
THE
NAMES
OF
THE
FACES
OF
AND
CONTAINING
IT
AS
EXPLAINED
ABOVE
THEOREM
LET
BE
A
PLANAR
SUBDIVISION
OF
COMPLEXITY
LET
BE
A
SUBDIVISION
OF
COMPLEXITY
AND
LET
N
THE
OVERLAY
OF
AND
CAN
BE
CONSTRUCTED
IN
O
N
LOG
N
K
LOG
N
TIME
WHERE
K
IS
THE
COMPLEXITY
OF
THE
OVERLAY
PROOF
COPYING
THE
DOUBLY
CONNECTED
EDGE
LISTS
IN
LINE
TAKES
O
N
TIME
AND
THE
PLANE
SWEEP
OF
LINE
TAKES
O
N
LOG
N
K
LOG
N
TIME
BY
LEMMA
STEPS
WHERE
WE
FILL
IN
THE
FACE
RECORDS
TAKES
TIME
LINEAR
IN
THE
COMPLEXITY
OF
O
THE
CONNECTED
COMPONENTS
OF
A
GRAPH
CAN
BE
DETERMINED
IN
LINEAR
TIME
BY
A
SIMPLE
DEPTH
FIRST
SEARCH
FINALLY
LABELING
EACH
FACE
IN
THE
RESULTING
SUBDIVISION
WITH
THE
FACES
OF
THE
ORIGINAL
SUBDIVISIONS
THAT
CONTAIN
IT
CAN
BE
DONE
IN
O
N
LOG
N
K
LOG
N
TIME
SECTION
BOOLEAN
OPERATIONS
BOOLEAN
OPERATIONS
THE
MAP
OVERLAY
ALGORITHM
IS
A
POWERFUL
INSTRUMENT
THAT
CAN
BE
USED
FOR
VARIOUS
OTHER
APPLICATIONS
ONE
PARTICULAR
USEFUL
ONE
IS
PERFORMING
THE
BOOLEAN
OPERA
TIONS
UNION
INTERSECTION
AND
DIFFERENCE
ON
TWO
POLYGONS
AND
SEE
FIGURE
FOR
AN
EXAMPLE
NOTE
THAT
THE
OUTPUT
OF
THE
OPERATIONS
MIGHT
NO
LONGER
BE
A
POLYGON
IT
CAN
CONSIST
OF
A
NUMBER
OF
POLYGONAL
REGIONS
SOME
WITH
HOLES
UNION
INTERSECTION
DIFFERENCE
TO
PERFORM
THE
BOOLEAN
OPERATION
WE
REGARD
THE
POLYGONS
AS
PLANAR
MAPS
WHOSE
BOUNDED
FACES
ARE
LABELED
AND
RESPECTIVELY
WE
COMPUTE
THE
OVERLAY
OF
THESE
MAPS
AND
WE
EXTRACT
THE
FACES
IN
THE
OVERLAY
WHOSE
LABELS
CORRESPOND
TO
THE
PARTICULAR
BOOLEAN
OPERATION
WE
WANT
TO
PERFORM
IF
WE
WANT
TO
COMPUTE
THE
INTERSECTION
WE
EXTRACT
THE
FACES
IN
THE
OVERLAY
THAT
ARE
FIGURE
THE
BOOLEAN
OPERATIONS
UNION
INTERSECTION
AND
DIFFERENCE
ON
TWO
POLYGONS
AND
LABELED
WITH
AND
IF
WE
WANT
TO
COMPUTE
THE
UNION
WE
EXTRACT
THE
CHAPTER
LINE
SEGMENT
INTERSECTION
FACES
IN
THE
OVERLAY
THAT
ARE
LABELED
WITH
OR
AND
IF
WE
WANT
TO
COMPUTE
THE
DIFFERENCE
WE
EXTRACT
THE
FACES
IN
THE
OVERLAY
THAT
ARE
LABELED
WITH
AND
NOT
WITH
BECAUSE
EVERY
INTERSECTION
POINT
OF
AN
EDGE
OF
AND
AN
EDGE
OF
IS
A
VERTEX
OF
THE
RUNNING
TIME
OF
THE
ALGORITHM
IS
O
N
LOG
N
K
LOG
N
WHERE
N
IS
THE
TOTAL
NUMBER
OF
VERTICES
IN
AND
AND
K
IS
THE
COMPLEXITY
OF
THE
SAME
HOLDS
FOR
THE
OTHER
BOOLEAN
OPERATIONS
EVERY
INTERSECTION
OF
TWO
EDGES
IS
A
VERTEX
OF
THE
FINAL
RESULT
NO
MATTER
WHICH
OPERATION
WE
WANT
TO
PERFORM
WE
IMMEDIATELY
GET
THE
FOLLOWING
RESULT
COROLLARY
LET
BE
A
POLYGON
WITH
VERTICES
AND
A
POLYGON
WITH
VERTICES
AND
LET
N
THEN
AND
CAN
EACH
BE
COMPUTED
IN
O
N
LOG
N
K
LOG
N
TIME
WHERE
K
IS
THE
COMPLEXITY
OF
THE
OUTPUT
NOTES
AND
COMMENTS
THE
LINE
SEGMENT
INTERSECTION
PROBLEM
IS
ONE
OF
THE
MOST
FUNDAMENTAL
PROBLEMS
IN
COMPUTATIONAL
GEOMETRY
THE
O
N
LOG
N
K
LOG
N
SOLUTION
PRESENTED
IN
THIS
CHAPTER
WAS
GIVEN
BY
BENTLEY
AND
OTTMANN
IN
A
FEW
YEARS
EARLIER
SHAMOS
AND
HOEY
HAD
SOLVED
THE
DETECTION
PROBLEM
WHERE
ONE
IS
ONLY
INTERESTED
IN
DECIDING
WHETHER
THERE
IS
AT
LEAST
ONE
INTERSECTION
IN
O
N
LOG
N
TIME
THE
METHOD
FOR
REDUCING
THE
WORKING
STORAGE
FROM
O
N
K
TO
O
N
DESCRIBED
IN
THIS
CHAPTER
IS
TAKEN
FROM
PACH
AND
SHARIR
WHO
ALSO
SHOW
THAT
THE
EVENT
LIST
CAN
HAVE
SIZE

N
LOG
N
BEFORE
THIS
IMPROVEMENT
BROWN
DESCRIBES
AN
ALTERNATIVE
METHOD
TO
ACHIEVE
THE
REDUCTION
THE
LOWER
BOUND
FOR
THE
PROBLEM
OF
REPORTING
ALL
LINE
SEGMENT
INTERSECTIONS
IS

N
LOG
N
K
SO
THE
PLANE
SWEEP
ALGORITHM
DESCRIBED
IN
THIS
CHAPTER
IS
NOT
OPTIMAL
WHEN
K
IS
LARGE
A
FIRST
STEP
TOWARDS
AN
OPTIMAL
ALGORITHM
WAS
TAKEN
BY
CHAZELLE
WHO
GAVE
AN
ALGORITHM
WITH
O
N
N
LOGLOG
N
K
RUNNING
TIME
IN
CHAZELLE
AND
EDELSBRUNNER
PRESENTED
THE
FIRST
O
N
LOG
N
K
TIME
ALGORITHM
UNFORTUNATELY
IT
REQUIRES
O
N
K
STORAGE
LATER
CLARKSON
AND
SHOR
AND
MULMULEY
GAVE
RANDOMIZED
INCREMENTAL
ALGORITHMS
WHOSE
EXPECTED
RUNNING
TIME
IS
ALSO
O
N
LOG
N
K
SEE
CHAPTER
FOR
AN
EXPLANATION
OF
RANDOMIZED
ALGORITHMS
THE
WORKING
STORAGE
OF
THESE
ALGORITHMS
IS
O
N
AND
O
N
K
RESPECTIVELY
UNLIKE
THE
ALGORITHM
OF
CHAZELLE
AND
EDELSBRUNNER
THESE
RANDOMIZED
ALGORITHMS
ALSO
WORK
FOR
COMPUTING
INTER
SECTIONS
IN
A
SET
OF
CURVES
BALABAN
GAVE
THE
FIRST
DETERMINISTIC
ALGORITHM
FOR
THE
SEGMENT
INTERSECTION
PROBLEM
THAT
WORKS
IN
O
N
LOG
N
K
TIME
AND
O
N
SPACE
IT
ALSO
WORKS
FOR
CURVES
THERE
ARE
CASES
OF
THE
LINE
SEGMENT
INTERSECTION
PROBLEM
THAT
ARE
EASIER
THAN
THE
GENERAL
CASE
ONE
SUCH
CASE
IS
WHERE
WE
HAVE
TWO
SETS
OF
SEGMENTS
SAY
RED
SEGMENTS
AND
BLUE
SEGMENTS
SUCH
THAT
NO
TWO
SEGMENTS
FROM
THE
SAME
SET
INTERSECT
EACH
OTHER
THIS
IS
IN
FACT
EXACTLY
THE
NETWORK
OVERLAY
PROBLEM
IN
THE
SOLUTION
DESCRIBED
IN
THIS
CHAPTER
HOWEVER
THE
FACT
THAT
THE
SEGMENTS
CAME
FROM
TWO
SETS
OF
NON
INTERSECTING
SEGMENTS
WAS
NOT
USED
THIS
SO
CALLED
RED
BLUE
LINE
SEGMENT
INTERSECTION
PROBLEM
WAS
SOLVED
IN
O
N
LOG
N
K
TIME
AND
O
N
STORAGE
BY
MAIRSON
AND
STOLFI
BEFORE
THE
GENERAL
PROBLEM
WAS
SOLVED
OPTIMALLY
OTHER
OPTIMAL
RED
BLUE
INTERSECTION
ALGORITHMS
WERE
GIVEN
BY
CHAZELLE
ET
AL
AND
BY
PALAZZI
AND
SNOEYINK
IF
THE
TWO
SETS
OF
SEGMENTS
FORM
CONNECTED
SUBDIVISIONS
THEN
THE
SITUATION
IS
EVEN
BETTER
IN
THIS
CASE
THE
OVERLAY
CAN
BE
COMPUTED
IN
O
N
K
TIME
AS
HAS
BEEN
SHOWN
BY
FINKE
AND
HINRICHS
THEIR
RESULT
GENERALIZES
AND
IMPROVES
PREVIOUS
RESULTS
ON
MAP
OVERLAY
BY
NIEVERGELT
AND
PREPARATA
GUIBAS
AND
SEIDEL
AND
MAIRSON
AND
STOLFI
THE
LINE
SEGMENT
INTERSECTION
COUNTING
PROBLEM
IS
TO
DETERMINE
THE
NUMBER
OF
INTERSECTION
POINTS
IN
A
SET
OF
N
LINE
SEGMENTS
SINCE
THE
OUTPUT
IS
A
SINGLE
INTEGER
A
TERM
WITH
K
IN
THE
TIME
BOUND
NO
LONGER
REFERS
TO
THE
OUTPUT
SIZE
WHICH
IS
CONSTANT
BUT
ONLY
TO
THE
NUMBER
OF
INTERSECTIONS
ALGORITHMS
THAT
DO
NOT
DEPEND
ON
THE
NUMBER
OF
INTERSECTIONS
TAKE
O
LOGC
N
TIME
FOR
SOME
SMALL
CONSTANT
C
A
RUNNING
TIME
CLOSE
TO
O
N
LOG
N
IS
NOT
KNOWN
TO
EXIST
PLANE
SWEEP
IS
ONE
OF
THE
MOST
IMPORTANT
PARADIGMS
FOR
DESIGNING
GEOMETRIC
ALGORITHMS
THE
FIRST
ALGORITHMS
IN
COMPUTATIONAL
GEOMETRY
BASED
ON
THIS
PARADIGM
ARE
BY
SHAMOS
AND
HOEY
LEE
AND
PREPARATA
AND
BENTLEY
AND
OTTMANN
PLANE
SWEEP
ALGORITHMS
ARE
ESPECIALLY
SUITED
FOR
FINDING
INTERSECTIONS
IN
SETS
OF
OBJECTS
BUT
THEY
CAN
ALSO
BE
USED
FOR
SOLVING
MANY
OTHER
PROBLEMS
IN
CHAPTER
PLANE
SWEEP
SOLVES
PART
OF
THE
POLYGON
TRIANGULATION
PROBLEM
AND
IN
CHAPTER
WE
WILL
SEE
A
PLANE
SWEEP
ALGORITHM
TO
COMPUTE
THE
SO
CALLED
VORONOI
DIAGRAM
OF
A
SET
OF
POINTS
THE
ALGORITHM
PRESENTED
IN
THE
CURRENT
CHAPTER
SWEEPS
A
HORIZONTAL
LINE
DOWNWARDS
OVER
THE
PLANE
FOR
SOME
PROBLEMS
IT
IS
MORE
CONVENIENT
TO
SWEEP
THE
PLANE
IN
ANOTHER
WAY
FOR
INSTANCE
WE
CAN
SWEEP
THE
PLANE
WITH
A
ROTATING
LINE
SEE
CHAPTER
FOR
AN
EXAMPLE
OR
WITH
A
PSEUDO
LINE
A
LINE
THAT
NEED
NOT
BE
STRAIGHT
BUT
OTHERWISE
BEHAVES
MORE
OR
LESS
AS
A
LINE
THE
PLANE
SWEEP
TECHNIQUE
CAN
ALSO
BE
USED
IN
HIGHER
DIMENSIONS
HERE
WE
SWEEP
THE
SPACE
WITH
A
HYPERPLANE
SUCH
ALGORITHMS
ARE
CALLED
SPACE
SWEEP
ALGORITHMS
IN
THIS
CHAPTER
WE
DESCRIBED
A
DATA
STRUCTURE
FOR
STORING
SUBDIVISIONS
THE
DOUBLY
CONNECTED
EDGE
LIST
THIS
STRUCTURE
OR
IN
FACT
A
VARIANT
OF
IT
WAS
DESCRIBED
BY
MULLER
AND
PREPARATA
THERE
ARE
ALSO
OTHER
DATA
STRUCTURES
FOR
STORING
SUBDIVISIONS
SUCH
AS
THE
WINGED
EDGE
STRUCTURE
BY
BAUMGART
AND
THE
QUAD
EDGE
STRUCTURE
BY
GUIBAS
AND
STOLFI
THE
DIFFERENCE
BETWEEN
ALL
THESE
STRUCTURES
IS
SMALL
THEY
ALL
HAVE
MORE
OR
LESS
THE
SAME
FUNCTIONALITY
BUT
SOME
SAVE
A
FEW
BYTES
OF
STORAGE
PER
EDGE
SECTION
EXERCISES
EXERCISES
LET
BE
A
SET
OF
N
DISJOINT
LINE
SEGMENTS
WHOSE
UPPER
ENDPOINTS
LIE
ON
THE
LINE
Y
AND
WHOSE
LOWER
ENDPOINTS
LIE
ON
THE
LINE
Y
THESE
SEGMENTS
PARTITION
THE
HORIZONTAL
STRIP
INTO
N
REGIONS
GIVE
AN
O
N
LOG
N
TIME
ALGORITHM
TO
BUILD
A
BINARY
SEARCH
TREE
ON
THE
SEGMENTS
CHAPTER
LINE
SEGMENT
INTERSECTION
IN
SUCH
THAT
THE
REGION
CONTAINING
A
QUERY
POINT
CAN
BE
DETERMINED
IN
O
LOG
N
TIME
ALSO
DESCRIBE
THE
QUERY
ALGORITHM
IN
DETAIL
THE
INTERSECTION
DETECTION
PROBLEM
FOR
A
SET
OF
N
LINE
SEGMENTS
IS
TO
DETERMINE
WHETHER
THERE
EXISTS
A
PAIR
OF
SEGMENTS
IN
THAT
INTERSECT
GIVE
A
PLANE
SWEEP
ALGORITHM
THAT
SOLVES
THE
INTERSECTION
DETECTION
PROBLEM
IN
O
N
LOG
N
TIME
CHANGE
THE
CODE
OF
ALGORITHM
FINDINTERSECTIONS
AND
OF
THE
PRO
CEDURES
THAT
IT
CALLS
SUCH
THAT
THE
WORKING
STORAGE
IS
O
N
INSTEAD
OF
O
N
K
LET
BE
A
SET
OF
N
LINE
SEGMENTS
IN
THE
PLANE
THAT
MAY
PARTLY
OVERLAP
EACH
OTHER
FOR
EXAMPLE
COULD
CONTAIN
THE
SEGMENTS
AND
WE
WANT
TO
COMPUTE
ALL
INTERSECTIONS
IN
MORE
PRECISELY
WE
WANT
TO
COMPUTE
EACH
PROPER
INTERSECTION
OF
TWO
SEGMENTS
IN
THAT
IS
EACH
INTERSECTION
OF
TWO
NON
PARALLEL
SEGMENTS
AND
FOR
EACH
END
POINT
OF
A
SEGMENT
ALL
SEGMENTS
CONTAINING
THE
POINT
ADAPT
ALGORITHM
FINDINTERSECTIONS
TO
THIS
END
WHICH
OF
THE
FOLLOWING
EQUALITIES
ARE
ALWAYS
TRUE
TWIN
TWIN
E
E
NEXT
PREV
E
E
TWIN
PREV
TWIN
E
NEXT
E
INCIDENTFACE
E
INCIDENTFACE
NEXT
E
GIVE
AN
EXAMPLE
OF
A
DOUBLY
CONNECTED
EDGE
LIST
WHERE
FOR
AN
EDGE
E
THE
FACES
INCIDENTFACE
E
AND
INCIDENTFACE
TWIN
E
ARE
THE
SAME
GIVEN
A
DOUBLY
CONNECTED
EDGE
LIST
REPRESENTATION
OF
A
SUBDIVISION
WHERE
TWIN
E
NEXT
E
HOLDS
FOR
EVERY
HALF
EDGE
E
HOW
MANY
FACES
CAN
THE
SUBDIVISION
HAVE
AT
MOST
GIVE
PSEUDOCODE
FOR
AN
ALGORITHM
THAT
LISTS
ALL
VERTICES
ADJACENT
TO
A
GIVEN
VERTEX
V
IN
A
DOUBLY
CONNECTED
EDGE
LIST
ALSO
GIVE
PSEUDOCODE
FOR
AN
ALGORITHM
THAT
LISTS
ALL
EDGES
THAT
BOUND
A
FACE
IN
A
NOT
NECESSARILY
CONNECTED
SUBDIVISION
SUPPOSE
THAT
A
DOUBLY
CONNECTED
EDGE
LIST
OF
A
CONNECTED
SUBDIVISION
IS
GIVEN
GIVE
PSEUDOCODE
FOR
AN
ALGORITHM
THAT
LISTS
ALL
FACES
WITH
VERTICES
THAT
APPEAR
ON
THE
OUTER
BOUNDARY
LET
BE
A
SUBDIVISION
OF
COMPLEXITY
N
AND
LET
P
BE
A
SET
OF
M
POINTS
GIVE
A
PLANE
SWEEP
ALGORITHM
THAT
COMPUTES
FOR
EVERY
POINT
IN
P
IN
WHICH
FACE
OF
IT
IS
CONTAINED
SHOW
THAT
YOUR
ALGORITHM
RUNS
IN
O
N
M
LOG
N
M
TIME
LET
BE
A
SET
OF
N
CIRCLES
IN
THE
PLANE
DESCRIBE
A
PLANE
SWEEP
ALGORITHM
TO
COMPUTE
ALL
INTERSECTION
POINTS
BETWEEN
THE
CIRCLES
BECAUSE
WE
DEAL
WITH
CIRCLES
NOT
DISCS
TWO
CIRCLES
DO
NOT
INTERSECT
IF
ONE
LIES
ENTIRELY
INSIDE
THE
OTHER
YOUR
ALGORITHM
SHOULD
RUN
IN
O
N
K
LOG
N
TIME
WHERE
K
IS
THE
NUMBER
OF
INTERSECTION
POINTS
LET
BE
A
SET
OF
N
TRIANGLES
IN
THE
PLANE
THE
BOUNDARIES
OF
THE
TRIANGLES
ARE
DISJOINT
BUT
IT
IS
POSSIBLE
THAT
A
TRIANGLE
LIES
COMPLETELY
INSIDE
ANOTHER
TRIANGLE
LET
P
BE
A
SET
OF
N
POINTS
IN
THE
PLANE
GIVE
AN
O
N
LOG
N
ALGORITHM
THAT
REPORTS
EACH
POINT
IN
P
LYING
OUTSIDE
ALL
TRIANGLES
LET
BE
A
SET
OF
N
DISJOINT
TRIANGLES
IN
THE
PLANE
WE
WANT
TO
FIND
A
SET
OF
N
SEGMENTS
WITH
THE
FOLLOWING
PROPERTIES
EACH
SEGMENT
CONNECTS
A
POINT
ON
THE
BOUNDARY
OF
ONE
TRIANGLE
TO
A
POINT
ON
THE
BOUNDARY
OF
ANOTHER
TRIANGLE
THE
INTERIORS
OF
THE
SEGMENTS
ARE
PAIRWISE
DISJOINT
AND
THEY
ARE
DISJOINT
FROM
THE
TRIANGLES
TOGETHER
THEY
CONNECT
ALL
TRIANGLES
TO
EACH
OTHER
THAT
IS
BY
WALKING
ALONG
THE
SEGMENTS
AND
THE
TRIANGLE
BOUNDARIES
IT
MUST
BE
POSSIBLE
TO
WALK
FROM
A
TRIANGLE
TO
ANY
OTHER
TRIANGLE
DEVELOP
A
PLANE
SWEEP
ALGORITHM
FOR
THIS
PROBLEM
THAT
RUNS
IN
O
N
LOG
N
TIME
STATE
THE
EVENTS
AND
THE
DATA
STRUCTURES
THAT
YOU
USE
EXPLICITLY
AND
DESCRIBE
THE
CASES
THAT
ARISE
AND
THE
ACTIONS
REQUIRED
FOR
EACH
OF
THEM
ALSO
STATE
THE
SWEEP
INVARIANT
LET
BE
A
SET
OF
N
DISJOINT
LINE
SEGMENTS
IN
THE
PLANE
AND
LET
P
BE
A
POINT
NOT
ON
ANY
OF
THE
LINE
SEGMENTS
OF
WE
WISH
TO
DETERMINE
ALL
LINE
SEGMENTS
OF
THAT
P
CAN
SEE
THAT
IS
ALL
LINE
SEGMENTS
OF
THAT
CONTAIN
SOME
POINT
Q
SO
THAT
THE
OPEN
SEGMENT
PQ
DOESN
T
INTERSECT
ANY
LINE
SEGMENT
OF
GIVE
AN
O
N
LOG
N
TIME
ALGORITHM
FOR
THIS
PROBLEM
THAT
USES
A
ROTATING
HALF
LINE
WITH
ITS
ENDPOINT
AT
P
SECTION
EXERCISES
NOT
VISIBLE
POLYGON
TRIANGULATION
GUARDING
AN
ART
GALLERY
WORKS
OF
FAMOUS
PAINTERS
ARE
NOT
ONLY
POPULAR
AMONG
ART
LOVERS
BUT
ALSO
AMONG
CRIMINALS
THEY
ARE
VERY
VALUABLE
EASY
TO
TRANSPORT
AND
APPARENTLY
NOT
SO
DIFFICULT
TO
SELL
ART
GALLERIES
THEREFORE
HAVE
TO
GUARD
THEIR
COLLECTIONS
CAREFULLY
FIGURE
AN
ART
GALLERY
DURING
THE
DAY
THE
ATTENDANTS
CAN
KEEP
A
LOOK
OUT
BUT
AT
NIGHT
THIS
HAS
TO
BE
DONE
BY
VIDEO
CAMERAS
THESE
CAMERAS
ARE
USUALLY
HUNG
FROM
THE
CEILING
AND
THEY
ROTATE
ABOUT
A
VERTICAL
AXIS
THE
IMAGES
FROM
THE
CAMERAS
ARE
SENT
TO
TV
SCREENS
IN
THE
OFFICE
OF
THE
NIGHT
WATCH
BECAUSE
IT
IS
EASIER
TO
KEEP
AN
EYE
ON
FEW
TV
SCREENS
RATHER
THAN
ON
MANY
THE
NUMBER
OF
CAMERAS
SHOULD
BE
AS
SMALL
AS
POSSIBLE
AN
ADDITIONAL
ADVANTAGE
OF
A
SMALL
NUMBER
OF
CAMERAS
IS
THAT
THE
COST
OF
THE
SECURITY
SYSTEM
WILL
BE
LOWER
ON
THE
OTHER
HAND
WE
CANNOT
HAVE
TOO
FEW
CAMERAS
BECAUSE
EVERY
PART
OF
THE
GALLERY
MUST
BE
VISIBLE
TO
AT
LEAST
ONE
OF
THEM
SO
WE
SHOULD
PLACE
THE
CAMERAS
AT
STRATEGIC
POSITIONS
SUCH
THAT
EACH
OF
THEM
GUARDS
A
LARGE
PART
OF
THE
GALLERY
THIS
GIVES
RISE
TO
WHAT
IS
USUALLY
REFERRED
TO
AS
THE
ART
GALLERY
PROBLEM
HOW
MANY
CAMERAS
DO
WE
NEED
TO
GUARD
A
GIVEN
GALLERY
AND
HOW
DO
WE
DECIDE
WHERE
TO
PLACE
THEM
CHAPTER
POLYGON
TRIANGULATION
GUARDING
AND
TRIANGULATIONS
IF
WE
WANT
TO
DEFINE
THE
ART
GALLERY
PROBLEM
MORE
PRECISELY
WE
SHOULD
FIRST
FORMALIZE
THE
NOTION
OF
GALLERY
A
GALLERY
IS
OF
COURSE
A
DIMENSIONAL
SPACE
BUT
A
FLOOR
PLAN
GIVES
US
ENOUGH
INFORMATION
TO
PLACE
THE
CAMERAS
THEREFORE
WE
MODEL
A
GALLERY
AS
A
POLYGONAL
REGION
IN
THE
PLANE
WE
FURTHER
RESTRICT
OURSELVES
TO
REGIONS
THAT
ARE
SIMPLE
POLYGONS
THAT
IS
REGIONS
ENCLOSED
BY
A
SINGLE
CLOSED
POLYGONAL
CHAIN
THAT
DOES
NOT
INTERSECT
ITSELF
THUS
WE
DO
NOT
ALLOW
REGIONS
WITH
HOLES
A
CAMERA
POSITION
IN
THE
GALLERY
CORRESPONDS
TO
A
POINT
IN
THE
POLYGON
A
CAMERA
SEES
THOSE
POINTS
IN
THE
POLYGON
TO
WHICH
IT
CAN
BE
CONNECTED
WITH
AN
OPEN
SEGMENT
THAT
LIES
IN
THE
INTERIOR
OF
THE
POLYGON
HOW
MANY
CAMERAS
DO
WE
NEED
TO
GUARD
A
SIMPLE
POLYGON
THIS
CLEARLY
DEPENDS
ON
THE
POLYGON
AT
HAND
THE
MORE
COMPLEX
THE
POLYGON
THE
MORE
CAMERAS
ARE
REQUIRED
WE
SHALL
THEREFORE
EXPRESS
THE
BOUND
ON
THE
NUMBER
OF
CAMERAS
NEEDED
IN
TERMS
OF
N
THE
NUMBER
OF
VERTICES
OF
THE
POLYGON
BUT
EVEN
WHEN
TWO
POLYGONS
HAVE
THE
SAME
NUMBER
OF
VERTICES
ONE
CAN
BE
EASIER
TO
GUARD
THAN
THE
OTHER
A
CONVEX
POLYGON
FOR
EXAMPLE
CAN
ALWAYS
BE
GUARDED
WITH
ONE
CAMERA
TO
BE
ON
THE
SAFE
SIDE
WE
SHALL
LOOK
AT
THE
WORST
CASE
SCENARIO
THAT
IS
WE
SHALL
GIVE
A
BOUND
THAT
IS
GOOD
FOR
ANY
SIMPLE
POLYGON
WITH
N
VERTICES
IT
WOULD
BE
NICE
IF
WE
COULD
FIND
THE
MINIMUM
NUMBER
OF
CAMERAS
FOR
THE
SPECIFIC
POLYGON
WE
ARE
GIVEN
NOT
JUST
A
WORST
CASE
BOUND
UNFORTUNATELY
THE
PROBLEM
OF
FINDING
THE
MINIMUM
NUMBER
OF
CAMERAS
FOR
A
GIVEN
POLYGON
IS
NP
HARD
LET
P
BE
A
SIMPLE
POLYGON
WITH
N
VERTICES
BECAUSE
P
MAY
BE
A
COMPLICATED
SHAPE
IT
SEEMS
DIFFICULT
TO
SAY
ANYTHING
ABOUT
THE
NUMBER
OF
CAMERAS
WE
NEED
TO
GUARD
P
HENCE
WE
FIRST
DECOMPOSE
P
INTO
PIECES
THAT
ARE
EASY
TO
GUARD
NAMELY
TRIANGLES
WE
DO
THIS
BY
DRAWING
DIAGONALS
BETWEEN
PAIRS
OF
VERTICES
FIGURE
A
SIMPLE
POLYGON
AND
A
POSSIBLE
TRIANGULATION
OF
IT
A
DIAGONAL
IS
AN
OPEN
LINE
SEGMENT
THAT
CONNECTS
TWO
VERTICES
OF
P
AND
LIES
IN
THE
INTERIOR
OF
P
A
DECOMPOSITION
OF
A
POLYGON
INTO
TRIANGLES
BY
A
MAXIMAL
SET
OF
NON
INTERSECTING
DIAGONALS
IS
CALLED
A
TRIANGULATION
OF
THE
POLYGON
SEE
FIGURE
WE
REQUIRE
THAT
THE
SET
OF
NON
INTERSECTING
DIAGONALS
BE
MAXIMAL
TO
ENSURE
THAT
NO
TRIANGLE
HAS
A
POLYGON
VERTEX
IN
THE
INTERIOR
OF
ONE
OF
ITS
EDGES
THIS
COULD
HAPPEN
IF
THE
POLYGON
HAS
THREE
CONSECUTIVE
COLLINEAR
VERTICES
TRIANGULATIONS
ARE
USUALLY
NOT
UNIQUE
THE
POLYGON
IN
FIGURE
FOR
EXAMPLE
CAN
BE
TRIANGULATED
IN
MANY
DIFFERENT
WAYS
WE
CAN
GUARD
P
BY
PLACING
A
CAMERA
IN
EVERY
TRIANGLE
OF
A
TRIANGULATION
TP
OF
P
BUT
DOES
A
TRIANGULATION
ALWAYS
EXIST
AND
HOW
MANY
TRIANGLES
CAN
THERE
BE
IN
A
TRIANGULATION
THE
FOLLOWING
THEOREM
ANSWERS
THESE
QUESTIONS
THEOREM
EVERY
SIMPLE
POLYGON
ADMITS
A
TRIANGULATION
AND
ANY
TRIANGULA
TION
OF
A
SIMPLE
POLYGON
WITH
N
VERTICES
CONSISTS
OF
EXACTLY
N
TRIANGLES
PROOF
WE
PROVE
THIS
THEOREM
BY
INDUCTION
ON
N
WHEN
N
THE
POLYGON
ITSELF
IS
A
TRIANGLE
AND
THE
THEOREM
IS
TRIVIALLY
TRUE
LET
N
AND
ASSUME
THAT
THE
THEOREM
IS
TRUE
FOR
ALL
M
N
LET
P
BE
A
POLYGON
WITH
N
VERTICES
WE
FIRST
PROVE
THE
EXISTENCE
OF
A
DIAGONAL
IN
P
LET
V
BE
THE
LEFTMOST
VERTEX
OF
P
IN
CASE
OF
TIES
WE
TAKE
THE
LOWEST
LEFTMOST
VERTEX
LET
U
AND
W
BE
THE
TWO
NEIGHBORING
SECTION
GUARDING
AND
TRIANGULATIONS
VERTICES
OF
V
ON
THE
BOUNDARY
OF
P
IF
THE
OPEN
SEGMENT
UW
LIES
IN
THE
INTERIOR
OF
V
P
WE
HAVE
FOUND
A
DIAGONAL
OTHERWISE
THERE
ARE
ONE
OR
MORE
VERTICES
INSIDE
THE
TRIANGLE
DEFINED
BY
U
V
AND
W
OR
ON
THE
DIAGONAL
UW
OF
THOSE
VERTICES
LET
VI
BE
THE
ONE
FARTHEST
FROM
THE
LINE
THROUGH
U
AND
W
THE
SEGMENT
CONNECTING
VI
TO
V
CANNOT
INTERSECT
AN
EDGE
OF
P
BECAUSE
SUCH
AN
EDGE
WOULD
HAVE
AN
ENDPOINT
INSIDE
THE
TRIANGLE
THAT
IS
FARTHER
FROM
THE
LINE
THROUGH
U
AND
W
CONTRADICTING
THE
DEFINITION
OF
VI
HENCE
VVI
IS
A
DIAGONAL
SO
A
DIAGONAL
EXISTS
ANY
DIAGONAL
CUTS
P
INTO
TWO
SIMPLE
SUBPOLYGONS
AND
LET
BE
THE
NUMBER
OF
VERTICES
OF
AND
THE
NUMBER
OF
VERTICES
OF
BOTH
AND
MUST
BE
SMALLER
THAN
N
SO
BY
INDUCTION
AND
CAN
V
BE
TRIANGULATED
HENCE
P
CAN
BE
TRIANGULATED
AS
WELL
IT
REMAINS
TO
PROVE
THAT
ANY
TRIANGULATION
OF
P
CONSISTS
OF
N
TRIANGLES
TO
THIS
END
CONSIDER
AN
ARBITRARY
DIAGONAL
IN
SOME
TRIANGULATION
TP
THIS
DIAGONAL
CUTS
P
INTO
TWO
SUBPOLYGONS
WITH
AND
VERTICES
RESPECTIVELY
EVERY
VERTEX
OF
P
OCCURS
IN
EXACTLY
ONE
OF
THE
TWO
SUBPOLYGONS
EXCEPT
FOR
THE
VERTICES
DEFINING
THE
DIAGONAL
WHICH
OCCUR
IN
BOTH
SUBPOLYGONS
HENCE
N
BY
INDUCTION
ANY
TRIANGULATION
OF
PI
CONSISTS
OF
MI
TRIANGLES
WHICH
IMPLIES
THAT
TP
CONSISTS
OF
N
TRIANGLES
THEOREM
IMPLIES
THAT
ANY
SIMPLE
POLYGON
WITH
N
VERTICES
CAN
BE
GUARDED
WITH
N
CAMERAS
BUT
PLACING
A
CAMERA
INSIDE
EVERY
TRIANGLE
SEEMS
OVERKILL
A
CAMERA
PLACED
ON
A
DIAGONAL
FOR
EXAMPLE
WILL
GUARD
TWO
TRIANGLES
SO
BY
PLACING
THE
CAMERAS
ON
WELL
CHOSEN
DIAGONALS
WE
MIGHT
BE
ABLE
TO
REDUCE
THE
NUMBER
OF
CAMERAS
TO
ROUGHLY
N
PLACING
CAMERAS
AT
VERTICES
SEEMS
EVEN
BETTER
BECAUSE
A
VERTEX
CAN
BE
INCIDENT
TO
MANY
TRIANGLES
AND
A
CAMERA
AT
THAT
VERTEX
GUARDS
ALL
OF
THEM
THIS
SUGGESTS
THE
FOLLOWING
APPROACH
LET
TP
BE
A
TRIANGULATION
OF
P
SELECT
A
SUBSET
OF
THE
VERTICES
OF
P
SUCH
THAT
ANY
TRIANGLE
IN
TP
HAS
AT
LEAST
ONE
SELECTED
VERTEX
AND
PLACE
THE
CAMERAS
AT
THE
SELECTED
VERTICES
TO
FIND
SUCH
A
SUBSET
WE
ASSIGN
EACH
VERTEX
OF
P
A
COLOR
WHITE
GRAY
OR
BLACK
THE
COLORING
WILL
BE
SUCH
THAT
ANY
TWO
VERTICES
CONNECTED
BY
AN
EDGE
OR
A
DIAGONAL
HAVE
DIFFERENT
COLORS
THIS
IS
CALLED
A
COLORING
OF
A
TRIANGULATED
POLYGON
IN
A
COLORING
OF
A
TRIANGULATED
POLYGON
EVERY
TRIANGLE
HAS
A
WHITE
A
GRAY
AND
A
BLACK
VERTEX
HENCE
IF
WE
PLACE
CAMERAS
AT
ALL
GRAY
VERTICES
SAY
WE
HAVE
GUARDED
THE
WHOLE
POLYGON
BY
CHOOSING
THE
SMALLEST
COLOR
CLASS
TO
PLACE
THE
CAMERAS
WE
CAN
GUARD
P
USING
AT
MOST
N
CAMERAS
BUT
DOES
A
COLORING
ALWAYS
EXIST
THE
ANSWER
IS
YES
TO
SEE
THIS
WE
LOOK
AT
WHAT
IS
CALLED
THE
DUAL
GRAPH
OF
TP
THIS
GRAPH
G
TP
HAS
A
NODE
FOR
EVERY
TRIANGLE
IN
TP
WE
DENOTE
THE
TRIANGLE
CORRESPONDING
TO
A
NODE

BY
T

THERE
IS
AN
ARC
BETWEEN
TWO
NODES

AND

IF
T

AND
T

SHARE
A
DIAGONAL
THE
ARCS
CHAPTER
POLYGON
TRIANGULATION
IN
G
TP
CORRESPOND
TO
DIAGONALS
IN
TP
BECAUSE
ANY
DIAGONAL
CUTS
P
INTO
TWO
THE
REMOVAL
OF
AN
EDGE
FROM
G
TP
SPLITS
THE
GRAPH
INTO
TWO
HENCE
G
TP
IS
A
TREE
NOTICE
THAT
THIS
IS
NOT
TRUE
FOR
A
POLYGON
WITH
HOLES
THIS
MEANS
THAT
WE
CAN
FIND
A
COLORING
USING
A
SIMPLE
GRAPH
TRAVERSAL
SUCH
AS
DEPTH
FIRST
SEARCH
NEXT
WE
DESCRIBE
HOW
TO
DO
THIS
WHILE
WE
DO
THE
DEPTH
FIRST
SEARCH
WE
MAINTAIN
THE
FOLLOWING
INVARIANT
ALL
VERTICES
OF
THE
ALREADY
ENCOUNTERED
TRIANGLES
HAVE
BEEN
COLORED
WHITE
GRAY
OR
BLACK
AND
NO
TWO
CONNECTED
VERTICES
HAVE
RECEIVED
THE
SAME
COLOR
THE
INVARIANT
IMPLIES
THAT
WE
HAVE
COMPUTED
A
VALID
COLORING
WHEN
ALL
TRIANGLES
HAVE
BEEN
ENCOUNTERED
THE
DEPTH
FIRST
SEARCH
CAN
BE
STARTED
FROM
ANY
NODE
OF
G
TP
THE
THREE
VERTICES
OF
THE
CORRESPONDING
TRIANGLE
ARE
COLORED
WHITE
GRAY
AND
BLACK
NOW
SUPPOSE
THAT
WE
REACH
A
NODE

IN
G
COMING
FROM
NODE

HENCE
T

AND
T

SHARE
A
DIAGONAL
SINCE
THE
VERTICES
OF
T

HAVE
ALREADY
BEEN
COLORED
ONLY
ONE
VERTEX
OF
T

REMAINS
TO
BE
COLORED
THERE
IS
ONE
COLOR
LEFT
FOR
THIS
VERTEX
NAMELY
THE
COLOR
THAT
IS
NOT
USED
FOR
THE
VERTICES
OF
THE
DIAGONAL
BETWEEN
T

AND
T

BECAUSE
G
TP
IS
A
TREE
THE
OTHER
NODES
ADJACENT
TO

HAVE
NOT
BEEN
VISITED
YET
AND
WE
STILL
HAVE
THE
FREEDOM
TO
GIVE
THE
VERTEX
THE
REMAINING
COLOR
WE
CONCLUDE
THAT
A
TRIANGULATED
SIMPLE
POLYGON
CAN
ALWAYS
BE
COLORED
AS
A
RESULT
ANY
SIMPLE
POLYGON
CAN
BE
GUARDED
WITH
N
CAMERAS
BUT
PERHAPS
WE
CAN
DO
EVEN
BETTER
AFTER
ALL
A
CAMERA
PLACED
AT
A
VERTEX
MAY
GUARD
MORE
THAN
JUST
THE
INCIDENT
TRIANGLES
UNFORTUNATELY
FOR
ANY
N
THERE
ARE
SIMPLE
POLYGONS
THAT
REQUIRE
N
CAMERAS
AN
EXAMPLE
IS
A
COMB
SHAPED
POLYGON
WITH
A
LONG
HORIZONTAL
BASE
EDGE
AND
N
PRONGS
MADE
OF
TWO
EDGES
EACH
THE
PRONGS
ARE
CONNECTED
BY
HORIZONTAL
EDGES
THE
CONSTRUCTION
CAN
BE
MADE
SUCH
THAT
THERE
IS
NO
POSITION
IN
THE
POLYGON
FROM
WHICH
A
CAMERA
CAN
LOOK
INTO
TWO
PRONGS
OF
THE
COMB
SIMULTANEOUSLY
SO
WE
CANNOT
HOPE
FOR
A
STRATEGY
THAT
ALWAYS
PRODUCES
LESS
THAN
N
CAMERAS
IN
OTHER
WORDS
THE
COLORING
APPROACH
IS
OPTIMAL
IN
THE
WORST
CASE
WE
JUST
PROVED
THE
ART
GALLERY
THEOREM
A
CLASSICAL
RESULT
FROM
COMBINATO
RIAL
GEOMETRY
THEOREM
ART
GALLERY
THEOREM
FOR
A
SIMPLE
POLYGON
WITH
N
VERTICES
N
CAMERAS
ARE
OCCASIONALLY
NECESSARY
AND
ALWAYS
SUFFICIENT
TO
HAVE
EVERY
POINT
IN
THE
POLYGON
VISIBLE
FROM
AT
LEAST
ONE
OF
THE
CAMERAS
NOW
WE
KNOW
THAT
N
CAMERAS
ARE
ALWAYS
SUFFICIENT
BUT
WE
DON
T
HAVE
AN
EFFICIENT
ALGORITHM
TO
COMPUTE
THE
CAMERA
POSITIONS
YET
WHAT
WE
NEED
IS
A
FAST
ALGORITHM
FOR
TRIANGULATING
A
SIMPLE
POLYGON
THE
ALGORITHM
SHOULD
DELIVER
A
SUITABLE
REPRESENTATION
OF
THE
TRIANGULATION
A
DOUBLY
CONNECTED
EDGE
LIST
FOR
INSTANCE
SO
THAT
WE
CAN
STEP
IN
CONSTANT
TIME
FROM
A
TRIANGLE
TO
ITS
NEIGHBORS
GIVEN
SUCH
A
REPRESENTATION
WE
CAN
COMPUTE
A
SET
OF
AT
MOST
N
CAMERA
POSITIONS
IN
LINEAR
TIME
WITH
THE
METHOD
DESCRIBED
ABOVE
USE
DEPTH
FIRST
SEARCH
ON
THE
DUAL
GRAPH
TO
COMPUTE
A
COLORING
AND
TAKE
THE
SMALLEST
COLOR
CLASS
TO
PLACE
THE
CAMERAS
IN
THE
COMING
SECTIONS
WE
DESCRIBE
HOW
TO
COMPUTE
A
TRIANGULATION
IN
O
N
LOG
N
TIME
ANTICIPATING
THIS
WE
ALREADY
STATE
THE
FINAL
RESULT
ABOUT
GUARDING
A
POLYGON
THEOREM
LET
P
BE
A
SIMPLE
POLYGON
WITH
N
VERTICES
A
SET
OF
N
CAMERA
POSITIONS
IN
P
SUCH
THAT
ANY
POINT
INSIDE
P
IS
VISIBLE
FROM
AT
LEAST
ONE
OF
THE
CAMERAS
CAN
BE
COMPUTED
IN
O
N
LOG
N
TIME
PARTITIONING
A
POLYGON
INTO
MONOTONE
PIECES
LET
P
BE
A
SIMPLE
POLYGON
WITH
N
VERTICES
WE
SAW
IN
THEOREM
THAT
A
TRIANGULATION
OF
P
ALWAYS
EXISTS
THE
PROOF
OF
THAT
THEOREM
IS
CONSTRUCTIVE
AND
LEADS
TO
A
RECURSIVE
TRIANGULATION
ALGORITHM
FIND
A
DIAGONAL
AND
TRIANGULATE
THE
TWO
RESULTING
SUBPOLYGONS
RECURSIVELY
TO
FIND
THE
DIAGONAL
WE
TAKE
THE
LEFTMOST
VERTEX
OF
P
AND
TRY
TO
CONNECT
ITS
TWO
NEIGHBORS
U
AND
W
IF
THIS
FAILS
WE
CONNECT
V
TO
THE
VERTEX
FARTHEST
FROM
UW
INSIDE
THE
TRIANGLE
DEFINED
BY
U
V
AND
W
THIS
WAY
IT
TAKES
LINEAR
TIME
TO
FIND
A
DIAGONAL
THIS
DIAGONAL
MAY
SPLIT
P
INTO
A
TRIANGLE
AND
A
POLYGON
WITH
N
VERTICES
INDEED
IF
WE
SUCCEED
TO
CONNECT
U
AND
W
THIS
WILL
ALWAYS
BE
THE
CASE
AS
A
CONSEQUENCE
THE
TRIANGULATION
ALGORITHM
WILL
TAKE
QUADRATIC
TIME
IN
THE
WORST
CASE
CAN
WE
DO
BETTER
FOR
SOME
CLASSES
OF
POLYGONS
WE
SURELY
CAN
CONVEX
POLYGONS
FOR
INSTANCE
ARE
EASY
PICK
ONE
VERTEX
OF
THE
POLYGON
AND
DRAW
DIAGONALS
FROM
THIS
VERTEX
TO
ALL
OTHER
VERTICES
EXCEPT
ITS
NEIGHBORS
THIS
TAKES
ONLY
LINEAR
TIME
SO
A
POSSIBLE
APPROACH
TO
TRIANGULATE
A
NON
CONVEX
POLYGON
WOULD
BE
TO
FIRST
DECOMPOSE
P
INTO
CONVEX
PIECES
AND
THEN
TRIANGULATE
THE
PIECES
UNFORTUNATELY
IT
IS
AS
DIFFICULT
TO
PARTITION
A
POLYGON
INTO
CONVEX
PIECES
AS
IT
IS
TO
TRIANGULATE
IT
THEREFORE
WE
SHALL
DECOMPOSE
P
INTO
SO
CALLED
MONOTONE
PIECES
WHICH
TURNS
OUT
TO
BE
A
LOT
EASIER
A
SIMPLE
POLYGON
IS
CALLED
MONOTONE
WITH
RESPECT
TO
A
LINE
F
IF
FOR
ANY
LINE
FI
PERPENDICULAR
TO
F
THE
INTERSECTION
OF
THE
POLYGON
WITH
FI
IS
CONNECTED
IN
OTHER
WORDS
THE
INTERSECTION
SHOULD
BE
A
LINE
SEGMENT
A
POINT
OR
EMPTY
A
POLYGON
THAT
IS
MONOTONE
WITH
RESPECT
TO
THE
Y
AXIS
IS
CALLED
Y
MONOTONE
THE
FOLLOWING
PROPERTY
IS
CHARACTERISTIC
FOR
Y
MONOTONE
POLYGONS
IF
WE
WALK
FROM
A
TOPMOST
TO
A
BOTTOMMOST
VERTEX
ALONG
THE
LEFT
OR
THE
RIGHT
BOUNDARY
CHAIN
THEN
WE
ALWAYS
MOVE
DOWNWARDS
OR
HORIZONTALLY
NEVER
UPWARDS
SECTION
PARTITIONING
A
POLYGON
INTO
MONOTONE
PIECES
OUR
STRATEGY
TO
TRIANGULATE
THE
POLYGON
P
IS
TO
FIRST
PARTITION
P
INTO
Y
MONOTONE
PIECES
AND
THEN
TRIANGULATE
THE
PIECES
WE
CAN
PARTITION
A
POLYGON
INTO
MONO
TONE
PIECES
AS
FOLLOWS
IMAGINE
WALKING
FROM
THE
TOPMOST
VERTEX
OF
P
TO
THE
BOTTOMMOST
VERTEX
ON
THE
LEFT
OR
RIGHT
BOUNDARY
CHAIN
A
VERTEX
WHERE
THE
DIRECTION
IN
WHICH
WE
WALK
SWITCHES
FROM
DOWNWARD
TO
UPWARD
OR
FROM
UPWARD
TO
DOWNWARD
IS
CALLED
A
TURN
VERTEX
TO
PARTITION
P
INTO
Y
MONOTONE
PIECES
WE
SHOULD
GET
RID
OF
THESE
TURN
VERTICES
THIS
CAN
BE
DONE
BY
ADDING
DIAGONALS
IF
AT
A
TURN
VERTEX
V
BOTH
INCIDENT
EDGES
GO
DOWN
AND
THE
INTERIOR
OF
THE
POLYGON
LOCALLY
LIES
ABOVE
V
THEN
WE
MUST
CHOOSE
A
DIAGONAL
THAT
GOES
UP
FROM
V
THE
DIAGONAL
SPLITS
THE
POLYGON
INTO
TWO
THE
VERTEX
V
WILL
APPEAR
IN
BOTH
PIECES
MOREOVER
IN
BOTH
PIECES
V
HAS
AN
EDGE
GOING
DOWN
NAMELY
ON
ORIGINAL
EDGE
OF
P
AND
AN
EDGE
GOING
UP
THE
DIAGONAL
HENCE
V
CANNOT
BE
A
TURN
VERTEX
ANYMORE
IN
EITHER
OF
THEM
IF
BOTH
INCIDENT
EDGES
OF
A
TURN
VERTEX
GO
UP
AND
CHAPTER
POLYGON
TRIANGULATION
THE
INTERIOR
LOCALLY
LIES
BELOW
IT
WE
HAVE
TO
CHOOSE
A
DIAGONAL
THAT
GOES
DOWN
APPARENTLY
THERE
ARE
DIFFERENT
TYPES
OF
TURN
VERTICES
LET
MAKE
THIS
MORE
PRECISE
IF
WE
WANT
TO
DEFINE
THE
DIFFERENT
TYPES
OF
TURN
VERTICES
CAREFULLY
WE
SHOULD
PAY
SPECIAL
ATTENTION
TO
VERTICES
WITH
EQUAL
Y
COORDINATE
WE
DO
THIS
BY
DEFINING
THE
NOTIONS
OF
BELOW
AND
ABOVE
AS
FOLLOWS
A
POINT
P
IS
BELOW
ANOTHER
POINT
Q
IF
PY
QY
OR
PY
QY
AND
PX
QX
AND
P
IS
ABOVE
Q
IF
PY
QY
OR
PY
QY
AND
PX
QX
YOU
CAN
IMAGINE
ROTATING
THE
PLANE
SLIGHTLY
IN
CLOCKWISE
DIRECTION
WITH
RESPECT
TO
THE
COORDINATE
SYSTEM
SUCH
THAT
NO
TWO
POINTS
HAVE
THE
SAME
Y
COORDINATE
THE
ABOVE
BELOW
RELATION
WE
JUST
DEFINED
IS
THE
SAME
AS
THE
ABOVE
BELOW
RELATION
IN
THIS
SLIGHTLY
ROTATED
PLANE
START
VERTEX
END
VERTEX
FIGURE
REGULAR
VERTEX
SPLIT
VERTEX
MERGE
VERTEX
FIVE
TYPES
OF
VERTICES
WE
DISTINGUISH
FIVE
TYPES
OF
VERTICES
IN
P
SEE
FIGURE
FOUR
OF
THESE
TYPES
ARE
TURN
VERTICES
START
VERTICES
SPLIT
VERTICES
END
VERTICES
AND
MERGE
VERTICES
THEY
ARE
DEFINED
AS
FOLLOWS
A
VERTEX
V
IS
A
START
VERTEX
IF
ITS
TWO
NEIGHBORS
LIE
BELOW
IT
AND
THE
INTERIOR
ANGLE
AT
V
IS
LESS
THAN

IF
THE
INTERIOR
ANGLE
IS
GREATER
THAN

THEN
V
IS
A
SPLIT
VERTEX
IF
BOTH
NEIGHBORS
LIE
BELOW
V
THEN
THE
INTERIOR
ANGLE
CANNOT
BE
EXACTLY

A
VERTEX
IS
AN
END
VERTEX
IF
ITS
TWO
NEIGHBORS
LIE
ABOVE
IT
AND
THE
INTERIOR
ANGLE
AT
V
IS
LESS
THAN

IF
THE
INTERIOR
ANGLE
IS
GREATER
THAN

THEN
V
IS
A
MERGE
VERTEX
THE
VERTICES
THAT
ARE
NOT
TURN
VERTICES
ARE
REGULAR
VERTICES
THUS
A
REGULAR
VERTEX
HAS
ONE
OF
ITS
NEIGHBORS
ABOVE
IT
AND
THE
OTHER
NEIGHBOR
BELOW
IT
THESE
NAMES
HAVE
BEEN
CHOSEN
BECAUSE
THE
ALGORITHM
WILL
USE
A
DOWNWARD
PLANE
SWEEP
MAINTAINING
THE
INTERSECTION
OF
THE
SWEEP
LINE
WITH
THE
POLYGON
WHEN
THE
SWEEP
LINE
REACHES
A
SPLIT
VERTEX
A
COMPONENT
OF
THE
INTERSECTION
SPLITS
WHEN
IT
REACHES
A
MERGE
VERTEX
TWO
COMPONENTS
MERGE
AND
SO
ON
THE
SPLIT
AND
MERGE
VERTICES
ARE
SOURCES
OF
LOCAL
NON
MONOTONICITY
THE
FOLLOWING
STRONGER
STATEMENT
IS
EVEN
TRUE
LEMMA
A
POLYGON
IS
Y
MONOTONE
IF
IT
HAS
NO
SPLIT
VERTICES
OR
MERGE
VERTICES
PROOF
SUPPOSE
P
IS
NOT
Y
MONOTONE
WE
HAVE
TO
PROVE
THAT
P
CONTAINS
A
SPLIT
OR
A
MERGE
VERTEX
SINCE
P
IS
NOT
MONOTONE
THERE
IS
A
HORIZONTAL
LINE
F
THAT
INTERSECTS
P
IN
MORE
THAN
ONE
CONNECTED
COMPONENT
WE
CAN
CHOOSE
F
SUCH
THAT
THE
LEFTMOST
COMPONENT
IS
A
SEGMENT
NOT
A
SINGLE
POINT
LET
P
BE
THE
LEFT
ENDPOINT
OF
THIS
SEGMENT
AND
LET
Q
BE
THE
RIGHT
ENDPOINT
STARTING
AT
Q
WE
FOLLOW
THE
BOUNDARY
OF
P
SUCH
THAT
P
LIES
TO
THE
LEFT
OF
THE
BOUNDARY
THIS
MEANS
THAT
WE
GO
UP
FROM
Q
AT
SOME
POINT
LET
CALL
IT
R
THE
BOUNDARY
WILL
INTERSECT
F
AGAIN
IF
R
P
AS
IN
FIGURE
A
THEN
THE
HIGHEST
VERTEX
WE
ENCOUNTERED
WHILE
GOING
FROM
Q
TO
R
MUST
BE
A
SPLIT
VERTEX
AND
WE
ARE
DONE
SECTION
PARTITIONING
A
POLYGON
INTO
MONOTONE
PIECES
B
PP
P
R
Q
RI
F
MERGE
VERTEX
FIGURE
TWO
CASES
IN
THE
PROOF
OF
LEMMA
IF
R
P
AS
IN
FIGURE
B
WE
AGAIN
FOLLOW
THE
BOUNDARY
OF
P
STARTING
AT
Q
BUT
THIS
TIME
IN
THE
OTHER
DIRECTION
AS
BEFORE
THE
BOUNDARY
WILL
INTERSECT
F
LET
RI
BE
THE
POINT
WHERE
THIS
HAPPENS
WE
CANNOT
HAVE
RI
P
BECAUSE
THAT
WOULD
MEAN
THAT
THE
BOUNDARY
OF
P
INTERSECTS
F
ONLY
TWICE
CONTRADICTING
THAT
F
INTERSECTS
P
IN
MORE
THAN
ONE
COMPONENT
SO
WE
HAVE
RI
P
IMPLYING
THAT
THE
LOWEST
VERTEX
WE
HAVE
ENCOUNTERED
WHILE
GOING
FROM
Q
TO
RI
MUST
BE
A
MERGE
VERTEX
LEMMA
IMPLIES
THAT
P
HAS
BEEN
PARTITIONED
INTO
Y
MONOTONE
PIECES
ONCE
WE
GET
RID
OF
ITS
SPLIT
AND
MERGE
VERTICES
WE
DO
THIS
BY
ADDING
A
DIAGONAL
GOING
UPWARD
FROM
EACH
SPLIT
VERTEX
AND
A
DIAGONAL
GOING
DOWNWARD
FROM
EACH
MERGE
VERTEX
THESE
DIAGONALS
SHOULD
NOT
INTERSECT
EACH
OTHER
OF
COURSE
ONCE
WE
HAVE
DONE
THIS
P
HAS
BEEN
PARTITIONED
INTO
Y
MONOTONE
PIECES
LET
FIRST
SEE
HOW
WE
CAN
ADD
THE
DIAGONALS
FOR
THE
SPLIT
VERTICES
WE
USE
A
PLANE
SWEEP
METHOD
FOR
THIS
LET
VN
BE
A
COUNTERCLOCKWISE
ENUMERATION
OF
THE
VERTICES
OF
P
LET
EN
BE
THE
SET
OF
EDGES
OF
P
WHERE
EI
VIVI
FOR
I
N
AND
EN
THE
PLANE
SWEEP
ALGORITHM
MOVES
AN
IMAGINARY
SWEEP
LINE
F
DOWNWARD
OVER
THE
PLANE
THE
SWEEP
LINE
HALTS
AT
CERTAIN
EVENT
POINTS
IN
OUR
CASE
THESE
WILL
BE
THE
VERTICES
OF
P
NO
NEW
EVENT
POINTS
WILL
BE
CREATED
DURING
THE
SWEEP
THE
EVENT
POINTS
ARE
STORED
IN
A
EVENT
QUEUE
Q
THE
EVENT
QUEUE
IS
A
PRIORITY
QUEUE
WHERE
THE
PRIORITY
OF
A
VERTEX
IS
ITS
Y
COORDINATE
IF
TWO
VERTICES
HAVE
THE
SAME
Y
COORDINATE
THEN
THE
LEFTMOST
ONE
HAS
HIGHER
PRIORITY
THIS
WAY
THE
NEXT
EVENT
TO
BE
HANDLED
CAN
BE
FOUND
IN
O
LOG
N
TIME
BECAUSE
NO
NEW
EVENTS
ARE
GENERATED
DURING
THE
SWEEP
WE
COULD
ALSO
SORT
THE
VERTICES
ON
Y
COORDINATE
BEFORE
THE
SWEEP
AND
THEN
USE
THE
SORTED
LIST
TO
FIND
THE
NEXT
EVENT
IN
O
TIME
CHAPTER
POLYGON
TRIANGULATION
VI
EK
E
J
VM
DIAGONAL
WILL
BE
ADDED
WHEN
THE
SWEEP
LINE
REACHES
VM
THE
GOAL
OF
THE
SWEEP
IS
TO
ADD
DIAGONALS
FROM
EACH
SPLIT
VERTEX
TO
A
VERTEX
LYING
ABOVE
IT
SUPPOSE
THAT
THE
SWEEP
LINE
REACHES
A
SPLIT
VERTEX
VI
TO
WHICH
VERTEX
SHOULD
WE
CONNECT
VI
A
GOOD
CANDIDATE
IS
A
VERTEX
CLOSE
TO
VI
BECAUSE
WE
CAN
PROBABLY
CONNECT
VI
TO
THIS
VERTEX
WITHOUT
INTERSECTING
ANY
EDGE
OF
P
LET
MAKE
THIS
MORE
PRECISE
LET
EJ
BE
THE
EDGE
IMMEDIATELY
TO
THE
LEFT
OF
VI
ON
THE
SWEEP
LINE
AND
LET
EK
BE
THE
EDGE
IMMEDIATELY
TO
THE
RIGHT
OF
VI
ON
THE
SWEEP
LINE
THEN
WE
CAN
ALWAYS
CONNECT
VI
TO
THE
LOWEST
VERTEX
IN
BETWEEN
EJ
AND
EK
AND
ABOVE
VI
IF
THERE
IS
NO
SUCH
VERTEX
THEN
WE
CAN
CONNECT
VI
TO
THE
UPPER
ENDPOINT
OF
EJ
OR
TO
THE
UPPER
ENDPOINT
OF
EK
WE
CALL
THIS
VERTEX
THE
HELPER
OF
EJ
AND
DENOTE
IT
BY
HELPER
EJ
FORMALLY
HELPER
EJ
IS
DEFINED
AS
THE
LOWEST
VERTEX
ABOVE
THE
SWEEP
LINE
SUCH
THAT
THE
HORIZONTAL
SEGMENT
CONNECTING
THE
VERTEX
TO
EJ
LIES
INSIDE
P
NOTE
THAT
HELPER
EJ
CAN
BE
THE
UPPER
ENDPOINT
OF
EJ
ITSELF
NOW
WE
KNOW
HOW
TO
GET
RID
OF
SPLIT
VERTICES
CONNECT
THEM
TO
THE
HELPER
OF
THE
EDGE
TO
THEIR
LEFT
WHAT
ABOUT
MERGE
VERTICES
THEY
SEEM
MORE
DIFFICULT
TO
GET
RID
OF
BECAUSE
THEY
NEED
A
DIAGONAL
TO
A
VERTEX
THAT
IS
LOWER
THAN
THEY
ARE
SINCE
THE
PART
OF
P
BELOW
THE
SWEEP
LINE
HAS
NOT
BEEN
EXPLORED
YET
WE
CANNOT
ADD
SUCH
A
DIAGONAL
WHEN
WE
ENCOUNTER
A
MERGE
VERTEX
FORTUNATELY
THIS
PROBLEM
IS
EASIER
THAN
IT
SEEMS
AT
FIRST
SIGHT
SUPPOSE
THE
SWEEP
LINE
REACHES
A
MERGE
VERTEX
VI
LET
EJ
AND
EK
BE
THE
EDGES
IMMEDIATELY
TO
THE
RIGHT
AND
TO
THE
LEFT
OF
VI
ON
THE
SWEEP
LINE
RESPECTIVELY
OBSERVE
THAT
VI
BECOMES
THE
NEW
HELPER
OF
EJ
WHEN
WE
REACH
IT
WE
WOULD
LIKE
TO
CONNECT
VI
TO
THE
HIGHEST
VERTEX
BELOW
THE
SWEEP
LINE
IN
BETWEEN
EJ
AND
EK
THIS
IS
EXACTLY
THE
OPPOSITE
OF
WHAT
WE
DID
FOR
SPLIT
VERTICES
WHICH
WE
CONNECTED
TO
THE
LOWEST
VERTEX
ABOVE
THE
SWEEP
LINE
IN
BETWEEN
EJ
AND
EK
THIS
IS
NOT
SURPRISING
MERGE
VERTICES
ARE
SPLIT
VERTICES
UPSIDE
DOWN
OF
COURSE
WE
DON
T
KNOW
THE
HIGHEST
VERTEX
BELOW
THE
SWEEP
LINE
WHEN
WE
REACH
VI
BUT
IT
IS
EASY
TO
FIND
LATER
ON
WHEN
WE
REACH
A
VERTEX
VM
THAT
REPLACES
VI
AS
THE
HELPER
OF
EJ
THEN
THIS
IS
THE
VERTEX
WE
ARE
LOOKING
FOR
SO
WHENEVER
WE
REPLACE
THE
HELPER
OF
SOME
EDGE
WE
CHECK
WHETHER
THE
OLD
HELPER
IS
A
MERGE
VERTEX
AND
IF
SO
WE
ADD
THE
DIAGONAL
BETWEEN
THE
OLD
HELPER
AND
THE
NEW
ONE
THIS
DIAGONAL
IS
ALWAYS
ADDED
WHEN
THE
NEW
HELPER
IS
A
SPLIT
VERTEX
TO
GET
RID
OF
THE
SPLIT
VERTEX
IF
THE
OLD
HELPER
WAS
A
MERGE
VERTEX
WE
THUS
GET
RID
OF
A
SPLIT
VERTEX
AND
A
MERGE
VERTEX
WITH
THE
SAME
DIAGONAL
IT
CAN
ALSO
HAPPEN
THAT
THE
HELPER
OF
EJ
IS
NOT
REPLACED
ANYMORE
BELOW
VI
IN
THIS
CASE
WE
CAN
CONNECT
VI
TO
THE
LOWER
ENDPOINT
OF
EJ
IN
THE
APPROACH
ABOVE
WE
NEED
TO
FIND
THE
EDGE
TO
THE
LEFT
OF
EACH
VERTEX
THEREFORE
WE
STORE
THE
EDGES
OF
P
INTERSECTING
THE
SWEEP
LINE
IN
THE
LEAVES
OF
A
DYNAMIC
BINARY
SEARCH
TREE
T
THE
LEFT
TO
RIGHT
ORDER
OF
THE
LEAVES
OF
T
CORRESPONDS
TO
THE
LEFT
TO
RIGHT
ORDER
OF
THE
EDGES
BECAUSE
WE
ARE
ONLY
INTERESTED
IN
EDGES
TO
THE
LEFT
OF
SPLIT
AND
MERGE
VERTICES
WE
ONLY
NEED
TO
STORE
EDGES
IN
T
THAT
HAVE
THE
INTERIOR
OF
P
TO
THEIR
RIGHT
WITH
EACH
EDGE
IN
T
WE
STORE
ITS
HELPER
THE
TREE
T
AND
THE
HELPERS
STORED
WITH
THE
EDGES
FORM
THE
STATUS
OF
THE
SWEEP
LINE
ALGORITHM
THE
STATUS
CHANGES
AS
THE
SWEEP
LINE
MOVES
EDGES
START
OR
STOP
INTERSECTING
THE
SWEEP
LINE
AND
THE
HELPER
OF
AN
EDGE
MAY
BE
REPLACED
THE
ALGORITHM
PARTITIONS
P
INTO
SUBPOLYGONS
THAT
HAVE
TO
BE
PROCESSED
FURTHER
IN
A
LATER
STAGE
TO
HAVE
EASY
ACCESS
TO
THESE
SUBPOLYGONS
WE
SHALL
STORE
THE
SUBDIVISION
INDUCED
BY
P
AND
THE
ADDED
DIAGONALS
IN
A
DOUBLY
CONNECTED
EDGE
LIST
D
WE
ASSUME
THAT
P
IS
INITIALLY
SPECIFIED
AS
A
DOUBLY
CONNECTED
EDGE
LIST
IF
P
IS
GIVEN
IN
ANOTHER
FORM
BY
A
COUNTERCLOCKWISE
LIST
OF
ITS
VERTICES
FOR
EXAMPLE
WE
FIRST
CONSTRUCT
A
DOUBLY
CONNECTED
EDGE
LIST
FOR
P
THE
DIAGONALS
COMPUTED
FOR
THE
SPLIT
AND
MERGE
VERTICES
ARE
ADDED
TO
THE
DOUBLY
CONNECTED
EDGE
LIST
TO
ACCESS
THE
DOUBLY
CONNECTED
EDGE
LIST
WE
USE
CROSS
POINTERS
BETWEEN
THE
EDGES
IN
THE
STATUS
STRUCTURE
AND
THE
CORRESPONDING
EDGES
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
ADDING
A
DIAGONAL
CAN
THEN
BE
DONE
IN
CONSTANT
TIME
WITH
SOME
SIMPLE
POINTER
MANIPULATIONS
THE
GLOBAL
ALGORITHM
IS
NOW
AS
FOLLOWS
ALGORITHM
MAKEMONOTONE
P
INPUT
A
SIMPLE
POLYGON
P
STORED
IN
A
DOUBLY
CONNECTED
EDGE
LIST
D
OUTPUT
A
PARTITIONING
OF
P
INTO
MONOTONE
SUBPOLYGONS
STORED
IN
D
CONSTRUCT
A
PRIORITY
QUEUE
Q
ON
THE
VERTICES
OF
P
USING
THEIR
Y
COORDINATES
AS
PRIORITY
IF
TWO
POINTS
HAVE
THE
SAME
Y
COORDINATE
THE
ONE
WITH
SMALLER
X
COORDINATE
HAS
HIGHER
PRIORITY
INITIALIZE
AN
EMPTY
BINARY
SEARCH
TREE
T
WHILE
Q
IS
NOT
EMPTY
DO
REMOVE
THE
VERTEX
VI
WITH
THE
HIGHEST
PRIORITY
FROM
Q
CALL
THE
APPROPRIATE
PROCEDURE
TO
HANDLE
THE
VERTEX
DEPENDING
ON
ITS
TYPE
WE
NEXT
DESCRIBE
MORE
PRECISELY
HOW
TO
HANDLE
THE
EVENT
POINTS
YOU
SHOULD
FIRST
READ
THESE
ALGORITHMS
WITHOUT
THINKING
ABOUT
DEGENERATE
CASES
AND
CHECK
ONLY
LATER
THAT
THEY
ARE
ALSO
CORRECT
IN
DEGENERATE
CASES
TO
THIS
END
YOU
SHOULD
GIVE
AN
APPROPRIATE
MEANING
TO
DIRECTLY
LEFT
OF
IN
LINE
OF
HANDLESPLITVERTEX
AND
LINE
OF
HANDLEMERGEVERTEX
THERE
ARE
ALWAYS
TWO
THINGS
WE
MUST
DO
WHEN
WE
HANDLE
A
VERTEX
FIRST
WE
MUST
CHECK
WHETHER
WE
HAVE
TO
ADD
A
DIAGONAL
THIS
IS
ALWAYS
THE
CASE
FOR
A
SPLIT
VERTEX
AND
ALSO
WHEN
WE
REPLACE
THE
HELPER
OF
AN
EDGE
AND
THE
PREVIOUS
HELPER
WAS
A
MERGE
VERTEX
SECOND
WE
MUST
UPDATE
THE
INFORMATION
IN
THE
STATUS
STRUCTURE
T
THE
PRECISE
ALGORITHMS
FOR
EACH
TYPE
OF
EVENT
ARE
GIVEN
BELOW
YOU
CAN
USE
THE
EXAMPLE
FIGURE
ON
THE
NEXT
PAGE
TO
SEE
WHAT
HAPPENS
IN
EACH
OF
THE
DIFFERENT
CASES
HANDLESTARTVERTEX
VI
INSERT
EI
IN
T
AND
SET
HELPER
EI
TO
VI
AT
THE
START
VERTEX
IN
THE
EXAMPLE
FIGURE
FOR
INSTANCE
WE
INSERT
INTO
THE
TREE
T
HANDLEENDVERTEX
VI
IF
HELPER
EI
IS
A
MERGE
VERTEX
THEN
INSERT
THE
DIAGONAL
CONNECTING
VI
TO
HELPER
EI
IN
D
DELETE
EI
FROM
T
IN
THE
RUNNING
EXAMPLE
WHEN
WE
REACH
END
VERTEX
THE
HELPER
OF
THE
EDGE
SECTION
PARTITIONING
A
POLYGON
INTO
MONOTONE
PIECES
IS
IS
NOT
A
MERGE
VERTEX
SO
WE
DON
T
NEED
TO
INSERT
A
DIAGONAL
CHAPTER
POLYGON
TRIANGULATION
HANDLESPLITVERTEX
VI
SEARCH
IN
T
TO
FIND
THE
EDGE
EJ
DIRECTLY
LEFT
OF
VI
INSERT
THE
DIAGONAL
CONNECTING
VI
TO
HELPER
EJ
IN
D
HELPER
EJ
VI
E3
INSERT
EI
IN
T
AND
SET
HELPER
EI
TO
VI
FOR
SPLIT
VERTEX
IN
OUR
EXAMPLE
IS
THE
EDGE
TO
THE
LEFT
ITS
HELPER
IS
SO
WE
ADD
A
DIAGONAL
FROM
TO
E
HANDLEMERGEVERTEX
VI
IF
HELPER
EI
IS
A
MERGE
VERTEX
THEN
INSERT
THE
DIAGONAL
CONNECTING
VI
TO
HELPER
EI
IN
D
DELETE
EI
FROM
T
SEARCH
IN
T
TO
FIND
THE
EDGE
EJ
DIRECTLY
LEFT
OF
VI
IF
HELPER
EJ
IS
A
MERGE
VERTEX
THEN
INSERT
THE
DIAGONAL
CONNECTING
VI
TO
HELPER
EJ
IN
D
HELPER
EJ
VI
FOR
THE
MERGE
VERTEX
IN
OUR
EXAMPLE
THE
HELPER
OF
EDGE
IS
A
MERGE
VERTEX
SO
WE
ADD
A
DIAGONAL
FROM
TO
THE
ONLY
ROUTINE
THAT
REMAINS
TO
BE
DESCRIBED
IS
THE
ONE
TO
HANDLE
A
REGULAR
VERTEX
THE
ACTIONS
WE
MUST
TAKE
AT
A
REGULAR
VERTEX
DEPEND
ON
WHETHER
P
LIES
LOCALLY
TO
ITS
LEFT
OR
TO
ITS
RIGHT
HANDLEREGULARVERTEX
VI
IF
THE
INTERIOR
OF
P
LIES
TO
THE
RIGHT
OF
VI
THEN
IF
HELPER
EI
IS
A
MERGE
VERTEX
THEN
INSERT
THE
DIAGONAL
CONNECTING
VI
TO
HELPER
EI
IN
D
DELETE
EI
FROM
T
INSERT
EI
IN
T
AND
SET
HELPER
EI
TO
VI
ELSE
SEARCH
IN
T
TO
FIND
THE
EDGE
EJ
DIRECTLY
LEFT
OF
VI
IF
HELPER
EJ
IS
A
MERGE
VERTEX
THEN
INSERT
THE
DIAGONAL
CONNECTING
VI
TO
HELPER
EJ
IN
D
HELPER
EJ
VI
FOR
INSTANCE
AT
THE
REGULAR
VERTEX
IN
OUR
EXAMPLE
WE
ADD
A
DIAGONAL
FROM
TO
IT
REMAINS
TO
PROVE
THAT
MAKEMONOTONE
CORRECTLY
PARTITIONS
P
INTO
MONOTONE
PIECES
LEMMA
ALGORITHM
MAKEMONOTONE
ADDS
A
SET
OF
NON
INTERSECTING
DIAG
ONALS
THAT
PARTITIONS
P
INTO
MONOTONE
SUBPOLYGONS
PROOF
IT
IS
EASY
TO
SEE
THAT
THE
PIECES
INTO
WHICH
P
IS
PARTITIONED
CONTAIN
NO
SPLIT
OR
MERGE
VERTICES
HENCE
THEY
ARE
MONOTONE
BY
LEMMA
IT
REMAINS
TO
PROVE
THAT
THE
ADDED
SEGMENTS
ARE
VALID
DIAGONALS
THAT
IS
THAT
THEY
DON
T
INTERSECT
THE
EDGES
OF
P
AND
THAT
THEY
DON
T
INTERSECT
EACH
OTHER
TO
THIS
END
WE
WILL
SHOW
THAT
WHEN
A
SEGMENT
IS
ADDED
IT
INTERSECTS
NEITHER
AN
EDGE
OF
P
NOR
ANY
OF
THE
PREVIOUSLY
ADDED
SEGMENTS
WE
SHALL
PROVE
THIS
FOR
THE
SEGMENT
ADDED
IN
HANDLESPLITVERTEX
THE
PROOF
FOR
THE
SEGMENTS
ADDED
INHANDLEENDVERTEX
HANDLEREGULARVERTEX
AND
HANDLEMERGE
VERTEX
IS
SIMILAR
WE
ASSUME
THAT
NO
TWO
VERTICES
HAVE
THE
SAME
Y
COORDINATE
THE
EXTENSION
TO
THE
GENERAL
CASE
IS
FAIRLY
STRAIGHTFORWARD
CONSIDER
A
SEGMENT
VMVI
THAT
IS
ADDED
BY
HANDLESPLITVERTEX
WHEN
VI
IS
REACHED
LET
EJ
BE
THE
EDGE
TO
THE
LEFT
OF
VI
AND
LET
EK
BE
THE
EDGE
TO
THE
RIGHT
OF
VI
THUS
HELPER
EJ
VM
WHEN
WE
REACH
VI
WE
FIRST
ARGUE
THAT
VMVI
DOES
NOT
INTERSECT
AN
EDGE
OF
P
TO
SEE
THIS
CONSIDER
THE
QUADRILATERAL
Q
BOUNDED
BY
THE
HORIZONTAL
LINES
THROUGH
VM
AND
VI
AND
BY
EJ
AND
EK
THERE
ARE
NO
VERTICES
OF
P
INSIDE
Q
OTHERWISE
VM
WOULD
NOT
BE
THE
HELPER
OF
EJ
NOW
SUPPOSE
THERE
WOULD
BE
AN
EDGE
OF
P
INTERSECTING
VMVI
SINCE
THE
EDGE
CANNOT
HAVE
AN
ENDPOINT
INSIDE
Q
AND
POLYGON
EDGES
DO
NOT
INTERSECT
EACH
OTHER
IT
WOULD
HAVE
TO
INTERSECT
THE
HORIZONTAL
SEGMENT
CONNECTING
VM
TO
EJ
OR
THE
HORIZONTAL
SEGMENT
CONNECTING
VI
TO
EJ
BOTH
ARE
IMPOSSIBLE
SINCE
FOR
BOTH
VM
AND
VI
THE
EDGE
EJ
LIES
IMMEDIATELY
TO
THE
LEFT
HENCE
NO
EDGE
OF
P
CAN
INTERSECT
VMVI
NOW
CONSIDER
A
PREVIOUSLY
ADDED
DIAGONAL
SINCE
THERE
ARE
NO
VERTICES
OF
P
INSIDE
Q
AND
ANY
PREVIOUSLY
ADDED
DIAGONAL
MUST
HAVE
BOTH
OF
ITS
ENDPOINTS
ABOVE
VI
IT
CANNOT
INTERSECT
VMVI
WE
NOW
ANALYZE
THE
RUNNING
TIME
OF
THE
ALGORITHM
CONSTRUCTING
THE
PRIORITY
QUEUE
Q
TAKES
LINEAR
TIME
AND
INITIALIZING
T
TAKES
CONSTANT
TIME
TO
HANDLE
AN
EVENT
DURING
THE
SWEEP
WE
PERFORM
ONE
OPERATION
ON
Q
AT
MOST
ONE
QUERY
ONE
INSERTION
AND
ONE
DELETION
ON
T
AND
WE
INSERT
AT
MOST
TWO
DIAGONALS
INTO
D
PRIORITY
QUEUES
AND
BALANCED
SEARCH
TREES
ALLOW
FOR
QUERIES
AND
UPDATES
IN
O
LOG
N
TIME
AND
THE
INSERTION
OF
A
DIAGONAL
INTO
D
TAKES
O
TIME
HENCE
HANDLING
AN
EVENT
TAKES
O
LOG
N
TIME
AND
THE
TOTAL
ALGORITHM
RUNS
IN
O
N
LOG
N
TIME
THE
AMOUNT
OF
STORAGE
USED
BY
THE
ALGORITHM
IS
CLEARLY
LINEAR
EVERY
VERTEX
IS
STORED
AT
MOST
ONCE
IN
Q
AND
EVERY
EDGE
IS
STORED
AT
MOST
ONCE
IN
T
TOGETHER
WITH
LEMMA
THIS
IMPLIES
THE
FOLLOWING
THEOREM
THEOREM
A
SIMPLE
POLYGON
WITH
N
VERTICES
CAN
BE
PARTITIONED
INTO
Y
MONOTONE
POLYGONS
IN
O
N
LOG
N
TIME
WITH
AN
ALGORITHM
THAT
USES
O
N
STORAGE
TRIANGULATING
A
MONOTONE
POLYGON
WE
HAVE
JUST
SEEN
HOW
TO
PARTITION
A
SIMPLE
POLYGON
INTO
Y
MONOTONE
PIECES
IN
O
N
LOG
N
TIME
IN
ITSELF
THIS
IS
NOT
VERY
INTERESTING
BUT
IN
THIS
SECTION
WE
SHOW
THAT
MONOTONE
POLYGONS
CAN
BE
TRIANGULATED
IN
LINEAR
TIME
TOGETHER
THESE
RESULTS
IMPLY
THAT
ANY
SIMPLE
POLYGON
CAN
BE
TRIANGULATED
IN
O
N
LOG
N
TIME
A
NICE
IMPROVEMENT
OVER
THE
QUADRATIC
TIME
ALGORITHM
THAT
WE
SKETCHED
AT
THE
BEGINNING
OF
THE
PREVIOUS
SECTION
SECTION
TRIANGULATING
A
MONOTONE
POLYGON
LET
P
BE
A
Y
MONOTONE
POLYGON
WITH
N
VERTICES
FOR
THE
MOMENT
WE
ASSUME
THAT
P
IS
STRICTLY
Y
MONOTONE
THAT
IS
WE
ASSUME
THAT
P
IS
Y
MONOTONE
AND
DOES
PUSHED
V
J
CHAPTER
POLYGON
TRIANGULATION
POPPED
E
POPPED
AND
PUSHED
NOT
CONTAIN
HORIZONTAL
EDGES
THUS
WE
ALWAYS
GO
DOWN
WHEN
WE
WALK
ON
THE
LEFT
OR
RIGHT
BOUNDARY
CHAIN
OF
P
FROM
THE
HIGHEST
VERTEX
OF
P
TO
THE
LOWEST
ONE
THIS
IS
THE
PROPERTY
THAT
MAKES
TRIANGULATING
A
MONOTONE
POLYGON
EASY
WE
CAN
WORK
OUR
WAY
THROUGH
P
FROM
TOP
TO
BOTTOM
ON
BOTH
CHAINS
ADDING
DIAGONALS
WHENEVER
THIS
IS
POSSIBLE
NEXT
WE
DESCRIBE
THE
DETAILS
OF
THIS
GREEDY
TRIANGULATION
ALGORITHM
THE
ALGORITHM
HANDLES
THE
VERTICES
IN
ORDER
OF
DECREASING
Y
COORDINATE
IF
TWO
VERTICES
HAVE
THE
SAME
Y
COORDINATE
THEN
THE
LEFTMOST
ONE
IS
HANDLED
FIRST
THE
ALGORITHM
REQUIRES
A
STACK
AS
AUXILIARY
DATA
STRUCTURE
INITIALLY
THE
STACK
IS
EMPTY
LATER
IT
CONTAINS
THE
VERTICES
OF
P
THAT
HAVE
BEEN
ENCOUNTERED
BUT
MAY
STILL
NEED
MORE
DIAGONALS
WHEN
WE
HANDLE
A
VERTEX
WE
ADD
AS
MANY
DIAGONALS
FROM
THIS
VERTEX
TO
VERTICES
ON
THE
STACK
AS
POSSIBLE
THESE
DIAGONALS
SPLIT
OFF
TRIANGLES
FROM
P
THE
VERTICES
THAT
HAVE
BEEN
HANDLED
BUT
NOT
SPLIT
OFF
THE
VERTICES
ON
THE
STACK
ARE
ON
THE
BOUNDARY
OF
THE
PART
OF
P
THAT
STILL
NEEDS
TO
BE
TRIANGULATED
THE
LOWEST
OF
THESE
VERTICES
WHICH
IS
THE
ONE
ENCOUNTERED
LAST
IS
ON
TOP
OF
THE
STACK
THE
SECOND
LOWEST
IS
SECOND
ON
THE
STACK
AND
SO
ON
THE
PART
OF
P
THAT
STILL
NEEDS
TO
BE
TRIANGULATED
AND
LIES
ABOVE
THE
LAST
VERTEX
THAT
HAS
BEEN
ENCOUNTERED
SO
FAR
HAS
A
PARTICULAR
SHAPE
IT
LOOKS
LIKE
A
FUNNEL
TURNED
UPSIDE
DOWN
ONE
BOUNDARY
OF
THE
FUNNEL
CONSISTS
OF
A
PART
OF
A
SINGLE
EDGE
OF
P
AND
THE
OTHER
BOUNDARY
IS
A
CHAIN
CONSISTING
OF
REFLEX
VERTICES
THAT
IS
THE
INTERIOR
ANGLE
AT
THESE
VERTICES
IS
AT
LEAST
ONLY
THE
HIGHEST
VERTEX
WHICH
IS
AT
THE
BOTTOM
OF
THE
STACK
IS
CONVEX
THIS
PROPERTY
REMAINS
TRUE
AFTER
WE
HAVE
HANDLED
THE
NEXT
VERTEX
HENCE
IT
IS
AN
INVARIANT
OF
THE
ALGORITHM
NOW
LET
SEE
WHICH
DIAGONALS
WE
CAN
ADD
WHEN
WE
HANDLE
THE
NEXT
VERTEX
WE
DISTINGUISH
TWO
CASES
V
J
THE
NEXT
VERTEX
TO
BE
HANDLED
LIES
ON
THE
SAME
CHAIN
AS
THE
REFLEX
VERTICES
ON
THE
STACK
OR
IT
LIES
ON
THE
OPPOSITE
CHAIN
IF
V
J
LIES
ON
THE
OPPOSITE
CHAIN
IT
MUST
BE
THE
LOWER
ENDPOINT
OF
THE
SINGLE
EDGE
E
BOUNDING
THE
FUNNEL
DUE
TO
THE
SHAPE
OF
THE
FUNNEL
WE
CAN
ADD
DIAGONALS
FROM
V
J
TO
ALL
VERTICES
CURRENTLY
ON
THE
STACK
EXCEPT
FOR
THE
LAST
ONE
THAT
IS
THE
ONE
AT
THE
BOTTOM
OF
THE
STACK
THE
LAST
VERTEX
ON
THE
STACK
IS
THE
UPPER
VERTEX
OF
E
SO
IT
IS
ALREADY
CONNECTED
TO
V
J
ALL
THESE
VERTICES
ARE
POPPED
FROM
THE
STACK
THE
UNTRIANGULATED
PART
OF
THE
POLYGON
ABOVE
V
J
IS
BOUNDED
BY
THE
DIAGONAL
THAT
CONNECTS
V
J
TO
THE
VERTEX
PREVIOUSLY
ON
TOP
OF
THE
STACK
AND
THE
EDGE
OF
P
EXTENDING
DOWNWARD
FROM
THIS
VERTEX
SO
IT
LOOKS
LIKE
A
FUNNEL
AND
THE
INVARIANT
IS
PRESERVED
THIS
VERTEX
AND
V
J
REMAIN
PART
OF
THE
NOT
YET
TRIANGULATED
POLYGON
SO
THEY
ARE
PUSHED
ONTO
THE
STACK
THE
OTHER
CASE
IS
WHEN
V
J
IS
ON
THE
SAME
CHAIN
AS
THE
REFLEX
VERTICES
ON
THE
STACK
THIS
TIME
WE
MAY
NOT
BE
ABLE
TO
DRAW
DIAGONALS
FROM
V
J
TO
ALL
VERTICES
ON
THE
STACK
NEVERTHELESS
THE
ONES
TO
WHICH
WE
CAN
CONNECT
V
J
ARE
ALL
CONSECUTIVE
AND
THEY
ARE
ON
TOP
OF
THE
STACK
SO
WE
CAN
PROCEED
AS
FOLLOWS
FIRST
POP
ONE
VERTEX
FROM
THE
STACK
THIS
VERTEX
IS
ALREADY
CONNECTED
TO
V
J
BY
AN
EDGE
OF
P
NEXT
POP
VERTICES
FROM
THE
STACK
AND
CONNECT
THEM
TO
V
J
UNTIL
WE
ENCOUNTER
ONE
WHERE
THIS
IS
NOT
POSSIBLE
CHECKING
WHETHER
A
DIAGONAL
CAN
BE
DRAWN
FROM
V
J
TO
A
VERTEX
VK
ON
THE
STACK
CAN
BE
DONE
BY
LOOKING
AT
V
J
VK
AND
THE
PREVIOUS
VERTEX
THAT
WAS
POPPED
WHEN
WE
FIND
A
VERTEX
TO
WHICH
WE
CANNOT
CONNECT
V
J
WE
PUSH
THE
LAST
VERTEX
THAT
HAS
BEEN
POPPED
BACK
ONTO
THE
STACK
THIS
IS
EITHER
THE
LAST
VERTEX
TO
WHICH
A
DIAGONAL
WAS
ADDED
OR
IF
NO
DIAGONALS
HAVE
BEEN
ADDED
IT
IS
THE
NEIGHBOR
OF
V
J
ON
THE
BOUNDARY
OF
P
SEE
FIGURE
AFTER
THIS
POPPED
AND
PUSHED
SECTION
TRIANGULATING
A
MONOTONE
POLYGON
POPPED
V
J
PUSHED
V
J
FIGURE
TWO
CASES
WHEN
THE
NEXT
VERTEX
IS
ON
THE
SAME
SIDE
AS
THE
REFLEX
VERTICES
ON
THE
STACK
HAS
BEEN
DONE
WE
PUSH
V
J
ONTO
THE
STACK
IN
BOTH
CASES
THE
INVARIANT
IS
RESTORED
ONE
SIDE
OF
THE
FUNNEL
IS
BOUNDED
BY
A
PART
OF
A
SINGLE
EDGE
AND
THE
OTHER
SIDE
IS
BOUNDED
BY
A
CHAIN
OF
REFLEX
VERTICES
WE
GET
THE
FOLLOWING
ALGORITHM
THE
ALGORITHM
IS
ACTUALLY
SIMILAR
TO
THE
CONVEX
HULL
ALGORITHM
OF
CHAPTER
ALGORITHM
TRIANGULATEMONOTONEPOLYGON
P
INPUT
A
STRICTLY
Y
MONOTONE
POLYGON
P
STORED
IN
A
DOUBLY
CONNECTED
EDGE
LIST
D
OUTPUT
A
TRIANGULATION
OF
P
STORED
IN
THE
DOUBLY
CONNECTED
EDGE
LIST
D
MERGE
THE
VERTICES
ON
THE
LEFT
CHAIN
AND
THE
VERTICES
ON
THE
RIGHT
CHAIN
OF
P
INTO
ONE
SEQUENCE
SORTED
ON
DECREASING
Y
COORDINATE
IF
TWO
VERTICES
HAVE
THE
SAME
Y
COORDINATE
THEN
THE
LEFTMOST
ONE
COMES
FIRST
LET
UN
DENOTE
THE
SORTED
SEQUENCE
INITIALIZE
AN
EMPTY
STACK
AND
PUSH
AND
ONTO
IT
FOR
J
TO
N
DO
IF
U
J
AND
THE
VERTEX
ON
TOP
OF
ARE
ON
DIFFERENT
CHAINS
THEN
POP
ALL
VERTICES
FROM
INSERT
INTO
D
A
DIAGONAL
FROM
U
J
TO
EACH
POPPED
VERTEX
EXCEPT
THE
LAST
ONE
PUSH
U
J
AND
U
J
ONTO
ELSE
POP
ONE
VERTEX
FROM
POP
THE
OTHER
VERTICES
FROM
AS
LONG
AS
THE
DIAGONALS
FROM
U
J
TO
THEM
ARE
INSIDE
P
INSERT
THESE
DIAGONALS
INTO
D
PUSH
THE
LAST
VERTEX
THAT
HAS
BEEN
POPPED
BACK
ONTO
PUSH
U
J
ONTO
ADD
DIAGONALS
FROM
UN
TO
ALL
STACK
VERTICES
EXCEPT
THE
FIRST
AND
THE
LAST
ONE
HOW
MUCH
TIME
DOES
THE
ALGORITHM
TAKE
STEP
TAKES
LINEAR
TIME
AND
STEP
TAKES
CONSTANT
TIME
THE
FOR
LOOP
IS
EXECUTED
N
TIMES
AND
ONE
EXECUTION
MAY
TAKE
LINEAR
TIME
BUT
AT
EVERY
EXECUTION
OF
THE
FOR
LOOP
AT
MOST
TWO
VERTICES
ARE
PUSHED
HENCE
THE
TOTAL
NUMBER
OF
PUSHES
INCLUDING
THE
TWO
IN
STEP
IS
BOUNDED
BY
BECAUSE
THE
NUMBER
OF
POPS
CANNOT
EXCEED
THE
NUMBER
OF
PUSHES
THE
TOTAL
TIME
FOR
ALL
EXECUTIONS
OF
THE
FOR
LOOP
IS
O
N
THE
LAST
STEP
OF
CHAPTER
POLYGON
TRIANGULATION
THE
ALGORITHM
ALSO
TAKES
AT
MOST
LINEAR
TIME
SO
THE
TOTAL
ALGORITHM
RUNS
IN
O
N
TIME
THEOREM
A
STRICTLY
Y
MONOTONE
POLYGON
WITH
N
VERTICES
CAN
BE
TRIANGULATED
IN
LINEAR
TIME
WE
WANTED
A
TRIANGULATION
ALGORITHM
FOR
MONOTONE
POLYGONS
AS
A
SUBROUTINE
FOR
TRIANGULATING
ARBITRARY
SIMPLE
POLYGONS
THE
IDEA
WAS
TO
FIRST
DECOMPOSE
A
POLYGON
INTO
MONOTONE
PIECES
AND
THEN
TO
TRIANGULATE
THESE
PIECES
IT
SEEMS
THAT
WE
HAVE
ALL
THE
INGREDIENTS
WE
NEED
THERE
IS
ONE
PROBLEM
HOWEVER
IN
THIS
SECTION
WE
HAVE
ASSUMED
THAT
THE
INPUT
IS
A
STRICTLY
Y
MONOTONE
POLYGON
WHEREAS
THE
ALGORITHM
OF
THE
PREVIOUS
SECTION
MAY
PRODUCE
MONOTONE
PIECES
WITH
HORIZONTAL
EDGES
RECALL
THAT
IN
THE
PREVIOUS
SECTION
WE
TREATED
VERTICES
WITH
THE
SAME
Y
COORDINATES
FROM
LEFT
TO
RIGHT
THIS
HAD
THE
SAME
EFFECT
AS
A
SLIGHT
ROTATION
OF
THE
PLANE
IN
CLOCKWISE
DIRECTION
SUCH
THAT
NO
TWO
VERTICES
ARE
ON
A
HORIZONTAL
LINE
IT
FOLLOWS
THAT
THE
MONOTONE
SUBPOLYGONS
PRODUCED
BY
THE
ALGORITHM
OF
THE
PREVIOUS
SECTION
ARE
STRICTLY
MONOTONE
IN
THIS
SLIGHTLY
ROTATED
PLANE
HENCE
THE
TRIANGULATION
ALGORITHM
OF
THE
CURRENT
SECTION
OPERATES
CORRECTLY
IF
WE
TREAT
VERTICES
WITH
THE
SAME
Y
COORDINATE
FROM
LEFT
TO
RIGHT
WHICH
CORRESPONDS
TO
WORKING
IN
THE
ROTATED
PLANE
SO
WE
CAN
COMBINE
THE
TWO
ALGORITHMS
TO
OBTAIN
A
TRIANGULATION
ALGORITHM
THAT
WORKS
FOR
ANY
SIMPLE
POLYGON
HOW
MUCH
TIME
DOES
THE
TRIANGULATION
ALGORITHM
TAKE
DECOMPOSING
THE
POLYGON
INTO
MONOTONE
PIECES
TAKES
O
N
LOG
N
TIME
BY
THEOREM
IN
THE
SECOND
STAGE
WE
TRIANGULATE
EACH
OF
THE
MONOTONE
PIECES
WITH
THE
LINEAR
TIME
ALGORITHM
OF
THIS
SECTION
SINCE
THE
SUM
OF
THE
NUMBER
OF
VERTICES
OF
THE
PIECES
IS
O
N
THE
SECOND
STAGE
TAKES
O
N
TIME
IN
TOTAL
WE
GET
THE
FOLLOWING
RESULT
THEOREM
A
SIMPLE
POLYGON
WITH
N
VERTICES
CAN
BE
TRIANGULATED
IN
O
N
LOG
N
TIME
WITH
AN
ALGORITHM
THAT
USES
O
N
STORAGE
WE
HAVE
SEEN
HOW
TO
TRIANGULATE
SIMPLE
POLYGONS
BUT
WHAT
ABOUT
POLYGONS
WITH
HOLES
CAN
THEY
ALSO
BE
TRIANGULATED
EASILY
THE
ANSWER
IS
YES
IN
FACT
THE
ALGORITHM
WE
HAVE
SEEN
ALSO
WORKS
FOR
POLYGONS
WITH
HOLES
NOWHERE
IN
THE
ALGORITHM
FOR
SPLITTING
A
POLYGON
INTO
MONOTONE
PIECES
DID
WE
USE
THE
FACT
THAT
THE
POLYGON
WAS
SIMPLE
IT
EVEN
WORKS
IN
A
MORE
GENERAL
SETTING
SUPPOSE
WE
HAVE
A
PLANAR
SUBDIVISION
AND
WE
WANT
TO
TRIANGULATE
THAT
SUBDIVISION
MORE
PRECISELY
IF
B
IS
A
BOUNDING
BOX
CONTAINING
ALL
EDGES
OF
IN
ITS
INTERIOR
WE
WANT
TO
FIND
A
MAXIMAL
SET
OF
NON
INTERSECTING
DIAGONALS
LINE
SEGMENTS
CONNECTING
VERTICES
OF
OR
B
THAT
DO
NOT
INTERSECT
THE
EDGES
OF
THAT
PARTITIONS
B
INTO
TRIANGLES
FIGURE
SHOWS
A
TRIANGULATED
SUBDIVISION
THE
EDGES
OF
THE
SUBDIVISIONS
AND
OF
THE
BOUNDING
BOX
ARE
SHOWN
BOLD
TO
COMPUTE
SUCH
A
TRIANGULATION
WE
CAN
USE
THE
ALGORITHM
OF
THIS
CHAPTER
FIRST
SPLIT
THE
SUBDIVISION
INTO
MONOTONE
PIECES
AND
THEN
TRIANGULATE
THE
PIECES
THIS
LEADS
TO
THE
FOLLOWING
THEOREM
THEOREM
A
PLANAR
SUBDIVISION
WITH
N
VERTICES
IN
TOTAL
CAN
BE
TRIANGULATED
IN
O
N
LOG
N
TIME
WITH
AN
ALGORITHM
THAT
USES
O
N
STORAGE
SECTION
NOTES
AND
COMMENTS
NOTES
AND
COMMENTS
THE
ART
GALLERY
PROBLEM
WAS
POSED
IN
BY
VICTOR
KLEE
IN
A
CONVERSATION
WITH
VASEK
CHVA
TAL
IN
CHVA
TAL
GAVE
THE
FIRST
PROOF
THAT
N
CAMERAS
ARE
ALWAYS
SUFFICIENT
AND
SOMETIMES
NECESSARY
A
RESULT
THAT
BECAME
KNOWN
AS
THE
ART
GALLERY
THEOREM
OR
THE
WATCHMAN
THEOREM
CHVA
TAL
PROOF
IS
QUITE
COMPLICATED
THE
MUCH
SIMPLER
PROOF
PRESENTED
IN
THIS
CHAPTER
WAS
DISCOVERED
BY
FISK
HIS
PROOF
IS
BASED
ON
THE
TWO
EARS
THEOREM
BY
MEISTERS
FROM
WHICH
THE
COLORABILITY
OF
THE
GRAPH
THAT
IS
A
TRIANGULATION
OF
A
SIMPLE
POLYGON
FOLLOWS
EASILY
THE
ALGORITHMIC
PROBLEM
OF
FINDING
THE
MINIMUM
NUMBER
OF
GUARDS
FOR
A
GIVEN
SIMPLE
POLYGON
WAS
SHOWN
TO
BE
NP
HARD
BY
AGGARWAL
AND
LEE
AND
LIN
THE
BOOK
BY
O
ROURKE
AND
THE
OVERVIEW
BY
SHERMER
CONTAIN
AN
EXTENSIVE
TREATMENT
OF
THE
ART
GALLERY
PROBLEM
AND
NUMEROUS
VARIATIONS
FIGURE
A
TRIANGULATED
SUBDIVISION
A
DECOMPOSITION
OF
A
POLYGON
OR
ANY
OTHER
REGION
INTO
SIMPLE
PIECES
IS
USEFUL
IN
MANY
PROBLEMS
OFTEN
THE
SIMPLE
PIECES
ARE
TRIANGLES
IN
WHICH
CASE
WE
CALL
THE
DECOMPOSITION
A
TRIANGULATION
BUT
SOMETIMES
OTHER
SHAPES
SUCH
AS
QUADRILATERALS
OR
TRAPEZOIDS
ARE
USED
SEE
ALSO
CHAPTERS
AND
WE
ONLY
DISCUSS
THE
RESULTS
ON
TRIANGULATING
POLYGONS
HERE
THE
LINEAR
TIME
ALGORITHM
TO
TRIANGULATE
A
MONOTONE
POLYGON
DESCRIBED
IN
THIS
CHAPTER
WAS
GIVEN
BY
GAREY
ET
AL
AND
THE
PLANE
SWEEP
ALGORITHM
TO
PARTITION
A
POLYGON
INTO
MONOTONE
PIECES
IS
DUE
TO
LEE
AND
PREPARATA
AVIS
AND
TOUSSAINT
AND
CHAZELLE
DESCRIBED
OTHER
ALGORITHMS
FOR
TRIANGULATING
A
SIMPLE
POLYGON
IN
O
N
LOG
N
TIME
FOR
A
LONG
TIME
ONE
OF
THE
MAIN
OPEN
PROBLEMS
IN
COMPUTATIONAL
GEOME
TRY
WAS
WHETHER
SIMPLE
POLYGONS
CAN
BE
TRIANGULATED
IN
O
N
LOG
N
TIME
FOR
TRIANGULATING
SUBDIVISIONS
WITH
HOLES
THERE
IS
AN

N
LOG
N
LOWER
BOUND
IN
THIS
CHAPTER
WE
HAVE
SEEN
THAT
THIS
IS
INDEED
THE
CASE
FOR
MONOTONE
POLYGONS
LINEAR
TIME
TRIANGULATION
ALGORITHMS
WERE
ALSO
FOUND
FOR
OTHER
SPECIAL
CLASSES
OF
POLYGONS
BUT
THE
PROBLEM
FOR
GENERAL
SIMPLE
POLYGONS
REMAINED
OPEN
FOR
A
NUMBER
OF
YEARS
IN
TARJAN
AND
VAN
WYK
BROKE
THE
O
N
LOG
N
BARRIER
BY
PRESENTING
AN
O
N
LOGLOG
N
ALGORITHM
THEIR
ALGORITHM
WAS
LATER
SIMPLIFIED
BY
KIRKPATRICK
ET
AL
RANDOMIZATION
AN
APPROACH
USED
IN
CHAPTERS
AND
PROVED
TO
BE
A
GOOD
TOOL
IN
DEVELOPING
EVEN
CHAPTER
POLYGON
TRIANGULATION
FASTER
ALGORITHMS
CLARKSON
ET
AL
DEVILLERS
AND
SEIDEL
PRE
SENTED
ALGORITHMS
WITH
O
N
LOG
N
RUNNING
TIME
WHERE
LOG
N
IS
THE
ITERATED
LOGARITHM
OF
N
BEING
THE
NUMBER
OF
TIMES
YOU
CAN
TAKE
THE
LOGARITHM
BEFORE
THE
RESULT
IS
SMALLER
THAN
THESE
ALGORITHMS
ARE
NOT
ONLY
SLIGHTLY
FASTER
THAN
THE
O
N
LOGLOG
N
ALGORITHM
BUT
ALSO
SIMPLER
SEIDEL
ALGORITHM
IS
CLOSELY
RELATED
TO
THE
ALGORITHM
FOR
CONSTRUCTING
A
TRAPEZOIDAL
DECOMPOSITION
OF
A
PLANAR
SUBDI
VISION
DESCRIBED
IN
CHAPTER
HOWEVER
THE
QUESTION
WHETHER
A
SIMPLE
POLYGON
CAN
BE
TRIANGULATED
IN
LINEAR
TIME
WAS
STILL
OPEN
IN
THIS
PROBLEM
WAS
FINALLY
SETTLED
BY
CHAZELLE
WHO
GAVE
A
QUITE
COMPLICATED
DETERMINISTIC
LINEAR
TIME
ALGORITHM
A
RANDOMIZED
LINEAR
TIME
ALGORITHM
WAS
DEVELOPED
LATER
BY
AMATO
ET
AL
THE
DIMENSIONAL
EQUIVALENT
TO
THE
POLYGON
TRIANGULATION
PROBLEM
IS
THIS
DE
COMPOSE
A
GIVEN
POLYTOPE
INTO
NON
OVERLAPPING
TETRAHEDRA
WHERE
THE
VERTICES
OF
THE
TETRAHEDRA
MUST
BE
VERTICES
OF
THE
ORIGINAL
POLYTOPE
SUCH
A
DECOMPOSITION
IS
CALLED
A
TETRAHEDRALIZATION
OF
THE
POLYTOPE
THIS
PROBLEM
IS
MUCH
MORE
DIFFICULT
THAN
THE
TWO
DIMENSIONAL
VERSION
IN
FACT
IT
IS
NOT
ALWAYS
POSSIBLE
TO
DECOMPOSE
A
POLYTOPE
INTO
TETRAHEDRA
WITHOUT
USING
ADDITIONAL
VERTICES
CHAZELLE
HAS
SHOWN
THAT
FOR
A
SIMPLE
POLYTOPE
WITH
N
VERTICES

ADDITIONAL
VERTICES
MAY
BE
NEEDED
AND
ARE
ALWAYS
SUFFICIENT
TO
OBTAIN
A
DECOMPOSITION
INTO
TETRAHEDRA
THIS
BOUND
WAS
REFINED
BY
CHAZELLE
AND
PALIOS
TO

N
WHERE
R
IS
THE
NUMBER
OF
REFLEX
EDGES
OF
THE
POLYTOPE
THE
ALGORITHM
TO
COMPUTE
THE
DECOMPO
SITION
RUNS
IN
O
NR
LOG
R
TIME
DECIDING
WHETHER
A
GIVEN
SIMPLE
POLYTOPE
CAN
BE
TETRAHEDRALIZED
WITHOUT
ADDITIONAL
VERTICES
IS
NP
COMPLETE
EXERCISES
PROVE
THAT
ANY
POLYGON
ADMITS
A
TRIANGULATION
EVEN
IF
IT
HAS
HOLES
CAN
YOU
SAY
ANYTHING
ABOUT
THE
NUMBER
OF
TRIANGLES
IN
THE
TRIANGULATION
A
RECTILINEAR
POLYGON
IS
A
SIMPLE
POLYGON
OF
WHICH
ALL
EDGES
ARE
HORIZONTAL
OR
VERTICAL
LET
P
BE
A
RECTILINEAR
POLYGON
WITH
N
VERTICES
GIVE
AN
EXAMPLE
TO
SHOW
THAT
LN
CAMERAS
ARE
SOMETIMES
NECESSARY
TO
GUARD
IT
PROVE
OR
DISPROVE
THE
DUAL
GRAPH
OF
THE
TRIANGULATION
OF
A
MONOTONE
POLYGON
IS
ALWAYS
A
CHAIN
THAT
IS
ANY
NODE
IN
THIS
GRAPH
HAS
DEGREE
AT
MOST
TWO
SUPPOSE
THAT
A
SIMPLE
POLYGON
P
WITH
N
VERTICES
IS
GIVEN
TOGETHER
WITH
A
SET
OF
DIAGONALS
THAT
PARTITIONS
P
INTO
CONVEX
QUADRILATERALS
HOW
MANY
CAMERAS
ARE
SUFFICIENT
TO
GUARD
P
WHY
DOESN
T
THIS
CONTRADICT
THE
ART
GALLERY
THEOREM
GIVE
THE
PSEUDO
CODE
OF
THE
ALGORITHM
TO
COMPUTE
A
COLORING
OF
A
TRIANGULATED
SIMPLE
POLYGON
THE
ALGORITHM
SHOULD
RUN
IN
LINEAR
TIME
GIVE
AN
ALGORITHM
THAT
COMPUTES
IN
O
N
LOG
N
TIME
A
DIAGONAL
THAT
SPLITS
A
SIMPLE
POLYGON
WITH
N
VERTICES
INTO
TWO
SIMPLE
POLYGONS
EACH
WITH
AT
MOST
VERTICES
HINT
USE
THE
DUAL
GRAPH
OF
A
TRIANGULATION
LET
P
BE
A
SIMPLE
POLYGON
WITH
N
VERTICES
WHICH
HAS
BEEN
PARTITIONED
INTO
MONOTONE
PIECES
PROVE
THAT
THE
SUM
OF
THE
NUMBER
OF
VERTICES
OF
THE
PIECES
IS
O
N
THE
ALGORITHM
GIVEN
IN
THIS
CHAPTER
TO
PARTITION
A
SIMPLE
POLYGON
INTO
MONOTONE
PIECES
CONSTRUCTS
A
DOUBLY
CONNECTED
EDGE
LIST
FOR
THE
PARTI
TIONED
POLYGON
DURING
THE
ALGORITHM
NEW
EDGES
ARE
ADDED
TO
THE
DCEL
NAMELY
DIAGONALS
TO
GET
RID
OF
SPLIT
AND
MERGE
VERTICES
IN
GENERAL
ADDING
AN
EDGE
TO
A
DCEL
CANNOT
BE
DONE
IN
CONSTANT
TIME
DISCUSS
WHY
ADDING
AN
EDGE
MAY
TAKE
MORE
THAN
CONSTANT
TIME
AND
ARGUE
THAT
IN
THE
POLYGON
PARTITIONING
ALGORITHM
WE
CAN
ADD
A
DIAGONAL
IN
O
TIME
NEVERTHELESS
SHOW
THAT
IF
A
POLYGON
HAS
O
TURN
VERTICES
THEN
THE
ALGORITHM
GIVEN
IN
THIS
CHAPTER
CAN
BE
MADE
TO
RUN
IN
O
N
TIME
CAN
THE
ALGORITHM
OF
THIS
CHAPTER
ALSO
BE
USED
TO
TRIANGULATE
A
SET
OF
N
POINTS
IF
SO
EXPLAIN
HOW
TO
DO
THIS
EFFICIENTLY
GIVE
AN
EFFICIENT
ALGORITHM
TO
DETERMINE
WHETHER
A
POLYGON
P
WITH
N
VERTICES
IS
MONOTONE
WITH
RESPECT
TO
SOME
LINE
NOT
NECESSARILY
A
HORIZONTAL
OR
VERTICAL
ONE
THE
POCKETS
OF
A
SIMPLE
POLYGON
ARE
THE
AREAS
OUTSIDE
THE
POLYGON
BUT
INSIDE
ITS
CONVEX
HULL
LET
BE
A
SIMPLE
POLYGON
WITH
M
VERTICES
AND
ASSUME
THAT
A
TRIANGULATION
OF
AS
WELL
AS
ITS
POCKETS
IS
GIVEN
LET
BE
A
CONVEX
POLYGON
WITH
N
VERTICES
SHOW
THAT
THE
INTERSECTION
CAN
BE
COMPUTED
IN
O
M
N
TIME
THE
STABBING
NUMBER
OF
A
TRIANGULATED
SIMPLE
POLYGON
P
IS
THE
MAXIMUM
NUMBER
OF
DIAGONALS
INTERSECTED
BY
ANY
LINE
SEGMENT
INTERIOR
TO
P
GIVE
AN
ALGORITHM
THAT
COMPUTES
A
TRIANGULATION
OF
A
CONVEX
POLYGON
THAT
HAS
STABBING
NUMBER
O
LOG
N
GIVEN
A
SIMPLE
POLYGON
P
WITH
N
VERTICES
AND
A
POINT
P
INSIDE
IT
SHOW
HOW
TO
COMPUTE
THE
REGION
INSIDE
P
THAT
IS
VISIBLE
FROM
P
SECTION
EXERCISES
POCKETS
LINEAR
PROGRAMMING
MANUFACTURING
WITH
MOLDS
MOST
OBJECTS
WE
SEE
AROUND
US
TODAY
FROM
CAR
BODIES
TO
PLASTIC
CUPS
AND
CUTLERY
ARE
MADE
USING
SOME
FORM
OF
AUTOMATED
MANUFACTURING
COMPUTERS
PLAY
AN
IMPORTANT
ROLE
IN
THIS
PROCESS
BOTH
IN
THE
DESIGN
PHASE
AND
IN
THE
CONSTRUCTION
PHASE
CAD
CAM
FACILITIES
ARE
A
VITAL
PART
OF
ANY
MODERN
FACTORY
THE
CONSTRUCTION
PROCESS
USED
TO
MANUFACTURE
A
SPECIFIC
OBJECT
DEPENDS
ON
FACTORS
SUCH
AS
THE
MATERIAL
THE
OBJECT
SHOULD
BE
MADE
OF
THE
SHAPE
OF
THE
OBJECT
AND
WHETHER
THE
OBJECT
WILL
BE
MASS
PRODUCED
IN
THIS
CHAPTER
WE
STUDY
SOME
GEOMETRIC
ASPECTS
OF
MANUFACTURING
WITH
MOLDS
A
COMMONLY
USED
PROCESS
FOR
PLASTIC
OR
METAL
OBJECTS
FOR
METAL
OBJECTS
THIS
PROCESS
IS
OFTEN
REFERRED
TO
AS
CASTING
FIGURE
THE
CASTING
PROCESS
FIGURE
ILLUSTRATES
THE
CASTING
PROCESS
LIQUID
METAL
IS
POURED
INTO
A
MOLD
IT
SOLIDIFIES
AND
THEN
THE
OBJECT
IS
REMOVED
FROM
THE
MOLD
THE
LAST
STEP
IS
NOT
ALWAYS
AS
EASY
AS
IT
SEEMS
THE
OBJECT
COULD
BE
STUCK
IN
THE
MOLD
SO
THAT
IT
CANNOT
BE
REMOVED
WITHOUT
BREAKING
THE
MOLD
SOMETIMES
WE
CAN
GET
AROUND
THIS
PROBLEM
BY
USING
A
DIFFERENT
MOLD
THERE
ARE
ALSO
OBJECTS
HOWEVER
FOR
WHICH
NO
GOOD
MOLD
EXISTS
A
SPHERE
IS
AN
EXAMPLE
THIS
IS
THE
PROBLEM
WE
SHALL
STUDY
IN
THIS
CHAPTER
GIVEN
AN
OBJECT
IS
THERE
A
MOLD
FOR
IT
FROM
WHICH
IT
CAN
BE
REMOVED
WE
SHALL
CONFINE
OURSELVES
TO
THE
FOLLOWING
SITUATION
FIRST
OF
ALL
WE
ASSUME
THAT
THE
OBJECT
TO
BE
CONSTRUCTED
IS
POLYHEDRAL
SECONDLY
WE
ONLY
CONSIDER
TOP
FACET
CHAPTER
LINEAR
PROGRAMMING
MOLDS
OF
ONE
PIECE
NOT
MOLDS
CONSISTING
OF
TWO
OR
MORE
PIECES
USING
MOLDS
CONSISTING
OF
TWO
PIECES
IT
IS
POSSIBLE
TO
MANUFACTURE
OBJECTS
SUCH
AS
SPHERES
WHICH
CANNOT
BE
MANUFACTURED
USING
A
MOLD
OF
A
SINGLE
PIECE
FINALLY
WE
ONLY
ALLOW
THE
OBJECT
TO
BE
REMOVED
FROM
THE
MOLD
BY
A
SINGLE
TRANSLATION
THIS
MEANS
THAT
WE
WILL
NOT
BE
ABLE
TO
REMOVE
A
SCREW
FROM
ITS
MOLD
FORTUNATELY
TRANSLATIONAL
MOTIONS
SUFFICE
FOR
MANY
OBJECTS
THE
GEOMETRY
OF
CASTING
IF
WE
WANT
TO
DETERMINE
WHETHER
AN
OBJECT
CAN
BE
MANUFACTURED
BY
CASTING
WE
HAVE
TO
FIND
A
SUITABLE
MOLD
FOR
IT
THE
SHAPE
OF
THE
CAVITY
IN
THE
MOLD
IS
DETERMINED
BY
THE
SHAPE
OF
THE
OBJECT
BUT
DIFFERENT
ORIENTATIONS
OF
THE
OBJECT
GIVE
RISE
TO
DIFFERENT
MOLDS
CHOOSING
THE
ORIENTATION
CAN
BE
CRUCIAL
SOME
ORIENTATIONS
MAY
GIVE
RISE
TO
MOLDS
FROM
WHICH
THE
OBJECT
CANNOT
BE
REMOVED
WHILE
OTHER
ORIENTATIONS
ALLOW
REMOVAL
OF
THE
OBJECT
ONE
OBVIOUS
RESTRICTION
ON
THE
ORIENTATION
IS
THAT
THE
OBJECT
MUST
HAVE
A
HORIZONTAL
TOP
FACET
THIS
FACET
WILL
BE
THE
ONLY
ONE
NOT
IN
CONTACT
WITH
THE
MOLD
HENCE
THERE
ARE
AS
MANY
POTENTIAL
ORIENTATIONS
OR
EQUIVALENTLY
POSSIBLE
MOLDS
AS
THE
OBJECT
HAS
FACETS
WE
CALL
AN
OBJECT
CASTABLE
IF
IT
CAN
BE
REMOVED
FROM
ITS
MOLD
FOR
AT
LEAST
ONE
OF
THESE
ORIENTATIONS
IN
THE
FOLLOWING
WE
SHALL
CONCENTRATE
ON
DETERMINING
WHETHER
AN
OBJECT
IS
REMOVABLE
BY
A
TRANSLATION
FROM
A
SPECIFIC
GIVEN
MOLD
TO
DECIDE
ON
THE
CASTABILITY
OF
THE
OBJECT
WE
THEN
SIMPLY
TRY
EVERY
POTENTIAL
ORIENTATION
LET
P
BE
A
DIMENSIONAL
POLYHEDRON
THAT
IS
A
DIMENSIONAL
SOLID
BOUNDED
BY
PLANAR
FACETS
WITH
A
DESIGNATED
TOP
FACET
WE
SHALL
NOT
TRY
TO
GIVE
A
PRECISE
FORMAL
DEFINITION
OF
A
POLYHEDRON
GIVING
SUCH
A
DEFINITION
IS
TRICKY
AND
NOT
NECESSARY
IN
THIS
CONTEXT
WE
ASSUME
THAT
THE
MOLD
IS
A
RECTANGULAR
BLOCK
WITH
A
CAVITY
THAT
CORRESPONDS
EXACTLY
TO
P
WHEN
THE
POLYHEDRON
IS
PLACED
IN
THE
MOLD
ITS
TOP
FACET
SHOULD
BE
COPLANAR
WITH
THE
TOPMOST
FACET
OF
THE
MOLD
WHICH
WE
ASSUME
TO
BE
PARALLEL
TO
THE
XY
PLANE
THIS
MEANS
THAT
THE
MOLD
HAS
NO
UNNECESSARY
PARTS
STICKING
OUT
ON
THE
TOP
THAT
MIGHT
PREVENT
P
FROM
BEING
REMOVED
WE
CALL
A
FACET
OF
P
THAT
IS
NOT
THE
TOP
FACET
AN
ORDINARY
FACET
EVERY
ORDINARY
FACET
F
HAS
A
CORRESPONDING
FACET
IN
THE
MOLD
WHICH
WE
DENOTE
BY
F
WE
WANT
TO
DECIDE
WHETHER
P
CAN
BE
REMOVED
FROM
ITS
MOLD
BY
A
SINGLE
TRANSLA
TION
IN
OTHER
WORDS
WE
WANT
TO
DECIDE
WHETHER
A
DIRECTION
D
EXISTS
SUCH
THAT
P
CAN
BE
TRANSLATED
TO
INFINITY
IN
DIRECTION
D
WITHOUT
INTERSECTING
THE
INTERIOR
OF
THE
MOLD
DURING
THE
TRANSLATION
NOTE
THAT
WE
ALLOW
P
TO
SLIDE
ALONG
THE
MOLD
BECAUSE
THE
FACET
OF
P
NOT
TOUCHING
THE
MOLD
IS
ITS
TOP
FACET
THE
REMOVAL
DIRECTION
HAS
TO
BE
UPWARD
THAT
IS
IT
MUST
HAVE
A
POSITIVE
Z
COMPONENT
THIS
IS
ONLY
A
NECESSARY
CONDITION
ON
THE
REMOVAL
DIRECTION
WE
NEED
MORE
CONSTRAINTS
TO
BE
SURE
THAT
A
DIRECTION
IS
VALID
LET
F
BE
AN
ORDINARY
FACET
OF
P
THIS
FACET
MUST
MOVE
AWAY
FROM
OR
SLIDE
ALONG
ITS
CORRESPONDING
FACET
F
OF
THE
MOLD
TO
MAKE
THIS
CONSTRAINT
PRECISE
WE
NEED
TO
DEFINE
THE
ANGLE
OF
TWO
VECTORS
IN
SPACE
WE
DO
THIS
AS
FOLLOWS
TAKE
THE
PLANE
SPANNED
BY
THE
VECTORS
WE
ASSUME
BOTH
VECTORS
ARE
ROOTED
AT
THE
ORIGIN
THE
ANGLE
OF
THE
VECTORS
IS
THE
SMALLER
OF
THE
TWO
ANGLES
MEASURED
IN
THIS
PLANE
NOW
F
BLOCKS
ANY
TRANSLATION
IN
A
DIRECTION
MAKING
AN
ANGLE
OF
LESS
THAN
WITH

F
THE
OUTWARD
NORMAL
OF
F
SO
A
NECESSARY
CONDITION
ON
D
IS
THAT
IT
MAKES
AN
ANGLE
OF
AT
LEAST
WITH
THE
OUTWARD
NORMAL
OF
EVERY
ORDINARY
FACET
OF
P
THE
NEXT
LEMMA
SHOWS
THAT
THIS
CONDITION
IS
ALSO
SUFFICIENT
LEMMA
THE
POLYHEDRON
P
CAN
BE
REMOVED
FROM
ITS
MOLD
BY
A
TRANSLATION
IN
DIRECTION
D
IF
AND
ONLY
IF
D
MAKES
AN
ANGLE
OF
AT
LEAST
WITH
THE
OUTWARD
NORMAL
OF
ALL
ORDINARY
FACETS
OF
P
PROOF
THE
ONLY
IF
PART
IS
EASY
IF
D
MADE
AN
ANGLE
LESS
THAN
WITH
SOME
OUTWARD
NORMAL

F
THEN
ANY
POINT
Q
IN
THE
INTERIOR
OF
F
COLLIDES
WITH
THE
MOLD
WHEN
TRANSLATED
IN
DIRECTION
D
TO
PROVE
THE
IF
PART
SUPPOSE
THAT
AT
SOME
MOMENT
P
COLLIDES
WITH
THE
MOLD
WHEN
TRANSLATED
IN
DIRECTION
D
WE
HAVE
TO
SHOW
THAT
THERE
MUST
BE
AN
OUTWARD
NORMAL
MAKING
AN
ANGLE
OF
LESS
THAN
WITH
D
LET
P
BE
A
POINT
OF
P
THAT
COLLIDES
WITH
A
FACET
F
OF
THE
MOLD
THIS
MEANS
THAT
P
IS
ABOUT
TO
MOVE
INTO
THE
INTERIOR
OF
THE
MOLD
SO

F
THE
OUTWARD
NORMAL
OF
F
MUST
MAKE
AN
ANGLE
GREATER
THAN
WITH
D
BUT
THEN
D
MAKES
AN
ANGLE
LESS
THAN
WITH
THE
OUTWARD
NORMAL
OF
THE
ORDINARY
FACET
F
OF
P
THAT
CORRESPONDS
TO
F
LEMMA
HAS
AN
INTERESTING
CONSEQUENCE
IF
P
CAN
BE
REMOVED
BY
A
SEQUENCE
OF
SMALL
TRANSLATIONS
THEN
IT
CAN
BE
REMOVED
BY
A
SINGLE
TRANSLATION
SO
ALLOWING
FOR
MORE
THAN
ONE
TRANSLATION
DOES
NOT
HELP
IN
REMOVING
THE
OBJECT
FROM
ITS
MOLD
WE
ARE
LEFT
WITH
THE
TASK
OF
FINDING
A
DIRECTION
D
THAT
MAKES
AN
ANGLE
OF
AT
LEAST
WITH
THE
OUTWARD
NORMAL
OF
EACH
ORDINARY
FACET
OF
P
A
DIRECTION
IN
DIMENSIONAL
SPACE
CAN
BE
REPRESENTED
BY
A
VECTOR
ROOTED
AT
THE
ORIGIN
WE
ALREADY
KNOW
THAT
WE
CAN
RESTRICT
OUR
ATTENTION
TO
DIRECTIONS
WITH
A
POSITIVE
Z
COMPONENT
WE
CAN
REPRESENT
ALL
SUCH
DIRECTIONS
AS
POINTS
IN
THE
PLANE
Z
WHERE
THE
POINT
X
Y
REPRESENTS
THE
DIRECTION
OF
THE
VECTOR
X
Y
THIS
WAY
EVERY
POINT
IN
THE
PLANE
Z
REPRESENTS
A
UNIQUE
DIRECTION
AND
EVERY
DIRECTION
WITH
A
POSITIVE
Z
VALUE
IS
REPRESENTED
BY
A
UNIQUE
POINT
IN
THAT
PLANE
LEMMA
GIVES
NECESSARY
AND
SUFFICIENT
CONDITIONS
ON
THE
REMOVAL
DIREC
TION
D
HOW
DO
THESE
CONDITIONS
TRANSLATE
INTO
OUR
PLANE
OF
DIRECTIONS
LET

X
Y
Z
BE
THE
OUTWARD
NORMAL
OF
AN
ORDINARY
FACET
THE
DIRECTION
D
DX
DY
MAKES
AN
ANGLE
AT
LEAST
WITH

IF
AND
ONLY
IF
THE
DOT
PRODUCT
OF
D
AND

IS
NON
POSITIVE
HENCE
AN
ORDINARY
FACET
INDUCES
A
CONSTRAINT
OF
THE
FORM
SECTION
THE
GEOMETRY
OF
CASTING
XDX
YDY
Z
THIS
INEQUALITY
DESCRIBES
A
HALF
PLANE
ON
THE
PLANE
Z
THAT
IS
THE
AREA
LEFT
OR
THE
AREA
RIGHT
OF
A
LINE
ON
THE
PLANE
THIS
LAST
STATEMENT
IS
NOT
TRUE
FOR
HORIZONTAL
FACETS
WHICH
HAVE
X
Y
IN
THIS
CASE
THE
CONSTRAINT
IS
EITHER
IMPOSSIBLE
TO
SATISFY
OR
ALWAYS
SATISFIED
WHICH
IS
EASY
TO
TEST
HENCE
EVERY
NON
HORIZONTAL
FACET
OF
P
DEFINES
A
CLOSED
HALF
PLANE
ON
THE
PLANE
Z
AND
ANY
POINT
IN
THE
CHAPTER
LINEAR
PROGRAMMING
COMMON
INTERSECTION
OF
THESE
HALF
PLANES
CORRESPONDS
TO
A
DIRECTION
IN
WHICH
P
CAN
BE
REMOVED
THE
COMMON
INTERSECTION
OF
THESE
HALF
PLANES
MAY
BE
EMPTY
IN
THIS
CASE
P
CANNOT
BE
REMOVED
FROM
THE
GIVEN
MOLD
WE
HAVE
TRANSFORMED
OUR
MANUFACTURING
PROBLEM
TO
A
PURELY
GEOMETRIC
PROBLEM
IN
THE
PLANE
GIVEN
A
SET
OF
HALF
PLANES
FIND
A
POINT
IN
THEIR
COMMON
INTERSECTION
OR
DECIDE
THAT
THE
COMMON
INTERSECTION
IS
EMPTY
IF
THE
POLYHEDRON
TO
BE
MANUFACTURED
HAS
N
FACETS
THEN
THE
PLANAR
PROBLEM
HAS
AT
MOST
N
HALF
PLANES
THE
TOP
FACET
DOES
NOT
INDUCE
A
HALF
PLANE
IN
THE
NEXT
SECTIONS
WE
WILL
SEE
THAT
THE
PLANAR
PROBLEM
JUST
STATED
CAN
BE
SOLVED
IN
EXPECTED
LINEAR
TIME
SEE
SECTION
WHERE
ALSO
THE
MEANING
OF
EXPECTED
IS
EXPLAINED
RECALL
THAT
THE
GEOMETRIC
PROBLEM
CORRESPONDS
TO
TESTING
WHETHER
P
CAN
BE
REMOVED
FROM
A
GIVEN
MOLD
IF
THIS
IS
IMPOSSIBLE
THERE
CAN
STILL
BE
OTHER
MOLDS
CORRESPONDING
TO
DIFFERENT
CHOICES
OF
THE
TOP
FACET
FROM
WHICH
P
IS
REMOVABLE
IN
ORDER
TO
TEST
WHETHER
P
IS
CASTABLE
WE
TRY
ALL
ITS
FACETS
AS
TOP
FACETS
THIS
LEADS
TO
THE
FOLLOWING
RESULT
THEOREM
LET
P
BE
A
POLYHEDRON
WITH
N
FACETS
IN
O
EXPECTED
TIME
AND
USING
O
N
STORAGE
IT
CAN
BE
DECIDED
WHETHER
P
IS
CASTABLE
MOREOVER
IF
P
IS
CASTABLE
A
MOLD
AND
A
VALID
DIRECTION
FOR
REMOVING
P
FROM
IT
CAN
BE
COMPUTED
IN
THE
SAME
AMOUNT
OF
TIME
HALF
PLANE
INTERSECTION
LET
H
HN
BE
A
SET
OF
LINEAR
CONSTRAINTS
IN
TWO
VARIABLES
THAT
IS
CONSTRAINTS
OF
THE
FORM
AIX
BIY
CI
WHERE
AI
BI
AND
CI
ARE
CONSTANTS
SUCH
THAT
AT
LEAST
ONE
OF
AI
AND
BI
IS
NON
ZERO
GEOMETRICALLY
WE
CAN
INTERPRET
SUCH
A
CONSTRAINT
AS
A
CLOSED
HALF
PLANE
IN
BOUNDED
BY
THE
LINE
AIX
BIY
CI
THE
PROBLEM
WE
CONSIDER
IN
THIS
SECTION
IS
TO
FIND
THE
SET
OF
ALL
POINTS
X
Y
THAT
SATISFY
ALL
N
CONSTRAINTS
AT
THE
SAME
TIME
IN
OTHER
WORDS
WE
WANT
TO
FIND
ALL
THE
POINTS
LYING
IN
THE
COMMON
INTERSECTION
OF
THE
HALF
PLANES
IN
H
IN
THE
PREVIOUS
SECTION
WE
REDUCED
THE
CASTING
PROBLEM
TO
FINDING
SOME
POINT
IN
THE
INTERSECTION
OF
A
SET
OF
HALF
PLANES
THE
PROBLEM
WE
STUDY
NOW
IS
MORE
GENERAL
THE
SHAPE
OF
THE
INTERSECTION
OF
A
SET
OF
HALF
PLANES
IS
EASY
TO
DETERMINE
A
HALF
PLANE
IS
CONVEX
AND
THE
INTERSECTION
OF
CONVEX
SETS
IS
AGAIN
A
CONVEX
SET
SO
THE
INTERSECTION
OF
A
SET
OF
HALF
PLANES
IS
A
CONVEX
REGION
IN
THE
PLANE
EVERY
POINT
ON
THE
INTERSECTION
BOUNDARY
MUST
LIE
ON
THE
BOUNDING
LINE
OF
SOME
HALF
PLANE
HENCE
THE
BOUNDARY
OF
THE
REGION
CONSISTS
OF
EDGES
CONTAINED
IN
THESE
BOUNDING
LINES
SINCE
THE
INTERSECTION
IS
CONVEX
EVERY
BOUNDING
LINE
CAN
CONTRIBUTE
AT
MOST
ONE
EDGE
IT
FOLLOWS
THAT
THE
INTERSECTION
OF
N
HALF
PLANES
IS
A
CONVEX
POLYGONAL
REGION
BOUNDED
BY
AT
MOST
N
EDGES
FIGURE
SHOWS
A
FEW
EXAMPLES
OF
INTERSECTIONS
OF
HALF
PLANES
TO
WHICH
SIDE
OF
ITS
BOUNDING
LINE
A
HALF
PLANE
LIES
IS
INDICATED
BY
DARK
SHADING
IN
THE
FIGURE
THE
COMMON
INTERSECTION
IS
SHADED
LIGHTLY
AS
YOU
CAN
SEE
IN
FIGURES
II
AND
III
THE
I
II
III
SECTION
HALF
PLANE
INTERSECTION
V
INTERSECTION
DOES
NOT
HAVE
TO
BE
BOUNDED
THE
INTERSECTION
CAN
ALSO
DEGENERATE
TO
A
LINE
SEGMENT
OR
A
POINT
AS
IN
IV
OR
IT
CAN
BE
EMPTY
AS
IN
V
WE
GIVE
A
RATHER
STRAIGHTFORWARD
DIVIDE
AND
CONQUER
ALGORITHM
TO
COMPUTE
THE
INTERSECTION
OF
A
SET
OF
N
HALF
PLANES
IT
IS
BASED
ON
A
ROUTINE
INTERSECTCON
VEXREGIONS
TO
COMPUTE
THE
INTERSECTION
OF
TWO
CONVEX
POLYGONAL
REGIONS
WE
FIRST
GIVE
THE
OVERALL
ALGORITHM
ALGORITHM
INTERSECTHALFPLANES
H
INPUT
A
SET
H
OF
N
HALF
PLANES
IN
THE
PLANE
OUTPUT
THE
CONVEX
POLYGONAL
REGION
C
H
H
H
IF
CARD
H
THEN
C
THE
UNIQUE
HALF
PLANE
H
H
ELSE
SPLIT
H
INTO
SETS
AND
OF
SIZE
IN
AND
LN
INTERSECTHALFPLANES
INTERSECTHALFPLANES
C
INTERSECTCONVEXREGIONS
WHAT
REMAINS
IS
TO
DESCRIBE
THE
PROCEDURE
INTERSECTCONVEXREGIONS
BUT
WAIT
DIDN
T
WE
SEE
THIS
PROBLEM
BEFORE
IN
CHAPTER
INDEED
COROLLARY
STATES
THAT
WE
CAN
COMPUTE
THE
INTERSECTION
OF
TWO
POLYGONS
IN
O
N
LOG
N
K
LOG
N
TIME
WHERE
N
IS
THE
TOTAL
NUMBER
OF
VERTICES
IN
THE
TWO
POLYGONS
WE
MUST
BE
A
BIT
CAREFUL
IN
APPLYING
THIS
RESULT
TO
OUR
PROBLEM
BECAUSE
THE
REGIONS
WE
HAVE
CAN
BE
UNBOUNDED
OR
DEGENERATE
TO
A
SEGMENT
OR
A
POINT
HENCE
THE
REGIONS
ARE
NOT
NECESSARILY
POLYGONS
BUT
IT
IS
NOT
DIFFICULT
TO
MODIFY
THE
ALGORITHM
FROM
CHAPTER
SO
THAT
IT
STILL
WORKS
LET
ANALYZE
THIS
APPROACH
ASSUME
WE
HAVE
ALREADY
COMPUTED
THE
TWO
REGIONS
AND
BY
RECURSION
SINCE
THEY
ARE
BOTH
DEFINED
BY
AT
MOST
N
HALF
PLANES
THEY
BOTH
HAVE
AT
MOST
N
EDGES
THE
ALGORITHM
FROM
CHAPTER
COMPUTES
THEIR
OVERLAY
IN
TIME
O
N
K
LOG
N
WHERE
K
IS
THE
NUMBER
OF
FIGURE
EXAMPLES
OF
THE
INTERSECTION
OF
HALF
PLANES
INTERSECTION
POINTS
BETWEEN
EDGES
OF
AND
EDGES
OF
WHAT
IS
K
LOOK
CHAPTER
LINEAR
PROGRAMMING
RIGHT
BOUNDARY
LEFT
BOUNDARY
LLEFT
C
LRIGHT
C
AT
AN
INTERSECTION
POINT
V
BETWEEN
AN
EDGE
OF
AND
AN
EDGE
OF
NO
MATTER
HOW
AND
INTERSECT
V
MUST
BE
A
VERTEX
OF
BUT
IS
THE
INTERSECTION
OF
N
HALF
PLANES
AND
THEREFORE
HAS
AT
MOST
N
EDGES
AND
VERTICES
IT
FOLLOWS
THAT
K
N
SO
THE
COMPUTATION
OF
THE
INTERSECTION
OF
AND
TAKES
O
N
LOG
N
TIME
THIS
GIVES
THE
FOLLOWING
RECURRENCE
FOR
THE
TOTAL
RUNNING
TIME
T
N
O
IF
N
O
N
LOG
N
N
IF
N
THIS
RECURRENCE
SOLVES
TO
T
N
O
N
N
TO
OBTAIN
THIS
RESULT
WE
USED
A
SUBROUTINE
FOR
COMPUTING
THE
INTERSECTION
OF
TWO
ARBITRARY
POLYGONS
THE
POLYGONAL
REGIONS
WE
DEAL
WITH
IN
INTERSECT
HALFPLANES
ARE
ALWAYS
CONVEX
CAN
WE
USE
THIS
TO
DEVELOP
A
MORE
EFFICIENT
ALGORITHM
THE
ANSWER
IS
YES
AS
WE
SHOW
NEXT
WE
WILL
ASSUME
THAT
THE
REGIONS
WE
WANT
TO
INTERSECT
ARE
DIMENSIONAL
THE
CASE
WHERE
ONE
OR
BOTH
OF
THEM
IS
A
SEGMENT
OR
A
POINT
IS
EASIER
AND
LEFT
AS
AN
EXERCISE
FIRST
LET
SPECIFY
MORE
PRECISELY
HOW
WE
REPRESENT
A
CONVEX
POLYGONAL
REGION
C
WE
WILL
STORE
THE
LEFT
AND
THE
RIGHT
BOUNDARY
OF
C
SEPARATELY
AS
SORTED
LISTS
OF
HALF
PLANES
THE
LISTS
ARE
SORTED
IN
THE
ORDER
IN
WHICH
THE
BOUNDING
LINES
OF
THE
HALF
PLANES
OCCUR
WHEN
THE
LEFT
OR
RIGHT
BOUNDARY
IS
TRAVERSED
FROM
TOP
TO
BOTTOM
WE
DENOTE
THE
LEFT
BOUNDARY
LIST
BY
LLEFT
C
AND
THE
RIGHT
BOUNDARY
LIST
BY
LRIGHT
C
VERTICES
ARE
NOT
STORED
EXPLICITLY
THEY
CAN
BE
COMPUTED
BY
INTERSECTING
CONSECUTIVE
BOUNDING
LINES
TO
SIMPLIFY
THE
DESCRIPTION
OF
THE
ALGORITHM
WE
SHALL
ASSUME
THAT
THERE
ARE
NO
HORIZONTAL
EDGES
TO
ADAPT
THE
ALGORITHM
TO
DEAL
WITH
HORIZONTAL
EDGES
ONE
CAN
DEFINE
SUCH
EDGES
TO
BELONG
TO
THE
LEFT
BOUNDARY
IF
THEY
BOUND
C
FROM
ABOVE
AND
TO
THE
RIGHT
BOUNDARY
IF
THEY
BOUND
C
FROM
BELOW
WITH
THIS
CONVENTION
ONLY
A
FEW
ADAPTATIONS
ARE
NEEDED
TO
THE
ALGORITHM
STATED
BELOW
THE
NEW
ALGORITHM
IS
A
PLANE
SWEEP
ALGORITHM
LIKE
THE
ONE
IN
CHAPTER
WE
MOVE
A
SWEEP
LINE
DOWNWARD
OVER
THE
PLANE
AND
WE
MAINTAIN
THE
EDGES
OF
AND
INTERSECTING
THE
SWEEP
LINE
SINCE
AND
ARE
CONVEX
THERE
ARE
AT
MOST
FOUR
SUCH
EDGES
HENCE
THERE
IS
NO
NEED
TO
STORE
THESE
EDGES
IN
A
COMPLICATED
DATA
STRUCTURE
INSTEAD
WE
SIMPLY
HAVE
POINTERS
LEFT
EDGE
RIGHT
EDGE
LEFT
EDGE
AND
RIGHT
EDGE
TO
THEM
IF
THE
SWEEP
LINE
DOES
NOT
INTERSECT
THE
RIGHT
OR
LEFT
BOUNDARY
OF
A
REGION
THEN
THE
CORRESPONDING
POINTER
IS
NIL
FIGURE
ILLUSTRATES
THE
DEFINITIONS
HOW
ARE
THESE
POINTERS
INITIALIZED
LET
BE
THE
Y
COORDINATE
OF
THE
TOPMOST
VERTEX
OF
IF
HAS
AN
UNBOUNDED
EDGE
EXTENDING
UPWARD
TO
INFINITY
THEN
WE
DEFINE
DEFINE
SIMILARLY
FOR
AND
LET
YSTART
MIN
TO
COMPUTE
THE
INTERSECTION
OF
AND
WE
CAN
RESTRICT
OUR
ATTENTION
TO
THE
PART
OF
THE
PLANE
WITH
Y
COORDINATE
LESS
THAN
OR
EQUAL
TO
YSTART
HENCE
WE
LET
THE
SWEEP
LINE
START
AT
YSTART
AND
WE
INITIALIZE
THE
EDGES
LEFT
EDGE
RIGHT
EDGE
LEFT
EDGE
AND
RIGHT
EDGE
AS
THE
ONES
INTERSECTING
THE
LINE
Y
YSTART
LEFT
EDGE
RIGHT
EDGE
NIL
SECTION
HALF
PLANE
INTERSECTION
RIGHT
EDGE
LEFT
EDGE
IN
A
PLANE
SWEEP
ALGORITHM
ONE
NORMALLY
ALSO
NEEDS
A
QUEUE
TO
STORE
THE
EVENTS
IN
OUR
CASE
THE
EVENTS
ARE
THE
POINTS
WHERE
EDGES
OF
OR
OF
START
OR
STOP
TO
INTERSECT
THE
SWEEP
LINE
THIS
IMPLIES
THAT
THE
NEXT
EVENT
POINT
WHICH
DETERMINES
THE
NEXT
EDGE
TO
BE
HANDLED
IS
THE
HIGHEST
OF
THE
LOWER
ENDPOINTS
OF
THE
EDGES
INTERSECTING
THE
SWEEP
LINE
ENDPOINTS
WITH
THE
SAME
Y
COORDINATE
ARE
HANDLED
FROM
LEFT
TO
RIGHT
IF
TWO
ENDPOINTS
COINCIDE
THEN
THE
LEFTMOST
EDGE
IS
TREATED
FIRST
HENCE
WE
DON
T
NEED
AN
EVENT
QUEUE
THE
NEXT
EVENT
CAN
BE
FOUND
IN
CONSTANT
TIME
USING
THE
POINTERS
LEFT
EDGE
RIGHT
EDGE
LEFT
EDGE
AND
RIGHT
EDGE
AT
EACH
EVENT
POINT
SOME
NEW
EDGE
E
APPEARS
ON
THE
BOUNDARY
TO
HANDLE
THE
EDGE
E
WE
FIRST
CHECK
WHETHER
E
BELONGS
TO
OR
TO
AND
WHETHER
IT
IS
ON
THE
LEFT
OR
THE
RIGHT
BOUNDARY
AND
THEN
CALL
THE
APPROPRIATE
PROCEDURE
WE
SHALL
ONLY
DESCRIBE
THE
PROCEDURE
THAT
IS
CALLED
WHEN
E
IS
ON
THE
LEFT
BOUNDARY
OF
THE
OTHER
PROCEDURES
ARE
SIMILAR
LET
P
BE
THE
UPPER
ENDPOINT
OF
E
THE
PROCEDURE
THAT
HANDLES
E
WILL
DISCOVER
THREE
POSSIBLE
EDGES
THAT
C
MIGHT
HAVE
THE
EDGE
WITH
P
AS
UPPER
ENDPOINT
THE
EDGE
WITH
E
LEFT
EDGE
AS
UPPER
ENDPOINT
AND
THE
EDGE
WITH
E
RIGHT
EDGE
AS
UPPER
ENDPOINT
IT
PERFORMS
THE
FOLLOWING
ACTIONS
FIRST
WE
TEST
WHETHER
P
LIES
IN
BETWEEN
LEFT
EDGE
AND
RIGHT
EDGE
IF
THIS
IS
THE
CASE
THEN
E
CONTRIBUTES
AN
EDGE
TO
C
STARTING
AT
P
WE
THEN
ADD
THE
HALF
PLANE
WHOSE
BOUNDING
LINE
CONTAINS
E
TO
THE
LIST
LLEFT
C
NEXT
WE
TEST
WHETHER
E
INTERSECTS
RIGHT
EDGE
IF
THIS
IS
THE
CASE
THEN
THE
INTERSECTION
POINT
IS
A
VERTEX
OF
C
EITHER
BOTH
EDGES
CONTRIBUTE
AN
EDGE
TO
C
STARTING
AT
THE
INTERSECTION
POINT
THIS
HAPPENS
WHEN
P
LIES
TO
THE
RIGHT
OF
RIGHT
EDGE
AS
IN
FIGURE
I
OR
BOTH
EDGES
CONTRIBUTE
AN
EDGE
ENDING
THERE
THIS
HAPPENS
WHEN
P
LIES
TO
THE
LEFT
OF
RIGHT
EDGE
AS
IN
FIGURE
II
IF
BOTH
EDGES
CONTRIBUTE
AN
EDGE
STARTING
AT
THE
INTERSECTION
POINT
THEN
WE
HAVE
TO
ADD
THE
HALF
PLANE
DEFINING
E
TO
LLEFT
C
AND
THE
HALF
PLANE
DEFINING
RIGHT
EDGE
TO
LRIGHT
C
IF
THEY
CONTRIBUTE
AN
EDGE
ENDING
AT
THE
INTERSECTION
POINT
WE
DO
NOTHING
THESE
EDGES
HAVE
ALREADY
BEEN
DISCOVERED
IN
SOME
OTHER
WAY
FIGURE
THE
EDGES
MAINTAINED
BY
THE
SWEEP
LINE
ALGORITHM
FINALLY
WE
TEST
WHETHER
E
INTERSECTS
LEFT
EDGE
IF
THIS
IS
THE
CASE
THEN
THE
CHAPTER
LINEAR
PROGRAMMING
I
II
P
EDGE
E
RIGHT
EDGE
FIGURE
THE
TWO
POSSIBILITIES
WHEN
E
INTERSECTS
RIGHT
EDGE
P
E
LEFT
EDGE
INTERSECTION
POINT
IS
A
VERTEX
OF
C
THE
EDGE
OF
C
STARTING
AT
THAT
VERTEX
IS
EITHER
A
PART
OF
E
OR
IT
IS
A
PART
OF
LEFT
EDGE
WE
CAN
DECIDE
BETWEEN
THESE
POSSIBILITIES
IN
CONSTANT
TIME
IF
P
LIES
TO
THE
LEFT
OF
LEFT
EDGE
THEN
IT
IS
A
PART
OF
E
OTHERWISE
IT
IS
A
PART
OF
LEFT
EDGE
AFTER
WE
DECIDED
WHETHER
E
OR
LEFT
EDGE
CONTRIBUTES
THE
EDGE
TO
C
WE
ADD
THE
APPROPRIATE
HALF
PLANE
TO
LLEFT
C
NOTICE
THAT
WE
MAY
ADD
TWO
HALF
PLANES
TO
LLEFT
C
THE
HALF
PLANE
BOUNDING
E
AND
THE
HALF
PLANE
BOUNDING
LEFT
EDGE
IN
WHICH
ORDER
SHOULD
WE
ADD
THEM
WE
ADD
LEFT
EDGE
ONLY
IF
IT
DEFINES
AN
EDGE
OF
C
STARTING
AT
THE
INTERSECTION
POINT
OF
LEFT
EDGE
AND
E
IF
WE
ALSO
DECIDE
TO
ADD
THE
HALF
PLANE
OF
E
IT
MUST
BE
BECAUSE
E
DEFINES
AN
EDGE
OF
C
STARTING
AT
ITS
UPPER
ENDPOINT
OR
AT
ITS
INTERSECTION
POINT
WITH
RIGHT
EDGE
IN
BOTH
CASES
WE
SHOULD
ADD
THE
HALF
PLANE
BOUNDING
E
FIRST
WHICH
IS
GUARANTEED
BY
THE
ORDER
OF
THE
TESTS
GIVEN
ABOVE
WE
CONCLUDE
THAT
IT
TAKES
CONSTANT
TIME
TO
HANDLE
AN
EDGE
SO
THE
INTERSECTION
OF
TWO
CONVEX
POLYGONS
CAN
BE
COMPUTED
IN
TIME
O
N
TO
SHOW
THAT
THE
ALGORITHM
IS
CORRECT
WE
HAVE
TO
PROVE
THAT
IT
ADDS
THE
HALF
PLANES
DEFINING
THE
EDGES
OF
C
IN
THE
RIGHT
ORDER
CONSIDER
AN
EDGE
OF
C
AND
LET
P
BE
ITS
UPPER
ENDPOINT
THEN
P
IS
EITHER
AN
UPPER
ENDPOINT
OF
AN
EDGE
IN
OR
OR
IT
IS
THE
INTERSECTION
OF
TWO
EDGES
E
AND
EL
OF
AND
RESPECTIVELY
IN
THE
FORMER
CASE
WE
DISCOVER
THE
EDGE
OF
C
WHEN
P
IS
REACHED
AND
IN
THE
LATTER
CASE
WHEN
THE
LOWER
OF
THE
UPPER
ENDPOINTS
OF
E
AND
EL
IS
REACHED
HENCE
ALL
HALF
PLANES
DEFINING
THE
EDGES
OF
C
ARE
ADDED
IT
IS
NOT
DIFFICULT
TO
PROVE
THAT
THEY
ARE
ADDED
IN
THE
CORRECT
ORDER
WE
GET
THE
FOLLOWING
RESULT
THEOREM
THE
INTERSECTION
OF
TWO
CONVEX
POLYGONAL
REGIONS
IN
THE
PLANE
CAN
BE
COMPUTED
IN
O
N
TIME
THIS
THEOREM
SHOWS
THAT
WE
CAN
DO
THE
MERGE
STEP
IN
INTERSECTHALF
PLANES
IN
LINEAR
TIME
HENCE
THE
RECURRENCE
FOR
THE
RUNNING
TIME
OF
THE
ALGORITHM
BECOMES
T
N
O
IF
N
O
N
N
IF
N
LEADING
TO
THE
FOLLOWING
RESULT
COROLLARY
THE
COMMON
INTERSECTION
OF
A
SET
OF
N
HALF
PLANES
IN
THE
PLANE
CAN
BE
COMPUTED
IN
O
N
LOG
N
TIME
AND
LINEAR
STORAGE
THE
PROBLEM
OF
COMPUTING
THE
INTERSECTION
OF
HALF
PLANES
IS
INTIMATELY
RELATED
TO
THE
COMPUTATION
OF
CONVEX
HULLS
AND
AN
ALTERNATIVE
ALGORITHM
CAN
BE
GIVEN
THAT
IS
ALMOST
IDENTICAL
TO
ALGORITHM
CONVEXHULL
FROM
CHAPTER
THE
RELATIONSHIP
BETWEEN
CONVEX
HULLS
AND
INTERSECTIONS
OF
HALF
PLANES
IS
DISCUSSED
IN
DETAIL
IN
SECTIONS
AND
THOSE
SECTIONS
ARE
INDEPENDENT
OF
THE
REST
OF
THEIR
CHAPTERS
SO
IF
YOU
ARE
CURIOUS
YOU
CAN
ALREADY
HAVE
A
LOOK
SECTION
INCREMENTAL
LINEAR
PROGRAMMING
INCREMENTAL
LINEAR
PROGRAMMING
IN
THE
PREVIOUS
SECTION
WE
SHOWED
HOW
TO
COMPUTE
THE
INTERSECTION
OF
A
SET
OF
N
HALF
PLANES
IN
OTHER
WORDS
WE
COMPUTED
ALL
SOLUTIONS
TO
A
SET
OF
N
LINEAR
CONSTRAINTS
THE
RUNNING
TIME
OF
OUR
ALGORITHM
WAS
O
N
LOG
N
ONE
CAN
PROVE
THAT
THIS
IS
OPTIMAL
AS
FOR
THE
SORTING
PROBLEM
ANY
ALGORITHM
THAT
SOLVES
THE
HALF
PLANE
INTERSECTION
PROBLEM
MUST
TAKE

N
LOG
N
TIME
IN
THE
WORST
CASE
IN
OUR
APPLICATION
TO
THE
CASTING
PROBLEM
HOWEVER
WE
DON
T
NEED
TO
KNOW
ALL
SOLUTIONS
TO
THE
SET
OF
LINEAR
CONSTRAINTS
JUST
ONE
SOLUTION
WILL
DO
FINE
IT
TURNS
OUT
THAT
THIS
ALLOWS
FOR
A
FASTER
ALGORITHM
FINDING
A
SOLUTION
TO
A
SET
OF
LINEAR
CONSTRAINTS
IS
CLOSELY
RELATED
TO
A
WELL
KNOWN
PROBLEM
IN
OPERATIONS
RESEARCH
CALLED
LINEAR
OPTIMIZATION
OR
LINEAR
PROGRAMMING
THIS
TERM
WAS
COINED
BEFORE
PROGRAMMING
CAME
TO
MEAN
GIVING
INSTRUCTIONS
TO
A
COMPUTER
THE
ONLY
DIFFERENCE
IS
THAT
LINEAR
PROGRAM
MING
INVOLVES
FINDING
ONE
SPECIFIC
SOLUTION
TO
THE
SET
OF
CONSTRAINTS
NAMELY
THE
ONE
THAT
MAXIMIZES
A
GIVEN
LINEAR
FUNCTION
OF
THE
VARIABLES
MORE
PRECISELY
A
LINEAR
OPTIMIZATION
PROBLEM
IS
DESCRIBED
AS
FOLLOWS
MAXIMIZE
CDXD
SUBJECT
TO
DXD
DXD
AN
AN
DXD
BN
WHERE
THE
CI
AND
AI
J
AND
BI
ARE
REAL
NUMBERS
WHICH
FORM
THE
INPUT
TO
THE
PROBLEM
THE
FUNCTION
TO
BE
MAXIMIZED
IS
CALLED
THE
OBJECTIVE
FUNCTION
AND
THE
SET
OF
CONSTRAINTS
TOGETHER
WITH
THE
OBJECTIVE
FUNCTION
IS
A
LINEAR
PROGRAM
THE
NUMBER
OF
VARIABLES
D
IS
THE
DIMENSION
OF
THE
LINEAR
PROGRAM
WE
ALREADY
SAW
THAT
LINEAR
CONSTRAINTS
CAN
BE
VIEWED
AS
HALF
SPACES
IN
RD
THE
INTERSECTION
OF
THESE
HALF
SPACES
WHICH
IS
THE
SET
OF
POINTS
SATISFYING
ALL
CONSTRAINTS
IS
CALLED
THE
FEASIBLE
REGION
OF
THE
LINEAR
PROGRAM
POINTS
SOLUTIONS
IN
THIS
REGION
ARE
CALLED
FEASIBLE
POINTS
OUTSIDE
ARE
INFEASIBLE
RECALL
FROM
FIGURE
THAT
THE
FEASIBLE
REGION
CAN
BE
UNBOUNDED
AND
THAT
IT
CAN
BE
EMPTY
IN
THE
LATTER
CASE
THE
LINEAR
PROGRAM
IS
CALLED
INFEASIBLE
THE
OBJECTIVE
FUNCTION
CAN
BE
VIEWED
AS
A
DIRECTION
IN
RD
MAXIMIZING
CDXD
MEANS
FINDING
CHAPTER
LINEAR
PROGRAMMING
FEASIBLE
REGION
FIGURE
DIFFERENT
TYPES
OF
SOLUTIONS
TO
A
LINEAR
PROGRAM
A
POINT
XD
THAT
IS
EXTREME
IN
THE
DIRECTION
C
CD
HENCE
THE
SOLUTION
TO
THE
LINEAR
PROGRAM
IS
A
POINT
IN
THE
FEASIBLE
REGION
THAT
IS
EXTREME
IN
DIRECTION
C
WE
LET
F
C
DENOTE
THE
OBJECTIVE
FUNCTION
DEFINED
BY
A
DIRECTION
VECTOR
C
MANY
PROBLEMS
IN
OPERATIONS
RESEARCH
CAN
BE
DESCRIBED
BY
LINEAR
PROGRAMS
AND
A
LOT
OF
WORK
HAS
BEEN
DEDICATED
TO
LINEAR
OPTIMIZATION
THIS
HAS
RESULTED
IN
MANY
DIFFERENT
LINEAR
PROGRAMMING
ALGORITHMS
SEVERAL
OF
WHICH
THE
FAMOUS
SIMPLEX
ALGORITHM
FOR
INSTANCE
PERFORM
WELL
IN
PRACTICE
LET
GO
BACK
TO
OUR
PROBLEM
WE
HAVE
N
LINEAR
CONSTRAINTS
IN
TWO
VARIABLES
AND
WE
WANT
TO
FIND
ONE
SOLUTION
TO
THE
SET
OF
CONSTRAINTS
WE
CAN
DO
THIS
BY
TAKING
AN
ARBITRARY
OBJECTIVE
FUNCTION
AND
THEN
SOLVING
THE
LINEAR
PROGRAM
DEFINED
BY
THE
OBJECTIVE
FUNCTION
AND
THE
LINEAR
CONSTRAINTS
FOR
THE
LATTER
STEP
WE
CAN
USE
THE
SIMPLEX
ALGORITHM
OR
ANY
OTHER
LINEAR
PROGRAMMING
ALGORITHM
DEVELOPED
IN
OPERATIONS
RESEARCH
HOWEVER
THIS
PARTICULAR
LINEAR
PROGRAM
IS
QUITE
DIFFERENT
FROM
THE
ONES
USUALLY
STUDIED
IN
OPERATIONS
RESEARCH
BOTH
THE
NUMBER
OF
CONSTRAINTS
AND
THE
NUMBER
OF
VARIABLES
ARE
LARGE
BUT
IN
OUR
CASE
THE
NUMBER
OF
VARIABLES
IS
ONLY
TWO
THE
TRADITIONAL
LINEAR
PROGRAMMING
METHODS
ARE
NOT
VERY
EFFICIENT
IN
SUCH
LOW
DIMENSIONAL
LINEAR
PROGRAMMING
PROBLEMS
METHODS
DEVELOPED
IN
COMPUTATIONAL
GEOMETRY
LIKE
THE
ONE
DESCRIBED
BELOW
DO
BETTER
WE
DENOTE
THE
SET
OF
N
LINEAR
CONSTRAINTS
IN
OUR
DIMENSIONAL
LINEAR
PROGRAM
MING
PROBLEM
BY
H
THE
VECTOR
DEFINING
THE
OBJECTIVE
FUNCTION
IS
C
CX
CY
THUS
THE
OBJECTIVE
FUNCTION
IS
F
C
P
CX
PX
CY
PY
OUR
GOAL
IS
TO
FIND
A
POINT
P
SUCH
THAT
P
H
AND
F
C
P
IS
MAXIMIZED
WE
DENOTE
THE
LINEAR
PROGRAM
BY
H
C
AND
WE
USE
C
TO
DENOTE
ITS
FEASIBLE
REGION
WE
CAN
DISTINGUISH
FOUR
CASES
FOR
THE
SOLUTION
OF
A
LINEAR
PROGRAM
H
C
THE
FOUR
CASES
ARE
ILLUSTRATED
IN
FIGURE
THE
VECTOR
DEFINING
THE
OBJECTIVE
FUNCTION
IS
VERTICALLY
DOWNWARD
IN
THE
EXAMPLES
I
II
III
IV
I
THE
LINEAR
PROGRAM
IS
INFEASIBLE
THAT
IS
THERE
IS
NO
SOLUTION
TO
THE
SET
OF
CONSTRAINTS
II
THE
FEASIBLE
REGION
IS
UNBOUNDED
IN
DIRECTION
C
IN
THIS
CASE
THERE
IS
A
RAY

COMPLETELY
CONTAINED
IN
THE
FEASIBLE
REGION
C
SUCH
THAT
THE
FUNCTION
F
C
TAKES
ARBITRARILY
LARGE
VALUES
ALONG

THE
SOLUTION
WE
REQUIRE
IN
THIS
CASE
IS
THE
DESCRIPTION
OF
SUCH
A
RAY
III
THE
FEASIBLE
REGION
HAS
AN
EDGE
E
WHOSE
OUTWARD
NORMAL
POINTS
IN
THE
DIRECTION
C
IN
THIS
CASE
THERE
IS
A
SOLUTION
TO
THE
LINEAR
PROGRAM
BUT
IT
IS
NOT
UNIQUE
ANY
POINT
ON
E
IS
A
FEASIBLE
POINT
THAT
MAXIMIZES
F
C
P
IV
IF
NONE
OF
THE
PRECEDING
THREE
CASES
APPLIES
THEN
THERE
IS
A
UNIQUE
SOLUTION
WHICH
IS
THE
VERTEX
V
OF
C
THAT
IS
EXTREME
IN
THE
DIRECTION
C
OUR
ALGORITHM
FOR
DIMENSIONAL
LINEAR
PROGRAMMING
IS
INCREMENTAL
IT
ADDS
THE
CONSTRAINTS
ONE
BY
ONE
AND
MAINTAINS
THE
OPTIMAL
SOLUTION
TO
THE
INTERMEDIATE
LINEAR
PROGRAMS
IT
REQUIRES
HOWEVER
THAT
THE
SOLUTION
TO
EACH
INTERMEDIATE
PROBLEM
IS
WELL
DEFINED
AND
UNIQUE
IN
OTHER
WORDS
IT
ASSUMES
THAT
EACH
INTERMEDIATE
FEASIBLE
REGION
HAS
A
UNIQUE
OPTIMAL
VERTEX
AS
IN
CASE
IV
ABOVE
TO
FULFILL
THIS
REQUIREMENT
WE
ADD
TO
OUR
LINEAR
PROGRAM
TWO
ADDITIONAL
CONSTRAINTS
THAT
WILL
GUARANTEE
THAT
THE
LINEAR
PROGRAM
IS
BOUNDED
FOR
EXAMPLE
IF
CX
AND
CY
WE
ADD
THE
CONTRAINTS
PX
M
AND
PY
M
FOR
SOME
LARGE
M
R
THE
IDEA
IS
THAT
M
SHOULD
BE
CHOSEN
SO
LARGE
THAT
THE
ADDITIONAL
CONSTRAINTS
DO
NOT
INFLUENCE
THE
OPTIMAL
SOLUTION
IF
THE
ORIGINAL
LINEAR
PROGRAM
WAS
BOUNDED
IN
MANY
PRACTICAL
APPLICATIONS
OF
LINEAR
PROGRAMMING
A
BOUND
OF
THIS
FORM
IS
ACTUALLY
A
NATURAL
RESTRICTION
IN
OUR
APPLICATION
TO
THE
CASTING
PROBLEM
FOR
INSTANCE
MECHANICAL
LIMITATIONS
WILL
NOT
ALLOW
US
TO
REMOVE
THE
POLYHEDRON
IN
A
DIRECTION
THAT
IS
NEARLY
HORIZONTAL
FOR
INSTANCE
WE
MAY
NOT
BE
ABLE
TO
REMOVE
THE
POLYHEDRON
IN
A
DIRECTION
WHOSE
ANGLE
WITH
THE
XY
PLANE
IS
LESS
THAN
DEGREE
THIS
CONSTRAINT
IMMEDIATELY
GIVES
A
BOUND
ON
THE
ABSOLUTE
VALUE
OF
PX
PY
WE
WILL
DISCUSS
IN
SECTION
HOW
WE
CAN
CORRECTLY
RECOGNIZE
UNBOUNDED
LINEAR
PROGRAMS
AND
HOW
WE
CAN
SOLVE
BOUNDED
ONES
WITHOUT
ENFORCING
ARTIFICIAL
CONSTRAINTS
ON
THE
SOLUTION
FOR
PRECISENESS
LET
GIVE
A
NAME
TO
THE
TWO
NEW
CONSTRAINTS
PX
M
IF
CX
PX
M
OTHERWISE
SECTION
INCREMENTAL
LINEAR
PROGRAMMING
AND
PY
M
IF
CY
PY
M
OTHERWISE
NOTE
THAT
ARE
CHOSEN
AS
A
FUNCTION
OF
C
ONLY
THEY
DO
NOT
DEPEND
ON
THE
HALF
PLANES
H
THE
FEASIBLE
REGION
IS
AN
ORTHOGONAL
WEDGE
ANOTHER
SIMPLE
CONVENTION
NOW
ALLOWS
US
TO
SAY
THAT
CASE
III
ALSO
HAS
A
UNIQUE
SOLUTION
IF
THERE
ARE
SEVERAL
OPTIMAL
POINTS
THEN
WE
WANT
THE
LEXICO
GRAPHICALLY
SMALLEST
ONE
CONCEPTUALLY
THIS
CONVENTION
IS
EQUIVALENT
TO
ROTATING
C
A
LITTLE
SUCH
THAT
IT
IS
NO
LONGER
NORMAL
TO
ANY
HALF
PLANE
WE
HAVE
TO
BE
CAREFUL
WHEN
DOING
THIS
AS
EVEN
A
BOUNDED
LINEAR
PROGRAM
MAY
NOT
HAVE
A
LEXICOGRAPHICALLY
SMALLEST
SOLUTION
SEE
EXERCISE
OUR
CHOICE
OF
THE
TWO
CONSTRAINTS
AND
IS
SUCH
THAT
THIS
CANNOT
HAPPEN
WITH
THESE
TWO
CONVENTIONS
ANY
LINEAR
PROGRAM
THAT
IS
FEASIBLE
HAS
A
UNIQUE
SOLUTION
WHICH
IS
A
VERTEX
OF
THE
FEASIBLE
REGION
WE
CALL
THIS
VERTEX
THE
OPTIMAL
VERTEX
LET
H
C
BE
A
LINEAR
PROGRAM
WE
NUMBER
THE
HALF
PLANES
HN
LET
HI
BE
THE
SET
OF
THE
FIRST
I
CONSTRAINTS
TOGETHER
WITH
THE
SPECIAL
CONSTRAINTS
AND
AND
LET
CI
BE
THE
FEASIBLE
REGION
DEFINED
BY
THESE
CONSTRAINTS
HI
HI
CI
HI
CHAPTER
LINEAR
PROGRAMMING
BY
OUR
CHOICE
OF
EACH
FEASIBLE
REGION
CI
HAS
A
UNIQUE
OPTIMAL
VERTEX
DENOTED
VI
CLEARLY
WE
HAVE
CN
C
THIS
IMPLIES
THAT
IF
CI
FOR
SOME
I
THEN
CJ
FOR
ALL
J
I
AND
THE
LINEAR
PROGRAM
IS
INFEASIBLE
SO
OUR
ALGORITHM
CAN
STOP
ONCE
THE
LINEAR
PROGRAM
BECOMES
INFEASIBLE
THE
NEXT
LEMMA
INVESTIGATES
HOW
THE
OPTIMAL
VERTEX
CHANGES
WHEN
WE
ADD
A
HALF
PLANE
HI
IT
IS
THE
BASIS
OF
OUR
ALGORITHM
LEMMA
LET
I
N
AND
LET
CI
AND
VI
BE
DEFINED
AS
ABOVE
THEN
WE
HAVE
I
IF
VI
HI
THEN
VI
VI
II
IF
VI
HI
THEN
EITHER
CI
OR
VI
FI
WHERE
FI
IS
THE
LINE
BOUNDING
HI
PROOF
I
LET
VI
HI
BECAUSE
CI
CI
HI
AND
VI
CI
THIS
MEANS
THAT
VI
CI
FURTHERMORE
THE
OPTIMAL
POINT
IN
CI
CANNOT
BE
BETTER
THAN
THE
OPTIMAL
POINT
IN
CI
SINCE
CI
CI
HENCE
VI
IS
THE
OPTIMAL
VERTEX
IN
CI
AS
WELL
II
LET
VI
HI
SUPPOSE
FOR
A
CONTRADICTION
THAT
CI
IS
NOT
EMPTY
AND
THAT
VI
DOES
NOT
LIE
ON
FI
CONSIDER
THE
LINE
SEGMENT
VI
WE
HAVE
VI
CI
AND
SINCE
CI
CI
ALSO
VI
CI
TOGETHER
WITH
THE
CONVEXITY
OF
CI
THIS
IMPLIES
THAT
THE
SEGMENT
VI
IS
CONTAINED
IN
CI
SINCE
VI
IS
THE
OPTIMAL
POINT
IN
CI
AND
THE
OBJECTIVE
FUNCTION
F
C
IS
LINEAR
IT
FOLLOWS
THAT
F
C
P
INCREASES
MONOTONICALLY
ALONG
VI
AS
P
MOVES
FROM
VI
TO
VI
NOW
CONSIDER
THE
INTERSECTION
POINT
Q
OF
VI
AND
FI
THIS
INTERSECTION
POINT
EXISTS
BECAUSE
VI
HI
AND
VI
CI
SINCE
VI
IS
CONTAINED
IN
CI
THE
POINT
Q
MUST
BE
IN
CI
BUT
THE
VALUE
OF
THE
OBJECTIVE
FUNCTION
INCREASES
ALONG
VI
SO
F
C
Q
F
C
VI
THIS
CONTRADICTS
THE
DEFINITION
OF
VI
FIGURE
ILLUSTRATES
THE
TWO
CASES
THAT
ARISE
WHEN
ADDING
A
HALF
PLANE
IN
FIGURE
I
THE
OPTIMAL
VERTEX
THAT
WE
HAVE
AFTER
ADDING
THE
FIRST
FOUR
HALF
PLANES
IS
CONTAINED
IN
THE
NEXT
HALF
PLANE
THAT
WE
ADD
THEREFORE
THE
OPTIMAL
VERTEX
REMAINS
THE
SAME
THE
OPTIMAL
VERTEX
IS
NOT
CONTAINED
IN
HOWEVER
SO
WHEN
WE
ADD
WE
MUST
FIND
A
NEW
OPTIMAL
VERTEX
ACCORDING
I
II
C
FIGURE
ADDING
A
HALF
PLANE
TO
LEMMA
THIS
VERTEX
IS
CONTAINED
IN
THE
LINE
BOUNDING
AS
IS
SHOWN
IN
FIGURE
II
BUT
LEMMA
DOES
NOT
TELL
US
HOW
TO
FIND
THE
NEW
OPTIMAL
VERTEX
FORTUNATELY
THIS
IS
NOT
SO
DIFFICULT
AS
WE
SHOW
NEXT
ASSUME
THAT
THE
CURRENT
OPTIMAL
VERTEX
VI
IS
NOT
CONTAINED
IN
THE
NEXT
HALF
PLANE
HI
THE
PROBLEM
WE
HAVE
TO
SOLVE
CAN
BE
STATED
AS
FOLLOWS
FIND
THE
POINT
P
ON
FI
THAT
MAXIMIZES
F
C
P
SUBJECT
TO
THE
CON
STRAINTS
P
H
FOR
H
HI
TO
SIMPLIFY
THE
TERMINOLOGY
WE
ASSUME
THAT
FI
IS
NOT
VERTICAL
AND
SO
WE
CAN
PARAMETERIZE
IT
BY
X
COORDINATE
WE
CAN
THEN
DEFINE
A
FUNCTION
F
C
R
R
SUCH
THAT
F
C
P
F
C
PX
FOR
POINTS
P
FI
FOR
A
HALF
PLANE
H
LET

H
FI
BE
THE
X
COORDINATE
OF
THE
INTERSECTION
POINT
OF
FI
AND
THE
BOUNDING
LINE
OF
H
IF
THERE
IS
NO
INTERSECTION
THEN
EITHER
THE
CONSTRAINT
H
IS
SATISFIED
BY
ANY
POINT
ON
FI
OR
BY
NO
POINT
ON
FI
IN
THE
FORMER
CASE
WE
CAN
IGNORE
THE
CONSTRAINT
IN
THE
LATTER
CASE
WE
CAN
REPORT
THE
LINEAR
PROGRAM
INFEASIBLE
DEPENDING
ON
WHETHER
FI
H
IS
BOUNDED
TO
THE
LEFT
OR
TO
THE
RIGHT
WE
GET
A
CONSTRAINT
ON
THE
X
COORDINATE
OF
THE
SOLUTION
OF
THE
FORM
X

H
FI
OR
OF
THE
FORM
X

H
FI
WE
CAN
THUS
RESTATE
OUR
PROBLEM
AS
FOLLOWS
MAXIMIZE
F
C
X
SUBJECT
TO
X

H
FI
H
HI
AND
FI
H
IS
BOUNDED
TO
THE
LEFT
X

H
FI
H
HI
AND
FI
H
IS
BOUNDED
TO
THE
RIGHT
THIS
IS
A
DIMENSIONAL
LINEAR
PROGRAM
SOLVING
IT
IS
VERY
EASY
LET
XLEFT
MAX

H
FI
FI
H
IS
BOUNDED
TO
THE
LEFT
H
HI
SECTION
INCREMENTAL
LINEAR
PROGRAMMING
AND
XRIGHT
MIN

H
FI
FI
H
IS
BOUNDED
TO
THE
RIGHT
HI
THE
INTERVAL
XLEFT
XRIGHT
IS
THE
FEASIBLE
REGION
OF
THE
DIMENSIONAL
LINEAR
X

H
FI
PROGRAM
HENCE
THE
LINEAR
PROGRAM
IS
INFEASIBLE
IF
XLEFT
XRIGHT
AND
OTHERWISE
THE
OPTIMAL
POINT
IS
THE
POINT
ON
FI
AT
EITHER
XLEFT
OR
XRIGHT
DEPENDING
ON
THE
OBJECTIVE
FUNCTION
NOTE
THAT
THE
DIMENSIONAL
LINEAR
PROGRAM
CANNOT
BE
UNBOUNDED
DUE
TO
THE
CONSTRAINTS
AND
WE
GET
THE
FOLLOWING
LEMMA
LEMMA
A
DIMENSIONAL
LINEAR
PROGRAM
CAN
BE
SOLVED
IN
LINEAR
TIME
HENCE
IF
CASE
II
OF
LEMMA
ARISES
THEN
WE
CAN
COMPUTE
THE
NEW
OPTIMAL
VERTEX
VI
OR
DECIDE
THAT
THE
LINEAR
PROGRAM
IS
INFEASIBLE
IN
O
I
TIME

H
FI
FI
WE
CAN
NOW
DESCRIBE
THE
LINEAR
PROGRAMMING
ALGORITHM
IN
MORE
DETAIL
AS
ABOVE
WE
USE
FI
TO
DENOTE
THE
LINE
THAT
BOUNDS
THE
HALF
PLANE
HI
ALGORITHM
H
C
INPUT
A
LINEAR
PROGRAM
H
C
WHERE
H
IS
A
SET
OF
N
HALF
PLANES
C
AND
BOUND
THE
SOLUTION
OUTPUT
IF
H
C
IS
INFEASIBLE
THEN
THIS
FACT
IS
REPORTED
OTHERWISE
THE
LEXICOGRAPHICALLY
SMALLEST
POINT
P
THAT
MAXIMIZES
F
C
P
IS
REPORTED
CHAPTER
LINEAR
PROGRAMMING
LET
BE
THE
CORNER
OF
LET
HN
BE
THE
HALF
PLANES
OF
H
FOR
I
TO
N
DO
IF
VI
HI
THEN
VI
VI
ELSE
VI
THE
POINT
P
ON
FI
THAT
MAXIMIZES
F
C
P
SUBJECT
TO
THE
CONSTRAINTS
IN
HI
IF
P
DOES
NOT
EXIST
THEN
REPORT
THAT
THE
LINEAR
PROGRAM
IS
INFEASIBLE
AND
QUIT
RETURN
VN
WE
NOW
ANALYZE
THE
PERFORMANCE
OF
OUR
ALGORITHM
LEMMA
ALGORITHM
COMPUTES
THE
SOLUTION
TO
A
BOUNDED
LINEAR
PROGRAM
WITH
N
CONSTRAINTS
AND
TWO
VARIABLES
IN
O
TIME
AND
LINEAR
STORAGE
PROOF
TO
PROVE
THAT
THE
ALGORITHM
CORRECTLY
FINDS
THE
SOLUTION
WE
HAVE
TO
SHOW
THAT
AFTER
EVERY
STAGE
WHENEVER
WE
HAVE
ADDED
A
NEW
HALF
PLANE
HI
THE
POINT
VI
IS
STILL
THE
OPTIMUM
POINT
FOR
CI
THIS
FOLLOWS
IMMEDIATELY
FROM
LEMMA
IF
THE
DIMENSIONAL
LINEAR
PROGRAM
ON
FI
IS
INFEASIBLE
THEN
CI
IS
EMPTY
AND
CONSEQUENTLY
C
CN
CI
IS
EMPTY
WHICH
MEANS
THAT
THE
LINEAR
PROGRAM
IS
INFEASIBLE
IT
IS
EASY
TO
SEE
THAT
THE
ALGORITHM
REQUIRES
ONLY
LINEAR
STORAGE
WE
ADD
THE
HALF
PLANES
ONE
BY
ONE
IN
N
STAGES
THE
TIME
SPENT
IN
STAGE
I
IS
DOMINATED
BY
THE
TIME
TO
SOLVE
A
DIMENSIONAL
LINEAR
PROGRAM
IN
LINE
WHICH
IS
O
I
HENCE
THE
TOTAL
TIME
NEEDED
IS
BOUNDED
BY
N
O
I
O
I
ALTHOUGH
OUR
LINEAR
PROGRAMMING
ALGORITHM
IS
NICE
AND
SIMPLE
ITS
RUNNING
TIME
IS
DISAPPOINTING
THE
ALGORITHM
IS
MUCH
SLOWER
THAN
THE
PREVIOUS
ALGORITHM
C
VN
HN
WHICH
COMPUTED
THE
WHOLE
FEASIBLE
REGION
IS
OUR
ANALYSIS
TOO
CRUDE
WE
BOUNDED
THE
COST
OF
EVERY
STAGE
I
BY
O
I
THIS
IS
NOT
ALWAYS
A
TIGHT
BOUND
STAGE
I
TAKES

I
TIME
ONLY
WHEN
VI
HI
WHEN
VI
HI
THEN
STAGE
I
TAKES
CONSTANT
TIME
SO
IF
WE
COULD
BOUND
THE
NUMBER
OF
TIMES
THE
OPTIMAL
VERTEX
CHANGES
WE
MIGHT
BE
ABLE
TO
PROVE
A
BETTER
RUNNING
TIME
UNFORTUNATELY
THE
OPTIMUM
VERTEX
CAN
CHANGE
N
TIMES
THERE
ARE
ORDERS
FOR
SOME
CONFIGURATIONS
WHERE
EVERY
NEW
HALF
PLANE
MAKES
THE
PREVIOUS
OPTIMUM
ILLEGAL
THE
FIGURE
IN
THE
MARGIN
SHOWS
SUCH
AN
EXAMPLE
THIS
MEANS
THAT
THE
ALGORITHM
WILL
REALLY
SPEND

TIME
HOW
CAN
WE
AVOID
THIS
NASTY
SITUATION
RANDOMIZED
LINEAR
PROGRAMMING
IF
WE
HAVE
A
SECOND
LOOK
AT
THE
EXAMPLE
WHERE
THE
OPTIMUM
CHANGES
N
TIMES
WE
SEE
THAT
THE
PROBLEM
IS
NOT
SO
MUCH
THAT
THE
SET
OF
HALF
PLANES
IS
BAD
IF
WE
HAD
ADDED
THEM
IN
THE
ORDER
HN
HN
THEN
THE
OPTIMAL
VERTEX
WOULD
NOT
CHANGE
ANYMORE
AFTER
THE
ADDITION
OF
HN
IN
THIS
CASE
THE
RUNNING
TIME
WOULD
BE
O
N
IS
THIS
A
GENERAL
PHENOMENON
IS
IT
TRUE
THAT
FOR
ANY
SET
H
OF
HALF
PLANES
THERE
IS
A
GOOD
ORDER
TO
TREAT
THEM
THE
ANSWER
TO
THIS
QUESTION
IS
YES
BUT
THAT
DOESN
T
SEEM
TO
HELP
US
MUCH
EVEN
IF
SUCH
A
GOOD
ORDER
EXISTS
THERE
SEEMS
TO
BE
NO
EASY
WAY
TO
ACTUALLY
FIND
IT
REMEMBER
THAT
WE
HAVE
TO
FIND
THE
ORDER
AT
THE
BEGINNING
OF
THE
ALGORITHM
WHEN
WE
DON
T
KNOW
ANYTHING
ABOUT
THE
INTERSECTION
OF
THE
HALF
PLANES
YET
WE
NOW
MEET
A
QUITE
INTRIGUING
PHENOMENON
ALTHOUGH
WE
HAVE
NO
WAY
TO
DETERMINE
AN
ORDERING
OF
H
THAT
IS
GUARANTEED
TO
LEAD
TO
A
GOOD
RUNNING
TIME
WE
HAVE
A
VERY
SIMPLE
WAY
OUT
OF
OUR
PROBLEM
WE
SIMPLY
PICK
A
RANDOM
ORDERING
OF
H
OF
COURSE
WE
COULD
HAVE
BAD
LUCK
AND
PICK
AN
ORDER
THAT
LEADS
TO
A
QUADRATIC
RUNNING
TIME
BUT
WITH
SOME
LUCK
WE
PICK
AN
ORDER
THAT
MAKES
IT
RUN
MUCH
FASTER
INDEED
WE
SHALL
PROVE
BELOW
THAT
MOST
ORDERS
LEAD
TO
A
FAST
ALGORITHM
FOR
COMPLETENESS
WE
FIRST
REPEAT
THE
ALGORITHM
ALGORITHM
H
C
INPUT
A
LINEAR
PROGRAM
H
C
WHERE
H
IS
A
SET
OF
N
HALF
PLANES
C
AND
BOUND
THE
SOLUTION
OUTPUT
IF
H
C
IS
INFEASIBLE
THEN
THIS
FACT
IS
REPORTED
OTHERWISE
THE
LEXICOGRAPHICALLY
SMALLEST
POINT
P
THAT
MAXIMIZES
F
C
P
IS
REPORTED
LET
BE
THE
CORNER
OF
COMPUTE
A
RANDOM
PERMUTATION
HN
OF
THE
HALF
PLANES
BY
CALLING
RANDOMPERMUTATION
H
N
FOR
I
TO
N
DO
IF
VI
HI
THEN
VI
VI
ELSE
VI
THE
POINT
P
ON
FI
THAT
MAXIMIZES
F
C
P
SUBJECT
TO
THE
CONSTRAINTS
IN
HI
IF
P
DOES
NOT
EXIST
THEN
REPORT
THAT
THE
LINEAR
PROGRAM
IS
INFEASIBLE
AND
QUIT
RETURN
VN
THE
ONLY
DIFFERENCE
FROM
THE
PREVIOUS
ALGORITHM
IS
IN
LINE
WHERE
WE
PUT
THE
HALF
PLANES
IN
RANDOM
ORDER
BEFORE
WE
START
ADDING
THEM
ONE
BY
ONE
TO
BE
ABLE
TO
DO
THIS
WE
ASSUME
THAT
WE
HAVE
A
RANDOM
NUMBER
GENERATOR
RANDOM
K
WHICH
HAS
AN
INTEGER
K
AS
INPUT
AND
GENERATES
A
RANDOM
INTEGER
BETWEEN
AND
K
IN
CONSTANT
TIME
COMPUTING
A
RANDOM
PERMUTATION
CAN
THEN
BE
DONE
WITH
THE
FOLLOWING
LINEAR
TIME
ALGORITHM
ALGORITHM
RANDOMPERMUTATION
A
INPUT
AN
ARRAY
A
N
OUTPUT
THE
ARRAY
A
N
WITH
THE
SAME
ELEMENTS
BUT
REARRANGED
INTO
A
RANDOM
PERMUTATION
FOR
K
N
DOWNTO
DO
RNDINDEX
RANDOM
K
SECTION
RANDOMIZED
LINEAR
PROGRAMMING
EXCHANGE
A
K
AND
A
RNDINDEX
CHAPTER
LINEAR
PROGRAMMING
THE
NEW
LINEAR
PROGRAMMING
ALGORITHM
IS
CALLED
A
RANDOMIZED
ALGORITHM
ITS
RUNNING
TIME
DEPENDS
ON
CERTAIN
RANDOM
CHOICES
MADE
BY
THE
ALGORITHM
IN
THE
LINEAR
PROGRAMMING
ALGORITHM
THESE
RANDOM
CHOICES
WERE
MADE
IN
THE
SUBROUTINE
RANDOMPERMUTATION
WHAT
IS
THE
RUNNING
TIME
OF
THIS
RANDOMIZED
VERSION
OF
OUR
INCREMENTAL
LINEAR
PROGRAMMING
ALGORITHM
THERE
IS
NO
EASY
ANSWER
TO
THAT
IT
ALL
DEPENDS
ON
THE
ORDER
THAT
IS
COMPUTED
IN
LINE
CONSIDER
A
FIXED
SET
H
OF
N
HALF
PLANES
TREATS
THEM
DEPENDING
ON
THE
PERMUTATION
CHO
SEN
IN
LINE
SINCE
THERE
ARE
N
POSSIBLE
PERMUTATIONS
OF
N
OBJECTS
THERE
ARE
N
POSSIBLE
WAYS
IN
WHICH
THE
ALGORITHM
CAN
PROCEED
EACH
WITH
ITS
OWN
RUN
NING
TIME
BECAUSE
THE
PERMUTATION
IS
RANDOM
EACH
OF
THESE
RUNNING
TIMES
IS
EQUALLY
LIKELY
SO
WHAT
WE
DO
IS
ANALYZE
THE
EXPECTED
RUNNING
TIME
OF
THE
ALGORITHM
WHICH
IS
THE
AVERAGE
RUNNING
TIME
OVER
ALL
N
POSSIBLE
PERMUTATIONS
THE
LEMMA
BELOW
STATES
THAT
THE
EXPECTED
RUNNING
TIME
OF
OUR
RANDOMIZED
LINEAR
PROGRAMMING
ALGORITHM
IS
O
N
IT
IS
IMPORTANT
TO
REALIZE
THAT
WE
DO
NOT
MAKE
ANY
ASSUMPTIONS
ABOUT
THE
INPUT
THE
EXPECTANCY
IS
WITH
RESPECT
TO
THE
RANDOM
ORDER
IN
WHICH
THE
HALF
PLANES
ARE
TREATED
AND
HOLDS
FOR
ANY
SET
OF
HALF
PLANES
LEMMA
THE
DIMENSIONAL
LINEAR
PROGRAMMING
PROBLEM
WITH
N
CONSTRAINTS
CAN
BE
SOLVED
IN
O
N
RANDOMIZED
EXPECTED
TIME
USING
WORST
CASE
LINEAR
STORAGE
PROOF
AS
WE
OBSERVED
BEFORE
THE
STORAGE
NEEDED
BY
THE
ALGORITHM
IS
LINEAR
THE
RUNNING
TIME
RANDOMPERMUTATION
IS
O
N
SO
WHAT
REMAINS
IS
TO
ANALYZE
THE
TIME
NEEDED
TO
ADD
THE
HALF
PLANES
HN
ADDING
A
HALF
PLANE
TAKES
CONSTANT
TIME
WHEN
THE
OPTIMAL
VERTEX
DOES
NOT
CHANGE
WHEN
THE
OPTIMAL
VERTEX
DOES
CHANGE
WE
NEED
TO
SOLVE
A
DIMENSIONAL
LINEAR
PROGRAM
WE
NOW
BOUND
THE
TIME
NEEDED
FOR
ALL
THESE
DIMENSIONAL
LINEAR
PROGRAMS
LET
XI
BE
A
RANDOM
VARIABLE
WHICH
IS
IF
VI
HI
AND
OTHERWISE
RECALL
THAT
A
DIMENSIONAL
LINEAR
PROGRAM
ON
I
CONSTRAINTS
CAN
BE
SOLVED
IN
O
I
TIME
THE
TOTAL
TIME
SPENT
IN
LINE
OVER
ALL
HALF
PLANES
HN
IS
THEREFORE
N
O
I
XI
I
TO
BOUND
THE
EXPECTED
VALUE
OF
THIS
SUM
WE
WILL
USE
LINEARITY
OF
EXPECTATION
THE
EXPECTED
VALUE
OF
A
SUM
OF
RANDOM
VARIABLES
IS
THE
SUM
OF
THE
EXPECTED
VALUES
OF
THE
RANDOM
VARIABLES
THIS
HOLDS
EVEN
IF
THE
RANDOM
VARIABLES
ARE
DEPENDENT
HENCE
THE
EXPECTED
TIME
FOR
SOLVING
ALL
DIMENSIONAL
LINEAR
PROGRAMS
IS
C
N
N
E
O
I
XI
O
I
E
XI
I
I
HALF
PLANES
DEFINING
VN
BUT
WHAT
IS
E
XI
IT
IS
EXACTLY
THE
PROBABILITY
THAT
VI
HI
LET
ANALYZE
THIS
PROBABILITY
WE
WILL
DO
THIS
WITH
A
TECHNIQUE
CALLED
BACKWARDS
ANALYSIS
WE
LOOK
AT
THE
ALGORITHM
BACKWARDS
ASSUME
THAT
IT
HAS
ALREADY
FINISHED
AND
THAT
IT
HAS
COMPUTED
THE
OPTIMUM
VERTEX
VN
SINCE
VN
IS
A
VERTEX
OF
CN
IT
IS
DEFINED
BY
AT
LEAST
TWO
OF
THE
HALF
PLANES
NOW
WE
MAKE
ONE
STEP
BACKWARDS
IN
TIME
AND
LOOK
AT
CN
NOTE
THAT
CN
IS
OBTAINED
FROM
CN
BY
REMOVING
THE
HALF
PLANE
HN
WHEN
DOES
THE
OPTIMUM
POINT
CHANGE
THIS
HAPPENS
EXACTLY
IF
VN
IS
NOT
A
VERTEX
OF
CN
THAT
IS
EXTREME
IN
THE
DIRECTION
C
WHICH
IS
ONLY
POSSIBLE
IF
HN
IS
ONE
OF
THE
HALF
PLANES
THAT
DEFINE
VN
BUT
THE
HALF
PLANES
ARE
ADDED
IN
RANDOM
ORDER
SO
HN
IS
A
RANDOM
ELEMENT
OF
HN
HENCE
THE
PROBABILITY
THAT
HN
IS
ONE
OF
THE
HALF
PLANES
DEFINING
VN
IS
AT
MOST
N
WHY
DO
WE
SAY
AT
MOST
FIRST
IT
IS
POSSIBLE
THAT
THE
BOUNDARIES
OF
MORE
THAN
TWO
HALF
PLANES
PASS
THROUGH
VN
IN
THAT
CASE
REMOVING
ONE
OF
THE
TWO
HALF
PLANES
CONTAINING
THE
EDGES
INCIDENT
TO
VN
MAY
FAIL
TO
CHANGE
VN
FURTHERMORE
VN
MAY
BE
DEFINED
BY
OR
WHICH
ARE
NOT
AMONG
THE
N
CANDIDATES
FOR
THE
RANDOM
CHOICE
OF
HN
IN
BOTH
CASES
THE
PROBABILITY
IS
LESS
THAN
N
THE
SAME
ARGUMENT
WORKS
IN
GENERAL
TO
BOUND
E
XI
WE
FIX
THE
SUBSET
OF
THE
FIRST
I
HALF
PLANES
THIS
DETERMINES
CI
TO
ANALYZE
WHAT
HAPPENED
IN
THE
LAST
STEP
WHEN
WE
ADDED
HI
WE
THINK
BACKWARDS
THE
PROBABILITY
THAT
WE
HAD
TO
COMPUTE
A
NEW
OPTIMAL
VERTEX
WHEN
ADDING
HI
IS
THE
SAME
AS
THE
PROBABILITY
THAT
THE
OPTIMAL
VERTEX
CHANGES
WHEN
WE
REMOVE
A
HALF
PLANE
FROM
CI
THE
LATTER
EVENT
ONLY
TAKES
PLACE
FOR
AT
MOST
TWO
HALF
PLANES
OF
OUR
FIXED
SET
HI
SINCE
THE
HALF
PLANES
ARE
ADDED
IN
RANDOM
ORDER
THE
PROBABILITY
THAT
HI
IS
ONE
OF
THE
SPECIAL
HALF
PLANES
IS
AT
MOST
I
WE
DERIVED
THIS
PROBABILITY
UNDER
THE
CONDITION
THAT
THE
FIRST
I
HALF
PLANES
ARE
SOME
FIXED
SUBSET
OF
H
BUT
SINCE
THE
DERIVED
BOUND
HOLDS
FOR
ANY
FIXED
SUBSET
IT
HOLDS
UNCONDITIONALLY
HENCE
E
XI
I
WE
CAN
NOW
BOUND
THE
EXPECTED
TOTAL
TIME
FOR
SOLVING
ALL
DIMENSIONAL
LINEAR
PROGRAMS
BY
SECTION
UNBOUNDED
LINEAR
PROGRAMS
N
O
I
O
N
I
WE
ALREADY
NOTED
THAT
THE
TIME
SPENT
IN
THE
REST
OF
THE
ALGORITHM
IS
O
N
AS
WELL
NOTE
AGAIN
THAT
THE
EXPECTANCY
HERE
IS
SOLELY
WITH
RESPECT
TO
THE
RANDOM
CHOICES
MADE
BY
THE
ALGORITHM
WE
DO
NOT
AVERAGE
OVER
POSSIBLE
CHOICES
FOR
THE
INPUT
FOR
ANY
INPUT
SET
OF
N
HALF
PLANES
THE
EXPECTED
RUNNING
TIME
OF
THE
ALGORITHM
IS
O
N
THERE
ARE
NO
BAD
INPUTS
UNBOUNDED
LINEAR
PROGRAMS
IN
THE
PRECEDING
SECTIONS
WE
AVOIDED
HANDLING
THE
CASE
OF
AN
UNBOUNDED
LINEAR
PROGRAM
BY
ADDING
TWO
ADDITIONAL
ARTIFICIAL
CONSTRAINTS
THIS
IS
NOT
ALWAYS
A
SUITABLE
SOLUTION
EVEN
IF
THE
LINEAR
PROGRAM
IS
BOUNDED
WE
MAY
NOT
KNOW
A
LARGE
ENOUGH
BOUND
M
FURTHERMORE
UNBOUNDED
LINEAR
PROGRAMS
DO
OCCUR
IN
PRACTICE
AND
WE
HAVE
TO
SOLVE
THEM
CORRECTLY
LET
FIRST
SEE
HOW
WE
CAN
RECOGNIZE
WHETHER
A
GIVEN
LINEAR
PROGRAM
H
C
IS
UNBOUNDED
AS
WE
SAW
BEFORE
THAT
MEANS
THAT
THERE
IS
A
RAY

COMPLETELY
CHAPTER
LINEAR
PROGRAMMING
CONTAINED
IN
THE
FEASIBLE
REGION
C
SUCH
THAT
THE
FUNCTION
F
C
TAKES
ARBITRARILY
LARGE
VALUES
ALONG

IF
WE
DENOTE
THE
RAY
STARTING
POINT
AS
P
AND
ITS
DIRECTION
VECTOR
AS
D
WE
CAN
PARAMETERIZE

AS
FOLLOWS

P

D

THE
FUNCTION
F
C
TAKES
ARBITRARILY
LARGE
VALUES
IF
AND
ONLY
IF
D
C
ON
THE
OTHER
HAND
IF

H
IS
THE
NORMAL
VECTOR
OF
A
HALF
PLANE
H
H
ORIENTED
TOWARDS
THE
FEASIBLE
SIDE
OF
H
BOUNDING
LINE
WE
HAVE
D

H
THE
NEXT
LEMMA
SHOWS
THAT
THESE
TWO
NECESSARY
CONDITIONS
ON
D
ARE
SUFFICIENT
TO
TEST
WHETHER
A
LINEAR
PROGRAM
IS
UNBOUNDED
LEMMA
A
LINEAR
PROGRAM
H
C
IS
UNBOUNDED
IF
AND
ONLY
IF
THERE
IS
A
VECTOR
D
WITH
D
C
SUCH
THAT
D

H
FOR
ALL
H
H
AND
THE
LINEAR
PROGRAM
HL
C
IS
FEASIBLE
WHERE
HL
H
H

H
D
PROOF
THE
ONLY
IF
DIRECTION
FOLLOWS
FROM
THE
ARGUMENT
ABOVE
SO
IT
REMAINS
TO
SHOW
THE
IF
DIRECTION
WE
CONSIDER
A
LINEAR
PROGRAM
H
C
AND
A
VECTOR
D
WITH
THE
CONDITIONS
OF
THE
LEMMA
SINCE
HL
C
IS
FEASIBLE
THERE
IS
A
POINT
H
HL
H
CONSIDER
NOW
THE
RAY

D

SINCE
D

H
FOR
H
HL
THE
RAY
IS
COMPLETELY
CONTAINED
IN
EACH
H
HL
FURTHERMORE
SINCE
D
C
THE
OBJECTIVE
FUNCTION
F
C
TAKES
ARBITRARILY
LARGE
VALUES
ALONG
FOR
A
HALF
PLANE
H
H
HL
WE
HAVE
D

H
THIS
IMPLIES
THAT
THERE
IS
A
PARAMETER
H
SUCH
THAT

D
H
FOR
ALL

H
LET

L
MAXH
H
HL
H
AND
P

LD
IT
FOLLOWS
THAT
THE
RAY

P

D

IS
COMPLETELY
CONTAINED
IN
EACH
HALF
PLANE
H
H
AND
SO
H
C
IS
UNBOUNDED
WE
CAN
NOW
TEST
WHETHER
A
GIVEN
DIMENSIONAL
LINEAR
PROGRAM
H
C
IS
UNBOUNDED
BY
PROCEEDING
SIMILARLY
TO
SECTION
AND
SOLVING
A
DIMENSIONAL
LINEAR
PROGRAM
LET
FIRST
ROTATE
THE
COORDINATE
SYSTEM
SO
THAT
C
IS
THE
UPWARD
VERTICAL
DIRECTION
C
ANY
DIRECTION
VECTOR
D
DX
DY
WITH
D
C
CAN
BE
NORMALIZED
TO
THE
FORM
D
DX
AND
BE
REPRESENTED
BY
THE
POINT
DX
ON
THE
LINE
Y
GIVEN
A
NORMAL
VECTOR

H
X
Y
THE
INEQUALITY
D

H
DXX
Y
TRANSLATES
TO
THE
INEQUALITY
DXX
Y
WE
THUS
OBTAIN
A
SYSTEM
OF
N
LINEAR
INEQUALITIES
OR
IN
OTHER
WORDS
A
DIMENSIONAL
LINEAR
PROGRAM
H
THIS
IS
ACTUALLY
AN
ABUSE
OF
THE
TERMINOLOGY
SINCE
A
LINEAR
PROGRAM
CONSISTS
OF
CONSTRAINTS
AND
AN
OBJECTIVE
FUNCTION
BUT
SINCE
AT
THIS
POINT
WE
ARE
ONLY
INTERESTED
IN
FEASIBILITY
IT
IS
CONVENIENT
TO
IGNORE
THE
OBJECTIVE
FUNCTION
IF
H
HAS
A
FEASIBLE
SOLUTION
DX
WE
IDENTIFY
THE
SET
HL
H
OF
HALF
PLANES
H
FOR
WHICH
THE
SOLUTION
IS
TIGHT
THAT
IS
WHERE
DX
X
Y
WE
STILL
NEED
TO
VERIFY
THAT
THE
SYSTEM
HL
IS
FEASIBLE
ARE
WE
AGAIN
LEFT
WITH
A
DIMENSIONAL
LINEAR
PROGRAMMING
PROBLEM
YES
BUT
A
VERY
SPECIAL
ONE
FOR
EACH
H
HL
THE
NORMAL

H
IS
ORTHOGONAL
TO
D
DX
AND
THAT
MEANS
THAT
THE
BOUNDING
LINE
OF
H
IS
PARALLEL
TO
D
IN
OTHER
WORDS
ALL
HALF
PLANES
IN
HL
ARE
BOUNDED
BY
PARALLEL
LINES
AND
BY
INTERSECTING
THEM
WITH
THE
X
AXIS
WE
HAVE
AGAIN
A
DIMENSIONAL
LINEAR
PROGRAM
HL
IF
HL
IS
FEASIBLE
THEN
THE
ORIGINAL
LINEAR
PROGRAM
IS
UNBOUNDED
AND
WE
CAN
CONSTRUCT
A
FEASIBLE
RAY

IN
TIME
O
N
AS
IN
THE
LEMMA
ABOVE
IF
HL
IS
INFEASIBLE
THEN
SO
IS
HL
AND
THEREFORE
H
IF
H
DOES
NOT
HAVE
A
FEASIBLE
SOLUTION
BY
THE
LEMMA
ABOVE
THE
ORIGINAL
LINEAR
PROGRAM
H
C
IS
BOUNDED
CAN
WE
EXTRACT
SOME
MORE
INFORMATION
IN
THIS
CASE
RECALL
THE
SOLUTION
FOR
DIMENSIONAL
LINEAR
PROGRAMS
H
IS
INFEASIBLE
IF
AND
ONLY
IF
THE
MAXIMUM
BOUNDARY
OF
A
HALF
LINE
BOUNDED
TO
THE
LEFT
IS
LARGER
THAN
THE
MINIMUM
BOUNDARY
OF
A
HALF
LINE
BOUNDED
TO
THE
RIGHT
THESE
TWO
HALF
LINES
AND
HAVE
AN
EMPTY
INTERSECTION
IF
AND
ARE
THE
ORIGINAL
HALF
PLANES
THAT
CORRESPOND
TO
THESE
TWO
CONSTRAINTS
THEN
THIS
IS
EQUIVALENT
TO
SAYING
THAT
C
IS
BOUNDED
WE
CAN
CALL
AND
CERTIFICATES
THEY
PROVE
THAT
H
C
IS
REALLY
BOUNDED
HOW
USEFUL
CERTIFICATES
ARE
BECOMES
CLEAR
WITH
THE
FOLLOWING
OBSERVATION
AFTER
FINDING
THE
TWO
CERTIFICATES
AND
WE
CAN
USE
THEM
LIKE
AND
IN
THAT
MEANS
THAT
WE
NO
LONGER
NEED
TO
MAKE
AN
ARTIFICIAL
RESTRICTION
ON
THE
RANGE
IN
WHICH
WE
ALLOW
THE
SOLUTION
TO
LIE
AGAIN
WE
MUST
BE
CAREFUL
IT
CAN
HAPPEN
THAT
THE
LINEAR
PROGRAM
C
IS
BOUNDED
BUT
HAS
NO
LEXICOGRAPHICALLY
SMALLEST
SOLUTION
THIS
IS
THE
CASE
WHEN
THE
DIMENSIONAL
LINEAR
PROGRAM
IS
INFEASIBLE
DUE
TO
A
SINGLE
CONSTRAINT
NAMELY
WHEN

C
IN
THAT
CASE
WE
SCAN
THE
REMAINING
LIST
OF
HALF
PLANES
FOR
A
HALF
PLANE
WITH
X
IF
WE
ARE
SUCCESSFUL
AND
ARE
CERTIFICATES
THAT
GUARANTEE
A
UNIQUE
LEXICOGRAPHICALLY
SMALLEST
SOLUTION
IF
NO
SUCH
EXISTS
THE
LINEAR
PROGRAM
IS
EITHER
INFEASIBLE
OR
IT
HAS
NO
LEXICOGRAPHICALLY
SMALLEST
SOLUTION
WE
CAN
SOLVE
IT
BY
SOLVING
THE
DIMENSIONAL
LINEAR
PROGRAM
FORMED
BY
ALL
HALF
PLANES
H
WITH
X
H
IF
IT
IS
FEASIBLE
WE
CAN
RETURN
A
RAY

IN
DIRECTION
SUCH
THAT
ALL
POINTS
ON

ARE
FEASIBLE
OPTIMAL
SOLUTIONS
WE
CAN
NOW
GIVE
A
GENERAL
ALGORITHM
FOR
THE
DIMENSIONAL
LINEAR
PROGRAM
MING
PROBLEM
ALGORITHM
H
C
INPUT
A
LINEAR
PROGRAM
H
C
WHERE
H
IS
A
SET
OF
N
HALF
PLANES
AND
C
OUTPUT
IF
H
C
IS
UNBOUNDED
A
RAY
IS
REPORTED
IF
IT
IS
INFEASIBLE
THEN
TWO
OR
THREE
CERTIFICATE
HALF
PLANES
ARE
REPORTED
OTHERWISE
THE
LEXICOGRAPHICALLY
SMALLEST
POINT
P
THAT
MAXIMIZES
F
C
P
IS
REPORTED
DETERMINE
WHETHER
THERE
IS
A
DIRECTION
VECTOR
D
SUCH
THAT
D
C
AND
D

H
FOR
ALL
H
H
IF
D
EXISTS
THEN
COMPUTE
HL
AND
DETERMINE
WHETHER
HL
IS
FEASIBLE
SECTION
UNBOUNDED
LINEAR
PROGRAMS
IF
HL
IS
FEASIBLE
CHAPTER
LINEAR
PROGRAMMING
THEN
REPORT
A
RAY
PROVING
THAT
H
C
IS
UNBOUNDED
AND
QUIT
ELSE
REPORT
THAT
H
C
IS
INFEASIBLE
AND
QUIT
LET
H
BE
CERTIFICATES
PROVING
THAT
H
C
IS
BOUNDED
AND
HAS
A
UNIQUE
LEXICOGRAPHICALLY
SMALLEST
SOLUTION
LET
BE
THE
INTERSECTION
OF
AND
LET
HN
BE
A
RANDOM
PERMUTATION
OF
THE
REMAINING
HALF
PLANES
IN
H
FOR
I
TO
N
DO
IF
VI
HI
THEN
VI
VI
ELSE
VI
THE
POINT
P
ON
FI
THAT
MAXIMIZES
F
C
P
SUBJECT
TO
THE
CONSTRAINTS
IN
HI
IF
P
DOES
NOT
EXIST
THEN
LET
H
J
HK
WITH
J
K
I
BE
THE
CERTIFICATES
POSSIBLY
H
J
HK
WITH
H
J
HK
FI
REPORT
THAT
THE
LINEAR
PROGRAM
IS
INFEASIBLE
WITH
HI
H
J
HK
AS
CERTIFICATES
AND
QUIT
RETURN
VN
WE
SUMMARIZE
OUR
RESULTS
SO
FAR
IN
THE
FOLLOWING
THEOREM
THEOREM
A
DIMENSIONAL
LINEAR
PROGRAMMING
PROBLEM
WITH
N
CONSTRAINTS
CAN
BE
SOLVED
IN
O
N
RANDOMIZED
EXPECTED
TIME
USING
WORST
CASE
LINEAR
STORAGE
LINEAR
PROGRAMMING
IN
HIGHER
DIMENSIONS
THE
LINEAR
PROGRAMMING
ALGORITHM
PRESENTED
IN
THE
PREVIOUS
SECTIONS
CAN
BE
GENERALIZED
TO
HIGHER
DIMENSIONS
WHEN
THE
DIMENSION
IS
NOT
TOO
HIGH
THEN
THE
RESULTING
ALGORITHM
COMPARES
FAVORABLY
WITH
TRADITIONAL
ALGORITHMS
SUCH
AS
THE
SIMPLEX
ALGORITHM
LET
H
BE
A
SET
OF
N
CLOSED
HALF
SPACES
IN
RD
GIVEN
A
VECTOR
C
CD
WE
WANT
TO
FIND
THE
POINT
P
PD
RD
THAT
MAXIMIZES
THE
LINEAR
FUNCTION
F
C
P
CD
PD
SUBJECT
TO
THE
CONSTRAINT
THAT
P
LIES
IN
H
FOR
ALL
H
H
TO
MAKE
SURE
THAT
THE
SOLUTION
IS
UNIQUE
WHEN
THE
LINEAR
PROGRAM
IS
BOUNDED
WE
AGREE
TO
LOOK
FOR
THE
LEXICOGRAPHICALLY
SMALLEST
POINT
THAT
MAXIMIZES
F
C
P
AS
IN
THE
PLANAR
VERSION
WE
MAINTAIN
THE
OPTIMAL
SOLUTION
WHILE
INCREMEN
TALLY
ADDING
THE
HALF
SPACE
CONSTRAINTS
ONE
BY
ONE
FOR
THIS
TO
WORK
WE
AGAIN
NEED
TO
MAKE
SURE
THAT
THERE
IS
A
UNIQUE
OPTIMAL
SOLUTION
AT
EACH
STEP
WE
DO
THIS
AS
IN
THE
PREVIOUS
SECTION
WE
FIRST
DETERMINE
WHETHER
THE
LINEAR
PROGRAM
IS
UNBOUNDED
IF
NOT
WE
OBTAIN
A
SET
OF
D
CERTIFICATES
HD
H
THAT
GUAR
ANTEE
THAT
THE
SOLUTION
IS
BOUNDED
AND
THAT
THERE
IS
A
UNIQUE
LEXICOGRAPHICALLY
SMALLEST
SOLUTION
WE
LL
LOOK
AT
THE
DETAILS
OF
FINDING
THESE
CERTIFICATES
LATER
AND
CONCENTRATE
ON
THE
MAIN
ALGORITHM
FOR
THE
MOMENT
LET
HD
BE
THE
D
CERTIFICATE
HALF
SPACES
OBTAINED
BY
CHECKING
THAT
THE
LINEAR
PROGRAM
IS
BOUNDED
AND
LET
HD
HD
HN
BE
A
RANDOM
PERMUTA
TION
OF
THE
REMAINING
HALF
SPACES
IN
H
FURTHERMORE
DEFINE
CI
TO
BE
THE
FEASIBLE
REGION
WHEN
THE
FIRST
I
HALF
SPACES
HAVE
BEEN
ADDED
FOR
D
I
N
CI
HI
LET
VI
DENOTE
THE
OPTIMAL
VERTEX
OF
CI
THAT
IS
THE
VERTEX
THAT
MAXIMIZES
F
C
LEMMA
GAVE
US
AN
EASY
WAY
TO
MAINTAIN
THE
OPTIMAL
VERTEX
IN
THE
DIMENSIONAL
CASE
EITHER
THE
OPTIMAL
VERTEX
DOESN
T
CHANGE
OR
THE
NEW
OPTIMAL
VERTEX
IS
CONTAINED
IN
THE
LINE
THAT
BOUNDS
THE
HALF
PLANE
HI
THAT
WE
ARE
ADDING
THE
FOLLOWING
LEMMA
GENERALIZES
THIS
RESULT
TO
HIGHER
DIMENSIONS
ITS
PROOF
IS
A
STRAIGHTFORWARD
GENERALIZATION
OF
THE
PROOF
OF
LEMMA
LEMMA
LET
I
N
AND
LET
CI
AND
VI
BE
DEFINED
AS
ABOVE
THEN
WE
HAVE
I
IF
VI
HI
THEN
VI
VI
II
IF
VI
HI
THEN
EITHER
CI
OR
VI
GI
WHERE
GI
IS
THE
HYPERPLANE
THAT
BOUNDS
HI
IF
WE
DENOTE
THE
HYPERPLANE
THAT
BOUNDS
THE
HALF
SPACE
HI
BY
GI
THE
OPTIMAL
VERTEX
VI
OF
CI
CAN
BE
FOUND
BY
FINDING
THE
OPTIMAL
VERTEX
OF
THE
INTERSECTION
GI
CI
BUT
HOW
DO
WE
FIND
THE
OPTIMAL
VERTEX
OF
GI
CI
IN
TWO
DIMENSIONS
THIS
WAS
EASY
TO
DO
IN
LINEAR
TIME
BECAUSE
EVERYTHING
WAS
RESTRICTED
TO
A
LINE
LET
LOOK
AT
THE
DIMENSIONAL
CASE
IN
THREE
DIMENSIONS
GI
IS
A
PLANE
AND
GI
CI
IS
A
DIMENSIONAL
CONVEX
POLYGONAL
REGION
WHAT
DO
WE
HAVE
TO
DO
TO
FIND
THE
OPTIMUM
IN
GI
CI
WE
HAVE
TO
SOLVE
A
DIMENSIONAL
LINEAR
PROGRAM
THE
LINEAR
FUNCTION
F
C
DEFINED
IN
INDUCES
A
LINEAR
FUNCTION
IN
GI
AND
WE
NEED
TO
FIND
THE
POINT
IN
GI
CI
THAT
MAXIMIZES
THIS
FUNCTION
IN
CASE
C
IS
ORTHOGONAL
TO
GI
ALL
POINTS
ON
GI
ARE
EQUALLY
GOOD
FOLLOWING
OUR
RULE
WE
THEN
NEED
TO
FIND
THE
LEXICOGRAPHICALLY
SMALLEST
SOLUTION
WE
ACHIEVE
THIS
BY
CHOOSING
THE
OBJECTIVE
FUNCTION
CORRECTLY
FOR
INSTANCE
WHEN
GI
IS
NOT
ORTHOGONAL
TO
THE
AXIS
WE
OBTAIN
THE
VECTOR
C
BY
PROJECTING
THE
VECTOR
ONTO
GI
SO
IN
THE
DIMENSIONAL
CASE
WE
FIND
THE
OPTIMAL
VERTEX
OF
GI
CI
AS
FOLLOWS
WE
COMPUTE
THE
INTERSECTION
OF
ALL
I
HALF
SPACES
WITH
GI
AND
PROJECT
THE
VECTORS
SECTION
LINEAR
PROGRAMMING
IN
HIGHER
DIMENSIONS
C
ON
GI
UNTIL
A
PROJECTION
IS
NON
ZERO
THIS
RESULTS
IN
A
LINEAR
PROGRAM
IN
TWO
DIMENSIONS
WHICH
WE
SOLVE
USING
ALGORITHM
BY
NOW
YOU
CAN
PROBABLY
GUESS
HOW
WE
WILL
ATTACK
THE
GENERAL
D
DIMENSIONAL
CASE
THERE
GI
IS
A
HYPERPLANE
A
D
DIMENSIONAL
SUBSPACE
AND
WE
HAVE
TO
FIND
THE
POINT
IN
THE
INTERSECTION
CI
GI
THAT
MAXIMIZES
F
C
THIS
IS
A
LINEAR
PROGRAM
IN
D
DIMENSIONS
AND
SO
WE
WILL
SOLVE
IT
BY
MAKING
A
RECURSIVE
CALL
TO
THE
D
DIMENSIONAL
VERSION
OF
OUR
ALGORITHM
THE
RECURSION
BOTTOMS
OUT
WHEN
WE
GET
TO
A
DIMENSIONAL
LINEAR
PROGRAM
WHICH
CAN
BE
SOLVED
DIRECTLY
IN
LINEAR
TIME
WE
STILL
NEED
TO
DETERMINE
WHETHER
THE
LINEAR
PROGRAM
IS
UNBOUNDED
AND
TO
FIND
SUITABLE
CERTIFICATES
IF
THAT
IS
NOT
THE
CASE
WE
FIRST
VERIFY
THAT
LEMMA
CHAPTER
LINEAR
PROGRAMMING
HOLDS
IN
ARBITRARY
DIMENSIONS
THE
LEMMA
AND
ITS
PROOF
NEED
NO
CHANGE
THE
LEMMA
IMPLIES
THAT
THE
D
DIMENSIONAL
LINEAR
PROGRAM
H
C
IS
BOUNDED
IF
AND
ONLY
IF
A
CERTAIN
D
DIMENSIONAL
LINEAR
PROGRAM
IS
INFEASIBLE
WE
WILL
SOLVE
THIS
D
DIMENSIONAL
LINEAR
PROGRAM
BY
A
RECURSIVE
CALL
IF
THE
D
DIMENSIONAL
LINEAR
PROGRAM
IS
FEASIBLE
WE
OBTAIN
A
DIRECTION
VECTOR
D
THE
D
DIMENSIONAL
LINEAR
PROGRAM
IS
THEN
EITHER
UNBOUNDED
IN
DI
RECTION
D
OR
INFEASIBLE
THIS
CAN
BE
DETERMINED
BY
VERIFYING
WHETHER
HL
C
IS
FEASIBLE
WHERE
HL
IS
AS
DEFINED
IN
LEMMA
THE
BOUNDARIES
OF
ALL
THE
HALF
SPACES
IN
HL
ARE
PARALLEL
TO
D
AND
SO
THIS
CAN
BE
DECIDED
BY
SOLVING
A
SECOND
D
DIMENSIONAL
PROGRAM
WITH
A
SECOND
RECURSIVE
CALL
IF
THE
D
DIMENSIONAL
LINEAR
PROGRAM
IS
INFEASIBLE
ITS
SOLUTION
WILL
GIVE
US
K
CERTIFICATE
HALF
SPACES
HK
H
WITH
K
D
THAT
PROVE
THAT
H
C
IS
BOUNDED
IF
K
D
THEN
THE
SET
OF
OPTIMAL
SOLUTIONS
TO
HK
C
IS
UNBOUNDED
IN
THAT
CASE
THESE
OPTIMAL
SOLUTIONS
FORM
A
D
K
DIMENSIONAL
SUBSPACE
WE
DETERMINE
WHETHER
THE
LINEAR
PROGRAM
RESTRICTED
TO
THIS
SUBSPACE
IS
BOUNDED
WITH
RESPECT
TO
THE
LEXICOGRAPHICAL
ORDER
IF
NOT
WE
CAN
REPORT
THE
SOLUTION
OTHERWISE
WE
CAN
REPEAT
THE
PROCESS
UNTIL
WE
OBTAIN
A
SET
OF
D
CERTIFICATES
WITH
A
UNIQUE
SOLUTION
THE
GLOBAL
ALGORITHM
NOW
LOOKS
AS
FOLLOWS
AGAIN
WE
USE
GI
TO
DENOTE
THE
HYPERPLANE
THAT
BOUNDS
THE
HALF
SPACE
HI
ALGORITHM
RANDOMIZEDLP
H
C
INPUT
A
LINEAR
PROGRAM
H
C
WHERE
H
IS
A
SET
OF
N
HALF
SPACES
IN
RD
AND
C
RD
OUTPUT
IF
H
C
IS
UNBOUNDED
A
RAY
IS
REPORTED
IF
IT
IS
INFEASIBLE
THEN
AT
MOST
D
CERTIFICATE
HALF
PLANES
ARE
REPORTED
OTHERWISE
THE
LEXICOGRAPHICALLY
SMALLEST
POINT
P
THAT
MAXIMIZES
F
C
P
IS
REPORTED
DETERMINE
WHETHER
A
DIRECTION
VECTOR
D
EXISTS
SUCH
THAT
D
C
AND
D

H
FOR
ALL
H
H
IF
D
EXISTS
THEN
COMPUTE
HL
AND
DETERMINE
WHETHER
HL
IS
FEASIBLE
IF
HL
IS
FEASIBLE
THEN
REPORT
A
RAY
PROVING
THAT
H
C
IS
UNBOUNDED
AND
QUIT
ELSE
REPORT
THAT
H
C
IS
INFEASIBLE
PROVIDE
CERTIFICATES
AND
QUIT
LET
HD
BE
CERTIFICATES
PROVING
THAT
H
C
IS
BOUNDED
LET
VD
BE
THE
INTERSECTION
OF
GD
COMPUTE
A
RANDOM
PERMUTATION
HD
HN
OF
THE
REMAINING
HALF
SPACES
IN
H
FOR
I
D
TO
N
DO
IF
VI
HI
THEN
VI
VI
ELSE
VI
THE
POINT
P
ON
GI
THAT
MAXIMIZES
F
C
P
SUBJECT
TO
THE
CONSTRAINTS
HI
IF
P
DOES
NOT
EXIST
THEN
LET
H
BE
THE
AT
MOST
D
CERTIFICATES
FOR
THE
INFEASI
BILITY
OF
THE
D
DIMENSIONAL
PROGRAM
REPORT
THAT
THE
LINEAR
PROGRAM
IS
INFEASIBLE
WITH
H
HI
AS
CERTIFICATES
AND
QUIT
RETURN
VN
THE
FOLLOWING
THEOREM
STATES
THE
PERFORMANCE
OF
RANDOMIZEDLP
ALTHOUGH
WE
CONSIDER
D
A
CONSTANT
WHICH
MEANS
WE
CAN
STATE
AN
O
N
BOUND
ON
THE
RUNNING
TIME
IT
IS
USEFUL
TO
HAVE
A
CLOSE
LOOK
AT
THE
DEPENDENCY
OF
THE
RUNNING
TIME
ON
D
SEE
THE
END
OF
THE
PROOF
THE
FOLLOWING
THEOREM
THEOREM
FOR
EACH
FIXED
DIMENSION
D
A
D
DIMENSIONAL
LINEAR
PROGRAMMING
PROBLEM
WITH
N
CONSTRAINTS
CAN
BE
SOLVED
IN
O
N
EXPECTED
TIME
PROOF
WE
MUST
PROVE
THAT
THERE
IS
A
CONSTANT
CD
SUCH
THAT
THE
ALGORITHM
TAKES
AT
MOST
CDN
EXPECTED
TIME
WE
PROCEED
BY
INDUCTION
ON
THE
DIMENSION
D
FOR
TWO
DIMENSIONS
THE
RESULT
FOLLOWS
FROM
THEOREM
SO
LET
ASSUME
D
THE
INDUCTION
STEP
IS
BASICALLY
IDENTICAL
TO
THE
PROOF
OF
THE
DIMENSIONAL
CASES
WE
START
BY
SOLVING
AT
MOST
D
LINEAR
PROGRAMS
OF
DIMENSION
D
BY
THE
INDUCTION
ASSUMPTION
THIS
TAKES
TIME
O
DN
DCD
THE
ALGORITHM
SPENDS
O
D
TIME
TO
COMPUTE
VD
TESTING
WHETHER
VI
HI
TAKES
O
D
TIME
THE
RUNNING
TIME
IS
THEREFORE
O
DN
AS
LONG
AS
WE
DO
NOT
COUNT
THE
TIME
SPENT
IN
LINE
IN
LINE
WE
NEED
TO
PROJECT
C
ON
GI
IN
TIME
O
D
AND
TO
INTERSECT
I
HALF
SPACES
WITH
GI
IN
TIME
O
DI
FURTHERMORE
WE
MAKE
A
RECURSIVE
CALL
WITH
DIMENSION
D
AND
I
HALF
SPACES
DEFINE
A
RANDOM
VARIABLE
XI
WHICH
IS
IF
VI
HI
AND
OTHERWISE
THE
TOTAL
EXPECTED
TIME
SPENT
BY
THE
ALGORITHM
IS
BOUNDED
BY
SECTION
LINEAR
PROGRAMMING
IN
HIGHER
DIMENSIONS
O
DN
DCD
N
O
DI
CD
I
E
XI
I
D
TO
BOUND
E
XI
WE
APPLY
BACKWARDS
ANALYSIS
CONSIDER
THE
SITUATION
AFTER
ADDING
HI
THE
OPTIMUM
POINT
IS
A
VERTEX
VI
OF
CI
SO
IT
IS
DEFINED
BY
D
OF
THE
HALF
SPACES
NOW
WE
MAKE
ONE
STEP
BACKWARDS
IN
TIME
THE
OPTIMUM
POINT
CHANGES
ONLY
IF
WE
REMOVE
ONE
OF
THE
HALF
SPACES
DEFINING
VI
SINCE
HD
HI
IS
A
RANDOM
PERMUTATION
THE
PROBABILITY
THAT
THIS
HAPPENS
IS
AT
MOST
D
I
D
CONSEQUENTLY
WE
GET
THE
FOLLOWING
BOUND
FOR
THE
EXPECTED
RUNNING
TIME
OF
THE
ALGORITHM
O
DN
DC
N
N
O
DI
C
I
D
D
I
D
D
I
D
THIS
CAN
BE
BOUNDED
BY
CDN
WITH
CD
O
CD
SO
CD
O
CDD
FOR
A
CONSTANT
C
INDPENDENT
ON
THE
DIMENSION
WHEN
D
IS
A
CONSTANT
IT
IS
CORRECT
TO
SAY
THAT
THE
ALGORITHM
RUNS
IN
LINEAR
TIME
STILL
THAT
WOULD
BE
QUITE
MISLEADING
THE
CONSTANT
FACTOR
CD
GROWS
SO
FAST
AS
A
FUNCTION
OF
D
THAT
THIS
ALGORITHM
IS
USEFUL
ONLY
FOR
RATHER
SMALL
DIMENSIONS
CHAPTER
LINEAR
PROGRAMMING
SMALLEST
ENCLOSING
DISCS
THE
SIMPLE
RANDOMIZED
TECHNIQUE
WE
USED
ABOVE
TURNS
OUT
TO
BE
SURPRISINGLY
POWERFUL
IT
CAN
BE
APPLIED
NOT
ONLY
TO
LINEAR
PROGRAMMING
BUT
TO
A
VARIETY
OF
OTHER
OPTIMIZATION
PROBLEMS
AS
WELL
IN
THIS
SECTION
WE
SHALL
LOOK
AT
ONE
SUCH
PROBLEM
CONSIDER
A
ROBOT
ARM
WHOSE
BASE
IS
FIXED
TO
THE
WORK
FLOOR
THE
ARM
HAS
TO
PICK
UP
ITEMS
AT
VARIOUS
POINTS
AND
PLACE
THEM
AT
OTHER
POINTS
WHAT
WOULD
BE
A
GOOD
POSITION
FOR
THE
BASE
OF
THE
ARM
THIS
WOULD
BE
SOMEWHERE
IN
THE
MIDDLE
OF
THE
POINTS
IT
MUST
BE
ABLE
TO
REACH
MORE
PRECISELY
A
GOOD
POSITION
IS
AT
THE
CENTER
OF
THE
SMALLEST
DISC
THAT
ENCLOSES
ALL
THE
POINTS
THIS
POINT
MINIMIZES
THE
MAXIMUM
DISTANCE
BETWEEN
THE
BASE
OF
THE
ARM
AND
ANY
POINT
IT
HAS
TO
REACH
WE
ARRIVE
AT
THE
FOLLOWING
PROBLEM
GIVEN
A
SET
P
OF
N
POINTS
IN
THE
PLANE
THE
POINTS
ON
THE
WORK
FLOOR
THAT
THE
ARM
MUST
BE
ABLE
TO
REACH
FIND
THE
SMALLEST
ENCLOSING
DISC
FOR
P
THAT
IS
THE
SMALLEST
DISC
THAT
CONTAINS
ALL
THE
POINTS
OF
P
THIS
SMALLEST
ENCLOSING
DISC
IS
UNIQUE
SEE
LEMMA
I
BELOW
WHICH
IS
A
GENERALIZATION
OF
THIS
STATEMENT
PI
PI
DI
DI
AS
IN
THE
PREVIOUS
SECTIONS
WE
WILL
GIVE
A
RANDOMIZED
INCREMENTAL
ALGORITHM
FOR
THE
PROBLEM
FIRST
WE
GENERATE
A
RANDOM
PERMUTATION
PN
OF
THE
POINTS
IN
P
LET
PI
PI
WE
ADD
THE
POINTS
ONE
BY
ONE
WHILE
WE
MAINTAIN
DI
THE
SMALLEST
ENCLOSING
DISC
OF
PI
IN
THE
CASE
OF
LINEAR
PROGRAMMING
THERE
WAS
A
NICE
FACT
THAT
HELPED
US
TO
MAINTAIN
THE
OPTIMAL
VERTEX
WHEN
THE
CURRENT
OPTIMAL
VERTEX
IS
CONTAINED
IN
THE
NEXT
HALF
PLANE
THEN
IT
DOES
NOT
CHANGE
AND
OTHERWISE
THE
NEW
OPTIMAL
VERTEX
LIES
ON
THE
BOUNDARY
OF
THE
HALF
PLANE
IS
A
SIMILAR
STATEMENT
TRUE
FOR
SMALLEST
ENCLOSING
DISCS
THE
ANSWER
IS
YES
LEMMA
LET
I
N
AND
LET
PI
AND
DI
BE
DEFINED
AS
ABOVE
THEN
WE
HAVE
DI
I
IF
PI
DI
THEN
DI
DI
II
IF
PI
DI
THEN
PI
LIES
ON
THE
BOUNDARY
OF
DI
WE
SHALL
PROVE
THIS
LEMMA
LATER
AFTER
WE
HAVE
SEEN
HOW
WE
CAN
USE
IT
TO
DESIGN
A
RANDOMIZED
INCREMENTAL
ALGORITHM
THAT
IS
QUITE
SIMILAR
TO
THE
LINEAR
PROGRAMMING
ALGORITHM
ALGORITHM
MINIDISC
P
INPUT
A
SET
P
OF
N
POINTS
IN
THE
PLANE
OUTPUT
THE
SMALLEST
ENCLOSING
DISC
FOR
P
COMPUTE
A
RANDOM
PERMUTATION
PN
OF
P
LET
BE
THE
SMALLEST
ENCLOSING
DISC
FOR
FOR
I
TO
N
DO
IF
PI
DI
THEN
DI
DI
ELSE
DI
MINIDISCWITHPOINT
PI
PI
RETURN
DN
THE
CRITICAL
STEP
OCCURS
WHEN
PI
DI
WE
NEED
A
SUBROUTINE
THAT
FINDS
THE
SMALLEST
DISC
ENCLOSING
PI
USING
THE
KNOWLEDGE
THAT
PI
MUST
LIE
ON
THE
BOUNDARY
OF
THAT
DISC
HOW
DO
WE
IMPLEMENT
THIS
ROUTINE
LET
Q
PI
WE
USE
THE
SAME
FRAMEWORK
ONCE
MORE
WE
ADD
THE
POINTS
OF
PI
IN
RANDOM
ORDER
AND
MAINTAIN
THE
SMALLEST
ENCLOSING
DISC
OF
PI
Q
UNDER
THE
EXTRA
CONSTRAINT
THAT
IT
SHOULD
HAVE
Q
ON
ITS
BOUNDARY
THE
ADDITION
OF
A
POINT
P
J
WILL
BE
FACILITATED
BY
THE
FOLLOWING
FACT
WHEN
P
J
IS
CONTAINED
IN
THE
CURRENTLY
SMALLEST
ENCLOSING
DISC
THEN
THIS
DISC
REMAINS
THE
SAME
AND
OTHERWISE
IT
MUST
HAVE
P
J
ON
ITS
BOUNDARY
SO
IN
THE
LATTER
CASE
THE
DISC
HAS
BOTH
Q
AND
P
J
AND
ITS
BOUNDARY
WE
GET
THE
FOLLOWING
SUBROUTINE
MINIDISCWITHPOINT
P
Q
INPUT
A
SET
P
OF
N
POINTS
IN
THE
PLANE
AND
A
POINT
Q
SUCH
THAT
THERE
EXISTS
AN
ENCLOSING
DISC
FOR
P
WITH
Q
ON
ITS
BOUNDARY
OUTPUT
THE
SMALLEST
ENCLOSING
DISC
FOR
P
WITH
Q
ON
ITS
BOUNDARY
COMPUTE
A
RANDOM
PERMUTATION
PN
OF
P
LET
BE
THE
SMALLEST
DISC
WITH
Q
AND
ON
ITS
BOUNDARY
FOR
J
TO
N
DO
IF
P
J
DJ
THEN
DJ
DJ
ELSE
DJ
P
J
P
J
Q
RETURN
DN
SECTION
SMALLEST
ENCLOSING
DISCS
HOW
DO
WE
FIND
THE
SMALLEST
ENCLOSING
DISC
FOR
A
SET
UNDER
THE
RESTRICTION
THAT
TWO
GIVEN
POINTS
AND
ARE
ON
ITS
BOUNDARY
WE
SIMPLY
APPLY
THE
SAME
APPROACH
ONE
MORE
TIME
THUS
WE
ADD
THE
POINTS
IN
RANDOM
ORDER
AND
MAINTAIN
THE
OPTIMAL
DISC
WHEN
THE
POINT
PK
WE
ADD
IS
INSIDE
THE
CURRENT
DISC
WE
DON
T
HAVE
TO
DO
ANYTHING
AND
WHEN
PK
IS
NOT
INSIDE
THE
CURRENT
DISC
IT
MUST
BE
ON
THE
BOUNDARY
OF
THE
NEW
DISC
IN
THE
LATTER
CASE
WE
HAVE
THREE
POINTS
ON
THE
DISC
BOUNDARY
AND
PK
THIS
MEANS
THERE
IS
ONLY
ONE
DISC
LEFT
THE
UNIQUE
DISC
WITH
AND
PK
ON
ITS
BOUNDARY
THIS
FOLLOWING
ROUTINE
DESCRIBES
THIS
IN
MORE
DETAIL
P
INPUT
A
SET
P
OF
N
POINTS
IN
THE
PLANE
AND
TWO
POINTS
AND
SUCH
THAT
THERE
EXISTS
AN
ENCLOSING
DISC
FOR
P
WITH
AND
ON
ITS
BOUNDARY
OUTPUT
THE
SMALLEST
ENCLOSING
DISC
FOR
P
WITH
AND
ON
ITS
BOUNDARY
LET
BE
THE
SMALLEST
DISC
WITH
AND
ON
ITS
BOUNDARY
FOR
K
TO
N
DO
IF
PK
DK
THEN
DK
DK
ELSE
DK
THE
DISC
WITH
AND
PK
ON
ITS
BOUNDARY
RETURN
DN
THIS
FINALLY
COMPLETES
THE
ALGORITHM
FOR
COMPUTING
THE
SMALLEST
ENCLOSING
DISC
OF
A
SET
OF
POINTS
BEFORE
WE
ANALYZE
IT
WE
MUST
VALIDATE
ITS
CORRECTNESS
BY
PROVING
SOME
FACTS
THAT
WE
USED
IN
THE
ALGORITHMS
FOR
INSTANCE
WE
USED
THE
CHAPTER
LINEAR
PROGRAMMING
Z
X
X
FACT
THAT
WHEN
WE
ADDED
A
NEW
POINT
AND
THIS
POINT
WAS
OUTSIDE
THE
CURRENT
OPTIMAL
DISC
THEN
THE
NEW
OPTIMAL
DISC
MUST
HAVE
THIS
POINT
ON
ITS
BOUNDARY
LEMMA
LET
P
BE
A
SET
OF
POINTS
IN
THE
PLANE
LET
R
BE
A
POSSIBLY
EMPTY
SET
OF
POINTS
WITH
P
R
AND
LET
P
P
THEN
THE
FOLLOWING
HOLDS
I
IF
THERE
IS
A
DISC
THAT
ENCLOSES
P
AND
HAS
ALL
POINTS
OF
R
ON
ITS
BOUNDARY
THEN
THE
SMALLEST
SUCH
DISC
IS
UNIQUE
WE
DENOTE
IT
BY
MD
P
R
II
IF
P
MD
P
P
R
THEN
MD
P
R
MD
P
P
R
III
IF
P
MD
P
P
R
THEN
MD
P
R
MD
P
P
R
P
PROOF
I
ASSUME
THAT
THERE
ARE
TWO
DISTINCT
ENCLOSING
DISCS
AND
WITH
CENTERS
AND
RESPECTIVELY
AND
WITH
THE
SAME
RADIUS
CLEARLY
ALL
POINTS
OF
P
MUST
LIE
IN
THE
INTERSECTION
WE
DEFINE
A
CONTINUOUS
FAMILY
D


OF
DISCS
AS
FOLLOWS
LET
Z
BE
AN
INTERSECTION
POINT
OF
AND
THE
BOUNDARIES
OF
AND
THE
CENTER
OF
D

IS
THE
POINT
X


AND
THE
RADIUS
OF
D

IS
R

D
X

Z
X

D

WE
HAVE
D

FOR
ALL

WITH

AND
IN
PARTICULAR
FOR

HENCE
SINCE
BOTH
AND
ENCLOSE
ALL
POINTS
OF
P
SO
MUST
D
MOREOVER
D
PASSES
THROUGH
THE
INTERSECTION
POINTS
OF
AND
BECAUSE
R
THIS
IMPLIES
THAT
R
D
IN
OTHER
WORDS
D
IS
AN
ENCLOSING
DISC
FOR
P
WITH
R
ON
ITS
BOUNDARY
BUT
THE
RADIUS
OF
D
IS
STRICTLY
LESS
THAN
THE
RADII
OF
AND
SO
WHENEVER
THERE
ARE
TWO
DISTINCT
ENCLOSING
DISCS
OF
THE
SAME
RADIUS
WITH
R
ON
THEIR
BOUNDARY
THEN
THERE
IS
A
SMALLER
ENCLOSING
DISC
WITH
R
ON
ITS
BOUNDARY
HENCE
THE
SMALLEST
ENCLOSING
DISC
MD
P
R
IS
UNIQUE
II
LET
D
MD
P
P
R
IF
P
D
THEN
D
CONTAINS
P
AND
HAS
R
ON
ITS
BOUNDARY
THERE
CANNOT
BE
ANY
SMALLER
DISC
CONTAINING
P
WITH
R
ON
ITS
BOUNDARY
BECAUSE
SUCH
A
DISC
WOULD
ALSO
BE
A
CONTAINING
DISC
FOR
P
P
WITH
R
ON
ITS
BOUNDARY
CONTRADICTING
THE
DEFINITION
OF
D
IT
FOLLOWS
THAT
D
MD
P
R
III
LET
MD
P
P
R
AND
LET
MD
P
R
CONSIDER
THE
FAMILY
D

OF
DISCS
DEFINED
ABOVE
NOTE
THAT
D
AND
D
SO
THE
FAMILY
DEFINES
A
CONTINOUS
DEFORMATION
OF
TO
BY
ASSUMPTION
WE
HAVE
P
WE
ALSO
HAVE
P
SO
BY
CONTINUITY
THERE
MUST
BE
SOME

SUCH
THAT
P
LIES
ON
THE
BOUNDARY
OF
D

AS
IN
THE
PROOF
OF
I
WE
HAVE
P
D

AND
R
D

SINCE
THE
RADIUS
OF
ANY
D

WITH

IS
STRICTLY
LESS
THAN
THE
RADIUS
OF
AND
IS
BY
DEFINITION
THE
SMALLEST
ENCLOSING
DISC
FOR
P
WE
MUST
HAVE

IN
OTHER
WORDS
HAS
P
ON
ITS
BOUNDARY
LEMMA
IMPLIES
THAT
MINIDISC
CORRECTLY
COMPUTES
THE
SMALLEST
ENCLOS
ING
DISC
OF
A
SET
OF
POINTS
THE
ANALYSIS
OF
THE
RUNNING
TIME
IS
GIVEN
IN
THE
PROOF
OF
THE
FOLLOWING
THEOREM
THEOREM
THE
SMALLEST
ENCLOSING
DISC
FOR
A
SET
OF
N
POINTS
IN
THE
PLANE
CAN
BE
COMPUTED
IN
O
N
EXPECTED
TIME
USING
WORST
CASE
LINEAR
STORAGE
PROOF
RUNS
IN
O
N
TIME
BECAUSE
EVERY
ITERATION
OF
THE
LOOP
TAKES
CONSTANT
TIME
AND
IT
USES
LINEAR
STORAGE
MINIDISCWITHPOINT
AND
MINIDISC
ALSO
NEED
LINEAR
STORAGE
SO
WHAT
REMAINS
IS
TO
ANALYZE
THEIR
EXPECTED
RUNNING
TIME
THE
RUNNING
TIME
OF
MINIDISCWITHPOINT
IS
O
N
AS
LONG
AS
WE
DON
T
COUNT
THE
TIME
SPENT
IN
CALLS
TO
WHAT
IS
THE
PROB
ABILITY
OF
HAVING
TO
MAKE
SUCH
A
CALL
AGAIN
WE
USE
BACKWARDS
ANALYSIS
TO
BOUND
THIS
PROBABILITY
FIX
A
SUBSET
PI
AND
LET
DI
BE
THE
SMALLEST
DISC
ENCLOSING
PI
AND
HAVING
Q
ON
ITS
BOUNDARY
IMAGINE
THAT
WE
REMOVE
ONE
OF
THE
POINTS
PI
WHEN
DOES
THE
SMALLEST
ENCLOSING
CIRCLE
CHANGE
THAT
HAPPENS
ONLY
WHEN
WE
REMOVE
ONE
OF
THE
THREE
POINTS
ON
THE
BOUNDARY
ONE
OF
THE
POINTS
ON
THE
BOUNDARY
IS
Q
SO
THERE
ARE
AT
MOST
TWO
POINTS
THAT
CAUSE
THE
SMALLEST
ENCLOSING
CIRCLE
TO
SHRINK
THE
PROBABILITY
THAT
PI
IS
ONE
OF
THOSE
POINTS
IS
I
WHEN
THERE
ARE
MORE
THAN
THREE
POINTS
ON
THE
BOUNDARY
THEN
THE
PROBABILITY
THAT
THE
SMALLEST
ENCLOSING
CIRCLE
CHANGES
CAN
ONLY
GET
SMALLER
SO
WE
CAN
BOUND
THE
TOTAL
EXPECTED
RUNNING
TIME
OF
MINIDISCWITHPOINT
BY
SECTION
NOTES
AND
COMMENTS
Q
DI
POINTS
THAT
TOGETHER
WITH
N
Q
DEFINE
DI
O
N
O
I
O
N
I
APPLYING
THE
SAME
ARGUMENT
ONCE
MORE
WE
FIND
THAT
THE
EXPECTED
RUNNING
TIME
OF
MINIDISC
IS
O
N
AS
WELL
ALGORITHM
MINIDISC
CAN
BE
IMPROVED
IN
VARIOUS
WAYS
FIRST
OF
ALL
IT
IS
NOT
NECESSARY
TO
USE
A
FRESH
RANDOM
PERMUTATION
IN
EVERY
INSTANCE
OF
SUBROUTINE
MINIDISCWITHPOINT
INSTEAD
ONE
CAN
COMPUTE
A
PERMUTATION
ONCE
AT
THE
START
OF
MINIDISC
AND
PASS
THE
PERMUTATION
TO
MINIDISCWITHPOINT
FURTHERMORE
INSTEAD
OF
WRITING
THREE
DIFFERENT
ROUTINES
ONE
COULD
WRITE
A
SINGLE
ALGORITHM
MINIDISCWITHPOINTS
P
R
THAT
COMPUTES
MD
P
R
AS
DEFINED
IN
LEMMA
CS
ALGORITHM
IMPLEMENTATION
HTTPS
PEOPLE
CS
PITT
EDU
BILL
HOME
CS
ALGORITHM
IMPLEMENTATION
SECTION
D
SPRING
HOME
POLICY
LECTURES
PROGRAMS
WRITING
GENERAL
INFORMATION
COURSE
DESCRIPTION
THIS
COURSE
WILL
COVER
A
BROAD
RANGE
OF
THE
MOST
COMMONLY
USED
ALGORITHMS
INCLUDING
ALGORITHMS
FOR
SORTING
SEARCHING
ENCRYPTION
COMPRESSION
AND
LOCAL
CS
ALGORITHM
IMPLEMENTATION
HTTPS
PEOPLE
CS
PITT
EDU
BILL
HOME
SEARCH
STUDENTS
WILL
LEARN
TO
IMPLEMENT
ALGORITHMS
AND
ANALYZE
THEIR
PERFORMANCE
TEXTBOOK
ROBERT
SEDGEWICK
AND
KEVIN
WAYNE
ALGORITHMS
EDITION
ADDISON
WESLEY
ISBN
X
GRADING
NON
WRITING
SECTION
FIRST
EXAM
FEB
SECOND
EXAM
APR
PROGRAMMING
ASSIGNMENTS
RECITATION
ATTENDANCE
AND
QUIZZES
GRADING
WRITING
SECTION
FIRST
EXAM
FEB
SECOND
EXAM
APR
PROGRAMMING
ASSIGNMENTS
WRITING
ASSIGNMENTS
RECITATION
ATTENDANCE
AND
QUIZZES
CS
COE
CS
PITT
EDU
BILL
INTRODUCTION
THESE
NOTES
ARE
INTENDED
FOR
USE
BY
STUDENTS
IN
CS
COE
AT
THE
UNIVERSITY
OF
PITTSBURGH
THEY
ARE
PROVIDED
FREE
OF
CHARGE
AND
MAY
NOT
BE
SOLD
IN
ANY
SHAPE
OR
FORM
THESE
NOTES
ARE
NOT
A
SUBSTITUTE
FOR
MATERIAL
COVERED
DURING
COURSE
LECTURES
IF
YOU
MISS
A
LECTURE
IT
IS
YOUR
RESPONSIBILITY
TO
OBTAIN
WRITTEN
NOTES
FROM
A
CLASSMATE
WHO
ATTENDED
THE
LECTURE
MATERIAL
FROM
THESE
NOTES
IS
OBTAINED
FROM
VARIOUS
SOURCES
INCLUDING
BUT
NOT
LIMITED
TO
THE
FOLLOWING
ALGORITHMS
IN
C
BY
ROBERT
SEDGEWICK
ALGORITHMS
EDITION
BY
ROBERT
SEDGEWICK
AND
KEVIN
WAYNE
INTRODUCTION
TO
ALGORITHMS
BY
CORMEN
LEISERSON
AND
RIVEST
VARIOUS
JAVA
AND
C
TEXTBOOKS
VARIOUS
ONLINE
RESOURCES
SEE
NOTES
FOR
SPECIFICS
DR
WILLIAM
GARRISON
BILL
CS
PITT
EDU
OFFICE
SENNOTT
SQUARE
NO
RECITATIONS
THIS
FRIDAY
PREFIX
ALL
EMAIL
SUBJECTS
WITH
ADDRESS
ALL
EMAILS
TO
BOTH
THE
INSTRUCTOR
AND
THE
TA
BE
SURE
TO
MENTION
THE
SECTION
OF
THE
CLASS
YOU
ARE
IN
SECTION
D
AND
WRITING
NON
WRITING
WEBSITE
CS
PITT
EDU
BILL
REVIEW
THE
COURSE
INFORMATION
AND
POLICIES
ASSIGNMENTS
WILL
NOT
BE
ACCEPTED
AFTER
THE
DEADLINE
NO
LATE
ASSIGNMENT
SUBMISSIONS
IF
YOU
DO
NOT
SUBMIT
AN
ASSIGNMENT
BY
THE
DEADLINE
YOU
WILL
RECEIVE
A
FOR
THAT
ASSIGNMENT
UP
UNTIL
NOW
YOUR
CLASSES
HAVE
FOCUSED
ON
HOW
YOU
COULD
SOLVE
A
PROBLEM
HERE
WE
WILL
START
TO
LOOK
AT
HOW
YOU
SHOULD
SOLVE
A
PROBLEM
FIRST
SOME
DEFINITIONS
OFFLINE
PROBLEM
WE
PROVIDE
THE
COMPUTER
WITH
SOME
INPUT
AND
AFTER
SOME
TIME
RECEIVE
SOME
ACCEPTABLE
OUTPUT
ALGORITHM
A
STEP
BY
STEP
PROCEDURE
FOR
SOLVING
A
PROBLEM
OR
ACCOMPLISHING
SOME
END
PROGRAM
AN
ALGORITHM
EXPRESSED
IN
A
LANGUAGE
THE
COMPUTER
CAN
UNDERSTAND
AN
ALGORITHM
SOLVES
A
PROBLEM
IF
IT
PRODUCES
AN
ACCEPTABLE
OUTPUT
ON
EVERY
INPUT
TO
LEARN
TO
CONVERT
NON
TRIVIAL
ALGORITHMS
INTO
PROGRAMS
MANY
SEEMINGLY
SIMPLE
ALGORITHMS
CAN
BECOME
MUCH
MORE
COMPLICATED
AS
THEY
ARE
CONVERTED
INTO
PROGRAMS
ALGORITHMS
CAN
ALSO
BE
VERY
COMPLEX
TO
BEGIN
WITH
AND
THEIR
IMPLEMENTATION
MUST
BE
CONSIDERED
CAREFULLY
VARIOUS
ISSUES
WILL
ALWAYS
POP
UP
DURING
IMPLEMENTATION
SUCH
AS
PSEUDOCODE
FOR
DYNAMIC
PROGRAMMING
ALGORITHM
FOR
RELATIONAL
QUERY
OPTIMIZATION
THE
OPTIMIZER
PORTION
OF
THE
POSTGRESQL
CODEBASE
IS
OVER
LINES
OF
CODE
I
E
NOT
COUNTING
BLANK
COMMENT
LINES
TO
SEE
AND
UNDERSTAND
DIFFERENCES
IN
ALGORITHMS
AND
HOW
THEY
AFFECT
THE
RUN
TIMES
OF
THE
ASSOCIATED
PROGRAMS
DIFFERENT
ALGORITHMS
CAN
BE
USED
TO
SOLVE
THE
SAME
PROBLEM
DIFFERENT
SOLUTIONS
CAN
BE
COMPARED
USING
MANY
METRICS
RUN
TIME
IS
A
BIG
ONE
BETTER
RUN
TIMES
CAN
MAKE
AN
ALGORITHM
MORE
DESIRABLE
BETTER
RUN
TIMES
CAN
SOMETIMES
MAKE
A
PROBLEM
SOLUTION
FEASIBLE
WHERE
IT
WAS
NOT
FEASIBLE
BEFORE
THERE
ARE
OTHER
METRICS
THOUGH
IMPLEMENT
IT
AND
MEASURE
PERFORMANCE
ANY
PROBLEMS
WITH
THIS
APPROACH
ALGORITHM
ANALYSIS
DETERMINE
RESOURCE
USAGE
AS
A
FUNCTION
OF
INPUT
SIZE
MEASURE
ASYMPTOTIC
PERFORMANCE
PERFORMANCE
AS
INPUT
SIZE
INCREASES
TO
INFINITY
PROBLEM
GIVEN
A
SET
OF
ARBITRARY
INTEGERS
COULD
BE
NEGATIVE
FIND
OUT
HOW
MANY
DISTINCT
TRIPLES
SUM
TO
EXACTLY
ZERO
SIMPLE
SOLUTION
TRIPLE
FOR
LOOPS
PUBLIC
STATIC
INT
COUNT
INT
A
INT
N
A
LENGTH
INT
COUNT
FOR
INT
I
I
N
I
FOR
INT
J
I
J
N
J
FOR
INT
K
J
K
N
K
IF
A
I
A
J
A
K
COUNT
RETURN
COUNT
BIG
O
UPPER
BOUND
ON
ASYMPTOTIC
PERFORMANCE
AS
WE
GO
TO
INFINITY
FUNCTION
REPRESENTING
RESOURCE
CONSUMPTION
WILL
NOT
EXCEED
SPECIFIED
FUNCTION
E
G
SAYING
RUNTIME
IS
O
MEANS
THAT
AS
INPUT
SIZE
N
APPROACHES
INFINITY
ACTUAL
RUNTIME
WILL
NOT
EXCEED
ASSUMING
THAT
DEFINITION
IS
THREESUM
O
WHAT
ABOUT
O
WHAT
ABOUT
O
IF
ALL
OF
THESE
ARE
TRUE
WHY
WAS
O
WHAT
WE
JUMPED
TO
TO
START
BIG
OMEGA
LOWER
BOUND
ON
ASYMPTOTIC
PERFORMANCE
THETA
UPPER
AND
LOWER
BOUND
ON
ASYMPTOTIC
PERFORMANCE
EXACT
BOUND
F
X
IS
O
G
X
IF
CONSTANTS
C
AND
EXIST
SUCH
THAT
F
X
C
G
X
X
F
X
IS

G
X
IF
CONSTANTS
C
AND
EXIST
SUCH
THAT
F
X
C
G
X
X
IF
F
X
IS
O
G
X
AND

G
X
THEN
F
X
IS

G
X
AND
EXIST
SUCH
THAT
G
X
F
X
G
X
X
MAY
ALSO
SEE
F
X
O
G
X
OR
F
X
O
G
X
USED
TO
MEAN
THAT
F
X
IS
O
G
X
SAME
FOR

AND

RUNTIME
PRIMARILY
DETERMINED
BY
TWO
FACTORS
COST
OF
EXECUTING
EACH
STATEMENT
DETERMINED
BY
MACHINE
USED
ENVIRONMENT
RUNNING
ON
THE
MACHINE
FREQUENCY
OF
EXECUTION
OF
EACH
STATEMENT
DETERMINED
BY
PROGRAM
AND
INPUT
PUBLIC
STATIC
INT
COUNT
INT
A
INT
N
A
LENGTH
INT
COUNT
FOR
INT
I
I
N
I
FOR
INT
J
I
J
N
J
FOR
INT
K
J
K
N
K
IF
A
I
A
J
A
K
COUNT
RETURN
COUNT
IGNORE
MULTIPLICATIVE
CONSTANTS
AND
LOWER
TERMS
USE
STANDARD
MEASURES
FOR
COMPARISON
CONSTANT
LOGARITHMIC
LOG
N
LINEAR
N
LINEARITHMIC
N
LOG
N
QUADRATIC
CUBIC
EXPONENTIAL
FACTORIAL
N
THREESUM
ORDER
OF
GROWTH
UPPER
BOUND
O
LOWER
BOUND

AND
HENCE

TILDE
APPROXIMATIONS
INTRODUCED
IN
SECTION
OF
THE
TEXT
IN
THIS
CASE
HOW
CAN
WE
IGNORE
LOWER
ORDER
TERMS
AND
MULTIPLICATIVE
CONSTANTS
REMEMBER
THIS
IS
ASYMPTOTIC
ANALYSIS
WHY
DO
WE
NEED
TO
BOTHER
WITH
BIG
O
AND
BIG
OMEGA
IS
THERE
A
BETTER
WAY
TO
SOLVE
THE
PROBLEM
WHAT
IF
WE
SORTED
THE
ARRAY
FIRST
PICK
TWO
NUMBERS
THEN
BINARY
SEARCH
FOR
THE
THIRD
ONE
THAT
WILL
MAKE
A
SUM
OF
ZERO
A
I
A
J
BINARY
SEARCH
FOR
STILL
HAVE
TWO
FOR
LOOPS
BUT
WE
REPLACE
THE
THIRD
WITH
A
BINARY
SEARCH
RUNTIME
NOW
WHAT
IF
THE
INPUT
DATA
ISN
T
SORTED
SEE
THREESUMFAST
JAVA
SORTING
SEARCHING
HASHING
COMPRESSION
HEAPS
AND
PRIORITY
QUEUES
GRAPH
ALGORITHMS
CRYPTOGRAPHY
P
VS
NP
HEURISTIC
APPROXIMATION
DYNAMIC
PROGRAMMING
CS
COE
CS
PITT
EDU
BILL
SORTING
GIVEN
A
LIST
OF
N
ITEMS
PLACE
THE
ITEMS
IN
A
GIVEN
ORDER
ASCENDING
OR
DESCENDING
NUMERICAL
ALPHABETICAL
ETC
BOOLEAN
LESS
COMPARABLE
V
COMPARABLE
W
RETURN
V
COMPARETO
W
VOID
SWAP
OBJECT
A
INT
I
INT
J
OBJECT
TEMP
A
I
A
I
A
J
A
J
TEMP
ITERATE
THROUGH
THE
ARRAY
COMPARING
ADJACENT
PAIRS
OF
ITEMS
SWAP
THEM
IF
THEY
ARE
OUT
OF
RELATIVE
ORDER
REPEAT
UNTIL
YOU
MAKE
IT
THROUGH
THE
ARRAY
WITH
SWAPS
VOID
BUBBLESORT
COMPARABLE
A
SWAPPED
VOID
BUBBLESORT
COMPARABLE
A
RUNTIME
O
A
LTHOUGH
THE
TECHNIQUES
USED
IN
THE
CALCULATIONS
TO
ANALYZE
THE
BUBBLE
SORT
ARE
INSTRUCTIVE
THE
RESULTS
ARE
DISAPPOINTING
SINCE
THEY
TELL
US
THAT
THE
BUBBLE
SORT
ISN
T
REALLY
VERY
GOOD
AT
ALL
DONALD
KNUTH
THE
ART
OF
COMPUTER
PROGRAMMING
WHAT
IS
THE
MOST
EFFICIENT
WAY
TO
SORT
A
MILLION
BIT
INTEGERS
I
THINK
THE
BUBBLE
SORT
WOULD
BE
THE
WRONG
WAY
TO
GO
DIVIDE
AND
CONQUER
VOID
SORT
COMPARABLE
A
COMPARABLE
AUX
INT
LO
INT
HI
IF
HI
LO
RETURN
INT
MID
LO
HI
LO
SORT
A
AUX
LO
MID
SORT
A
AUX
MID
HI
MERGE
A
AUX
LO
MID
HI
MERGE
COMPARABLE
A
COMPARABLE
AUX
INT
LO
INT
MID
INT
HI
FOR
INT
K
LO
K
HI
K
AUX
K
A
K
RUNTIME
O
N
LOG
N
SO
WHAT
THE
CATCH
NOW
WE
NEED
O
N
SPACE
AVAILABLE
FOR
THE
AUX
ARRAY
SORT
DOES
NOT
OCCUR
IN
PLACE
CHOOSE
A
PIVOT
VALUE
PLACE
THE
PIVOT
IN
THE
ARRAY
SUCH
THAT
ALL
ITEMS
AT
LOWER
INDICES
ARE
LESS
THAN
PIVOT
AND
ALL
HIGHER
INDICES
ARE
GREATER
RECURSE
FOR
LESSER
INDICES
AND
GREATER
INDICES
VOID
SORT
COMPARABLE
A
INT
LO
INT
HI
IF
HI
LO
RETURN
INT
J
PARTITION
A
LO
HI
SORT
A
LO
J
SORT
A
J
HI
INT
PARTITION
COMPARABLE
A
INT
LO
INT
HI
INT
I
LO
J
HI
COMPARABLE
V
A
LO
WHILE
TRUE
WHILE
LESS
A
I
V
IF
I
HI
BREAK
WHILE
LESS
V
A
J
IF
J
LO
BREAK
IF
I
J
BREAK
SWAP
A
I
J
SWAP
A
LO
J
RETURN
J
LO
V
HI
I
J
RUNTIME
IN
PLACE
STABLE
SORTING
MAINTAINS
THE
RELATIVE
ORDERING
OF
TIED
VALUES
COMPARISON
SORT
RUNTIME
OF
O
N
LOG
N
IS
OPTIMAL
THE
PROBLEM
OF
SORTING
CANNOT
BE
SOLVED
USING
COMPARISONS
WITH
LESS
THAN
N
LOG
N
TIME
COMPLEXITY
SEE
PROPOSITION
I
IN
CHAPTER
OF
THE
TEXT
CONSIDER
THE
FOLLOWING
APPROACH
LOOK
AT
THE
LEAST
SIGNIFICANT
DIGIT
GROUP
NUMBERS
WITH
THE
SAME
DIGIT
MAINTAIN
RELATIVE
ORDER
PLACE
GROUPS
BACK
IN
ARRAY
TOGETHER
I
E
ALL
THE
ALL
THE
ALL
THE
ETC
REPEAT
FOR
INCREASINGLY
SIGNIFICANT
DIGITS
RUNTIME
N
LENGTH
OF
ITEMS
IN
COLLECTION
WE
LL
SAY
NK
HOW
CAN
WE
COMPARE
THIS
TO
THE
N
LOG
N
RUNTIME
THAT
IS
OPTIMAL
FOR
COMPARISON
BASED
SORTS
ALSO
WHY
IS
IT
CALLED
RADIX
SORT
IN
PLACE
STABLE
BIT
INTEGERS
DON
T
TAKE
UP
A
WHOLE
LOT
OF
SPACE
MB
WHAT
IF
WE
NEEDED
TO
SORT
OF
NUMBERS
WON
T
ALL
FIT
IN
MEMORY
WE
HAD
BEEN
ASSUMING
WE
WERE
PERFORMING
INTERNAL
SORTS
EVERYTHING
IN
MEMORY
WE
NOW
NEED
TO
CONSIDER
EXTERNAL
SORTING
WHERE
WE
NEED
TO
WRITE
TO
DISK
READ
IN
AMOUNT
OF
DATA
THAT
WILL
FIT
IN
MEMORY
SORT
IT
IN
PLACE
I
E
VIA
QUICK
SORT
WRITE
SORTED
CHUNK
OF
DATA
TO
DISK
REPEAT
UNTIL
ALL
DATA
IS
STORED
IN
SORTED
CHUNKS
MERGE
CHUNKS
TOGETHER
SHOULD
WE
MERGE
ALL
CHUNKS
TOGETHER
AT
ONCE
MEANS
FEWER
DISK
READ
WRITES
EACH
MERGE
PASS
READS
WRITES
EVERY
VALUE
BUT
ALSO
MORE
DISK
SEEKS
CAN
WE
DO
PARALLEL
READS
WRITES
TO
MULTIPLE
DISKS
CAN
WE
USE
MULTIPLE
CPUS
CORES
TO
SPEED
UP
PROCESSING
WHAT
ABOUT
WHEN
YOU
HAVE
OF
DATA
IN
GOOGLE
SORTED
TRILLION
BYTE
RECORDS
ON
COMPUTERS
IN
HOURS
MINUTES
HARD
DRIVES
WERE
INVOLVED
AT
LEAST
DISK
FAILED
DURING
EACH
RUN
OF
THE
SORT
CS
COE
CS
PITT
EDU
BILL
BRUTE
FORCE
SEARCH
FIND
THE
SOLUTION
TO
A
PROBLEM
BY
CONSIDERING
ALL
POTENTIAL
SOLUTIONS
AND
SELECTING
THE
CORRECT
ONE
RUN
TIME
IS
BOUNDED
BY
THE
NUMBER
OF
POTENTIAL
SOLUTIONS
POTENTIAL
SOLUTIONS
MEANS
CUBIC
RUN
TIME
POTENTIAL
SOLUTIONS
MEANS
EXPONENTIAL
RUN
TIME
BRUTE
FORCE
PASSWORD
ATTACKS
DEPEND
ON
THE
LENGTH
OF
THE
PASSWORD
HENCE
THE
INSECURITY
OF
SHORT
PASSWORDS
WE
CAN
VIEW
THE
SERIES
OF
GUESSES
WE
MAKE
AS
A
TREE
EACH
PATH
FROM
ROOT
TO
LEAF
IS
AN
ATTEMPTED
SOLUTION
ROOT
THIS
TREE
WILL
ENUMERATE
DIFFERENT
PINS
N
IS
THE
LENGTH
OF
THE
PIN
SO
FOR
OUR
CASE
DIFFERENT
PINS
NOTE
THAT
THIS
IS
FOR
A
COMPUTER
TINY
WHAT
WOULD
BE
A
LONG
PASSWORD
FOR
A
COMPUTER
SAY
BITS
LONG
DIFFERENT
PASSWORDS
ASSUMING
A
SUPERCOMPUTER
CAN
CHECK
PASSWORDS
PER
SECOND
AND
WE
LL
ON
AVERAGE
FIND
THE
CORRECT
PASSWORD
AFTER
GUESSING
HALF
THE
POSSIBILITIES
WE
SHOULD
BE
ABLE
TO
CRACK
A
BIT
PASSWORD
ON
OUR
SUPERCOMPUTER
IN
X
YEARS
USING
BRUTE
FORCE
WHAT
IF
WE
HAVE
BACKGROUND
KNOWLEDGE
THAT
THE
PIN
WE
RE
TRYING
TO
CRACK
DOESN
T
HAVE
MORE
THAN
ONE
REMOVES
ENTIRE
SUBTREES
OF
OUR
SEARCH
SPACE
EXPLORATION
WHEN
WE
CAN
USE
IT
IT
MAKES
OUR
ALGORITHM
PRACTICAL
FOR
MUCH
LARGER
VALUES
OF
N
DOES
NOT
HOWEVER
AFFECT
THE
ASYMPTOTIC
PERFORMANCE
OF
AN
ALGORITHM
STILL
EXPONENTIAL
TIME
REQUIREMENT
FOR
OUR
PIN
EXAMPLE
FOR
THE
PIN
EXAMPLE
A
WHOLE
BUNCH
OF
FOR
LOOPS
WOULD
DO
IN
GENERAL
EXHAUSTIVE
SEARCH
TREES
CAN
BE
EASILY
TRAVERSED
VIA
RECURSION
AND
BACKTRACKING
RECURSE
UNTIL
ITS
APPARENT
NO
SOLUTION
CAN
BE
ACHIEVED
ALONG
THE
CURRENT
PATH
UNDO
THE
PATH
TO
THE
POINT
THAT
YOU
CAN
START
TO
MOVE
FORWARD
AGAIN
PLACE
QUEENS
ON
A
CHESSBOARD
SUCH
THAT
NO
QUEEN
CAN
TAKE
ANOTHER
QUEENS
CAN
MOVE
HORIZONTALLY
VERTICALLY
AND
DIAGONALLY
HOW
MANY
WAYS
CAN
YOU
PLACES
PIECES
ON
A
CHESS
BOARD
C
MEANING
TOTAL
QUEEN
PLACEMENTS
DO
WE
REALLY
NEED
TO
LOOK
THROUGH
ALL
OF
THESE
OPTIONS
SOLUTIONS
ONLY
HAVE
ONE
QUEEN
PER
COLUMN
STILL
POSSIBLE
COMBINATIONS
SOLUTIONS
ONLY
HAVE
ONE
QUEEN
PER
ROW
COMBINING
THESE
TWO
OBSERVATIONS
ONLY
LOOKING
QUITE
FEASIBLE
FINALLY
PRUNE
SUBTREES
WITH
QUEENS
ON
THE
SAME
DIAGONAL
BASIC
IDEA
RECURSE
OVER
COLUMNS
OF
THE
BOARD
EACH
RECURSIVE
CALL
ITERATES
THROUGH
THE
ROWS
OF
THE
BOARD
CHECK
ROWS
DIAGONALS
ARE
THEY
CURRENTLY
SAFE
PLACE
A
QUEEN
IN
THE
CURRENT
ROW
COL
IF
YOU
ARE
AT
THE
END
OF
THE
BOARD
YOU
VE
FOUND
A
SOLUTION
OTHERWISE
TRY
RECURSIVE
CALL
FOR
THE
NEXT
COLUMN
IF
THEY
ARE
NOT
CURRENTLY
SAFE
CONTINUE
TO
THE
NEXT
ROW
IN
THE
CURRENT
RECURSIVE
CALL
A
B
C
D
E
F
G
H
WORDS
AT
LEAST
ADJACENT
LETTERS
LONG
MUST
BE
ASSEMBLED
FROM
A
GRID
ADJACENT
LETTERS
ARE
HORIZONTALLY
VERTICALLY
OR
DIAGONALLY
NEIGHBORING
ANY
CUBE
IN
THE
GRID
CAN
ONLY
BE
USED
ONCE
PER
WORD
HAVE
DIFFERENT
OPTIONS
FROM
EACH
CUBE
FROM
B
I
J
B
I
J
B
I
J
B
I
J
B
I
J
B
I
J
B
I
J
B
I
J
B
I
J
NAIVELY
THE
RUNTIME
HERE
WOULD
BE
CONSTRUCTING
THE
WORDS
OVER
THE
COURSE
OF
RECURSION
WILL
MEAN
BUILDING
UP
AND
TEARING
DOWN
STRINGS
MOVING
FORWARD
ADDS
A
NEW
CHARACTER
TO
THE
CURRENT
WORD
STRING
BACKTRACKING
REMOVES
THE
MOST
RECENT
CHARACTER
BASICALLY
PUSHING
POPPING
TO
FROM
A
STRING
STACK
PUSH
POP
STACK
OPERATIONS
ARE
GENERALLY

UNLESS
YOU
NEED
TO
RESIZE
BUT
THAT
COST
CAN
BE
AMORTIZED
JAVA
STRINGS
HOWEVER
ARE
IMMUTABLE
NEW
STRING
HERE
IS
A
BASIC
STRING
THIS
OPERATION
ALLOCATES
AND
INITIALIZES
ALL
OVER
AGAIN
BECOMES
ESSENTIALLY
A

N
OPERATION
WHERE
N
IS
THE
LENGTH
OF
THE
STRING
APPEND
AND
DELETECHARAT
CAN
BE
USED
TO
PUSH
AND
POP
BACK
TO

STILL
NEED
TO
ACCOUNT
FOR
RESIZING
THOUGH
STRINGBUFFER
CAN
ALSO
BE
USED
FOR
THIS
PURPOSE
DIFFERENCES
CS
COE
CS
PITT
EDU
BILL
SEARCHING
GIVEN
A
COLLECTION
OF
KEYS
C
HOW
TO
WE
SEARCH
FOR
THE
VALUE
ASSOCIATED
WITH
A
GIVEN
KEY
K
STORE
COLLECTION
IN
AN
ARRAY
UNSORTED
SORTED
LINKED
LIST
UNSORTED
SORTED
BINARY
SEARCH
TREE
DIFFERENCES
RUNTIMES
ABSTRACT
STRUCTURES
THAT
LINK
KEYS
TO
VALUES
KEY
IS
USED
TO
SEARCH
THE
DATA
STRUCTURE
FOR
A
VALUE
DESCRIBED
AS
A
CLASS
IN
THE
TEXT
BUT
PROBABLY
MORE
ACCURATE
TO
THINK
OF
THE
CONCEPT
OF
A
SYMBOL
TABLE
IN
GENERAL
AS
AN
INTERFACE
KEY
FUNCTIONS
PUT
CONTAINS
GET
FOLLOWS
SIMILARLY
BINARYSEARCHST
JAVA
AND
BST
JAVA
PRESENT
SYMBOL
TABLES
BASED
ON
SORTED
ARRAYS
AND
BINARY
SEARCH
TREES
RESPECTIVELY
CAN
WE
DO
BETTER
THAN
THESE
BOTH
METHODS
DEPEND
ON
COMPARISONS
AGAINST
OTHER
KEYS
I
E
K
IS
COMPARED
AGAINST
OTHER
KEYS
IN
THE
DATA
STRUCTURE
OPTIONS
AT
EACH
NODE
IN
A
BST
NODE
REF
IS
NULL
K
NOT
FOUND
K
IS
EQUAL
TO
THE
CURRENT
NODE
KEY
K
IS
FOUND
K
IS
LESS
THAN
CURRENT
KEY
CONTINUE
TO
LEFT
CHILD
K
IS
GREATER
THAN
THE
CURRENT
KEY
CONTINUE
TO
RIGHT
CHILD
INSTEAD
OF
LOOKING
AT
LESS
THAN
GREATER
THAN
LET
GO
LEFT
RIGHT
BASED
ON
THE
BITS
OF
THE
KEY
SO
WE
AGAIN
HAVE
OPTIONS
NODE
REF
IS
NULL
K
NOT
FOUND
K
IS
EQUAL
TO
THE
CURRENT
NODE
KEY
K
IS
FOUND
CURRENT
BIT
OF
K
IS
CONTINUE
TO
LEFT
CHILD
CURRENT
BIT
OF
K
IS
CONTINUE
TO
RIGHT
CHILD
SEARCH
RUNTIME
WE
END
UP
DOING
MANY
COMPARISONS
AGAINST
THE
FULL
KEY
CAN
WE
IMPROVE
ON
THIS
TRIE
AS
IN
RETRIEVE
PRONOUNCED
THE
SAME
AS
TRY
INSTEAD
OF
STORING
KEYS
AS
NODES
IN
THE
TREE
WE
STORE
THEM
IMPLICITLY
AS
PATHS
DOWN
THE
TREE
INTERIOR
NODES
OF
THE
TREE
ONLY
SERVE
TO
DIRECT
US
ACCORDING
TO
THE
BITSTRING
OF
THE
KEY
VALUES
CAN
THEN
BE
STORED
AT
THE
END
OF
KEY
BIT
STRING
PATH
SEARCH
RUNTIME
WOULD
THIS
STRUCTURE
WORK
AS
WELL
FOR
OTHER
KEY
DATA
TYPES
CHARACTERS
STRINGS
IN
OUR
BINARY
BASED
RADIX
SEARCH
TRIE
WE
CONSIDERED
ONE
BIT
AT
A
TIME
WHAT
IF
WE
APPLIED
THE
SAME
METHOD
TO
CHARACTERS
IN
A
STRING
WHAT
WOULD
LIKE
THIS
NEW
STRUCTURE
LOOK
LIKE
LET
TRY
INSERTING
THE
FOLLOWING
STRINGS
INTO
AN
TRIE
SHE
SELLS
SEA
SHELLS
BY
THE
SEA
SHORE
B
T
Y
E
H
H
A
L
E
O
E
L
L
R
L
E
RUNTIME
MISS
TIMES
REQUIRE
AN
AVERAGE
OF
LOGR
N
NODES
TO
BE
EXAMINED
WHERE
R
IS
THE
SIZE
OF
THE
ALPHABET
BEING
CONSIDERED
PROOF
IN
PROPOSITION
H
OF
SECTION
OF
THE
TEXT
AVERAGE
OF
CHECKS
WITH
KEYS
IN
AN
RST
WITH
KEYS
IN
AN
R
WAY
TRIE
ASSUMING
BIT
ASCII
SEE
TRIEST
JAVA
IMPLEMENTS
AN
R
WAY
TRIE
BASIC
NODE
OBJECT
WHERE
R
IS
THE
BRANCHING
FACTOR
PRIVATE
STATIC
CLASS
NODE
PRIVATE
OBJECT
VAL
PRIVATE
NODE
NEXT
NEW
NODE
R
NON
NULL
VAL
MEANS
WE
HAVE
TRAVERSED
TO
A
VALID
KEY
AGAIN
NOTE
THAT
KEYS
ARE
NOT
DIRECTLY
STORED
IN
THE
TRIE
AT
ALL
VAL
NEXT
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
T
U
V
W
X
Y
Z
VAL
NEXT
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
T
U
V
W
X
Y
Z
SPACE
CONSIDERING
BIT
ASCII
EACH
NODE
CONTAINS
REFERENCES
THIS
IS
ESPECIALLY
PROBLEMATIC
AS
IN
MANY
CASES
A
LOT
OF
THIS
SPACE
IS
WASTED
COMMON
PATHS
OR
PREFIXES
FOR
EXAMPLE
E
G
IF
ALL
KEYS
BEGIN
WITH
KEY
THAT
WASTED
REFERENCES
AT
THE
LOWER
LEVELS
OF
THE
TRIE
MOST
KEYS
HAVE
PROBABLY
BEEN
SEPARATED
OUT
AND
REFERENCE
LISTS
WILL
BE
SPARSE
REPLACE
THE
NEXT
ARRAY
OF
THE
R
WAY
TRIE
WITH
A
LINKED
LIST
DLB
EXAMPLE
HOW
DOES
DLB
PERFORMANCE
DIFFER
FROM
R
WAY
TRIES
WHICH
SHOULD
YOU
USE
SO
FAR
WE
VE
CONTINUALLY
ASSUMED
EACH
SEARCH
WOULD
ONLY
LOOK
FOR
THE
PRESENCE
OF
A
WHOLE
KEY
WHAT
ABOUT
PREFIX
SEARCH
AS
WAS
NEEDED
FOR
BOGGLE
THIS
LECTURE
DOES
NOT
PRESENT
AN
EXHAUSTIVE
LOOK
AT
SEARCH
TREES
TRIES
JUST
THE
SAMPLING
THAT
WE
RE
GOING
TO
FOCUS
ON
MANY
VARIATIONS
ON
THESE
TECHNIQUES
EXIST
AND
PERFORM
QUITE
WELL
IN
DIFFERENT
CIRCUMSTANCES
RED
BLACK
BSTS
TERNARY
SEARCH
TRIES
R
WAY
TRIES
WITHOUT
WAY
BRANCHING
SEE
THE
TABLE
AT
THE
END
OF
SECTION
OF
THE
TEXT
CS
COE
CS
PITT
EDU
BILL
B
TREES
THE
VARIANT
OF
B
TREES
PRESENTED
HERE
DIFFERS
SLIGHTLY
FROM
THAT
PRESENTED
IN
THE
BOOK
B
TREES
ARE
NOT
DISCUSSED
IN
THE
BOOK
WE
VE
DISCUSSED
SEVERAL
APPROACHES
TO
SEARCH
THROUGH
A
SET
OF
KEYS
AND
RETRIEVE
A
VALUE
SEVERAL
IMPLEMENTATIONS
OF
A
SYMBOL
TABLE
ALL
OF
THEM
ASSUMED
WE
WERE
STORING
THE
KEYS
VALUES
THE
SYMBOL
TABLE
IN
MEMORY
WHAT
IF
DATA
NEEDS
TO
BE
STORED
ON
DISK
WHAT
SHOULD
WE
DO
DIFFERENTLY
YOU
RE
WRITING
SOFTWARE
THAT
WILL
BE
USED
TO
STORE
RECORDS
OF
ONLINE
STORE
TRANSACTIONS
EACH
WITH
A
UNIQUE
ID
E
G
VINYL
ALBUM
SALES
YOU
LL
WANT
TO
STORE
THESE
RECORDS
ON
DISK
YOU
EXPECT
A
LARGE
VOLUME
OF
TRANSACTION
RECORDS
YOU
WANT
THE
TRANSACTION
RECORDS
STORED
IN
NON
VOLATILE
MEMORY
HOW
CAN
YOU
STILL
EFFICIENTLY
SEARCH
FOR
A
GIVEN
TRANSACTION
BY
ITS
ID
DATA
STORED
ON
DISK
IS
GROUPED
INTO
BLOCKS
TYPICALLY
OF
SIZE
I
O
TO
THE
DISK
IS
PERFORMED
AT
THE
BLOCK
LEVEL
TO
READ
A
FILE
FROM
DISK
THE
OS
WILL
FETCH
ALL
OF
THE
BLOCKS
THAT
STORE
SOME
PORTION
OF
THAT
FILE
AND
READ
THE
DATA
FROM
EACH
BLOCK
OPERATES
SIMILARLY
TO
A
BINARY
SEARCH
TREE
BUT
NOT
LIMITED
TO
A
BRANCHING
FACTOR
OF
THE
ORDER
OF
A
B
TREE
DETERMINES
THE
MAX
BRANCHING
FACTOR
INVARIANTS
FOR
AN
ORDER
M
B
TREE
NODES
HAVE
A
MAX
OF
M
CHILDREN
INTERIOR
NODES
HAVE
AT
MIN
OF
M
CHILDREN
NODES
THAT
ARE
NOT
THE
ROOT
OR
LEAVES
COROLLARY
ALL
INTERIOR
NODES
MUST
BE
AT
LEAST
HALF
FULL
ROOT
HAS
AT
LEAST
TWO
CHILDREN
IF
IT
IS
NOT
A
LEAF
NODE
NON
LEAF
NODES
WITH
K
CHILDREN
HAVE
K
KEYS
STORED
ALL
LEAVES
APPEAR
ON
THE
SAME
LEVEL
START
WITH
A
SINGLE
NODE
ADD
KEYS
UNTIL
THE
NODE
FILLS
I
E
CONTAINS
M
KEYS
HAS
M
CHILDREN
IN
ADDING
THE
MTH
KEY
SPLIT
THE
NODE
IN
TWO
PULL
ONE
KEY
UP
TO
THE
PARENT
NODE
POTENTIALLY
CREATING
A
NEW
PARENT
NODE
OK
SO
HOW
DOES
THIS
HELP
US
STORE
TRANSACTION
RECORDS
SEE
HOW
TO
STORE
IDS
AS
KEYS
BUT
WHAT
ABOUT
FULL
RECORDS
OF
A
SALE
TRANSACTION
ID
CUSTOMER
INFO
PRICE
ITEM
PURCHASED
HOW
MANY
PURCHASED
ETC
RUNTIME
SEARCH
INSERT
TO
MAINTAIN
INVARIANTS
TREE
MUST
BE
SELF
BALANCING
FIND
AND
DELETE
THE
KEY
IF
THE
KEY
IS
NOT
IN
A
LEAF
NODE
YOU
NEED
TO
FIND
A
REPLACEMENT
REBALANCE
THE
TREE
IS
THERE
A
SIBLING
NODE
WITH
MORE
THAN
MINIMUM
KEYS
IF
SO
ROTATE
RIGHT
LEFT
ACCORDINGLY
IF
NOT
NEED
TO
MERGE
WITH
THE
LEFT
OR
RIGHT
SIBLING
HOW
LONG
WILL
IT
TAKE
US
TO
FIND
ALL
THE
DISK
BLOCKS
CONTAINING
RECORDS
IS
THERE
A
BETTER
WAY
MAINTAIN
A
COPY
OF
ALL
KEYS
IN
THE
LEAVES
OF
THE
TREE
CREATE
A
LINKED
LIST
OUT
OF
THE
LEAF
NODES
OF
THE
TREE
DEFINING
ORDER
HERE
M
IS
THE
MAX
NUMBER
OF
CHILDREN
ELSEWHERE
COULD
BE
THE
MIN
NUMBER
OF
KEYS
MIN
WAS
THE
ORIGINAL
NOTATION
BUT
IS
AMBIGUOUS
WHERE
TO
GO
TO
FOLLOW
KEYS
SOME
IMPLEMENTATIONS
HAVE
LEFT
LINK
POINT
TO
KEYS
AND
RIGHT
POINT
TO
KEYS
STRICTLY
OTHERS
HAVE
LEFT
POINT
TO
KEYS
STRICTLY
AND
RIGHT
POINT
TO
KEYS
THE
VARIANT
OF
B
TREES
PRESENTED
HERE
DIFFERS
SLIGHTLY
FROM
THAT
PRESENTED
IN
THE
BOOK
B
TREES
ARE
NOT
DISCUSSED
IN
THE
BOOK
TYPICALLY
YOU
LL
STORE
SUCH
RECORDS
IN
A
DATABASE
BUT
HOW
DOES
THE
DATABASE
STORE
RECORDS
IBM
INFORMIX
MICROSOFT
SQL
SERVER
ORACLE
SYBASE
ASE
AND
SQLITE
ALL
USE
B
TREES
TO
STORE
TABLES
INDEXES
OTHER
APPLICATIONS
NTFS
REISERFS
NSS
XFS
JFS
REFS
AND
BFS
ALL
USE
B
TREES
FOR
METADATA
INDEXING
CS
COE
CS
PITT
EDU
BILL
HASHING
SEARCH
THROUGH
A
COLLECTION
COULD
BE
ACCOMPLISHED
IN

WITH
RELATIVELY
SMALL
MEMORY
NEEDS
LET
TRY
THIS
ASSUME
WE
HAVE
AN
ARRAY
OF
LENGTH
M
CALL
IT
HT
ASSUME
WE
HAVE
A
FUNCTION
H
X
THAT
MAPS
FROM
OUR
KEY
SPACE
TO
M
E
G
H

M
INTEGER
KEYS
LET
ALSO
ASSUME
H
X
IS
EFFICIENT
TO
COMPUTE
THIS
IS
THE
BASIC
PREMISE
OF
HASH
TABLES
INSERT
I
H
X
HT
I
X
SEARCH
I
H
X
IF
HT
I
X
RETURN
TRUE
ELSE
RETURN
FALSE
THIS
IS
A
VERY
GENERAL
SIMPLE
APPROACH
TO
A
HASH
TABLE
IMPLEMENTATION
WHERE
WILL
IT
RUN
INTO
PROBLEMS
CALLED
A
COLLISION
COMPANY
HAS
EMPLOYEES
STORES
RECORDS
USING
A
HASHMAP
WITH
ENTRIES
EMPLOYEE
SSNS
ARE
HASHED
TO
STORE
RECORDS
IN
THE
HASHMAP
KEYS
ARE
SSNS
SO
KEYSPACE
SPECIFICALLY
WHAT
KEYS
ARE
NEEDED
CAN
T
BE
KNOWN
IN
ADVANCE
DUE
TO
EMPLOYEE
TURNOVER
WHAT
IF
ONE
EMPLOYEE
WITH
SSN
X
IS
FIRED
AND
REPLACEMENT
HAS
AN
SSN
OF
Y
CAN
WE
DESIGN
A
HASH
FUNCTION
THAT
GUARANTEES
H
Y
DOES
NOT
COLLIDE
WITH
THE
OTHER
EMPLOYEES
HASHED
SSNS
CAN
WE
EVER
GUARANTEE
COLLISIONS
WILL
NOT
OCCUR
YES
IF
THE
OUR
KEYSPACE
IS
SMALLER
THAN
OUR
HASHMAP
IF
KEYSPACE
M
PERFECT
HASHING
CAN
BE
USED
I
E
A
HASH
FUNCTION
THAT
MAPS
EVERY
KEY
TO
A
DISTINCT
INTEGER
M
NOTE
IT
CAN
ALSO
BE
USED
IF
N
M
AND
THE
KEYS
TO
BE
INSERTED
ARE
KNOWN
IN
ADVANCE
E
G
HASHING
THE
KEYWORDS
OF
A
PROGRAMMING
LANGUAGE
DURING
COMPILATION
IF
KEYSPACE
M
COLLISIONS
CANNOT
BE
AVOIDED
CAN
WE
REDUCE
THE
NUMBER
OF
COLLISIONS
USING
A
GOOD
HASH
FUNCTION
IS
A
START
WHAT
MAKES
A
GOOD
HASH
FUNCTION
UTILIZE
THE
ENTIRE
KEY
EXPLOIT
DIFFERENCES
BETWEEN
KEYS
UNIFORM
DISTRIBUTION
OF
HASH
VALUES
SHOULD
BE
PRODUCED
HASH
LIST
OF
CLASSMATES
BY
PHONE
NUMBER
BAD
USE
FIRST
DIGITS
BETTER
CONSIDER
IT
A
SINGLE
INT
TAKE
THAT
VALUE
MODULO
M
HASH
WORDS
BAD
ADD
UP
THE
ASCII
VALUES
BETTER
USE
HORNER
METHOD
TO
DO
MODULAR
HASHING
AGAIN
SEE
SECTION
OF
THE
TEXT
HORNER
METHOD
BASE
BASE
BASE
ASCII
STRINGS
B
E
E
F
OVERALL
A
GOOD
SIMPLE
GENERAL
APPROACH
TO
IMPLEMENT
A
HASH
MAP
BASIC
FORMULA
H
X
C
X
MOD
M
WHERE
C
X
CONVERTS
X
INTO
A
POSSIBLY
LARGE
INTEGER
GENERALLY
WANT
M
TO
BE
A
PRIME
NUMBER
CONSIDER
M
ONLY
THE
LEAST
SIGNIFICANT
DIGITS
MATTER
H
H
H
BY
CHOOSING
A
GOOD
HASH
FUNCTION
WE
CAN
REDUCE
THE
NUMBER
OF
COLLISIONS
BUT
WE
STILL
NEED
TO
DEAL
WITH
THOSE
WE
CANNOT
PREVENT
COLLISION
RESOLUTION
TWO
MAIN
APPROACHES
OPEN
ADDRESSING
CLOSED
ADDRESSING
I
E
IF
A
PIGEON
HOLE
IS
TAKEN
IT
HAS
TO
FIND
ANOTHER
IF
H
X
H
Y
I
AND
X
IS
STORED
AT
INDEX
I
IN
AN
EXAMPLE
HASH
TABLE
IF
WE
WANT
TO
INSERT
Y
WE
MUST
TRY
ALTERNATIVE
INDICES
THIS
MEANS
Y
WILL
NOT
BE
STORED
AT
HT
H
Y
WE
MUST
SELECT
ALTERNATIVES
IN
A
CONSISTENT
AND
PREDICTABLE
WAY
SO
THAT
THEY
CAN
BE
LOCATED
LATER
INSERT
IF
WE
CANNOT
STORE
A
KEY
AT
INDEX
I
DUE
TO
COLLISION
ATTEMPT
TO
INSERT
THE
KEY
AT
INDEX
I
THEN
I
AND
SO
ON
MOD
M
UNTIL
AN
OPEN
SPACE
IS
FOUND
SEARCH
IF
ANOTHER
KEY
IS
STORED
AT
INDEX
I
CHECK
I
I
I
UNTIL
KEY
IS
FOUND
EMPTY
LOCATION
IS
FOUND
WE
CIRCLE
THROUGH
THE
BUFFER
BACK
TO
I
H
X
X
MOD
INSERT
HOW
WOULD
DELETES
BE
HANDLED
WHAT
HAPPENS
IF
KEY
IS
REMOVED
WELL
NOT
QUITE
CONSIDER
THE
LOAD
FACTOR

N
M
AS

INCREASES
WHAT
HAPPENS
TO
HASH
TABLE
PERFORMANCE
CONSIDER
AN
EMPTY
TABLE
USING
A
GOOD
HASH
FUNCTION
WHAT
IS
THE
PROBABILITY
THAT
A
KEY
X
WILL
BE
INSERTED
INTO
ANY
ONE
OF
THE
INDICES
IN
THE
HASH
TABLE
CONSIDER
A
TABLE
THAT
HAS
A
CLUSTER
OF
C
CONSECUTIVE
INDICES
OCCUPIED
WHAT
IS
THE
PROBABILITY
THAT
A
KEY
X
WILL
BE
INSERTED
INTO
THE
INDEX
DIRECTLY
AFTER
THE
CLUSTER
WE
MUST
MAKE
SURE
THAT
EVEN
AFTER
A
COLLISION
ALL
OF
THE
INDICES
OF
THE
HASH
TABLE
ARE
POSSIBLE
FOR
A
KEY
PROBABILITY
OF
FILLED
LOCATIONS
NEED
TO
BE
DISTRIBUTED
THROUGHOUT
THE
TABLE
AFTER
A
COLLISION
INSTEAD
OF
ATTEMPTING
TO
PLACE
THE
KEY
X
IN
I
MOD
M
LOOK
AT
I
X
MOD
M
IS
A
SECOND
DIFFERENT
HASH
FUNCTION
SHOULD
STILL
FOLLOW
THE
SAME
GENERAL
RULES
AS
H
TO
BE
CONSIDERED
GOOD
BUT
NEEDS
TO
BE
DIFFERENT
FROM
H
H
X
H
Y
AND
X
Y
SHOULD
BE
VERY
UNLIKELY
HENCE
IT
SHOULD
BE
UNLIKELY
FOR
TWO
KEYS
TO
USE
THE
SAME
INCREMENT
H
X
X
MOD
X
X
MOD
INSERT
INSERT
SECOND
HASH
FUNCTION
CANNOT
MAP
A
VALUE
TO
YOU
SHOULD
TRY
ALL
INDICES
ONCE
BEFORE
TRYING
ONE
TWICE
WERE
EITHER
OF
THESE
ISSUES
FOR
LINEAR
PROBING
AS

MEANING
N
APPROACHES
M
BOTH
LINEAR
PROBING
AND
DOUBLE
HASHING
DEGRADE
TO

N
HOW
MULTIPLE
COLLISIONS
WILL
OCCUR
IN
BOTH
SCHEMES
CONSIDER
INSERTS
AND
MISSES
BOTH
CONTINUE
UNTIL
AN
EMPTY
INDEX
IS
FOUND
WITH
FEW
INDICES
AVAILABLE
CLOSE
TO
M
PROBES
WILL
NEED
TO
BE
PERFORMED

M
N
IS
APPROACHING
M
SO
THIS
TURNS
OUT
TO
BE

N
MUST
KEEP
A
PORTION
OF
THE
TABLE
EMPTY
TO
MAINTAIN
RESPECTABLE
PERFORMANCE
FOR
LINEAR
PROBING
IS
A
GOOD
RULE
OF
THUMB
CAN
GO
HIGHER
WITH
DOUBLE
HASHING
MOST
COMMONLY
DONE
WITH
SEPARATE
CHAINING
I
E
IF
A
PIGEON
HOLE
IS
TAKEN
IT
LIVES
WITH
A
ROOMMATE
CREATE
A
LINKED
LIST
OF
KEYS
AT
EACH
INDEX
IN
THE
TABLE
AS
WITH
DLBS
PERFORMANCE
DEPENDS
ON
CHAIN
LENGTH
WHICH
IS
DETERMINED
BY

AND
THE
QUALITY
OF
THE
HASH
FUNCTION
CLOSED
ADDRESSING
HASH
TABLES
ARE
FAST
AND
EFFICIENT
FOR
A
LARGE
NUMBER
OF
APPLICATIONS
CS
COE
CS
PITT
EDU
BILL
COMPRESSION
REPRESENT
THE
SAME
DATA
USING
LESS
STORAGE
SPACE
CAN
GET
MORE
USE
OUT
A
DISK
OF
A
GIVEN
SIZE
CAN
GET
MORE
USE
OUT
OF
MEMORY
E
G
FREE
UP
MEMORY
BY
COMPRESSING
INACTIVE
SECTIONS
FASTER
THAN
PAGING
BUILT
IN
TO
MAC
OS
X
AND
LATER
CAN
REDUCE
THE
AMOUNT
DATA
TRANSMITTED
FASTER
FILE
TRANSFERS
CUT
POWER
USAGE
ON
MOBILE
DEVICES
TWO
MAIN
APPROACHES
TO
COMPRESSION
D
C
D
INFORMATION
IS
PERMANENTLY
LOST
IN
THE
COMPRESSION
PROCESS
EXAMPLES
JPEG
WITH
AUDIO
VIDEO
FILES
THIS
TYPICALLY
ISN
T
A
HUGE
PROBLEM
AS
HUMAN
USERS
MIGHT
NOT
BE
ABLE
TO
PERCEIVE
THE
DIFFERENCE
CUTS
OUT
PORTIONS
OF
AUDIO
THAT
ARE
CONSIDERED
BEYOND
WHAT
MOST
PEOPLE
ARE
CAPABLE
OF
HEARING
JPEG
D
C
D
INPUT
CAN
BE
RECOVERED
FROM
COMPRESSED
DATA
EXACTLY
EXAMPLES
ZIP
FILES
FLAC
PNG
GIF
WORKS
ON
ARBITRARY
BIT
STRINGS
BUT
PRETTY
EASILY
EXPLAINED
USING
CHARACTERS
CONSIDER
THE
ASCII
CHARACTER
SET
ESSENTIALLY
BLOCKS
OF
CODES
IN
GENERAL
TO
FIT
R
POTENTIAL
CHARACTERS
IN
A
BLOCK
YOU
NEED
LG
R
BITS
OF
STORAGE
PER
BLOCK
CONSEQUENTLY
N
BIT
STORAGE
BLOCKS
CAN
REPRESENT
CHARACTERS
EACH
BIT
CODE
BLOCK
REPRESENTS
ONE
OF
POSSIBLE
CHARACTERS
IN
ASCII
EASY
TO
ENCODE
DECODE
WHAT
IF
WE
USED
VARIABLE
LENGTH
CODEWORDS
INSTEAD
OF
THE
CONSTANT
COULD
WE
STORE
THE
SAME
INFO
IN
LESS
SPACE
DIFFERENT
CHARACTERS
ARE
REPRESENTED
USING
CODES
OF
DIFFERENT
BIT
LENGTHS
IF
ALL
CHARACTERS
IN
THE
ALPHABET
HAVE
THE
SAME
USAGE
FREQUENCY
WE
CAN
T
BEAT
BLOCK
STORAGE
ON
A
CHARACTER
BY
CHARACTER
BASIS
WHAT
ABOUT
DIFFERENT
USAGE
FREQUENCIES
BETWEEN
CHARACTERS
IN
ENGLISH
R
T
L
N
E
ARE
USED
MUCH
MORE
THAN
Q
OR
X
DECODING
WAS
EASY
FOR
BLOCK
CODES
GRAB
THE
NEXT
BITS
IN
THE
BITSTRING
HOW
CAN
WE
DECODE
A
BITSTRING
THAT
IS
MADE
UP
OF
VARIABLE
LENGTH
CODE
WORDS
BAD
EXAMPLE
OF
VARIABLE
LENGTH
ENCODING
A
T
K
U
R
C
N
VARIABLE
LENGTH
ENCODING
FOR
LOSSLESS
COMPRESSION
CODES
MUST
BE
PREFIX
FREE
NO
CODE
CAN
BE
A
PREFIX
OF
ANY
OTHER
IN
THE
SCHEME
USING
THIS
WE
CAN
ACHIEVE
COMPRESSION
BY
USING
FEWER
BITS
TO
REPRESENT
MORE
COMMON
CHARACTERS
USING
LONGER
CODES
TO
REPRESENT
LESS
COMMON
CHARACTERS
HUFFMAN
ENCODING
ASSUME
WE
HAVE
K
CHARACTERS
THAT
ARE
USED
IN
THE
FILE
TO
BE
COMPRESSED
AND
EACH
HAS
A
WEIGHT
ITS
FREQUENCY
OF
USE
CREATE
A
FOREST
F
OF
K
SINGLE
NODE
TREES
ONE
FOR
EACH
CHARACTER
WITH
THE
SINGLE
NODE
STORING
THAT
CHAR
WEIGHT
WHILE
F
SELECT
F
THAT
HAVE
THE
SMALLEST
WEIGHTS
IN
F
CREATE
A
NEW
TREE
NODE
N
WHOSE
WEIGHT
IS
THE
SUM
OF
AND
WEIGHTS
ADD
AND
AS
CHILDREN
SUBTREES
OF
N
REMOVE
AND
FROM
F
ADD
THE
NEW
TREE
ROOTED
BY
N
TO
F
BUILD
A
TREE
FOR
ABRACADABRA
TO
ENCODE
DECODE
WE
LL
NEED
TO
READ
IN
CHARACTERS
AND
OUTPUT
CODES
READ
IN
CODES
AND
OUTPUT
CHARACTERS
SOUNDS
LIKE
WE
LL
NEED
A
SYMBOL
TABLE
WHAT
IMPLEMENTATION
WOULD
BE
BEST
SAME
FOR
ENCODING
AND
DECODING
NOTE
THAT
THIS
MEANS
WE
NEED
ACCESS
TO
THE
TRIE
TO
EXPAND
A
COMPRESSED
FILE
NEED
TO
EFFICIENTLY
BE
ABLE
TO
SELECT
LOWEST
WEIGHT
TREES
TO
MERGE
WHEN
CONSTRUCTING
THE
TRIE
CAN
ACCOMPLISH
THIS
USING
A
PRIORITY
QUEUE
NEED
TO
BE
ABLE
TO
READ
WRITE
BITSTRINGS
UNLESS
WE
PICK
MULTIPLES
OF
BITS
FOR
OUR
CODEWORDS
WE
WILL
NEED
TO
READ
WRITE
FRACTIONS
OF
BYTES
FOR
OUR
CODEWORDS
WE
RE
NOT
ACTUALLY
GOING
TO
DO
I
O
ON
FRACTION
OF
BYTES
WE
LL
MAINTAIN
A
BUFFER
OF
BYTES
AND
PERFORM
BIT
PROCESSING
ON
THIS
BUFFER
SEE
BINARYSTDIN
JAVA
AND
BINARYSTDOUT
JAVA
PRIVATE
STATIC
VOID
WRITEBIT
BOOLEAN
BIT
ADD
BIT
TO
BUFFER
BUFFER
IF
BIT
BUFFER
IF
BUFFER
IS
FULL
BITS
WRITE
OUT
AS
A
SINGLE
BYTE
N
IF
N
CLEARBUFFER
WRITEBIT
TRUE
WRITEBIT
FALSE
WRITEBIT
TRUE
WRITEBIT
FALSE
WRITEBIT
FALSE
WRITEBIT
FALSE
WRITEBIT
FALSE
WRITEBIT
TRUE
BUFFER
N
BINARY
I
O
PRIVATE
STATIC
VOID
WRITETRIE
NODE
X
IF
X
ISLEAF
BINARYSTDOUT
WRITE
TRUE
BINARYSTDOUT
WRITE
X
CH
RETURN
BINARYSTDOUT
WRITE
FALSE
WRITETRIE
X
LEFT
WRITETRIE
X
RIGHT
PRIVATE
STATIC
NODE
READTRIE
IF
BINARYSTDIN
READBOOLEAN
RETURN
NEW
NODE
BINARYSTDIN
READCHAR
NULL
NULL
RETURN
NEW
NODE
READTRIE
READTRIE
ENCODING
APPROACH
READ
INPUT
COMPUTE
FREQUENCIES
BUILD
TRIE
CODEWORD
TABLE
WRITE
OUT
TRIE
AS
A
BITSTRING
TO
COMPRESSED
FILE
WRITE
OUT
CHARACTER
COUNT
OF
INPUT
USE
TABLE
TO
WRITE
OUT
THE
CODEWORD
FOR
EACH
INPUT
CHARACTER
DECODING
APPROACH
READ
TRIE
READ
CHARACTER
COUNT
USE
TRIE
TO
DECODE
BITSTRING
OF
COMPRESSED
FILE
OPTION
PREPROCESS
THE
FILE
TO
BE
COMPRESSED
UPSIDE
ENSURE
THAT
HUFFMAN
ALGORITHM
WILL
PRODUCE
THE
BEST
OUTPUT
FOR
THE
GIVEN
FILE
DOWNSIDES
REQUIRES
TWO
PASSES
OVER
THE
INPUT
ONE
TO
ANALYZE
FREQUENCIES
BUILD
THE
TRIE
BUILD
THE
CODE
LOOKUP
TABLE
AND
ANOTHER
TO
COMPRESS
THE
FILE
TRIE
MUST
BE
STORED
WITH
THE
COMPRESSED
FILE
REDUCING
THE
QUALITY
OF
THE
COMPRESSION
THIS
ESPECIALLY
HURTS
SMALL
FILES
GENERALLY
LARGE
FILES
ARE
MORE
AMENABLE
TO
HUFFMAN
COMPRESSION
JUST
BECAUSE
A
FILE
IS
LARGE
HOWEVER
DOES
NOT
MEAN
THAT
IT
WILL
COMPRESS
WELL
OPTION
USE
A
STATIC
TRIE
ANALYZE
MULTIPLE
SAMPLE
FILES
BUILD
A
SINGLE
TREE
THAT
WILL
BE
USED
FOR
ALL
COMPRESSIONS
EXPANSIONS
SAVES
ON
TRIE
STORAGE
OVERHEAD
BUT
IN
GENERAL
NOT
A
VERY
GOOD
APPROACH
DIFFERENT
CHARACTER
FREQUENCY
CHARACTERISTICS
OF
DIFFERENT
FILES
MEANS
THAT
A
CODE
SET
TRIE
THAT
WORKS
WELL
FOR
ONE
FILE
COULD
WORK
VERY
POORLY
FOR
ANOTHER
COULD
EVEN
CAUSE
AN
INCREASE
IN
FILE
SIZE
AFTER
COMPRESSION
OPTION
ADAPTIVE
HUFFMAN
CODING
SINGLE
PASS
OVER
THE
DATA
TO
CONSTRUCT
THE
CODES
AND
COMPRESS
A
FILE
WITH
NO
BACKGROUND
KNOWLEDGE
OF
THE
SOURCE
DISTRIBUTION
NOT
GOING
TO
REALLY
FOCUS
ON
ADAPTIVE
HUFFMAN
IN
THE
CLASS
JUST
POINTING
OUT
THAT
IT
EXISTS
ASCII
REQUIRES
BITS
TO
STORE
M
CHARACTERS
FOR
A
FILE
CONTAINING
C
DIFFERENT
CHARACTERS
GIVEN
HUFFMAN
CODES
H
C
AND
FREQUENCIES
F
C
SUM
FROM
TO
C
HI
FI
TOTAL
STORAGE
DEPENDS
ON
THE
DIFFERENCES
IN
FREQUENCIES
THE
BIGGER
THE
DIFFERENCES
THE
BETTER
THE
POTENTIAL
FOR
COMPRESSION
HUFFMAN
IS
OPTIMAL
FOR
CHARACTER
BY
CHARACTER
PREFIX
FREE
ENCODINGS
PROOF
IN
PROPOSITIONS
T
AND
U
OF
SECTION
OF
THE
TEXT
WHERE
DOES
HUFFMAN
FALL
SHORT
WHAT
ABOUT
REPEATED
PATTERNS
OF
MULTIPLE
CHARACTERS
CONSIDER
A
FILE
CONTAINING
A
B
OF
EVERY
ASCII
CHARACTER
WILL
THIS
COMPRESS
AT
ALL
WITH
HUFFMAN
ENCODING
NOPE
BUT
IT
SEEMS
LIKE
IT
SHOULD
BE
COMPRESSIBLE
COULD
REPRESENT
THE
PREVIOUSLY
MENTIONED
STRING
AS
ETC
ASSUMING
WE
USE
BITS
TO
REPRESENT
THE
NUMBER
OF
REPEATS
AND
BITS
TO
REPRESENT
THE
CHARACTER
BITS
NEEDED
TO
STORE
RUN
LENGTH
ENCODED
FILE
VS
BITS
FOR
INPUT
FILE
HUGE
SAVINGS
NOTE
THAT
THIS
INCREDIBLE
COMPRESSION
PERFORMANCE
IS
BASED
ON
A
VERY
SPECIFIC
SCENARIO
RUN
LENGTH
ENCODING
IS
NOT
GENERALLY
EFFECTIVE
FOR
MOST
FILES
AS
THEY
OFTEN
LACK
LONG
RUNS
OF
REPEATED
CHARACTERS
PATTERNS
ARE
COMPRESSIBLE
NEED
A
GENERAL
APPROACH
HUFFMAN
USED
VARIABLE
LENGTH
CODEWORDS
TO
REPRESENT
FIXED
LENGTH
PORTIONS
OF
THE
INPUT
LET
TRY
ANOTHER
APPROACH
THAT
USES
FIXED
LENGTH
CODEWORDS
TO
REPRESENT
VARIABLE
LENGTH
PORTIONS
OF
THE
INPUT
IDEA
THE
MORE
CHARACTERS
CAN
BE
REPRESENTED
IN
A
SINGLE
CODEWORD
THE
BETTER
THE
COMPRESSION
CONSIDER
THE
BITS
IN
ASCII
REPRESENTING
THE
WITH
A
SINGLE
BIT
CODEWORD
CUTS
THE
USED
SPACE
IN
HALF
SIMILARLY
REPRESENTING
LONGER
STRINGS
WITH
A
BIT
CODEWORD
WOULD
MEAN
EVEN
BETTER
SAVINGS
NEED
TO
AVOID
THE
SAME
PROBLEMS
AS
THE
USE
OF
A
STATIC
TRIE
FOR
HUFFMAN
ENCODING
SO
USE
AN
ADAPTIVE
ALGORITHM
AND
BUILD
UP
OUR
PATTERNS
AND
CODEWORDS
AS
WE
GO
THROUGH
THE
FILE
INITIALIZE
CODEBOOK
TO
ALL
SINGLE
CHARACTERS
E
G
CHARACTER
MAPS
TO
ITS
ASCII
VALUE
WHILE
EOF
MATCH
LONGEST
PREFIX
IN
CODEBOOK
OUTPUT
CODEWORD
TAKE
THIS
LONGEST
PREFIX
ADD
THE
NEXT
CHARACTER
IN
THE
FILE
AND
ADD
THE
RESULT
TO
THE
DICTIONARY
WITH
A
NEW
CODEWORD
COMPRESS
USING
BIT
CODEWORDS
TOBEORNOTTOBEORTOBEORNOT
INITIALIZE
CODEBOOK
TO
ALL
SINGLE
CHARACTERS
E
G
ASCII
VALUE
MAPS
TO
ITS
CHARACTER
WHILE
EOF
READ
NEXT
CODEWORD
FROM
FILE
LOOKUP
CORRESPONDING
PATTERN
IN
THE
CODEBOOK
OUTPUT
THAT
PATTERN
ADD
THE
PREVIOUS
PATTERN
THE
FIRST
CHARACTER
OF
THE
CURRENT
PATTERN
TO
THE
CODEBOOK
NOTE
THIS
MEANS
NO
CODEBOOK
ADDITION
AFTER
FIRST
PATTERN
OUTPUT
BOTH
COMPRESSION
AND
EXPANSION
CONSTRUCT
THE
SAME
CODEBOOK
COMPRESSION
STORES
CHARACTER
STRING
CODEWORD
EXPANSION
STORES
CODEWORD
CHARACTER
STRING
THEY
CONTAIN
THE
SAME
PAIRS
IN
THE
SAME
ORDER
HENCE
THE
CODEBOOK
DOESN
T
NEED
TO
BE
STORED
WITH
THE
COMPRESSED
FILE
SAVING
SPACE
EXPANSION
CAN
SOMETIMES
BE
A
STEP
AHEAD
OF
COMPRESSION
IF
DURING
COMPRESSION
THE
PATTERN
CODEWORD
THAT
WAS
JUST
ADDED
TO
THE
DICTIONARY
IS
IMMEDIATELY
USED
IN
THE
NEXT
STEP
THE
DECOMPRESSION
ALGORITHM
WILL
NOT
YET
KNOW
THE
CODEWORD
THIS
IS
EASILY
DETECTED
AND
DEALT
WITH
HOWEVER
COMPRESS
USING
BIT
CODEWORDS
AAAAAA
AA
AAA
EXPANSION
HOW
TO
REPRESENT
STORE
DURING
COMPRESSION
EXPANSION
CONSIDERATIONS
WHAT
OPERATIONS
ARE
NEEDED
HOW
MANY
OF
THESE
OPERATIONS
ARE
GOING
TO
BE
PERFORMED
DISCUSS
EVEN
FURTHER
IMPLEMENTATION
ISSUES
CODEBOOK
SIZE
WHAT
HAPPENS
WHEN
WE
RUN
OUT
OF
CODEWORDS
ONLY
POSSIBLE
CODEWORDS
FOR
N
BIT
CODES
TWO
PRIMARY
OPTIONS
STOP
ADDING
NEW
KEYWORDS
USE
THE
CODEBOOK
AS
IT
STANDS
MAINTAINS
LONG
ALREADY
ESTABLISHED
PATTERNS
BUT
IF
THE
FILE
CHANGES
IT
WILL
NOT
BE
COMPRESSED
AS
EFFECTIVELY
THROW
OUT
THE
CODEBOOK
AND
START
OVER
FROM
SINGLE
CHARACTERS
ALLOWS
NEW
PATTERNS
TO
BE
COMPRESSED
UNTIL
NEW
PATTERNS
ARE
BUILT
UP
THOUGH
COMPRESSION
WILL
BE
MINIMAL
HOW
LONG
SHOULD
CODEWORDS
BE
USE
FEWER
BITS
GIVES
BETTER
COMPRESSION
EARLIER
ON
BUT
LEAVES
FEWER
CODEWORDS
AVAILABLE
WHICH
WILL
HAMPER
COMPRESSION
LATER
ON
USE
MORE
BITS
DELAYS
ACTUAL
COMPRESSION
UNTIL
LONGER
PATTERNS
ARE
FOUND
DUE
TO
LARGE
CODEWORD
SIZE
MORE
CODEWORDS
AVAILABLE
MEANS
THAT
GREATER
COMPRESSION
GAINS
CAN
BE
MADE
LATER
ON
IN
THE
PROCESS
THIS
SOUNDS
EERILY
LIKE
VARIABLE
LENGTH
CODEWORDS
EXACTLY
WHAT
WE
SET
OUT
TO
AVOID
HERE
WE
RE
TALKING
ABOUT
A
DIFFERENT
TECHNIQUE
EXAMPLE
START
OUT
USING
BIT
CODEWORDS
WHEN
CODEWORD
IS
INSERTED
INTO
THE
CODEBOOK
SWITCH
TO
OUTPUTTING
GRABBING
BIT
CODEWORDS
WHEN
CODEWORD
IS
INSERTED
INTO
THE
CODEBOOK
SWITCH
TO
OUTPUTTING
GRABBING
BIT
CODEWORDS
ETC
HUFFMAN
VS
LZW
IN
GENERAL
LZW
WILL
GIVE
BETTER
COMPRESSION
ALSO
BETTER
FOR
COMPRESSION
ARCHIVED
DIRECTORIES
OF
FILES
WHY
VERY
LONG
PATTERNS
CAN
BE
BUILT
UP
LEADING
TO
BETTER
COMPRESSION
DIFFERENT
FILES
DON
T
HURT
EACH
OTHER
AS
THEY
DID
IN
HUFFMAN
REMEMBER
OUR
THOUGHTS
ON
USING
STATIC
TRIES
WELL
GIFS
USE
IT
AND
PDFS
MOST
DEDICATED
COMPRESSION
APPLICATIONS
USE
OTHER
ALGORITHMS
DEFLATE
COMBINATION
OF
AND
HUFFMAN
USED
BY
PKZIP
AND
GZIP
MOST
COMMON
ZIP
ALGORITHMS
BURROWS
WHEELER
TRANSFORMS
USED
BY
LZMA
USED
BY
BROTLI
INTRODUCED
BY
GOOGLE
IN
SEPT
BASED
AROUND
A
COMBINATION
OF
A
MODERN
VARIANT
OF
THE
ALGORITHM
HUFFMAN
CODING
AND
ORDER
CONTEXT
MODELING
HOW
MUCH
CAN
THEY
COMPRESS
A
FILE
BETTER
QUESTION
HOW
MUCH
CAN
A
FILE
BE
COMPRESSED
BY
ANY
ALGORITHM
NO
ALGORITHM
CAN
COMPRESS
EVERY
BITSTREAM
ASSUME
WE
HAVE
SUCH
AN
ALGORITHM
WE
CAN
USE
TO
COMPRESS
ITS
OWN
OUTPUT
AND
WE
COULD
KEEP
COMPRESSING
ITS
OUTPUT
UNTIL
OUR
COMPRESSED
FILE
IS
BITS
CLEARLY
THIS
CAN
T
WORK
PROOFS
IN
PROPOSITION
OF
SECTION
OF
THE
TEXT
YES
USING
SHANNON
ENTROPY
FOUNDED
BY
CLAUDE
SHANNON
IN
HIS
PAPER
A
MATHEMATICAL
THEORY
OF
COMMUNICATION
ENTROPY
IS
A
KEY
MEASURE
IN
INFORMATION
THEORY
SLIGHTLY
DIFFERENT
FROM
THERMODYNAMIC
ENTROPY
A
MEASURE
OF
THE
UNPREDICTABILITY
OF
INFORMATION
CONTENT
BY
LOSSLESSLY
COMPRESSING
DATA
WE
REPRESENT
THE
SAME
INFORMATION
IN
LESS
SPACE
HENCE
BITS
OF
UNCOMPRESSED
TEXT
HAS
LESS
ENTROPY
THAN
BITS
OF
COMPRESSED
DATA
TRANSLATING
A
LANGUAGE
INTO
BINARY
THE
ENTROPY
IS
THE
AVERAGE
NUMBER
OF
BITS
REQUIRED
TO
STORE
A
LETTER
OF
THE
LANGUAGE
ENTROPY
OF
A
MESSAGE
LENGTH
OF
MESSAGE
AMOUNT
OF
INFORMATION
CONTAINED
IN
THAT
MESSAGE
ON
AVERAGE
A
LOSSLESS
COMPRESSION
SCHEME
CANNOT
COMPRESS
A
MESSAGE
TO
HAVE
MORE
THAN
BIT
OF
INFORMATION
PER
BIT
OF
COMPRESSED
MESSAGE
UNCOMPRESSED
ENGLISH
HAS
BETWEEN
AND
BITS
OF
ENTROPY
PER
CHARACTER
OF
THE
MESSAGE
WEISSMAN
SCORES
ARE
A
MADE
UP
METRIC
FOR
SILICON
VALLEY
TV
CS
COE
CS
PITT
EDU
BILL
STRING
PATTERN
MATCHING
HAVE
A
PATTERN
STRING
P
OF
LENGTH
M
HAVE
A
TEXT
STRING
A
OF
LENGTH
N
CAN
WE
FIND
AN
INDEX
I
OF
STRING
A
SUCH
THAT
EACH
OF
THE
M
CHARACTERS
IN
THE
SUBSTRING
OF
A
STARTING
AT
I
MATCHES
EACH
CHARACTER
IN
P
EXAMPLE
CAN
WE
FIND
THE
PATTERN
FOX
IN
THE
TEXT
THE
QUICK
BROWN
FOX
JUMPS
OVER
THE
LAZY
DOG
YES
AT
INDEX
OF
THE
TEXT
STRING
BRUTE
FORCE
START
AT
THE
BEGINNING
OF
BOTH
PATTERN
AND
TEXT
COMPARE
CHARACTERS
LEFT
TO
RIGHT
MISMATCH
START
AGAIN
AT
THE
CHARACTER
OF
THE
TEXT
AND
THE
BEGINNING
OF
THE
PATTERN
PUBLIC
STATIC
INT
STRING
PAT
STRING
TXT
INT
M
PAT
LENGTH
INT
N
TXT
LENGTH
FOR
INT
I
I
N
M
I
INT
J
FOR
J
J
M
J
IF
TXT
CHARAT
I
J
PAT
CHARAT
J
BREAK
IF
J
M
RETURN
I
FOUND
AT
OFFSET
I
RETURN
N
NOT
FOUND
RUNTIME
WHAT
DOES
THE
WORST
CASE
LOOK
LIKE
A
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXY
P
XXXXY
M
N
M

NM
IF
N
M
IS
THE
AVERAGE
CASE
RUNTIME
ANY
BETTER
ASSUME
WE
MOSTLY
MISS
ON
THE
FIRST
PATTERN
CHARACTER

N
M

N
IF
N
M
IMPROVE
WORST
CASE
THEORETICALLY
VERY
INTERESTING
PRACTICALLY
DOESN
T
COME
UP
THAT
OFTEN
FOR
HUMAN
LANGUAGE
IMPROVE
AVERAGE
CASE
MUCH
MORE
PRACTICALLY
HELPFUL
ESPECIALLY
IF
WE
ANTICIPATE
SEARCHING
THROUGH
LARGE
FILES
FIRST
IMPROVING
THE
WORST
CASE
DISCOVERED
THE
SAME
ALGORITHM
INDEPENDENTLY
KNUTH
MORRIS
PRATT
WORKED
TOGETHER
JOINTLY
PUBLISHED
IN
KNUTH
MORRIS
PRATT
ALGORITHM
KMP
GOAL
AVOID
BACKING
UP
IN
THE
TEXT
STRING
ON
A
MISMATCH
MAIN
IDEA
IN
CHECKING
THE
PATTERN
WE
LEARNED
SOMETHING
ABOUT
THE
CHARACTERS
IN
THE
TEXT
TAKE
ADVANTAGE
OF
THIS
KNOWLEDGE
TO
AVOID
BACKING
UP
BUILD
A
DETERMINISTIC
FINITE
STATE
AUTOMATA
DFA
STORING
INFORMATION
ABOUT
THE
PATTERN
FROM
A
GIVEN
STATE
IN
SEARCHING
THROUGH
THE
PATTERN
IF
YOU
ENCOUNTER
A
MISMATCH
HOW
MANY
CHARACTERS
CURRENTLY
MATCH
FROM
THE
BEGINNING
OF
THE
PATTERN
PATTERN
ABABAC
A
B
C
D
A
A
B
A
B
A
B
A
C
C
D
B
C
D
C
D
B
C
D
D
DFA
CAN
BE
REPRESENTED
AS
A
ARRAY
DFA
STORAGE
NEEDED
MR
PUBLIC
INT
STRING
PAT
STRING
TXT
INT
M
PAT
LENGTH
INT
N
TXT
LENGTH
INT
I
J
FOR
I
J
I
N
J
M
I
J
DFA
TXT
CHARAT
I
J
IF
J
M
RETURN
I
M
FOUND
RETURN
N
NOT
FOUND
RUNTIME
WHAT
IF
WE
COMPARE
STARTING
AT
THE
END
OF
THE
PATTERN
A
ABCDVABCDWABCDXABCDYABCDZ
P
ABCDE
V
DOES
NOT
MATCH
E
FURTHER
V
IS
NOWHERE
IN
THE
PATTERN
SO
SKIP
AHEAD
M
POSITIONS
WITH
COMPARISON
RUNTIME
IN
THE
BEST
CASE
N
M
WHEN
SEARCHING
THROUGH
TEXT
WITH
A
LARGE
ALPHABET
WILL
OFTEN
COME
ACROSS
CHARACTERS
NOT
IN
THE
PATTERN
ONE
OF
BOYER
MOORE
HEURISTICS
TAKES
ADVANTAGE
OF
THIS
FACT
MISMATCHED
CHARACTER
HEURISTIC
HOW
WELL
IT
WORKS
DEPENDS
ON
THE
PATTERN
AND
TEXT
AT
HAND
WHAT
DO
WE
DO
IN
THE
GENERAL
CASE
AFTER
A
MISMATCH
CONSIDER
A
XYXYXYZXXXXXXXXXXXXXX
P
XYXYZ
IF
MISMATCHED
CHARACTER
DOES
APPEAR
IN
P
NEED
TO
SLIDE
TO
THE
RIGHT
TO
THE
NEXT
OCCURRENCE
OF
THAT
CHARACTER
IN
P
REQUIRES
US
TO
PRE
PROCESS
THE
PATTERN
CREATE
A
RIGHT
ARRAY
FOR
ALL
I
RIGHT
I
FOR
ALL
J
FROM
TO
M
RIGHT
P
CHARAT
J
J
TEXT
A
B
C
D
X
A
B
C
D
C
A
B
C
D
Y
A
E
C
D
E
A
B
C
D
E
A
B
C
D
E
A
B
C
D
E
A
B
C
D
E
A
B
C
D
E
PATTERN
A
B
C
D
E
RIGHT
A
B
C
D
E
A
B
C
D
E
A
B
C
D
E
WHAT
DOES
THE
WORST
CASE
LOOK
LIKE
RUNTIME

NM
SAME
AS
BRUTE
FORCE
THIS
IS
WHY
MISSED
CHARACTER
IS
ONLY
ONE
OF
BOYER
MOORE
HEURISTICS
THE
GALIL
RULE
WORKS
SIMILARLY
TO
KMP
SEE
BOYERMOORE
JAVA
HASHING
WAS
COOL
LET
TRY
USING
THAT
PUBLIC
STATIC
INT
STRING
PAT
STRING
TXT
INT
M
PAT
LENGTH
INT
N
TXT
LENGTH
INT
H
PAT
FOR
INT
I
I
N
M
I
IF
H
TXT
SUBSTRING
I
I
M
RETURN
I
FOUND
RETURN
N
NOT
FOUND
IS
IT
EFFICIENT
NOPE
PRACTICALLY
WORSE
THAN
BRUTE
FORCE
INSTEAD
OF
NM
CHARACTER
COMPARISONS
WE
PERFORM
N
HASHES
OF
M
CHARACTER
STRINGS
CAN
WE
MAKE
AN
EFFICIENT
PATTERN
MATCHING
ALGORITHM
BASED
ON
HASHING
HORNER
METHOD
BROUGHT
UP
DURING
THE
HASHING
LECTURE
PUBLIC
LONG
STRING
KEY
INT
M
LONG
H
FOR
INT
J
J
M
J
H
R
H
KEY
CHARAT
J
Q
RETURN
H
ABCD
A
B
C
R
D
MOD
Q
BCDE
B
C
D
R
E
MOD
Q
CDEF
C
D
E
R
F
MOD
Q
TEXT
ABCDEFG
PATTERN
DEFG
THIS
IS
RABIN
KARP
NOTE
THAT
WE
RE
NOT
STORING
ANY
VALUES
IN
A
HASH
TABLE
SO
INCREASING
Q
DOESN
T
AFFECT
MEMORY
UTILIZATION
MAKE
Q
REALLY
BIG
AND
THE
CHANCE
OF
A
COLLISION
BECOMES
REALLY
SMALL
BUT
NOT
OK
SO
DO
A
CHARACTER
BY
CHARACTER
COMPARISON
ON
A
COLLISION
JUST
TO
BE
SURE
WORST
CASE
RUNTIME
BACK
TO
BRUTE
FORCE
ESQUE
RUNTIME
TWO
OPTIONS
DO
A
CHARACTER
BY
CHARACTER
COMPARISON
AFTER
COLLISION
GUARANTEED
CORRECT
PROBABLY
FAST
LAS
VEGAS
ASSUME
A
HASH
MATCH
MEANS
A
SUBSTRING
MATCH
GUARANTEED
FAST
PROBABLY
CORRECT
MONTE
CARLO
CS
COE
CS
PITT
EDU
BILL
PRIORITY
QUEUES
WE
MENTIONED
PRIORITY
QUEUES
IN
BUILDING
HUFFMAN
TRIES
PRIMARY
OPERATIONS
THEY
NEEDED
INSERT
FIND
ITEM
WITH
HIGHEST
PRIORITY
E
G
FINDMIN
OR
FINDMAX
REMOVE
AN
ITEM
WITH
HIGHEST
PRIORITY
E
G
REMOVEMIN
OR
REMOVEMAX
HOW
DO
WE
IMPLEMENT
THESE
OPERATIONS
SIMPLEST
APPROACH
ARRAYS
INSERT
ADD
NEW
ITEM
TO
THE
END
OF
THE
ARRAY

FIND
SEARCH
FOR
THE
HIGHEST
PRIORITY
ITEM
E
G
MIN
OR
MAX

N
REMOVE
SEARCH
FOR
THE
HIGHEST
PRIORITY
ITEM
AND
DELETE

N
TOTAL
RUNTIME
FOR
N
INSERTS
AND
DELETES

INSERT
ADD
NEW
ITEM
IN
APPROPRIATE
SORTED
ORDER

N
FIND
RETURN
THE
ITEM
AT
THE
END
OF
THE
ARRAY

REMOVE
RETURN
AND
DELETE
THE
ITEM
AT
THE
END
OF
THE
ARRAY

TOTAL
RUNTIME
FOR
N
INSERTS
AND
DELETES

WHAT
ABOUT
A
BINARY
SEARCH
TREE
INSERT
AVERAGE
CASE
OF

LG
N
BUT
WORST
CASE
OF

N
FIND
AVERAGE
CASE
OF

LG
N
BUT
WORST
CASE
OF

N
REMOVE
AVERAGE
CASE
OF

LG
N
BUT
WORST
CASE
OF

N
OK
SO
IN
THE
AVERAGE
CASE
ALL
OPERATIONS
ARE

LG
N
NO
CONSTANT
TIME
OPERATIONS
WORST
CASE
IS

N
FOR
ALL
OPERATIONS
OUR
FIND
AND
REMOVE
OPERATIONS
ONLY
NEED
THE
HIGHEST
PRIORITY
ITEM
NOT
TO
FIND
REMOVE
ANY
ITEM
CAN
WE
TAKE
ADVANTAGE
OF
THIS
TO
IMPROVE
OUR
RUNTIME
YES
A
HEAP
IS
COMPLETE
BINARY
TREE
SUCH
THAT
FOR
EACH
NODE
T
IN
THE
TREE
T
ITEM
IS
OF
A
HIGHER
PRIORITY
THAN
T
ITEM
T
ITEM
IS
OF
A
HIGHER
PRIORITY
THAN
T
ITEM
IT
DOES
NOT
MATTER
HOW
T
ITEM
RELATES
TO
T
ITEM
THIS
IS
A
RELAXATION
OF
THE
APPROACH
NEEDED
BY
A
BST
THE
HEAP
PROPERTY
FIND
IS
EASY
SIMPLY
THE
ROOT
OF
THE
TREE

REMOVE
AND
INSERT
ARE
NOT
QUITE
SO
TRIVIAL
THE
TREE
IS
MODIFIED
AND
THE
HEAP
PROPERTY
MUST
BE
MAINTAINED
ADD
A
NEW
NODE
AT
THE
NEXT
AVAILABLE
LEAF
PUSH
THE
NEW
NODE
UP
THE
TREE
UNTIL
IT
IS
SUPPORTING
THE
HEAP
PROPERTY
INSERT
TRICKY
TO
DELETE
ROOT
SO
LET
SIMPLY
OVERWRITE
THE
ROOT
WITH
THE
ITEM
FROM
THE
LAST
LEAF
AND
DELETE
THE
LAST
LEAF
BUT
THEN
THE
ROOT
IS
VIOLATING
THE
HEAP
PROPERTY
SO
WE
PUSH
THE
ROOT
DOWN
THE
TREE
UNTIL
IT
IS
SUPPORTING
THE
HEAP
PROPERTY
NO
FIND

INSERT
AND
REMOVE
HEIGHT
OF
A
COMPLETE
BINARY
TREE
IS
LG
N
AT
MOST
UPHEAP
AND
DOWNHEAP
OPERATIONS
TRAVERSE
THE
HEIGHT
OF
THE
TREE
HENCE
INSERT
AND
REMOVE
ARE

LG
N
SIMPLY
IMPLEMENT
TREE
NODES
LIKE
FOR
BST
THIS
REQUIRES
OVERHEAD
FOR
DYNAMIC
NODE
ALLOCATION
ALSO
MUST
FOLLOW
CHAINS
OF
PARENT
CHILD
RELATIONS
TO
TRAVERSE
THE
TREE
NOTE
THAT
A
HEAP
WILL
BE
A
COMPLETE
BINARY
TREE
WE
CAN
EASILY
REPRESENT
A
COMPLETE
BINARY
TREE
USING
AN
ARRAY
NUMBER
NODES
ROW
WISE
STARTING
AT
USE
THESE
NUMBERS
AS
INDICES
IN
THE
ARRAY
NOW
FOR
NODE
AT
INDEX
I
PARENT
I
I
I
I
FOR
ARRAYS
INDEXED
FROM
HEAPIFY
THE
NUMBERS
MAX
HEAP
TO
SORT
ASCENDING
MIN
HEAP
TO
SORT
DESCENDING
REMOVE
THE
ROOT
DON
T
ACTUALLY
DELETE
THE
LEAF
NODE
CONSIDER
THE
HEAP
TO
BE
FROM
LENGTH
REPEAT
RUNTIME
WORST
CASE
N
LOG
N
IN
PLACE
YES
STABLE
NO
WHAT
IF
WE
WANT
TO
UPDATE
AN
OBJECT
WHAT
IS
THE
RUNTIME
TO
FIND
AN
ARBITRARY
ITEM
IN
A
HEAP

N
HENCE
UPDATING
AN
ITEM
IN
THE
HEAP
IS

N
CAN
WE
IMPROVE
OF
THIS
BACK
THE
PQ
WITH
SOMETHING
OTHER
THAN
A
HEAP
DEVELOP
A
CLEVER
WORKAROUND
MAINTAIN
A
SECOND
DATA
STRUCTURE
THAT
MAPS
ITEM
IDS
TO
EACH
ITEM
CURRENT
POSITION
IN
THE
HEAP
THIS
CREATES
AN
INDEXABLE
PQ
INDIRECTION
EXAMPLE
SETUP
LET
SAY
I
M
SHOPPING
FOR
A
NEW
VIDEO
CARD
AND
WANT
TO
BUILD
A
HEAP
TO
HELP
ME
KEEP
TRACK
OF
THE
LOWEST
PRICE
AVAILABLE
FROM
DIFFERENT
STORES
KEEP
OBJECTS
OF
THE
FOLLOWING
TYPE
IN
THE
HEAP
CLASS
CARDPRICE
IMPLEMENTS
COMPARABLE
CARDPRICE
PUBLIC
STRING
STORE
PUBLIC
DOUBLE
PRICE
PUBLIC
CARDPRICE
STRING
DOUBLE
P
PUBLIC
INT
COMPARETO
CARDPRICE
O
IF
PRICE
O
PRICE
RETURN
ELSE
IF
PRICE
O
PRICE
RETURN
ELSE
RETURN
INDIRECTION
EXAMPLE
N
NEW
CARDPRICE
NE
A
NEW
CARDPRICE
AMZN
X
NEW
CARDPRICE
NCIX
B
NEW
CARDPRICE
BB
UPDATE
PRICE
FOR
NE
UPDATE
PRICE
FOR
NCIX
UPDATE
PRICE
FOR
BB
INDIRECTION
CS
COE
CS
PITT
EDU
BILL
GRAPHS
A
GRAPH
G
V
E
WHERE
V
IS
A
SET
OF
VERTICES
E
IS
A
SET
OF
EDGES
CONNECTING
VERTEX
PAIRS
EXAMPLE
V
E
CAN
BE
USED
TO
MODEL
MANY
DIFFERENT
SCENARIOS
UNDIRECTED
GRAPH
EDGES
ARE
UNORDERED
PAIRS
A
B
B
A
DIRECTED
GRAPH
EDGES
ARE
ORDERED
PAIRS
A
B
B
A
ADJACENT
VERTICES
OR
NEIGHBORS
VERTICES
CONNECTED
BY
AN
EDGE
LET
V
V
AND
E
E
GIVEN
V
WHAT
ARE
THE
MINIMUM
MAXIMUM
SIZES
OF
E
MINIMUM
VALUE
OF
E
DEFINITION
DOESN
T
NECESSITATE
THAT
THERE
ARE
ANY
EDGES
SO
MAXIMUM
OF
E
DEPENDS
ARE
SELF
EDGES
ALLOWED
DIRECTED
GRAPH
OR
UNDIRECTED
GRAPH
IN
THIS
CLASS
WE
LL
ASSUME
DIRECTED
GRAPHS
HAVE
SELF
EDGES
WHILE
UNDIRECTED
GRAPHS
DO
NOT
A
GRAPH
IS
CONSIDERED
SPARSE
IF
E
V
LG
V
A
GRAPH
IS
CONSIDERED
DENSE
AS
IT
APPROACHES
THE
MAXIMUM
NUMBER
OF
EDGES
I
E
E
MAX

A
COMPLETE
GRAPH
HAS
THE
MAXIMUM
NUMBER
OF
EDGES
OR
TRIVIALLY
GRAPHS
CAN
BE
REPRESENTED
AS
LIST
OF
VERTICES
LIST
OF
EDGES
PERFORMANCE
ASSUME
WE
RE
GOING
TO
BE
ANALYZING
STATIC
GRAPHS
I
E
NO
INSERT
AND
REMOVE
SO
WHAT
OPERATIONS
SHOULD
WE
CONSIDER
ROWS
COLUMNS
ARE
VERTEX
LABELS
M
I
J
IF
I
J
E
M
I
J
IF
I
J
E
RUNTIME
SPACE
ARRAY
OF
NEIGHBOR
LISTS
A
I
CONTAINS
A
LIST
OF
THE
NEIGHBORS
OF
VERTEX
I
RUNTIME
SPACE
WHERE
WOULD
WE
WANT
TO
USE
ADJACENCY
LISTS
VS
ADJACENCY
MATRICES
WHAT
ABOUT
THE
LIST
OF
NODES
LIST
OF
EDGES
APPROACH
PATH
A
SEQUENCE
OF
ADJACENT
VERTICES
SIMPLE
PATH
A
PATH
IN
WHICH
NO
VERTICES
ARE
REPEATED
SIMPLE
CYCLE
A
SIMPLE
PATH
WITH
THE
SAME
FIRST
AND
LAST
VERTEX
CONNECTED
GRAPH
A
GRAPH
IN
WHICH
A
PATH
EXISTS
BETWEEN
ALL
VERTEX
PAIRS
CONNECTED
COMPONENT
CONNECTED
SUBGRAPH
OF
A
GRAPH
ACYCLIC
GRAPH
A
GRAPH
WITH
NO
CYCLES
TREE
A
CONNECTED
ACYCLIC
GRAPH
HAS
EXACTLY
V
EDGES
WHAT
IS
THE
BEST
ORDER
TO
TRAVERSE
A
GRAPH
TWO
PRIMARY
APPROACHES
DEPTH
FIRST
SEARCH
DFS
DIVE
AS
DEEP
AS
POSSIBLE
INTO
THE
GRAPH
FIRST
BRANCH
WHEN
NECESSARY
BREADTH
FIRST
SEARCH
BFS
SEARCH
ALL
DIRECTIONS
EVENLY
I
E
FROM
I
VISIT
ALL
OF
I
NEIGHBORS
THEN
ALL
OF
THEIR
NEIGHBORS
ETC
ALREADY
SEEN
AND
USED
THIS
THROUGHOUT
THE
TERM
FOR
TRIES
FOR
HUFFMAN
ENCODING
CAN
BE
EASILY
IMPLEMENTED
RECURSIVELY
FOR
EACH
NODE
VISIT
FIRST
UNSEEN
NEIGHBOR
BACKTRACK
AT
DEAD
ENDS
I
E
NODES
WITH
NO
UNSEEN
NEIGHBORS
TRY
NEXT
UNSEEN
NEIGHBOR
AFTER
BACKTRACKING
CAN
BE
EASILY
IMPLEMENTED
USING
A
QUEUE
FOR
EACH
NODE
VISITED
ADD
ALL
OF
ITS
NEIGHBORS
TO
THE
QUEUE
VERTICES
THAT
HAVE
BEEN
SEEN
BUT
NOT
YET
VISITED
ARE
SAID
TO
BE
THE
FRINGE
POP
HEAD
OF
THE
QUEUE
TO
BE
THE
NEXT
VISITED
VERTEX
SEE
EXAMPLE
BFS
EXAMPLE
Q
BFS
TRAVERSALS
CAN
FURTHER
BE
USED
TO
DETERMINE
THE
SHORTEST
PATH
BETWEEN
TWO
VERTICES
AT
A
HIGH
LEVEL
DFS
AND
BFS
HAVE
THE
SAME
RUNTIME
EACH
NODE
MUST
BE
SEEN
AND
THEN
VISITED
BUT
THE
ORDER
WILL
DIFFER
BETWEEN
THESE
TWO
APPROACHES
HOW
WILL
THE
REPRESENTATION
OF
THE
GRAPH
AFFECT
THE
RUNTIMES
OF
OF
THESE
TRAVERSAL
ALGORITHMS
DFS
AND
BFS
WOULD
BE
CALLED
FROM
A
WRAPPER
FUNCTION
IF
THE
GRAPH
IS
CONNECTED
DFS
BFS
IS
CALLED
ONLY
ONCE
AND
RETURNS
A
SPANNING
TREE
ELSE
A
LOOP
IN
THE
WRAPPER
FUNCTION
WILL
HAVE
TO
CONTINUALLY
CALL
DFS
BFS
WHILE
THERE
ARE
STILL
UNSEEN
VERTICES
EACH
CALL
WILL
YIELD
A
SPANNING
TREE
FOR
A
CONNECTED
COMPONENT
OF
THE
GRAPH
A
BICONNECTED
GRAPH
HAS
AT
LEAST
DISTINCT
PATHS
NO
COMMON
EDGES
OR
VERTICES
BETWEEN
ALL
VERTEX
PAIRS
ANY
GRAPH
THAT
IS
NOT
BICONNECTED
HAS
ONE
OR
MORE
ARTICULATION
POINTS
VERTICES
THAT
IF
REMOVED
WILL
SEPARATE
THE
GRAPH
ANY
GRAPH
THAT
HAS
NO
ARTICULATION
POINTS
IS
BICONNECTED
THUS
WE
CAN
DETERMINE
THAT
A
GRAPH
IS
BICONNECTED
IF
WE
LOOK
FOR
BUT
DO
NOT
FIND
ANY
ARTICULATION
POINTS
VARIATION
ON
DFS
CONSIDER
BUILDING
UP
THE
SPANNING
TREE
HAVE
IT
BE
DIRECTED
CREATE
BACK
EDGES
WHEN
CONSIDERING
A
NODE
THAT
HAS
ALREADY
BEEN
VISITED
IN
CONSTRUCTING
THE
SPANNING
TREE
LABEL
EACH
VERTEX
V
WITH
WITH
TWO
NUMBERS
NUM
V
PRE
ORDER
TRAVERSAL
ORDER
LOW
V
LOWEST
NUMBERED
VERTEX
REACHABLE
FROM
V
USING
OR
MORE
SPANNING
TREE
EDGES
AND
THEN
AT
MOST
ONE
BACK
EDGE
MIN
OF
NUM
V
LOWEST
NUM
W
OF
ALL
BACK
EDGES
V
W
LOWEST
LOW
W
OF
ALL
SPANNING
TREE
EDGES
V
W
FINDING
ARTICULATION
POINTS
EXAMPLE
NUM
LOW
E
A
B
C
D
F
SO
WHERE
ARE
THE
ARTICULATION
POINTS
IF
ANY
NON
ROOT
VERTEX
V
HAS
SOME
CHILD
W
SUCH
THAT
LOW
W
NUM
V
V
IS
AN
ARTICULATION
POINT
WHAT
ABOUT
IF
WE
START
AT
AN
ARTICULATION
POINT
IF
THE
ROOT
OF
THE
SPANNING
TREE
HAS
MORE
THAN
ONE
CHILD
IT
IS
AN
ARTICULATION
POINT
CS
COE
CS
PITT
EDU
BILL
WEIGHTED
GRAPHS
LAST
TIME
WE
SAID
SPATIAL
LAYOUTS
OF
GRAPHS
WERE
IRRELEVANT
WE
DEFINE
GRAPHS
AS
SETS
OF
VERTICES
AND
EDGES
HOWEVER
WE
LL
CERTAINLY
WANT
TO
BE
ABLE
TO
REASON
ABOUT
BANDWIDTH
DISTANCE
CAPACITY
ETC
OF
THE
REAL
WORLD
THINGS
OUR
GRAPH
REPRESENTS
WHETHER
A
LINK
IS
GIGABIT
OR
MEGABIT
WILL
DRASTICALLY
AFFECT
OUR
ANALYSIS
OF
TRAFFIC
FLOWING
THROUGH
A
NETWORK
HAVING
A
ROAD
BETWEEN
TWO
CITIES
THAT
IS
A
LANE
COUNTRY
ROAD
IS
VERY
DIFFERENT
FROM
HAVING
A
LANE
HIGHWAY
IF
TWO
AIRPORTS
ARE
MILES
APART
THE
NUMBER
OF
FLIGHTS
GOING
IN
AND
OUT
BETWEEN
THEM
WILL
BE
DRASTICALLY
DIFFERENT
FROM
AIRPORTS
MILES
APART
WE
CAN
REPRESENT
SUCH
INFORMATION
WITH
EDGE
WEIGHTS
HOW
DO
WE
STORE
EDGE
WEIGHTS
ADJACENCY
MATRIX
ADJACENCY
LIST
DO
WE
NEED
A
WHOLE
NEW
GRAPH
REPRESENTATION
HOW
DO
WEIGHTS
AFFECT
FINDING
SPANNING
TREES
SHORTEST
PATHS
THE
WEIGHTED
VARIANTS
OF
THESE
PROBLEMS
ARE
CALLED
FINDING
THE
MINIMUM
SPANNING
TREE
AND
THE
WEIGHTED
SHORTEST
PATH
GRAPHS
CAN
POTENTIALLY
HAVE
MULTIPLE
SPANNING
TREES
MST
IS
THE
SPANNING
TREE
THAT
HAS
THE
MINIMUM
SUM
OF
THE
WEIGHTS
OF
ITS
EDGES
INITIALIZE
T
TO
CONTAIN
THE
STARTING
VERTEX
T
WILL
EVENTUALLY
BECOME
THE
MST
WHILE
THERE
ARE
VERTICES
NOT
IN
T
FIND
MINIMUM
EDGE
WEIGHT
EDGE
THAT
CONNECTS
A
VERTEX
IN
T
TO
A
VERTEX
NOT
YET
IN
T
ADD
THE
EDGE
WITH
ITS
VERTEX
TO
T
AT
EACH
STEP
CHECK
ALL
POSSIBLE
EDGES
FOR
A
COMPLETE
GRAPH
FIRST
ITERATION
V
POSSIBLE
EDGES
NEXT
ITERATION
V
POSSIBILITIES
EACH
VERTEX
IN
T
SHARED
V
EDGES
WITH
OTHER
VERTICES
BUT
THE
EDGES
THEY
SHARED
WITH
EACH
OTHER
ALREADY
IN
T
NEXT
V
POSSIBILITIES
RUNTIME
I
TO
V
I
V
I
EVALUATES
TO

DO
WE
NEED
TO
KEEP
TRACK
OF
ALL
POSSIBLE
EDGES
NO
WE
ONLY
NEED
THE
BEST
EDGE
FOR
POSSIBLE
FOR
EACH
VERTEX
PARENT
BEST
EDGE
LET
ASSUME
WE
USE
AN
ADJACENCY
MATRIX
TAKES

V
TO
CHECK
THE
NEIGHBORS
OF
A
GIVEN
VERTEX
FOR
EVERY
VERTEX
WE
ADD
TO
T
WE
LL
NEED
TO
CHECK
ALL
OF
ITS
NEIGHBORS
TO
CHECK
FOR
EDGES
TO
ADD
TO
T
NEXT
DURING
EACH
NEIGHBOR
CHECK
MAINTAIN
A
PARENT
AND
LIST
WHILE
T
V
NEW
T
T
NEW
FOR
J
TO
V
IF
M
NEW
J
J
T
M
NEW
J
J
PARENT
J
NEW
J
M
NEW
J
SOUNDS
LIKE
A
JOB
FOR
A
PRIORITY
QUEUE
PRIORITY
QUEUES
CAN
REMOVE
THE
MIN
VALUE
STORED
IN
THEM
IN

LG
N
ALSO

LG
N
TO
ADD
TO
THE
PRIORITY
QUEUE
WHAT
DOES
OUR
ALGORITHM
LOOK
LIKE
NOW
VISIT
A
VERTEX
ADD
EDGES
COMING
OUT
OF
IT
TO
A
PQ
WHILE
THERE
ARE
UNVISITED
VERTICES
POP
FROM
THE
PQ
FOR
THE
NEXT
VERTEX
TO
VISIT
AND
REPEAT
PQ
HAVE
TO
INSERT
ALL
E
EDGES
INTO
THE
PRIORITY
QUEUE
IN
THE
WORST
CASE
WE
LL
ALSO
HAVE
TO
REMOVE
ALL
E
EDGES
SO
WE
HAVE
E

LG
E
E

LG
E

E
LG
E

E
LG
E
THIS
ALGORITHM
IS
KNOWN
AS
LAZY
PRIM
DO
WE
REALLY
NEED
TO
MAINTAIN
E
ITEMS
IN
THE
PQ
I
SUPPOSE
WE
COULD
BE
LESS
LAZY
JUST
LIKE
WITH
THE
ADJACENCY
MATRIX
IMPLEMENTATION
WE
ONLY
NEED
THE
BEST
EDGE
FOR
EACH
VERTEX
PQ
WILL
NEED
TO
BE
INDEXABLE
THIS
IS
THE
IDEA
OF
EAGER
PRIM
RUNTIME
IS

E
LG
V
ADJACENCY
MATRIX
PRIM
RUNTIME

SPACE

V
LAZY
PRIM
RUNTIME

E
LG
SPACE

E
REQUIRES
A
PQ
EAGER
PRIM
RUNTIME

E
LG
V
SPACE

V
REQUIRES
AN
INDEXABLE
PQ
HOW
DO
THESE
COMPARE
DIJKSTRA
ALGORITHM
SET
A
DISTANCE
VALUE
OF
FOR
ALL
VERTICES
BUT
START
SET
CUR
START
WHILE
DESTINATION
IS
NOT
VISITED
FOR
EACH
UNVISITED
NEIGHBOR
OF
CUR
COMPUTE
TENTATIVE
DISTANCE
FROM
START
TO
THE
UNVISITED
NEIGHBOR
THROUGH
CUR
UPDATE
ANY
VERTICES
FOR
WHICH
A
LESSER
DISTANCE
IS
COMPUTED
MARK
CUR
AS
VISITED
LET
CUR
BE
THE
UNVISITED
VERTEX
WITH
THE
SMALLEST
TENTATIVE
DISTANCE
FROM
START
DISTANCE
VIA
HOW
TO
IMPLEMENT
BEST
PATH
PARENT
ARRAY
RUNTIME
PQ
TURNS
OUT
TO
BE
VERY
SIMILAR
TO
EAGER
PRIM
STORING
PATHS
INSTEAD
OF
EDGES
RUNTIME
KRUSKAL
MST
INSERT
ALL
EDGES
INTO
A
PQ
GRAB
THE
MIN
EDGE
FROM
THE
PQ
THAT
DOES
NOT
CREATE
A
CYCLE
IN
THE
MST
REMOVE
IT
FROM
THE
PQ
AND
ADD
IT
TO
THE
MST
PQ
INSTEAD
OF
BUILDING
UP
THE
MST
STARTING
FROM
A
SINGLE
VERTEX
WE
BUILD
IT
UP
USING
EDGES
ALL
OVER
THE
GRAPH
HOW
DO
WE
EFFICIENTLY
IMPLEMENT
CYCLE
DETECTION
CS
COE
CS
PITT
EDU
BILL
UNION
FIND
FOR
A
GIVEN
GRAPH
G
CAN
WE
DETERMINE
WHETHER
OR
NOT
TWO
VERTICES
ARE
CONNECTED
IN
G
CAN
ALSO
BE
VIEWED
AS
CHECKING
SUBSET
MEMBERSHIP
IMPORTANT
FOR
MANY
PRACTICAL
APPLICATIONS
WE
WILL
SOLVE
THIS
PROBLEM
USING
A
UNION
FIND
DATA
STRUCTURE
HAVE
AN
ID
ARRAY
SIMPLY
STORE
THE
COMPONENT
ID
FOR
EACH
ITEM
IN
THE
UNION
FIND
STRUCTURE
FIND
SIMPLY
RETURNS
ITS
ID
WHAT
ABOUT
UNION
U
U
U
U
U
U
U
ID
RUNTIME
FOR
FIND

FOR
UNION

N
INITIALIZE
WITH
N
ITEMS
NUMBERED
TO
N
UF
INT
N
VOID
UNION
INT
P
INT
Q
INT
FIND
INT
P
BOOLEAN
CONNECTED
INT
P
INT
Q
INT
COUNT
CONNECT
P
WITH
Q
RETURN
ID
OF
THE
CONNECTED
COMPONENT
THAT
P
IS
IN
TRUE
IF
P
AND
Q
ARE
CONNECTED
NUMBER
OF
CONNECTED
COMPONENTS
PUBLIC
INT
COUNT
RETURN
COUNT
PUBLIC
BOOLEAN
CONNECTED
INT
P
INT
Q
RETURN
FIND
P
FIND
Q
PUBLIC
UF
INT
N
COUNT
N
ID
NEW
INT
N
FOR
INT
I
I
N
I
ID
I
I
PUBLIC
INT
FIND
INT
P
RETURN
ID
P
PUBLIC
VOID
UNION
INT
P
INT
Q
INT
PID
FIND
P
QID
FIND
Q
IF
PID
QID
RETURN
FOR
INT
I
I
ID
LENGTH
I
IF
ID
I
PID
ID
I
QID
COUNT
WHAT
IF
WE
STORE
OUR
CONNECTED
COMPONENTS
AS
A
FOREST
OF
TREES
EACH
TREE
REPRESENTING
A
DIFFERENT
CONNECTED
COMPONENT
EVERY
TIME
A
NEW
CONNECTION
IS
MADE
WE
SIMPLY
MAKE
ONE
TREE
THE
CHILD
OF
ANOTHER
PUBLIC
INT
FIND
INT
P
WHILE
P
ID
P
P
ID
P
RETURN
P
PUBLIC
VOID
UNION
INT
P
INT
Q
INT
I
FIND
P
INT
J
FIND
Q
IF
I
J
RETURN
ID
I
J
COUNT
RUNTIME
FIND
BOUND
BY
THE
HEIGHT
OF
THE
TREE
UNION
BOUND
BY
THE
HEIGHT
OF
THE
TREE
WHAT
IS
THE
MAX
HEIGHT
OF
THE
TREE
CAN
WE
MODIFY
OUR
APPROACH
TO
CAP
ITS
MAX
HEIGHT
PUBLIC
UF
INT
N
COUNT
N
ID
NEW
INT
N
SZ
NEW
INT
N
FOR
INT
I
I
N
I
ID
I
I
SZ
I
PUBLIC
VOID
UNION
INT
P
INT
Q
INT
I
FIND
P
J
FIND
Q
IF
I
J
RETURN
IF
SZ
I
SZ
J
ID
I
J
SZ
J
SZ
I
ELSE
ID
J
I
SZ
I
SZ
J
COUNT
RUNTIME
FIND

LOG
N
UNION

LOG
N
CAN
WE
DO
ANY
BETTER
WITH
THIS
KNOWLEDGE
OF
UNION
FIND
HOW
EXACTLY
CAN
IT
BE
USED
AS
A
PART
OF
KRUSKAL
ALGORITHM
WHAT
IS
THE
RUNTIME
OF
KRUSKAL
ALGORITHM
CS
COE
CS
PITT
EDU
BILL
NETWORK
FLOW
CONSIDER
A
DIRECTED
WEIGHTED
GRAPH
G
V
E
WEIGHTS
ARE
APPLIED
TO
EDGES
TO
STATE
THEIR
CAPACITY
C
U
W
IS
THE
CAPACITY
OF
EDGE
U
W
IF
THERE
IS
NO
EDGE
FROM
U
TO
W
C
U
W
CONSIDER
TWO
NODES
A
SOURCE
AND
A
SINK
T
LET
DETERMINE
THE
MAXIMUM
FLOW
THAT
CAN
RUN
FROM
TO
T
IN
THE
GRAPH
G
LET
THE
F
U
W
BE
THE
AMOUNT
OF
FLOW
BEING
CARRIED
ALONG
THE
EDGE
U
W
SOME
RULES
ON
THE
FLOW
RUNNING
THROUGH
AN
EDGE
U
W
E
F
U
W
C
U
W
U
V
T
W
V
F
W
U
W
V
F
U
W
LET
ALL
EDGES
IN
G
HAVE
AN
ALLOCATED
FLOW
OF
WHILE
THERE
IS
PATH
P
FROM
TO
T
IN
G
T
ALL
EDGES
IN
P
HAVE
SOME
RESIDUAL
CAPACITY
I
E
U
W
P
F
U
W
C
U
W
SUCH
A
PATH
IS
CALLED
AN
AUGMENTING
PATH
COMPUTE
THE
RESIDUAL
CAPACITY
OF
EACH
EDGE
IN
P
RESIDUAL
CAPACITY
OF
EDGE
U
W
IS
C
U
W
F
U
W
FIND
THE
EDGE
WITH
THE
MINIMUM
RESIDUAL
CAPACITY
IN
P
WE
LL
CALL
THIS
RESIDUAL
CAPACITY
INCREMENT
THE
FLOW
ON
ALL
EDGES
IN
P
BY
TO
FIND
THE
MAX
FLOW
WE
WILL
HAVE
NEED
TO
CONSIDER
RE
ROUTING
FLOW
WE
HAD
PREVIOUSLY
ALLOCATED
THIS
MEANS
WHEN
FINDING
AN
AUGMENTING
PATH
WE
WILL
NEED
TO
LOOK
NOT
ONLY
AT
THE
EDGES
OF
G
BUT
ALSO
AT
BACKWARDS
EDGES
THAT
ALLOW
SUCH
RE
ROUTING
FOR
EACH
EDGE
U
W
E
A
BACKWARDS
EDGE
W
U
MUST
BE
CONSIDERED
DURING
PATHFINDING
IF
F
U
W
THE
CAPACITY
OF
A
BACKWARDS
EDGE
W
U
IS
EQUAL
TO
F
U
W
WE
WILL
PERFORM
SEARCHES
FOR
AN
AUGMENTING
PATH
NOT
ON
G
BUT
ON
A
RESIDUAL
GRAPH
BUILT
USING
THE
CURRENT
STATE
OF
FLOW
ALLOCATION
ON
G
THE
RESIDUAL
GRAPH
IS
MADE
UP
OF
V
AN
EDGE
FOR
EACH
U
W
E
WHERE
F
U
W
C
U
W
U
W
MIRROR
IN
THE
RESIDUAL
GRAPH
WILL
HAVE
FLOW
AND
A
CAPACITY
OF
C
U
W
F
U
W
A
BACKWARDS
EDGE
FOR
EACH
U
W
E
WHERE
F
U
W
U
W
BACKWARDS
EDGE
HAS
A
CAPACITY
OF
F
U
W
ALL
BACKWARDS
EDGES
HAVE
FLOW
RESIDUAL
GRAPH
EXAMPLE
A
B
T
A
T
B
HOW
THE
AUGMENTING
PATH
IS
CHOSEN
AFFECTS
THE
PERFORMANCE
OF
THE
SEARCH
FOR
MAX
FLOW
EDMONDS
AND
KARP
PROPOSED
A
SHORTEST
PATH
HEURISTIC
FOR
FORD
FULKERSON
USE
BFS
TO
FIND
AUGMENTING
PATHS
A
T
B
EDMONDS
KARP
ONLY
USES
BFS
USED
TO
FIND
SPANNING
TREES
AND
SHORTEST
PATHS
FOR
UNWEIGHTED
GRAPHS
WHY
DO
WE
NOT
USE
SOME
MEASURE
OF
PRIORITY
TO
FIND
AUGMENTING
PATHS
REPRESENTING
THE
GRAPH
SIMILAR
TO
A
DIRECTED
GRAPH
CAN
STORE
AN
ADJACENCY
LIST
OF
DIRECTED
EDGES
ACTUALLY
MORE
THAN
SIMPLY
DIRECTED
EDGES
FLOW
EDGES
FOR
EACH
EDGE
WE
NEED
TO
STORE
START
POINT
THE
FROM
VERTEX
END
POINT
THE
TO
VERTEX
CAPACITY
FLOW
RESIDUAL
CAPACITIES
FOR
FORWARDS
AND
BACKWARDS
EDGES
PUBLIC
CLASS
FLOWEDGE
PRIVATE
FINAL
INT
V
FROM
PRIVATE
FINAL
INT
W
TO
PRIVATE
FINAL
DOUBLE
CAPACITY
CAPACITY
PRIVATE
DOUBLE
FLOW
FLOW
PUBLIC
DOUBLE
RESIDUALCAPACITYTO
INT
VERTEX
IF
VERTEX
V
RETURN
FLOW
ELSE
IF
VERTEX
W
RETURN
CAPACITY
FLOW
ELSE
THROW
NEW
ILLEGALARGUMENTEXCEPTION
ILLEGAL
ENDPOINT
BFS
SEARCH
FOR
AN
AUGMENTING
PATH
PSEUDOCODE
EDGETO
V
MARKED
V
QUEUE
Q
Q
ENQUEUE
MARKED
TRUE
WHILE
Q
ISEMPTY
V
Q
DEQUEUE
EACH
FLOWEDGE
OBJECT
IS
STORED
IN
THE
ADJACENCY
LIST
TWICE
ONCE
FOR
ITS
FORWARD
EDGE
ONCE
FOR
ITS
BACKWARDS
EDGE
FOR
EACH
V
W
IN
ADJLIST
V
IF
RESIDUALCAPACITY
V
W
IF
MARKED
W
EDGETO
W
E
MARKED
W
TRUE
Q
ENQUEUE
W
A
C
T
B
AN
ST
CUT
ON
G
IS
A
SET
OF
EDGES
IN
G
THAT
IF
REMOVED
WILL
PARTITION
THE
VERTICES
OF
G
INTO
TWO
DISJOINT
SETS
ONE
CONTAINS
ONE
CONTAINS
T
MAY
BE
MANY
ST
CUTS
FOR
A
GIVEN
GRAPH
LET
FOCUS
ON
FINDING
THE
MINIMUM
ST
CUT
THE
ST
CUT
WITH
THE
SMALLEST
CAPACITY
MAY
NOT
BE
UNIQUE
WE
COULD
EXAMINE
RESIDUAL
GRAPHS
SPECIFICALLY
TRY
AND
ALLOCATE
FLOW
IN
THE
GRAPH
UNTIL
WE
GET
TO
A
RESIDUAL
GRAPH
WITH
NO
EXISTING
AUGMENTING
PATHS
THE
SET
OF
SATURATED
EDGES
MAKES
UP
A
MINIMUM
ST
CUT
A
C
T
B
A
SPECIAL
CASE
OF
DUALITY
I
E
YOU
CAN
LOOK
AT
AN
OPTIMIZATION
PROBLEM
FROM
TWO
ANGLES
IN
THIS
CASE
TO
FIND
THE
MAXIMUM
FLOW
OR
MINIMUM
CUT
IN
GENERAL
DUAL
PROBLEMS
DO
NOT
HAVE
TO
HAVE
EQUAL
SOLUTIONS
THE
DIFFERENCES
IN
SOLUTIONS
TO
THE
TWO
WAYS
OF
LOOKING
AT
THE
PROBLEM
IS
REFERRED
TO
AS
THE
DUALITY
GAP
IF
THE
DUALITY
GAP
STRONG
DUALITY
HOLDS
MAX
FLOW
MIN
CUT
UPHOLD
STRONG
DUALITY
IF
THE
DUALITY
GAP
WEAK
DUALITY
HOLDS
FIRST
RUN
FORD
FULKERSON
TO
PRODUCE
A
RESIDUAL
GRAPH
WITH
NO
FURTHER
AUGMENTING
PATHS
THE
LAST
ATTEMPT
TO
FIND
AN
AUGMENTING
PATH
WILL
VISIT
EVERY
NODE
REACHABLE
FROM
EDGES
WITH
ONLY
ONE
ENDPOINT
IN
THIS
SET
COMPRISE
A
MINIMUM
ST
CUT
A
C
T
B
MIN
CUT
IS
IT
POSSIBLE
HOW
WOULD
WE
MEASURE
THE
MAX
FLOW
MIN
CUT
WHAT
WOULD
AN
ALGORITHM
TO
SOLVE
THIS
PROBLEM
LOOK
LIKE
A
F
B
E
T
C
D
CS
MIDTERM
GREEDY
ALGORITHMS
FALL
CONSIDER
THEFOLLOWINGPROBLEM
THEINPUT
CONSISTS
OF
N
SKIERS
WITHHEIGHTS
PN
AND
N
SKIES
WITHHEIGHTS
SN
THEPROBLEMISTOASSIGN
EACH
SKIERASKI
TO
TO
MINIMIZETHE
AVERAGEDI
ERENCEBETWEENTHEHEIGHT
OF
A
SKIER
ANDHIS
HER
ASSIGNED
SKI
THAT
IS
IF
THE
ITH
SKIER
IS
GIVEN
THE
I
THSKI
THEN
YOU
WANT
TO
MINIMIZE
X
N
PI
I
N
I
SO
FOR
EXAMPLE
IF
AND
THEN
THE
MATCHING
AND
WHICH
MATCHESTHEFRSTPERSONTOTHE
THIRD
SKI
THE
SECOND
PERSON
TO
THE
SECOND
SKI
AND
THE
THIRD
PERSON
TO
THE
FRST
SKI
WOULD
HAVE
AVERAGE
DI
ERENCE
A
CONSIDER
THE
FOLLOWING
GREEDY
ALGORITHM
FIND
THE
SKIER
AND
SKI
WHOSE
HEIGHT
DI
ERENCE
IS
MINIMIZED
ASSIGN
THIS
SKIER
THIS
SKI
REPEAT
THE
PROCESS
UNTIL
EVERY
SKIER
HAS
A
SKI
PROVE
OF
DISPROVE
THAT
THIS
ALGORITHM
IS
CORRECT
B
CONSIDERTHEFOLLOWINGGREEDY
ALGORITHM
GIVETHE
SHORTEST
SKIERTHE
SHORTEST
SKI
GIVETHESECOND
SHORTEST
SKIERTHESECOND
SHORTEST
SKI
GIVETHETHIRD
SHORTEST
SKIER
THE
THIRD
SHORTEST
SKI
ETC
PROVE
OF
DISPROVE
THAT
THIS
ALGORITHM
IS
CORRECT
CS
MIDTERM
FALL
POINTS
WE
CONSIDER
THE
PROBLEM
OF
COMPUTING
THE
LONGEST
COMMON
SUBSEQUENCE
OF
TWO
SEQUENCES
A
AM
AND
B
BN
LET
T
I
J
BE
THELENGTHOF
THELONGEST
COMMON
SUBSEQUENCE
OF
AI
AND
BJ
A
WRITE
A
RECURSIVE
FUNCTION
TO
COMPUTE
T
I
J
IN
THE
NAIVE
WAY
DON
T
FORGET
THE
BASE
CASE
B
SHOWTHATIFYOUIMPLEMENTTHIS
RECURSIONDIRECTLY
IN
SAY
THECPROGRAMMING
LANGUAGE
THAT
THE
PROGRAM
COULD
USE
TIME
THAT
IS
EXPONENTIAL
IN
N
C
WRITE
ITERATIVE
ARRAY
BASED
CODE
TO
COMPUTE
T
M
N
THAT
RUNS
IN
O
N
TIME
D
WRITE
CODE
TO
ACTUALLY
FND
THE
LONGEST
COMMON
SUBSEQUENCE
FROM
YOUR
ARRAY
POINTS
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
IS
A
COLLECTION
OF
N
TRAIN
TRIPS
WITHIN
GERMANY
FOR
THE
ITH
TRIP
TI
YOU
ARE
GIVEN
THE
DATE
DI
OF
THAT
TRIP
AND
THE
NON
DISCOUNTED
FARE
FI
FOR
THAT
TRIP
FOR
SIMPLICITY
WE
WILL
ASSUME
THAT
DATES
ARE
NONNEGATIVE
INTEGERS
THE
GERMAN
RAILWAY
SYSTEM
SELLS
A
CLASS
A
BAHNCARD
FOR
Y
EUROSTHAT
ENTITLESYOUTO
FARE
REDUCTION
ON
ALL
TRAINTRAVEL
WITHINGERMANY
WITHIN
A
DAYS
OFPURCHASE
THEGERMAN
RAILWAY
SYSTEM
ALSO
SELLS
A
CLASS
B
BAHNCARD
FOR
M
EUROS
THAT
ENTITLES
YOU
TO
A
FARE
REDUCTION
ON
ALL
TRAIN
TRAVEL
WITHIN
GERMANY
WITHIN
B
DAYS
OF
PURCHASE
YOU
CAN
APPLY
AT
MOST
ONE
BAHNCARDDISCOUNTTO
APARTICULARTRIP
THEPROBLEMISTODETERMINETHELEASTYOUCAN
SPEND
ON
YOUR
TRAVEL
IN
THIS
PARAGRAPH
WE
GIVE
AN
EXAMPLE
ASSUME
THAT
Y
A
AND
M
AND
B
FURTHER
ASSUME
EUROS
EUROS
EUROS
EUROS
EUROS
AND
AND
EUROS
THEN
YOU
MIGHT
BUY
A
CLASS
B
BAHNCARD
ON
DAY
AND
A
CLASS
A
BAHNCARD
ON
DAY
THIS
RESULTS
IN
A
TOTAL
COST
OF
EUROS
GIVE
AN
O
N
TIME
ALGORITHM
FOR
PROBLEM
SIGNIFCANT
PARTIAL
CREDIT
WILL
BE
GIVEN
FOR
ANY
POLYNOMIAL
TIME
ALGORITHM
POINTS
THIS
IS
AN
ACTUAL
PROBLEM
THAT
ARISES
IN
VIDEO
PROCESSING
CALLED
TEMPORALLY
CONSISTENT
ASSIGNMENT
YOU
ARE
GIVEN
TWO
VIDEOS
EACH
REPRESENTED
AS
A
SEQUENCE
OF
IM
AGES
BOTH
VIDEOS
WERE
TAKEN
O
OF
THE
SAME
SCENE
AT
ROUGHLY
THE
SAME
TIME
PERIOD
LET
X
XM
BE
ONE
SEQUENCE
OF
IMAGES
AND
Y
YN
BE
THE
OTHER
SEQUENCE
OF
IMAGES
THE
CAMERAS
ARE
NOT
SYNCHRONIZED
AND
MAY
RUN
AT
SIGNIFCANTLY
DI
ERENT
SPEEDS
THE
OBJECTIVE
IS
TO
ASSIGN
EACH
IMAGE
OF
THE
X
VIDEO
SEQUENCE
WITHITS
MOST
SIMILARIMAGEIN
THE
Y
VIDEO
SEQUENCE
SUBJECTTOTHECONSTRAINTTHATTHEASSIGNMENTSARECONSISTENTINTIME
IN
ORDER
TO
DETERMINE
HOW
SIMILAR
TWO
IMAGES
ARE
AS
PART
OF
THE
INPUT
YOU
MAY
ASSUME
THAT
YOU
ARE
GIVEN
A
TABLE
D
I
J
WHICH
CONTAINS
A
NUMERIC
DISSIMILARITY
VALUE
BETWEEN
THESE
TWO
IMAGES
XI
AND
YJ
THE
LOWER
D
I
J
IS
THE
MORE
SIMILAR
THE
IMAGES
ARE
DO
NOT
WORRY
HOW
D
I
J
IS
COMPUTED
AN
ASSIGNMENT
OF
SEQUENCE
X
TO
SEQUENCE
Y
IS
A
SEQUENCE
OF
M
INDICES
A
JM
MEANING
THAT
FOR
I
M
IMAGE
XI
IS
ASSIGNED
TO
IMAGE
YJI
THE
COST
OF
AN
ASSIGNMENT
IS
A
SUM
OF
THE
DISSIMILARITIES
BETWEEN
THE
ASSIGNED
IMAGES
THAT
IS
P
M
COST
A
D
I
JI
AN
ASSIGNMENTA
IS
TEMPORALLY
CONSISTENT
IF
JI
JI
FOR
I
M
I
IN
OTHER
WORDS
IF
XI
IS
ASSIGNED
TO
SOME
IMAGE
YJI
THEN
THE
NEXT
IMAGE
IN
THE
SEQUENCE
XI
MUST
BE
ASSIGNED
TO
AN
IMAGE
APPEARING
NO
EARLIER
THAT
YJI
IN
THE
Y
IMAGE
SEQUENCE
THIS
MAKES
SENSE
AS
TIME
RUNS
FORWARD
FOR
BOTH
CAMERAS
WE
ALLOW
TWO
IMAGES
OF
X
TO
BE
AS
SIGNED
TO
THE
SAME
IMAGE
OF
Y
THE
PROBLEM
IS
GIVEN
THE
VIDEO
SEQUENCES
X
Y
AND
THE
COST
TABLE
D
I
J
COMPUTE
THE
MINIMUM
COST
TEMPORALLY
CONSISTENT
ASSIGNMENT
OF
X
TO
Y
CONSIDER
THE
FOLLOWING
TABLE
FOR
M
AND
N
D
I
J
J
J
J
J
J
J
I
I
I
IS
AND
IS
IS
ASSIGNED
TO
THENTHE
COST
OFTHIS
ASSIGNMENTIS
D
D
D
GIVE
ANO
N
TIME
ALGORITHMTO
COMPUTE
THELOWEST
ACHIEVABLE
COST
SIGNIFCANTPARTIALCREDIT
WILLBEGIVENFOR
ANY
ALGORITHM
WITHPOLYNOMIAL
RUNNING
TIME
CS
MIDTERM
FALL
POINTS
CONSIDER
THE
PROBLEM
INPUT
A
UNDIRECTED
GRAPH
G
AND
AN
INTEGER
K
OUTPUT
IF
G
HAS
THREE
VERTEX
DISJOINT
CLIQUES
OF
SIZE
K
AND
OTHERWISE
SHOW
THAT
THIS
PROBLEM
IS
NP
HARD
USE
THE
FACT
THAT
THE
CLIQUE
PROBLEM
IN
NP
COMPLETE
THE
INPUT
TO
THE
CLIQUE
PROBLEM
IS
AN
UNDIRECTED
GRAPH
H
AND
AN
INTEGER
J
THE
OUTPUT
SHOULD
BE
IF
H
CONTAINS
A
CLIQUE
OF
SIZE
J
AND
OTHERWISE
NOTE
THAT
A
CLIQUE
IS
A
MUTUALLY
ADJACENT
COLLECTION
OF
VERTICES
THREE
CLIQUES
ARE
DISJOINT
IF
NO
VERTEX
IS
IN
MORE
THAN
ONE
CLIQUE
POINTS
SHOW
THAT
THE
VERTEX
COVER
PROBLEM
IS
SELF
REDUCIBLE
THE
DECISION
PROBLEM
IS
TO
TAKE
A
GRAPH
G
AND
AN
INTEGER
K
AND
DECIDE
IF
G
HAS
A
VERTEX
COVER
OF
SIZE
K
OR
NOT
THE
OPTIMIZATIONPROBLEM
TAKES
AGRAPH
G
AND
RETURNSASMALLEST
VERTEXCOVERIN
G
SOYOU
MUST
SHOW
THAT
IF
THE
DECISION
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THE
OPTIMIZATION
PROBLEM
ALSO
HAS
A
POLYNOMIAL
TIME
ALGORITHM
RECALL
THAT
A
VERTEX
COVER
IS
A
COLLECTION
OF
VERTICES
WITH
THE
PROPERTY
THAT
EVERY
EDGE
IS
INCIDENT
TO
A
VERTEX
IN
POINTS
CONSIDER
THE
FOLLOWING
BAHNCARD
PROBLEM
WHERE
THE
INPUT
IS
A
COLLECTION
OF
N
TRAIN
TRIPS
WITHINGERMANY
FOR
THE
ITH
TRIP
TI
YOU
AREGIVENTHEDATEDI
OF
THAT
TRIP
AND
THE
NON
DISCOUNTED
FARE
FI
FORTHATTRIP
FORSIMPLICITY
WEWILL
ASSUMETHATDATESARE
NONNEGATIVE
INTEGERS
THE
GERMAN
RAILWAY
SYSTEM
SELLS
A
BAHNCARD
FOR
Y
EUROS
THAT
ENTITLES
YOU
TO
A
FARE
REDUCTION
ON
ALL
TRAIN
TRAVEL
WITHIN
GERMANY
WITHIN
A
DAYS
OF
PURCHASE
YOU
CAN
APPLY
AT
MOST
ONE
BAHNCARD
DISCOUNT
TO
A
PARTICULAR
TRIP
THE
PROBLEM
IS
TO
DETERMINE
THE
LEAST
YOU
CAN
SPEND
ON
YOUR
TRAVEL
IN
THIS
PARAGRAPH
WE
GIVE
AN
EXAMPLE
ASSUME
THAT
Y
A
FURTHER
ASSUME
EUROS
EUROS
EUROS
EUROS
EUROS
AND
AND
EUROS
THEN
YOU
MIGHT
BUY
A
BAHNCARD
ON
DAY
AND
DAY
THIS
RESULTS
IN
A
TOTAL
COST
OF
GIVE
AN
O
N
TIME
ALGORITHM
FOR
PROBLEM
SIGNIFCANT
PARTIAL
CREDIT
WILL
BE
GIVEN
FOR
ANY
POLYNOMIAL
TIME
ALGORITHM
CS
MIDTERM
FALL
POINTS
A
WHAT
IS
THE
MOST
IMPORTANT
REASON
THAT
IT
IS
STANDARD
PRACTICE
TO
IGNORE
MULTIPLICATIVE
CONSTANTS
WHEN
COMPUTING
RUNNING
TIMES
OF
ALGORITHMS
PROGRAMS
HINT
YOUR
ANSWER
SHOULD
EXPLAIN
WHY
WE
ARE
NOT
MORE
PRECISE
FOR
EXAMPLE
INCLUD
ING
MULTIPLICATIVE
CONSTANTS
AND
IGNORING
LOW
ORDER
TERMS
OR
LESS
PRECISE
FOR
EXAMPLE
IGNORINGPOLY
LOG
FACTORS
B
EXPLAIN
HOW
TO
COMPUTE
THE
MINIMUM
OF
N
NUMBERS
XN
IN
O
LOGN
TIME
WITH
N
LOGN
PROCESSORSON
AEREWPRAM
THATISYOUWANT
T
N
P
N
LOGN
O
LOGN
C
WHATISTHE
ECIENCY
OFTHEEREW
ALGORITHMINPART
A
START
WITH
THEDEFNITION
OF
ECIENCY
D
EXPLAIN
HOW
TO
COMPUTE
THE
MINIMUM
OF
N
NUMBERS
XN
IN
O
TIME
WITH
NPROCESSORS
ON
A
COMMON
CRCW
PRAM
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
STRING
C
OF
N
INTEGERS
THE
PROBLEM
IS
TO
FND
THE
LARGEST
K
K
N
SUCH
THAT
C
C
C
K
C
N
K
C
N
C
N
THAT
IS
K
IS
THE
LENGTH
OF
THE
LONGEST
PREFX
THAT
IS
ALSO
A
SUX
SO
FOR
EXAMPLE
IF
C
THEN
K
GIVE
A
EREW
PARALLEL
ALGORITHM
THAT
RUNS
IN
O
LOGN
TIME
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
POINTS
DESIGN
A
PARALLEL
ALGORITHM
THAT
FNDS
THE
MAXIMUM
NUMBER
IN
A
SEQUENCE
XN
OF
NOT
NECESSARILYDISTINCT
INTEGERSIN
THE
TO
N
YOUR
ALGORITHM
SHOULD
RUN
IN
CONSTANT
TIME
ON
A
CRCW
PRAM
WITH
N
PROCESSORS
NOTE
THAT
IT
IS
IMPORTANT
HERE
THAT
THE
XI
HAVE
RESTRICTED
RANGE
ADVERSARY
ARGUMENTS
SEARCHING
SECTION
SORTING
SECTION
QUESTIONS
MAXIMUM
FINDING
SUBSECTION
MAXIMUM
AND
MINIMUM
FINDING
SUBSECTION
MAXIMUM
AND
MAXIMUM
FINDING
SUBSECTION
NO
TITLE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
EXAMS
HTML
NEX
T
U
P
PREVIOU
NEXT
ABOUT
THIS
DOCUMENT
CS
FINAL
EXAM
SUMMER
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
CONSISTS
OF
THE
LENGTHS
AND
ACCESS
PROBABILITIES
FOR
N
FILES
THE
PROBLEM
IS
TO
ORDER
THESE
FILES
ON
A
TAPE
SO
AS
TO
MINIMIZE
THE
EXPECTED
ACCESS
TIME
IF
THE
FILES
ARE
PLACED
IN
THE
ORDER
THEN
THE
EXPECTED
ACCESS
TIME
IS
DON
T
LET
THIS
FORMULA
THROW
YOU
THE
TERM
IS
THE
PROBABILITY
THAT
YOU
ACCESS
THE
ITH
FILE
TIMES
THE
LENGTH
OF
THE
FIRST
I
FILES
FOR
EACH
OF
THE
BELOW
ALGORITHMS
EITHER
GIVE
A
PROOF
THAT
THE
ALGORITHM
IS
CORRECT
OR
A
PROOF
THAT
THE
ALGORITHM
IS
INCORRECT
A
ORDER
THE
FILES
FROM
SHORTEST
TO
LONGEST
ON
THE
TAPE
THAT
IS
IMPLIES
THAT
I
J
B
ORDER
THE
FILES
FROM
MOST
LIKELY
TO
BE
ACCESSED
TO
LEAST
LIKELY
TO
BE
ACCESSED
THAT
IS
PI
PJ
IMPLIES
THAT
I
J
C
ORDER
THE
THE
FILES
FROM
SMALLEST
RATIO
OF
LENGTH
OVER
ACCESS
PROBABILITY
TO
LARGEST
RATIO
OF
LENGTH
OVER
ACCESS
PROBABILITY
THAT
IS
IMPLIES
THAT
I
J
POINTS
GIVE
AN
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
WHOSE
RUNNING
TIME
IS
POLYNOMIAL
IN
N
L
K
INPUT
POSITIVE
INTEGERS
K
AND
L
OUTPUT
A
SOLUTION
IF
ONE
EXISTS
TO
WHERE
EACH
XI
IS
AN
INTEGER
SATISFYING
NO
TITLE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
EXAMS
HTML
POINTS
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
THAT
TAKES
THREE
STRINGS
A
B
AND
C
AS
INPUT
AND
RETURNS
THE
LONGEST
SEQUENCE
THAT
IS
A
SUBSEQUENCE
OF
A
B
AND
C
POINTS
SHOW
THAT
THE
FOLLOWING
PROBLEM
IS
NPHARD
INPUT
A
GRAPH
G
LET
N
BE
THE
NUMBER
OF
VERTICES
IN
G
OUTPUT
IF
G
CONTAINS
A
SIMPLE
CYCLE
WITH
EDGES
AND
OTHERWISE
USE
THE
FACT
THE
THE
FOLLOWING
PROBLEM
IS
NPHARD
INPUT
A
GRAPH
G
OUTPUT
IF
G
CONTAINS
A
SIMPLE
CYCLE
THAT
SPANS
G
AND
OTHERWISE
NOTE
THAT
A
CYCLE
IS
SIMPLE
IF
IT
DOESN
T
VISIT
ANY
VERTEX
MORE
THAN
ONCE
A
CYCLE
SPANS
G
IF
EVERY
VERTEX
IS
INCLUDED
IN
THE
CYCLE
POINTS
SHOW
THAT
THE
VERTEX
COVER
PROBLEM
IS
SELFREDUCIBLE
THE
DECISION
PROBLEM
IS
TO
TAKE
A
GRAPH
G
AND
AN
INTEGER
K
AND
DECIDE
IF
G
HAS
A
VERTEX
COVER
OF
SIZE
K
OR
NOT
THE
OPTIMIZATION
PROBLEM
TAKES
A
GRAPH
G
AND
RETURNS
A
SMALLEST
VERTEX
COVER
IN
G
SO
YOU
MUST
SHOW
THAT
IF
THE
DECISION
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THE
OPTIMIZATION
PROBLEM
ALSO
HAS
A
POLYNOMIAL
TIME
ALGORITHM
RECALL
THAT
A
VERTEX
COVER
IS
A
COLLECTION
OF
VERTICES
WITH
THE
PROPERTY
THAT
EVERY
EDGE
IS
INCIDENT
TO
A
VERTEX
IN
POINTS
GIVE
AN
ALGORITHM
THAT
GIVEN
AN
INTEGER
N
COMPUTES
N
THAT
IS
N
FACTORIAL
IN
TIME
ON
AN
EREW
PRAM
WITH
N
PROCESSORS
MAKE
THE
UNREALISTIC
ASSUMPTION
THAT
A
WORD
OF
MEMORY
CAN
STORE
ARBITRARILY
LARGE
INTEGERS
POINTS
GIVE
AN
ALGORITHM
FOR
THE
MINIMUM
EDIT
DISTANCE
PROBLEM
THAT
RUNS
IN
POLYLOG
TIME
ON
A
CREW
PRAM
WITH
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
HERE
POLYLOG
MEANS
WHERE
N
IS
THE
INPUT
SIZE
AND
K
IS
SOME
CONSTANT
INDEPENDENT
OF
THE
INPUT
SIZE
RECALL
THAT
THE
INPUT
TO
THIS
PROBLEM
IS
A
PAIR
OF
STRINGS
AND
THE
GOAL
IS
TO
CONVERT
A
INTO
B
AS
CHEAPLY
AS
POSSIBLE
THE
RULES
ARE
AS
FOLLOWS
FOR
A
COST
OF
YOU
CAN
DELETE
ANY
LETTER
FOR
A
COST
OF
YOU
CAN
INSERT
A
LETTER
IN
ANY
POSITION
FOR
A
COST
OF
YOU
CAN
REPLACE
ANY
LETTER
BY
ANY
OTHER
LETTER
ABOUT
THIS
DOCUMENT
NEX
T
U
P
PREVIOU
NEXT
ABOUT
THIS
DOCUMENT
CS
ADVERSARIAL
LOWER
BOUND
ARGUMENTS
IN
A
SIMPLIFIED
FORM
OF
THE
GAME
MASTERMIND
THERE
IS
A
HIDDEN
SEQUENCE
H
CK
OF
K
COLORED
PEGS
THERE
ARE
C
DIFFERENT
POSSIBLE
COLORS
COLORS
CAN
BE
REPEATED
IN
THE
HIDDEN
SEQUENCE
THE
GAME
CONSISTES
OF
REPEATED
ROUNDS
TO
START
A
ROUND
THE
GUESSER
GIVES
THE
HIDER
A
SEQUECE
G
GK
OF
K
COLORS
THE
HIDER
THEN
TELLS
THE
GUESSER
HOW
MANY
OF
THE
GUESSES
WERE
CORRECT
THAT
IS
THE
NUMBER
OF
INDICES
J
SUCH
THAT
HJ
GJ
THIS
ENDS
A
ROUND
COMPUTE
A
LOWER
BOUND
AS
A
FUNCTION
OF
K
AND
C
ON
THE
NUMBER
OF
THE
NUMBER
ROUNDS
REQUIRED
BY
THE
GUESSER
TO
GUARANTEE
THAT
HE
SHE
WILL
SOLVE
THE
PUZZLE
A
TYPICAL
VALUES
OF
K
AND
C
WHAT
DO
YOU
GET
FOR
YOUR
LOWER
BOUND
IN
THIS
CASE
IN
THE
GAME
MASTERMIND
THERE
IS
A
HIDDEN
SEQUENCE
H
CK
OF
K
COLORED
PEGS
THERE
ARE
C
DIFFERENT
POSSIBLE
COLORS
COLORS
CAN
BE
REPEATED
IN
THE
HIDDEN
SEQUENCE
THE
GAME
CONSISTES
OF
REPEATED
ROUNDS
TO
START
A
ROUND
THE
GUESSER
GIVES
THE
HIDER
A
SEQUECE
G
GK
OF
K
COLORS
THE
HIDER
THEN
TELLS
THE
GUESSER
HOW
MANY
OF
THE
GUESSES
WERE
CORRECT
THAT
IS
THE
NUMBER
OF
INDICES
J
SUCH
THAT
HJ
GJ
IN
ADDITION
THE
HIDER
TELLS
THE
GUESS
HOW
MANY
COLORS
ARE
CORRECT
BUT
ARE
IN
THE
WRONG
POSITION
THINK
OF
H
AND
G
AS
BEING
MULTI
SETS
AND
THE
HIDER
TELLS
THE
GUESSER
THE
CARDINALITY
OF
THE
MULTI
SET
INTERSECTION
OF
H
AND
G
THIS
ENDS
A
ROUND
COMPUTE
A
LOWER
BOUND
AS
A
FUNCTION
OF
K
AND
C
ON
THE
NUMBER
OF
THE
NUMBER
ROUNDS
REQUIRED
BY
THE
GUESSER
TO
GUARANTEE
THAT
HE
SHE
WILL
SOLVE
THE
PUZZLE
A
TYPICAL
VALUES
OF
K
AND
C
WHAT
DO
YOU
GET
FOR
YOUR
LOWER
BOUND
IN
THIS
CASE
PROVE
THAT
COMPUTING
THE
OR
OF
N
BITS
REQUIRES

LOG
N
STEPS
ON
A
EREW
PRAM
INDEPENDENT
OF
THE
NUMBER
OF
PROCESSORS
USED
CONSIDER
THE
FOLLOWING
SITUATION
YOU
HAVE
TWO
WORKSTATIONS
A
AND
B
CONNECTED
BY
A
COMMUNICATION
LINE
THE
WORKSTATION
A
IS
INITIALLY
GIVEN
AN
N
BIT
INTEGER
X
THE
WORKSTATION
B
IS
INITIALLY
GIVEN
AN
N
BIT
INTEGER
Y
THE
GOAL
OF
THE
TWO
WORKSTATIONS
IS
TO
COMMUNICATE
OVER
THE
LINE
IN
SUCH
A
WAY
THAT
THEY
BOTH
KNOW
THE
NUMBER
OF
BITS
THAT
ARE
IN
X
PLUS
THE
NUMBER
OF
BITS
THAT
ARE
IN
Y
SHOW
THAT
THE
NUMBER
OF
BITS
SENT
ACROSS
THE
LINE
MUST
BE

LOG
N
CONSIDER
THE
FOLLOWING
SITUATION
YOU
HAVE
TWO
WORKSTATIONS
A
AND
B
CONNECTED
BY
A
COMMUNICATION
LINE
THE
WORKSTATION
A
IS
INITIALLY
GIVEN
AN
N
BIT
INTEGER
X
THE
WORKSTATION
B
IS
INITIALLY
GIVEN
AN
N
BIT
INTEGER
Y
THE
GOAL
OF
THE
TWO
WORKSTATIONS
IS
TO
COMMUNICATE
OVER
THE
LINE
IN
SUCH
A
WAY
THAT
THEY
BOTH
KNOW
THE
BIT
WISE
EXCLUSIVE
OR
OF
X
AND
Y
SHOW
THAT
THE
NUMBER
OF
BITS
SENT
ACROSS
THE
LINE
MUST
BE

N
YOU
GOAL
IS
TO
FIND
A
COUNTERFEIT
COIN
AMONG
A
GROUP
OF
COINS
COUNTERFEIT
COINS
ARE
LIGHTER
THAN
REAL
COINS
YOU
KNOW
THAT
EXACTLY
ONE
OF
THE
COINS
IS
COUNTERFEIT
TO
HELP
YOU
DECIDE
WHICH
COIN
IS
LEGITIMATE
YOU
HAVE
A
PAN
BALANCE
A
PAN
BALANCE
FUNCTIONS
IN
THE
FOLLOWING
MANNER
YOU
CAN
GIVE
THE
PAN
BALANCE
ANY
TWO
DISJOINT
SUBCOLLECTIONS
SAY
AND
OF
THE
COINS
LET
AND
BE
THE
CUMULATIVE
WEIGHT
OF
THE
COINS
IN
AND
RESPECTIVELY
THE
PAN
BALANCE
THEN
DETERMINES
WHETHER
OR
SHOW
HOW
TO
SOLVE
THIS
PROBLEM
IN
TWO
WEIGHINGS
ON
THE
PAN
HINT
THIS
IS
NOT
A
LOWER
BOUND
PROBLEM
IT
PURPOSE
IS
TO
BUILD
YOU
INTUTION
YOU
GOAL
IS
TO
FIND
A
COUNTERFEIT
COIN
AMONG
A
GROUP
OF
N
COINS
COUNTERFEIT
COINS
ARE
LIGHTER
THAN
REAL
COINS
YOU
KNOW
THAT
EXACTLY
ONE
OF
THE
N
COINS
IS
COUNTERFEIT
TO
HELP
YOU
DECIDE
WHICH
COIN
IS
LEGITIMATE
YOU
HAVE
A
PAN
BALANCE
A
PAN
BALANCE
FUNCTIONS
IN
THE
FOLLOWING
MANNER
YOU
CAN
GIVE
THE
PAN
BALANCE
ANY
TWO
DISJOINT
SUBCOLLECTIONS
SAY
AND
OF
THE
COINS
LET
AND
BE
THE
CUMULATIVE
WEIGHT
OF
THE
COINS
IN
AND
RESPECTIVELY
THE
PAN
BALANCE
THEN
DETERMINES
WHETHER
OR
SHOW
THAT
SOLVING
THIS
PROBLEM
REQUIRES
AT
LEAST
N
WEIGHINGS
ON
THE
PAN
BALANCE
SHOW
THAT
THERE
IS
NO
COMPARISON
BASED
SORTING
ALGORITHM
WHO
RUNNING
TIME
IS
LINEAR
FOR
AT
LEAST
HALF
OF
THE
N
INPUTS
OF
LENGTH
N
SHOW
THAT
COMPARISONS
ARE
NECESSARY
IN
THE
WORST
CASE
TO
MERGE
TWO
SORTED
LISTS
OF
LENGTH
N
IN
THE
BROADCAST
GOSSIP
PROBLEM
THERE
ARE
N
WORKSTATIONS
THERE
WORKSTATIONS
MAY
BE
INITIALLY
PRO
GRAMMED
IN
ANY
WAY
THAT
YOU
LIKE
AFTER
THEY
ARE
PROGRAMMED
AN
ARBITARY
K
OF
THEM
ARE
GIVEN
AN
INTEGER
ASSUME
TIME
IS
DIVIDED
INTO
UNIT
SLOTS
AND
THAT
A
WORKSTATION
CAN
TRANSMIT
ITS
INTEGER
IN
A
UNIT
SLOT
WORKSTATIONS
CAN
ONLY
COMMUNICATE
VIA
BROADCAST
IF
MORE
THAN
ONE
WORKSTATION
TRIES
TO
BROADCAST
IN
A
TIME
SLOT
THEN
ALL
THE
WORKSTATIONS
DETECT
INTERFERENCE
THAT
IS
THEY
DON
T
GET
THE
MESSAGE
BUT
THEY
CAN
TELL
THAT
MORE
THAN
TWO
WORKSTATIONS
ATTEMPTED
TO
BROADCAST
IF
ONLY
ONE
WORKSTATION
BROADCASTS
IN
A
TIME
SLOT
THEN
IT
SUCCEEDS
AND
ALL
WORKSTATIONS
HEAR
THE
BROADCAST
IF
ONLY
NO
WORKSTATION
BROADCASTS
IN
A
TIME
SLOT
THEN
THIS
CAN
BE
DETECTED
BY
ALL
WORKSTATIONS
HERE
ASSUME
THAT
THE
WORKSTATIONS
GOAL
IS
FOR
ALL
WORKSTATIONS
TO
SUCCESSFULLY
TRANSMIT
THEIR
MESSAGES
EXPLAIN
HOW
TO
SOLVE
THIS
PROBLEM
IN
TIME
N
HINT
THIS
IS
NOT
A
LOWER
BOUND
QUESTION
IT
IS
JUST
A
WARM
UP
QUESTION
TO
UNDERSTAND
THE
PROBLEM
CONSIDER
THE
BROADCAST
PROBLEM
WHERE
THE
GOAL
IS
FOR
AT
LEAST
ONE
WORKSTATION
TO
SUCCESSFULLY
TRANSMIT
ITS
MESSAGE
SHOW
HOW
TO
SOLVE
THIS
PROBLEM
IN
TIME
O
LOG
N
HINT
THIS
IS
NOT
A
LOWER
BOUND
QUESTION
IT
IS
JUST
A
WARM
UP
QUESTION
TO
UNDERSTAND
THE
PROBLEM
CONSIDER
THE
BROADCAST
PROBLEM
WHERE
THE
GOAL
IS
FOR
ALL
WORKSTATIONS
TO
SUCCESSFULLY
TRANSMIT
THEIR
MESSAGES
SHOW
HOW
TO
SOLVE
THIS
PROBLEM
IN
TIME
O
K
LOG
N
HINT
THIS
IS
NOT
A
LOWER
BOUND
QUESTION
IT
IS
JUST
A
WARM
UP
QUESTION
TO
UNDERSTAND
THE
PROBLEM
CONSIDER
THE
BROADCAST
PROBLEM
WHERE
THE
GOAL
IS
FOR
ALL
WORKSTATIONS
TO
SUCCESSFULLY
TRANSMIT
THEIR
MESSAGES
AND
ALL
WORKSTATIONS
KNOW
A
PRIORI
THAT
K
THAT
IS
THE
WORKSTATIONS
CAN
BE
PROGRAMMED
UNDER
THE
ASSUMPTION
THAT
K
SHOW
TO
SOLVE
THIS
PROBLEM
REQUIRES
TIME

LOG
N
CONSIDER
THE
BROADCAST
PROBLEM
WHERE
THE
GOAL
IS
FOR
ALL
WORKSTATIONS
TO
SUCCESSFULLY
TRANSMIT
THEIR
MESSAGES
SHOW
TO
SOLVE
THIE
PROBLEM
REQUIRES
TIME

K
LOG
N
HIN
T
THE
MATH
GETS
A
BIT
INVOLVED
HERE
THE
FIRST
FACT
YOU
NEED
IS
THAT
X
CAN
BE
APPROXIMATED
WELL
BY
X
X
WHERE
E
IS
THE
BASE
OF
THE
NATURAL
LOGARITHM
THE
SECOND
FACT
YOU
NEED
IS
THAT
X
Y
Y
CAN
BE
APPROXIMATED
WELL
BY
EX
WHEN
Y
IS
LARGE
CONSIDER
THE
FOLLOWING
PROBLEM
YOU
START
WITH
ONE
ZYGLIT
IN
A
PETRI
DISH
ZYGLIT
REPRODUCE
ASEXUALLY
BY
SPLITTING
INTO
TWO
ZYGLITS
THE
ORIGINAL
ZYGLIT
DISAPPEARS
IN
THIS
PROCESS
THE
GENETIC
MATERIAL
OF
THE
TWO
RESULTING
ZYGLITS
IS
SUBJECT
TO
MUTATION
AND
ARE
NOT
IDENTICAL
TO
EITHER
SIBLINGS
OR
PARENTS
YOU
ARE
GIVEN
A
PETRI
DISH
WITH
N
ZYGLITS
THAT
ARE
THE
LEAVES
OF
THE
FAMILY
TREE
YOUR
GOAL
IS
TO
REPRODUCE
THE
FAMILY
TREE
TO
HELP
YOU
YOU
CAN
PERFORM
A
DNA
CHECK
ON
ANY
THREE
ZYGLITS
SAY
ZI
ZJ
AND
ZK
THAT
WILL
DETERMINE
WHICH
PAIR
OF
ZYGLITS
AMONG
THE
THREE
POSSIBLE
PAIRS
ZI
AND
ZJ
ZI
AND
ZK
AND
ZJ
AND
ZK
HAVE
THE
LOWEST
COMMON
ANCESTOR
IN
THE
TREE
SHOW
THAT
TO
RECOMPUTE
THE
TREE
REQUIRES

N
LOG
N
DNA
CHECKS
YOU
ARE
GIVEN
A
COLLECTION
OF
N
VLSI
CHIPS
UP
TO
OF
THE
CHIPS
MAY
NOT
BE
RELIABLE
THERE
IS
JIG
THAT
ALLOWS
YOU
TO
TEST
PAIRS
OF
CHIPS
SAY
YOU
ARE
TESTING
A
PAIR
X
AND
Y
OF
CHIPS
IF
X
IS
GOOD
THEN
X
WILL
ACCURATELY
REPORT
ON
WHETHER
Y
IS
GOOD
OR
NOT
IF
X
IS
BAD
X
MAY
SAY
THAT
Y
IS
GOOD
OR
X
MAY
SAY
THAT
Y
IS
BAD
INDEPENDENT
OF
WHETHER
Y
IS
GOOD
OR
BAD
SHOW
THAT
IT
IS
NOT
POSSIBLE
TO
IDENTIFY
A
GOOD
CHIP
WITH
SURITY
UNDER
THIS
SETTING
CONSIDER
THE
ELEMENT
UNIQUENESS
PROBLEM
THE
INPUT
IS
N
REALS
XN
THE
QUESTION
IS
DOES
THERE
EXIST
AN
I
AND
J
WITH
I
J
WITH
THAT
XI
XJ
THAT
IS
ARE
THERE
TWO
NUMBERS
IN
THE
INPUT
THAT
ARE
IDENTICAL
SHOW
THAT
THE
INFORMATION
THEORETIC
LOWER
BOUND
ON
THE
WORST
CASE
TIME
COMPLEXITY
FOR
THIS
PROBLEM
IS

N
LOG
N
HINT
THINK
OF
THE
INPUT
AS
A
POINT
XN
AS
A
POINT
IN
N
DIMENSIONAL
SPACE
RN
LET
U
BE
THE
PORTION
OF
RN
WHERE
NO
PAIR
OF
COORDINATES
ARE
THE
SAME
SHOW
THAT
U
CONSISTS
OF
N
DISJOINT
REGIONS
PERHAPS
ITS
EASIEST
TO
FIRST
CONSIDER
N
THEN
N
AND
THEN
YOU
SHOULD
SEE
IT
ASSUME
THAT
THE
ALGORITHM
A
HAS
MADE
K
COMPARISONS
LET
AK
BE
THE
REGION
OF
RN
CONSISTENT
WITH
THE
ANSWERS
THAT
A
HAS
RECEIVED
TO
DATE
FOR
EXAMPLE
IF
N
ASSUME
THAT
IN
ITS
FIRST
K
COMPARISONS
A
LEARNED
THAT
AND
THEN
AK
WOULD
BE
EXACTLY
THOST
POINTS
WHERE
AND
AND
SHOW
THAT
IT
MUST
ALWAYS
BE
THE
CASE
THE
AK
IS
CONVEX
THAT
IS
IF
AND
T
ARE
POINTS
IN
AK
THEN
THE
LINE
SEGMENT
FROM
TO
T
IS
IN
AK
CONCLUDE
THAT
AT
LEAST

N
LOG
N
COMPARISONS
ARE
NEEDED
BY
ANY
ALGORITHM
FOR
ELEMENT
UNIQUENESS
LET
XN
BE
A
COLLECTION
OF
REALS
LET

BE
THE
PERMUTATION
THAT
SORTS
THIS
COLLECTION
THAT
IS
X
X
X
N
THEN
THE
MAXIMUM
GAP
IS
DEFINED
AS
THE
I
I
N
THAT
MAXIMIZES
X
I
X
I
THAT
IS
THIS
IS
THE
MAXIMUM
GAP
BETWEEN
ANY
TWO
CONSECUTIVE
NUMBERS
IN
THE
SORTED
LIST
SHOW
THAT
THE
INFORMATION
THEORETIC
LOWER
BOUND
FOR
COMPUTING
THE
MAXIMUM
GAP
IS

N
LOG
N
SHOW
HOW
TO
COMPUTE
MAXIMUM
GAP
IN
TIME
O
N
GIVEN
THAT
YOU
CAN
IN
CONSTANT
TIME
TAKE
THE
FLOOR
OF
A
REAL
NUMBER
YOU
HAVE
N
WORKSTATIONS
ON
THE
INTERNET
EACH
WORKSTATION
KNOWS
THE
INDENTIFY
OF
THE
OTHER
WORK
STATIONS
AND
KNOWS
HOW
TO
SEND
MESSAGES
TO
EACH
OF
THE
OTHER
WORKSTATIONS
YOU
KNOW
A
PRIORI
THAT
INFILITRATED
BY
SOME
HACKER
AND
MAY
FUNCTION
IN
ARBITRARILY
MALICIOUS
WAYS
THE
GOAL
OF
THE
REMAINING
OF
SOME
BIT
THE
VALUE
OF
THE
BIT
DOESN
T
MATTER
ALL
WE
NEED
IS
THAT
ALL
OF
THE
GOOD
WORKSTATIONS
AGREE
ON
THE
VALUE
NOTE
THAT
A
WORKSTATION
KNOWS
WHETHER
OR
NOT
IT
IS
GOOD
BUT
IT
HAS
NO
IDEA
WHICH
OTHER
WORKSTATIONS
ARE
GOOD
ASSUME
THAT
ALL
SENT
MESSAGE
ARE
EVENTUALLY
DELIVERED
ALTHOUGH
THEY
MAY
BE
DELAYED
ARBITRARILY
LONG
SHOW
THAT
THERE
IS
NO
ALGORITHM
THAT
WILL
ALLOW
THE
GOOD
WORKSTATIONS
TO
AGREE
ON
A
BIT
HINT
AS
THE
RATING
SUGGESTS
THIS
SHOULD
NOT
BE
ATTEMPTED
BY
THE
FAINT
OF
HEART
THIS
IS
A
VERY
HARD
PROBLEM
CS
APPROXIMIATION
ALGORITHMS
PROBLEMS
CONSIDER
THE
VERTEX
COVER
PROBLEM
THAT
IS
GIVEN
A
GRAPH
G
FIND
A
MINIMAL
CARDINALITY
COLLECTION
OF
VERTICES
WITH
THE
PROPERTY
THAT
EVERY
EDGE
IN
G
IS
INCIDENT
TO
A
VERTEX
IN
CONSIDER
THE
FOLLOWING
ALGORITHM
PICK
AN
ARBITRARY
EDGE
E
V
W
FROM
G
ADD
V
AND
W
TO
REMOVE
V
AND
W
AND
ALL
INCIDENT
EDGES
FROM
G
GO
TO
STEP
A
SHOW
THAT
THE
PERFORMANCE
RATIO
OF
THIS
ALGORITHM
IS
AT
MOST
HINT
FIRST
CONSIDER
WHY
THE
SIZE
OF
ANY
MATCHING
A
COLLECTION
OF
EDGES
SUCH
THAT
NO
PAIR
ARE
INCIDENT
ON
A
COMMON
VERTEX
IS
A
LOWER
BOUND
ON
THE
SIZE
OF
THE
VERTEX
COVER
GIVE
AN
EXAMPLE
INSTANCE
OF
THE
VERTEX
COVER
PROBLEM
WHERE
THE
ABOVE
ALGORITHM
DOES
NOT
GIVE
AN
OPTIMAL
SOLUTION
IN
THIS
PROBLEM
YOU
HAVE
N
BOXES
BN
THAT
YOU
WISH
TO
LOAD
ONTO
K
TRUCKS
YOU
KNOW
THE
INTEGRAL
WEIGHT
IN
KILOGRAMS
WI
OF
EACH
BOX
BI
YOU
GOAL
IS
TO
MINIMIZE
THE
WEIGHT
ON
MORE
HEAVILY
LOADED
TRUCK
CONSIDER
THE
OBVIOUS
GREEDY
ALGORITHM
THAT
CONSIDERS
THE
BOXES
IN
AN
ARBITRARY
ORDER
AND
ALWAYS
PLACES
THE
BOX
UNDER
CONSIDERATION
INTO
THE
LEAST
HEAVILY
LOADED
TRUCK
SHOW
THAT
THIS
ALGORITHM
GUARANTEES
THAT
THE
WEIGHT
ON
THE
MORE
HEAVILY
LOADED
TRUCK
IS
AT
MOST
TIMES
OPTIMAL
THAT
IS
THIS
ALGORITHM
HAS
PERFORMANCE
RATIO
OF
AT
MOST
IN
THIS
PROBLEM
YOU
HAVE
N
BOXES
BN
THAT
YOU
WISH
TO
LOAD
ONTO
TWO
TRUCKS
YOU
KNOW
THE
INTEGRAL
WEIGHT
IN
KILOGRAMS
WI
OF
EACH
BOX
BI
YOU
GOAL
IS
TO
MINIMIZE
THE
WEIGHT
ON
MORE
HEAVILY
LOADED
TRUCK
CONSIDER
THE
OBVIOUS
GREEDY
ALGORITHM
THAT
CONSIDERS
THE
BOXES
IN
AN
ARBITRARY
ORDER
AND
ALWAYS
PLACES
THE
BOX
UNDER
CONSIDERATION
INTO
THE
LEAST
HEAVILY
LOADED
TRUCK
SHOW
THAT
THIS
ALGORITHMS
GUARANTEES
THAT
THE
WEIGHT
ON
THE
MORE
HEAVILY
LOADED
TRUCK
IS
AT
MOST
TIMES
OPTIMAL
THAT
IS
THIS
ALGORITHM
HAS
PERFORMANCE
RATIO
GIVE
AN
EXAMPLE
OF
AN
INSTANCE
TO
THE
ABOVE
PROBLEM
WHERE
THE
LOAD
ON
THE
MORE
HEAVILY
LOADED
TRUCK
IS
FIFTY
PERCENT
LARGER
THAN
THE
LOAD
ON
THE
MORE
HEAVILY
LOADED
TRUCK
IN
THE
OPTIMAL
SOLUTION
IN
THIS
PROBLEM
YOU
HAVE
N
BOXES
BN
THAT
YOU
WISH
TO
LOAD
ONTO
TWO
TRUCKS
YOU
KNOW
THE
INTEGRAL
WEIGHT
IN
KILOGRAMS
WI
OF
EACH
BOX
BI
YOU
GOAL
IS
TO
MINIMIZE
THE
WEIGHT
ON
MORE
HEAVILY
LOADED
TRUCK
CONSIDER
GENERALIZATIONS
OF
THE
OBVIOUS
GREEDY
ALGORITHM
THAT
CONSIDERS
THE
BOXES
IN
AN
ARBITRARY
ORDER
AND
ALWAYS
PLACES
THE
BOX
UNDER
CONSIDERATION
INTO
ONE
OF
THE
TRUCKS
BASED
ON
SOME
RULE
THAT
RELIES
ONLY
ON
THE
LOAD
OF
THE
TWO
TRUCKS
AT
THAT
TIME
SHOW
NO
SUCH
ALGORITHM
CAN
HAVE
PERFORMANCE
RATIO
STRICTLY
BETTER
THAN
IN
THIS
PROBLEM
YOU
HAVE
N
CHICKENS
WITH
WEIGHTS
BN
GRAMS
THAT
YOU
WISH
TO
PACK
INTO
PACKAGES
EACH
PACKAGE
MUST
CONTAIN
AT
LEAST
L
GRAMS
OF
CHICKEN
SO
YOU
DON
T
GET
SUED
FOR
FALSE
ADVERTISING
THE
GOAL
IS
TO
DO
THIS
BY
MAXIMIZIE
THE
NUMBER
OF
PACKAGES
THAT
YOU
FILL
TO
L
OR
MORE
GRAMS
CONSIDER
THE
OBVIOUS
GREEDY
ALGORITHM
THAT
CONSIDERS
THE
CHICKENS
IN
AN
ARBITRARY
ORDER
AND
ADDS
THE
CHICKENS
TO
THE
SAME
PACKAGE
UNTIL
THAT
PACKAGE
IS
FULL
SHOW
THAT
THE
PERFORMANCE
RATIO
OF
THIS
ALGORITHM
IS
THAT
IS
THAT
THIS
ALGORITHM
FILLS
AT
LEAST
AS
MANY
BAGS
AS
OPTIMAL
BASIC
DEFINITIONS
A
OPTIMIZATION
PROBLEM
HAS
THE
FOLLOWING
FORM
OUTPUT
A
BEST
SOLUTION
SATISFYING
SOME
PROPERTY
P
BEST
USUALLY
MEANS
LEAST
COST
A
MINIMIZATION
PROBLEM
OR
MOST
BENEFIT
A
MAXIMIZATION
PROBLEM
A
BEST
SOLUTION
IS
CALLED
AN
OPTIMAL
SOLUTION
NOTE
THAT
FOR
MANY
PROBLEMS
THERE
MAY
BE
MANY
DIF
FERENT
OPTIMAL
SOLUTIONS
A
FEASIBLE
SOLUTION
IS
A
SOLUTION
THAT
SATISFIES
THE
PROPERTY
P
MOST
OF
THE
PROBLEMS
THAT
WE
CONSIDER
CAN
BE
VIEWED
AS
OPTI
MIZATION
PROBLEMS
AN
ALGORITHM
A
FOR
A
MINIMIZATION
PROBLEM
P
HAS
PERFORMANCE
RATIO
C
IF
FOR
EVERY
INPUT
I
THE
COST
OF
THE
OUTPUT
OF
A
ON
INPUT
I
HAS
COST
AT
MOST
C
TIME
THE
COST
OF
THE
LEAST
COST
FEASIBLE
SOLUTION
TO
I
AN
ALGORITHM
A
FOR
A
MAXIMIZATION
PROBLEM
P
HAS
PERFORMANCE
RATIO
C
IF
FOR
EVERY
INPUT
I
THE
BENEFIT
OF
MOST
BENEFICIAL
FEASIBLE
SOLUTION
TO
I
IS
AT
MOST
C
TIMES
THE
BENEFIT
OF
THE
OUTPUT
OF
A
ON
INPUT
I
MST
DOUBLING
ALGORITHM
FOR
TSP
WITH
TRI
ANGLE
INEQUALITY
SEE
SECTION
CHRISTOFIDES
ALGORITHM
FOR
TSP
WITH
TRIAN
GLE
INEQUALITY
SEE
SECTION
WITHOUT
TRIANGLE
INEQUALITY
THERE
IS
NO
AL
GORITHM
WITH
CONSTANT
PERFORMANCE
RATIO
THEOREM
FOR
ALL
C
IF
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
FOR
TSP
WITH
A
CONSTANT
PERFORMANCE
RATIO
C
THEN
EVERY
NP
COMPLETE
PROBLEM
HAS
A
POLYNO
MIAL
TIME
ALGORITHM
PROOF
WE
USE
A
MANY
TO
ONE
REDUCTION
FROM
THE
HAMILTONIAN
CYCLE
PROBLEM
I
E
THE
PROBLEM
OF
DECIDING
WHETHER
A
GRAPH
CONTAINS
A
SIMPLE
SPANNING
CYCLE
LET
H
A
WEIGHTED
COMPLETE
GRAPH
CONSTRUCTED
FROM
AN
UNWEIGHTED
GRAPH
G
WITH
N
VERTICES
IN
THE
FOLLORING
MANNER
EACH
EDGE
IN
G
IS
GIVEN
WEIGHT
AND
A
EDGE
X
Y
WITH
WEIGHT
CN
IS
ADDED
BETWEEN
EACH
PAIR
OF
NONADJACENT
VERTICES
IN
G
NOTE
THAT
IF
G
HAS
A
HAMILTONIAN
CYCLE
THEN
H
HAS
A
TOUR
OF
WEIGHT
N
AND
IF
G
DOES
NOT
HAVE
A
HAMILTONIAN
CYCLE
THEN
EVERY
TOUR
IN
H
HAS
WEIGHT
GREATER
THAN
CN
HENCE
IF
THE
APPROXIMIATION
ALGORITHM
FOR
TSP
FINDS
A
TOUR
WITH
LENGTH
AT
MOST
CN
THEN
WE
MAY
BE
SURE
THE
G
HAS
A
HAMILTONIAN
CYCLE
AND
IF
THE
APPROXIMIATION
ALGORITHM
FOR
TSP
FINDS
A
TOUR
WITH
LENGTH
MORE
THAN
CN
THEN
WE
MAY
BE
SURE
THE
G
DOES
NOT
HAVE
A
HAMILTONIAN
CYCLE
ANALYSIS
OF
FIRST
FIT
FOR
BIN
PACKING
ANALYSIS
OF
FIRST
FIT
DECREASING
FOR
BIN
PACKING
SEE
SECTION
DYNAMIC
PROGRAMMING
TAKE
WE
EXAMINE
PROBLEMS
THAT
CAN
BE
SOLVED
BY
DYNAMIC
PROGRAMMING
PERHAPS
THE
SINGLE
MOST
USEFUL
ALGORITHMIC
DESIGN
TECHNIQUE
DYNAMIC
PROGRAMMING
CAN
BE
EXPLAINED
MANY
WAYS
RATHER
THAN
EXPLAIN
WHAT
A
DYNAMIC
PROGRAM
MING
ALGORITHM
IS
WE
EXPLAIN
HOW
ONE
MIGHT
DEVELOP
ONE
FIND
A
RECURSIVE
ALGORITHM
FOR
THE
PROBLEM
IT
OFTEN
HELPS
TO
FIRST
FIND
A
RECURSIVE
ALGORITHM
TO
COUNT
THE
NUMBER
OF
FEASIBLE
SOLUTIONS
SPOT
REDUNDANCY
IN
THE
CALCULATION
ELIMINATE
THE
REDUNDANCY
THIS
CAN
OFTEN
BE
BEST
ACCOMPLISHED
BY
PER
FORMING
THE
CALCULATIONS
BOTTOM
UP
INSTEAD
OF
TOP
DOWN
FIBONACCI
NUMBERS
AND
BINOMIAL
COEFFI
CIENTS
SEE
SECTION
AND
SECTION
FROM
THE
TEXT
LONGEST
COMMON
SUBSEQUENCE
PROBLEM
THE
INPUT
TO
THIS
PROBLEM
IS
TWO
SEQUENCES
A
AM
AND
B
BN
THE
PROBLEM
IS
TO
FIND
THE
LONGEST
SEQUENCE
THAT
IS
A
SUBSEQUENCE
OF
BOTH
A
AND
B
FOR
EXAMPLE
IF
A
CCDEDCDEC
AND
B
CDEDCDEC
THEN
CDDEC
IS
SUBSEQUENCE
OF
LENGTH
OF
BOTH
SEQUENCES
LET
T
I
J
BE
THE
LENGTH
OF
THE
LONGEST
COMMON
SUBSEQUENCE
OF
AI
AND
BJ
THEN
ONE
CAN
SEE
THAT
IF
AI
BJ
THEN
T
I
J
T
I
J
OTHERWISE
ONE
CAN
SEE
THAT
T
I
J
MAX
T
I
J
T
I
J
NOTE
THAT
THERE
ARE
ONLY
NM
POSSIBLE
SUBPROBLEMS
SINCE
THERE
ARE
ONLY
M
CHOICES
FOR
I
AND
N
CHOICES
FOR
J
HENCE
BY
TREATING
THE
T
I
J
AS
ARRAY
ENTRIES
INSTEAD
OF
RECURSIVE
CALLS
AND
UPDATING
THE
TABLE
IN
THE
APPROPRIATE
WAY
WE
CAN
GET
THE
FOLLOWING
O
TIME
ALGORITHM
FOR
I
TO
M
DO
T
I
FOR
J
TO
N
DO
T
J
FOR
I
TO
M
DO
FOR
J
TO
N
DO
IF
A
I
B
J
THEN
T
I
J
T
I
J
ELSE
T
I
J
MAX
T
I
J
T
I
J
COMPUTING
NUMBER
OF
BINARY
SEARCH
TREES
AND
OPTIMAL
BINARY
SEARCH
TREES
SECTION
FROM
THE
TEXT
CHAINED
MATRIX
MULTIPLICATION
SECTION
FROM
THE
TEXT
MAXIMUM
WEIGHT
INDEPENDENT
SET
IN
A
TREE
THE
INPUT
TO
THIS
PROBLEM
IS
A
TREE
T
WITH
WEIGHTS
ON
THE
VERTICES
THE
GOAL
IS
TO
FIND
THE
INDEPENDENT
SET
IN
T
WITH
MAXIMUM
AGGREGATE
WEIGHT
AN
INDEPENDENT
SET
IS
A
COLLECTION
OF
MUTUALLY
NONADJACENT
VERTICES
ROOT
THE
TREE
AT
AN
ARBITRARY
NODE
R
AND
PROCESS
THE
TREE
IN
POSTORDER
WE
GENERALIZE
THE
INDUCTION
HYPOTHESIS
CONSIDER
AN
ARBITRARY
NODE
V
WITH
BRANCHES
TO
K
DESCENDANTS
WK
WE
CAN
CREATE
AN
INDEPENDENT
SET
FOR
THE
SUBTREE
ROOTED
AT
V
IN
ESSENTIALLY
TWO
WAYS
DEPENDING
ON
WHETHER
OR
NOT
WE
INCLUDE
V
IN
THE
INDEPENDENT
SET
IF
WE
DECIDE
NOT
TO
INCLUDE
V
CONSIDER
AN
ARBITRARY
ROOT
V
WITH
BRANCHES
TO
K
DESCENDANTS
WK
WE
CAN
CREATE
AN
INDEPENDENT
SET
FOR
THE
SUBTREE
ROOTED
AT
V
IN
ESSENTIALLY
TWO
WAYS
DEPENDING
ON
WHETHER
OR
NOT
WE
INCLUDE
V
IN
THE
INDEPENDENT
SET
IF
WE
DECIDE
NOT
TO
INCLUDE
V
WE
CAN
COMBINE
ANY
INDEPENDENT
SETS
FOR
THE
SUBTREES
ROOTED
AT
WK
TO
CREATE
AN
INDEPENDENT
SET
FOR
THE
SUBTREE
ROOTED
AT
V
SINCE
THERE
ARE
NO
EDGES
BETWEEN
THE
SUBTREES
ON
THE
OTHER
HAND
IF
WE
DO
INCLUDE
V
IN
THE
INDEPENDENT
SET
WE
CAN
ONLY
USE
INDEPENDENT
SETS
FOR
THE
SUBTREES
THAT
DO
NOT
INCLUDE
THEIR
RESPECTIVE
ROOT
WK
OTHERWISE
WE
WOULD
HAVE
BOTH
V
AND
SOME
WJ
IN
THE
SET
AND
IT
WOULD
NOT
BE
AN
INDEPENDENT
SET
ANYMORE
THEREFORE
FOR
EACH
NODE
V
THE
ALGORITHM
COMPUTES
THE
FOLLOWING
INFORMATION
BIG
V
THE
MAXIMUM
WEIGHT
OF
AN
INDEPENDENT
SET
FOR
THE
SUBTREE
ROOTED
AT
V
AND
BIGNOTROOT
V
THE
MAXIMUM
WEIGHT
OF
AN
INDEPENDENT
SET
FOR
THE
SUBTREE
ROOTED
AT
V
THAT
DOES
NOT
INCLUDE
V
AT
NODE
V
THE
ALGORITHM
FIRST
RECURSIVELY
COMPUTES
BIG
WI
AND
BIGNOTROOT
WI
FOR
EACH
DESCENDANT
SUBTREE
WK
IT
THEN
COMPUTES
BIGNOTROOT
V
AND
BIG
V
USING
THE
FOLLOWING
RECURRENCE
RELATIONS
THAT
CORRESPOND
TO
THE
TWO
CASES
IDENTIFIED
ABOVE
K
BIGNOTROOT
V
BIG
WI
I
K
BIG
V
MAX
BIGNOTROOT
V
WEIGHT
V
BIGNOTROOT
WI
I
IF
V
IS
A
LEAF
THEN
BIGNOTROOT
V
AND
BIG
V
WEIGHT
V
LONGEST
INCREASING
SUBSEQUENCE
THE
LONGEST
INCREASING
SUBSEQUENCE
LIS
PROBLEM
IS
DEFINED
AS
FOLLOWS
INPUT
A
SEQUENCE
X
XN
OF
INTEGERS
OUTPUT
THE
LONGEST
INCREASING
SUBSEQUENCE
OF
X
A
SEQUENCE
IS
INCREASING
IF
EACH
NUMBER
IN
THE
SEQUENCE
IS
LARGER
THAN
THE
PREVIOUS
NUMBER
LET
US
TRY
TO
DEVELOP
A
RECURSIVE
ALGORITHM
FOR
THIS
PROBLEM
LET
LIS
K
BE
THE
LONGEST
INCREASING
SUBSEQUENCE
OF
THE
FIRST
K
INTEGERS
IN
X
CONSIDER
THE
FOLLOWING
FIRST
STAB
AT
AN
INDUCTION
HYPOTHESIS
INDUCTION
HYPOTHESIS
WE
KNOW
HOW
TO
COMPUTE
LIS
K
ASSUME
THAT
WE
HAVE
COMPUTED
LIS
K
AND
WE
NOW
WANT
TO
COMPUTE
LIS
K
THE
FOLLOWING
SEQUENCE
SHOWS
THAT
WE
CAN
T
JUST
KNOW
ANY
LONGEST
SEQUENCE
BEFORE
WE
CONSIDER
WE
NEED
TO
KNOW
THE
LIS
NOT
THE
LIS
THE
OBVIOUS
SOLUTION
IS
TO
REMEMBER
THE
LIS
THAT
ENDS
IN
THE
SMALLEST
NUMBER
HENCE
WE
CHANGE
THE
DEFINITION
OF
LIS
AS
FOLLOWS
LET
LIS
K
BE
THE
THE
LONGEST
INCREASING
SUBSEQUENCE
OF
THE
FIRST
K
INTEGERS
IN
X
THAT
ENDS
IN
THE
SMALLEST
NUMBER
INDUCTION
HYPOTHESIS
WE
KNOW
HOW
TO
COMPUTE
LIS
K
THE
FOLLOWING
SEQUENCE
SHOWS
THAT
KNOWING
THE
LIS
THAT
ENDS
IN
THE
SMALLEST
NUMBER
IS
NOT
SUFFICIENT
INFORMATION
NOTICE
THAT
IN
THIS
EXAMPLE
THE
LENGTH
OF
THE
LIS
DOESN
T
CHANGE
BUT
A
NEW
ONE
IS
FORMED
WITH
A
SMALLER
LAST
NUMBER
THE
MOST
OBVIOUS
WAY
TO
FIX
THIS
PROBLEM
IS
TO
REMEMBER
THE
BEST
THE
ONE
THAT
ENDS
IN
THE
SMALLEST
NUMBER
SEQUENCE
OF
LENGTH
ONE
LESS
THAN
THE
LIS
LET
K
BE
THE
THE
INCREASING
SUBSEQUENCE
OF
THE
FIRST
K
INTEGERS
IN
X
THAT
HAS
LENGTH
ONE
LESS
THAN
THE
LENGTH
OF
LIS
K
AND
THAT
ENDS
IN
THE
SMALLEST
NUMBER
INDUCTION
HYPOTHESIS
WE
KNOW
HOW
TO
COMPUTE
LIS
K
AND
K
THE
FOLLOWING
SEQUENCE
SHOWS
THAT
THERE
IS
NOT
SUFFICIENT
INDUCTIVE
INFORMATION
TO
COMPUTE
K
WE
NEED
TO
KNOW
THE
SEQUENCE
OF
THE
FIRST
K
INTEGERS
IN
X
OF
LENGTH
TWO
SHORTER
THAN
LIS
K
THAT
ENDS
IN
THE
SMALLEST
NUMBER
ONE
CAN
SEE
THAT
EVENTUALLY
WE
HAVE
TO
INDUCTIVELY
KNOW
THE
SEQUENCE
OF
EACH
LENGTH
THAT
ENDS
IN
THE
SMALLEST
NUMBER
HENCE
WE
DEFINE
LIS
K
AS
THE
THE
SMALLEST
LAST
NUMBER
OF
ANY
SUBSEQUENCE
OF
LENGTH
FROM
AMONG
THE
FIRST
K
NUMBERS
OF
X
THIS
THEN
LEADS
US
TO
THE
FOLLOWING
ALGORITHM
FOR
K
TO
N
DO
FOR
TO
N
DO
LIS
K
PLUS
INFINITY
FOR
K
TO
N
DO
LIS
K
MINUS
INFINITY
FOR
K
TO
N
DO
FOR
TO
N
DO
IF
LIS
K
X
K
LIS
K
THEN
LIS
K
X
K
ELSE
LIS
K
LIS
K
THIS
IS
AN
EXAMPLE
OF
WHERE
WHEN
TRYING
TO
COMPUTE
SOMETHING
RECURSIVELY
INDUCTIVE
IT
IS
SOMETIMES
EASIER
TO
COMPUTE
MORE
INFORMATION
THAN
YOU
NEED
THIS
IS
SOMETIMES
CALLED
STRENGTHENING
THE
INDUCTIVE
HYPOTHESIS
THIS
IS
NOT
PARA
DOXICAL
BECAUSE
THE
STRENGTHENING
OF
THE
INDUCTIVE
HYPOTHESIS
ALSO
GIVES
YOU
MORE
INFORMATION
TO
WORK
WITH
WHEN
THE
RECURSION
RETURNS
FROM
THE
SMALLER
SUBPROBLEM
THE
MOST
COMMON
MISTAKE
MADE
HERE
IS
TO
USE
THE
ADDITIONAL
INFORMATION
RETURNED
FROM
THE
RECURSION
TO
SOLVE
THE
ORIGINAL
PROBLEM
NOT
THE
MORE
GENERALIZED
PROBLEM
ONE
POINT
THAT
I
WANT
YOU
TO
DRAW
FROM
THIS
EXAMPLE
IS
THAT
ITS
NOT
ALWAYS
EASY
TO
DETERMINE
HOW
ONE
SHOULD
STRENGTHEN
THE
INDUCTIVE
HYPOTHESIS
DYNAMIC
PROGRAMMING
TAKE
IN
THIS
SECTION
WE
DISCUSS
ANOTHER
METHOD
FOR
DEVELOPING
DYNAMIC
PROGRAM
MING
ALGORITHMS
THAT
AVOIDS
HAVING
TO
DEVELOP
A
RECURSIVE
ALGORITHM
WHICH
IS
ALMOST
ALWAYS
THE
MOST
DIFFICULT
PART
IN
THE
PREVIOUSLY
OUTLINED
METHOD
THIS
METHOD
IS
PARTICULARLY
APPLICABLE
WHEN
THE
FEASIBLE
SOLUTIONS
ARE
SUBSETS
OR
SUBSEQUENCES
THE
STEPS
TO
DEVELOPING
A
DYNAMIC
PROGRAMMING
ALGORITHM
USING
THIS
METHOD
ARE
AS
FOLLOWS
DETERMINE
HOW
TO
GENERATE
ALL
POSSIBLE
FEASIBLE
SOLUTIONS
ONCE
AGAIN
IT
MIGHT
BE
EASIER
TO
FIRST
DETERMINE
HOW
TO
COUNT
THE
NUMBER
OF
FEASIBLE
SOLUTIONS
ENUMERATION
USUALLY
FOLLOWS
EASILY
FROM
COUNTING
DEVELOP
A
PRUNING
RULE
TO
ELIMINATE
PARTIAL
FEASIBLE
SOLUTIONS
THAT
EITHER
ARE
REDUNDANT
OR
THAT
CAN
NOT
BE
EXTENDED
TO
AN
OPTIMAL
SOLUTION
TRANSFORM
THE
ALGORITHM
TO
AN
ITERATIVE
TABLE
BASED
ALGORITHM
SUBSET
SUM
EXAMPLE
THE
SUBSET
SUM
PROBLEM
IS
DEFINED
AS
FOLLOWS
INPUT
A
COLLECTION
XN
OF
POSITIVE
INTEGERS
AND
A
POSITIVE
INTEGER
L
OUTPUT
A
SUBSET
OF
THE
XI
THAT
SUM
TO
L
OR
A
STATEMENT
THAT
NO
SUCH
SUBSET
EXISTS
WE
CAN
GENERATE
THE
SUBSETS
INDUCTIVELY
USING
A
BINARY
TREE
AS
FOLLOWS
THE
NODES
OF
DEPTH
I
ARE
ALL
SUBSETS
OF
XI
THE
CHILDREN
OF
A
NODE
AT
DEPTH
I
ARE
AND
XI
THUS
ALL
THE
SUBSETS
CAN
BE
FOUND
AT
THE
LEAVES
THE
DEPTH
OF
THIS
TREE
IS
N
THE
TWO
PRUNING
RULES
ARE
ELIMINATE
THE
SUBTREE
ROOTED
AT
ANY
SUBSET
WITH
SUM
GREATER
THAN
L
IF
THERE
ARE
TWO
SUBSETS
AND
T
AT
THE
SAME
DEPTH
WITH
THE
SAME
AGGRE
GATE
SUM
THEN
ONE
CAN
ARBITRARY
SELECT
ONE
OF
THE
TWO
NODES
AND
ELIMINATE
THE
SUBTREE
ROOTED
AT
THAT
NODE
NOTE
THAT
THESE
TWO
PRUNING
RULES
MEAN
THAT
THERE
ARE
AT
MOST
L
NODES
LEFT
UNPRUNED
AT
ANY
LEVEL
HENCE
THIS
GIVES
US
AN
ALGORITHM
WITH
RUNNING
TIME
IS
POLYNOMIAL
IN
N
AND
L
WE
NOW
WISH
TO
DERIVE
AN
ITERATIVE
ALGORITHM
LET
SUM
K
BE
TRUE
IF
THERE
IS
A
SUBSET
OF
THE
FIRST
K
NUMBERS
THAT
SUMS
TO
WE
COMPUTE
SUM
K
AS
FOLLOWS
SUM
TRUE
FOR
TO
L
DO
SUM
FALSE
FOR
K
TO
N
DO
FOR
TO
L
DO
SUM
K
SUM
K
OR
SUM
K
X
K
KNAPSACK
EXAMPLE
THE
KNAPSACK
PROBLEM
CAN
BE
DEFINED
AS
FOLLOWS
INPUT
A
COLLECTION
OF
OBJECTS
ON
WITH
POSITIVE
INTEGER
WEIGHTS
WN
AND
POSITIVE
INTEGER
VALUES
VN
A
POSITIVE
INTEGER
L
OUTPUT
THE
HIGHEST
VALUED
SUBSET
OF
THE
OBJECTS
WITH
WEIGHT
AT
MOST
L
WE
CAN
GENERATE
THE
SUBSETS
INDUCTIVELY
USING
A
BINARY
TREE
AS
IN
THE
SUBSET
SUM
PROBLEM
THE
TWO
PRUNING
RULES
ARE
ELIMINATE
THE
SUBTREE
ROOTED
AT
ANY
SUBSET
WITH
SUM
GREATER
THAN
L
IF
THERE
ARE
TWO
SUBSETS
AND
T
AT
THE
SAME
DEPTH
WITH
THE
SAME
TOTAL
WEIGHT
THEN
ELIMINATE
THE
ONE
OF
LEAST
VALUE
NOTE
THAT
THESE
TWO
PRUNING
RULES
MEAN
THAT
THERE
ARE
AT
MOST
L
NODES
LEFT
UNPRUNED
AT
ANY
LEVEL
LET
V
ALUE
K
BE
HIGHEST
VALUE
ONE
CAN
OBTAIN
FROM
A
SUBSET
OF
THE
FIRST
K
NUMBERS
WITH
AGGREGATE
WEIGHT
WE
COMPUTE
V
ALUE
K
AS
FOLLOWS
VALUE
FOR
TO
L
DO
SUM
MINUS
INFINITY
FOR
K
TO
N
DO
FOR
TO
L
DO
VALUE
K
MAX
VALUE
K
VALUE
K
W
K
V
K
LONGEST
INCREASING
SUBSEQUENCE
PROBLEM
TAKE
WE
NOW
APPLY
THIS
METHOD
TO
THE
LONGEST
INCREASING
SUBSEQUENCE
PROBLEM
WE
CAN
GENERATE
FEASIBLE
SOLUTIONS
SUBSEQUENCES
AS
IN
THE
SUBSET
SUM
PROB
LEM
ONE
OBVIOUS
THE
PRUNING
RULE
IS
IF
YOU
HAVE
TWO
SUBSEQUENCES
AND
T
AT
THE
SAME
DEPTH
THAT
HAVE
THE
SAME
LENGTH
PRUNE
THE
ONE
THAT
ENDS
IN
THE
LARGER
NUMBER
THIS
PRUNING
RULE
WILL
GIVE
YOU
AT
MOST
N
UNPRUNED
NODES
AT
ANY
LEVEL
IF
YOU
TURN
THIS
INTO
AN
ITERATIVE
CODE
YOU
WILL
GET
THE
SAME
CODE
AS
WE
GOT
BEFORE
ANOTHER
POSSIBLE
PRUNING
RULE
WOULD
BE
IF
TWO
SEQUENCES
AND
T
AT
THE
SAME
DEPTH
HAVE
THE
SAME
LAST
NUMBER
PRUNE
THE
SHORTER
SEQUENCE
THIS
PRUNING
RULE
WILL
ALSO
GIVE
YOU
AT
MOST
N
UNPRUNED
NODES
AT
ANY
DEPTH
AND
AN
TIME
ALGORITHM
NOTE
HOW
MUCH
EASIER
IT
WAS
TO
DEVELOP
AN
ALGORITHM
FOR
THE
LIS
PROBLEM
THIS
WAY
AS
OPPOSED
TO
TRYING
RECURSION
AND
GENERALIZING
THE
INDUCTION
HYPOTHESIS
THE
SINGLE
SOURCE
SHORTEST
PATH
PROBLEM
THE
INPUT
TO
THIS
PROBLEM
IS
A
DIRECTED
POSITIVE
EDGE
WEIGHTED
GRAPH
WITH
A
DESIGNATED
VERTEX
THE
PROBLEM
IS
TO
FIND
THE
SHORTEST
SIMPLE
PATH
FROM
TO
EACH
OTHER
VERTEX
FOR
MORE
INFORMATION
SEE
SECTION
OF
THE
TEXT
HERE
FEASIBLE
SOLUTIONS
ARE
SIMPLE
PATHS
THAT
START
FROM
THE
SOURCE
VERTEX
THE
NODES
IN
LEVEL
K
OF
THE
TREE
REPRESENT
ALL
PATHS
FROM
OF
K
OR
LESS
HOPS
NOTE
THAT
BY
SIMPLICITY
WE
WE
NEED
ONLY
CONSIDER
THE
TREE
TO
DEPTH
N
THE
NUMBER
OF
VERTICES
THE
PRUNING
RULE
IS
THAT
WE
NEED
ONLY
REMEMBER
THE
SHORTEST
PATH
TO
A
PARTICULAR
VERTEX
WE
THUS
GET
THE
FOLLOWING
CODE
HERE
D
K
I
IS
THE
SHORTEST
PATH
FROM
TO
I
OF
K
OR
LESS
HOPS
FOR
K
TO
N
DO
FOR
I
TO
N
DO
D
K
I
MIN
D
K
I
D
K
I
FOR
EACH
EDGE
E
I
J
DO
D
K
J
MIN
D
K
J
D
K
I
THE
LENGTH
OF
E
THIS
IS
BELLMAN
FORD
SHORTEST
PATH
ALGORITHM
AND
HAS
RUNNING
TIME
O
V
E
THE
SHORTEST
PATH
PROBLEM
WITH
NEGATIVE
EDGE
WEIGHTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
DIRECTED
EDGE
WEIGHTED
GRAPH
WITH
A
DESIGNATED
VERTEX
THE
EDGE
WEIGHTS
MAY
BE
POSITIVE
OR
NEGATIVE
THE
PROBLEM
IS
TO
FIND
THE
SHORTEST
SIMPLE
PATH
FROM
TO
EACH
OTHER
VERTEX
FOR
MORE
INFORMATION
SEE
SECTION
OF
THE
TEXT
HERE
FEASIBLE
SOLUTIONS
ARE
SIMPLE
PATHS
THAT
START
FROM
THE
SOURCE
VERTEX
THE
NODES
IN
LEVEL
K
OF
THE
TREE
REPRESENT
ALL
PATHS
FROM
OF
K
OR
LESS
HOPS
NOTE
THAT
BY
SIMPLICITY
WE
WE
NEED
ONLY
CONSIDER
THE
TREE
TO
DEPTH
N
THE
NUMBER
OF
VERTICES
THE
PRUNING
RULE
IS
THAT
IF
TWO
PATHS
END
AT
THE
SAME
VERTEX
AND
CONTAIN
THE
SAME
VERTICES
THEN
WE
MAY
PRUNE
THE
SHORTER
ONE
MAKE
SURE
YOU
UNDERSTAND
WHY
THE
PRUNING
RULE
THAT
WE
USED
FOR
POSITIVE
WEIGHTS
DOES
NOT
WORK
HERE
WE
THUS
GET
THE
FOLLOWING
CODE
HERE
D
K
I
IS
THE
SHORTEST
PATH
FROM
TO
I
OF
K
OR
LESS
HOPS
THAT
VISITS
EXACTLY
THE
VERTICES
IN
FOR
K
TO
N
DO
FOR
I
TO
N
DO
FOR
TO
N
DO
D
K
I
MIN
D
K
I
D
K
I
FOR
EACH
EDGE
E
I
J
DO
IF
J
IS
NOT
IN
THEN
D
K
J
J
MIN
D
K
J
J
D
K
I
THE
LENGTH
OF
E
THE
RUNNING
TIME
OF
THIS
CODE
IS
O
V
WHERE
V
IS
THE
NUMBER
OF
VERTICES
AND
E
IS
THE
NUMBER
OF
EDGES
THE
TRAVELING
SALESMAN
PROBLEM
SEE
SECTION
FROM
THE
TEXT
THE
INPUT
TO
THIS
PROBLEM
IS
A
DIRECTED
EDGE
WEIGHTED
GRAPH
WITH
A
DESIGNATED
VERTEX
THE
EDGE
WEIGHTS
MAY
BE
POSITIVE
OR
NEGATIVE
THE
PROBLEM
IS
TO
FIND
THE
SHORTEST
SIMPLE
PATH
FROM
THAT
VISITS
ALL
OF
THE
VERTICES
HERE
FEASIBLE
SOLUTIONS
ARE
SIMPLE
PATHS
THAT
START
FROM
THE
SOURCE
VERTEX
THE
NODES
IN
LEVEL
K
OF
THE
TREE
REPRESENT
ALL
PATHS
FROM
OF
EXACTLY
K
NOTE
THAT
BY
SIMPLICITY
WE
WE
NEED
ONLY
CONSIDER
THE
TREE
TO
DEPTH
N
THE
NUMBER
OF
VERTICES
THE
PRUNING
RULE
IS
THAT
IF
TWO
PATHS
END
AT
THE
SAME
VERTEX
AND
CONTAIN
THE
SAME
VERTICES
THEN
WE
MAY
PRUNE
THE
SHORTER
ONE
WE
THUS
GET
THE
FOLLOWING
CODE
HERE
D
K
I
IS
THE
SHORTEST
PATH
FROM
TO
I
OF
K
OR
LESS
HOPS
THAT
VISITS
EXACTLY
THE
VERTICES
IN
FOR
K
TO
N
DO
FOR
I
TO
N
DO
FOR
TO
N
DO
FOR
EACH
EDGE
E
I
J
DO
IF
J
IS
NOT
IN
THEN
D
K
J
J
MIN
D
K
J
J
D
K
I
THE
LENGTH
OF
E
THE
RUNNING
TIME
OF
THIS
CODE
IS
O
V
WHERE
V
IS
THE
NUMBER
OF
VERTICES
AND
E
IS
THE
NUMBER
OF
EDGES
CS
DYNAMIC
PROGRAMMING
HOMEWORK
PROBLEMS
POINTS
CONSIDER
THE
RECURRENCE
RELATION
T
T
AND
FOR
N
N
T
N
T
I
T
I
I
WE
CONSIDER
THE
PROBLEM
OF
COMPUTING
T
N
FROM
N
SHOW
THAT
IF
YOU
IMPLEMENT
THIS
RECURSION
DIRECTLY
IN
SAY
THE
C
PROGRAMMING
LANGUAGE
THAT
THE
PROGRAM
WOULD
USE
EXPONENTIALLY
IN
N
MANY
ARITHMETIC
OPERATIONS
EXPLAIN
HOW
BY
NOT
RECOMPUTING
THE
SAME
T
I
VALUE
TWICE
ONE
CAN
OBTAIN
AN
ALGORITHM
FOR
THIS
PROBLEM
THAT
ONLY
USES
O
ARITHMETIC
OPERATIONS
GIVE
AN
ALGORITHM
FOR
THIS
PROBLEM
THAT
ONLY
USES
O
N
ARITHMETIC
OPERATIONS
POINTS
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
THAT
TAKES
THREE
STRINGS
A
B
AND
C
AS
INPUT
AND
RETURNS
THE
LONGEST
SEQUENCE
THAT
IS
A
SUBSEQUENCE
OF
A
B
AND
C
POINTS
GIVE
AN
EFFICIENT
ALGORITHM
FOR
FINDING
THE
SHORTEST
COMMON
SUPER
SEQUENCE
OF
TWO
STRINGS
A
AND
B
C
IS
A
SUPER
SEQUENCE
OF
A
IF
AND
ONLY
IF
A
IS
A
SUBSEQUENCE
OF
C
HINT
OBVIOUSLY
THIS
PROBLEM
IS
VERY
SIMILAR
TO
THE
PROBLEM
OF
FINDING
THE
LONGEST
COMMON
SUB
SEQUENCE
YOU
SHOULD
TRY
TO
FIRST
FIGURE
OUT
HOW
TO
COMPUTE
THE
LENGTH
OF
THE
SHORTEST
COMMON
SUPER
SEQUENCE
SHOW
THE
TABLE
THAT
YOUR
ALGORITHM
CONSTRUCTS
FOR
THE
INPUTS
A
ZXYYZZ
AND
B
ZZYXZY
EXPLAIN
HOW
TO
FIND
THE
LENGTH
OF
THE
SHORTEST
COMMON
SUPER
SEQUENCE
IN
YOUR
TABLE
EXPLAIN
HOW
TO
COMPUTE
THE
ACTUAL
SHORTEST
COMMON
SUPER
SEQUENCE
FROM
YOUR
TABLE
BY
TRACING
BACK
FROM
THE
TABLE
ENTRY
THAT
GIVES
THE
LENGTH
OF
THE
SHORTEST
COMMON
SUPER
SEQUENCE
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
PAIR
OF
STRINGS
A
AM
AND
B
BN
THE
GOAL
IS
TO
CONVERT
A
INTO
B
AS
CHEAPLY
AS
POSSIBLE
THE
RULES
ARE
AS
FOLLOWS
FOR
A
COST
OF
YOU
CAN
DELETE
ANY
LETTER
FOR
A
COST
OF
YOU
CAN
INSERT
A
LETTER
IN
ANY
POSITION
FOR
A
COST
OF
YOU
CAN
REPLACE
ANY
LETTER
BY
ANY
OTHER
LETTER
FOR
EXAMPLE
YOU
CAN
CONVERT
A
ABCABC
TO
B
ABACAB
VIA
THE
FOLLOWING
SEQUENCE
ABCABC
AT
A
COST
OF
CAN
BE
CONVERTED
TO
ABAABC
WHICH
AT
COST
OF
CAN
BE
CONVERTED
TO
ABABC
WHICH
AT
COST
OF
CAN
BE
CONVERTED
TO
ABAC
WHICH
AT
COST
OF
CAN
BE
CONVERTED
TO
ABACB
WHICH
AT
COST
OF
CAN
BE
CONVERTED
TO
ABACAB
THUS
THE
TOTAL
COST
FOR
THIS
CONVERSION
WOULD
BE
THIS
IS
ALMOST
SURELY
NOT
THE
CHEAPEST
POSSIBLE
CONVERSION
GIVE
A
POLYNOMIAL
TIME
DYNAMIC
PROGRAMMING
ALGORITHM
NOTE
THE
UNIX
DIFF
COMMAND
ESSENTIALLY
SOLVES
THIS
PROBLEM
POINTS
FIND
THE
OPTIMAL
BINARY
SEARCH
TREE
FOR
KEYS
WHERE
THE
ACCESS
PROBABILITIES
WEIGHTS
ARE
RESPECTIVELY
USING
THE
ALGORITHM
DISCUSSED
IN
CLASS
AND
IN
THE
NOTES
CONSTRUCT
ONE
TABLE
SHOWING
THE
OPTIMAL
EXPECTED
ACCESS
TIME
FOR
ALL
SUBTREES
CONSIDERED
IN
THE
ALGORITHM
AND
ANOTHER
SHOWING
THE
ROOTS
OF
THE
OPTIMAL
SUBTREES
COMPUTED
IN
THE
OTHER
TABLE
SHOW
HOW
TO
USE
THE
TABLE
OF
ROOTS
TO
RECOMPUTE
THE
TREE
POINTS
GIVE
AN
EFFICIENT
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
AN
N
SIDED
CONVEX
POLYGON
ASSUME
THAT
THE
POLYGON
IS
SPECIFIED
BY
THE
CARTESIAN
COORDINATES
OF
ITS
VERTICES
THE
OUTPUT
SHOULD
BE
THE
TRIANGULATION
OF
THE
POLYGON
INTO
N
TRIANGLES
THAT
MINIMIZES
THE
SUMS
OF
THE
PERIMETERS
OF
THE
INTO
TRIANGLES
NOTE
THAT
THIS
IS
EQUIVALENT
TO
MINIMIZING
THE
LENGTH
OF
THE
CUTS
REQUIRED
TO
CREATE
THE
TRIANGLE
HINT
THIS
IS
VERY
SIMILAR
TO
THE
MATRIX
MULTIPLICATION
PROBLEM
AND
THE
PROBLEM
OF
FINDING
THE
OPTIMAL
BINARY
SEARCH
TREE
YOU
NEED
TO
FIGURE
OUT
HOW
TO
REPRESENT
ALL
FEASIBLE
SOLUTIONS
AS
BINARY
TREES
HINT
HINT
FIX
A
SIDE
OF
THE
POLYGON
AND
CALL
IT
E
NOW
CONSIDER
THE
TRIANGLES
THAT
MIGHT
CONTAIN
E
THINK
OF
THESE
TRIANGLES
AS
THE
ROOT
OF
A
BINARY
TREE
THINK
OF
THE
TWO
RESULTING
POLYGONS
THAT
YOU
GET
BY
REMOVING
THIS
TRIANGLE
AS
THE
TWO
SUBTREES
OF
THE
ROOT
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
SEQUENCE
OF
INTEGERS
NOT
NECESSARILY
POSITIVE
THE
PROBLEM
IS
TO
FIND
THE
CONSECUTIVE
SUBSEQUENCE
OF
WITH
MAXIMUM
SUM
CONSECUTIVE
MEANS
THAT
YOU
ARE
NOT
ALLOWED
TO
SKIP
NUMBERS
FOR
EXAMPLE
IF
THE
INPUT
WAS
THE
OUTPUT
WOULD
BE
GIVE
A
LINEAR
TIME
DYNAMIC
PROGRAMMING
ALGORITHM
FOR
THIS
PROBLEM
IN
YOUR
WRITE
UP
FIRST
EXPLAIN
WHY
A
NAIVE
RECURSIVE
SOLUTION
IS
NOT
POSSIBLE
THAT
IS
FIGURE
OUT
WHY
KNOWING
THE
NTH
NUMBER
AND
THE
MAXIMUM
CONSECUTIVE
SUM
OF
THE
FIRST
N
NUMBERS
IS
NOT
SUFFICIENT
INFORMATION
TO
COMPUTE
THE
MAXIMUM
CONSECUTIVE
SUM
OF
THE
FIRST
N
NUMBERS
THESE
EXAMPLES
WHICH
SHOW
YOU
NEED
TO
STRENGTHEN
THE
INDUCTIVE
HYPOTHESIS
SHOULD
GIVE
YOU
A
BIG
HINT
HOW
TO
STRENGTHEN
THE
INDUCTIVE
HYPOTHESIS
TO
COMPUTE
TWO
DIFFERENT
DIFFERENT
CONSECUTIVE
SUBSEQUENCES
THE
MAXIMUM
CONSECUTIVE
SUM
SUBSEQUENCE
AND
ONE
OTHER
ONE
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
TREE
T
WITH
INTEGER
WEIGHTS
ON
THE
EDGES
THE
WEIGHTS
MAY
BE
NEGATIVE
ZERO
OR
POSITIVE
A
POSITIVE
EDGE
WEIGHT
REPRESENTS
A
PAYMENT
THAT
ONE
RECEIVES
WHEN
TRAVELING
OVER
THE
EDGE
A
NEGATIVE
EDGE
WEIGHT
REPRESENTS
A
PAYMENT
THAT
ONE
MUCH
MAKE
WHEN
TRAVELING
OVER
THE
EDGE
GIVE
A
LINEAR
TIME
ALGORITHM
TO
FIND
THE
MOST
PROFIT
THAT
ONE
CAN
MAKE
FROM
TRAVERSING
A
SIMPLE
PATH
IN
T
NOTE
THAT
YOU
DO
NOT
HAVE
TO
NECESSARILY
FIND
THE
ACTUAL
PATH
THE
LENGTH
OF
A
PATH
IS
THE
SUM
OF
THE
WEIGHTS
OF
THE
EDGES
IN
THE
PATH
A
PATH
IS
SIMPLE
IF
NO
VERTEX
IS
REPEATED
NOTE
THAT
THE
ENDPOINTS
OF
THE
PATH
ARE
UNCONSTRAINED
THIS
MEANS
THAT
IF
THE
TREE
HAS
N
VERTICES
THEN
THERE
ARE
POSSIBLE
SIMPLE
PATHS
THAT
FEASIBLY
MIGHT
BE
THE
SHORTEST
SIMPLE
PATH
DEPENDING
ON
THE
WEIGHTS
AS
THERE
IS
A
ONE
TO
ONE
CORRESPONDENCE
BETWEEN
PAIRS
OF
VERTICES
AND
SIMPLE
PATHS
IN
A
TREE
NOTE
ALSO
THAT
THE
MAXIMUM
PROFIT
IS
ALWAYS
NON
NEGATIVE
SINCE
ONE
CAN
MAKE
ZERO
PROFIT
BY
PICKING
THE
START
AND
ENDPOINT
TO
BE
THE
SAME
POINTS
THE
INPUT
FOR
THIS
PROBLEM
CONSISTS
OF
N
KEYS
KN
WITH
KN
AND
ASSOCIATED
PROBABILITIES
PN
THE
PROBLEM
IS
TO
FIND
THE
AVL
TREE
FOR
THESE
KEYS
THAT
MINIMIZES
THE
EXPECTED
DEPTH
OF
A
KEY
AN
AVL
TREE
IS
A
BINARY
SEARCH
TREE
WITH
THE
PROPERTY
THAT
EVERY
NODE
HAS
BALANCE
FACTOR
OR
THE
BALANCE
FACTOR
OR
A
NODE
IS
THE
HEIGHT
OF
ITS
RIGHT
SUBTREE
MINUS
THE
HEIGHT
OF
ITS
LEFT
SUBTREE
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
HINT
YOU
WILL
HAVE
TO
STRENGTHEN
THE
INDUCTIVE
HYPOTHESIS
OBVIOUSLY
THE
HEIGHT
OF
A
SUBTREE
IS
RELEVANT
POINTS
THE
INPUT
CONSISTS
OF
N
INTERVALS
OVER
THE
REAL
LINE
THE
OUTPUT
SHOULD
BE
A
COLLECTION
C
OF
NON
OVERLAPPING
INTERVALS
SUCH
THE
SUM
OF
THE
LENGTHS
OF
THE
INTERVALS
IN
C
IS
MAXIMIZED
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
DEVELOP
A
DYNAMIC
PROGRAMMING
ALGORITHM
BY
FIRST
DEVELOPING
A
RECURSIVE
ALGORITHM
HINT
TO
GET
A
RECURSIVE
ALGORITHM
YOU
WILL
NEED
TO
STRENGTHEN
THE
INDUCTION
HYPOTHESIS
CONSIDER
THE
INTERVALS
BY
INCREASING
ORDER
OF
THEIR
LEFT
ENDPOINTS
JUST
LIKE
IN
THE
LONGEST
INCREASING
SUBSEQUENCE
LIS
PROBLEM
THERE
ARE
TWO
PIECES
OF
INFORMATION
THAT
ARE
RELEVANT
ABOUT
A
PARTIAL
SOLUTION
ONE
IS
OBVIOUSLY
THE
LENGTH
OF
THE
INTERVALS
WHAT
IS
THE
OTHER
THINK
ABOUT
WHAT
THE
ANSWER
WAS
IN
THE
LIS
PROBLEM
DEVELOP
A
DYNAMIC
PROGRAMMING
ALGORITHM
BY
ENUMERATING
THE
POSSIBLE
SUBSETS
OF
INTERVALS
AND
THEN
PRUNING
THE
TREE
HINT
CONSIDER
THE
INTERVALS
BY
INCREASING
ORDER
OF
THEIR
LEFT
ENDPOINTS
POINTS
CONSIDER
THE
CODE
FOR
THE
KNAPSACK
PROGRAM
GIVEN
IN
THE
CLASS
NOTES
EXPLAIN
HOW
ONE
CAN
ACTUALLY
FIND
THE
HIGHEST
VALUED
SUBSET
OF
OBJECTS
SUBJECT
TO
THE
WEIGHT
CONSTRAINT
FROM
THE
VALUE
TABLE
COMPUTED
BY
THIS
CODE
SO
YOU
NEED
TO
EXPLAIN
HOW
TO
BACKTRACK
FROM
THE
BOTTOM
OF
THE
TABLE
BACK
TO
THE
TOP
OF
THE
TABLE
TO
ACTUALLY
CONSTRUCT
THE
SUBSET
OF
OBJECTS
IN
THE
KNAPSACK
EXPLAIN
HOW
TO
SOLVE
THE
KNAPSACK
PROBLEM
USING
ONLY
O
L
MEMORY
SPACE
AND
O
NL
TIME
YOU
NEED
ONLY
FIND
THE
VALUE
AND
WEIGHT
OF
THE
OPTIMAL
SOLUTION
NOT
THE
ACTUAL
COLLECTION
OF
OBJECTS
POINTS
OUR
GOAL
IS
NOW
TO
CONSIDER
THE
KNAPSACK
PROBLEM
AND
DEVELOP
A
METHOD
FOR
COMPUTING
THE
ACTUAL
ITEMS
TO
BE
TAKEN
IN
O
L
SPACE
AND
O
NL
TIME
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
THE
SAME
AS
FOR
THE
KNAPSACK
PROBLEM
A
COLLECTION
OF
N
ITEMS
IN
WITH
WEIGHTS
WN
AND
VALUES
VN
AND
A
WEIGHT
LIMIT
L
THE
OUTPUT
IS
IN
TWO
PARTS
FIRST
YOU
WANT
TO
COMPUTE
THE
MAXIMUM
VALUE
OF
A
SUBSET
OF
THE
N
ITEMS
THAT
HAS
WEIGHT
AT
MOST
L
AS
WELL
AS
THE
WEIGHT
OF
THIS
SUBSET
LET
US
CALL
THIS
VALUE
AND
WEIGHT
VA
AND
WA
SECONDLY
FOR
THIS
SUBSET
YOU
WANT
TO
COMPUTE
THE
WEIGHT
AND
VALUE
OF
THE
ITEMS
IN
IN
THAT
ARE
IN
LET
USE
CALL
THIS
VALUE
AND
WEIGHT
VB
AND
WB
SO
YOUR
OUTPUT
WILL
BE
TWO
WEIGHTS
AND
TWO
VALUES
GIVE
AN
ALGORITHM
FOR
THIS
PROBLEM
THAT
USES
SPACE
O
L
AND
TIME
O
NL
EXPLAIN
HOW
TO
USE
THE
ALGORITHM
FROM
THE
PREVIOUS
SUBPROBLEM
TO
GET
A
DIVIDE
AND
CONQUER
ALGORITHM
FOR
FINDING
THE
ITEMS
IN
THE
KNAPSACK
PROBLEM
A
AND
USES
SPACE
O
L
AND
TIME
O
NL
HINT
FIRST
CALL
THE
ALGORITHM
FOR
THE
PREVIOUS
SUBPROBLEM
WHAT
RECURSIVE
CALL
DO
YOU
NEED
TO
MAKE
TO
FIND
THE
ITEMS
IN
THE
FINAL
ANSWER
FROM
THE
ITEMS
IN
IN
WHAT
RECURSIVE
CALL
DO
YOU
NEED
TO
MAKE
TO
FIND
THE
ITEMS
IN
THE
FINAL
ANSWER
FROM
THE
ITEMS
IN
IN
IN
HINT
HINT
THE
SOLUTION
TO
THE
RECURRENCE
RELATION
T
K
T
A
T
B
K
IS
O
K
IF
A
B
K
POINTS
GIVE
AN
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
WHOSE
RUNNING
TIME
IS
POLYNOMIAL
IN
N
L
INPUT
POSITIVE
INTEGERS
VN
WITH
L
N
VI
OUTPUT
A
SOLUTION
IF
ONE
EXISTS
TO
N
XI
VI
WHERE
EACH
XI
IS
EITHER
OR
HINT
VERY
SIMILAR
TO
SUBSET
SUM
ALGORITHM
POINTS
GIVE
AN
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
WHOSE
RUNNING
TIME
IS
POLYNOMIAL
IN
N
LOG
L
INPUT
POSITIVE
INTEGERS
VN
AND
L
OUTPUT
A
SOLUTION
IF
ONE
EXISTS
TO
N
XIVI
MOD
N
L
MOD
N
WHERE
EACH
XI
IS
EITHER
OR
HERE
X
MOD
Y
MEANS
THE
REMAINDER
WHEN
X
IS
DIVIDED
BY
Y
HINT
THIS
IS
LIKE
THE
SUBSET
SUM
PROBLEM
BUT
YOU
WILL
HAVE
TO
BE
MORE
SEVERE
IN
YOUR
PRUNING
SINCE
YOU
CAN
T
AFFORD
TO
HAVE
L
PARTIAL
SOLUTIONS
ANYMORE
POINTS
GIVE
AN
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
WHOSE
RUNNING
TIME
IS
POLYNOMIAL
IN
N
W
INPUT
POSITIVE
INTEGERS
WN
VN
AND
W
OUTPUT
THE
MAXIMUM
POSSIBLE
VALUE
OF
N
XIVI
SUBJECT
TO
N
XIWI
W
AND
EACH
XI
IS
A
NONNEGATIVE
INTEGER
HINT
THE
TREE
OF
FEASIBLE
SOLUTIONS
WILL
BE
DIFFERENT
THAN
THE
ONE
IN
THE
KNAPSACK
SUBSET
SUM
PROBLEM
SINCE
YOU
MAY
INCLUDE
AN
ITEM
IN
THE
FINAL
SUM
MORE
THAN
ONCE
EACH
NODE
IN
THE
TREE
OF
FEASIBLE
SOLUTIONS
MAY
NOW
HAVE
UP
TO
W
CHILDREN
POINTS
GIVE
AN
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
WHOSE
RUNNING
TIME
IS
POLYNOMIAL
IN
N
L
WHERE
L
MAX
N
N
VI
INPUT
POSITIVE
INTEGERS
VN
OUTPUT
A
SUBSET
OF
THE
INTEGERS
SUCH
THAT
VI
VI
VI
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
SET
OF
N
GEMS
EACH
GEM
HAS
A
VALUE
IN
DOLLARS
AND
IS
EITHER
A
RUBY
OR
AN
EMERALD
LET
THE
SUM
OF
THE
VALUES
OF
THE
GEMS
BE
L
THE
PROBLEM
IS
TO
DETERMINE
IF
IT
IS
POSSIBLE
TO
PARTITION
OF
THE
GEMS
INTO
TWO
PARTS
P
AND
Q
SUCH
THAT
EACH
PART
HAS
THE
SAME
VALUE
THE
NUMBER
OF
RUBIES
IN
P
IS
EQUAL
TO
THE
NUMBER
OF
RUBIES
IN
Q
AND
THE
NUMBER
OF
EMERALDS
IN
P
IS
EQUAL
TO
THE
NUMBER
OF
EMERALDS
IN
Q
NOTE
THAT
A
PARTITION
MEANS
THAT
EVERY
GEM
MUST
BE
IN
EXACTLY
ONE
OF
P
OR
Q
YOU
ALGORITHM
SHOULD
RUN
IN
TIME
POLYNOMIAL
IN
N
L
HINT
START
AS
IN
THE
SUBSET
SUM
EXAMPLE
YOUR
PRUNING
RULE
WILL
HAVE
TO
BE
LESS
SEVERE
THAT
IS
FIRST
ASK
YOURSELF
WHY
YOU
MAY
NOT
BE
ABLE
TO
PRUNE
TWO
POTENTIAL
SOLUTIONS
THAT
HAVE
THE
SAME
AGGREGATE
VALUE
POINTS
THE
INPUT
TO
THIS
PROBLEM
CONSISTS
OF
AN
ORDERED
LIST
OF
N
WORDS
THE
LENGTH
OF
THE
ITH
WORD
IS
WI
THAT
IS
THE
ITH
WORD
TAKES
UP
WI
SPACES
FOR
SIMPLICITY
ASSUME
THAT
THERE
ARE
NO
SPACES
BETWEEN
WORDS
THE
GOAL
IS
TO
BREAK
THIS
ORDERED
LIST
OF
WORDS
INTO
LINES
THIS
IS
CALLED
A
LAYOUT
NOTE
THAT
YOU
CAN
NOT
REORDER
THE
WORDS
THE
LENGTH
OF
A
LINE
IS
THE
SUM
OF
THE
LENGTHS
OF
THE
WORDS
ON
THAT
LINE
THE
IDEAL
LINE
LENGTH
IS
L
NO
LINE
MAY
BE
LONGER
THAN
L
ALTHOUGH
IT
MAY
BE
SHORTER
THE
PENALTY
FOR
HAVING
A
LINE
OF
LENGTH
K
IS
L
K
THE
TOTAL
PENALTY
IS
THE
MAXIMUM
OF
THE
LINE
PENALTIES
THE
PROBLEM
IS
TO
FIND
A
LAYOUT
THAT
MINIMIZES
THE
TOTAL
PENALTY
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
HINT
CONSIDER
WHETHER
HOW
MANY
LAYOUTS
OF
THE
FIRST
M
WORDS
WHICH
HAVE
K
LETTERS
ON
THE
LAST
LINE
YOU
NEED
TO
REMEMBER
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
TWO
SEQUENCES
T
TN
AND
P
PK
SUCH
THAT
K
N
AND
A
POSITIVE
INTEGER
COST
CI
ASSOCIATED
WITH
EACH
TI
THE
PROBLEM
IS
TO
FIND
A
SUBSEQUENCE
OF
OF
T
THAT
MATCHES
P
WITH
MAXIMUM
AGGREGATE
COST
THAT
IS
FIND
THE
SEQUENCE
IK
SUCH
THAT
FOR
ALL
J
J
K
WE
HAVE
TIJ
PJ
AND
K
CIJ
IS
MAXIMIZED
SO
FOR
EXAMPLE
IF
N
T
XY
XXY
K
P
XY
AND
THEN
THE
OPTIMAL
SOLUTION
IS
TO
PICK
THE
SECOND
X
IN
T
AND
THE
SECOND
Y
IN
T
FOR
A
COST
OF
GIVE
A
RECURSIVE
ALGORITHM
TO
SOLVE
THIS
PROBLEM
THEN
EXPLAIN
HOW
TO
TURN
THIS
RECURSIVE
ALGORITHM
INTO
A
DYNAMIC
PROGRAM
GIVE
A
DYNAMIC
PROGRAMMING
ALGORITHM
BASED
ON
ENUMERATING
SUBSEQUENCES
OF
T
AND
USING
THE
PRUNING
METHOD
GIVE
A
DYNAMIC
PROGRAMMING
ALGORITHM
BASED
ON
ENUMERATING
SUBSEQUENCES
OF
P
AND
USING
THE
PRUNING
METHOD
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
SEQUENCE
OF
N
POINTS
PN
IN
THE
EUCLIDEAN
PLANE
YOU
ARE
TO
FIND
THE
SHORTEST
ROUTES
FOR
TWO
TAXIS
TO
SERVICE
THESE
REQUESTS
IN
ORDER
LET
US
BE
MORE
SPECIFIC
THE
TWO
TAXIS
START
AT
THE
ORIGIN
IF
A
TAXI
VISITS
A
POINT
PI
BEFORE
PJ
THEN
IT
MUST
BE
THE
CASE
THAT
I
J
STOP
AND
THINK
ABOUT
WHAT
THIS
LAST
SENTENCE
MEANS
EACH
POINT
MUST
BE
VISITED
BY
AT
LEAST
ONE
OF
THE
TWO
TAXIS
THE
COST
OF
A
ROUTING
IS
JUST
THE
TOTAL
DISTANCE
TRAVELED
BY
THE
FIRST
TAXI
PLUS
THE
TOTAL
DISTANCE
TRAVELED
BY
THE
SECOND
TAXI
DESIGN
AN
O
TIME
ALGORITHM
TO
FIND
THE
MINIMUM
COST
ROUTING
HINT
USE
DYNAMIC
PROGRAMMING
CONSIDER
EXHAUSTIVELY
ENUMERATING
THE
POSSIBLE
TOURS
ONE
POINT
AT
A
TIME
SO
AFTER
THE
ITH
STAGE
YOU
WOULD
CONSIDER
ALL
WAYS
TO
VISIT
THE
POINTS
PI
THEN
FIND
A
PRUNING
RULE
THAT
WILL
REDUCE
THE
NUMBER
OF
TOURS
WE
NEED
TO
REMEMBER
DOWN
TO
A
POLYNOMIAL
NUMBER
AN
O
TIME
ALGORITHM
IS
WORTH
POINTS
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
N
POINTS
XN
ON
A
LINE
A
GOOD
PATH
P
HAS
THE
PROPERTY
THAT
ONE
ENDPOINT
OF
P
IS
THE
ORIGIN
AND
EVERY
XI
IS
COVERED
BY
P
NOTE
THAT
P
NEED
NOT
BE
SIMPLE
THAT
IS
IT
CAN
BACKTRACK
OVER
TERRITORY
THAT
IT
HAS
ALREADY
COVERED
ASSUME
A
VEHICLE
MOVES
ALONG
THIS
PATH
FROM
THE
ORIGIN
AT
UNIT
SPEED
THE
RESPONSE
TIME
RI
FOR
EACH
XI
IS
THE
TIME
UNTIL
THE
VEHICLE
FIRST
REACHES
XI
THE
PROBLEM
IS
TO
FIND
THE
GOOD
PATH
THAT
MINIMIZES
N
RI
N
THE
AVERAGE
RESPONSE
TIME
FOR
EXAMPLE
IF
THE
POINTS
ARE
AND
AND
THE
PATH
VISITED
THE
POINTS
IN
THE
ORDER
THE
AVERAGE
RESPONSE
TIME
FOR
THIS
PATH
WOULD
BE
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
POINTS
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
IS
A
COLLECTION
OF
N
TRAIN
TRIPS
WITHIN
GERMANY
FOR
THE
ITH
TRIP
TI
YOU
ARE
GIVEN
THE
DATE
DI
OF
THAT
TRIP
AND
THE
NON
DISCOUNTED
FARE
FI
FOR
THAT
TRIP
THE
GERMAN
RAILWAY
SYSTEM
SELLS
A
BAHNCARD
FOR
B
MARKS
THAT
ENTITLES
YOU
TO
A
FARE
REDUCTION
ON
ALL
TRAIN
TRAVEL
WITHIN
GERMANY
WITHIN
L
DAYS
OF
PURCHASE
THE
PROBLEM
IS
TO
DETERMINE
WHEN
TO
BUY
A
BAHNCARD
TO
MINIMIZE
THE
TOTAL
COST
OF
YOUR
TRAVEL
FOR
EXAMPLE
IF
THE
INPUT
WAS
JANUARY
MARKS
FEBRUARY
MARKS
JANUARY
MARKS
MARCH
MARKS
FEBRUARY
MARKS
AND
JANUARY
MARKS
B
AND
L
THEN
YOU
MIGHT
BUY
A
BAHNCARD
ON
FEBRUARY
AND
FEBRUARY
RESULTING
IN
A
TOTAL
COST
OF
MARKS
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
THE
RUNNING
TIME
OF
YOU
ALGORITHM
SHOULD
BE
INDEPENDENT
OF
B
AND
L
POINTS
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
THE
INPUT
CONSISTS
OF
A
SEQUENCE
R
RN
OF
NON
NEGATIVE
INTEGERS
AND
AN
INTEGER
K
THE
NUMBER
RI
REPRESENTS
THE
NUMBER
OF
USERS
REQUESTING
SOME
PARTICULAR
PIECE
OF
INFORMATION
AT
TIME
I
SAY
FROM
A
WWW
SERVER
IF
THE
SERVER
BROADCASTS
THIS
INFORMATION
AT
SOME
TIME
T
THE
THE
REQUESTS
OF
ALL
THE
USERS
WHO
REQUESTED
THE
INFORMATION
STRICTLY
BEFORE
TIME
T
ARE
SATISFIED
THE
SERVER
CAN
BROADCAST
THIS
INFORMATION
AT
MOST
K
TIMES
THE
GOAL
IS
TO
PICK
THE
K
TIMES
TO
BROADCAST
IN
ORDER
TO
MINIMIZE
THE
TOTAL
TIME
OVER
ALL
REQUESTS
THAT
REQUESTS
USERS
HAVE
TO
WAIT
IN
ORDER
TO
HAVE
THEIR
REQUESTS
SATISFIED
AS
AN
EXAMPLE
ASSUME
THAT
THE
INPUT
WAS
R
SO
N
AND
K
THEN
ONE
POSSIBLE
SOLUTION
THERE
IS
NO
CLAIM
THAT
THIS
IS
THE
OPTIMAL
SOLUTION
WOULD
BE
TO
BROADCAST
AT
TIMES
AND
NOTE
THAT
IT
IS
OBVIOUS
THAT
IN
EVERY
OPTIMAL
SCHEDULE
THAT
THERE
IS
A
BROADCAST
AT
TIME
N
IF
RN
THE
REQUESTS
AT
TIME
WOULD
THEN
HAVE
TO
WAIT
TIME
UNIT
THE
REQUESTS
AT
TIME
WOULD
THEN
HAVE
TO
WAIT
TIME
UNITS
THE
REQUESTS
AT
TIME
WOULD
THEN
HAVE
TO
WAIT
TIME
UNITS
THE
REQUESTS
AT
TIME
WOULD
THEN
HAVE
TO
WAIT
TIME
UNITS
THE
REQUESTS
AT
TIME
WOULD
THEN
HAVE
TO
WAIT
TIME
UNITS
THUS
THE
TOTAL
WAITING
TIME
FOR
THIS
SOLUTION
WOULD
BE
POINTS
ASSUME
THAT
YOU
ARE
GIVEN
A
COLLECTION
BN
OF
BOXES
YOU
ARE
TOLD
THAT
THE
WEIGHT
IN
KILOGRAMS
OF
EACH
BOX
IS
AN
INTEGER
BETWEEN
AND
SOME
CONSTANT
L
INCLUSIVE
HOWEVER
YOU
DO
NOT
KNOW
THE
SPECIFIC
WEIGHT
OF
ANY
BOX
AND
YOU
DO
NOT
KNOW
THE
SPECIFIC
VALUE
OF
L
YOU
ARE
ALSO
GIVEN
A
PAN
BALANCE
A
PAN
BALANCE
FUNCTIONS
IN
THE
FOLLOWING
MANNER
YOU
CAN
GIVE
THE
PAN
BALANCE
ANY
TWO
DISJOINT
SUB
COLLECTIONS
SAY
AND
OF
THE
BOXES
LET
AND
BE
THE
CUMULATIVE
WEIGHT
OF
THE
BOXES
IN
AND
RESPECTIVELY
THE
PAN
BALANCE
THEN
DETERMINES
WHETHER
OR
YOU
HAVE
NOTHING
ELSE
AT
YOUR
DISPOSAL
OTHER
THAN
THESE
N
BOXES
AND
THE
PAN
BALANCE
THE
PROBLEM
IS
TO
DETERMINE
IF
ONE
CAN
PARTITION
THE
BOXES
INTO
TWO
DISJOINT
SUB
COLLECTIONS
OF
EQUAL
WEIGHT
GIVE
AN
ALGORITHM
FOR
THIS
PROBLEM
THAT
MAKES
AT
MOST
O
L
USES
OF
THE
PAN
BALANCE
FOR
PARTIAL
CREDIT
FIND
AN
ALGORITHM
WHERE
THE
NUMBER
OF
USES
IS
POLYNOMIAL
IN
N
AND
L
POINTS
GIVE
A
ALGORITHM
THAT
TAKES
A
POSITIVE
INTEGER
N
AS
INPUT
AND
COMPUTES
THE
NUMBER
OF
POSSIBLE
ORDERINGS
OF
N
OBJECTS
UNDER
THE
RELATIONS
AND
FOR
EXAMPLE
IF
N
THE
POSSIBLE
ORDERINGS
ARE
AS
FOLLOWS
A
B
C
A
B
C
A
B
C
A
B
C
A
C
B
A
C
B
B
A
C
B
A
C
B
C
A
B
C
A
C
A
B
C
A
B
AND
C
B
A
YOUR
ALGORITHM
SHOULD
RUN
IN
TIME
POLYNOMIAL
IN
N
POINTS
GIVE
A
POLYNOMIAL
TIME
DYNAMIC
PROGRAMMING
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
THE
INPUT
CONSISTS
OF
A
TWO
DIMENSIONAL
ARRAY
R
OF
NON
NEGATIVE
INTEGERS
AND
AN
INTEGER
K
THE
VALUE
RT
P
GIVES
THE
NUMBER
OF
OF
USERS
REQUESTING
PAGE
P
AT
TIME
T
SAY
FROM
A
WWW
SERVER
AT
EACH
INTEGER
TIME
THE
SERVER
CAN
BROADCAST
AN
ARBITRARY
COLLECTION
OF
PAGES
IF
THE
SERVER
BROADCASTS
THE
J
PAGES
PJ
AT
TIME
T
THEN
THE
REQUESTS
OF
ALL
THE
USERS
WHO
REQUESTED
PAGES
PJ
STRICTLY
BEFORE
TIME
T
ARE
SATISFIED
THIS
COUNTS
AT
J
BROADCASTS
THE
SERVER
CAN
MAKE
AT
MOST
K
BROADCASTS
IN
TOTAL
OVER
ALL
TIMES
THE
GOAL
IS
TO
PICK
THE
TIMES
TO
BROADCAST
AND
THE
PAGES
TO
BROADCAST
AT
THOSE
TIMES
IN
ORDER
TO
MINIMIZE
THE
TOTAL
TIME
OVER
ALL
REQUESTS
THAT
REQUESTS
USERS
HAVE
TO
WAIT
IN
ORDER
TO
HAVE
THEIR
REQUESTS
SATISFIED
SUBJECT
TO
THE
CONSTRAINT
THAT
THERE
ARE
AT
MOST
K
BROADCASTS
FOR
EXAMPLE
IF
K
AND
THE
ARRAY
R
WAS
ONE
SCHEDULE
WHICH
IS
PRESUMABLY
OPTIMAL
IS
TO
BROADCAST
PAGES
A
AND
B
AT
TIME
AND
PAGE
B
AGAIN
AT
TIME
THIS
GIVES
K
TOTAL
BROADCASTS
THE
WAITING
TIME
FOR
THE
PAGE
REQUESTS
TO
PAGE
A
AT
TIME
WOULD
BE
THE
PAGE
REQUEST
TO
B
AT
TIME
WOULD
WAIT
THE
PAGE
REQUESTS
TO
B
AT
TIME
WOULD
WAIT
AND
THE
PAGE
REQUESTS
TO
B
AT
TIME
WOULD
WAIT
THIS
GIVES
TOTAL
WAITING
TIME
SO
PROBLEM
IS
A
SPECIAL
CASE
OF
THIS
PROBLEM
WHERE
THERE
IS
ONLY
ONE
PAGE
POINTS
INFORMALLY
IN
THIS
PROBLEM
WE
CONSIDER
HOW
TO
DIVIDE
THE
CHAPTERS
IN
A
STORY
INTO
VOLUMES
THINK
THE
VOLUMES
OF
HARRY
POTTER
OR
HOWEVER
MANY
GAME
OF
THRONES
VOLUMES
THERE
WILL
BE
SO
AS
TO
EQUALIZE
THE
SIZE
OF
THE
VOLUMES
THE
INPUT
CONSISTS
OF
POSITIVE
INTEGERS
XN
AND
K
HERE
XI
IS
THE
NUMBER
OF
PAGES
IN
CHAPTER
I
AND
K
IS
THE
DESIRED
NUMBER
OF
VOLUMES
THE
PROBLEM
IS
DETERMINE
WHICH
CHAPTERS
GO
INTO
EACH
OF
THE
K
VOLUMES
SO
AS
TO
MINIMIZE
THE
DIFFERENCE
BETWEEN
THE
MOST
NUMBER
OF
PAGES
IN
ANY
VOLUMES
AND
THE
LEAST
NUMBER
OF
PAGES
IN
ANY
OF
THE
VOLUMES
OF
COURSE
YOU
CAN
NOT
REORDER
THE
STORY
GIVE
AN
ALGORITHM
WHOSE
RUNNING
TIME
IS
BOUNDED
BY
A
POLYNOMIAL
IN
N
YOU
RUNNING
TIME
SHOULD
NOT
DEPEND
ON
THE
NUMBER
OF
PAGES
IN
THE
CHAPTERS
CS
GREEDY
HOMEWORK
PROBLEMS
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
INPUT
A
SET
XI
YI
I
N
OF
INTERVALS
OVER
THE
REAL
LINE
OUTPUT
A
MAXIMUM
CARDINALITY
SUBSET
SI
OF
SUCH
THAT
NO
PAIR
OF
INTERVALS
IN
SI
OVERLAP
CONSIDER
THE
FOLLOWING
ALGORITHM
REPEAT
UNTIL
IS
EMPTY
SELECT
THE
INTERVAL
I
THAT
OVERLAPS
THE
LEAST
NUMBER
OF
OTHER
INTERVALS
ADD
I
TO
FINAL
SOLUTION
SET
SI
REMOVE
ALL
INTERVALS
FROM
THAT
OVERLAP
WITH
I
PROVE
OR
DISPROVE
THAT
THIS
ALGORITHM
SOLVES
THE
PROBLEM
POINTS
CONSIDER
THE
FOLLOWING
INTERVAL
COLORING
PROBLEM
INPUT
A
SET
XI
YI
I
N
OF
INTERVALS
OVER
THE
REAL
LINE
THINK
OF
INTERVAL
XI
YI
AS
BEING
A
REQUEST
FOR
A
ROOM
FOR
A
CLASS
THAT
MEETS
FROM
TIME
XI
TO
TIME
YI
OUTPUT
FIND
AN
ASSIGNMENT
OF
CLASSES
TO
ROOMS
THAT
USES
THE
FEWEST
NUMBER
OF
ROOMS
NOTE
THAT
EVERY
ROOM
REQUEST
MUST
BE
HONORED
AND
THAT
NO
TWO
CLASSES
CAN
USE
A
ROOM
AT
THE
SAME
TIME
CONSIDER
THE
FOLLOWING
ITERATIVE
ALGORITHM
ASSIGN
AS
MANY
CLASSES
AS
POSSIBLE
TO
THE
FIRST
ROOM
WE
CAN
DO
THIS
USING
THE
GREEDY
ALGORITHM
DISCUSSED
IN
CLASS
AND
IN
THE
CLASS
NOTES
THEN
ASSIGN
AS
MANY
CLASSES
AS
POSSIBLE
TO
THE
SECOND
ROOM
THEN
ASSIGN
AS
MANY
CLASSES
AS
POSSIBLE
TO
THE
THIRD
ROOM
ETC
DOES
THIS
ALGORITHM
SOLVE
THE
INTERVAL
COLORING
PROBLEM
JUSTIFY
YOUR
ANSWER
CONSIDER
THE
FOLLOWING
ALGORITHM
PROCESS
THE
CLASSES
IN
INCREASING
ORDER
OF
START
TIMES
ASSUME
THAT
YOU
ARE
PROCESSING
CLASS
C
IF
THERE
IS
A
ROOM
R
SUCH
THAT
R
HAS
BEEN
ASSIGNED
TO
AN
EARLIER
CLASS
AND
C
CAN
BE
ASSIGNED
TO
R
WITHOUT
OVERLAPPING
PREVIOUSLY
ASSIGNED
CLASSES
THEN
ASSIGN
C
TO
R
OTHERWISE
PUT
C
IN
A
NEW
ROOM
DOES
THIS
ALGORITHM
SOLVE
THE
INTERVAL
COLORING
PROBLEM
JUSTIFY
YOUR
ANSWER
HINT
LET
BE
THE
MAXIMUM
NUMBER
OF
INTERVALS
THAT
OVERLAP
AT
ONE
PARTICULAR
POINT
IN
TIME
OBVI
OUSLY
YOU
NEED
AT
LEAST
ROOMS
THEREFORE
ANY
ALGORITHM
THAT
USES
ONLY
ROOMS
IS
OBVIOUSLY
OPTIMAL
THIS
LOWER
BOUND
ON
THE
NUMBER
OF
ROOMS
REQUIRED
ALLOWS
YOU
TO
PROVE
OPTIMALITY
WITHOUT
USING
AN
EXCHANGE
ARGUMENT
POINTS
WE
CONSIDER
TWO
CHANGE
MAKING
PROBLEMS
CONSIDER
THE
CHANGE
PROBLEM
IN
PRE
EURO
AUSTRIA
THE
INPUT
TO
THIS
PROBLEM
IS
AN
INTEGER
L
THE
OUTPUT
SHOULD
BE
THE
MINIMUM
CARDINALITY
COLLECTION
OF
COINS
REQUIRED
TO
MAKE
L
SHILLINGS
OF
CHANGE
THAT
IS
YOU
WANT
TO
USE
AS
FEW
COINS
AS
POSSIBLE
IN
AUSTRIA
THE
COINS
ARE
WORTH
SHILLINGS
ASSUME
THAT
YOU
HAVE
AN
UNLIMITED
NUMBER
OF
COINS
OF
EACH
TYPE
FORMALLY
PROVE
OR
DISPROVE
THAT
THE
GREEDY
ALGORITHM
THAT
TAKES
AS
MANY
COINS
AS
POSSIBLE
FROM
THE
HIGHEST
DENOMINATIONS
CORRECTLY
SOLVES
THE
CHANGE
PROBLEM
SO
FOR
EXAMPLE
TO
MAKE
CHANGE
FOR
SHILLINGS
THE
GREEDY
ALGORITHMS
WOULD
TAKE
FOUR
SHILLING
COINS
ONE
SHILLING
COIN
ONE
SHILLING
COIN
AND
FOUR
SHILLING
COINS
CONSIDER
THE
CHANGE
PROBLEM
IN
BINARYLAND
THE
INPUT
TO
THIS
PROBLEM
IS
AN
INTEGER
L
THE
OUTPUT
SHOULD
BE
THE
MINIMUM
CARDINALITY
COLLECTION
OF
COINS
REQUIRED
TO
MAKE
L
NIBBLES
OF
CHANGE
THAT
IS
YOU
WANT
TO
USE
AS
FEW
COINS
AS
POSSIBLE
IN
BINARYLAND
THE
COINS
ARE
WORTH
NIBBLES
ASSUME
THAT
YOU
HAVE
AN
UNLIMITED
NUMBER
OF
COINS
OF
EACH
TYPE
PROVE
OR
DISPROVE
THAT
THE
GREEDY
ALGORITHM
THAT
TAKES
AS
MANY
COINS
OF
THE
HIGHEST
VALUE
AS
POSSIBLE
SOLVES
THE
CHANGE
PROBLEM
IN
BINARYLAND
HINT
THE
GREEDY
ALGORITHM
IS
CORRECT
FOR
ONE
OF
THE
ABOVE
TWO
SUBPROBLEMS
AND
IS
INCORRECT
FOR
THE
OTHER
FOR
THE
PROBLEM
WHERE
GREEDY
IS
CORRECT
USE
THE
FOLLOWING
PROOF
STRATEGY
ASSUME
TO
REACH
A
CONTRADICTION
THAT
THERE
IS
AN
INPUT
I
ON
WHICH
GREEDY
IS
IS
NOT
CORRECT
LET
OP
T
I
BE
A
SOLUTION
FOR
INPUT
I
THAT
IS
BETTER
THAN
THE
GREEDY
OUTPUT
G
I
SHOW
THAT
THE
EXISTENCE
OF
SUCH
AN
OPTIMAL
SOLUTION
OP
T
I
THAT
IS
DIFFERENT
THAN
GREEDY
IS
A
CONTRADICTION
SO
WHAT
YOU
CAN
CONCLUDE
FROM
THIS
IS
THAT
FOR
EVERY
INPUT
THE
OUTPUT
OF
THE
GREEDY
ALGORITHM
IS
THE
UNIQUE
OPTIMAL
CORRECT
SOLUTION
POINTS
YOU
WISH
TO
DRIVE
FROM
POINT
A
TO
POINT
B
ALONG
A
HIGHWAY
MINIMIZING
THE
TIME
THAT
YOU
ARE
STOPPED
FOR
GAS
YOU
ARE
TOLD
BEFOREHAND
THE
CAPACITY
C
OF
YOU
GAS
TANK
IN
LITERS
YOUR
RATE
F
OF
FUEL
CONSUMPTION
IN
LITERS
KILOMETER
THE
RATE
R
IN
LITERS
MINUTE
AT
WHICH
YOU
CAN
FILL
YOUR
TANK
AT
A
GAS
STATION
AND
THE
LOCATIONS
A
B
XN
OF
THE
GAS
STATIONS
ALONG
THE
HIGHWAY
SO
IF
YOU
STOP
TO
FILL
YOUR
TANK
FROM
LITERS
TO
LITERS
YOU
WOULD
HAVE
TO
STOP
FOR
R
MINUTES
CONSIDER
THE
FOLLOWING
TWO
ALGORITHMS
STOP
AT
EVERY
GAS
STATION
AND
FILL
THE
TANK
WITH
JUST
ENOUGH
GAS
TO
MAKE
IT
TO
THE
NEXT
GAS
STATION
STOP
IF
AND
ONLY
IF
YOU
DON
T
HAVE
ENOUGH
GAS
TO
MAKE
IT
TO
THE
NEXT
GAS
STATION
AND
IF
YOU
STOP
FILL
THE
TANK
UP
ALL
THE
WAY
FOR
EACH
ALGORITHM
EITHER
PROVE
OR
DISPROVE
THAT
THIS
ALGORITHM
CORRECTLY
SOLVES
THE
PROBLEM
YOUR
PROOF
OF
CORRECTNESS
MUST
USE
AN
EXCHANGE
ARGUMENT
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
A
COLLECTION
A
AN
OF
N
POINTS
ON
THE
REAL
LINE
THE
PROBLEM
IS
TO
FIND
A
MINIMUM
CARDINALITY
COLLECTION
OF
UNIT
INTERVALS
THAT
COVER
EVERY
POINT
IN
A
ANOTHER
WAY
TO
THINK
ABOUT
THIS
SAME
PROBLEM
IS
THE
FOLLOWING
YOU
KNOW
A
COLLECTION
OF
TIMES
A
THAT
TRAINS
WILL
ARRIVE
AT
A
STATION
WHEN
A
TRAIN
ARRIVES
THERE
MUST
BE
SOMEONE
MANNING
THE
STATION
DUE
TO
UNION
RULES
EACH
EMPLOYEE
CAN
WORK
AT
MOST
ONE
HOUR
AT
THE
STATION
THE
PROBLEM
IS
TO
FIND
A
SCHEDULING
OF
EMPLOYEES
THAT
COVERS
ALL
THE
TIMES
IN
A
AND
USES
THE
FEWEST
NUMBER
OF
EMPLOYEES
PROVE
OR
DISPROVE
THAT
THE
FOLLOWING
ALGORITHM
CORRECTLY
SOLVES
THIS
PROBLEM
LET
I
BE
THE
INTERVAL
THAT
COVERS
THE
MOST
NUMBER
OF
POINTS
IN
A
ADD
I
TO
THE
SOLUTION
SET
THEN
RECURSIVELY
CONTINUE
ON
THE
POINTS
IN
A
NOT
COVERED
BY
I
PROVE
OR
DISPROVE
THAT
THE
FOLLOWING
ALGORITHM
CORRECTLY
SOLVES
THIS
PROBLEM
LET
AJ
BE
THE
SMALLEST
LEFTMOST
POINT
IN
A
ADD
THE
INTERVAL
I
AJ
AJ
TO
THE
SOLUTION
SET
THEN
RECURSIVELY
CONTINUE
ON
THE
POINTS
IN
A
NOT
COVERED
BY
I
HINT
ONE
OF
THE
ABOVE
GREEDY
ALGORITHMS
IS
CORRECT
AND
ONE
IS
INCORRECT
FOR
THE
OTHER
THE
PROOF
OF
CORRECTNESS
MUST
USE
AN
EXCHANGE
ARGUMENT
POINTS
WE
CONSIDER
A
GREEDY
ALGORITHM
FOR
TWO
RELATED
PROBLEMS
THE
INPUT
TO
THIS
PROBLEM
CONSISTS
OF
AN
ORDERED
LIST
OF
N
WORDS
THE
LENGTH
OF
THE
ITH
WORD
IS
WI
THAT
IS
THE
ITH
WORD
TAKES
UP
WI
SPACES
FOR
SIMPLICITY
ASSUME
THAT
THERE
ARE
NO
SPACES
BETWEEN
WORDS
THE
GOAL
IS
TO
BREAK
THIS
ORDERED
LIST
OF
WORDS
INTO
LINES
THIS
IS
CALLED
A
LAYOUT
NOTE
THAT
YOU
CAN
NOT
REORDER
THE
WORDS
THE
LENGTH
OF
A
LINE
IS
THE
SUM
OF
THE
LENGTHS
OF
THE
WORDS
ON
THAT
LINE
THE
IDEAL
LINE
LENGTH
IS
L
NO
LINE
MAY
BE
LONGER
THAN
L
ALTHOUGH
IT
MAY
BE
SHORTER
THE
PENALTY
FOR
HAVING
A
LINE
OF
LENGTH
K
IS
L
K
THE
TOTAL
PENALTY
IS
THE
SUM
OF
THE
LINE
PENALTIES
THE
PROBLEM
IS
TO
FIND
A
LAYOUT
THAT
MINIMIZES
THE
TOTAL
PENALTY
PROVE
OF
DISPROVE
THAT
THE
FOLLOWING
GREEDY
ALGORITHM
CORRECTLY
SOLVES
THIS
PROBLEM
FOR
I
TO
N
PLACE
THE
ITH
WORD
ON
THE
CURRENT
LINE
IF
IT
FITS
ELSE
PLACE
THE
ITH
WORD
ON
A
NEW
LINE
THE
INPUT
TO
THIS
PROBLEM
CONSISTS
OF
AN
ORDERED
LIST
OF
N
WORDS
THE
LENGTH
OF
THE
ITH
WORD
IS
WI
THAT
IS
THE
ITH
WORD
TAKES
UP
WI
SPACES
FOR
SIMPLICITY
ASSUME
THAT
THERE
ARE
NO
SPACES
BETWEEN
WORDS
THE
GOAL
IS
TO
BREAK
THIS
ORDERED
LIST
OF
WORDS
INTO
LINES
THIS
IS
CALLED
A
LAYOUT
NOTE
THAT
YOU
CAN
NOT
REORDER
THE
WORDS
THE
LENGTH
OF
A
LINE
IS
THE
SUM
OF
THE
LENGTHS
OF
THE
WORDS
ON
THAT
LINE
THE
IDEAL
LINE
LENGTH
IS
L
NO
LINE
MAY
BE
LONGER
THAN
L
ALTHOUGH
IT
MAY
BE
SHORTER
THE
PENALTY
FOR
HAVING
A
LINE
OF
LENGTH
K
IS
L
K
THE
TOTAL
PENALTY
IS
THE
MAXIMUM
OF
THE
LINE
PENALTIES
THE
PROBLEM
IS
TO
FIND
A
LAYOUT
THAT
MINIMIZES
THE
TOTAL
PENALTY
PROVE
OF
DISPROVE
THAT
THE
FOLLOWING
GREEDY
ALGORITHM
CORRECTLY
SOLVES
THIS
PROBLEM
FOR
I
TO
N
PLACE
THE
ITH
WORD
ON
THE
CURRENT
LINE
IF
IT
FITS
ELSE
PLACE
THE
ITH
WORD
ON
A
NEW
LINE
HINT
THE
GREEDY
ALGORITHM
IS
CORRECT
FOR
ONE
OF
THE
ABOVE
TWO
PROBLEMS
AND
IS
INCORRECT
FOR
THE
OTHER
THE
PROOF
OF
CORRECTNESS
MUST
BE
DONE
USING
AN
EXCHANGE
ARGUMENT
POINTS
THE
SETTING
FOR
THIS
PROBLEM
IS
STORAGE
SYSTEM
WITH
A
FAST
MEMORY
CONSISTING
OF
K
PAGES
AND
A
SLOW
MEMORY
CONSISTING
OF
N
PAGES
AT
ANY
TIME
THE
FAST
MEMORY
CAN
HOLD
COPIES
OF
UP
TO
K
OF
THE
PAGES
IN
SLOW
MEMORY
THE
INPUT
CONSISTS
OF
A
SEQUENCE
OF
PAGES
FROM
SLOW
MEMORY
THINK
OF
THESE
AS
BEING
ACCESSES
TO
MEMORY
IF
AN
ACCESSED
PAGE
IS
NOT
IN
FAST
MEMORY
THEN
IT
MUST
BE
SWAPPED
INTO
FAST
MEMORY
AND
IF
THE
FAST
MEMORY
WAS
FULL
SOME
PAGE
MUST
SELECTED
TO
BE
EVICTED
FROM
FAST
MEMORY
THE
GOAL
IS
TO
DETERMINE
THE
PAGES
TO
EVICT
SO
AS
TO
MINIMIZE
THE
TOTAL
NUMBER
OF
EVICTIONS
CONSIDER
FOR
EXAMPLE
THAT
K
N
PAGES
ARE
NAMED
A
B
C
AND
D
AND
THE
ACCESS
SEQUENCE
IS
A
B
C
A
THEN
AFTER
THE
FIRST
TWO
PAGES
THE
FAST
MEMORY
CONTAINS
A
AND
B
WHEN
C
IS
ACCESSED
THEN
EITHER
A
OR
B
MUST
BE
EVICTED
IF
B
IS
EVICTED
THEN
NO
FURTHER
EVICTIONS
ARE
NECESSARY
AND
THE
TOTAL
NUMBER
OF
EVICTIONS
IS
IF
A
WAS
EVICTED
THEN
EITHER
B
OR
C
MUST
BE
EVICTED
WHEN
A
IS
ACCESSED
AGAIN
AND
THE
TOTAL
NUMBER
OF
EVICTIONS
WOULD
BE
GIVE
A
GREEDY
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
CONSISTS
OF
THE
LENGTHS
N
AND
ACCESS
PROBABILITIES
PN
FOR
N
FILES
FN
THE
PROBLEM
IS
TO
ORDER
THESE
FILES
ON
A
TAPE
SO
AS
TO
MINIMIZE
THE
EXPECTED
ACCESS
TIME
IF
THE
FILES
ARE
PLACED
IN
THE
ORDER
FS
FS
N
THEN
THE
EXPECTED
ACCESS
TIME
IS
N
I
PS
I
J
DON
T
LET
THIS
FORMULA
THROW
YOU
THE
TERM
PS
I
I
J
IS
THE
PROBABILITY
THAT
YOU
ACCESS
THE
ITH
FILE
TIMES
THE
LENGTH
OF
THE
FIRST
I
FILES
FOR
EACH
OF
THE
BELOW
ALGORITHMS
EITHER
GIVE
A
PROOF
THAT
THE
ALGORITHM
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
OR
A
PROOF
THAT
THE
ALGORITHM
IS
INCORRECT
ORDER
THE
FILES
FROM
SHORTEST
TO
LONGEST
ON
THE
TAPE
THAT
IS
I
J
IMPLIES
THAT
I
J
ORDER
THE
FILES
FROM
MOST
LIKELY
TO
BE
ACCESSED
TO
LEAST
LIKELY
TO
BE
ACCESSED
THAT
IS
PI
PJ
IMPLIES
THAT
I
J
ORDER
THE
THE
FILES
FROM
SMALLEST
RATIO
OF
LENGTH
OVER
ACCESS
PROBABILITY
TO
LARGEST
RATIO
OF
LENGTH
OVER
ACCESS
PROBABILITY
THAT
IS
I
J
IMPLIES
THAT
I
J
PI
PJ
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
CONSISTS
OF
N
SKIERS
WITH
HEIGHTS
PN
AND
N
SKIES
WITH
HEIGHTS
SN
THE
PROBLEM
IS
TO
ASSIGN
EACH
SKIER
A
SKI
TO
TO
MINIMIZE
THE
AVERAGE
DIFFERENCE
BETWEEN
THE
HEIGHT
OF
A
SKIER
AND
HIS
HER
ASSIGNED
SKI
THAT
IS
IF
THE
ITH
SKIER
IS
GIVEN
THE

I
TH
SKI
THEN
YOU
WANT
TO
MINIMIZE
N
PI
N
I
S
I
CONSIDER
THE
FOLLOWING
GREEDY
ALGORITHM
FIND
THE
SKIER
AND
SKI
WHOSE
HEIGHT
DIFFERENCE
IS
MINI
MIZED
ASSIGN
THIS
SKIER
THIS
SKI
REPEAT
THE
PROCESS
UNTIL
EVERY
SKIER
HAS
A
SKI
PROVE
OF
DISPROVE
THAT
THIS
ALGORITHM
IS
CORRECT
CONSIDER
THE
FOLLOWING
GREEDY
ALGORITHM
GIVE
THE
SHORTEST
SKIER
THE
SHORTEST
SKI
GIVE
THE
SECOND
SHORTEST
SKIER
THE
SECOND
SHORTEST
SKI
GIVE
THE
THIRD
SHORTEST
SKIER
THE
THIRD
SHORTEST
SKI
ETC
PROVE
OF
DISPROVE
THAT
THIS
ALGORITHM
IS
CORRECT
HINT
ONE
OF
THE
ABOVE
GREEDY
ALGORITHMS
IS
CORRECT
AND
ONE
IS
INCORRECT
FOR
THE
OTHER
THE
PROOF
OF
CORRECTNESS
MUST
BE
DONE
USING
AN
EXCHANGE
ARGUMENT
POINTS
WE
CONSIDER
THE
FOLLOWING
SCHEDULING
PROBLEM
INPUT
A
COLLECTION
OF
JOBS
JN
WHERE
THE
ITH
JOB
IS
A
TUPLE
RI
XI
OF
NON
NEGATIVE
INTEGERS
SPECIFYING
THE
RELEASE
TIME
AND
SIZE
OF
THE
JOB
OUTPUT
A
PREEMPTIVE
FEASIBLE
SCHEDULE
FOR
THESE
JOBS
ON
ONE
PROCESSOR
THAT
MINIMIZES
THE
TOTAL
COMPLETION
TIME
N
CI
A
SCHEDULE
SPECIFIES
FOR
EACH
UNIT
TIME
INTERVAL
THE
UNIQUE
JOB
THAT
THAT
IS
RUN
DURING
THAT
TIME
INTERVAL
IN
A
FEASIBLE
SCHEDULE
EVERY
JOB
JI
HAS
TO
BE
RUN
FOR
EXACTLY
XI
TIME
UNITS
AFTER
TIME
RI
THE
COMPLETION
TIME
CI
FOR
JOB
JI
IS
THE
EARLIEST
TIME
WHEN
JI
HAS
BEEN
RUN
FOR
XI
TIME
UNITS
EXAMPLES
OF
THESE
BASIC
DEFINITIONS
CAN
BE
FOUND
BELOW
WE
CONSIDER
TWO
GREEDY
ALGORITHMS
FOR
SOLVING
THIS
PROBLEM
THAT
SCHEDULE
TIMES
IN
AN
ONLINE
FASHION
THAT
IS
THE
ALGORITHMS
ARE
OF
THE
FOLLOWING
FORM
T
WHILE
THERE
ARE
JOBS
LEFT
NOT
COMPLETELY
SCHEDULED
AMONG
THOSE
JOBS
JI
SUCH
THAT
RI
T
AND
THAT
HAVE
PREVIOUSLY
BEEN
SCHEDULED
FOR
LESS
THAN
XI
TIME
UNITS
PICK
A
JOB
JM
TO
SCHEDULE
AT
TIME
T
ACCORDING
TO
SOME
RULE
INCREMENT
T
ONE
CAN
GET
DIFFERENT
GREEDY
ALGORITHMS
DEPENDING
ON
THE
RULE
FOR
SELECTING
JM
FOR
EACH
OF
THE
FOLLOWING
GREEDY
ALGORITHMS
PROVE
OR
DISPROVE
THAT
THE
ALGORITHM
IS
CORRECT
PROOFS
OF
CORRECTNESS
MUST
USE
AN
EXCHANGE
ARGUMENT
HINT
THE
MOST
OBVIOUS
EXCHANGE
ARGUMENT
DOES
NOT
WORK
IF
YOU
THINK
THAT
THE
FIRST
THING
THAT
YOU
TRIED
WORKED
YOU
MIGHT
WANT
TO
REEVALUATE
SJF
PICK
JM
TO
BE
THE
JOB
WITH
MINIMAL
SIZE
XI
TIES
MAY
BE
BROKEN
ARBITRARILY
SRPT
LET
YI
T
BE
THE
TOTAL
TIME
THAT
JOB
JI
HAS
BEEN
RUN
BEFORE
TIME
T
PICK
JM
TO
BE
A
JOB
THAT
HAS
MINIMAL
REMAINING
PROCESSING
TIME
THAT
IT
THAT
HAS
MINIMAL
XI
YI
T
TIES
MAY
BE
BROKEN
ARBITRARILY
AS
AN
EXAMPLE
OF
SJF
AND
SRPT
CONSIDER
THE
FOLLOWING
INSTANCE
AND
BOTH
SJF
AND
SRPT
SCHEDULE
JOB
BETWEEN
TIME
AND
TIME
AND
JOB
BETWEEN
TIME
AND
TIME
WHEN
JOB
COMPLETES
AND
JOB
AGAIN
BETWEEN
TIME
AND
TIME
AT
TIME
SJF
SCHEDULES
JOB
BECAUSE
ITS
ORIGINAL
SIZE
IS
LESS
THAN
JOB
ORIGINAL
SIZE
AT
TIME
SRPT
SCHEDULES
JOB
BECAUSE
ITS
REMAINING
PROCESSING
TIME
IS
LESS
THAN
JOB
REMAINING
PROCESSING
TIME
BOTH
SJF
AND
SRPT
SCHEDULE
JOB
BETWEEN
TIME
AND
WHEN
COMPLETES
AND
THEN
JOB
FROM
TIME
UNTIL
TIME
WHICH
JOB
COMPLETES
THUS
FOR
BOTH
SJF
AND
SRPT
ON
THIS
INSTANCE
AND
AND
THUS
BOTH
SJF
AND
SRPT
HAVE
TOTAL
COMPLETION
TIME
POINTS
WE
CONSIDER
THE
FOLLOWING
SCHEDULING
PROBLEM
INPUT
A
COLLECTION
OF
JOBS
JN
THE
SIZE
OF
JOB
JI
IS
XI
WHICH
IS
A
NONNEGATIVE
INTEGER
AN
INTEGER
M
OUTPUT
A
NONPREEMPTIVE
FEASIBLE
SCHEDULE
FOR
THESE
JOBS
ON
M
PROCESSOR
THAT
MINIMIZES
THE
TOTAL
COMPLETION
TIME
N
CI
A
SCHEDULE
SPECIFIES
FOR
EACH
UNIT
TIME
INTERVAL
AND
FOR
EACH
PROCESSOR
THE
UNIQUE
JOB
THAT
THAT
IS
RUN
DURING
THAT
TIME
INTERVAL
ON
THAT
PROCESSOR
IN
A
FEASIBLE
SCHEDULE
EVERY
JOB
JI
HAS
TO
BE
RUN
FOR
EXACTLY
XI
TIME
UNITS
AFTER
TIME
IN
A
NONPREEMPTIVE
SCHEDULE
ONCE
A
JOB
STARTS
RUNNING
ON
A
PARTICULAR
PROCESSOR
IT
HAS
TO
BE
RUN
TO
COMPLETION
ON
THAT
PARTICULAR
PROCESSOR
THE
COMPLETION
TIME
CI
FOR
JOB
JI
IS
THE
EARLIEST
TIME
WHEN
JI
HAS
BEEN
RUN
FOR
XI
TIME
UNITS
SO
FOR
EXAMPLE
IF
M
JOBS
OF
SIZE
ARE
RUN
IN
THAT
ORDER
ON
THE
FIRST
PROCESSOR
AND
JOBS
OF
SIZE
ARE
RUN
ON
THE
SECOND
PROCESSOR
IN
THAT
ORDER
THEN
THE
TOTAL
COMPLETION
TIME
WOULD
BE
GIVE
A
GREEDY
ALGORITHM
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
INPUT
POSITIVE
INTEGERS
RN
AND
CN
OUTPUT
AN
N
BY
N
MATRIX
A
WITH
ENTRIES
SUCH
THAT
FOR
ALL
I
THE
SUM
OF
THE
ITH
ROW
IN
A
IS
RI
AND
THE
SUM
OF
THE
ITH
COLUMN
IN
A
IS
CI
IF
SUCH
A
MATRIX
EXISTS
THINK
OF
THE
PROBLEM
THIS
WAY
YOU
WANT
TO
PUT
PAWNS
ON
AN
N
BY
N
CHESSBOARD
SO
THAT
THE
ITH
ROW
HAS
RI
PAWNS
AND
THE
ITH
COLUMN
HAS
CI
PAWNS
CONSIDER
THE
FOLLOWING
GREEDY
ALGORITHM
THAT
CONSTRUCTS
A
ROW
BY
ROW
ASSUME
THAT
THE
FIRST
I
ROWS
HAVE
BEEN
CONSTRUCTED
LET
AJ
BE
THE
NUMBER
OF
IN
THE
JTH
COLUMN
IN
THE
FIRST
I
ROWS
NOW
THE
RI
COLUMNS
WITH
WITH
MAXIMUM
CJ
AJ
ARE
ASSIGNED
IN
ROW
I
AND
THE
REST
OF
THE
COLUMNS
ARE
ASSIGNED
THAT
IS
THE
COLUMNS
THAT
STILL
NEEDS
THE
MOST
ARE
GIVEN
FORMALLY
PROVE
THAT
THIS
ALGORITHM
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
POINTS
WE
CONSIDER
TWO
PROBLEM
WHERE
THE
INPUT
CONTAINS
N
JOBS
WHERE
EACH
JOB
J
HAS
AN
INTEGER
RELEASE
TIME
RJ
AND
AN
INTEGER
DEADLINE
DJ
IN
A
FEASIBLE
SCHEDULE
EACH
JOB
J
MUST
BE
RUN
FOR
ONE
UNIT
OF
TIME
NOT
STARTING
BEFORE
RJ
AND
NOT
ENDING
AFTER
DJ
NOTE
THAT
NO
TWO
JOBS
MAY
BE
RUN
AT
THE
SAME
TIME
ASSUME
ALL
RELEASE
TIMES
ARE
NONNEGATIVE
AND
LET
T
MAXJ
DJ
IN
THE
WARMUP
PROBLEM
THE
INPUT
ALSO
SPECIFIES
FOR
EACH
INTEGER
T
T
WHETHER
A
PARTICULAR
MACHINE
IS
TURNED
ON
DURING
THE
TIME
INTERVAL
T
T
THE
PROBLEM
IS
TO
DETERMINE
IF
EACH
JOB
J
CAN
FEASIBLY
BE
RUN
FOR
ONE
UNIT
OF
TIME
WHEN
THE
MACHINE
IS
TURNED
ON
GIVE
A
GREEDY
ALGORITHM
AND
PROVE
THAT
IT
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
IN
THE
REAL
PROBLEM
THE
INPUT
ALSO
CONTAINS
A
POSITIVE
INTEGER
L
THE
PROBLEM
IS
TO
DETERMINE
THE
MINIMUM
NUMBER
K
OF
TIME
INTERVALS
OF
LENGTH
L
SUCH
ALL
JOBS
CAN
FEASIBLY
BE
RUN
FOR
ONE
UNIT
OF
TIME
DURING
ONE
OF
THESE
K
INTERVALS
ANOTHER
WAY
TO
INTERPRET
THIS
PROBLEM
IT
COSTS
A
DOLLAR
TO
TURN
THE
MACHINE
ON
ONCE
THE
MACHINE
IS
ON
IT
WILL
STAY
ON
FOR
L
UNITS
OF
TIME
THE
QUESTION
IS
TO
FIGURE
OUT
THE
LEAST
NUMBER
OF
TIMES
TO
TURN
THE
MACHINE
ON
SO
THAT
ONE
CAN
FINISH
ALL
THE
JOBS
WHICH
EACH
HAVE
TO
BE
RUN
FOR
ONE
UNIT
OF
TIME
GIVE
A
GREEDY
ALGORITHM
AND
PROVE
THAT
IT
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
POINTS
YOU
HAVE
N
HETEROSEXUAL
MEN
AND
N
HETEROSEXUAL
WOMEN
EACH
MAN
RANKS
THE
WOMEN
IN
ORDER
OF
PREFERENCE
EACH
WOMAN
RANKS
THE
MEN
IN
ORDER
OF
PREFERENCE
CONSIDER
THE
FOLLOWING
INCREDIBLY
STEREOTYPICAL
COURTING
ALGORITHM
ON
STAGE
I
EACH
MAN
GOES
TO
PITCH
WOO
ON
THE
PORCH
OF
THE
WOMAN
THAT
HE
PREFERS
MOST
AMONG
ALL
WOMEN
THAT
HAVE
NOT
REJECTED
HIM
YET
AT
THE
END
OF
THE
STAGE
THE
WOMAN
REJECTS
ALL
THE
MEN
ON
HER
PORCH
BUT
THE
ONE
THAT
SHE
FAVORS
MOST
NOTE
THAT
A
WOMEN
MAY
NOT
REJECT
A
MAN
IN
SOME
STAGE
BUT
LATER
END
UP
REJECTING
THAT
MAN
IF
A
BETTER
PROSPECT
ARRIVES
ON
HER
PORCH
IF
IT
SHOULD
EVER
HAPPEN
THAT
THERE
IS
EXACTLY
ONE
MAN
ON
EACH
PORCH
THE
ALGORITHM
TERMINATES
AND
EACH
WOMAN
MARRIES
THE
MAN
ON
HER
PORCH
YOU
MAY
BE
INTERESTED
TO
KNOW
THAT
MEDICAL
SCHOOLS
REALLY
USE
THIS
ALGORITHM
TO
FILL
INTERN
POSITIONS
GIVE
AN
UPPER
BOUND
AS
A
FUNCTION
OF
N
OF
THE
NUMBER
OF
STAGES
IN
THIS
ALGORITHM
A
MARRIAGE
ASSIGNMENT
IS
STABLE
IF
THERE
DOES
NOT
EXIST
A
MAN
X
AND
A
WOMAN
Y
SUCH
THAT
X
PREFERS
Y
TO
HIS
ASSIGNED
MATE
AND
Y
PREFERS
X
TO
HER
ASSIGNED
MATE
CLEARLY
ADULTERY
IS
A
RISK
IF
A
MARRIAGE
ASSIGNMENT
IS
NOT
STABLE
PROVE
THAT
THIS
ALGORITHM
LEADS
TO
A
STABLE
MARRIAGE
A
STABLE
MARRIAGE
M
IS
MAN
OPTIMAL
IF
FOR
EVERY
MAN
X
M
IS
THE
BEST
POSSIBLE
STABLE
MARRIAGE
THAT
IS
IN
EVERY
STABLE
MARRIAGE
OTHER
THAN
M
X
ENDS
UP
WITH
A
WOMAN
NO
MORE
PREFERABLE
TO
HIM
THAN
THE
WOMAN
HE
IS
MARRIED
TO
IN
M
PROVE
OR
DISPROVE
THE
ABOVE
ALGORITHM
PRODUCES
A
MAN
OPTIMAL
STABLE
MARRIAGE
A
STABLE
MARRIAGE
M
IS
WOMAN
OPTIMAL
IF
FOR
EVERY
WOMAN
Y
M
IS
THE
BEST
POSSIBLE
STABLE
MARRIAGE
THAT
IS
IN
EVERY
STABLE
MARRIAGE
OTHER
THAN
M
Y
ENDS
UP
WITH
A
MAN
NO
MORE
PREFERABLE
TO
HER
THAN
THE
MAN
SHE
IS
MARRIED
TO
IN
M
PROVE
OR
DISPROVE
THE
ABOVE
ALGORITHM
PRODUCES
A
WOMAN
OPTIMAL
STABLE
MARRIAGE
A
STABLE
MARRIAGE
M
IS
MAN
PESSIMAL
IF
FOR
EVERY
MAN
X
M
IS
THE
WORST
POSSIBLE
STABLE
MARRIAGE
THAT
IS
IN
EVERY
STABLE
MARRIAGE
OTHER
THAN
M
X
ENDS
UP
WITH
A
WOMAN
NO
LESS
PREFERABLE
TO
HER
THAT
THE
WOMAN
HE
IS
MARRIED
TO
IN
M
PROVE
OR
DISPROVE
THE
ABOVE
ALGORITHM
PRODUCES
A
MAN
PESSIMAL
STABLE
MARRIAGE
A
STABLE
MARRIAGE
M
IS
WOMAN
PESSIMAL
IF
FOR
EVERY
WOMAN
Y
M
IS
THE
WORST
POSSIBLE
STABLE
MARRIAGE
THAT
IS
IN
EVERY
STABLE
MARRIAGE
OTHER
THAN
M
Y
ENDS
UP
WITH
A
MAN
NO
LESS
PREFERABLE
TO
HER
LIST
THAN
THE
MAN
SHE
IS
MARRIED
TO
IN
M
PROVE
OR
DISPROVE
THE
ABOVE
ALGORITHM
PRODUCES
A
WOMAN
PESSIMAL
STABLE
MARRIAGE
POINTS
THE
SETTING
FOR
THIS
PROBLEM
IS
A
LINE
NETWORK
MODEL
BY
A
LINE
GRAPH
THERE
ARE
N
NODES
IN
THIS
GRAPH
AND
EACH
NODE
IS
CONNECTED
TO
A
LEFT
NEIGHBOR
AND
A
RIGHT
NEIGHBOR
EXCEPT
THE
LEFTMOST
NODE
HAS
NO
LEFT
NEIGHBOR
AND
THE
RIGHTMOST
NODE
HAS
NO
RIGHT
NEIGHBOR
THE
INPUT
CONSISTS
OF
K
PACKETS
WHERE
PACKET
P
CONSISTS
OF
AN
INTEGER
RELEASE
TIME
RP
WHEN
THE
PACKET
P
ARRIVES
IN
THE
SYSTEM
A
SOURCE
NODE
SP
AT
WHICH
THE
PACKET
P
ARRIVES
AND
A
DESTINATION
NODE
TP
WHICH
MUST
BE
TO
THE
RIGHT
OF
SP
TO
WHICH
THE
PACKET
P
MUST
REACH
BETWEEN
CONSECUTIVE
INTEGER
TIMES
ONE
PACKET
MAY
BE
FORWARDED
BETWEEN
EACH
PAIR
OF
ADJACENT
ROUTERS
ONCE
A
PACKET
P
REACHES
ITS
DESTINATION
TP
IT
LEAVES
THE
SYSTEM
WE
WANT
ALL
PACKETS
TO
REACH
THEIR
DESTINATIONS
FOR
EXAMPLE
IF
THE
INPUT
CONSISTED
OF
THE
FOLLOWING
TRIPLES
OF
THE
FORM
NAME
RP
SP
TP
A
B
C
THEN
ONE
WAY
TO
HAVE
EACH
PACKET
REACH
ITS
DESTINATION
IS
BETWEEN
TIME
AND
PACK
A
IS
FORWARDED
FROM
NODE
TO
NODE
AND
PACKET
B
IS
FORWARDED
FROM
NODE
TO
NODE
BETWEEN
TIME
AND
TIME
PACKET
A
IS
FORWARDED
FROM
NODE
TO
NODE
LEAVING
THE
SYSTEM
AT
TIME
AND
PACKET
B
IS
FORWARDED
FROM
NODE
TO
NODE
LEAVING
THE
SYSTEM
AT
TIME
WE
COULD
HAVE
FORWARD
PACKET
C
INSTEAD
OF
PACKET
A
BUT
IT
IS
NOT
POSSIBLE
TO
FORWARD
BOTH
AT
THIS
TIME
BETWEEN
TIME
AND
TIME
PACKET
C
IS
FORWARD
FROM
NODE
TO
NODE
LEAVING
THE
SYSTEM
AT
TIME
ASSUME
THAT
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
MAXIMUM
TIME
THAT
A
PACKET
LEAVES
THE
NETWORK
THAT
IS
WE
WANT
TO
CLEAR
THE
NETWORK
OF
PACKETS
AS
QUICKLY
AS
POSSIBLE
GIVE
A
GREEDY
ALGORITHM
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
ASSUME
THAT
N
SO
THAT
THE
NETWORK
CONSISTS
OF
TWO
NODES
AND
ONE
EDGE
FURTHER
ASSUME
THAT
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
MAXIMUM
WAITING
TIME
FOR
ANY
PACKET
THE
WAITING
TIME
FOR
A
PACKET
IS
DIFFERENCE
BETWEEN
THE
TIME
THAT
THE
PACKET
REACHES
ITS
DESTINATION
AND
THE
RELEASE
TIME
FOR
THAT
PACKET
THAT
IS
WE
WANT
THE
PACKET
THAT
WAITS
THE
LONGEST
TO
WAIT
AS
LITTLE
TIME
AS
POSSIBLE
GIVE
A
GREEDY
ALGORITHM
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
ASSUME
ALL
THE
RELEASE
TIMES
ARE
ZERO
FURTHER
ASSUME
THAT
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
SUM
OF
THE
WAITING
TIMES
OF
THE
PACKETS
THIS
IS
EQUIVALENT
TO
MINIMIZING
THE
AVERAGE
WAITING
TIMES
OF
THE
PACKETS
GIVE
A
GREEDY
ALGORITHM
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
THIS
PROBLEM
IS
QUITE
NONTRIVIAL
POINTS
CONSIDER
THE
FOLLOWING
BRIDGE
CROSSING
PROBLEM
WHERE
N
PEOPLE
WITH
SPEEDS
SN
WISH
TO
CROSS
THE
BRIDGE
AS
QUICKLY
AS
POSSIBLE
THE
RULES
REMAIN
IT
IS
NIGHTTIME
AND
YOU
ONLY
HAVE
ONE
FLASHLIGHT
A
MAXIMUM
OF
TWO
PEOPLE
CAN
CROSS
AT
ANY
ONE
TIME
ANY
PARTY
WHO
CROSSES
EITHER
OR
PEOPLE
MUST
HAVE
THE
FLASHLIGHT
WITH
THEM
THE
FLASHLIGHT
MUST
BE
WALKED
BACK
AND
FORTH
IT
CANNOT
BE
THROWN
ETC
A
PAIR
MUST
WALK
TOGETHER
AT
THE
RATE
OF
THE
SLOWER
PERSON
PACE
GIVE
AN
EFFICIENT
ALGORITHM
TO
FIND
THE
FASTEST
WAY
TO
GET
A
GROUP
OF
PEOPLE
ACROSS
THE
BRIDGE
YOU
MUST
HAVE
A
PROOF
OF
CORRECTNESS
FOR
YOUR
METHOD
POINTS
A
HETEROSEXUAL
COUPLE
IS
DIVORCING
AND
NEED
TO
PARTITION
N
INDIVIDUAL
GOODS
GN
EACH
OF
THE
HUSBAND
AND
WIFE
HAS
A
VALUATION
FOR
EACH
ITEM
BUT
YOU
DO
NOT
KNOW
THIS
VALUATION
HOWEVER
BASED
ON
THEIR
VALUATIONS
EACH
OF
THE
HUSBAND
AND
WIFE
DOES
PROVIDE
YOU
WITH
AN
ORDERED
LIST
SPECIFYING
THE
ORDER
THAT
THEY
VALUE
THE
ITEMS
YOUR
GOAL
IS
TO
DETERMINE
WHETHER
THE
LISTS
CONTAIN
ENOUGH
INFORMATION
TO
DETERMINE
WITH
A
CERTAINTY
THAT
IT
IS
POSSIBLE
TO
PARTITION
THE
GOODS
SO
THAT
EACH
OF
THE
HUSBAND
AND
WIFE
THINK
THAT
THE
TOTAL
VALUE
OF
THE
GOODS
THAT
THEY
RECEIVE
IS
MORE
THAN
HALF
OF
THE
TOTAL
VALUATION
OF
THE
GOODS
ACCORDING
TO
THEIR
EVALUATION
LET
US
CALL
THIS
A
FAIR
PARTITION
IF
SO
YOU
SHOULD
GIVE
A
FAIR
PARTITION
NOTE
THAT
THE
HUSBAND
AND
WIFE
MAY
VALUE
GOODS
VERY
DIFFERENTLY
SO
FOR
EXAMPLE
IF
THERE
WERE
GOODS
THE
HUSBAND
LIST
FROM
MOST
TO
LEAST
DESIRABLE
WAS
AND
THE
WIFE
LIST
WAS
THEN
AN
FAIR
PARTITION
IS
POSSIBLE
BY
GIVING
THE
HUSBAND
AND
AND
THE
WIFE
AND
IN
CONTRAST
IF
THERE
WERE
GOODS
THE
HUSBAND
LIST
FROM
MOST
TO
LEAST
DESIRABLE
WAS
AND
THE
WIFE
LIST
WAS
THEN
THERE
IS
NOT
ENOUGH
INFORMATION
TO
DETERMINE
WHETHER
A
FAIR
PARTITION
IS
POSSIBLE
GIVE
A
GREEDY
ALGORITHM
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
WE
CONSIDER
THE
FOLLOWING
PROBLEM
INPUT
A
COLLECTION
OF
JOBS
JN
WHERE
THE
ITH
JOB
IS
A
TUPLE
RI
XI
DI
OF
NON
NEGATIVE
INTEGERS
OUTPUT
IF
THERE
IS
A
PREEMPTIVE
FEASIBLE
SCHEDULE
FOR
THESE
JOBS
ON
ONE
PROCESSOR
AND
OTHERWISE
A
SCHEDULE
IS
FEASIBLE
IF
EVERY
JOB
JOB
JI
IS
RUN
FOR
XI
TIME
UNITS
BETWEEN
ITS
RELEASE
TIME
RI
AND
ITS
DEADLINE
DI
WE
CONSIDER
GREEDY
ALGORITHMS
FOR
SOLVING
THIS
PROBLEM
THAT
SCHEDULE
TIMES
IN
AN
ONLINE
FASHION
THAT
IS
THE
ALGORITHMS
ARE
OF
THE
FOLLOWING
FORM
T
WHILE
THERE
ARE
JOBS
LEFT
NOT
COMPLETELY
SCHEDULED
PICK
A
JOB
JM
TO
SCHEDULE
AT
TIME
T
INCREMENT
T
ONE
CAN
GET
DIFFERENT
GREEDY
ALGORITHMS
DEPENDING
ON
HOW
JOB
JM
IS
SELECTED
FOR
EACH
OF
THE
FOLLOW
ING
METHODS
OF
SELECTING
JM
PROVE
OR
DISPROVE
THE
THAT
RESULTING
GREEDY
ALGORITHMS
PRODUCE
FEASIBLE
SCHEDULES
IF
THEY
EXIST
FOR
THE
JOBS
BEING
CONSIDERED
YOUR
PROOF
OF
CORRECTNESS
MUST
USE
AN
EXCHANGE
ARGUMENT
AMONG
THOSE
JOBS
JI
SUCH
THAT
RI
T
AND
THAT
HAVE
NOT
BEEN
SCHEDULED
FOR
ENOUGH
TIME
UNITS
PICK
JM
TO
BE
THE
JOB
I
WHOSE
SIZE
XI
IS
SMALLEST
TIES
MAY
BE
BROKEN
ARBITRARILY
AMONG
THOSE
JOBS
JI
SUCH
THAT
RI
T
AND
THAT
HAVE
NOT
BEEN
SCHEDULED
FOR
ENOUGH
TIME
UNITS
PICK
JM
TO
BE
THE
JOB
I
WHOSE
REMAINING
SIZE
XI
T
IS
SMALLEST
TIES
MAY
BE
BROKEN
ARBITRARILY
THE
REMAINING
SIZE
XI
T
OF
A
JOB
I
AT
A
TIME
T
IS
THE
SIZE
XI
MINUS
THE
AMOUNT
OF
TIME
THAT
JOB
I
HAS
BEEN
RUN
BEFORE
TIME
T
SO
IF
A
JOB
HAD
SIZE
AND
WAS
RUN
FOR
UNITS
OF
TIME
BEFORE
T
ITS
REMAINING
SIZE
WOULD
BE
AMONG
THOSE
JOBS
SUCH
THAT
RI
T
AND
THAT
HAVE
NOT
BEEN
SCHEDULED
FOR
ENOUGH
TIME
UNITS
PICK
JM
TO
BE
THE
JOB
I
WHOSE
LAXITY
I
T
IS
THE
SMALLEST
TIES
MAY
BE
BROKEN
ARBITRARILY
THE
LAXITY
OF
A
JOB
I
AT
TIME
T
IS
DI
T
XI
T
THAT
IS
THE
DEADLINE
MINUS
THE
CURRENT
TIME
MINUS
THE
REMAINING
SIZE
PROBLEM
THIS
ALGORITHM
DOES
NOT
SOLVE
THE
PROBLEM
OF
FINDING
A
MAXI
MUM
CARDINALITY
SET
OF
NON
OVERLAPPING
INTERVALS
CONSIDER
THE
FOLLOWING
INTERVALS
E
A
B
C
D
OBVIOUSLY
THE
OPTIMAL
SOLUTION
IS
A
B
C
D
HOWEVER
THE
INTERVAL
THAT
OVERLAPS
WITH
THE
FEWEST
OTHERS
IS
E
AND
THE
ALGORITHM
WILL
SELECT
E
FIRST
WHICH
PRECLUDES
IT
FROM
PICKING
INTERVALS
B
AND
C
PROBLEM
THIS
ALGORITHM
DOES
NOT
SOLVE
THE
INTERVAL
COLORING
PROBLEM
CON
SIDER
THE
FOLLOWING
INTERVALS
A
B
C
D
E
F
G
THE
OPTIMAL
SOLUTION
IS
TO
PUT
A
IN
ONE
ROOM
B
C
D
IN
ANOTHER
AND
E
F
G
IN
ANOTHER
FOR
A
TOTAL
OF
ROOMS
HOWEVER
MAX
IMIZING
THE
NUMBER
OF
CLASSES
IN
THE
FIRST
ROOM
RESULTS
IN
HAVING
B
C
F
G
IN
ONE
ROOM
AND
CLASSES
A
D
AND
G
EACH
IN
THEIR
OWN
ROOMS
FOR
A
TOTAL
OF
THIS
ALGORITHM
DOES
SOLVE
THE
INTERVAL
COLORING
PROBLEM
NOTE
THAT
IF
THE
GREEDY
ALGORITHM
CREATES
A
NEW
ROOM
FOR
THE
CURRENT
CLASS
CI
THEN
BECAUSE
IT
EXAMINES
CLASSES
IN
ORDER
OF
START
TIMES
CI
START
POINT
MUST
INTERSECT
WITH
THE
LAST
CLASS
IN
ALL
OF
THE
CURRENT
ROOMS
THUS
WHEN
GREEDY
CREATES
THE
LAST
ROOM
N
IT
IS
BECAUSE
THE
START
TIME
OF
THE
CURRENT
CLASS
INTERSECTS
WITH
N
OTHER
CLASSES
BUT
WE
KNOW
THAT
FOR
ANY
SINGLE
POINT
IN
ANY
CLASS
IT
CAN
ONLY
INTERSECT
WITH
AT
MOST
OTHER
CLASS
IT
MUST
BE
THEN
THAT
N
AS
IS
A
LOWER
BOUND
ON
THE
TOTAL
NUMBER
NEEDED
AND
GREEDY
IS
FEASIBLE
IT
IS
THUS
ALSO
OPTIMAL
PROBLEM
THE
GREEDY
ALGORITHM
IS
NOT
OPTIMAL
FOR
THE
PROBLEM
OF
MAKING
CHANGE
WITH
THE
MINIMUM
NUMBER
OF
COINS
WHEN
THE
DENOMINATIONS
ARE
AND
IN
ORDER
TO
MAKE
SHILLINGS
THE
GREEDY
ALGORITHM
WOULD
USE
THREE
COINS
OF
AND
SHILLINGS
THE
OPTI
MAL
SOLUTION
IS
TO
USE
TWO
SHILLING
COINS
THE
GREEDY
ALGORITHM
IS
OPTIMAL
FOR
THE
PROBLEM
OF
MAKING
CHANGE
WITH
THE
MINIMUM
NUMBER
OF
COINS
WHEN
THE
DENOMINATIONS
ARE
SUC
CESSIVE
POWERS
OF
SOME
INTEGER
P
WE
PROVE
THIS
BY
CONTRADICTION
ASSUME
THERE
IS
SOME
INTEGER
D
SUCH
THAT
THE
GREEDY
ALGORITHM
IS
NOT
OPTIMAL
FOR
THE
SET
OF
DENOMINATIONS
DM
WHEN
MAK
ING
CHANGE
FOR
X
FOR
I
N
LET
GI
DENOTE
THE
NUMBER
OF
COINS
OF
DENOMINATION
DI
PICKED
BY
THE
GREEDY
ALGORITHM
AND
LET
TI
DENOTE
THE
NUMBER
OF
DENOMINATION
DI
PICKED
IN
AN
OPTIMAL
SOLUTION
WE
HAVE
N
N
GIDI
TIDI
X
I
I
STARTING
FROM
N
LET
K
BE
THE
FIRST
INDEX
FOR
WHICH
GK
TK
THE
GREEDY
ALGORITHM
TAKES
AS
MANY
COINS
WORTH
DK
AS
IT
CAN
SO
IT
MUST
BE
TRUE
THAT
GK
TK
FURTHERMORE
SINCE
BOTH
SOLUTIONS
HAVE
THE
SAME
TOTAL
VALUE
X
THE
TOTAL
VALUE
OF
TK
TK
MUST
MAKE
UP
FOR
THE
LOST
VALUE
OF
AT
LEAST
ONE
DK
THIS
CAN
NEVER
HAPPEN
NOTE
THAT
K
K
K
TIDI
D
DI
DI
DI
DK
DK
I
I
I
THIS
SAYS
THAT
IF
TMDM
X
THEN
ONE
OF
THE
TI
FOR
I
K
MUST
BE
GREATER
THAN
D
HOWEVER
IF
THERE
ARE
EVER
MORE
THAN
D
OF
ANY
DENOMINATION
OF
COIN
EXCEPT
THE
LARGEST
THAN
D
OF
THOSE
COINS
CAN
BE
REPLACED
BY
ONE
COIN
OF
THE
NEXT
LARGEST
DENOMINATION
THIS
CONTRADICTS
OUR
ASSUMPTION
THAT
THE
T
FORM
AN
OPTIMAL
SOLUTION
SINCE
IF
ANY
TI
DIFFERS
FROM
GI
THEN
THERE
MUST
BE
AT
LEAST
D
COINS
OF
SOME
SMALLER
DENOMINATION
AMONG
THE
TI
PROBLEM
THIS
GREEDY
ALGORITHM
IS
OPTIMAL
WE
PROVE
BY
CONTRADICTION
AS
SUME
GREEDY
IS
NOT
OPTIMAL
FOR
INPUT
I
WE
PICK
THE
OPTIMAL
SOLUTION
OP
T
THAT
IS
IDENTICAL
TO
GREEDY
FOR
THE
MOST
CONSECTUTIVE
GAS
STA
TIONS
CONSIDER
THE
FIRST
GAS
STATION
WHERE
THE
GREEDY
SOLUTION
G
AND
OP
T
DIFFER
CALL
IT
STATION
K
SAY
G
ADDS
GK
GAS
AND
OP
T
ADDS
OK
GAS
WE
NOW
CREATE
A
NEW
SOLUTION
OP
T
AS
FOLLOWS
OP
T
IS
IDEN
TICAL
TO
OP
T
AT
EVERY
STATION
EXCEPT
K
AND
K
CALL
THE
AMOUNT
OF
GAS
OP
T
ADDS
AT
STATION
K
OK
AT
STATION
K
OP
T
ONLY
ADDS
GK
GAS
TO
THE
TANK
AND
AT
STATION
K
OP
T
ADDS
OK
OK
GK
CLEARLY
OP
T
IS
IDENTICAL
TO
G
FOR
ONE
MORE
STATION
NAMELY
K
WE
CLAIM
THAT
OP
T
IS
FEASIBLE
AND
SPENDS
NO
MORE
TIME
FILLING
THE
TANK
THAN
OP
T
PRIOR
TO
STATION
K
OP
T
IS
IDENTICAL
TO
G
THUS
BE
CAUSE
G
MAKES
IT
TO
K
OP
T
MUST
MAKE
IT
TO
K
BY
THE
FACT
THAT
GREEDY
ADDS
THE
MINIMAL
AMOUNT
OF
GAS
REQUIRED
TO
GET
FROM
K
TO
K
AND
G
AND
OP
T
DIFFER
AT
K
IT
MUST
BE
THAT
OK
GK
THUS
OK
OK
GK
MEANING
OP
T
ADDS
A
VALID
AMOUNT
OF
GAS
AT
K
FUTHER
BECAUSE
GK
OK
OK
GK
OK
OK
OP
T
HAS
THE
SAME
AMOUNT
OF
GAS
IN
THE
TANK
AS
OP
T
AFTER
FILING
UP
AT
K
NAMELY
OK
OK
GK
BECAUSE
OP
T
IS
IDENTICAL
TO
OP
T
AFTER
K
OP
T
NEVER
RUNS
OUT
OF
GAS
AFTER
K
FINALLY
BECAUSE
THE
TOTAL
GAS
PUT
IN
THE
TANK
BY
OP
T
OVER
K
AND
K
IS
GK
OK
OK
GK
OK
OK
OP
T
AND
OP
T
ADD
THE
SAME
AMOUNT
OF
GAS
IN
TOTAL
OVER
THE
TWO
STATIONS
IN
WHICH
THEY
DIF
FER
MAKING
THEIR
TOTAL
TIME
SPENT
FILLING
THE
SAME
THUS
WE
HAVE
AN
OPTIMAL
SOLUTION
THAT
IS
IDENTICAL
TO
GREEDY
FOR
ONE
MORE
STATION
A
CONTRADICTION
THIS
GREEDY
ALGORITHM
IS
NOT
OPTIMAL
WITHOUT
LOSS
OF
GENERALITY
WE
CAN
ASSUME
THE
CAR
STARTS
AT
A
WITH
AN
EMPTY
TANK
CONSIDER
THE
INPUT
OF
FUTHER
ASSUME
THAT
C
F
AND
R
ARE
SUCH
THAT
A
FULL
TANK
OF
GAS
TAKES
YOU
THE
GREEDY
ALGORITHM
WILL
FILL
THE
TANK
TWICE
BUT
FILLING
THE
TANK
ONLY
AT
THEN
ADDING
JUST
ENOUGH
AT
TO
GO
WILL
GIVE
A
LOWER
TOTAL
TIME
FILLING
UP
PROBLEM
THIS
ALGORITHM
IS
NOT
OPTIMAL
FOR
THE
PROBLEM
OF
COVERING
POINTS
WITH
UNIT
INTERVALS
LET
THE
POINTS
TO
BE
COVERED
BE
A
B
C
D
E
AND
F
THE
ALGORITHM
THAT
TRIES
TO
MAXIMIZE
THE
NUMBER
OF
POINTS
COVERED
BY
THE
FIRST
INTERVAL
WILL
COVER
B
C
D
E
WITH
THE
FIRST
INTERVAL
WHICH
FORCES
IT
TO
USE
AT
LEAST
INTERVALS
TOTAL
THE
POINTS
CAN
HOWEVER
BE
COVERED
WITH
TWO
INTERVALS
AND
THIS
ALGORITHM
IS
OPTIMAL
FOR
THE
PROBLEM
OF
COVERING
POINTS
WITH
UNIT
INTERVALS
ASSUME
THERE
IS
A
SET
OF
POINTS
A
AN
SUCH
THAT
THE
SOLUTION
OBTAINED
BY
THE
GREEDY
ALGORITHM
IS
NOT
OPTIMAL
CALL
THE
GREEDY
SOLUTION
G
GN
AND
THE
OPTIMAL
SOLUTION
T
TN
ASSUME
THE
INTERVALS
ARE
NUMBERED
IN
INCREASING
ORDER
OF
LEFT
ENDPOINT
STARTING
AT
THE
LEFTMOST
INTERVAL
IN
G
COMPARE
G
AND
T
LET
K
BE
THE
NUMBER
OF
THE
FIRST
INTERVAL
FOR
WHICH
GK
TK
BY
THE
DEFINITION
OF
THE
GREEDY
ALGORITHM
IT
MUST
BE
THE
CASE
THAT
GK
TK
MEANING
THAT
GK
BEGINS
FURTHER
TO
THE
RIGHT
THAN
TK
CREATE
SOLUTION
T
BY
REPLACING
INTERVAL
TK
WITH
GK
SINCE
FOR
I
K
GI
TI
SOLUTION
T
WILL
CONTINUE
TO
COVER
ALL
THE
POINTS
IN
A
IF
GK
OVERLAPS
ANY
OTHER
INTERVAL
TJ
IN
T
SHIFT
TJ
TO
THE
RIGHT
UNTIL
IT
NO
LONGER
OVERLAPS
GK
CONTINUE
SHIFTING
INTERVALS
IN
T
TO
THE
RIGHT
UNTIL
THERE
ARE
NO
MORE
OVERLAPS
NOTE
THAT
T
CONTINUES
TO
COVER
ALL
POINTS
IN
A
BY
REPEATING
THE
ABOVE
PROCESS
WE
CAN
MAKE
T
G
CONTRADICTING
OUR
ASSUMPTION
THAT
G
IS
NOT
AN
OPTIMAL
SOLUTION
PROBLEM
THIS
ALGORITHM
IS
INCORRECT
FOR
THE
PROBLEM
OF
MINIMIZING
THE
AVERAGE
DIFFERENCE
BETWEEN
THE
HEIGHTS
OF
SKIERS
AND
THEIR
SKIS
LET
AND
THE
ALGORITHM
WOULD
PAIR
WITH
AND
WITH
FOR
A
TOTAL
COST
OF
PAIRING
WITH
AND
WITH
YIELDS
A
TOTAL
COST
OF
THE
ALGORITHM
IS
CORRECT
FOR
THE
PROBLEM
OF
MINIMIZING
THE
AVER
AGE
DIFFERENCE
BETWEEN
THE
HEIGHTS
OF
SKIERS
AND
THEIR
SKIS
THE
PROOF
IS
BY
CONTRADICTION
ASSUME
THE
PEOPLE
AND
SKIS
ARE
NUM
BERED
IN
INCREASING
ORDER
BY
HEIGHT
IF
THE
GREEDY
ALGORITHM
IS
NOT
OPTIMAL
THEN
THERE
IS
SOME
INPUT
PN
SN
FOR
WHICH
IT
DOES
NOT
PRODUCE
AN
OPTIMAL
SOLUTION
LET
THE
OPTIMAL
SOLUTION
BE
T
S
PN
S
N
AND
NOTE
THE
OUTPUT
OF
THE
GREEDY
ALGORITHM
WILL
BE
G
PN
SN
BEGINNING
WITH
COMPARE
T
AND
G
LET
PI
BE
THE
FIRST
PERSON
WHO
IS
ASSIGNED
DIFFER
ENT
SKIS
IN
G
THAN
IN
T
LET
SJ
BE
THE
PAIR
OF
SKIS
ASSIGNED
TO
PI
IN
T
CREATE
SOLUTION
T
BY
SWITCHING
THE
SKI
ASSIGNMENTS
OF
PI
AND
PK
WHERE
PK
IS
THE
PERSON
WHO
WAS
ASSIGNED
SI
IN
T
NOTE
THAT
BY
THE
DEFINITION
OF
THE
GREEDY
ALGORITHM
SI
SJ
ALSO
NOTE
THAT
BY
DEF
OF
PI
PI
PK
THE
TOTAL
COST
OF
T
IS
GIVEN
BY
COST
T
COST
T
P
N
I
SJ
PK
SI
PI
SI
PK
SJ
THERE
ARE
SIX
CASES
TO
BE
CONSIDERED
FOR
EACH
CASE
ONE
NEEDS
TO
SHOW
THAT
PI
SJ
PK
SI
PI
SI
PK
SJ
CASE
PI
PK
SI
SJ
PI
SJ
PK
SI
PI
SI
PK
SJ
SJ
PI
SI
PK
SI
PI
SJ
PK
CASE
PI
SI
PK
SJ
CASE
PI
SI
SJ
PK
CASE
SI
SJ
PI
PK
PI
SJ
PK
SI
PI
SI
PK
SJ
PI
SJ
PK
SI
PI
SI
PK
SJ
CASE
SI
PI
SJ
PK
CASE
SI
PI
PK
SJ
PROBLEM
THE
ALGORITHM
IS
CORRECT
FOR
THE
PROBLEM
OF
BUILDING
AN
N
N
MATRIX
WITH
ZEROS
AND
ONES
SUCH
THAT
THE
SUM
OF
ALL
ONES
IN
THE
ITH
ROW
IS
RI
AND
THE
SUM
OF
ALL
ONES
IN
THE
ITH
COLUMN
IS
CI
FOR
ALL
I
N
THE
PROOF
IS
BY
CONTRADICTION
ASSUME
THERE
IS
SOME
INPUT
RN
CN
FOR
WHICH
THE
GREEDY
ALGORITHM
DOES
NOT
GIVE
THE
CORRECT
SOLUTION
CALL
ANY
CORRECT
MATRIX
T
AND
THE
MATRIX
GENERATED
BY
THE
GREEDY
ALGORITHM
G
LET
I
AND
J
BE
TWO
NUMBERS
SUCH
THAT
GIJ
TIJ
LET
GIJ
THIS
IMPLIES
THAT
TIJ
BY
THE
DEFINITION
OF
THE
PROBLEM
THERE
MUST
BE
A
NUMBER
K
J
SUCH
THAT
GIK
AND
TIK
CREATE
MATRIX
T
BY
MAKING
TIJ
GIJ
T
IS
NOT
A
FEASIBLE
SOLUTION
COLUMN
J
HAS
TOO
MANY
ONES
AND
COLUMN
K
HAS
TOO
FEW
SINCE
THE
GREEDY
ALGORITHM
PLACED
A
IN
GIJ
AND
A
IN
GIK
IT
MUST
BE
TRUE
THAT
CJ
CK
THEREFORE
THE
NUMBER
OF
ONES
IN
COLUMN
K
OF
T
IS
AT
MOST
C
AND
THE
NUMBER
IN
COLUMN
J
IS
EXACTLY
CJ
THERE
MUST
BE
AT
LEAST
ONE
NUMBER
L
I
SUCH
THAT
GLJ
T
GLK
AND
T
CREATE
A
NEW
MATRIX
T
BY
MAKING
G
LJ
T
T
LK
LJ
LJ
AND
GLK
LK
COLUMNS
J
AND
K
NOW
HAVE
THE
CORRECT
NUMBER
OF
ONES
MATRIX
T
IS
NOW
A
FEASIBLE
SOLUTION
THAT
IS
CLOSER
TO
G
THAT
T
CONTRADICTION
THE
CASE
WHERE
GIJ
AND
TIJ
IS
NEARLY
IDENTICAL
PROBLEM
THE
FOLLOWING
GREEDY
ALGORITHM
SELECTS
THE
OPTIMAL
OUTPUT
FOR
ALL
INPUTS
AT
EACH
STEP
IN
THE
SEQUENCE
WHERE
A
PAGE
IN
FAST
MEMORY
NEEDS
TO
BE
REPLACED
BY
ONE
IN
SLOW
MEMORY
REPLACE
THE
PAGE
WHOSE
NEXT
USE
IS
AT
THE
LATEST
POINT
IN
THE
SEQUENCE
PROOF
LET
G
BE
THE
GREEDY
ALGORITHM
DESCRIBED
BY
THE
THEOREM
SUP
POSE
G
IS
NON
OPTIMAL
FOR
SOME
INPUT
SEQUENCE
LET
OPT
BE
THE
OPTIMAL
ALGORITHM
HAVING
THE
FEWEST
NUMBER
OF
SWAPS
THAT
AGREES
THE
MOST
WITH
G
LET
K
BE
THE
FIRST
SWAP
WHERE
OPT
AND
G
DISAGREE
ON
WHICH
PAGE
TO
SWAP
INTO
FAST
MEMORY
LET
LABEL
THE
PAGE
SWAPPED
OUT
OF
FAST
MEMORY
BY
G
AT
STEP
K
AS
A
THE
PAGE
SWAPPED
OUT
OF
FAST
MEMORY
BY
OPT
AS
B
AND
THE
PAGE
THAT
NEEDS
TO
BE
SWAPPED
IN
BY
BOTH
AS
C
WE
KNOW
THAT
BY
DEFINITION
OF
THE
GREEDY
ALGORITHM
B
WILL
APPEAR
SOONER
THAN
A
AFTER
STEP
K
LET
CALL
THE
STEP
WHERE
B
NEXT
OCCURS
STEP
I
AND
THE
STEP
WHERE
A
NEXT
OCCURS
STEP
J
WHERE
I
OCCURS
BEFORE
J
LET
CALL
THE
STEPS
BETWEEN
STEP
K
AND
STEP
I
REGION
X
AND
THE
STEPS
BETWEEN
STEP
K
AND
STEP
J
REGION
Y
WHERE
Y
INCLUDES
STEP
I
AND
REGION
X
IDEALLY
THERE
SHOULD
BE
A
PICTURE
ILLUSTRATING
THESE
DEFINITIONS
SUPPOSE
THAT
THERE
EXISTS
A
SOLUTION
OPT
THAT
IS
IDENTICAL
TO
OPT
EX
CEPT
FOR
AT
STEP
K
OPT
MAKES
THE
SAME
DECISION
AS
G
AND
SELECTS
A
TO
BE
REPLACED
IS
OPT
STILL
AN
OPTIMAL
SOLUTION
IN
ORDER
FOR
OPT
TO
BE
OPTIMAL
IT
MUST
HAVE
THE
SAME
NUMBER
OF
SWAPS
AS
OPT
MEANING
THAT
THE
CHANGE
OF
THE
DECISION
AT
K
DID
NOT
AFFECT
THE
NUMBER
OF
SWAPS
THAT
HAD
TO
OCCUR
FOR
THE
ALGORITHM
TO
BE
FEASIBLE
AFTER
STEP
K
THE
FAST
MEMORY
OF
OPT
CONTAINS
AT
LEAST
PAGES
A
AND
C
HAVING
SWAPPED
OUT
PAGE
B
WE
ASSUME
THE
PROBLEM
APPLIES
TO
FAST
MEM
ORIES
OF
SIZE
OR
GREATER
SINCE
A
PAGE
FAST
MEMORY
WOULD
ONLY
HAVE
ONE
FEASIBLE
SOLUTION
OF
SWAPPING
AT
EVERY
NON
REPEATED
PAGE
THIS
MEANS
THAT
OPT
MAKES
AT
LEAST
SWAP
BY
STEP
I
WHERE
B
NEEDS
TO
BE
SWAPPED
INTO
FAST
MEMORY
OPT
INSTEAD
MUST
SWAP
BY
STEP
J
WHERE
A
NEEDS
TO
BE
SWAPPED
INTO
FAST
MEMORY
IT
MUST
BE
THE
CASE
TO
MEET
REQUIREMENTS
FOR
OPTIMALITY
THAT
NO
EXTRA
SWAPS
WERE
INCURRED
BY
THE
DECISION
OF
OPT
TO
REPLACE
B
AT
STEP
K
AT
STEP
K
THE
FAST
MEMORIES
OF
OPT
AND
OPT
ARE
IDENTICAL
EXCEPT
FOR
THE
PAGE
WHICH
CONTAINS
EITHER
A
OR
B
WITH
THIS
INFORMATION
WE
MIGHT
TRY
TO
INFER
THAT
ANY
SWAPS
NOT
INVOLVING
B
THAT
OPT
NEEDS
TO
MAKE
IN
REGION
Y
WILL
HOLD
TRUE
FOR
OPT
AS
WELL
BUT
ALL
CASES
MUST
BE
CONSIDERED
THESE
CASES
MUST
CONCERN
PAGES
A
AND
B
FOR
THEY
ACCOUNT
FOR
THE
ONLY
DIFFERENCE
BETWEEN
THE
FAST
MEMORIES
OF
OPT
AND
OPT
CONSIDER
THE
FIRST
OF
SUCH
A
CASE
WHERE
OPT
AND
OPT
TAKE
DIFFERENT
ACTIONS
IN
REGION
X
THIS
COULD
ONLY
OCCUR
IF
SOME
PAGE
IN
THE
SEQUENCE
WITHIN
X
NOT
A
OR
B
CAUSED
THE
PAGE
A
OR
B
TO
BE
REPLACED
OTHERWISE
OPT
AND
OPT
WOULD
NOT
BE
TAKING
DIFFERENT
ACTIONS
THIS
ACTION
HOWEVER
WOULD
MAKE
THE
FAST
MEMORIES
OF
BOTH
SOLUTIONS
IDENTICAL
WITH
AN
EQUAL
NUMBER
OF
SWAPS
TAKEN
AND
ALLOW
OPT
TO
REMAIN
OPTIMAL
NOW
CONSIDER
A
SECOND
CASE
WHERE
BOTH
SOLUTIONS
AGREE
UP
TO
STEP
I
WHERE
OPT
MUST
PERFORM
A
SWAP
TO
PUT
B
IN
FAST
MEMORY
IF
OPT
REPLACES
A
THEN
OPT
AND
OPT
HAVE
THE
SAME
FAST
MEMORY
WITH
OPT
HAVING
MADE
EXTRA
SWAP
CONTRADICTING
THE
NOTION
THAT
IT
IS
INDEED
OPTIMAL
FOR
ALL
INPUTS
SO
LET
ASSUME
THAT
OPT
REPLACES
SOME
OTHER
PAGE
IN
FAST
MEMORY
THAT
WE
CALL
Z
WHICH
COULD
BE
ANYTHING
OTHER
THAN
A
OR
B
INCLUDING
C
OPT
IN
THIS
CASE
COULD
TAKE
THE
OPPORTUNITY
TO
ALSO
REPLACE
Z
AND
RETURN
A
TO
FAST
MEMORY
SHOWING
THAT
BOTH
SOLUTIONS
CAN
HAVE
THE
SAME
FAST
MEMORY
BY
STEP
I
WITH
THE
SAME
NUMBER
OF
SWAPS
FOLLOWING
STEP
I
THEN
OPT
AND
OPT
ARE
IDENTICAL
AND
OPT
IS
ONE
STEP
CLOSER
TO
G
THIS
HOWEVER
CONFLICTS
WITH
THE
PREMISE
THAT
OPT
WAS
THE
CLOSEST
SOLUTION
TO
G
AND
CAUSES
A
CONTRADICTION
IT
MAY
ALSO
BE
USEFUL
TO
CONSIDER
THE
CASE
THAT
THERE
IS
NO
STEP
AFTER
K
WHERE
A
OCCURS
IN
THE
SEQUENCE
IN
THIS
CASE
OPT
WOULD
NOT
HAVE
TO
MAKE
ANY
SWAP
AT
STEP
I
TO
EXACTLY
CONFORM
TO
THE
FAST
MEMORY
OF
OPT
STEP
J
DOES
NOT
EXIST
AND
A
DOES
NOT
NEED
TO
BE
IN
FAST
MEMORY
BUT
OPT
WOULD
NECESSARILY
HAVE
TO
MAKE
A
SWAP
AT
STEP
I
THIS
SUGGESTS
THAT
OPT
WOULD
BE
NON
OPTIMAL
FOR
ANY
CASE
WHERE
B
OCCURS
IN
THE
SEQUENCE
FOLLOWING
STEP
K
AND
A
DOES
NOT
THE
HALTING
PROBLEM
IS
INPUT
A
STRING
P
AND
A
STRING
I
WE
WILL
THINK
OF
P
AS
A
PROGRAM
OUTPUT
IF
P
HALTS
ON
I
AND
IF
P
GOES
INTO
AN
INFINITE
LOOP
ON
I
THEOREM
TURING
CIRCA
THERE
IS
NO
PROGRAM
TO
SOLVE
THE
HALTING
PROBLEM
PROOF
ASSUME
TO
REACH
A
CONTRADICTION
THAT
THERE
EXISTS
A
PROGRAM
HALT
P
I
THAT
SOLVES
THE
HALTING
PROBLEM
HALT
P
I
RETURNS
TRUE
IF
AND
ONLY
P
HALTS
ON
I
THE
GIVEN
THIS
PROGRAM
FOR
THE
HALTING
PROBLEM
WE
COULD
CONSTRUCT
THE
FOLLOWING
STRING
CODE
Z
PROGRAM
STRING
X
IF
HALT
X
X
THEN
LOOP
FOREVER
ELSE
HALT
END
CONSIDER
WHAT
HAPPENS
WHEN
THE
PROGRAM
Z
IS
RUN
WITH
INPUT
Z
CASE
PROGRAM
Z
HALTS
ON
INPUT
Z
HENCE
BY
THE
CORRECTNESS
OF
THE
HALT
PROGRAM
HALT
RETURNS
TRUE
ON
INPUT
Z
Z
HENCE
PROGRAM
Z
LOOPS
FOREVER
ON
INPUT
Z
CONTRADICTION
CASE
PROGRAM
Z
LOOPS
FOREVER
ON
INPUT
Z
HENCE
BY
THE
CORRECTNESS
OF
THE
HALT
PROGRAM
HALT
RETURNS
FALSE
ON
INPUT
Z
Z
HENCE
PROGRAM
Z
HALTS
ON
INPUT
Z
CONTRADICTION
END
PROOF
ONE
CAN
NOW
SHOW
THAT
THERE
IS
NO
PROGRAM
FOR
SOME
NEW
PROBLEM
PROBLEM
U
BY
SHOWING
THAT
HALTING
U
I
E
HALTING
IS
REDUCIBLE
TO
U
SUPPOSED
GOOGLE
AND
OR
MICROSOFT
INTERVIEW
QUESTIONS
A
YOU
ARE
GIVEN
IDENTICAL
LOOKING
BALLS
OF
THEM
WEIGH
EXACTLY
THE
SAME
AND
IS
HEAVIER
THAN
THE
REST
YOU
ARE
PROVIDED
WITH
A
SIMPLE
MECHANICAL
BALANCE
AND
YOU
ARE
RESTRICTED
TO
ONLY
USES
FIND
THE
HEAVIER
BALL
B
NOW
YOU
ARE
GIVE
IDENTICAL
LOOKING
BALLS
ONE
OF
THEM
IS
HEAVIER
OR
LIGHTER
YOU
DON
T
KNOW
WHICH
THAN
THE
REST
OF
THE
YOU
ARE
PROVIDED
WITH
A
SIMPLE
MECHANICAL
BALANCE
AND
YOU
ARE
RESTRICTED
TO
ONLY
USES
FIND
THE
ODD
BALL
AND
DETERMINE
WHETHER
IT
IS
HEAVIER
OR
LIGHTER
THAN
THE
REST
FOUR
PEOPLE
NEED
TO
CROSS
A
RICKETY
BRIDGE
AT
NIGHT
UNFORTUNATELY
THEY
HAVE
ONLY
ONE
TORCH
AND
THE
BRIDGE
IS
TOO
DANGEROUS
TO
CROSS
WITHOUT
ONE
THE
BRIDGE
IS
ONLY
STRONG
ENOUGH
TO
SUPPORT
TWO
PEOPLE
AT
A
TIME
NOT
ALL
PEOPLE
TAKE
THE
SAME
TIME
TO
CROSS
THE
BRIDGE
THE
TIMES
FOR
THE
FOUR
PEOPLE
ARE
MIN
MINS
MINS
AND
MINS
WHEN
TWO
PEOPLE
CROSS
TOGETHER
THE
TIME
TAKEN
IS
EQUAL
TO
THE
TIME
OF
THE
SLOWER
PERSON
WHAT
IS
THE
SHORTEST
TIME
NEEDED
FOR
ALL
FOUR
OF
THEM
TO
CROSS
THE
BRIDGE
IF
YOU
HAD
AN
INFINITE
SUPPLY
OF
WATER
A
QUART
AND
A
QUART
PAIL
HOW
WOULD
YOU
MEASURE
EXACTLY
QUARTS
YOU
ARE
ONLY
ALLOWED
TO
FULLY
FILL
A
PAIL
FROM
YOUR
SUPPLY
TRANSFER
FROM
ONE
PAIL
TO
ANOTHER
UNTIL
THE
RECEIVING
PAIL
IS
FULL
OR
EMPTY
A
PAIL
EACH
STEP
IS
CONSIDERED
AS
A
SINGLE
FILL
EMPTY
OR
TRANSFER
WHAT
IS
THE
LEAST
NUMBER
OF
STEPS
YOU
NEED
FIVE
PIRATES
DISCOVER
A
CHEST
CONTAINING
GOLD
COINS
THEY
DECIDE
TO
SIT
DOWN
AND
DEVISE
A
DISTRIBUTION
STRATEGY
THE
PIRATES
ARE
RANKED
BASED
ON
THEIR
EXPE
RIENCE
PIRATE
TO
PIRATE
WHERE
PIRATE
IS
THE
MOST
EXPERIENCED
THE
MOST
EXPERIENCED
PIRATE
GETS
TO
PROPOSE
A
PLAN
AND
THEN
ALL
THE
PIRATES
VOTE
ON
IT
IF
AT
LEAST
HALF
OF
THE
PIRATES
AGREE
ON
THE
PLAN
THE
GOLD
IS
SPLIT
ACCORDING
TO
THE
PROPOSAL
IF
NOT
THE
MOST
EXPERIENCED
PIRATE
IS
THROWN
OFF
THE
SHIP
AND
THIS
PRO
CESS
CONTINUES
WITH
THE
REMAINING
PIRATES
UNTIL
A
PROPOSAL
IS
ACCEPTED
THE
FIRST
PRIORITY
OF
THE
PIRATES
IS
TO
STAY
ALIVE
AND
THE
SECOND
IS
TO
MAXIMIZE
THE
GOLD
THEY
GET
PIRATE
DEVISES
A
PLAN
WHICH
HE
KNOWS
WILL
BE
ACCEPTED
FOR
SURE
AND
WILL
MAXIMIZE
HIS
GOLD
WHAT
IS
HIS
PLAN
PRISONERS
ARE
STUCK
IN
THE
PRISON
IN
SOLITARY
CELLS
THE
WARDEN
OF
THE
PRISON
GOT
BORED
ONE
DAY
AND
OFFERED
THEM
A
CHALLENGE
HE
WILL
PUT
ONE
PRISONER
PER
DAY
SELECTED
AT
RANDOM
A
PRISONER
CAN
BE
SELECTED
MORE
THAN
ONCE
INTO
A
SPECIAL
ROOM
WITH
A
LIGHT
BULB
AND
A
SWITCH
WHICH
CONTROLS
THE
BULB
NO
OTHER
PRISONERS
CAN
SEE
OR
CONTROL
THE
LIGHT
BULB
WHILE
NOT
IN
THE
ROOM
THE
PRISONER
IN
THE
SPECIAL
ROOM
CAN
EITHER
TURN
ON
THE
BULB
TURN
OFF
THE
BULB
OR
DO
NOTHING
ON
ANY
DAY
ANY
PRISONER
CAN
STOP
THIS
PROCESS
AND
SAY
EVERY
PRISONER
HAS
BEEN
IN
THE
SPECIAL
ROOM
AT
LEAST
ONCE
IF
THAT
HAPPENS
TO
BE
TRUE
ALL
THE
PRISONERS
WILL
BE
SET
FREE
IF
IT
IS
FALSE
THEN
ALL
THE
PRISONERS
WILL
BE
EXECUTED
THE
PRISONERS
ARE
GIVEN
SOME
TIME
TO
DISCUSS
AND
FIGURE
OUT
A
SOLUTION
ONCE
THEY
AGREE
ON
A
SOLUTION
AND
THE
RANDOM
CHOOSING
STARTS
THEY
ARE
NOT
ABLE
TO
COMMUNICATE
UNTIL
THEY
ARE
EITHER
RELEASED
OR
EXECUTED
IN
WHICH
CASE
THEY
WON
T
BE
ABLE
TO
COMMUNICATE
ANYWAY
HOW
DO
THEY
ENSURE
THEY
ALL
GO
FREE
YOU
HAVE
TWO
IDENTICAL
EGGS
STANDING
IN
FRONT
OF
A
FLOOR
BUILDING
YOU
WONDER
WHAT
IS
THE
MAXIMUM
NUMBER
OF
FLOORS
FROM
WHICH
THE
EGG
CAN
BE
DROPPED
WITHOUT
BREAKING
IT
WHAT
IS
THE
MINIMUM
NUMBER
OF
TRIES
NEEDED
TO
FIND
OUT
THE
SOLUTION
WHAT
IF
THE
BUILDING
HAS
N
FLOORS
A
CERTAIN
TOWN
IS
COMPRISED
OF
MARRIED
COUPLES
EVERYONE
IN
THE
TOWN
LIVES
BY
THE
FOLLOWING
RULE
IF
A
HUSBAND
CHEATS
ON
HIS
WIFE
THE
HUSBAND
IS
EXECUTED
AS
SOON
AS
HIS
WIFE
FINDS
OUT
ABOUT
HIM
ALL
THE
WOMEN
IN
THE
TOWN
ONLY
GOSSIP
ABOUT
THE
HUSBANDS
OF
OTHER
WOMEN
NO
WOMAN
EVER
TELLS
ANOTHER
WOMAN
IF
HER
HUSBAND
IS
CHEATING
ON
HER
SO
EVERY
WOMAN
IN
THE
TOWN
KNOWS
ABOUT
ALL
THE
CHEATING
HUSBANDS
IN
THE
TOWN
EXCEPT
HER
OWN
IT
CAN
ALSO
BE
ASSUMED
THAT
A
HUSBAND
REMAINS
SILENT
ABOUT
HIS
INFIDELITY
ONE
DAY
THE
MAYOR
OF
THE
TOWN
ANNOUNCES
TO
THE
WHOLE
TOWN
THAT
THERE
IS
AT
LEAST
CHEATING
HUSBAND
IN
THE
TOWN
WHAT
HAPPENS
GIVEN
AN
ARRAY
OF
NATURAL
NUMBERS
EFFICIENTLY
FIND
THE
LONGEST
CONTIGUOUS
INCREASING
SUBSEQUENCE
EFFICIENTLY
FIND
THE
LONGEST
INCREASING
SUBSEQUENCE
I
E
NUMBERS
NEED
NOT
BE
IMMEDIATELY
AFTER
EACH
OTHER
IN
THE
ARRAY
THERE
ARE
BASKETS
ONE
OF
THEM
HAS
APPLES
ONE
HAS
ORANGES
AND
THE
OTHER
HAS
MIXTURE
OF
APPLES
AND
ORANGES
THE
LABELS
ON
THEIR
BASKETS
ALWAYS
LIE
I
E
IF
THE
LABEL
SAYS
ORANGES
YOU
ARE
SURE
THAT
IT
DOESN
T
HAVE
ORANGES
ONLY
IT
COULD
BE
APPLES
ONLY
OR
IT
COULD
BE
A
MIXTURE
THE
TASK
IS
TO
PICK
ONE
BASKET
AND
PICK
ONLY
ONE
FRUIT
FROM
IT
AND
THEN
CORRECTLY
LABEL
ALL
THE
THREE
BASKETS
YOU
HAVE
TWO
JARS
RED
MARBLES
AND
BLUE
MARBLES
A
JAR
WILL
BE
PICKED
AT
RANDOM
AND
THEN
A
MARBLE
WILL
BE
PICKED
FROM
THE
JAR
PLACING
ALL
OF
THE
MARBLES
IN
THE
JARS
HOW
CAN
YOU
MAXIMIZE
THE
CHANCES
OF
A
RED
MARBLE
BEING
PICKED
WHAT
ARE
THE
EXACT
ODDS
OF
GETTING
A
RED
MARBLE
USING
YOUR
SCHEME
YOU
HAVE
JARS
OF
PILLS
EACH
PILL
WEIGHS
GRAMS
EXCEPT
FOR
CONTAMINATED
PILLS
CONTAINED
IN
ONE
JAR
WHERE
EACH
PILL
WEIGHS
GRAMS
GIVEN
A
SCALE
HOW
COULD
YOU
TELL
WHICH
JAR
HAD
THE
CONTAMINATED
PILLS
IN
JUST
ONE
MEASUREMENT
YOU
ARE
GIVEN
THREE
SORTED
ARRAYS
A
B
AND
C
OF
N
NUMBERS
EACH
FOR
ANY
TRIPLET
A
I
B
J
C
K
THE
DISTANCE
OF
THAT
TRIPLET
IS
DEFINED
AS
THE
MAXIMUM
VALUE
OF
THE
ABSOLUTE
DIFFERENCES
BETWEEN
ANY
OF
THE
THREE
VALUES
IN
OTHER
WORDS
THE
DISTANCE
OF
ANY
TRIPLET
IS
THE
MAXIMUM
OF
A
I
B
J
A
I
C
K
AND
B
J
C
K
FIND
THE
MINIMUM
DISTANCE
TRIPLET
IN
O
N
TIME
GIVEN
AN
ARRAY
T
N
WHICH
CONTAINS
NUMBERS
BETWEEN
AND
N
RETURN
THE
DUPLICATED
VALUE
ALSO
GIVEN
AN
ARRAY
OF
LENGTH
N
CONTAINING
INTEGERS
BETWEEN
AND
N
DETERMINE
IF
IT
CONTAINS
ANY
DUPLICATES
IS
THERE
AN
O
N
TIME
SOLUTION
THAT
USES
ONLY
O
EXTRA
SPACE
AND
DOES
NOT
DESTROY
THE
ORIGINAL
ARRAY
GIVEN
A
SINGLY
LINKED
LIST
DETERMINE
WHETHER
IT
CONTAINS
A
LOOP
OR
NOT
USING
ONLY
O
WORDS
OF
MEMORY
CS
PARALLEL
ALGORITHMS
HOMEWORK
PROBLEMS
POINTS
CONSIDER
THE
PROBLEM
OF
COMPUTING
THE
AND
OF
N
BITS
GIVE
AN
ALGORITHM
THAT
RUNS
IN
TIME
O
LOG
N
USING
N
PROCESSORS
ON
AN
EREW
PRAM
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
GIVE
AN
ALGORITHM
THAT
RUNS
IN
TIME
O
LOG
N
USING
N
LOG
N
PROCESSORS
ON
AN
EREW
PRAM
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
GIVE
AN
ALGORITHM
THAT
RUNS
IN
TIME
O
USING
N
PROCESSORS
ON
A
CRCW
COMMON
PRAM
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
POINTS
YOU
KNOW
THAT
LOTS
OF
FAMOUS
COMPUTER
SCIENTISTS
HAVE
TRIED
TO
FIND
A
FAST
EFFICIENT
PARALLEL
ALGORITHM
FOR
THE
FOLLOWING
BOOLEAN
FORMULA
VALUE
PROBLEM
INPUT
A
BOOLEAN
FORMULA
F
AND
A
TRUTH
ASSIGNMENT
A
OF
THE
VARIABLES
IN
F
OUTPUT
IF
A
MAKES
F
TRUE
AND
OTHERWISE
MOREOVER
MOST
COMPUTER
SCIENTISTS
BELIEVE
THAT
THERE
IS
NO
FAST
EFFICIENT
PARALLEL
ALGORITHM
FOR
THE
BOOLEAN
VALUE
PROBLEM
YOU
WANT
TO
FIND
A
FAST
EFFICIENT
PARALLEL
ALGORITHM
FOR
SOME
NEW
PROBLEM
N
AFTER
MUCH
EFFORT
YOU
CAN
NOT
FIND
A
FAST
EFFICIENT
PARALLEL
ALGORITHM
FOR
N
NOR
A
PROOF
THAT
N
DOES
NOT
HAVE
A
FAST
EFFICIENT
PARALLEL
ALGORITHM
HOW
COULD
YOU
GIVE
EVIDENCE
THAT
FINDING
A
FAST
EFFICIENT
PARALLEL
ALGORITHM
FOR
N
IS
AT
LEAST
A
HARD
OF
A
PROBLEM
AS
FINDING
A
FAST
EFFICIENT
PARALLEL
ALGORITHM
FOR
BOOLEAN
FORMULA
VALUE
PROBLEM
BE
AS
SPECIFIC
AS
POSSIBLE
AND
EXPLAIN
HOW
CONVINCING
THE
EVIDENCE
IS
NOTE
THAT
FAST
AND
EFFICIENT
MEANS
POLY
LOG
TIME
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
THE
TERM
POLY
LOG
MEANS
BOUNDED
BY
O
LOGK
N
FOR
SOME
CONSTANT
K
POINTS
CONSIDER
THE
PROBLEM
OF
TAKING
AS
INPUT
AN
INTEGER
N
AND
AN
INTEGER
X
AND
CREATING
AN
ARRAY
A
OF
N
INTEGERS
WHERE
EACH
ENTRY
OF
A
IS
EQUAL
TO
X
GIVE
AN
ALGORITHM
THAT
RUNS
IN
TIME
O
LOG
N
USING
N
PROCESSORS
ON
AN
EREW
PRAM
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
GIVE
AN
ALGORITHM
THAT
RUNS
IN
TIME
O
LOG
N
USING
N
LOG
N
PROCESSORS
ON
AN
EREW
PRAM
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
GIVE
AN
ALGORITHM
THAT
RUNS
IN
TIME
O
USING
N
PROCESSORS
ON
A
CRCW
COMMON
PRAM
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
POINTS
DESIGN
A
PARALLEL
ALGORITHM
FOR
THE
PARALLEL
PREFIX
PROBLEM
THAT
RUNS
IN
TIME
O
LOG
N
WITH
N
LOG
N
PROCESSORS
ON
A
EREW
PRAM
POINTS
GIVE
AN
ALGORITHM
THAT
GIVEN
AN
INTEGER
N
COMPUTES
N
THAT
IS
N
FACTORIAL
IN
TIME
O
LOG
N
ON
AN
EREW
PRAM
WITH
N
PROCESSORS
MAKE
THE
UNREALISTIC
ASSUMPTION
THAT
A
WORD
OF
MEMORY
CAN
STORE
ARBITRARILY
LARGE
INTEGERS
POINTS
WE
CONSIDER
THE
PROBLEM
OF
MULTIPLYING
TWO
N
BY
N
MATRICES
ASSUME
THAT
THE
SEQUENTIAL
TIME
ALGORITHM
THAT
YOU
WISH
TO
COMPARE
TO
HAS
TIME
COMPLEXITY
N
DESIGN
A
PARALLEL
ALGORITHM
THAT
RUNS
IN
TIME
N
ON
A
CREW
PRAM
WITH
PROCESSORS
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
DESIGN
A
PARALLEL
ALGORITHM
THAT
RUNS
IN
TIME
O
LOG
N
TIME
ON
A
CREW
PRAM
WITH
PROCESSORS
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
DESIGN
A
PARALLEL
ALGORITHM
THAT
RUNS
IN
TIME
O
LOG
N
TIME
ON
A
CREW
PRAM
WITH
LOG
N
PROCESSORS
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
DESIGN
A
PARALLEL
ALGORITHM
THAT
RUNS
IN
TIME
O
LOG
N
TIME
ON
A
EREW
PRAM
WITH
LOG
N
PROCESSORS
HINT
RECALL
PROBLEM
WHAT
IS
THE
EFFICIENCY
OF
THIS
ALGORITHM
USING
THE
FOLDING
PRINCIPLE
WHAT
UPPER
BOUND
WOULD
YOU
GET
ON
THE
RUNNING
TIME
FOR
THIS
ALGORITHM
ON
PROCESSORS
POINTS
DESIGN
A
PARALLEL
ALGORITHM
THAT
GIVEN
A
POLYNOMIAL
P
X
OF
DEGREE
N
AND
AN
INTEGER
K
COMPUTES
THE
VALUE
OF
P
K
YOU
ALGORITHM
SHOULD
RUN
IN
TIME
O
LOG
N
ON
A
EREW
PRAM
WITH
O
N
LOG
N
PROCESSORS
ASSUME
THAT
THE
POLYNOMIAL
IS
REPRESENTED
BY
ITS
COEFFICIENTS
FURTHER
ASSUME
THAT
ALL
NUMBERS
THAT
YOU
WILL
COMPUTE
WILL
FIT
WITHIN
A
WORD
OF
MEMORY
POINTS
WE
CONSIDER
THE
PROBLEM
OF
COMPUTING
FN
THE
NTH
FIBONACCI
NUMBER
GIVEN
AN
INTEGER
N
AS
INPUT
SHOW
HOW
TO
SOLVE
THIS
PROBLEM
IN
TIME
O
LOG
N
ON
A
EREW
PRAM
WITH
N
PROCESSORS
MAKE
THE
UNREALISTIC
ASSUMPTION
THAT
FN
WILL
FIT
WITHIN
ONE
WORD
OF
MEMORY
FOR
ALL
N
THAT
IS
ASSUME
THAT
ALL
ARITHMETIC
OPERATIONS
TAKE
CONSTANT
TIME
RECALL
THAT
FN
IS
DEFINED
BY
THE
FOLLOWING
RECURRENCE
AND
FN
FN
FN
FOR
N
HINT
NOTE
THAT
FOR
J
L
FJ
L
FJ
L
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
CHARACTER
STRING
C
OF
N
LETTERS
THE
PROBLEM
IS
TO
FIND
THE
LARGEST
K
SUCH
THAT
K
N
AND
SUCH
THAT
C
C
C
K
C
N
K
C
N
C
N
THAT
IS
K
IS
THE
LENGTH
OF
THE
LONGEST
PREFIX
THAT
IS
ALSO
A
SUFFIX
GIVE
A
EREW
PARALLEL
ALGORITHM
THAT
RUNS
IN
POLY
LOGARITHMIC
TIME
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
POINTS
THE
INPUT
TO
THIS
PROBLEM
IS
A
CHARACTER
STRING
C
OF
N
LETTERS
THE
PROBLEM
IS
TO
FIND
THE
LARGEST
K
SUCH
THAT
K
N
AND
SUCH
THAT
C
C
C
K
C
N
K
C
N
C
N
THAT
IS
K
IS
THE
LENGTH
OF
THE
LONGEST
PREFIX
THAT
IS
ALSO
A
SUFFIX
GIVE
A
CRCW
COMMON
PARALLEL
ALGORITHM
THAT
RUNS
IN
CONSTANT
TIME
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
POINTS
WE
CONSIDER
THE
PROBLEM
OF
ADDING
TWO
N
BIT
INTEGERS
GIVE
AN
ALGORITHM
THAT
RUNS
IN
O
LOG
N
TIME
ON
A
CREW
PRAM
WITH
N
PROCESSORS
NOTE
IF
YOUR
ALGORITHM
IS
EREW
YOU
MIGHT
WANT
TO
RETHINK
SINCE
I
DON
T
KNOW
HOW
TO
DO
THIS
EASILY
WITHOUT
CR
HINT
USE
DIVIDE
AND
CONQUER
AND
GENERALIZE
THE
INDUCTION
HYPOTHESIS
GIVE
AN
ALGORITHM
THAT
RUNS
IN
O
N
TIME
ON
AN
EREW
PRAM
WITH
N
PROCESSORS
POINTS
EXPLAIN
HOW
TO
MODIFY
THE
ALL
PAIRS
SHORTEST
PATH
ALGORITHM
FOR
A
CREW
PRAM
THAT
WAS
GIVEN
IN
CLASS
SO
THAT
IT
RUNS
IN
TIME
O
N
ON
A
EREW
PRAM
WITH
PROCESSORS
POINTS
EXPLAIN
HOW
TO
MODIFY
THE
ALL
PAIRS
SHORTEST
PATH
ALGORITHM
FOR
A
CREW
PRAM
THAT
WAS
GIVEN
IN
CLASS
SO
THAT
IT
ACTUALLY
RETURNS
THE
SHORTEST
PATHS
NOT
JUST
THEIR
LENGTHS
IN
TIME
O
N
ON
A
EREW
PRAM
WITH
PROCESSORS
POINTS
EXPLAIN
HOW
TO
SOLVE
THE
LONGEST
COMMON
SUBSEQUENCE
PROBLEM
IN
TIME
O
N
USING
AT
MOST
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
ON
A
CREW
PRAM
HINT
ONE
WAY
TO
DO
THIS
IS
TO
REDUCE
THE
LONGEST
COMMON
SUBSEQUENCE
PROBLEM
TO
A
SHORTEST
PATH
PROBLEM
NOTE
THAT
THE
SHORTEST
PATH
ALGORITHM
WORKS
FOR
ANY
GRAPH
FOR
WHICH
THERE
ARE
NOT
CYCLES
WHOSE
AGGREGATE
WEIGHT
IS
NEGATIVE
POINTS
GIVE
AN
ALGORITHM
FOR
THE
MINIMUM
EDIT
DISTANCE
PROBLEM
THAT
RUNS
IN
POLY
LOG
TIME
ON
A
CREW
PRAM
WITH
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
HERE
POLY
LOG
MEANS
O
LOGK
N
WHERE
N
IS
THE
INPUT
SIZE
AND
K
IS
SOME
CONSTANT
INDEPENDENT
OF
THE
INPUT
SIZE
RECALL
THAT
THE
INPUT
TO
THIS
PROBLEM
IS
A
PAIR
OF
STRINGS
A
AM
AND
B
BN
THE
GOAL
IS
TO
CONVERT
A
INTO
B
AS
CHEAPLY
AS
POSSIBLE
THE
RULES
ARE
AS
FOLLOWS
FOR
A
COST
OF
YOU
CAN
DELETE
ANY
LETTER
FOR
A
COST
OF
YOU
CAN
INSERT
A
LETTER
IN
ANY
POSITION
FOR
A
COST
OF
YOU
CAN
REPLACE
ANY
LETTER
BY
ANY
OTHER
LETTER
POINTS
DESIGN
A
PARALLEL
ALGORITHMS
THAT
MERGES
TWO
SORTED
ARRAYS
INTO
ONE
SORTED
ARRAY
IN
TIME
O
USING
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
ON
A
CRCW
COMMON
PRAM
POINTS
DESIGN
A
PARALLEL
ALGORITHM
THAT
FINDS
THE
MAXIMUM
NUMBER
IN
A
SEQUENCE
XN
OF
NOT
NECESSARILY
DISTINCT
INTEGERS
YOUR
ALGORITHM
SHOULD
RUN
IN
TIME
O
LOG
LOG
N
ON
A
CRCW
COMMON
PRAM
WITH
N
PROCESSORS
HINT
RECALL
THAT
YOU
CAN
FIND
THE
MAXIMUM
OF
K
NUMBERS
IN
O
TIME
WITH

PROCESSORS
TRY
DIVIDE
AND
CONQUER
INTO
N
SUBPROBLEMS
POINTS
DESIGN
A
PARALLEL
ALGORITHM
THAT
FINDS
THE
MAXIMUM
NUMBER
IN
A
SEQUENCE
XN
OF
NOT
NECESSARILY
DISTINCT
INTEGERS
IN
THE
RANGE
TO
N
YOUR
ALGORITHM
SHOULD
RUN
IN
CONSTANT
TIME
ON
A
CRCW
PRIORITY
PRAM
WITH
N
PROCESSORS
NOTE
THAT
IT
IS
IMPORTANT
HERE
THAT
THE
XI
HAVE
RESTRICTED
RANGE
IN
A
CRCW
PRIORITY
PRAM
EACH
PROCESSOR
HAS
A
UNIQUE
POSITIVE
INTEGER
IDENTIFIER
AND
IN
THE
CASE
OF
WRITE
CONFLICTS
THE
VALUE
WRITTEN
IS
THE
VALUE
THAT
THE
PROCESSOR
WITH
THE
LOWEST
IDENTIFIER
IS
TRYING
TO
WRITE
POINTS
DESIGN
A
PARALLEL
ALGORITHM
THAT
FINDS
THE
MAXIMUM
NUMBER
IN
A
SEQUENCE
XN
OF
NOT
NECESSARILY
DISTINCT
INTEGERS
IN
THE
RANGE
TO
N
YOUR
ALGORITHM
SHOULD
RUN
IN
CONSTANT
TIME
ON
A
CRCW
COMMMON
PRAM
WITH
N
PROCESSORS
NOTE
THAT
IT
IS
IMPORTANT
HERE
THAT
THE
XI
HAVE
RESTRICTED
RANGE
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
COMPOSE
INPUT
ARRAY
A
OF
SIZE
N
CONTAINING
POSITIVE
INTEGERS
ARRAY
B
OF
SIZE
N
CONTAINING
INTEGERS
IN
THE
RANGE
N
OUTPUT
AN
ARRAY
C
OF
SIZE
N
WHERE
EACH
ENTRY
C
I
A
B
I
FOR
EXAMPLE
IF
A
AND
B
THEN
THE
OUTPUT
WOULD
BE
C
GIVE
A
PARALLEL
ALGORITHM
THAT
RUNS
IN
TIME
O
N
ON
AN
EREW
PRAM
WITH
N
PROCESSORS
POINTS
GIVE
A
PARALLEL
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
THAT
RUNS
IN
TIME
O
LOG
N
ON
AN
EREW
PRAM
THE
INPUT
IS
A
BINARY
TREE
WITH
N
NODES
ASSUME
THAT
EACH
PROCESSOR
HAS
A
POINTER
TO
A
UNIQUE
NODE
IN
THE
TREE
THE
PROBLEM
IS
TO
NUMBER
THE
LEAFS
CONSECUTIVELY
FROM
LEFT
TO
RIGHT
THAT
IS
IN
ORDER
NOTE
THAT
THIS
ALGORITHM
IS
NEEDED
FOR
THE
ALGORITHM
IN
THE
NOTES
FOR
COMPUTING
ARITHMETIC
EXPRESSIONS
POINTS
GIVE
A
PARALLEL
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
THAT
RUNS
IN
TIME
O
LOG
N
ON
AN
EREW
PRAM
THE
INPUT
IS
A
BINARY
TREE
WITH
N
NODES
ASSUME
THAT
EACH
PROCESSOR
HAS
A
POINTER
TO
A
UNIQUE
NODE
IN
THE
TREE
THE
PROBLEM
IS
DETERMINE
THE
BALANCE
FACTOR
OF
EACH
NODE
IN
THE
TREE
THE
BALANCE
FACTOR
OF
A
NODE
IS
THE
HEIGHT
OF
ITS
LEFT
SUBTREE
MINUS
THE
HEIGHT
OF
ITS
RIGHT
SUBTREE
POINTS
DESIGN
A
PARALLEL
ALGORITHM
THAT
TAKES
A
BINARY
EXPRESSION
TREE
WHERE
THE
LEAVES
ARE
INTEGERS
AND
THE
INTERNAL
NODES
ARE
THE
FOUR
STANDARD
ARITHMETIC
OPERATORS
ADDITION
SUBTRACTION
MULTIPLICATION
AND
DIVISION
AND
COMPUTES
THE
VALUE
OF
THE
EXPRESSION
YOUR
ALGORITHM
SHOULD
RUN
IN
O
N
TIME
ON
A
CREW
PRAM
WITH
N
PROCESSORS
WHERE
N
IS
THE
NUMBER
OF
NODES
IN
THE
TREE
YOU
MAY
ASSUME
THAT
EACH
PROCESSOR
INITIALLY
HAS
A
POINTER
TO
A
UNIQUE
NODE
IN
THE
TREE
HINT
FOLLOWING
THE
TECHNIQUE
USED
FOR
SUBTRACTION
IN
THE
CLASS
NOTES
YOU
NEED
ONLY
FIND
A
COLLECTION
OF
FUNCTIONS
THAT
CONTAIN
THE
IDENTITY
FUNCTION
AND
CONSTANT
FUNCTIONS
AND
IS
CLOSED
UNDER
ADDITION
SUBTRACTION
MULTIPLICATION
DIVISION
WITH
CONSTANTS
AND
COMPOSITION
POINTS
DESIGN
A
PARALLEL
ALGORITHM
THAT
TAKES
A
BINARY
EXPRESSION
TREE
WHERE
THE
LEAVES
ARE
BOOLEAN
VALUES
OR
AND
THE
INTERNAL
NODES
ARE
THE
THREE
STANDARD
LOGICAL
OPERATIONS
NOT
OR
AND
AND
THE
OUTPUT
SHOULD
BE
THE
VALUE
OF
THE
EXPRESSION
REPRESENTED
BY
THE
TREE
YOUR
ALGORITHM
SHOULD
RUN
IN
O
N
TIME
ON
A
CREW
PRAM
WITH
N
PROCESSORS
WHERE
N
IS
THE
NUMBER
OF
NODES
IN
THE
TREE
YOU
MAY
ASSUME
THAT
EACH
PROCESSOR
INITIALLY
HAS
A
POINTER
TO
A
UNIQUE
NODE
IN
THE
TREE
POINTS
GIVE
A
PARALLEL
ALGORITHMS
FOR
THE
FOLLOWING
PROBLEM
THAT
RUNS
IN
TIME
O
LOG
N
ON
AN
EREW
PRAM
WITH
N
PROCESSORS
THE
INPUT
IS
A
FULLY
PARANTHESIZED
ARITHMETIC
EXPRESSION
WITH
N
SYMBOLS
STORED
IN
AN
N
ELEMENT
ARRAY
IN
THE
STANDARD
IN
ORDER
FASION
THE
OUTPUT
SHOULD
BE
AN
EXPRESSION
TREE
WITH
EACH
PROCESSOR
HAVING
A
POINTER
TO
A
UNIQUE
NODE
IN
THE
TREE
NO
HINT
THIS
IS
THE
ONE
PROBLEM
ASSIGNED
THIS
TERM
THAT
I
DON
T
KNOW
HOW
TO
DO
THIS
WAS
FROM
AN
OLD
TEXT
THAT
WE
USED
TO
USE
I
SEEM
TO
RECALL
THAT
THE
TEXT
SAID
THE
PROBLEM
WAS
EASY
BUT
I
WORKED
ON
IT
FOR
AT
LEAST
MINUTES
AND
COULDN
T
SOLVE
IT
SO
DECIDED
TO
ASSIGN
IT
AS
HOMEWORK
SEVERAL
YEARS
AGO
NO
ONE
HAS
SOLVED
IT
YET
A
O
LOG
N
ALGORITHM
FOR
FINDING
THE
LOGICAL
AND
OF
N
BITS
WITH
N
PRO
CESSORS
ON
AN
EREW
PRAM
SEE
SOLUTION
FOR
THE
NEXT
PROBLEM
OMIT
THE
STEP
WHERE
EACH
PROCES
SOR
SEQUENTIALLY
COMPUTES
THE
AND
OF
LOG
N
BITS
THE
EFFICIENCY
WITH
N
PROCESSORS
IS
E
N
N
N
N
LOG
N
LOG
N
O
LOG
N
ALGORITHM
FOR
FINDING
THE
LOGICAL
AND
OF
N
BITS
WITH
N
LOG
N
PROCESSORS
ON
AN
EREW
PRAM
EACH
PROCESSOR
PI
SEQUENTIALLY
COMPUTES
THE
AND
OF
LOG
N
BITS
AND
STORES
THEM
IN
N
LOG
N
VARIABLES
THE
AND
OF
THESE
N
LOG
N
RESULTS
ARE
COMPUTED
IN
PARALLEL
AS
FOLLOWS
EACH
PROCESSOR
PI
I
N
LOG
N
COMPUTES
RI
AND
RI
AND
STORES
THE
RESULT
IN
R
I
BY
REPEATEDLY
AND
ING
THE
RESULT
BITS
WE
HALVE
THE
NUMBER
OF
BITS
WITH
EACH
RECURSIVE
ACTIVATION
AFTER
LOG
N
LOG
N
AC
TIVATIONS
WE
OBTAIN
THE
RESULT
THE
TOTAL
TIME
IS
T
N
LOG
N
LOG
N
LOG
N

LOG
N
THE
BEST
SEQUENTIAL
ALGORITHM
IS
LINEAR
SO
E
N
N
LOG
N
N
N
LOG
N
LOGN
O
ALGORITHM
FOR
FINDING
THE
LOGICAL
AND
OF
N
BITS
WITH
N
PROCESSORS
ON
A
CRCW
PRAM
ASSUME
WE
HAVE
A
SHARED
VARIABLE
RESULT
WHICH
IS
INITIALIZED
TO
TRUE
ALGORITHM
FOR
EACH
PROCESSOR
PI
READ
NI
IF
NI
RESULT
FALSE
THIS
CLEARLY
TAKES
CONSTANT
TIME
SINCE
THE
BEST
KNOWN
SEQUENTIAL
ALGORITHM
IS
LINEAR
E
N
N
N
N
FIND
A
PARALLEL
ALGORITHM
A
TO
SOLVE
THE
BOOLEAN
FORMULA
VALUE
PROBLEM
THAT
A
LACKS
ONLY
CODE
FOR
PROBLEM
N
AND
B
RUNS
IN
POLY
LOG
TIME
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
THEN
IF
YOU
COULD
FIND
CODE
FOR
PROBLEM
N
THAT
RAN
IN
POLY
LOG
TIME
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
THIS
WOULD
THEN
IMMEDIATELY
GIVE
YOU
CODE
FOR
THE
BOOLEAN
FORMULA
VALUE
PROBLEM
THAT
RUNS
IN
POLY
LOG
TIME
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
SINCE
POLYNOMIAL
AND
POLY
LOG
FUNCTIONS
ARE
CLOSED
UNDER
ADDITION
MULTIPLICATION
AND
COMPOSITION
SO
FIND
GOOD
PARALLEL
CODE
FOR
N
IS
AT
LEAST
AS
HARD
AS
FINDING
GOOD
PARALLEL
CODE
FOR
THE
BOOLEAN
FORMULA
VALUE
PROBLEM
A
O
LOG
N
ALGORITHM
FOR
INDEXING
OF
AN
N
CELL
ARRAY
WITH
N
PROCESSORS
ON
AN
EREW
PRAM
SIMILAR
TO
THE
FOLLOWING
SOLUTION
EXCEPT
WE
HAVE
A
PROCESSOR
FOR
EACH
ARRAY
ENTRY
THE
EFFICIENCY
IS
E
N
N
N
N
LOG
N
LOG
N
O
LOG
N
ALGORITHM
FOR
INDEXING
OF
AN
N
CELL
ARRAY
WITH
N
LOG
N
PRO
CESSORS
ON
AN
EREW
PRAM
ASSUME
THAT
YOU
HAVE
A
PROCESSOR
PI
FOR
ARRAY
ENTRY
OF
AN
ARRAY
B
B
N
LOG
N
AT
STEP
B
IS
INITIALIZED
TO
X
AT
STEP
I
I
LOG
N
PI
WRITES
B
I
TO
LOCATIONS
B
AND
B
THEN
PI
COPIES
B
I
TO
LOCATIONS
A
I
LOG
N
TO
A
I
LOG
N
THE
BEST
KNOWN
ALGORITHM
TAKES
LINEAR
TIME
SO
E
N
N
LOG
N
N
N
LOG
N
LOG
N
HERE
IS
CRCW
CODE
FOR
FILLING
AN
ARRAY
CODE
FOR
PI
I
N
READ
X
A
I
X
HERE
IS
HOW
TO
SOLVE
THE
PARALLEL
PREFIX
PROBLEM
IN
LOG
N
TIME
WITH
N
LOG
N
PROCESSORS
ON
AN
EREW
MACHINE
EACH
PROCESSOR
PI
IS
GIVEN
A
CONTIGUOUS
LOG
N
SUBARRAY
X
I
LOG
N
XI
LOG
N
EACH
PI
COMPUTES
THE
SUM
SI
OF
ITS
LOG
N
SIZED
SUBARRAY
THIS
TAKES
LOG
N
TIME
THEN
EREW
PARALLEL
PREFIX
ALGORITHM
FROM
THE
NOTES
IS
THEN
APPLIED
ON
SN
LOG
N
NOTE
THAT
THE
NUMBER
OF
PROCESSORS
IS
EQUAL
TO
THE
SIZE
OF
THE
LIST
HENCE
IN
TIME
LOG
N
YOU
HAVE
THE
PARALLEL
PREFIXES
OF
THE
LIST
THEN
PI
CAN
CALCULATE
THE
I
LOG
N
J
TH
PREFIX
J
LOG
N
AS
THE
I
PREFIX
OF
THE
LIST
PLUS
X
I
LOG
N
X
I
LOG
N
J
SINCE
MULTIPLICATION
IS
ASSOCIATIVE
YOU
CAN
USE
THE
EREW
ALGORITHM
FROM
THE
NOTES
FOR
ASSOCIATIVE
OPERATORS
TO
SOLVE
THIS
PROBLEM
IN
O
LOG
N
TIME
WITH
N
LOG
N
PROCESSORS
ASSUME
THAT
WE
ARE
TRYING
TO
COMPUTE
THE
N
BY
N
MATRIX
C
THAT
IS
THE
PRODUCT
OF
N
BY
N
MATRICES
A
AND
B
COMPUTE
EACH
OF
THE
ENTRIES
IN
THE
RESULTANT
MATRIX
IN
LINEAR
TIME
USING
THE
STANDARD
FORMULA
CI
J
N
AI
KBK
J
USE
N
PROCESSORS
PER
ENTRY
CI
J
IN
CONSTANT
TIME
COMPUTE
THE
N
PRODUCTS
AI
KBK
J
K
N
THEN
IN
LOG
N
TIME
USING
THE
DI
VIDE
ALGORITHM
TO
EVALUATE
AN
ASSOCIATE
OPERATOR
COMPUTE
THE
SUM
N
K
AI
KBK
J
O
LOG
N
ALGORITHM
FOR
MULTIPLYING
TWO
N
N
MATRICES
WITH
LOG
N
PROCESSORS
ON
A
CREW
PRAM
ASSUME
THAT
WE
ARE
TRYING
TO
COMPUTE
AB
C
EACH
OF
THE
ENTRIES
OF
C
ARE
COMPUTED
IN
PARALLEL
USING
N
LOG
N
PROCESSORS
TO
COMPUTE
CI
J
EACH
PROCESSOR
COMPUTES
B
AI
KBK
J
FOR
A
SUB
RANGE
A
B
OF
N
OF
LENGTH
LOG
N
THESE
SUMS
ARE
THEN
ADDED
IN
TIME
LOG
N
USING
THE
TREE
ADDITION
ALGORITHM
ASSUMING
FALSELY
THAT
THE
BEST
KNOWN
ALGORITHM
RUNS
IN
TIME
O
THE
EFFICIENCY
IS
E
N
LOG
N
LOG
N
LOG
N
BEFORE
RUNNING
THE
ALGORITHM
IN
THE
PREVIOUS
SUBPROBLEM
USE
N
LOG
N
PROCESSORS
PER
ENTRY
IN
A
AND
B
TO
MAKE
N
COPIES
OF
EACH
OF
THESE
ENTRIES
IN
O
LOG
N
TIME
THEN
WHEN
EACH
REACH
TO
A
AND
B
IN
THE
AL
GORITHM
FROM
THE
PREVIOUS
SUBPROBLEM
CAN
REACH
A
DIFFERENT
MEMORY
LOCATION
A
LOG
N
TIME
ALGORITHM
FOR
EVALUATING
A
POLYNOMIAL
P
X
N
AIXI
WITH
N
LOG
N
PROCESSORS
ON
A
EREW
MACHINE
IN
TIME
O
LOG
N
FIND
K
KN
USING
PARALLEL
PREFIX
ALGORITHM
WE
CAN
MAKE
N
COPIES
OF
K
USING
PROBLEM
IN
CONSTANT
TIME
COMPUTE
K
AN
KN
IN
TIME
O
LOG
N
COMPUTE
P
K
N
AIKI
USING
TREE
ALGORITHM
NOTE
PLUS
IS
ASSOCIATIVE
BY
EXPANDING
THE
RECURRENCE
RELATION
FN
L
LN
L
FN
AS
MATRIX
MULTIPLICATION
OF
MATRICES
IS
ASSOCIATIVE
AND
TAKES
CONSTANT
TIME
ALL
OF
THE
FIBONACCI
NUMBERS
CAN
BE
COMPUTED
USING
PARALLEL
PREFIX
SOLUTION
COURTESY
OF
DANIEL
COLE
WE
GIVE
AN
EREW
ALGORITHM
FOR
FINDING
THE
LONGEST
PREFIX
THAT
IS
EQUAL
TO
A
SUFFIX
IN
POLY
LOG
TIME
USING
A
POLYNO
MIAL
NUMBER
OF
PROCESSORS
WE
LL
ASSUME
THAT
WE
HAVE
PROCESSORS
AND
WE
LL
RUN
IN
ABOUT
PHASES
NOTE
WE
DON
T
TRY
K
N
EACH
LETTER
IS
ASSIGNED
N
PROCESSORS
AND
WE
RUN
OUR
COPY
ALOGRITHM
FROM
PREVIOUS
HOMEWORKS
DOUBLE
THEN
NUMBER
OF
COPIED
ITEMS
AT
EACH
OF
THE
STEPS
TO
GET
N
COPIES
OF
EACH
ITEM
TIME
O
LOG
N
NOTE
THAT
THERE
ARE
N
POSSIBLE
ANSWERS
TO
THIS
PROBLEM
SO
WE
AS
SIGN
ONE
OF
THESE
POSSIBLE
K
VALUES
TO
EACH
OF
THE
N
COPIES
FURTHER
EACH
COPY
IS
ASSIGNED
A
SET
OF
N
PROCESSORS
FOR
EACH
SET
OF
PROCES
SORS
THEY
HAVE
SOME
K
VALUE
AND
EACH
PROCESSOR
PI
IN
THIS
SET
CHECKS
IF
C
I
IS
EQUAL
TO
C
N
K
I
FOR
I
K
SOME
PROCESSORS
DON
T
DO
ANYTHING
THIS
IS
CHECKING
IF
A
UNIQUE
CHARACTER
OF
THE
PREFIX
IS
EQUAL
TO
THE
CORRESPONDING
UNIQUE
CHARACTER
OF
THE
SUFFIX
BECAUSE
THRERE
IS
OVERLAP
HERE
WE
CAN
JUST
HAVE
THE
N
PROCESSORS
MAKE
A
COPY
OF
THE
INPUT
AND
THEN
WE
RE
FINE
BECAUSE
EACH
CHARACTER
CAN
ONLY
APPEAR
ONCE
IN
THE
PREFIX
AND
ONCE
IN
THE
SUFFIX
IN
ANY
CASE
EACH
PI
NOW
HAS
A
OR
BIT
BASED
ON
WHETHER
OR
NOT
THEIR
CHRACTER
MATCHED
NOTE
THAT
EACH
SET
OF
N
PROCESSORS
DOES
ALL
THIS
IN
CONSTANT
TIME
THUS
FOR
EACK
K
WE
NEED
ONLY
TO
KNOW
IF
ALL
THE
BITS
ARE
IF
SO
THEN
THE
PREFIX
AND
SUFFIX
MATCH
AND
THAT
K
IS
VALID
IF
NOT
THE
MAX
IN
THIS
PHASE
WE
RUN
OUR
ALGORITHM
FOR
ANDING
BITS
TOGETHER
THUS
EACH
GROUP
OF
N
PROCESSORS
EACH
WITH
A
UNIQUE
K
AND
THEIR
BITS
IN
THE
NAIVE
WAY
WHICH
TAKES
O
LOG
N
TIME
AND
AT
THE
END
WE
HAVE
A
OR
A
FOR
EACH
K
VALUE
THE
LAST
PHASE
IS
TO
FIND
THE
MAX
K
VALUE
WE
ONLY
NEED
N
PROCESSORS
HERE
AND
ASSUME
THAT
FOR
EACH
FOR
A
K
VALUE
IN
THE
LAST
PHASE
INSTEAD
WE
JUST
HAVE
K
AND
A
FOR
A
THUS
WE
ARE
SIMPLY
TRYING
TO
FIND
THE
MAX
VALUE
AGAIN
WE
JUST
DO
A
SIMPLE
NAIVE
PARALLLEL
MAX
FINDING
ALGORITHM
WHERE
EACH
PROCESSOR
PASSES
ON
THE
MAX
OF
IT
TWO
ASSIGNED
NUMBERS
AND
AT
THE
NEXT
LEVEL
THOSE
NUMBERS
ARE
USED
BY
HALF
THE
PROCESSORS
THIS
WILL
RUN
IN
O
LOG
N
TIME
WITH
N
PROCESSORS
AND
PRODUCE
THE
MAXIMUM
K
VALUE
FOR
THE
PROBLEM
AS
WE
CAN
SEE
EACH
PHASE
RAN
IN
O
LOG
N
TIME
ASSUMING
PROCESSORS
AND
HAVING
A
CONSTANT
NUMBER
OF
STEPS
OUR
TOTAL
TIME
IS
STILL
O
LOG
N
SOLUTION
COURTESY
OF
DANIEL
COLE
WE
GIVE
AN
CRCW
ALGORITHM
FOR
FIND
ING
THE
LONGEST
PREFIX
THAT
IS
EQUAL
TO
A
SUFFIX
IN
CONSTANT
TIME
USING
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
IN
THIS
PROBLEM
WE
JUST
MODIFY
THE
PRE
VIOUS
ALGORITHM
AGAIN
ASSUMING
PROCESSORS
NOTE
WE
DON
T
TRY
K
N
AS
PREVIOUSLY
FIRSTLY
WE
DO
NOT
NEED
THE
FIRST
PHASE
AS
WE
CAN
DO
CON
CURRENT
READ
THUS
IN
THE
SECOND
PHASE
WE
DO
THE
EXACT
SAME
THING
JUST
THAT
EVERY
GROUP
USES
THE
SAME
N
CHARACTERS
THIS
TAKES
CONSTANT
TIME
AND
AGAIN
WE
ARE
LEFT
WITH
N
BITS
FOR
EACH
GROUP
OF
N
PROCESSORS
AT
THIS
POINT
WE
CAN
RUN
OUR
CONSTANT
TIME
CRCW
AND
ALGORITHM
THAT
HAS
EACH
PROCESSOR
SIMPLY
WRITE
A
TO
THE
DESIRED
OUTPUT
AND
THEN
IF
A
PROCESSOR
BIT
IS
IT
WRITES
A
TO
THAT
OUTPUT
OTHERWISE
IT
DOES
NOTHING
THUS
THE
ANSWER
WILL
BE
IF
AND
ONLY
IF
NO
PROCESSOR
HAS
A
BIT
EACH
SET
OF
N
RUNS
THIS
ALGORITHM
IN
CONSTANT
TIME
AND
THUS
WE
HAVE
FOR
EACH
K
WHETHER
OR
NOT
IT
IS
FEASIBLE
NOW
WE
SIMPLY
NEED
TO
FIND
THE
MAXIMUM
K
AGAIN
HERE
WE
ASSUME
K
INSTEAD
OF
WHICH
IS
A
CONSTANT
TIME
UPDATE
NOW
TO
FIND
THE
MAX
K
WE
HAVE
N
PROCESSORS
ASSIGNED
TO
EACH
K
VALUE
AND
WITHIN
EACH
GROUP
A
PROCESSOR
WILL
FIRST
WRITE
A
K
TO
THE
COMMON
OUTPUT
AND
WILL
THEN
LOOK
AT
ITS
GROUP
K
AND
ONE
OTHER
K
UNIQUE
FOR
EACH
PROCESSOR
IN
A
PARTICULAR
K
GROUP
IF
ITS
K
IS
BIGGER
IT
WILL
DO
NOTHING
ELSE
IT
WILL
WRITE
A
TO
THE
COMMON
OUTPUT
FOR
THAT
K
GROUP
THUS
AT
THIS
STEP
EACH
K
THAT
WAS
WILL
STILL
BE
BUT
EACH
K
THAT
IS
NOT
WILL
HAVE
BEEN
COMPARED
TO
EVERY
OTHER
K
AND
IF
A
SINGLE
OTHER
K
WAS
LARGER
THEN
THIS
K
WILL
IN
EFFECT
BE
NOW
THUS
ONLY
ONE
K
WILL
HAVE
A
VALUE
AND
THE
REST
WILL
BE
THIS
STEP
TAKES
CONSTANT
TIME
AS
WE
ASSIGNED
EACH
K
VALUE
N
PROCESSORS
IN
THE
FINAL
PHASE
WE
WILL
SIMPLY
FIND
THE
K
VALUE
THAT
IS
NOT
AS
WE
HAVE
ESTABLISHED
THAT
ALL
OF
THEM
ARE
EXCEPT
THE
LARGEST
WHOSE
N
GROUP
OF
PROCESSORS
DID
NOT
FIND
ANY
K
LARGER
TO
DO
THIS
WE
ASSIGN
PROCESSOR
TO
EACH
OF
THESE
LOCATIONS
OF
POTENTIAL
MAXIMUM
K
VALUES
AND
EACH
PROCESSOR
FIRST
WRITES
A
TO
THE
COMMON
OUTPUT
AND
THEN
CHECKS
THEIR
K
IF
IT
IS
NOT
THEY
WRITE
IT
TO
THE
COMMON
OUT
PUT
THIS
WILL
ONLY
BE
TRUE
FOR
ONE
PROCESSOR
THUS
THE
COMMON
OUTPUT
WILL
CONTAIN
THE
LARGEST
K
THIS
STEP
WAS
DONE
IN
CONSTANT
TIME
AS
WELL
EACH
STEP
OF
OUR
PROCESS
EACH
N
GROUP
TESTS
A
K
VALUE
ANDING
RESULTS
IN
EACH
N
GROUP
CLEAR
ALL
K
EXCEPT
THE
MAX
AND
FIND
THE
NON
ZERO
K
LEFT
OVER
RUN
IN
CONSTANT
TIME
THUS
OUR
ALGORITHM
IS
A
CONSTANT
NUMBER
OF
STEPS
OF
CONSTANT
TIME
EACH
FOR
A
TOTAL
RUNTIME
THAT
IS
CONSTANT
ON
PROCESSORS
O
LOG
N
ALGORITHM
FOR
ADDING
TWO
N
BIT
INTEGERS
ON
AN
CREW
PRAM
GENERALIZE
THE
INDUCTIVE
HYPOTHESIS
TO
COMPUTE
THE
SUM
BOTH
ASSUMING
NO
CARRY
AND
ASSUMING
A
CARRY
OF
ASSUME
THAT
WE
WANT
TO
ADD
INTEGERS
A
AND
B
AND
A
AND
B
NOW
RECURSIVELY
SOLVE
THE
PROBLEMS
OF
ADDING
AND
AND
OF
ADDING
AND
DEPENDING
ON
WHETHER
OR
NOT
THERE
IS
A
CARRY
FROM
ADDING
AND
ONE
CAN
COMPUTE
THE
FINAL
SUM
IN
CONSTANT
TIME
ONCE
THE
NUMBER
OF
BITS
IS
LESS
THAN
LOG
N
WE
CAN
ADD
IN
LOG
TIME
WITH
ONE
PROCESSOR
THIS
RUNNING
TIME
IS
TIME
O
LOG
N
USING
N
LOG
N
PROCESSORS
WE
EXPLAIN
HOW
TO
CONVERT
THE
CREW
SHORTEST
PATH
ALGORITHM
INTO
AN
EREW
ALGORITHM
INITIALLY
MAKE
N
COPIES
OF
THE
N
N
MATRIX
HOLDING
THE
EDGE
DISTANCES
THIS
TAKES
O
LOG
N
TIME
WITH
PROCESSORS
SINCE
THE
DISTANCE
MATRIX
HAS
ENTRIES
AS
ONLY
N
PROCESSORS
READ
AN
EDGE
DISTANCE
IN
ANY
ONE
STEP
THIS
MEANS
THAT
CONCURRENT
READING
IS
NO
LONGER
NECESSARY
SO
WE
HAVE
AN
EREW
ALGORITHM
NOTE
THAT
WITHIN
EACH
ITERATION
OF
THE
LOG
N
ROUNDS
OF
DISTANCE
UPDATES
YOU
MUST
AGAIN
DO
THIS
O
LOG
N
TIME
COPYING
PROCEDURE
SO
THAT
NONE
OF
THE
DISTANCE
INFO
BEING
READ
FROM
THE
COPIES
OF
THE
DISTANCE
MATRIX
BECOMES
STALE
AND
NOTE
THAT
THE
ENTIRE
ALGORITHM
STILL
RUNS
IN
O
N
TIME
SOLUTION
COURTESY
OF
DANIEL
COLE
HERE
WE
EXPLAIN
HOW
TO
HAVE
THE
SHORT
EST
PATH
ALGORITHM
ACTUALLY
COMPUTE
THE
SHORTEST
PATHS
HERE
THE
IDEA
WILL
BE
TO
SAVE
A
BIT
OF
EXTRA
DATA
DURING
THE
MAIN
ALGORITHM
AND
THEN
REBUILD
ALL
THE
PATHS
AT
THE
END
IT
DOESN
T
SEEM
LIKE
WE
CAN
BUILD
THE
PATHS
AS
WE
GO
BECAUSE
ALTHOUGH
WE
KNOW
AFTER
EACH
ITERATION
THAT
WE
HAVE
COMPLETED
THE
SHORTESTS
PATHS
OF
LENGTH
UP
TO
IN
LENGTH
WE
DON
T
KNOW
WHICH
PATHS
THESE
ARE
NECESSARILY
THUS
WE
HAVE
TO
WAIT
UNTIL
THE
END
FOR
EXTRA
DATA
WE
WILL
KEEP
THE
MIDPOINT
USED
TO
CREATE
THE
SHORTEST
PATH
I
E
THE
COMMON
POINT
OF
THE
TWO
SHORTEST
PATHS
THAT
WE
USED
TO
CREATE
THE
NEW
SHORTEST
PATH
WE
WILL
ALSO
KEEP
NUMBER
OF
HOPS
IN
THE
PATH
WE
CAN
DO
BOTH
OF
THESE
ITEMS
IN
OUR
ORIGINAL
ALGORITHM
WITHOUT
ADDING
ANY
TIME
AS
THEY
TAKE
AN
ADDATIVE
CONSTANT
LONGER
THAN
JUST
KEEP
ING
TRACK
OF
THE
LENGTH
TO
SEE
THIS
NOTE
THAT
WHEN
WE
ARE
DOING
THE
MIN
OF
A
SET
OF
COMBINED
PATHS
FOR
SOME
I
J
PATH
WE
USE
N
MIDPOINTS
EACH
WITH
A
UNIQUE
VALUE
K
WHEN
WE
DO
THIS
MIN
OPERATION
WE
CAN
JUST
KEEP
THE
WINNER
K
VALUE
AS
WELL
AS
HIS
LENGTH
TO
KEEP
THE
HOP
LENGTH
WE
CAN
SEE
THAT
IT
CAN
EASILY
BE
CREATED
INITIALLY
IN
THE
FIRST
ROUND
AS
FOR
ANY
PATHS
THAT
ARE
CREATED
AND
THEREAFTER
WE
CAN
JUST
CALCULATED
IT
AS
THE
HOP
LENGTH
OF
I
K
PLUS
THAT
OF
K
J
FOR
THE
WINNING
SUB
PATHS
THUS
FROM
NOW
ON
WE
WILL
ASSUME
THAT
IN
ADDITION
TO
HAVING
SHORTEST
PATH
LENGTH
IN
OUR
TWO
DIMENSIONAL
ARRAY
WE
ALSO
HAVE
THE
K
VALUE
USED
TO
CREATE
THE
PATH
AS
WELL
AS
THE
NUMBER
OF
HOPS
ON
THE
PATH
AFTER
OUR
EREW
ALGORITHM
FROM
THE
LAST
QUESTION
MODIFIED
ACCORDING
TO
OUR
REQUIREMENTS
FINISHES
WE
CAN
COMMENCE
CONSTRUCTING
THE
PATHS
THEM
SELVES
WE
ESSENTIALLY
FOLLOW
THE
SAME
PROCEDURE
AS
ABOVE
EXCEPT
THAT
WE
KNOW
THE
OPTIMAL
PATHS
AND
WE
SIMPLY
NEED
TO
CONSTRUCT
THEM
THE
IDEA
THUS
IS
AGAIN
TO
RUN
FOR
LOG
N
ITERATIONS
GUARENTEEING
THAT
AFTER
EACH
ITER
ATION
WE
COMPLETE
ALL
PATHS
OF
LENGTH
WE
HAVE
TWO
PHASES
THE
PATH
OUTPUT
PHASE
AND
THE
PATH
COPY
PHASE
THE
OUTPUT
OUTPUTS
THE
COMPLETED
PATHS
THE
COPY
PHASE
COPIES
THESE
PATHS
SO
THAT
THEY
MAY
BE
USED
IN
SUBSEQUENT
ROUNDS
OUTPUT
PHASE
EACH
ENTRY
I
J
IN
THE
TABLE
IS
ASSIGNED
N
PROCESSORS
AND
IN
ITERATION
P
ANY
ENTRY
WITH
HOP
COUNT
TO
WILL
BE
CALCULATED
THIS
WILL
BE
DONE
BY
COPYING
UNIQUE
COPIES
OF
THE
PREVIOUSLY
FINISHED
PATHS
I
K
AND
K
J
TO
THE
PROPER
OUTPUT
LOCATION
FOR
I
J
WE
KNOW
THAT
THESE
PATHS
WERE
FINISHED
IN
THE
LAST
ROUND
THUS
THEY
ARE
AVAILABLE
THE
COPY
OF
THESE
PATHS
TAKES
AT
MOST
LOG
N
TIME
PER
PATH
AS
EACH
PATH
CAN
BE
AT
MOST
N
IN
LENGTH
AND
WE
CAN
COPY
THAT
IN
LOG
N
TIME
WITH
N
PROCESSORS
WHICH
IS
EXACTLY
WHAT
WE
HAVE
PER
ENTRY
IN
THE
NEXT
PHASE
WE
WILL
EXPLAIN
THE
UNIQUE
COPIES
OF
I
K
AND
K
J
COPY
PHASE
AT
THIS
POINT
WE
HAVE
CREATED
ALL
PATHS
OF
HOP
COUNT
TO
HOP
COUNT
WE
JUST
NEED
TO
MAKE
THESE
PATHS
AVAILABLE
TO
THE
NEXT
ITERATION
NOTE
THAT
FOR
A
PATH
I
J
THAT
IT
CAN
ONLY
BE
USED
IN
THE
NEXT
ITERATION
AS
EITHER
I
K
J
OR
K
I
J
BECAUSE
K
IS
FIXED
IN
BOTH
CASES
THE
OTHER
HALF
OF
THE
PATH
CAN
ONLY
BE
ONE
OF
N
PATHS
MEANING
OUR
CURRENT
I
J
PATH
CAN
BE
USED
AT
MOST
TIMES
SO
WE
D
LIKE
COPIES
SO
THAT
EVERYONE
CAN
HAVE
THEIR
OWN
UNIQUE
COPY
IN
PHASE
OF
THE
NEXT
ITERATION
NOW
WE
MUST
CONSIDER
THAT
WE
WANT
TO
MAKE
COPIES
OF
AN
UNKNOWN
NUMBER
OF
PATHS
THAT
CAN
BE
UP
TO
IN
LENGTH
BUT
CONSIDER
THAT
IN
EACH
ROUND
WE
DOUBLE
THE
NUMBER
OF
PATHS
THAT
ARE
FINISHED
AND
EVEN
IF
WE
HAVE
THE
MAX
POSSIBLE
PATHS
ALL
OF
LENGTH
THEN
WE
STILL
ONLY
NEED
COPIES
OF
PATHS
OF
LENGTH
WHICH
JUST
GIVES
THAT
WE
NEED
ORDER
N
COPIES
OF
DATA
ORDER
BY
ASSIGNING
PROCESSORS
FOR
EACH
FINAL
COPY
OF
THE
DATA
WE
CAN
MAKE
ALL
OUR
COPIES
IN
LOG
N
TIME
BY
OUR
STANDARD
DOUBLING
OF
DATA
EACH
ROUND
FURTHER
WE
CAN
IDENTIFY
THESE
PATH
COPIES
BY
HAVING
ONE
COPY
FOR
ALL
POSSIBLE
I
AND
ONE
COPY
FOR
ALL
POSSIBLE
J
SO
THAT
IN
PHASE
ONE
THE
PROCESSORS
WILL
KNOW
WHERE
TO
LOOK
USE
THE
SAME
METHOD
AS
USED
FOR
THE
MINIMUM
EDIT
DISTANCE
PROBLEM
EXCEPT
WITH
DIFFERENT
WEIGHTS
ON
THE
ARCS
E
G
ON
HORIZONTAL
VERTICAL
ARCS
AND
ON
DIAGONAL
ARCS
SOLUTION
COURTESTY
OF
DANIEL
COLE
HERE
WE
JUST
CREATE
A
GRAPH
AND
THEN
RUN
THE
ALL
PAIRS
SHORTEST
PATH
PROBLEM
FROM
CLASS
FOLLOWED
BY
A
STEP
TO
EXTRACT
THE
MINIMUM
EDIT
DISTANCE
FIRST
WE
CONSTRUCT
THE
GRAPH
CONSIDER
AN
N
BY
N
MATRIX
M
WHERE
EACH
ENTRY
IS
A
VERTEX
AND
I
J
HAS
B
J
AS
THE
COLUMN
AND
A
I
AS
THE
ROW
WE
LL
ASSIGN
A
SINGLE
PROCESSOR
TO
EACH
VERTEX
TO
CREATE
THE
EDGES
GOING
OUT
OF
THAT
VERTEX
PROCESSOR
PI
J
WILL
LOOK
AT
A
I
AND
B
J
IF
THEY
ARE
EQUAL
THEN
IT
WILL
CREATE
AN
ARC
FROM
M
I
J
TO
M
I
J
WITH
COST
IF
THEY
ARE
NOT
EQUAL
IT
WILL
CREATE
ARCS
M
I
J
TO
M
I
J
WITH
COST
OR
MORE
GENERALLY
COST
OPDELETE
M
I
J
TO
M
I
J
WITH
COST
OR
MORE
GENERALLY
COST
OPINSERT
M
I
J
TO
M
I
J
WITH
COST
OR
MORE
GENERALLY
COST
OPREPLACE
NOTICE
THAT
WE
NEED
AN
EXTRA
ROW
AND
AN
EXTRA
COLUMN
WHICH
WE
PLACE
IN
THE
N
POSITION
FOR
BOTH
I
E
WE
HAVE
AN
EXTRA
N
ROW
AND
N
COLUMN
THESE
ARE
NEEDED
BECAUSE
COMPARING
A
N
WITH
B
I
OR
A
I
WITH
B
N
WOULD
CAUSE
EDGES
TO
GO
OUTSIDE
OUR
N
BY
N
MATRIX
BUT
CONSIDER
WHAT
THIS
MEANS
IT
MEANS
THAT
WE
HAVE
EITHER
REMOVED
OR
REPLACED
ALL
LETTERS
IN
A
N
ROW
AND
ARE
LEFT
WITH
SOME
OF
B
LEFT
OR
THAT
WE
HAVE
COVERED
ALL
OF
B
N
COLUMN
THROUGH
INSERTIONS
OR
REPLACEMENTS
AND
ARE
LEFT
WITH
SOME
OF
A
LEFT
IF
THE
FIRST
CASE
WE
JUST
NEED
TO
INSERT
THE
REST
OF
B
THUS
WE
SIMPLY
ADD
EDGES
FROM
M
N
J
TO
M
N
J
WITH
COST
COST
OPINSERT
IN
THE
SECOND
CASE
WE
JUST
NEED
TO
REMOVE
THE
REST
OF
A
THUS
WE
ADD
EDGES
FROM
M
J
N
TO
M
J
N
WITH
COST
COST
OPDELETE
WE
CAN
ASSIGN
A
SINGLE
PROCESSOR
TO
EACH
OF
THESE
ENTRIES
AS
WELL
CONCEPTUALLY
WE
THINK
OF
THE
MIMIMUM
EDIT
DISTANCE
PROBLEM
AS
STARTING
AT
M
AND
MAKING
DECISIONS
ON
CONVERSION
FOR
THE
FIRST
ENTRY
THE
OPTIMAL
EITHER
REMOVES
A
IN
WHICH
CASE
A
IS
NOW
BEING
COMPARED
TO
B
HENCE
WE
GO
DOWN
LIKEWISE
FOR
INSERTING
OR
REPLACING
ONCE
WE
VE
REACHED
M
N
N
ALL
LETTERS
IN
B
HAVE
BEEN
MATCHED
EITHER
THROUGH
INSERT
OR
REPLACE
AND
WE
VE
MADE
DECISIONS
ABOUT
EVER
LETTER
IN
A
EITHER
THROUGH
DELETE
OR
REPLACE
AND
THAT
THE
KEY
REPLACE
HANDLES
BOTH
A
LETTER
IN
B
AND
A
WHILE
INSERT
AND
DELETE
ONLY
HANDLE
A
LETTER
IN
ONE
STRING
THUS
ONCE
WE
RUN
ALL
PAIRS
SHORTEST
PATH
WE
NEED
TO
SIMPLY
FIND
THE
MINIMUM
DISTANCE
BETWEEN
POINT
M
AND
M
N
N
THE
CONSTRUCTION
OF
THIS
GRAPH
TAKES
CONSTANT
TIME
ON
A
CREW
MACHINE
WITH
PROCESSORS
AS
EACH
PROCESSOR
IS
ASSIGNED
A
SINGLE
VERTEX
AND
CREATES
ARCS
OUT
OF
THAT
VERTEX
IF
THERE
IS
A
CONCURRENT
WRITE
ISSUE
WITH
WHERE
THE
ARCS
ARE
STORED
THEN
WE
CAN
JUST
DO
IT
IN
TWO
SHIFTS
SUCH
THAT
THERE
IS
A
GAP
BETWEEN
THE
HEAD
AND
TAIL
OF
ANY
ARC
THIS
WILL
STILL
TAKE
A
CONSTANT
AMOUNT
OF
TIME
IN
EITHER
CASE
WE
HAVE
JUST
CONSTRUCTED
A
GRAPH
SUCH
THAT
THE
SHORTEST
PATH
DISTANCE
FROM
TO
N
N
IS
IN
FACT
THE
MINIMUM
EDIT
DISTANCE
THUS
WE
CAN
RUN
THE
ALL
PAIRS
SHORTEST
PATH
ALGORITHM
USING
PROCESSORS
AND
GET
THE
RESULT
IN
O
TIME
USING
OUR
IN
CLASS
ALGORITHM
FOR
ALL
PAIRS
SHORTEST
PATH
THEN
WE
CAN
LOOK
UP
THE
SHORTEST
PATH
DISTANCE
FROM
NODE
TO
N
N
IN
CONSTANT
TIME
THUS
OUR
RUN
TIME
IS
BOUND
BY
THE
ALL
PAIRS
SHORTEST
PATH
COMPUTATION
MAKING
OUR
RUN
TIME
O
N
WITH
O
PROCESSORS
SOLUTION
COURTESY
OF
DANIEL
COLE
HERE
WE
WOULD
LIKE
A
CRCW
ALGORITHM
FOR
MERGING
THAT
RUNS
IN
CONSTANT
TIME
ASSUME
WE
HAVE
TWO
SORTED
ARRAYS
OF
LENGTH
N
NAMELY
XN
AND
YN
WE
GIVE
AN
ALGORITHM
FOR
PLACING
YI
CORRECTLY
IN
ITS
FINAL
LOCATION
IN
THE
OUTPUT
ARRAY
IN
CONSTANT
TIME
WE
USE
N
PROCESSORS
AND
EACH
PROCESSOR
IS
ASSIGNED
AN
XJ
VALUE
WE
HAVE
AN
ARRAY
AI
N
THAT
WE
INITIALIZE
TO
ALL
ZEROS
IN
CONSTANT
TIME
EACH
PROCESSOR
COMPARES
XJ
AND
YI
AND
IF
YI
XJ
THEN
SET
AI
J
ELSE
AI
J
THIS
TAKES
CONSTANT
TIME
AI
NOW
HAS
A
FOR
EVERY
XJ
THAT
IS
LARGER
THAN
YI
AND
A
FOR
ALL
SMALLER
THUS
ALL
VALUES
REPRESENT
X
VALUES
THAT
ARE
LESS
THAN
OR
EQUAL
TO
YI
EACH
PROCESSOR
PJ
NOW
LOOKS
AT
J
AND
J
AND
ONLY
ONE
PROCESSOR
WILL
SEE
THAT
AI
J
AND
AI
J
AS
THE
XJ
VALUES
ARE
IN
SORTED
ORDER
THUS
THE
FINAL
POSTION
OF
YI
IS
IN
INDEX
I
J
INDEX
FROM
OF
THE
OUTPUT
ARRAY
BECAUSE
WE
KNOW
I
Y
VALUES
ARE
SMALLER
THAN
YI
AND
J
X
VALUES
ARE
SMALLER
THAN
YI
BECAUSE
ONLY
A
SINGLE
PROCESSOR
KNOWS
THIS
IT
CAN
SAFELY
WRITE
YI
TO
THE
CORRECT
OUTPUT
LOCATION
CREATING
AND
POPULATING
AI
WITH
TAKES
CONSTANT
TIME
AND
FINDING
THE
LARGEST
XJ
THAT
IS
SMALLER
THAN
YI
THE
LARGEST
INDEXED
TOOK
CONSTANT
TIME
THUS
WE
HAVE
PLACED
YI
IN
CONSTANT
TIME
THUS
WE
CAN
SIMPLY
ASSIGN
N
PROCESSORS
TO
EVERY
X
AND
Y
VALUE
TO
PLACE
EACH
VALUE
IN
THE
OUTPUT
ARRAY
IN
PARALLEL
IN
CONSTANT
TIME
NOTE
THAT
WE
SHOULD
WRITE
A
FOR
X
Y
INSTEAD
OF
X
Y
TO
GIVE
THE
Y
VALUES
PRECEDENCE
OVER
X
VALUES
AND
AVOID
CONCURRENT
WRITES
AND
EMPTY
ENTRIES
IN
THE
OUTPUT
WE
THUS
NEED
A
TOTAL
OF
O
PROCESSORS
AND
OUR
RUN
TIME
IS
O
SOLUTION
COURTESY
OF
DANIEL
COLE
HERE
WE
GIVE
A
PARALLEL
ALGORITHM
THAT
FINDS
THE
MAX
OF
N
NUMBERS
IN
O
LOG
LOG
N
TIME
WITH
N
PROCESSORS
ON
A
CRCW
PRAM
HERE
WE
SIMPLY
BREAK
OUR
PROBLEM
UP
INTO
N
SUBPROB
LEMS
OF
N
SIZE
EACH
AND
RECURSIVELY
CALL
IN
PARALLEL
OUR
MAX
FUNCTION
ON
EACH
OF
THESE
CHUNKS
WITH
N
PROCESSORS
EACH
WE
RECEIVE
A
SINGLE
MAX
VALUE
FROM
EACH
OF
THESE
N
CALLS
AND
BECAUSE
WE
HAVE
N
PROCES
SORS
WE
CAN
SOLVE
THE
MAX
PROBLEM
FOR
N
VALUES
IN
CONSTANT
TIME
WITH
N
PROCESSORS
USING
THE
METHOD
FROM
CLASS
I
E
WE
HAVE
PROCESSORS
EQUAL
TO
THE
NUMBER
OF
VALUES
SQUARED
THUS
OUR
RECURRENCE
RELATION
IS
T
N
N
T
N
N
C
WHERE
C
IS
THE
CONSTANT
TIME
MAX
PARALLEL
ALGORITHM
ON
CRCW
TO
SOLVE
THIS
WE
JUST
GUESS
T
N
N
C
LOG
LOG
N
TO
GET
T
N
N
C
LOG
LOG
N
C
C
LOG
LOG
N
C
C
LOG
LOG
LOG
N
C
C
LOG
C
LOG
LOG
N
C
C
C
LOG
LOG
N
C
C
LOG
LOG
N
WHICH
IS
WHAT
WE
GUESSED
THUS
WE
HAVE
A
RUNNING
TIME
OF
O
LOG
LOG
N
HERE
WE
GIVE
A
PARALLEL
ALGORITHM
THAT
FINDS
THE
MAX
OF
N
NUMBERS
ALL
OF
WHICH
ARE
IN
THE
RANGE
TO
N
IN
CONSTANT
TIME
ON
A
CRCW
PRIORITY
ASSUME
WE
HAVE
AN
ARRAY
A
OF
SIZE
N
AND
DENOTE
A
PROCESSOR
INTEGER
IDENTIFIER
AS
PI
I
WHERE
I
N
GIVEN
N
PROCESSORS
ON
A
CRCW
PRIORITY
MACHINE
WE
GIVE
THE
FOLLOWING
CODE
FOR
PROCESSOR
PI
TO
FIND
THE
MAXIMUM
OF
NUMBERS
XN
IN
THE
RANGE
TO
N
A
A
IF
A
N
ANSWER
A
N
NOT
YET
TURNED
IN
NO
SOLUTION
GIVEN
PARALLEL
AND
DISTRIBUTED
COMPUTATION
PARALLEL
COMPUTATION
TIGHTLY
COUPLED
PROCESSORS
THAT
CAN
COMMUNICATE
AL
MOST
AS
QUICKLY
AS
PERFORM
A
COMPUTATION
DISTRIBUTED
COMPUTATION
LOOSELY
COUPLE
PROCESSOR
FOR
WHICH
COMMUNICATION
IS
MUCH
SLOWER
THAN
COMPUTATION
PRAM
MODEL
A
PRAM
MACHINE
CONSISTS
OF
M
SYNCHRONOUS
PROCESSORS
WITH
SHARED
MEMORY
THIS
MODEL
IGNORES
SYNCHRONIZATION
PROBLEMS
AND
COMMUNICATION
ISSUES
AND
CONCENTRATES
ON
THE
TASK
OF
PARALLELIZATION
OF
THE
PROBLEM
ONE
GETS
VARIOUS
VARIATIONS
OF
THIS
MODEL
DEPENDING
ON
HOW
VARIOUS
PROCESSORS
ARE
PERMITTED
TO
ACCESS
THE
SAME
MEMORY
LOCATION
AT
THE
SAME
TIME
ER
EXCLUSIVE
READ
ONLY
ONE
PROCESSOR
CAN
READ
A
LOCATION
IN
ANY
STEP
CR
CONCURRENT
READ
ANY
NUMBER
OF
PROCESSORS
CAN
READ
A
LOCATION
IN
A
STEP
EW
EXCLUSIVE
WRITE
ONLY
ONE
PROCESSOR
CAN
WRITE
A
LOCATION
IN
ANY
STEP
CW
CONCURRENT
WRITE
ANY
NUMBER
OF
PROCESSORS
CAN
WRITE
A
LOCATION
IN
A
STEP
WHAT
IT
PROCESSORS
TRY
TO
WRITE
DIFFERENT
VALUES
COMMON
ALL
PROCESSORS
MUST
BE
TRYING
TO
WRITE
THE
SAME
VALUE
ARBITRARY
AN
ARBITRARY
PROCESSOR
SUCCEEDS
IN
THE
CASE
OF
A
WRITE
CONFLICT
PRIORITY
THE
LOWEST
NUMBER
PROCESSOR
SUCCEEDS
THE
RIGHT
MODEL
IS
PROBABLY
AN
EREW
PRAM
BUT
WE
WILL
STUDY
OTHER
MODELS
AS
ACADEMIC
EXERCISES
WE
WILL
SOMETIMES
REFER
TO
ALGORITHMS
BY
THE
TYPE
OF
MODEL
THAT
THESE
ALGORITHMS
ARE
DESIGNED
FOR
E
G
AN
EREW
PRAM
ALGORITHM
WE
DEFINE
T
N
P
TO
BE
PARALLEL
TIME
FOR
THE
ALGORITHM
UNDER
CONSIDER
ATION
WITH
P
PROCESSORS
ON
INPUT
OF
SIZE
N
LET
N
BE
THE
SEQUENTIAL
TIME
COMPLEXITY
THEN
THE
EFFICIENCY
OF
A
PARALLEL
ALGORITHM
IS
DEFINED
BY
E
N
P
N
MT
N
P
EFFICIENCIES
CAN
RANGE
FROM
TO
THE
BEST
POSSIBLE
EFFICIENCY
YOU
CAN
HAVE
IS
GENERALLY
WE
PREFER
ALGORITHM
WHOSE
EFFICIENCY
IS

THE
FOLDING
PRINCIPLE
CAN
BE
STATED
IN
TWO
EQUIVALENT
WAYS
TIME
BASED
DEFINITION
FOR
K
IT
MUST
BE
THE
CASE
THAT
T
N
P
KT
N
KP
THAT
IS
INCREASING
THE
NUMBER
OF
PROCESSORS
BY
A
FACTOR
OF
K
REDUCES
THE
TIME
BY
AT
MOST
A
FACTOR
OF
K
OR
EQUIVALENTLY
REDUCING
THE
NUMBER
OF
PROCESSORS
BY
A
FACTOR
OF
K
INCREASES
TIME
BY
AT
MOST
A
FACTOR
OF
K
EFFICIENCY
BASED
DEFINITION
FOR
K
E
N
P
E
N
KP
THAT
IS
MORE
PROCESSORS
CAN
NOT
INCREASE
EFFICIENCY
AND
THERE
IS
NO
LOSS
OF
EFFI
CIENCY
IF
YOU
DECREASE
THE
NUMBER
OF
PROCESSORS
THE
OR
PROBLEM
INPUT
BITS
BN
OUTPUT
THE
LOGICAL
OR
OF
THE
BITS
ONE
CAN
OBTAIN
AN
EREW
ALGORITHM
WITH
T
N
P
N
P
LOG
P
USING
A
DIVIDE
AND
CONQUER
ALGORITHM
THAT
IS
PERHAPS
BEST
UNDERSTOOD
AS
A
BINARY
TREE
THE
P
LEAVES
OF
THE
BINARY
TREE
ARE
N
P
BITS
EACH
INTERNAL
NODE
IS
A
PROCESSOR
THAT
OR
THE
OUTPUT
OF
ITS
CHILDREN
THE
EFFICIENCY
OF
THE
EREW
ALGORITHM
IS
E
N
P
N
PT
N
P
N
P
N
P
LOG
P
N
P
P
LOG
P
WHICH
IS

IF
P
O
N
LOG
N
ONE
CAN
ALSO
OBTAIN
A
CRCW
COMMON
ALGORITHM
WITH
T
N
N

IN
THIS
ALGORITHM
EACH
PROCESSOR
PI
SETS
A
VARIABLE
ANSWER
TO
THEN
IF
BI
PI
SETS
ANSWER
TO
THE
EFFICIENCY
OF
THIS
ALGORITHM
IS
E
N
N

MIN
PROBLEM
SEE
SECTION
AND
SECTION
INPUT
INTEGERS
XN
OUTPUT
THE
SMALLEST
XI
THE
RESULTS
ARE
ESSENTIALLY
THE
SAME
AS
FOR
THE
OR
PROBLEM
THERE
IS
AN
EREW
DIVIDE
AND
CONQUER
ALGORITHM
WITH
E
N
N
LOG
N

NOTE
THAT
THIS
TECHNIQUE
WORKS
FOR
ANY
ASSOCIATIVE
OPERATOR
BOTH
OR
AND
MIN
ARE
ASSOCIATIVE
THERE
IS
AN
CRCW
COMMON
ALGORITHM
WITH
T
N
P
AND
E
N
P
N
HERE
CODE
FOR
PROCESSOR
PI
J
I
J
J
FOR
THE
CRCW
COMMON
ALGORITHM
TO
COMPUTE
THE
LOCATION
OF
THE
MINIMUM
NUM
BER
IF
X
I
X
J
THEN
T
I
J
ELSE
T
I
J
AND
I
IF
T
I
J
THEN
AND
I
IF
AND
I
THEN
ANSWER
I
WHAT
HAPPENS
WHEN
THE
ABOVE
CODE
IS
RUN
IN
THE
VARIOUS
CW
MODELS
IF
THERE
ARE
TWO
SMALLEST
NUMBERS
WHAT
HAPPENS
IN
THE
VARIOUS
CW
MODELS
IF
THERE
ARE
TWO
SMALLEST
NUM
BERS
AND
YOU
JUST
WANT
TO
COMPUTE
THE
VALUE
OF
THE
SMALLEST
NUMBER
THAT
IS
IF
THE
LAST
LINE
IS
CHANGED
TO
IF
AND
I
THEN
ANSWER
X
I
PARALLEL
PREFIX
PROBLEM
INPUT
INTEGERS
XN
OUTPUT
SN
WHERE
SI
J
XJ
WE
GIVE
A
DIVIDE
AND
CONQUER
ALGORITHM
SOLVE
THE
PROBLEM
FOR
THE
EVEN
XI
AND
ODD
XI
SEPARATELY
THEN
AND
THIS
GIVES
AN
ALGORITHM
WITH
TIME
T
N
N
LOG
N
ON
EREW
PRAM
THIS
CAN
BE
IMPROVED
TO
T
N
N
LOG
N
LOG
N
THUS
GIVING

EFFICIENCY
NOTE
THAT
DIVIDE
AND
CONQUER
INTO
THE
FIRST
HALF
AND
LAST
HALF
IS
MORE
DIFFICULT
BECAUSE
OF
THE
SUM
FOR
THE
FIRST
HALF
BECOMES
A
BOTTLENECK
THAT
ALL
OF
THE
LAST
HALF
OF
THE
PROCESSORS
WANT
TO
ACCESS
ALSO
NOTE
THAT
THIS
TECHNIQUE
WORKS
FOR
ANY
ASSOCIATIVE
OPERATOR
ALL
PAIRS
SHORTEST
PATH
PROBLEM
INPUT
A
DIRECTED
EDGE
WEIGHTED
GRAPH
G
WITH
NO
NEGATIVE
CYCLES
OUTPUT
THE
LENGTH
OF
THE
SHORTEST
PATH
D
I
J
BETWEEN
ANY
PAIR
OF
POINTS
I
AND
J
FIRST
CONSIDER
THE
FOLLOWING
SEQUENTIAL
CODE
FOR
I
TO
N
DO
FOR
J
TO
N
DO
D
I
J
WEIGHT
OF
EDGE
I
J
REPEAT
LOG
N
TIMES
FOR
I
TO
N
DO
FOR
J
TO
N
DO
FOR
M
TO
N
DO
D
I
J
MIN
D
I
J
D
I
M
D
M
J
THE
CORRECTNESS
OF
THIS
PROCEDURE
CAN
BE
SEEN
USING
THE
FOLLOWING
LOOP
INVARIANT
AFTER
T
TIMES
THROUGH
THE
REPEAT
LOOP
FOR
ALL
I
AND
J
IF
THE
LENGTH
OF
THE
SHORTEST
PATH
BETWEEN
VERTICES
I
AND
J
THAT
HAS
OR
LESS
EDGES
IS
EQUAL
TO
D
I
J
A
PARALLEL
FOR
LOOP
IS
A
LOOP
WHERE
ALL
OPERATIONS
CAN
BE
EXECUTED
IN
PARALLEL
FOR
EXAMPLE
FOR
I
TO
N
DO
C
I
A
I
B
I
QUESTION
SO
WHICH
LOOPS
CAN
BE
REPLACED
BY
PARALLEL
FOR
LOOPS
ANSWER
THE
SECOND
AND
THIRD
THIS
GIVES
T
N
P
N
LOG
N
ON
A
CREW
PRAM
THE
FOURTH
LOOP
COULD
BE
REPLACED
BY
A
PARALLEL
FOR
LOOP
ON
A
MACHINE
WITH
CONCURRENT
WRITE
MACHINE
THAT
ALWAYS
WRITES
THE
SMALLEST
VALUE
BUT
NOTE
THAT
THE
FOURTH
LOOP
IS
JUST
COMPUTING
A
MINIMUM
WHICH
IS
AN
ASSOCIA
TIVE
OPERATOR
THUS
USING
THE
STANDARD
ALGORITHM
THE
COMPUTE
THE
VALUE
OF
AN
ASSOCIATIVE
OPERATOR
IN
TIME
LOG
N
WITH
N
LOG
N
PROCESSORS
WE
GET
TIME
T
N
LOG
N
LOG
N
ON
AN
CREW
PRAM
QUESTION
WHAT
IS
THE
EFFICIENCY
ANSWER
IT
DEPENDS
WHAT
YOU
USE
FOR
N
N
T
N
THIS
MEASURES
SPEED
UP
OF
THE
PARALLEL
ALGORITHM
BUT
DOESN
T
GIVE
SPEED
UP
OVER
STANDARD
SEQUENTIAL
ALGORITHM
N
BEST
ACHIEVABLE
SEQUENTIAL
TIME
BUT
FOR
ALMOST
ALL
PROBLEMS
THE
BEST
ACHIEVABLE
SEQUENTIAL
TIME
IS
NOT
KNOWN
N
SEQUENTIAL
TIME
OF
STANDARD
OR
BEST
KNOWN
SEQUENTIAL
ALGO
RITHM
BUT
THIS
HAS
THE
ODD
PROPERTY
THAT
THE
EFFICIENCY
OF
A
PARALLEL
ALGORITHM
CAN
CHANGE
WHEN
A
NEW
SEQUENTIAL
ALGORITHM
IS
DISCOVERED
NOTE
THAT
THERE
ARE
SIMPLE
SEQUENTIAL
SHORTEST
PATH
ALGORITHMS
THAT
RUN
IN
TIME
O
AND
COMPLICATED
ONES
THAT
RUN
IN
TIME
SOMETHING
LIKE
O
ODD
EVEN
MERGING
SEE
SECTION
INPUT
SORTED
LISTS
XN
AND
YN
OUTPUT
THE
TWO
LISTS
MERGED
INTO
ONE
SORTED
LIST
WE
GIVE
THE
FOLLOWING
DIVIDE
AND
CONQUER
ALGORITHM
MERGE
MERGE
TO
GET
MERGE
TO
GET
FOR
I
TO
N
DO
MIN
MAX
THIS
CAN
BE
IMPLEMENTED
ON
AN
EREW
PRAM
TO
RUN
IN
TIME
T
N
N
LOG
N
THUS
GIVING
EFFICIENCY

LOG
N
THE
FOLLOWING
ARGUMENT
ESTABLISHES
THE
CORRECTNESS
OF
THE
ALGORITHM
EACH
AI
IS
GREATER
THAN
OR
EQUAL
AI
EACH
AI
I
IS
LARGER
THAN
BI
HENCE
AI
EACH
BI
IS
GREATER
THAN
OR
EQUAL
BI
EACH
BI
I
IS
LARGER
THAN
AI
HENCE
BI
THIS
SAME
ARGUMENT
SHOWS
AI
AND
BI
SO
AND
MUST
BE
AI
AND
BI
ODD
EVEN
MERGE
SORTING
SEE
SECTION
WE
GIVE
THE
FOLLOWING
DIVIDE
AND
CONQUER
ALGORITHM
SORT
MERGE
SORT
SORT
THIS
CAN
BE
IMPLEMENTED
ON
AN
EREW
PRAM
TO
RUN
IN
TIME
T
N
N
N
THUS
GIVING
EFFICIENCY
N
LOG
N

LOG
N
THERE
IS
A
EREW
SORTING
ALGORITHM
WITH
CONSTANT
EFFICIENCY
BUT
IT
IS
A
BIT
COMPLICATED
POINTER
DOUBLING
PROBLEM
IN
THE
POINTER
DOUBLING
PROBLEM
EACH
OF
THE
N
PROCESSORS
IS
GIVEN
A
POINTER
TO
A
UNIQUE
ELEMENT
OF
A
SINGLY
LINKED
LIST
OF
N
ITEMS
THE
GOAL
IS
FOR
EACH
PROCESSOR
TO
LEARN
ITS
LOCATION
IN
THE
LINKED
LIST
E
G
THE
THE
PROCESSOR
WITH
THE
ELEMENT
IN
THE
LIST
SHOULD
KNOW
THAT
IT
IS
IN
THE
LIST
FOR
I
TO
N
IN
PARALLEL
DO
D
I
D
N
REPEAT
LOG
N
TIMES
FOR
EACH
ITEM
I
IN
PARALLEL
IF
NEXT
I
NIL
THEN
D
I
D
I
D
NEXT
I
NEXT
I
NEXT
NEXT
I
THE
CORRECTNESS
OF
THE
CODE
FOLLOWS
FROM
THE
FOLLOWING
LOOP
INVARIANT
THE
POSITION
OF
I
EQUALS
D
I
D
NEXT
I
D
NEXT
NEXT
I
NOTE
THAT
THIS
IS
ESSENTIALLY
SOLVING
THE
PARALLEL
PREFIX
PROBLEM
WITH
THE
WORK
DONE
BEFORE
THE
RECURSION
INSTEAD
OF
AFTER
TO
SOLVE
THE
PARALLEL
PREFIX
PROBLEM
WE
WOULD
REPLACE
THE
INITIALIZATION
FOR
I
TO
N
IN
PARALLEL
DO
D
I
BY
FOR
I
TO
N
IN
PARALLEL
DO
D
I
X
I
EULERIAN
TOUR
TECHNIQUE
TO
FIND
TREE
DEPTHS
THE
INPUT
IS
A
BINARY
TREE
WITH
ONE
PROCESSOR
PER
NODE
ASSUME
THAT
EACH
PROCESSOR
KNOWS
THE
LOCATION
OF
ONE
NODE
THE
PROBLEM
IS
TO
COMPUTE
THE
DEPTH
OF
EACH
NODE
IN
THE
TREE
WE
SHOW
BY
EXAMPLE
HOW
TO
REDUCE
THIS
TO
POINTER
DOUBLING
FROM
THE
FOLLOWING
TREE
A
B
C
D
E
WE
CREATE
THE
LIST
THE
FIRST
LINE
A
B
D
B
E
B
A
C
A
AND
CALL
POINTER
DOUBLING
WITH
D
I
INITIALIZED
TO
EITHER
OR
APPROPRIATELY
THE
DEPTH
OF
A
NODE
IS
THEN
COMPUTED
BY
LOOKING
AT
THE
SUM
UP
TO
THE
POINT
SHOWN
IN
THE
SECOND
LINE
EXPRESSION
EVALUATION
THE
INPUT
IS
AN
ALGEBRAIC
EXPRESSION
IN
THE
FORM
OF
A
BINARY
TREE
WITH
THE
LEAVES
BEING
THE
ELEMENTS
AND
THE
INTERNAL
NODES
BEING
THE
ALGEBRAIC
OPER
ATIONS
THE
GOAL
IS
TO
COMPUTE
THE
VALUE
OF
THE
EXPRESSION
SOME
OBVIOUS
APPROACHES
WON
T
WORK
ARE
EVALUATE
NODES
WHEN
BOTH
VALUES
OF
CHILDREN
ARE
KNOWN
AND
PARALLEL
PREFIX
THE
FIRST
APPROACH
WON
T
GIVE
YOU
A
SPEED
UP
IF
THE
TREE
IS
UNBALANCED
THE
SECOND
APPROACH
WON
T
WORK
IF
THE
OPERATORS
ARE
NOT
BE
ASSOCIATIVE
FIRST
ASSUME
THAT
THE
ONLY
OPERATION
IS
SUBTRACTION
WE
LABEL
EDGES
BY
FUNCTIONS
WE
NOW
DEFINE
THE
CUT
OPERATION
IF
WE
HAVE
A
SUBTREE
THAT
LOOKS
LIKE
H
X
F
X
G
X
CONSTANT
C
A
B
AND
CUT
ON
THE
ROOT
OF
THIS
SUBTREE
WE
GET
H
F
X
G
C
A
B
IF
WE
HAVE
A
SUBTREE
THAT
LOOKS
LIKE
H
X
F
X
G
X
CONSTANT
C
A
B
AND
CUT
ON
THE
ROOT
OF
THIS
SUBTREE
WE
GET
H
F
C
G
X
A
B
THUS
WE
ARE
LEFT
WITH
FINDING
A
CLASS
OF
FUNCTIONS
WITH
THE
BASE
ELEMENTS
BEING
CONSTANTS
THAT
ARE
CLOSED
UNDER
COMPOSITION
SUBTRACTION
OF
CONSTANTS
AND
SUBTRACTION
FROM
CONSTANTS
THIS
CLASS
IS
THE
FUNCTIONS
OF
THE
FORM
AX
B
A
IS
OR
AND
B
CAN
BE
ANY
NUMBER
NOTE
THAT
IN
ONE
STEP
WE
CAN
APPLY
CUTS
TO
ALL
NODES
WITH
AN
ODD
NUMBERED
LEFT
CHILD
THAT
IS
A
LEAF
NOTE
THAT
IN
ONE
STEP
WE
CAN
APPLY
CUTS
TO
ALL
NODES
WITH
AN
ODD
NUMBERED
RIGHT
CHILD
THAT
IS
A
LEAF
THIS
LEADS
TO
THE
FOLLOWING
ALGORITHM
REPEAT
LOG
N
TIMES
FOR
EACH
INTERNAL
NODE
V
IN
PARALLEL
IF
V
HAS
ODD
NUMBERED
LEFT
CHILD
THAT
IS
A
LEAF
THEN
CUT
AT
V
IF
V
HAS
ODD
NUMBERED
RIGHT
CHILD
THAT
IS
A
LEAF
THEN
CUT
AT
V
RENUMBER
THE
LEAVES
USING
POINTER
DOUBLING
NOTE
THAT
IN
LOG
N
STEPS
WE
WILL
DOWN
TO
A
CONSTANT
SIZED
TREE
SINCE
EACH
ITERATION
OF
THE
OUTER
LOOP
REDUCES
THE
NUMBER
OF
LEAVES
BY
ONE
HALF
SO
T
N
N
N
SINCE
NUMBER
THE
LEFT
OR
RIGHT
LEAVES
CAN
BE
DONE
IN
LOG
N
TIME
USING
THE
EULERIAN
TOUR
TECHNIQUE
A
PROBLEM
THAT
IS
HARD
TO
PARALLELIZE
NO
ONE
KNOWS
A
FAST
PARALLEL
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
KNOWN
AS
THE
CIRCUIT
VALUE
PROBLEM
INPUT
A
BOOLEAN
CIRCUIT
F
CONSISTING
OF
AND
AND
OR
AND
NOT
GATES
AND
ASSIGNMENT
OF
VALUES
TO
THE
INPUT
LINES
OF
THE
CIRCUIT
OUTPUT
IF
THE
CIRCUIT
EVALUATES
TO
BE
TRUE
AND
OTHERWISE
MORE
PRECISELY
NO
ONE
KNOWS
OF
A
PARALLEL
ALGORITHM
THAT
RUNS
IN
TIME
O
LOGKN
FOR
SOME
K
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
HERE
N
IS
THE
SIZE
OF
THE
CIRCUIT
FURTHER
THIS
PROBLEMS
IS
COMPLETE
FOR
POLYNOMIAL
TIME
SEQUENTIAL
ALGORITHMS
IN
THE
SENSE
THAT
IF
THIS
PROBLEM
IS
PARALLELIZABLE
TIME
O
LOGKN
FOR
SOME
K
WITH
A
POLYNOMIAL
NUMBER
OF
PROCESSORS
THEN
ALL
PROBLEMS
THAT
HAVE
POLYNOMIAL
TIME
SEQUENTIAL
ALGORITHMS
ARE
PARALLELIZABLE
DEFINITION
OF
REDUCTION
PROBLEM
A
IS
REDUCIBLE
OR
MORE
TECHNICALLY
TURING
REDUCIBLE
TO
PROBLEM
B
DENOTED
A
B
IF
THERE
A
MAIN
PROGRAM
M
TO
SOLVE
PROBLEM
A
THAT
LACKS
ONLY
A
PROCEDURE
TO
SOLVE
PROBLEM
B
THE
PROGRAM
M
IS
CALLED
THE
REDUCTION
FROM
A
TO
B
NOTE
THAT
WE
USE
THE
BOOK
NOTATION
T
AND
INTERCHANGEABLY
A
IS
POLYNOMIAL
TIME
REDUCIBLE
TO
B
IF
M
RUNS
IN
POLYNOMIAL
TIME
A
IS
LINEAR
TIME
REDUCIBLE
TO
B
IF
M
RUNS
IN
LINEAR
TIME
AND
MAKES
AT
MOST
A
CONSTANT
NUMBER
OF
CALLS
TO
THE
PROCEDURE
FOR
B
ASSUME
THAT
THE
REDUCTION
RUNS
IN
TIME
A
N
EXCLUSIVE
OF
R
N
RECURSIVE
CALLS
TO
B
ON
AN
INPUT
SIZE
OF
N
THEN
IF
ONE
PLUGS
IN
AN
ALGORITHM
FOR
B
THAT
RUNS
IN
TIME
B
N
ONE
GETS
AN
ALGORITHM
FOR
A
THAT
RUNS
IN
TIME
A
N
R
N
B
N
A
DECISION
PROBLEM
IS
A
PROBLEM
WHERE
THE
OUTPUT
IS
LET
A
AND
B
BE
DECISION
PROBLEMS
WE
SAY
A
IS
MANY
TO
ONE
REDUCIBLE
TO
B
IF
THERE
IS
REDUCTION
M
FROM
A
TO
B
OF
FOLLOWING
SPECIAL
FORM
M
CONTAINS
EXACTLY
ONE
CALL
TO
THE
PROCEDURE
FOR
B
AND
THIS
CALL
IS
THE
LAST
STEP
IN
M
M
RETURNS
WHAT
THE
PROCEDURE
FOR
B
RETURNS
EQUIVALENTLY
A
IS
MANY
TO
ONE
REDUCIBLE
TO
B
IF
THERE
EXISTS
A
COMPUTABLE
FUNCTION
F
FROM
INSTANCES
OF
A
TO
INSTANCES
OF
B
SUCH
THAT
FOR
ALL
INSTANCES
I
OF
A
IT
IS
THE
CASE
THAT
I
HAS
OUTPUT
IN
PROBLEM
A
IF
AND
ONLY
IF
F
I
HAS
OUTPUT
IN
PROBLEM
B
REDUCTIONS
CAN
BE
USED
TO
BOTH
FIND
EFFICIENT
ALGORITHMS
FOR
PROBLEMS
AND
TO
PROVIDE
EVIDENCE
THAT
FINDING
PARTICULARLY
EFFICIENT
ALGORITHMS
FOR
SOME
PROBLEMS
WILL
LIKELY
BE
DIFFICULT
WE
WILL
MAINLY
BE
CONCERNED
WITH
THE
LATER
USE
USING
REDUCTIONS
TO
DEVELOP
ALGORITHMS
ASSUME
THAT
A
IS
SOME
NEW
PROBLEM
THAT
YOU
WOULD
LIKE
TO
DEVELOP
AN
ALGO
RITHM
FOR
AND
THAT
B
IS
SOME
PROBLEM
THAT
YOU
ALREADY
KNOW
AN
ALGORITHM
FOR
THEN
SHOWING
A
B
WILL
GIVE
YOU
AN
ALGORITHM
FOR
PROBLEM
A
CONSIDER
THE
FOLLOWING
EXAMPLE
LET
A
BE
THE
PROBLEM
OF
DETERMINING
WHETHER
N
NUMBERS
ARE
DISTINCT
LET
B
BE
THE
SORTING
PROBLEM
ONE
WAY
TO
SOLVE
THE
PROBLEM
A
IS
TO
FIRST
SORT
THE
NUMBERS
USING
A
CALL
TO
A
BLACK
BOX
SORTING
ROUTINE
AND
THEN
IN
LINEAR
TIME
TO
CHECK
WHETHER
ANY
TWO
CONSECUTIVE
NUMBERS
IN
THE
SORTED
ORDER
ARE
EQUAL
THIS
GIVE
AN
ALGORITHM
FOR
PROBLEM
A
WITH
RUNNING
TIME
O
N
PLUS
THE
TIME
FOR
SORTING
IF
ONE
USES
AN
O
N
LOG
N
TIME
ALGORITHM
FOR
SORTING
LIKE
MERGESORT
THEN
ONE
OBTAINS
AN
O
N
LOG
N
TIME
ALGORITHM
FOR
THE
ELEMENT
UNIQUENESS
PROBLEM
USING
REDUCTIONS
TO
SHOW
THAT
A
PROBLEM
IS
HARD
ABSOLUTELY
POSITIVELY
YOU
MUST
READ
THE
FIRST
TWO
PARAGRAPHS
OF
CHAPTER
THIS
EXPLAINS
THE
GENERAL
IDEA
MATRIX
SQUARING
YOU
WANT
TO
FIND
AN
O
TIME
ALGORITHM
TO
SQUARE
AN
N
BY
N
MATRIX
THE
OBVIOUS
ALGORITHM
RUNS
IN
TIME

YOU
KNOW
THAT
LOTS
OF
SMART
COMPUTER
SCIENTISTS
HAVE
TRIED
TO
FIND
AN
O
TIME
ALGORITHM
FOR
MULTIPLY
TWO
MATRICES
BUT
HAVE
NOT
BEEN
SUCCESSFUL
BUT
IT
IS
AT
LEAST
CONCEIVABLE
THAT
SQUARING
A
MATRIX
MULTIPLYING
IDENTICAL
MATRICES
MIGHT
BE
AN
EASIER
PROBLEM
THAN
MULTIPLY
TWO
ARBITRARY
MATRICES
TO
SHOW
THAT
IN
FACT
THAT
MATRIX
SQUARING
IS
NOT
EASIER
THAN
MATRIX
MULTIPLICATION
WE
LINEAR
TIME
REDUCE
MATRIX
MULTIPLICATION
TO
MATRIX
SQUARING
THEOREM
IF
THERE
IS
AN
O
TIME
ALGORITHM
TO
SQUARE
AN
N
BY
N
MATRIX
THEN
THERE
IS
AN
O
TIME
ALGORITHM
TO
MULTIPLY
TWO
ARBITRARY
N
BY
N
MATRICES
PROOF
WE
SHOW
THAT
MATRIX
MULTIPLICATION
IS
LINEAR
TIME
REDUCIBLE
TO
MATRIX
SQUARING
WE
EXHIBIT
THE
FOLLOWING
REDUCTION
PROGRAM
FOR
MATRIX
MULTIPLI
CATION
READ
X
AND
Y
THE
TWO
MATRICES
WE
WISH
TO
MULTIPLY
LET
CALL
PROCEDURE
TO
COMPUTE
I
Y
X
XY
XY
READ
XY
OF
FROM
THE
TOP
LEFT
QUARTER
OF
IF
YOU
PLUG
IN
AN
O
B
N
TIME
ALGORITHM
FOR
SQUARING
THE
RUNNING
TIME
OF
THE
RESULTING
ALGORITHM
FOR
SQUARING
IS
O
B
THUS
AN
O
TIME
ALGORITHM
FOR
SQUARING
YIELDS
AN
O
TIME
ALGORITHM
FOR
MATRIX
MULTIPLICA
TION
END
PROOF
SO
THE
FINAL
CONCLUSION
IS
SINCE
LOTS
OF
SMART
COMPUTER
SCIENTISTS
HAVE
TRIED
TO
FIND
AN
O
TIME
ALGORITHM
FOR
MULTIPLY
TWO
MATRICES
BUT
HAVE
NOT
BEEN
SUCCESSFUL
YOU
PROBABLY
SHOULDN
T
WASTE
A
LOT
OF
TIME
LOOKING
FOR
AN
O
TIME
ALGORITHM
TO
SQUARE
A
MATRIX
CONVEX
HULL
THE
CONVEX
HULL
PROBLEM
IS
DEFINED
BELOW
INPUT
N
POINTS
PN
IN
THE
EUCLIDEAN
PLANE
OUTPUT
THE
SMALLEST
EITHER
AREA
OR
PERIMETER
DOESN
T
MATTER
CONVEX
POLYGON
THAT
CONTAIN
ALL
N
POINTS
THE
POLYGON
IS
SPECIFIED
BY
A
LINEAR
ORDER
ING
OF
ITS
VERTICES
YOU
WOULD
LIKE
TO
FIND
AN
EFFICIENT
ALGORITHM
FOR
THE
CONVEX
HULL
PROBLEM
YOU
KNOW
THAT
LOTS
OF
SMART
COMPUTER
SCIENTISTS
HAVE
TRIED
TO
FIND
AN
A
LINEAR
TIME
ALGORITHM
FOR
SORTING
BUT
HAVE
NOT
BEEN
SUCCESSFUL
WE
WANT
USE
THAT
FACT
TO
SHOW
THAT
IT
WILL
BE
HARD
TO
FIND
A
LINEAR
TIME
ALGORITHM
FOR
THE
CONVEX
HULL
PROBLEM
THEOREM
IF
THERE
IS
AN
O
N
TIME
ALGORITHM
FOR
CONVEX
HULL
THEN
THERE
IS
AN
O
N
TIME
ALGORITHM
FOR
SORTING
PROOF
WE
NEED
TO
SHOW
THAT
SORTING
CONVEX
HULL
VIA
A
LINEAR
TIME
REDUC
TION
CONSIDER
THE
FOLLOWING
REDUCTION
ALGORITHM
FOR
SORTING
READ
XN
LET
PI
XI
AND
PN
CALL
PROCEDURE
TO
COMPUTE
THE
CONVEX
HULL
C
OF
THE
POINTS
PN
IN
LINEAR
TIME
READ
THE
SORTED
ORDER
OF
THE
FIRST
COORDINATES
OFF
OF
C
BY
TRAVERSING
C
COUNTER
CLOCKWISE
IF
YOU
PLUG
IN
AN
O
B
N
TIME
ALGORITHM
FOR
THE
CONVEX
HULL
PROBLEM
THE
RUNNING
TIME
OF
THE
RESULTING
ALGORITHM
FOR
SORTING
IS
O
N
B
N
THUS
AN
O
N
TIME
ALGORITHM
FOR
THE
CONVEX
HULL
PROBLEM
YIELDS
AN
O
N
TIME
ALGORITHM
FOR
MATRIX
MULTIPLICATION
END
PROOF
SO
THE
FINAL
CONCLUSION
IS
SINCE
LOTS
OF
SMART
COMPUTER
SCIENTISTS
HAVE
TRIED
TO
FIND
AN
O
N
TIME
ALGORITHM
FOR
SORTING
BUT
HAVE
NOT
BEEN
SUCCESSFUL
YOU
PROBABLY
SHOULDN
T
WASTE
A
LOT
OF
TIME
LOOKING
FOR
AN
O
N
TIME
ALGORITHM
TO
SOLVE
THE
CONVEX
HULL
PROBLEM
NP
COMPLETE
NP
EQUIVALENT
PROBLEMS
THERE
ARE
A
CLASS
OF
PROBLEM
CALLED
NP
COMPLETE
PROBLEMS
FOR
OUR
PURPOSES
WE
USE
NP
COMPLETE
AND
NP
EQUIVALENT
INTERCHANGEABLY
ALTHOUGH
THERE
IS
A
TECHNICAL
DIFFERENCE
THAT
NOT
REALLY
RELEVANT
TO
US
THE
FOLLOWING
FACTS
ABOUT
THESE
NP
COMPLETE
ARE
RELEVANT
IF
ANY
NP
COMPLETE
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THEY
ALL
DO
ANOTHER
WAY
TO
THINK
OF
THIS
IS
THAT
ALL
PAIRS
OF
NP
COMPLETE
PROBLEMS
ARE
REDUCIBLE
TO
EACH
OTHER
VIA
A
REDUCTION
THAT
RUNS
IN
POLYNOMIAL
TIME
THERE
ARE
THOUSANDS
OF
KNOWN
NATURAL
NP
COMPLETE
PROBLEMS
FROM
EVERY
POSSIBLE
AREA
OF
APPLICATION
THAT
PEOPLE
WOULD
LIKE
TO
FIND
POLY
NOMIAL
TIME
ALGORITHMS
FOR
NO
ONE
KNOWS
OF
A
POLYNOMIAL
TIME
ALGORITHM
FOR
ANY
NP
COMPLETE
PROBLEM
NO
ONE
KNOWS
OF
A
PROOF
THAT
NO
NP
COMPLETE
PROBLEM
CAN
HAVE
A
POLYNOMIAL
TIME
ALGORITHM
ALMOST
ALL
COMPUTER
SCIENTISTS
BELIEVE
THAT
NP
COMPLETE
PROBLEMS
DO
NOT
HAVE
POLYNOMIAL
TIME
ALGORITHMS
A
PROBLEM
L
IS
NP
HARD
IF
A
POLYNOMIAL
TIME
ALGORITHM
FOR
L
YIELDS
A
POLYNOMIAL
TIME
ALGORITHM
FOR
ANY
ALL
NP
COMPLETE
PROBLEM
OR
EQUIVA
LENTLY
IF
THERE
IS
AN
NP
COMPLETE
PROBLEM
C
THAT
POLYNOMIAL
TIME
REDUCES
TO
L
A
PROBLEM
L
IS
NP
EASY
IF
A
POLYNOMIAL
TIME
ALGORITHM
FOR
ANY
NP
COMPLETE
PROBLEM
YIELDS
A
POLYNOMIAL
TIME
ALGORITHM
FOR
L
OR
EQUIVALENTLY
IF
THERE
IS
AN
NP
COMPLETE
PROBLEM
C
SUCH
THAT
L
IS
POLYNOMIAL
TIME
RE
DUCIBLE
TO
C
A
PROBLEM
IS
NP
EQUIVALENT
OR
FOR
US
NP
COMPLETE
IF
IT
IS
BOTH
NP
HARD
AND
NP
EASY
FACT
THE
DECISION
VERSION
OF
THE
CNF
SAT
PROBLEM
DETERMINING
IF
A
SAT
ISFYING
ASSIGNMENT
EXISTS
IS
NP
COMPLETE
SELF
REDUCIBILITY
AN
OPTIMIZATION
PROBLEM
O
IS
POLYNOMIAL
TIME
SELF
REDUCIBLE
TO
A
DECISION
PROBLEM
D
IF
THERE
IS
A
POLYNOMIAL
TIME
REDUCTION
FROM
O
TO
D
ALMOST
ALL
NATURAL
OPTIMIZATION
PROBLEMS
ARE
SELF
REDUCIBLE
HENCE
THERE
IS
NO
GREAT
LOSS
OF
GENERALITY
BY
CONSIDERING
ONLY
DECISION
PROBLEMS
AS
AN
EXAMPLE
WE
NOW
THAT
THE
CNF
SAT
PROBLEM
IS
SELF
REDUCIBLE
THEOREM
IF
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THE
DECISION
VERSION
OF
CNF
SAT
THEN
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
TO
FIND
A
SATISFYING
ASSIGNMENT
PROOF
CONSIDER
THE
FOLLOWING
POLYNOMIAL
TIME
REDUCTION
FROM
THE
PROBLEM
OF
FINDING
A
SATISFYING
ASSIGNMENT
TO
THE
DECISION
VERSION
OF
THE
CNF
SAT
PROBLEM
WE
CONSIDER
A
FORMULA
F
ONE
CALL
TO
THE
PROCEDURE
FOR
THE
DECISION
VERSION
OF
CNF
SAT
WILL
TELL
WHETHER
F
IS
SATISFIABLE
OR
NOT
ASSUMING
THAT
F
IS
SATISFIABLE
THE
FOLLOWING
PROCEDURE
WILL
PRODUCE
A
SATISFYING
ASSIGNMENT
PICK
AN
ARBITRARY
VARIABLE
X
THAT
APPEARS
IN
F
CREATE
A
FORMULA
F
BY
REMOVING
CLAUSES
IN
F
THAT
CONTAIN
THE
LITERAL
X
AND
REMOVING
ALL
OCCURRENCES
OF
THE
LITERAL
X
CALL
A
PROCEDURE
TO
SEE
IF
F
IS
SATISFIABLE
IF
F
IS
SATISFIABLE
MAKE
X
EQUAL
TO
TRUE
AND
RECURSE
ON
F
IF
F
IS
NOT
SATISFIABLE
THEN
CREATE
A
FORMULA
F
BY
REMOVING
CLAUSES
IN
F
THAT
CONTAIN
THE
LITERAL
X
AND
REMOVING
ALL
OCCURRENCES
OF
THE
LITERAL
X
MAKE
X
FALSE
AND
RECURSE
ON
F
END
PROOF
CNF
SAT
CIRCUIT
SATISFIABILITY
AND
ARE
POLYNOMIAL
TIME
EQUIVALENT
THE
CIRCUIT
SATISFIABILITY
PROBLEM
IS
DEFINED
AS
FOLLOWS
INPUT
A
BOOLEAN
CIRCUIT
WITH
AND
OR
AND
NOT
GATES
OUTPUT
IF
THERE
IS
SOME
INPUT
THAT
CAUSES
ALL
OF
THE
OUTPUT
LINES
TO
BE
AND
OTHERWISE
THE
PROBLEM
IS
DEFINED
AS
FOLLOWS
INPUT
A
BOOLEAN
FORMULA
F
IN
CNF
WITH
EXACTLY
LITERALS
PER
CLAUSE
OUTPUT
IF
F
IS
SATISFIABLE
OTHERWISE
THE
CNF
SAT
PROBLEM
IS
DEFINED
AS
FOLLOWS
INPUT
A
BOOLEAN
FORMULA
F
IN
CONJUNCTIVE
NORMAL
FORM
OUTPUT
IF
F
IS
SATISFIABLE
OTHERWISE
WE
WANT
TO
SHOW
THAT
IF
ONE
OF
THESE
PROBLEMS
HAVE
A
POLYNOMIAL
TIME
AL
GORITHM
THAN
THEY
ALL
DO
OBVIOUSLY
IS
POLYNOMIAL
TIME
REDUCIBLE
TO
CNF
SAT
A
BIT
LESS
OBVIOUS
BUT
STILL
EASY
TO
SEE
IS
THAT
CNF
SAT
IS
POLYNOMIAL
TIME
REDUCIBLE
TO
CIRCUIT
SATISFIABILITY
THERE
IS
AN
OBVIOUS
CIR
CUIT
IMMEDIATELY
DERIVABLE
FROM
THE
FORMULA
TO
COMPLETE
THE
PROOF
WE
WILL
SHOW
THAT
CNF
SAT
IS
POLYNOMIAL
TIME
REDUCIBLE
TO
AND
THAT
CIRCUIT
SATISFIABILITY
IS
REDUCIBLE
TO
CNF
SAT
THEOREM
CNF
SAT
IS
POLYNOMIAL
TIME
REDUCIBLE
TO
PROOF
WE
EXHIBIT
THE
FOLLOWING
POLYNOMIAL
TIME
MANY
TO
ONE
REDUCTION
FROM
CNF
SAT
TO
MAIN
PROGRAM
FOR
CNF
SAT
READ
THE
FORMULA
F
CREATE
A
NEW
FORMULA
G
BY
REPLACING
EACH
CLAUSE
C
IN
F
BY
A
COLLECTION
G
C
OF
CLAUSES
WE
GET
SEVERAL
CASES
DEPENDING
ON
THE
NUMBER
OF
LITERALS
IN
C
IF
C
CONTAIN
ONE
LITERAL
X
THEN
G
C
CONTAINS
THE
CLAUSES
X
AC
BC
X
AC
BC
AND
X
AC
BC
X
AC
BC
IF
C
CONTAINS
TWO
LITERALS
X
AND
Y
THEN
G
C
CONTAINS
THE
CLAUSES
X
Y
AC
AND
X
Y
AC
IF
C
CONTAINS
LITERALS
THEN
G
C
C
IF
C
XK
CONTAINS
K
LITERALS
THEN
G
C
CONTAINS
THE
CLAUSES
AND
AC
A
C
AC
A
C
AC
XK
A
C
K
AC
K
XK
XK
AC
K
NOTE
THAT
IN
EACH
CASE
AC
BC
AC
AC
K
ARE
NEW
VARIABLES
THAT
APPEAR
NOWHERE
ELSE
OUTSIDE
OF
G
C
CLEARLY
G
CAN
BE
COMPUTED
IN
POLYNOMIAL
TIME
G
HAS
EXACTLY
LITERALS
PER
CLAUSE
FURTHERMORE
F
IS
SATISFIABLE
IF
AND
ONLY
IF
G
IS
SATISFIABLE
END
PROOF
THIS
TYPE
OF
REDUCTION
IN
WHICH
EACH
PART
OF
THE
INSTANCE
IS
REPLACED
OR
MODIFIED
INDEPENDENTLY
IS
CALLED
LOCAL
REPLACEMENT
THEOREM
CIRCUIT
SATISFIABILITY
IS
POLYNOMIAL
TIME
REDUCIBLE
TO
CNF
SAT
PROOF
THE
MAIN
ISSUE
IS
THAT
THE
FAN
OUT
OF
THE
CIRCUIT
MAY
BE
HIGH
SO
THE
OBVIOUS
REDUCTION
WON
T
WORK
THE
MAIN
IDEA
IS
TO
INTRODUCE
A
NEW
VARIABLE
FOR
EACH
LINE
IN
THE
CIRCUIT
AND
THEN
WRITE
A
CNF
FORMULA
THAT
INSURES
CONSISTENCY
IN
THE
SETTING
OF
THESE
VARIABLES
END
PROOF
VERTEX
COVER
THE
VERTEX
COVER
PROBLEM
IS
DEFINED
AS
FOLLOWS
INPUT
GRAPH
G
AND
INTEGER
K
OUTPUT
IF
G
HAVE
A
VERTEX
COVER
OF
SIZE
K
OR
LESS
A
VERTEX
COVER
IS
A
COLLECTION
OF
VERTICES
SUCH
THAT
EVERY
EDGE
IN
G
IS
INCIDENT
TO
AT
LEAST
ONE
VERTEX
IN
THEOREM
VERTEX
COVER
IS
NP
HARD
PROOF
WE
SHOW
IS
POLYNOMIAL
TIME
MANY
TO
ONE
REDUCIBLE
TO
VERTEX
COVER
GIVEN
THE
FORMULA
F
IN
FORM
WE
CREATE
A
G
AND
A
K
AS
FOLLOWS
FOR
EACH
VARIABLE
X
INF
WE
CREATE
TWO
VERTICES
X
AND
X
AND
CONNECT
THEM
WITH
AN
EDGE
THEN
FOR
EACH
CLAUSE
C
WE
CREATE
THREE
VERTICES
AND
CONNECTED
BY
THREE
EDGES
WE
THEN
PUT
AN
EDGE
BETWEEN
CI
I
AND
THE
VERTEX
CORRESPONDING
TO
THE
ITH
LITERAL
IN
C
LET
K
THE
NUMBER
OF
VARIABLES
IN
F
PLUS
TWICE
THE
NUMBER
OF
CLAUSES
IN
F
WE
NOW
CLAIM
THAT
G
HAS
A
VERTEX
COVER
OF
SIZE
K
IF
AND
ONLY
IF
F
IS
SATISFIABLE
TO
SEE
THIS
NOTE
THAT
A
TRIANGLE
CORRESPONDING
TO
A
CLAUSE
REQUIRES
AT
LEAST
VERTICES
TO
COVER
IT
AND
AND
EDGE
BETWEEN
A
VARIABLE
AND
ITS
NEGATION
REQUIRES
AT
LEAST
VERTEX
SUBSET
SUM
THEOREM
SUBSET
SUM
IS
NP
HARD
PROOF
WE
SHOW
THAT
IS
POLYNOMIAL
TIME
MANY
TO
ONE
REDUCIBLE
TO
SUBSET
SUM
THIS
IS
BY
EXAMPLE
CONSIDER
THE
FORMULA
X
OR
Y
OR
NOT
Z
AND
NOT
X
OR
Y
OR
Z
AND
X
OR
NOT
Y
OR
Z
WE
CREATE
ONE
NUMBER
OF
EACH
VARIABLE
AND
TWO
NUMBERS
FOR
EACH
CLAUSE
AS
FOLLOWS
FURTHER
THE
TARGET
L
IS
SET
AS
SHOWN
NUMBERS
BASE
REPRESENTATION
NAME
L
WHY
THE
DYNAMIC
PROGRAMMING
ALGORITHM
FOR
SUBSET
SUM
IS
NOT
A
POLYNOMIAL
TIME
ALGORITHM
RECALL
THAT
THE
INPUT
SIZE
IS
THE
NUMBER
OF
BITS
REQUIRED
TO
WRITE
DOWN
THE
INPUT
AND
A
POLYNOMIAL
TIME
ALGORITHM
SHOULD
RUN
IN
TIME
BOUNDED
BY
A
POLYNOMIAL
IN
THE
INPUT
SIZE
THE
INPUT
IS
N
INTEGERS
XN
AND
AN
INTEGER
L
THE
INPUTS
SIZE
IS
THEN
WHICH
IS
AT
LEAST
N
L
N
L
XI
I
THE
RUNNING
TIME
OF
THE
ALGORITHM
IS
O
NL
NOTE
THAT
THIS
TIME
ESTIMATE
ASSUMED
THAT
ALL
ARITHMETIC
OPERATIONS
COULD
BE
PERFORMED
IN
CONSTANT
WHICH
MAY
BE
A
BIT
OPTIMISTIC
FOR
SOME
INPUTS
NEVER
THE
LESS
IF
N
IS
CONSTANT
THEN
THE
INPUT
SIZE
I

LOG
L
AND
THE
RUNNING
TIME
IS
L

IS
EXPONENTIAL
IN
THE
INPUT
SIZE
A
MOST
CONCRETE
WAY
TO
SEE
THIS
IS
TO
CONSIDER
AN
INSTANCE
WITH
N
AND
L
THE
INPUT
SIZE
IS
ABOUT
BITS
OR
BYTES
BUT
ANY
ALGORITHM
THAT
REQUIRES
STEPS
IS
NOT
GOING
TO
FINISH
IN
YOUR
LIFE
TIME
COLORING
THE
COLORING
PROBLEM
IS
DEFINED
AS
FOLLOWS
INPUT
GRAPH
G
OUTPUT
IF
THE
VERTICES
OF
G
CAN
BE
COLORED
WITH
COLORS
SO
THAT
NO
PAIR
OF
ADJACENT
VERTICES
ARE
COLORING
THE
SAME
AND
OTHERWISE
THEOREM
COLORING
IS
NP
HARD
PROOF
WE
SHOW
THAT
IS
POLYNOMIAL
TIME
MANY
TO
ONE
REDUCIBLE
TO
COLORING
ONCE
AGAIN
WE
DO
THIS
BY
EXAMPLE
CONSIDER
FORMULA
F
X
OR
Y
OR
NOT
Z
AND
NOT
X
OR
Y
OR
Z
AND
X
OR
NOT
Y
OR
Z
WE
CREATE
THE
GRAPH
G
AS
FOLLOWS
FOR
EACH
VARIABLE
X
IN
F
WE
CREATE
TWO
VERTICES
X
AND
NOT
X
AND
CONNECT
THEM
WE
THEN
CREATE
A
TRIANGLE
WITH
THREE
NEW
VERTICES
TRUE
FALSE
AND
C
AND
CONNECT
C
TO
EACH
LITERAL
VERTEX
SO
FOR
THE
EXAMPLE
ABOVE
WE
WOULD
GET
SOMETHING
LIKE
TRUE
FALSE
WHAT
EVER
COLOR
THIS
IS
WE
CALL
FALSE
VERTEX
C
VERTEX
C
IS
CONNECTED
TO
EACH
OF
THE
LITERAL
VERTICES
X
NOT
X
Y
NOT
Y
Z
NOT
Z
WE
THEN
CREATE
THE
GADGET
SUBGRAPH
SHOWN
IN
FIGURE
FOR
EACH
CLAUSE
LITERAL
LITERAL
C
TRUE
LITERAL
FIGURE
THE
CLAUSE
GADGET
WE
CLAIM
THAT
THIS
CLAUSE
GADGET
CAN
BE
COLORED
IF
AND
ONLY
IF
AT
LEAST
ONE
OF
LITERAL
LITERAL
LITERAL
IS
COLORED
TRUE
HENCE
IT
FOLLOWS
THAT
G
IS
COLORABLE
IF
AND
ONLY
IF
F
IS
SATISFIABLE
THE
FINAL
GRAPH
G
FOR
THE
ABOVE
FORMULA
IS
SHOWN
BELOW
TRUE
FIGURE
THE
FINAL
GRAPH
CS
REDUCTIONS
AND
NP
HARDNESS
HOMEWORK
PROBLEMS
POINTS
A
SQUARE
MATRIX
M
IS
LOWER
TRIANGULAR
IF
EACH
ENTRY
ABOVE
THE
MAIN
DIAGONAL
IS
ZERO
THAT
IS
EACH
ENTRY
MI
J
WITH
I
J
IS
EQUAL
TO
ZERO
SHOW
THAT
IF
THERE
IS
AN
O
TIME
ALGORITHM
FOR
MULTIPLYING
TWO
N
BY
N
LOWER
TRIANGULAR
MATRICES
THEN
THERE
IS
AN
O
TIME
ALGORITHM
FOR
MULTIPLYING
TWO
ARBITRARY
N
BY
N
MATRICES
POINTS
SHOW
THAT
IF
THERE
IS
AN
O
NK
K
TIME
ALGORITHM
FOR
INVERTING
A
NONSINGULAR
N
BY
N
MATRIX
C
THEN
THERE
IS
AN
O
NK
TIME
ALGORITHM
FOR
MULTIPLY
TWO
ARBITRARY
N
BY
N
MATRICES
A
AND
B
FOR
A
SQUARE
MATRIX
A
A
INVERSE
DENOTED
A
IS
THE
UNIQUE
MATRIX
SUCH
THAT
AA
I
WHERE
I
IS
THE
IDENTITY
MATRIX
WITH
ON
THE
MAIN
DIAGONAL
AND
EVERYPLACE
ELSE
NOTE
THAT
NOT
EVERY
SQUARE
MATIX
HAS
AN
INVERSE
E
G
THE
ALL
ZERO
MATRIX
HINT
IF
YOU
WANT
TO
MULTIPLY
N
BY
N
MATRICES
A
AND
B
CONSIDER
THE
MATRIX
C
OF
THE
FOLLOWING
FORM
WHERE
I
IS
THE
N
N
IDENTITY
MATRIX
I
A
I
B
I
POINTS
SHOW
THAT
IF
THERE
IS
AN
O
NK
K
TIME
ALGORITHM
FOR
SQUARING
A
DEGREE
N
POLYNOMIAL
THEN
THERE
IS
AN
O
NK
TIME
ALGORITHM
FOR
MULTIPLYING
TWO
DEGREE
N
POLYNOMIALS
ASSUME
THAT
THE
POLYNOMIALS
ARE
GIVEN
BY
THEIR
COEFFICIENTS
ASSUME
THAT
ALL
COEFFICIENTS
YOU
COMPUTE
CAN
BE
FIT
INTO
ONE
WORD
OF
COMPUTER
MEMORY
POINTS
CONSIDER
THE
FOLLOWING
VARIANT
OF
THE
MINIMUM
STEINER
TREE
PROBLEM
THE
INPUT
IS
N
POINTS
IN
THE
PLANE
EACH
POINT
IS
GIVEN
BY
ITS
CARTESIAN
COORDINATES
THE
PROBLEM
IS
BUILD
A
COLLECTION
OF
ROADS
BETWEEN
THESE
POINTS
SO
THAT
YOU
CAN
REACH
ANY
CITY
FROM
ANY
OTHER
CITY
AND
THE
TOTAL
LENGTH
OF
THE
ROADS
IS
MINIMIZED
THE
COLLECTION
OF
ROADS
SHOULD
BE
OUTPUT
AS
AN
ADJACENCY
LIST
STRUCTURE
THAT
IS
FOR
EACH
POINT
P
OF
INTERSECTION
OF
ROADS
THERE
ARE
A
LIST
OF
ROADS
THAT
MEET
THAT
POINT
ROADS
MUST
TERMINATE
WHEN
THEY
MEET
ONE
OF
THE
ORIGINAL
INPUT
POINTS
OR
WHEN
THEY
MEET
ANOTHER
ROAD
FOR
EXAMPLE
IF
THE
POINTS
ARE
THE
OUTPUT
WOULD
BE
FROM
THE
POINT
THERE
ARE
ROADS
TO
THE
POINTS
AND
FROM
THE
POINT
THERE
ARE
ROADS
TO
AND
FROM
THE
POINT
THERE
IS
A
ROAD
TO
FROM
THE
POINT
THERE
IS
A
ROAD
TO
FROM
THE
POINT
THERE
IS
A
ROAD
TO
ROADS
FROM
TO
AND
FROM
TO
WOULD
NOT
BE
ALLOWED
BECAUSE
THEY
CROSS
A
ROAD
FROM
TO
WOULD
NOT
BE
ALLOWED
SINCE
IT
WOULD
CROSS
THE
POINT
SHOW
BY
REDUCTION
THAT
IF
YOU
CAN
SOLVE
THIS
PROBLEM
IN
LINEAR
TIME
THEN
YOU
CAN
SORT
N
NUMBERS
IN
LINEAR
TIME
POINTS
SHOW
THAT
IF
ONE
OF
THE
FOLLOWING
THREE
PROBLEMS
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THEY
ALL
DO
A
COMBINATORIAL
CIRCUIT
IS
ONE
THAT
DOES
NOT
CONTAIN
DIRECTED
CYCLES
THE
PROBLEM
IS
TO
DETERMINE
WHETHER
A
BOOLEAN
COMBINATORIAL
CIRCUIT
WITH
GATES
NOT
BINARY
AND
AND
BINARY
OR
HAS
SOME
INPUT
THAT
CAUSES
ALL
OF
THE
OUTPUT
LINES
TO
BE
ASSUME
THAT
THE
FAN
OUT
THE
NUMBER
OF
GATES
THAT
THE
OUTPUT
OF
A
SINGLE
GATE
CAN
BE
FED
INTO
OF
THE
GATES
IN
A
CIRCUIT
MAY
BE
ARBITRARY
THE
PROBLEM
IS
TO
DETERMINE
WHETHER
A
BOOLEAN
COMBINATORIAL
CIRCUIT
WITH
GATES
NOT
ARBITRARY
FAN
IN
AND
AND
ARBITRARY
FAN
IN
OR
HAS
SOME
INPUT
THAT
CAUSES
ALL
OF
THE
OUTPUT
LINES
TO
BE
ASSUME
THAT
THE
FAN
OUT
THE
NUMBER
OF
GATES
THAT
THE
OUTPUT
OF
A
SINGLE
GATE
CAN
BE
FED
INTO
OF
THE
GATES
IN
A
CIRCUIT
MAY
BE
ARBITRARY
DETERMINE
WHETHER
A
BOOLEAN
FORMULA
WITH
NOT
BINARY
AND
AND
BINARY
OR
OPERATIONS
IS
SATISFIABLE
MAKE
SURE
TO
STATE
WHAT
REDUCTIONS
YOU
SHOW
EVEN
IF
SOME
OF
THE
REDUCTIONS
ARE
TRIVIAL
HINT
YOU
NEED
TO
SHOW
HOW
TO
SIMULATE
UNBOUNDED
FAN
IN
AND
AND
OR
GATES
WITH
BOUNDED
FAN
IN
AND
AND
OR
GATES
YOU
NEED
TO
SHOW
HOW
TO
TRANSFORM
A
BOOLEAN
FORMULA
INTO
A
CIRCUIT
AND
YOU
NEED
TO
SHOW
HOW
TO
TRANSFORM
A
CIRCUIT
INTO
A
BOOLEAN
FORMULA
THIS
IS
PROBABLY
THE
TRICKIEST
PART
DUE
TO
THE
UNBOUNDED
FAN
OUT
POINTS
SHOW
THAT
IF
ONE
OF
THE
FOLLOWING
THREE
PROBLEMS
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THEY
ALL
DO
THE
INPUT
IS
TWO
UNDIRECTED
GRAPHS
G
AND
H
THE
PROBLEM
IS
TO
DETERMINE
IF
THE
GRAPHS
ARE
ISOMORPHIC
THE
INPUT
IS
TWO
DIRECTED
GRAPHS
G
AND
H
THE
PROBLEM
IS
TO
DETERMINE
IF
THE
GRAPHS
ARE
ISOMORPHIC
THE
INPUT
IS
TWO
UNDIRECTED
GRAPHS
G
AND
H
AND
AN
INTEGER
K
THE
PROBLEM
IS
TO
DETERMINE
IF
THE
GRAPHS
ARE
ISOMORPHIC
AND
ALL
THE
VERTICES
IN
EACH
GRAPH
HAVE
DEGREE
K
INTUITIVELY
TWO
GRAPHS
ARE
ISOMORPHIC
IF
ON
CAN
NAME
LABEL
THE
VERTICES
SO
THAT
THE
GRAPHS
ARE
IDENTICAL
MORE
FORMALLY
TWO
UNDIRECTED
GRAPHS
G
AND
H
ARE
ISOMORPHIC
IF
THERE
IS
A
BIJECTION
F
FROM
THE
VERTICES
OF
G
TO
THE
VERTICES
OF
H
SUCH
THAT
V
W
IS
AN
EDGE
IN
G
IF
AND
ONLY
IF
F
V
F
W
IS
AN
EDGE
IN
H
MORE
FORMALLY
TWO
DIRECTED
GRAPHS
G
AND
H
ARE
ISOMORPHIC
IF
THERE
IS
A
BIJECTION
F
FROM
THE
VERTICES
OF
G
TO
THE
VERTICES
OF
H
SUCH
THAT
V
W
IS
A
DIRECTED
EDGE
IN
G
IF
AND
ONLY
IF
F
V
F
W
IS
A
DIRECTED
EDGE
IN
H
THE
DEGREE
OF
A
VERTEX
IS
THE
NUMBER
OF
EDGES
INCIDENT
TO
THAT
VERTEX
NOTE
THERE
IS
NO
KNOWN
POLYNOMIAL
TIME
ALGORITHM
FOR
THE
GRAPH
ISOMORPHISM
PROBLEM
FOR
REASONS
THAT
ARE
TOO
COMPLICATED
TO
GO
INTO
HERE
IT
IS
UNLIKELY
THAT
THE
GRAPH
ISOMORPHISM
PROBLEM
IS
NP
HARD
BUT
THERE
IS
NO
KNOWN
PROOF
OF
THIS
HINT
IT
IS
STRAIGHT
FORWARD
TO
SOLVE
UNDIRECTED
GRAPH
ISOMORPHISM
USING
A
ROUTINE
FOR
DIRECTED
GRAPH
ISOMORPHISM
THE
OTHER
DIRECTION
IS
NOT
SO
STRAIGHT
FORWARD
YOUR
REDUCTIONS
HERE
PROBABLY
SHOULD
INTRODUCE
SOME
ADDITIONAL
PIECES
TO
THE
GRAPHS
SO
THE
ONLY
POSSIBLE
ISOMORPHISMS
ARE
OF
THE
TYPE
THAT
YOU
SEEK
IN
THE
ORIGINAL
PROBLEM
POINTS
SHOW
THAT
THE
SUBSET
SUM
PROBLEM
IS
SELF
REDUCIBLE
THE
DECISION
PROBLEM
IS
TO
TAKE
A
COLLECTION
OF
POSITIVE
INTEGERS
XN
AND
AN
INTEGER
L
AND
DECIDE
IF
THERE
IS
A
SUBSET
OF
THE
XI
THAT
SUM
TO
L
THE
OPTIMIZATION
PROBLEM
ASKS
YOU
TO
RETURN
THE
ACTUAL
SUBSET
IF
IT
EXITS
SO
YOU
MUST
SHOW
THAT
IF
THE
DECISION
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THE
OPTIMIZATION
PROBLEM
ALSO
HAS
A
POLYNOMIAL
TIME
ALGORITHM
POINTS
THE
INPUT
TO
THE
HAMILTONIAN
CYCLE
PROBLEM
IS
AN
UNDIRECTED
GRAPH
G
THE
PROBLEM
IS
TO
FIND
A
HAMILTONIAN
CYCLE
IF
ONE
EXISTS
A
HAMILTONIAN
CYCLE
IS
A
SIMPLE
CYCLE
THAT
SPANS
G
SHOW
THAT
THE
HAMILTONIAN
CYCLE
PROBLEM
IS
SELF
REDUCIBLE
THAT
IT
SHOW
THAT
IF
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
THAT
DETERMINES
WHETHER
A
GRAPH
HAS
A
HAMILTONIAN
CYCLE
THEN
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
TO
FIND
HAMILTONIAN
CYCLES
POINTS
SHOW
THAT
THE
CLIQUE
PROBLEM
IS
SELF
REDUCIBLE
THE
DECISION
PROBLEM
IS
TO
TAKE
A
GRAPH
G
AND
AN
INTEGER
K
AND
DECIDE
IF
G
HAS
A
CLIQUE
OF
SIZE
K
OR
NOT
THE
OPTIMIZATION
PROBLEM
TAKES
A
GRAPH
G
AND
RETURNS
A
LARGEST
CLIQUE
IN
G
SO
YOU
MUST
SHOW
THAT
IF
THE
DECISION
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THE
OPTIMIZATION
PROBLEM
ALSO
HAS
A
POLYNOMIAL
TIME
ALGORITHM
RECALL
THAT
A
CLIQUE
IS
A
COLLECTION
OF
MUTUALLY
ADJACENT
VERTICES
POINTS
SHOW
THAT
THE
VERTEX
COVER
PROBLEM
IS
SELF
REDUCIBLE
THE
DECISION
PROBLEM
IS
TO
TAKE
A
GRAPH
G
AND
AN
INTEGER
K
AND
DECIDE
IF
G
HAS
A
VERTEX
COVER
OF
SIZE
K
OR
NOT
THE
OPTIMIZATION
PROBLEM
TAKES
A
GRAPH
G
AND
RETURNS
A
SMALLEST
VERTEX
COVER
IN
G
SO
YOU
MUST
SHOW
THAT
IF
THE
DECISION
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THE
OPTIMIZATION
PROBLEM
ALSO
HAS
A
POLYNOMIAL
TIME
ALGORITHM
RECALL
THAT
A
VERTEX
COVER
IS
A
COLLECTION
OF
VERTICES
WITH
THE
PROPERTY
THAT
EVERY
EDGE
IS
INCIDENT
TO
A
VERTEX
IN
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
INPUT
A
UNDIRECTED
GRAPH
G
AND
AN
INTEGER
K
OUTPUT
IF
G
HAS
TWO
VERTEX
DISJOINT
CLIQUES
OF
SIZE
K
AND
OTHERWISE
SHOW
THAT
THIS
PROBLEM
IS
N
P
HARD
USE
THE
FACT
THAT
THE
CLIQUE
PROBLEM
IN
N
P
COMPLETE
THE
INPUT
TO
THE
CLIQUE
PROBLEM
IS
AN
UNDIRECTED
GRAPH
H
AND
AN
INTEGER
J
THE
OUTPUT
SHOULD
BE
IF
H
CONTAINS
A
CLIQUE
OF
SIZE
J
AND
OTHERWISE
NOTE
THAT
A
CLIQUE
IS
A
MUTUALLY
ADJACENT
COLLECTION
OF
VERTICES
TWO
CLIQUES
ARE
DISJOINT
IF
THEY
DO
NOT
SHARE
ANY
VERTICES
IN
COMMON
POINTS
FOR
EACH
OF
THE
FOLLOWING
PROBLEMS
EITHER
PROVE
THAT
IT
IS
NP
HARD
BY
REDUCTION
FROM
EITHER
THE
STANDARD
CLIQUE
PROBLEM
OR
FROM
THE
STANDARD
INDEPENDENT
SET
PROBLEM
OR
FROM
ONE
OF
THE
PREVIOUS
SUBPROBLEMS
OR
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
SOME
OF
THE
REDUCTIONS
WILL
BE
TRIVIAL
AND
ITS
OK
TO
DISPOSE
OF
THESE
PROBLEMS
WITH
A
SENTENCE
OR
TWO
EXPLAINING
WHY
THE
REDUCTION
IS
EASY
THE
INPUT
IS
AN
UNDIRECTED
GRAPH
G
LET
N
BE
THE
NUMBER
OF
VERTICES
IN
G
THE
PROBLEM
IS
TO
DETERMINE
IF
G
CONTAINS
A
CLIQUE
OF
SIZE
RECALL
THAT
A
CLIQUE
IS
A
COLLECTION
OF
MUTUALLY
ADJACENT
VERTICES
THE
INPUT
IS
AN
UNDIRECTED
GRAPH
G
LET
N
BE
THE
NUMBER
OF
VERTICES
IN
G
THE
PROBLEM
IS
TO
DETERMINE
IF
G
CONTAINS
AN
INDEPENDENT
SET
OF
SIZE
RECALL
THAT
AN
INDEPENDENT
SET
IS
A
COLLECTION
OF
MUTUALLY
NONADJACENT
VERTICES
THE
INPUT
IS
AN
UNDIRECTED
GRAPH
G
AND
AN
INTEGER
K
THE
PROBLEM
IS
TO
DETERMINE
IF
G
CONTAINS
A
CLIQUE
OF
SIZE
K
AND
AN
INDEPENDENT
SET
OF
SIZE
K
THE
INPUT
IS
AN
UNDIRECTED
GRAPH
G
AND
AN
INTEGER
K
THE
PROBLEM
IS
TO
DETERMINE
IF
G
CONTAINS
A
CLIQUE
OF
SIZE
K
OR
AN
INDEPENDENT
SET
OF
SIZE
K
THE
INPUT
IS
AN
UNDIRECTED
GRAPH
G
LET
N
BE
THE
NUMBER
OF
VERTICES
IN
G
THE
PROBLEM
IS
TO
DETERMINE
IF
G
CONTAINS
A
CLIQUE
OF
SIZE
AND
AN
INDEPENDENT
SET
OF
SIZE
THE
INPUT
IS
AN
UNDIRECTED
GRAPH
G
LET
N
BE
THE
NUMBER
OF
VERTICES
IN
G
THE
PROBLEM
IS
TO
DETERMINE
IF
G
CONTAINS
A
CLIQUE
OF
SIZE
OR
AN
INDEPENDENT
SET
OF
SIZE
POINTS
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
IS
A
COLLECTION
OF
LINEAR
INEQUALITIES
FOR
EXAMPLE
THE
INPUT
MIGHT
LOOK
LIKE
X
X
Y
THE
PROBLEM
IS
TO
DETERMINE
IF
THERE
IS
AN
INTEGER
SOLUTION
THAT
SIMULTANEOUSLY
SATISFIES
ALL
THE
INEQUAL
ITIES
SHOW
THAT
THIS
PROBLEM
IS
NP
HARD
USING
THE
FACT
THAT
IT
IS
NP
HARD
TO
DETERMINE
IF
A
BOOLEAN
FORMULA
IN
CONJUNCTIVE
NORMAL
FORM
IS
SATISFIABLE
POINTS
THE
INPUT
TO
THE
THREE
COLORING
PROBLEM
IS
A
GRAPH
G
AND
THE
PROBLEM
IS
TO
DECIDE
WHETHER
THE
VERTICES
OF
G
CAN
BE
COLORED
WITH
THREE
COLORS
SUCH
THAT
NO
PAIR
OF
ADJACENT
VERTICES
ARE
COLORED
THE
SAME
COLOR
THE
INPUT
TO
THE
FOUR
COLORING
PROBLEM
IS
A
GRAPH
G
AND
THE
PROBLEM
IS
TO
DECIDE
WHETHER
THE
VERTICES
OF
G
CAN
BE
COLORED
WITH
FOUR
COLORS
SUCH
THAT
NO
PAIR
OF
ADJACENT
VERTICES
ARE
COLORED
THE
SAME
COLOR
SHOW
BY
REDUCTION
THAT
IF
THE
FOUR
COLORING
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
SO
DOES
THE
THREE
COLORING
PROBLEM
POINTS
SHOW
BY
REDUCTION
THAT
IF
THE
DECISION
VERSION
OF
THE
SAT
CNF
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THE
DECISION
VERSION
OF
THE
COLORING
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
HINT
GIVEN
A
GRAPH
YOU
NEED
TO
WRITE
A
BOOLEAN
FORMULA
IN
CONJUNCTIVE
NORMAL
FORM
THAT
EXPRESSES
THE
FACT
THAT
THE
GRAPH
IS
COLORABLE
POINTS
IN
THE
DOMINATING
SET
PROBLEM
THE
INPUT
IS
AN
UNDIRECTED
GRAPH
G
THE
PROBLEM
IS
TO
FIND
THE
SMALLEST
DOMINATING
SET
IN
G
A
DOMINATING
SET
IS
A
COLLECTION
OF
VERTICES
WITH
THE
PROPERTY
THAT
EVERY
VERTEX
V
IN
G
IS
EITHER
IN
OR
THERE
IS
AN
EDGE
BETWEEN
A
VERTEX
IN
AND
V
SHOW
THAT
THE
DOMINATING
SET
PROBLEM
IS
N
P
HARD
USING
A
REDUCTION
FROM
THE
VERTEX
COVER
PROBLEM
HINT
LOCAL
REPLACEMENT
WILL
WORK
POINTS
THE
INPUT
TO
THE
FIXED
HAMILTONIAN
PATH
PROBLEM
IS
AN
UNDIRECTED
GRAPH
G
AND
TWO
DIFFERENT
VERTICES
X
AND
Y
IN
G
THE
PROBLEM
IS
TO
DETERMINE
IF
THERE
IS
A
SIMPLE
PATH
BETWEEN
X
AND
Y
IN
G
THAT
SPANS
ALL
THE
VERTICES
IN
G
A
PATH
IS
SIMPLE
IF
IT
DOESN
T
INCLUDE
ANY
VERTEX
MORE
THAN
ONCE
SHOW
THAT
IF
THE
FIXED
HAMILTONIAN
PATH
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
THEN
THE
HAMILTONIAN
CYCLE
PROBLEM
HAS
A
POLYNOMIAL
TIME
ALGORITHM
RECALL
THAT
THE
HAMILTONIAN
CYCLE
PROBLEM
IS
TO
DETERMINE
WHETHER
A
GRAPH
HAS
A
SIMPLE
CYCLE
THAT
SPANS
THE
VERTICES
HINT
I
THINK
IT
IS
EASIER
TO
DO
THIS
PROBLEM
IF
YOU
DON
T
RESTRICT
YOURSELF
TO
ONE
PROCEDURE
CALL
TO
THE
PATH
PROBLEM
THAT
IS
FEEL
FREE
TO
CALL
THE
PATH
PROCEDURE
MULTIPLE
TIMES
POINTS
EXTRA
CREDIT
IF
YOUR
CYCLE
CODE
ONLY
MAKES
ONE
PROCEDURE
CALL
TO
THE
PATH
CODE
POINTS
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
A
GRAPH
G
V
E
A
SUBSET
R
OF
VERTICES
OF
G
AND
A
POSITIVE
INTEGER
K
THE
PROBLEM
IS
TO
DETERMINE
IF
THERE
IS
A
SUBSET
U
OF
V
SUCH
THAT
ALL
THE
VERTICES
IN
R
ARE
CONTAINED
IN
U
AND
THE
NUMBER
OF
VERTICES
IN
U
IS
AT
MOST
K
AND
FOR
EVERY
PAIR
OF
VERTICES
X
AND
Y
IN
R
ONE
CAN
WALK
FROM
X
TO
Y
IN
G
ONLY
TRAVERSING
VERTICES
THAT
ARE
IN
U
SHOW
THAT
THIS
PROBLEM
IS
NP
HARD
USING
A
REDUCTION
FROM
VERTEX
COVER
RECALL
THAT
THE
INPUT
FOR
THE
VERTEX
COVER
PROBLEM
IS
A
GRAPH
H
AND
AN
INTEGER
F
AND
THE
PROBLEM
IS
TO
DETERMINE
WHETHER
H
HAS
A
VERTEX
COVER
OF
SIZE
F
OR
NOT
A
VERTEX
COVER
IS
A
COLLECTION
OF
VERTICES
WITH
THE
PROPERTY
THAT
EVERY
EDGE
IS
INCIDENT
ON
AT
LEAST
ONE
VERTEX
IN
HINT
LET
H
F
BE
THE
GRAPH
AND
INTEGER
PAIR
INSTANCE
FOR
VERTEX
COVER
HAVE
R
CONSIST
OF
A
SINGLE
SOURCE
VERTEX
PLUS
ONE
VERTEX
FOR
EACH
EDGE
IN
H
NOW
HAVE
ONE
MORE
VERTEX
IN
G
BUT
NOT
IN
R
FOR
EACH
VERTEX
IN
H
NOW
ADD
EDGES
TO
G
SO
THAT
YOU
CAN
CONNECT
THE
VERTICES
IN
R
USING
FEW
ADDITIONAL
VERTICES
IF
AND
ONLY
IF
H
HAS
A
VERTEX
COVER
OF
SIZE
F
POINTS
IN
THE
DISJOINT
PATHS
PROBLEM
THE
INPUT
IS
A
DIRECTED
GRAPH
G
AND
PAIRS
SK
TK
OF
VERTICES
THE
PROBLEM
IS
TO
DETERMINE
IF
THERE
EXIST
A
COLLECTION
OF
VERTEX
DISJOINT
PATHS
BETWEEN
THE
PAIRS
OF
VERTICES
FROM
EACH
SI
TO
EACH
TI
SHOW
THAT
THIS
PROBLEM
IS
N
P
HARD
BY
A
REDUCTION
FROM
THE
PROBLEM
NOTE
THAT
THIS
PROBLEM
IS
NOT
EASY
HINT
CONSTRUCT
ONE
PAIR
SI
TI
FOR
EACH
VARIABLE
XI
IN
YOUR
FORMULA
F
INTUITIVELY
THERE
WILL
BE
TWO
POSSIBLE
PATHS
BETWEEN
SI
AND
TI
DEPENDING
ON
WHETHER
XI
IS
TRUE
OR
FALSE
THERE
WILL
BE
A
COMPONENT
SUBGRAPH
DJ
OF
G
FOR
EACH
CLAUSE
CJ
IN
F
THERE
WILL
BE
THREE
POSSIBLE
PATHS
BETWEEN
THE
SI
TI
PAIRS
FOR
EACH
DJ
YOU
WANT
THAT
IT
IS
POSSIBLE
TO
ROUTE
ANY
TWO
OF
THESE
PATHS
BUT
NOT
ALL
THREE
THROUGH
DJ
POINTS
THE
INPUT
TO
THE
TRIANGLE
PROBLEM
IS
A
SUBSET
W
OF
THE
CARTESIAN
PRODUCT
X
Y
Z
OF
SETS
X
Y
AND
Z
EACH
OF
CARDINALITY
N
THE
PROBLEM
IS
TO
DETERMINE
IF
THERE
IS
A
SUBSET
U
OF
W
SUCH
THAT
EVERY
ELEMENT
OF
X
IS
IN
EXACTLY
ONE
ELEMENT
OF
U
EVERY
ELEMENT
OF
Y
IS
IN
EXACTLY
ONE
ELEMENT
OF
U
AND
EVERY
ELEMENT
OF
Z
IS
IN
EXACTLY
ONE
ELEMENT
OF
U
HERE
A
STORY
VERSION
OF
THE
SAME
PROBLEM
YOU
HAVE
DISJOINT
COLLECTIONS
OF
N
PILOTS
N
COPILOTS
AND
N
FLIGHT
ENGINEERS
FOR
EACH
POSSIBLE
TRIPLE
OF
PILOT
COPILOT
AND
FLIGHT
ENGINEER
YOU
KNOW
IF
THESE
THREE
PEOPLE
ARE
COMPATIBLE
OR
NOT
YOU
GOAL
IS
TO
DETERMINE
IF
YOU
CAN
ASSIGN
THESE
PEOPLE
TO
N
FLIGHTS
SO
THAT
EVERY
FLIGHT
HAS
ONE
PILOT
ONE
COPILOT
AND
ONE
FLIGHT
ENGINEER
THAT
ARE
COMPATIBLE
SHOW
THAT
THIS
PROBLEM
IS
NP
HARD
USING
A
REDUCTION
FROM
HINT
CONSIDER
A
CYCLIC
COLLECTION
OF
AN
EVEN
NUMBER
OF
TRIANGLES
WHERE
CONSECUTIVE
TRIANGLES
IN
THIS
CYCLE
SHARE
A
SINGLE
COMMON
ELEMENT
THESE
SHARED
COMMON
ELEMENTS
ARE
ALTERNATELY
X
AND
Y
SO
TO
COVER
ALL
THESE
X
AND
Y
ELEMENTS
YOU
EITHER
NEED
TO
PICK
ALL
THE
ODD
TRIANGLES
IN
THE
CYCLE
OR
ALL
THE
EVEN
TRIANGLES
IN
THE
CYCLE
NOW
AS
A
WARMUP
ASSUME
THAT
YOU
ARE
REDUCING
FROM
THE
PROBLEM
OF
DECIDING
WHERE
THERE
IS
A
TRUTH
ASSIGNMENT
THAT
MAKES
EXACTLY
ONE
LITERAL
PER
CLAUSE
TRUE
AND
THAT
YOU
KNOW
THAT
THE
NUMBER
OF
OCCURRENCES
OF
EACH
LITERAL
X
IS
EQUAL
TO
THE
NUMBER
OF
OCCURRENCES
OF
THE
LITERAL
NOT
X
ONCE
YOU
SEE
THIS
YOU
CAN
NOW
TRY
TO
FIGURE
OUT
HOW
TO
MODIFY
THIS
TO
FIX
THE
ISSUES
THAT
YOU
CAN
HAVE
MORE
THAN
ONE
LITERAL
PER
CLAUSE
BEING
TRUE
AND
THE
NUMBER
OF
OCCURRENCES
OF
A
LITERAL
AND
ITS
NEGATION
MAY
NOT
BE
THE
SAME
POINTS
WE
CONSIDER
THE
FOLLOWING
MEDICAL
TESTING
PROBLEM
THE
INPUT
CONSISTS
A
SET
A
OF
POSSIBLE
DISEASES
A
COLLECTION
TK
OF
MEDICAL
TESTS
WITH
BINARY
OUTCOMES
EACH
MEDICAL
TEST
IS
A
FUNCTION
FROM
A
TO
IF
TEST
TI
IS
APPLIED
TO
SOMEONE
WITH
A
DISEASE
A
A
THEN
THE
MEDICAL
TEST
RETURNS
THE
OUTCOME
TI
A
WHICH
IS
EITHER
OR
THINK
OF
TEST
AS
BEING
ABLE
TO
DISTINGUISH
BETWEEN
A
DISEASES
A
AND
B
WHERE
THE
TESTS
OUTCOMES
ARE
DIFFERENT
SO
FOR
EXAMPLE
ONE
TEST
COULD
BE
TO
DETERMINE
IF
A
PATIENT
HAS
AN
ELEVATED
TEMPERATURE
SUCH
A
TEST
COULD
DIFFERENTIATE
BETWEEN
A
DISEASE
WHERE
AN
ELEVATED
TEMPERATURE
IS
A
SYMPTOM
AND
A
DISEASE
WHERE
AN
ELEVATED
TEMPERATURE
IS
NOT
A
SYMPTOM
INTEGER
J
IT
IS
ONLY
INTERESTING
IF
J
K
THE
DR
CUDDY
PROBLEM
IS
TO
DETERMINE
WHETHER
THERE
IS
A
COLLECTION
OF
J
TESTS
SUCH
THAT
FOR
ALL
DISEASES
A
AND
B
THERE
IS
A
TEST
IN
THAT
CAN
DISTINGUISH
BETWEEN
A
AND
B
SHOW
THAT
THE
DR
CUDDY
PROBLEM
IS
N
P
HARD
BY
REDUCTION
FROM
THE
TRIANGLE
PROBLEM
DEFINED
IN
THE
PREVIOUS
PROBLEM
HINT
LOCAL
REPLACEMENT
WILL
WORK
POINTS
WE
CONSIDER
A
GENERALIZATION
OF
THE
FOX
GOOSE
AND
BAG
OF
BEANS
PUZZLE
WIKIPEDIA
ORG
WIKI
FOX
THE
INPUT
IS
A
GRAPH
G
AN
INTEGER
K
THE
VERTICES
OF
G
ARE
OBJECTS
THAT
THE
FARMER
HAS
TO
TRANSPORT
OVER
THE
RIVER
THERE
ARE
AN
EDGE
BETWEEN
TWO
OBJECTS
IF
THEY
CAN
NOT
BE
LEFT
ALONE
TOGETHER
ON
THE
SAME
SIZE
OF
THE
RIVER
THE
GOAL
IS
TO
DETERMINE
IF
A
BOAT
OF
SIZE
K
IS
SUFFICIENT
TO
SAFELY
TRANSPORT
THE
OBJECTS
ACROSS
THE
RIVER
THE
SIZE
OF
THE
BOAT
IS
THE
NUMBER
OF
OBJECTS
THAT
THE
FARMER
CAN
HAUL
IN
THE
BOAT
SHOW
THAT
THIS
PROBLEM
IS
NP
HARD
USING
A
REDUCTION
FROM
ONE
OF
THE
PROBLEMS
THAT
EITHER
I
SHOWED
WAS
NP
HARD
IN
CLASS
OR
THAT
YOU
SHOWED
WAS
NP
HARD
IN
THE
HOMEWORK
SO
I
AM
LETTING
YOU
PICK
THE
PROBLEM
TO
REDUCE
FROM
HERE
YOU
SHOULD
TAKE
SOME
TIME
TO
REFLECT
WHICH
PROBLEM
WOULD
BE
EASIEST
TO
REDUCE
FROM
POINTS
PROVE
THAT
THE
FOLLOWING
PROBLEM
IS
NP
HARD
BY
REDUCTION
FROM
THE
INPUT
CONSISTS
OF
A
FINITE
SET
AND
A
COLLECTION
C
OF
SUBSETS
OF
THE
PROBLEM
IS
TO
DETERMINE
IF
THERE
IS
A
PARTITION
OF
INTO
TWO
SUBSETS
AND
SUCH
THAT
NO
SET
D
C
IS
ENTIRELY
CONTAINED
IN
EITHER
OR
HINT
YOU
WILL
SURELY
NEED
TO
DO
A
COMPONENT
DESIGN
PROBLEM
TO
REDUCE
THE
PROBLEM
OF
MULTIPLYING
N
N
MATICES
A
AND
B
TO
THE
PROBLEM
OF
MULTIPLYING
TWO
LOWER
TRIANGULAR
MATRICES
C
AND
D
SIMPLY
CREATE
A
MATRIX
C
D
B
A
THEN
WE
HAVE
THE
MATRIX
AB
CAN
EASILY
BE
OBTAINED
BY
ISOLATING
THE
LOWER
LEFT
CORNER
OF
THE
PRODUCT
MATRIX
PROBLEM
TO
REDUCE
THE
PROBLEM
OF
MULTIPLYING
N
N
MATICES
TO
THE
PROBLEM
OF
INVERTING
A
SINGLE
MATRIX
CONSTRUCT
A
MATRIX
C
OF
THE
FOLLOWING
FORM
I
A
I
B
I
WHERE
I
IS
THE
N
N
IDENTITY
MATRIX
BY
INVERTING
C
WE
GET
I
A
I
B
I
I
A
AB
I
B
I
AB
CAN
BE
EASILY
OBTAINED
BY
EXTRACTING
THE
UPPER
RIGHT
CORNER
OF
C
PROBLEM
TO
REDUCE
THE
PROBLEM
OF
SORTING
N
NUMBERS
TO
THE
MINIMUM
STEINER
TREE
PROBLEM
TAKE
THE
NUMBERS
XN
TO
SORT
AND
CREATE
THE
POINTS
XN
IN
THE
PLANE
THE
MINIMUM
STEINER
TREE
OF
THESE
POINTS
IS
THE
TREE
THAT
CONTAINS
XN
IN
ORDER
PROBLEM
SHOW
THAT
POLYMULT
POLYSQUARE
USING
THE
IDENTITY
A
B
WE
HAVE
AB
A
B
PROCEDURE
POLYMULT
READ
A
AND
B
X
POLYSQUARE
A
B
Y
POLYSQUARE
A
Z
POLYSQUARE
B
AB
X
Y
Z
THE
TIME
FOR
PROCEDURE
POLYMULT
IS
THE
TIME
FOR
PROCEDURE
POLYSQUARE
PLUS
O
N
PROBLEM
NO
SOLUTION
GIVEN
PROBLEM
TO
REDUCE
THE
CLIQUE
PROBLEM
TO
THE
PROBLEM
CREATE
A
NEW
GRAPH
G
BY
ADDING
A
K
VERTEX
CLIQUE
TO
G
DO
NOT
CONNECT
ANY
OF
THE
VERTICES
IN
THE
NEW
CLIQUE
TO
ANY
OF
THE
VETICES
OF
THE
ORIGINAL
GRAPH
CALL
THE
PROCEDURE
FOR
ON
G
A
WILL
BE
RETURNED
IF
AND
ONLY
IF
G
HAS
A
CLIQUE
OF
SIZE
K
PROBLEM
NO
SOLUTION
GIVEN
PROBLEM
TO
REDUCE
THE
PROBLEM
OF
FINDING
A
HAMILTONIAN
CYCLE
IN
A
GRAPH
G
TO
THE
PROBLEM
OF
DETERMINING
WHETHER
ONE
EXISTS
CREATE
GRAPH
G
BY
REMOVING
AN
ARBITRARY
EDGE
X
Y
CALL
THE
HAM
DECISION
ALGORITHM
ON
BOTH
G
AND
G
IF
THERE
IS
A
HAMILTONIAN
CYCLE
IN
BOTH
RECURSE
ON
G
IF
THERE
IS
A
HAMILTONIAN
CYCLE
IN
G
BUT
NOT
G
THEN
WE
KNOW
X
Y
IS
IN
THE
HAMILTONIAN
CYCLE
RECURSE
ON
G
TAKING
CARE
NOT
TO
SELECT
EDGE
X
Y
AGAIN
PROBLEM
THIS
SOLUTION
WAS
ADAPTED
FROM
MIGUEL
DICKSON
AND
ERIC
WIEGANDT
HOMEWORK
WRITEUP
WE
WILL
PROVE
THAT
DETERMINING
IF
GRAPH
G
CONTAINS
A
CLIQUE
OF
SIZE
WHERE
N
IS
THE
NUMBER
OF
VERTICES
IN
G
IS
NP
HARD
WE
WILL
SHOW
THAT
CLIQUE
CLIQUE
THE
INPUT
TO
THE
CLIQUE
PROBLEM
IS
GRAPH
H
AND
INTEGER
K
WE
NEED
TO
TRANSFORM
THESE
INPUTS
INTO
THE
INPUT
FOR
CLIQUE
A
SINGLE
GRAPH
G
THERE
ARE
THREE
CASES
IN
WHICH
P
WILL
REPRESENT
THE
NUMBER
OF
VERTICES
IN
H
K
THIS
CASE
IS
TRIVIAL
H
REQUIRES
NO
TRANSFORMATION
AND
THE
OUTPUT
TO
THE
PROBLEM
IS
THE
SAME
AS
THE
OUTPUT
TO
THE
CLIQUE
PROBLEM
K
TO
TRANSFORM
H
INTO
A
SUITABLE
INPUT
FOR
THE
CLIQUE
PROBLEM
ADD
VERTICES
TO
H
UNTIL
K
THESE
VERTICES
HAVE
NO
EDGES
CONNECTED
TO
THEM
SO
THEY
CANNOT
BE
PART
OF
A
CLIQUE
THUS
THERE
WILL
BE
A
CLIQUE
OF
SIZE
K
IN
THIS
NEW
GRAPH
IF
AND
ONLY
IF
THERE
WAS
A
CLIQUE
OF
SIZE
K
IN
H
K
THIS
IS
THE
MOST
COMPLICATED
CASE
WE
CANNOT
TAKE
VERTICES
OUT
OF
H
WITHOUT
POTENTIALLY
CHANGING
AN
EXISTING
CLIQUE
SO
WE
MUST
ADD
VERTICES
AND
EDGES
TO
H
WE
WILL
ADD
X
VERTICES
TO
H
CONNECTING
EACH
ADDED
VERTEX
TO
EVERY
VERTEX
ALREADY
IN
H
THESE
VERTICES
WILL
FORM
A
CLIQUE
OF
SIZE
X
AND
CAN
ALSO
BE
PART
OF
ANY
EX
ISTING
CLIQUE
AS
EVERY
VERTEX
ADDED
IS
MUTUALLY
ADJACENT
TO
ALL
OTHER
VERTICES
ADDED
AND
ALL
VERTICES
IN
THE
EXISTING
CLIQUE
IN
OUR
NEW
GRAPH
THERE
WILL
BE
A
CLIQUE
OF
SIZE
X
K
IF
AND
ONLY
IF
THERE
WAS
A
CLIQUE
OF
SIZE
K
IN
H
WE
WILL
USE
THE
FOLLOWING
EQUATION
TO
DEFINE
X
P
X
K
X
WHICH
SIMPLIFIES
TO
X
PROGRAM
TRANSFORM
GRAPH
H
INT
K
INT
P
OF
VERTICES
IN
H
IF
K
RETURN
H
ELSE
IF
K
INT
X
K
P
G
H
WITH
X
VERTICES
AND
NO
EDGES
ADDED
RETURN
G
ELSE
IF
K
INT
X
G
H
WITH
X
VERTICES
ADDED
AND
EDGES
CONNECTING
EACH
NEW
VERTEX
TO
ALL
OTHER
VERTICES
RETURN
G
THE
CODE
FOR
THE
CLIQUE
PROBLEM
IS
NOW
SIMPLE
PROGRAM
CLIQUE
GRAPH
H
INT
K
GRAPH
G
TRANSFORM
H
K
RETURN
CLIQUE
G
THE
PROOF
THAT
THE
PROBLEM
OF
DETERMINING
IF
GRAPH
G
WITH
N
VERTICES
HAS
AN
INDEPENDENT
SET
OF
SIZE
IS
VERY
SIMILAR
TO
THE
PROOF
IN
PART
A
WE
WILL
SHOW
THAT
INDEPENDENT
SET
INDEPENDENT
SET
GRAPH
H
AND
INTEGER
K
ARE
THE
INPUTS
TO
THE
INDEPENDENT
SET
PROBLEM
LET
P
BE
THE
NUMBER
OF
VERTICES
IN
H
THERE
ARE
THREE
CASES
TO
TRANS
FORMING
H
AND
K
INTO
AN
INPUT
FOR
THE
INDEPENDENT
SET
PROBLEM
K
NO
TRANSFORMATION
IS
NEEDED
THE
OUTPUT
TO
THE
P
INDEPENDENT
SET
PROBLEM
WITH
INPUT
H
IS
THE
SAME
AS
THE
OUTPUT
TO
THE
INDEPENDENT
SET
PROBLEM
WITH
INPUT
H
AND
K
K
WE
WANT
TO
ADD
VERTICES
TO
H
UNTIL
K
WE
DO
NOT
WANT
THESE
VERTICES
TO
BE
PART
OF
ANY
INDEPENDENT
SET
WE
NEED
TO
ADD
K
P
VERTICES
TO
H
ALONG
WITH
EDGES
CONNECTING
EACH
OF
THE
NEW
VERTICES
TO
EVERY
OTHER
VERTEX
THIS
WILL
ENSURE
THAT
NO
NEW
VERTEX
CAN
BE
PART
OF
AN
INDEPENDENT
SET
AND
THIS
NEW
GRAPH
WILL
HAVE
AN
INDEPENDENT
SET
OF
SIZE
K
IF
AND
ONLY
IF
H
HAS
AN
INDEPENDENT
SET
OF
SIZE
K
K
WE
NEED
TO
ADD
VERTICES
TO
H
SO
THAT
THE
INDEPEN
DENT
SET
PROBLEM
WILL
OUTPUT
TRUE
IF
AND
ONLY
IF
H
HAS
AN
INDPENDENT
SET
OF
SIZE
K
LET
X
ADD
X
VERTICES
TO
H
AND
NO
EDGES
IN
THIS
NEW
GRAPH
THERE
WILL
BE
AN
INDEPENDENT
SET
OF
SIZE
X
THESE
NEW
VERTICES
CAN
BE
PART
OF
ANY
INDEPENDENT
SET
AS
THEY
ARE
NOT
MUTUALLY
ADJACENT
TO
ANY
OTHER
VERTEX
THUS
THE
NEW
GRAPH
WILL
HAVE
AN
IN
DEPENDENT
SET
OF
SIZE
X
K
IF
AND
ONLY
IF
H
HAS
AN
INDEPENDENT
SET
OF
SIZE
K
THE
CLIQUE
PROBLEM
WILL
OUTPUT
IF
THE
NEW
GRAPH
HAS
AN
INDEPENDENT
SET
OF
SIZE
X
K
AS
THIS
PROBLEM
WILL
OUPUT
WHETHER
OR
NOT
THE
GRAPH
HAS
AN
INDEPENDENT
SET
OF
SIZE
AS
P
X
K
X
PROGRAM
TRANSFORM
GRAPH
H
INT
K
INT
P
OF
VERTICES
IN
H
IF
K
RETURN
H
ELSE
IF
K
INT
X
K
P
G
H
WITH
X
VERTICES
ADDED
AND
EDGES
CONNECTING
EACH
NEW
VERTEX
TO
ALL
OTHER
VERTICES
RETURN
G
ELSE
IF
K
INT
X
G
H
WITH
X
VERTICES
AND
NO
EDGES
ADDED
RETURN
G
PROGRAM
INDEPENDENTSET
GRAPH
H
INT
K
GRAPH
G
TRANSFORM
H
K
RETURN
INDEPENDENTSET
G
IF
K
NUM
VERTICES
G
THEN
G
CANNOT
CONTAIN
A
CLIQUE
OF
SIZE
K
AND
AN
INDEPENDENT
SET
OF
SIZE
K
SINCE
BY
THE
PIGEONHOLE
PRINCIPLE
SOME
OF
THE
REQUIRED
VERTICES
TO
BE
IN
THE
CLIQUE
HAVE
TO
BE
INCLUDED
IN
THE
INDEPENDENT
SET
WHICH
PROVES
THEY
CANNOT
BE
IN
THE
CLIQUE
AND
VICE
VERSA
FOR
K
NUM
VERTICES
G
WE
SHOW
THAT
THIS
PROBLEM
IS
NP
HARD
TO
DO
THIS
WE
WILL
SHOW
THAT
CLIQUE
CLIQUE
AND
INDEPENDENT
SET
THE
INPUT
TO
THE
CLIQUE
PROBLEM
IS
A
GRAPH
H
AND
AN
INTEGER
J
TO
TRANSFORM
H
INTO
THE
INPUT
FOR
THE
AND
PROBLEM
SIMPLY
ADD
J
VERTICES
AND
NO
EDGES
TO
THE
GRAPH
WHICH
WE
WILL
NOW
CALL
G
G
WILL
ALWAYS
HAVE
AN
INDEPENDENT
SET
OF
SIZE
J
AS
EACH
OF
THE
J
VERTICES
WE
ADDED
HAVE
NO
EDGES
AND
CAN
BE
PART
OF
THE
SET
G
WILL
HAVE
A
CLIQUE
IF
AND
ONLY
IF
H
HAS
A
CLIQUE
AS
WE
DID
NOT
ADD
OR
REMOVE
EDGES
BY
MAKING
ONE
OF
THE
CONJUNCTS
TRUE
CALLING
THE
AND
CODE
WILL
RETURN
THE
TRUTH
VALUE
OF
THE
OTHER
CONJUNCT
WHETHER
H
HAS
A
CLIQUE
OF
SIZE
J
PROGRAM
CLIQUE
GRAPH
H
INT
J
G
TRANSFORM
G
RETURN
AND
G
J
DETERMINING
WHETHER
G
CONTAINS
A
CLIQUE
OF
SIZE
K
OR
AN
INDEPEN
DENT
SET
OF
SIZE
K
IS
NP
HARD
WE
DEMONSTRATE
THIS
BY
REDUCTION
FROM
THE
INDEPENDENT
SET
PROBLEM
THAT
IS
WE
SHOW
THAT
INDEPENDENT
SET
INDEPENDENT
SET
SIZE
K
OR
CLIQUE
SIZE
K
EITHER
TAKE
THE
INPUT
G
AND
RUN
EITHER
ON
IT
IF
EITHER
RETURNS
RETURN
FOR
THE
INDEPENDENT
SET
PROBLEM
IF
EITHER
RETURNS
THEN
CONSTRUCT
A
NEW
GRAPH
H
BY
ADDING
TOTALLY
DISCONNECTED
VERTICES
TO
THE
GRAPH
OF
G
EQUAL
TO
THE
NUMBER
OF
VERTICES
IN
G
CALL
THAT
NUMBER
N
CLEARLY
H
CANNOT
HAVE
A
CLIQUE
OF
SIZE
K
N
SINCE
IT
CANNOT
HAVE
A
CLIQUE
SIZE
GREATER
THAN
N
SINCE
EVEN
IF
K
N
NONE
OF
THE
NEW
POINTS
ADDED
TO
H
CAN
BE
PART
OF
A
CLIQUE
SO
RUN
EITHER
K
N
ON
GRAPH
H
IF
EITHER
RETURNS
THEN
THE
ORIGINAL
GRAPH
G
HAD
TO
HAVE
AN
INDE
PENDENT
SET
OF
SIZE
K
SINCE
EITHER
RESULT
CANNOT
BE
FROM
A
N
K
SIZE
CLIQUE
IT
HAS
TO
BE
FROM
A
N
K
SIZE
INDEPENDENT
SET
OF
WHICH
N
POINTS
ARE
THE
NEWLY
ADDED
DISCONNECTED
POINTS
AND
THE
OTHER
K
ARE
AN
IDNEPENDENT
SET
IN
GRAPH
G
IF
EITHER
K
N
RETURNS
THEN
THE
ORIGINAL
GRAPH
DID
NOT
HAVE
AN
INDEPENDENT
SET
OF
SIZE
K
AND
THUS
WE
HAVE
SHOWN
THAT
INDEPENDENT
SET
EITHER
THERE
IS
A
POLYNOMIAL
TIME
ALGORITHM
FOR
DETERMINING
IF
GRAPH
G
WITH
N
VERTICES
CONTAINS
A
CLIQUE
OF
SIZE
AND
AN
INDEPENDENT
SET
OF
SIZE
IF
N
IT
IS
IMPOSSIBLE
FOR
G
TO
HAVE
BOTH
A
CLIQUE
OF
SIZE
AND
AN
INDEPENDENT
SET
OF
SIZE
ASSUME
THAT
THERE
IS
A
GRAPH
G
WITH
N
AND
A
CLIQUE
OF
SIZE
AND
AN
INDEPENDENT
SET
OF
SIZE
IN
G
THERE
MUST
BE
AT
LEAST
TWO
VERTICES
THAT
ARE
BOTH
IN
THE
CLIQUE
AND
THE
INDEPENDENT
SET
THESE
VERTICES
MUST
BE
CONNECTED
AS
THEY
ARE
IN
THE
CLIQUE
THESE
VERTICES
CANNOT
BE
CON
NECTED
AS
THE
ARE
IN
THE
INDEPENDENT
SET
THIS
IS
A
CONTRADICTION
AND
OUR
ASSUMPTION
THAT
THERE
IS
SUCH
A
GRAPH
IS
FALSE
THERE
ARE
CASES
LEFT
TO
CONSIDER
N
N
AND
N
N
IN
THIS
CASE
TRIVIALLY
THERE
IS
A
CLIQUE
OF
SIZE
AND
AN
INDEPENDENT
SET
OF
SIZE
ALWAYS
RETURN
TRUE
N
TRIVIALLY
THERE
IS
A
CLIQUE
OF
SIZE
AND
AN
IN
DEPENDENT
SET
OF
SIZE
ALWAYS
RETURN
TRUE
N
THERE
ARE
POSSIBLE
EDGES
IN
A
GRAPH
OF
SIZE
IF
THERE
ARE
EDGES
THERE
IS
NO
CLIQUE
OF
SIZE
WITH
EDGE
THERE
WILL
BE
A
CLIQUE
OF
SIZE
THE
TWO
CONNECTED
VERTICES
AND
AN
INDEPENDENT
SET
OF
SIZE
OF
SIZE
ONE
OF
THE
EDGE
ENDPOINT
AND
THE
VERTEX
NOT
CONNECTED
TO
THE
EDGE
WITH
EDGES
THERE
IS
A
CLIQUE
OF
SIZE
ANY
CONNECTED
VERTICES
AND
AN
INDEPENDET
SET
OF
SIZE
THE
TWO
VERTICES
WITHOUT
AN
EDGE
CONNECTING
THEM
WITH
EDGES
THERE
IS
NOT
INDEPENDENT
SET
OF
SIZE
AS
ALL
VERTICES
ARE
CONNECTED
PROGRAM
AND
GRAPH
G
N
OF
VERTICES
IN
G
IF
N
RETURN
TRUE
ELSE
IF
N
RETURN
TRUE
ELSE
IF
N
E
EDGES
IN
G
IF
E
OR
E
RETURN
FALSE
ELSE
IF
E
OR
E
RETURN
TRUE
ELSE
RETURN
FALSE
THIS
PROBLEM
IS
NP
HARD
BECAUSE
WE
CAN
REDUCE
INDEPENDENT
SET
TO
THIS
PROBLEM
E
G
SHOW
THAT
INDEPENDENT
SET
INDEPENDENT
SET
SIZE
OR
CLIQUE
SIZE
AGAIN
CALL
THIS
EITHER
THE
PROOF
IS
ESSENTIALLY
A
COMBINATION
OF
PROBLEMS
B
AND
D
ABOVE
FIRST
APPLY
THE
PROCEDURE
IN
B
THEN
APPLY
THE
PROCEDURE
IN
D
WITH
ONE
SLIGHT
MODIFICATION
WE
ADD
N
MORE
VERTICES
TOTAL
WHERE
N
IS
THE
NUMBER
OF
VERTICES
OF
THE
GRAPH
BUT
INSTEAD
OF
MAKING
THEM
ALL
DISCONNECTED
ONLY
MAKE
OF
THEM
OF
THEM
DISCONNECTED
AND
MAKE
THE
OTHER
OF
THEM
CONNECT
COMPLETELY
WITH
EACH
OTHER
SUCH
THAT
THEY
CANNOT
BE
PART
OF
ANY
INDEPENDENT
SET
THEN
APPLY
THE
EITHER
ALGORITHM
FOR
ANALOGOUS
REASONS
TO
THOSE
DESCRIBED
IN
D
THIS
PROCEDURE
RETURNS
IF
AND
ONLY
IF
THE
NEW
GRAPH
HAS
AN
INDEPENDENT
SET
OF
SIZE
WHICH
IMPLIES
THAT
THE
ORIGINAL
GRAPH
HAS
AN
INDEPENDENT
SET
OF
SIZE
AND
THUS
WE
HAVE
SHOWN
THAT
INDEPENDENT
SET
INDEPENDENT
SET
SIZE
OR
CLIQUE
SIZE
PROBLEM
TO
REDUCE
THE
CLIQUE
OPTIMAIZATION
PROBLEM
TO
THE
CLIQUE
DECISION
PROBLEM
WE
NEED
TO
SHOW
THAT
PROBLEM
OF
FINDING
A
CLIQUE
OF
MAXIMUM
SIZE
IS
REDUCIBLE
TO
DETERMINE
THE
SIZE
OF
THE
MAXIMUM
CLIQUE
ALGORITHM
FOR
FINDING
CLIQUE
PICK
A
VERTEX
V
IF
THE
MAXIMUM
CLIQUE
SIZE
IN
G
V
IS
EQUAL
TO
THE
MAXIMUM
CLIQUE
SIZE
IN
G
WE
CAN
RECURSE
ON
G
V
OTHERWISE
ADD
V
TO
FINAL
CLIQUE
DELETE
V
AND
VERTICES
IN
G
NOT
ADJACENT
TO
V
AND
RECURSE
PROBLEM
GIVEN
A
POLYNOMIAL
TIME
ALGORITHM
V
C
G
K
WHICH
RETURNS
TRUE
IFF
GRAPH
G
CONTAINS
A
VERTEX
COVER
OF
SIZE
K
WE
CAN
CREATE
AN
ALGO
RITHM
TO
FIND
THE
MAXIMUM
VERTEX
COVER
BY
FIRST
CALLING
V
C
G
I
FOR
I
FROM
V
TO
CALL
K
THE
SMALLEST
I
SUCH
THAT
V
C
G
I
RETURNED
TRUE
WE
NOW
CONSIDER
EACH
VERTEX
V
AND
CALL
V
C
G
V
K
IF
V
C
G
V
K
RETURNS
TRUE
THEN
ADD
V
TO
THE
COVER
AND
SET
G
G
V
AND
K
K
OTHERWISE
LEAVE
G
AND
K
ALONE
TO
SEE
WHY
THIS
IS
CORRECT
OBSERVE
THAT
WE
NEVER
ADD
MORE
THAN
K
VERTICES
TO
THE
COVER
WE
ONLY
REMOVE
EDGES
FROM
G
IF
THEY
ARE
COVERED
AND
BECAUSE
V
C
G
V
K
IS
TRUE
ALL
REMAINING
EDGES
CAN
BE
COVERED
WITH
K
VERTICES
STILL
IN
G
V
IT
IS
NOT
TOO
HARD
TO
SEE
THAT
WE
CANNOT
GO
THROUGH
THE
ENTIRE
GRAPH
MORE
THAN
ONCE
BEFORE
V
C
G
V
K
RETURNS
TRUE
THUS
WE
ITERATE
AT
MOST
V
TIMES
MAKING
OUR
REDUCTION
POLYNOMIAL
IF
V
C
G
K
IS
POLYNOMIAL
PROBLEM
TO
REDUCE
CNF
SAT
TO
THE
LINEAR
INEQUALITY
PROBLEM
WE
CREATE
A
SET
OF
INEQUALITIES
AS
FOLLOWS
FOR
EACH
VARIABLE
XI
IN
BOOLEAN
FORMULA
F
WE
CREATE
A
INTEGER
VARIABLE
XI
AND
CONSTRAIN
IT
TO
BE
OR
BY
ADDING
THE
INEQUALITIES
XI
AND
XI
FOR
EACH
DISJUNCTION
WE
CREATE
A
SUM
IF
THE
LITERAL
IS
XI
WE
SIMPLY
ADD
XI
AND
IF
THE
LITERAL
IS
X
I
WE
ADD
XI
WE
THEN
REQUIRE
THE
SUM
TO
BE
AT
LEAST
CALL
THE
SET
OF
INEQUALITIES
IF
WE
MAP
TRUE
TO
AND
F
ALSE
TO
IT
NOT
TOO
HARD
TO
SEE
THAT
A
SATISFYING
ASSIGNMENT
TO
F
GIVES
A
SOLUTION
AND
A
SOLUTION
TO
GIVES
A
SATISFYING
ASSIGNMENT
TO
F
PROBLEM
TO
REDUCE
THE
COLORING
PROBLEM
TO
THE
COLORING
PROBLEM
CREATE
A
NEW
VERTEX
V
THAT
IS
CONNECTED
TO
EVERY
OTHER
VERTEX
IN
THE
ORIGINAL
GRAPH
SINCE
V
IS
CONNECTED
TO
EVERY
VERTEX
IT
MUST
HAVE
A
DIFFERENT
COLOR
THAN
THE
OTHERS
THIS
NEW
GEAPH
CAN
BE
COLORED
WITH
COLORS
IF
AND
ONLY
IF
THE
ORIGINAL
GRAPH
CAN
BE
COLORED
WITH
COLORS
PROBLEM
TO
REDUCE
THE
COLORING
DECISION
PROBLEM
TO
THE
SAT
CNF
ASSUME
THE
COLORS
ARE
RED
BLUE
AND
GREEN
FOR
EACH
VERTEX
X
IN
G
CREATE
THE
FOLLOWING
VARIABLES
XRED
XBLUE
AND
XGREEN
FOR
EACH
VERTEX
V
G
EXACTLY
ONE
OF
VRED
VBLUE
AND
VGREEN
MUST
BE
TRUE
AND
FOR
EACH
VERTEX
U
ADJACENT
TO
V
THE
U
VARIABLE
CORESPONDING
TO
V
COLOR
MUST
BE
FALSE
THAT
IS
V
COLOR
U
COLOR
MUST
BE
TRUE
THE
CONSTRUCTION
OF
THE
ENTIRE
CLAUSE
IS
STRAIGHTFORWARD
SIMPLY
AND
TOGETHER
ALL
THE
VERTEX
CLAUSES
IF
THERE
IS
AN
ASSIGNMENT
TO
THESE
VARIABLES
THAT
MAKES
THE
ENTIRE
CLAUSE
TRUE
THE
GRAPH
CAN
BE
COLORED
WITH
COLORS
PROBLEM
TO
REDUCE
THE
VERTEX
COVER
PROBLEM
TO
THE
DOMINATING
SET
PROBLEM
CREATE
A
NEW
GRAPH
G
BY
REPLACING
EACH
EDGE
E
X
Y
IN
G
BY
A
NEW
VERTEX
VE
AND
EDGES
X
VE
Y
VE
AND
Y
X
THE
VERTEX
VE
ESSENTIALLY
FORCES
THE
EDGE
E
TO
BE
COVERED
CALL
THE
PROCEDURE
FOR
DOMINATING
SET
TO
GET
A
MINIMUM
CARDINALITY
DOMINATING
SET
D
IF
A
VE
D
THEN
REPLACE
VE
BY
X
OR
Y
DOESN
T
MATTER
CALL
THIS
NEW
SET
D
NOTE
THAT
D
IS
STILL
DOMINATING
IN
G
THEN
D
IS
A
MINIMUM
CARDINALITY
VERTEX
COVER
IN
G
NOTE
THIS
REDUCTION
ONLY
HANDLES
THE
CASE
WHEN
G
IS
A
CONNECTED
GRAPH
AND
HAS
AT
LEAST
ONE
EDGE
IF
G
IS
NOT
CONNECTED
RUN
THIS
REDUCTION
ON
EACH
NON
TRIVIAL
CONNECTED
COMPONENT
PROBLEM
NON
MANY
TO
ONE
REDUCTION
TO
REDUCE
THE
HAMILTONIAN
CYCLE
PROBLEM
TO
THE
FIXED
HAMILTONIAN
PATH
PROBLEM
CHECK
IF
THERE
IS
A
HAMILTONIAN
PATH
BETWEEN
X
AND
Y
FOR
EACH
EDGE
E
X
Y
G
NOTE
THAT
THIS
IS
SUFFIENT
TO
ANSWER
THE
PROBLEM
AS
STATED
MANY
TO
ONE
REDUCTION
CREATE
GRAPH
G
AS
FOLLOWS
ADD
A
NEW
VERTEX
V
TO
THE
INPUT
GRAPH
G
AND
THEN
PICK
ANY
VERTEX
V
IN
G
AND
CONNECT
V
TO
ALL
OF
THE
NEIGHBORS
OF
V
TO
SOLVE
THE
HAMILTONIAN
CYCLE
DECISION
PROBLEM
HC
G
RETURN
THE
VALUE
OF
THE
FIXED
HAMILTONIAN
PATH
PROBLEM
ON
G
WITH
START
VERTEX
V
AND
END
VERTEX
V
F
HP
G
V
V
IF
F
HP
G
V
V
IS
TRUE
THEN
BY
DEFINITION
IF
WE
ADDED
AN
EDGE
BETWEEN
V
AND
V
WE
D
NOW
HAVE
A
HAMILTONIAN
CYCLE
IN
G
HOWEVER
AS
V
AND
V
HAVE
AN
IDENTICAL
SET
OF
NEIGHBORS
WE
KNOW
THAT
V
NEIGHBOR
IN
THE
PATH
CALL
IT
U
IS
V
NEIGHBOR
IN
G
THUS
THE
SECTION
OF
THE
PATH
THAT
IS
IN
G
WOULD
START
AT
V
AND
END
AT
U
BECAUSE
V
AND
U
ARE
NEIGHBORS
WE
CAN
COMPLETE
THE
CYCLE
IF
HC
G
IS
TRUE
THEN
TO
CONSTRUCT
THE
PATH
FOR
F
HP
G
V
V
FOR
ANY
V
IN
G
REMOVE
THE
EDGE
FROM
THE
CYCLE
BETWEEN
V
AND
ONE
OF
V
NEIGHBORS
IN
THE
CYCLE
THERE
ARE
TWO
CALL
IT
U
THEN
ADD
THE
EDGE
FROM
U
TO
V
TO
COMPLETE
THE
PATH
FROM
V
TO
V
THE
EDGE
FROM
U
TO
V
MUST
EXIST
IN
G
BY
THE
CONSTRUCTION
OF
G
PROBLEM
THIS
SOLUTION
WAS
ADAPTED
FROM
BRIAN
WONGCHAOWART
HOMEWORK
WRITEUP
TO
SOLVE
THE
VERTEX
COVER
PROBLEM
FOR
AN
UNDIRECTED
GRAPH
G
AND
AN
IN
TEGER
M
CONSTRUCT
A
NEW
GRAPH
H
TO
BE
USED
AS
INPUT
TO
THE
PROBLEM
BEGIN
BY
ADDING
A
NEW
VERTEX
R
TO
H
THEN
FOR
EACH
VERTEX
VK
IN
G
ADD
A
VERTEX
TO
H
LABELED
VK
AND
AN
EDGE
BETWEEN
THIS
VERTEX
AND
R
FOR
EACH
EDGE
VI
VJ
IN
G
ADD
A
VERTEX
TO
H
LABELED
EIJ
AND
ADD
AN
EDGE
BETWEEN
THIS
VERTEX
AND
THE
VERTICES
IN
H
LABELED
VI
AND
VJ
ADD
VERTEX
R
AND
ALL
OF
THE
VERTICES
EIJ
CORRESPONDING
TO
EDGES
OF
G
TO
THE
SET
R
LET
E
BE
THE
NUMBER
OF
EDGES
IN
G
USE
H
R
AND
M
E
AS
THE
INPUT
TO
THE
PROBLEM
A
SET
U
ALL
OF
THE
VERTICES
IN
R
AND
AT
MOST
M
E
VERTICES
IS
A
SUBGRAPH
OF
H
IF
AND
ONLY
IF
G
HAS
A
VERTEX
COVER
OF
SIZE
M
IF
G
HAS
A
VERTEX
COVER
C
OF
SIZE
M
SUCH
A
U
CAN
BE
FOUND
IN
H
BY
TAKING
R
AS
THE
ROOT
ADDING
THE
M
VERTICES
LABELED
WITH
THE
VERTICES
IN
C
AND
FINALLY
ADDING
EACH
OF
THE
E
VERTICES
CORRESPONDING
TO
AN
EDGE
IN
G
THERE
IS
A
PATH
FROM
THE
VERTEX
R
TO
EVERY
VERTEX
EIJ
BY
USING
THE
EDGE
CONNECTING
IT
TO
THE
VERTEX
FROM
C
SUCH
AN
EDGE
MUST
EXIST
BY
THE
DEFINITION
OF
A
VERTEX
COVER
THIS
SET
HAS
M
E
VERTICES
IF
ON
THE
OTHER
HAND
H
CONTAINS
A
SET
U
THAT
INCLUDES
PATHS
BETWEEN
ALL
OF
THE
VERTICES
IN
R
AND
HAS
AT
MOST
M
E
VERTICES
THE
VERTICES
IN
G
THAT
CORRESPOND
TO
A
VERTEX
IN
U
FORM
A
VERTEX
COVER
FOR
G
OF
SIZE
AT
MOST
M
TO
SEE
WHY
NOTE
THAT
R
IS
NOT
CONNECTED
DIRECTLY
TO
ANY
VERTEX
EIJ
IN
H
BUT
BY
DEFINITION
OF
R
THESE
E
VERTICES
MUST
ALL
BE
IN
U
SO
U
MUST
INCLUDE
SOME
NUMBER
OF
THE
VERTICES
IN
H
SUCH
THAT
THERE
IS
AN
EDGE
FROM
ONE
OF
THESE
VERTICES
TO
EACH
VERTEX
EIJ
THIS
CORRESPONDS
EXACTLY
TO
CHOOSING
A
SET
OF
VERTICES
IN
G
SO
THAT
EACH
EDGE
IS
INCIDENT
TO
A
VERTEX
IN
THE
SET
I
E
CHOOSING
A
VERTEX
COVER
THE
NUMBER
OF
THESE
VERTICES
THE
SIZE
OF
THIS
VERTEX
COVER
CANNOT
BE
GREATER
THAN
M
BECAUSE
R
AS
WELL
AS
ALL
E
VERTICES
EACH
CORRESPONDING
TO
AN
EDGE
IN
G
MUST
BY
IN
U
THIS
REDUCTION
CAN
CLEARLY
BE
CARRIED
OUT
IN
POLYNOMIAL
TIME
AS
ONE
VERTEX
IS
ADDED
TO
H
FOR
EACH
VERTEX
AND
EACH
EDGE
IN
G
CS
SYLLABUS
FALL
COURSE
HOME
PAGE
COURSE
PIAZZA
GROUP
THIS
GROUP
WILL
BE
USED
FOR
ANNOUNCEMENTS
THE
COURSE
GROUP
IS
THE
BEST
PLACE
TO
ASK
GENERAL
QUESTIONS
E
G
A
QUESTION
ABOUT
A
PARTICULAR
HOMEWORK
PROBLEM
THIS
GROUP
WILL
BE
MONITORED
BY
THE
INSTRUCTOR
AND
TA
BUT
OFTEN
OTHER
STUDENTS
CAN
PROVIDE
A
QUICKER
ANSWER
THAN
THE
INSTRUCTOR
COURSE
MEETING
THE
COURSE
WILL
MEET
MONDAYS
WEDNESDAYS
AND
FRIDAYS
FROM
IN
SENNOTT
SQUARE
THROUGH
THE
END
OF
OCTOBER
A
NORMAL
SEMESTER
CLASS
HAS
SCHEDULED
CLASS
MEETINGS
OF
WHICH
OFTEN
ONE
OR
TWO
ARE
CANCELED
WE
WILL
HAVE
A
SIMILAR
NUMBER
OF
CLASS
MEETINGS
TEXT
THE
OFFICIAL
TEXT
IS
FOUNDATIONS
OF
ALGORITHMS
BY
NEAPOLITAN
AND
NAIMIPOUR
ANY
EDITION
OF
THE
TEXTBOOK
IS
FINE
FOR
THIS
CLASS
YOU
ARE
WELCOME
TO
CONSULT
OTHER
INTRODUCTORY
TEXTBOOKS
IF
YOU
PREFER
MOST
STUDENTS
DON
T
FIND
A
TEXTBOOK
PARTICULARLY
USEFUL
PREREQUISITES
CS
AND
CS
IF
YOU
TAKE
THIS
CLASS
WITHOUT
THESE
PREREQUISITES
YOU
FORFEIT
ANY
RIGHT
TO
COMPLAIN
THAT
THE
CLASS
IS
AT
AN
INAPPROPRIATE
LEVEL
COURSE
CONTENT
THE
MAIN
GOAL
OF
THE
COURSE
IS
TO
LEARN
TO
THINK
ALGORITHMICALLY
LIKE
A
REAL
COMPUTER
SCIENTIST
THIS
COURSE
IS
DIFFERENT
THAN
CS
IN
THAT
WE
WILL
BE
DESIGNING
OUR
OWN
ALGORITHMS
AS
OPPOSED
TO
LEARNING
ALGORITHMS
IN
THE
PAST
MOST
STUDENTS
HAVE
FOUND
THE
COURSE
MATERIAL
TO
BE
CHALLENGING
MOST
CLASS
TIME
WILL
BE
DEVOTED
TO
EXAMPLES
OF
ALGORITHM
DESIGN
FOR
PARTICULARLY
INTERESTING
PROBLEMS
THERE
WILL
BE
SMALL
GROUP
HOMEWORK
ASSIGNMENTS
DUE
ALMOST
EVERY
CLASS
IT
IS
EXPECTED
THAT
MOST
OF
YOUR
LEARNING
WILL
COME
FROM
THE
PROCESS
OF
SOLVING
THE
HOMEWORK
PROBLEMS
WITHIN
YOUR
GROUP
PROBLEMS
ON
THE
MIDTERM
EXAMS
WILL
BE
VERY
SIMILAR
USUALLY
IDENTICAL
TO
PROBLEMS
COVERED
IN
CLASS
OR
ASSIGNED
AS
HOMEWORK
WE
WILL
COVER
THE
FOLLOWING
TOPICS
IN
THE
FOLLOWING
ORDER
DECIDING
THE
CORRECTNESS
OF
ALGORITHMS
GREEDY
ALGORITHMS
CHAPTER
OF
NEAPOLITAN
AND
NAIMIPOUR
DYNAMIC
PROGRAMMING
CHAPTER
OF
NEAPOLITAN
AND
NAIMIPOUR
REDUCTIONS
AND
NP
COMPLETENESS
CHAPTER
OF
NEAPOLITAN
AND
NAIMIPOUR
PARALLEL
ALGORITHMS
CHAPTER
OF
NEAPOLITAN
AND
NAIMIPOUR
GRADING
GRADES
WILL
BE
BASED
ON
HOMEWORK
CLASSROOM
PARTICIPATION
AND
TWO
MIDTERM
EXAMS
HOMEWORK
WILL
CONSTITUTE
OF
THE
FINAL
GRADE
EACH
MIDTERM
EXAM
WILL
CONSTITUTE
OF
THE
FINAL
GRADE
THERE
WILL
NOT
BE
A
CUMULATIVE
FINAL
EXAM
ATTENDANCE
WILL
BE
TAKEN
AND
ALONG
WITH
CLASS
PARTICIPATION
WILL
COUNT
FOR
THE
REMAINING
OF
THE
GRADE
I
WILL
SUBJECTIVELY
SET
THE
GRADING
SCALE
AT
THE
END
OF
THE
SEMESTER
YOU
ARE
NOT
IN
COMPETITION
WITH
OTHER
STUDENTS
I
HAVE
NO
SET
NUMBERS
OF
A
B
ETC
I
STRONGLY
SUGGEST
YOU
COOPERATE
WITH
EACH
OTHER
TO
UNDERSTAND
THE
MATERIAL
THIS
IS
IN
ALL
STUDENTS
BEST
INTERESTS
IF
A
STUDENT
HOMEWORK
SCORES
ARE
CONSPICUOUSLY
SUSPICIOUSLY
HIGHER
THAN
A
STUDENT
EXAM
GRADES
I
RESERVE
THE
RIGHT
TO
BASE
THE
COURSE
GRADE
ON
ONLY
THE
EXAM
SCORES
AND
CLASSROOM
PARTICIPATION
GENERALLY
SPEAKING
I
USUALLY
DON
T
GIVE
OUT
A
LOT
OF
A
BECAUSE
I
THINK
THE
TOP
GRADE
SHOULD
REALLY
REPRESENT
MASTERY
OF
THE
MATERIAL
BUT
I
TEND
TO
BE
SYMPATHETIC
IN
GIVING
OUT
C
IF
A
STUDENT
ATTENDS
CLASS
REGULARLY
PARTICIPATES
FULL
IN
CLASS
AND
REGULARLY
MAKES
A
GOOD
FAITH
ATTEMPT
ON
HOMEWORK
ASSIGNMENTS
HOMEWORK
POLICY
YOU
SHOULD
DO
YOUR
HOMEWORK
IN
GROUPS
OF
OR
PEOPLE
GROUPS
OF
DIFFERENT
CARDINAL
ITIES
INCLUDING
MUST
BE
APPROVED
BY
ME
EACH
GROUP
NEED
ONLY
PROVIDE
ONE
WRITE
UP
PER
GROUP
WRITE
UPS
MUST
USE
LATEX
YOU
MAY
DISCUSS
PROBLEMS
WITH
ANY
STUDENT
IN
THE
CLASS
WITH
THE
PROVISOS
THAT
YOU
SHOULDN
T
FEED
OTHERS
COMPLETE
SOLUTIONS
AND
YOU
MUST
ACKNOWLEDGE
YOUR
COLLABORATORS
AND
THE
NATURE
OF
THE
COLLABORATIONS
AT
THE
END
OF
YOUR
THE
WRITE
UP
YOU
MAY
NOT
SEEK
SOLUTIONS
TO
ASSIGNED
PROBLEMS
ON
THE
WWW
IN
OTHER
BOOKS
FROM
FRIENDS
OUTSIDE
THE
CLASS
ETC
ALL
HOMEWORK
IS
DUE
AT
THE
START
OF
CLASS
ON
THE
DATE
DUE
NO
LATE
HOMEWORK
IS
ACCEPTED
THE
HOMEWORK
WILL
BE
GRADED
BY
THE
TA
MANY
STUDENTS
WILL
FIND
SOME
PROBLEMS
DEMANDING
IT
IS
NOT
EXPECTED
THAT
ALL
STUDENTS
WILL
BE
ABLE
TO
ANSWER
ALL
THE
HOMEWORK
QUESTIONS
EXAM
SCORING
APPEAL
POLICY
YOU
MAY
SUBMIT
AN
APPEAL
IN
WRITING
IF
YOU
BELIEVE
THAT
YOUR
SOLUTION
FOR
A
PROBLEM
ON
AN
EXAM
IS
ESSENTIALLY
FULLY
CORRECT
NO
APPEALS
ARE
ALLOWED
FOR
ADDITIONAL
PARTIAL
CREDIT
PARTIAL
CREDIT
IS
TOO
SUBJECTIVE
APPEALS
WILL
NOT
BE
ACCEPTED
EARLIER
THAN
CLASS
AFTER
THE
EXAMS
WERE
RETURNED
AND
WILL
NOT
BE
ACCEPTED
LATER
THAN
CLASSES
AFTER
THE
EXAMS
WERE
RETURNED
NOTE
THAT
THE
PROBLEM
WILL
BE
REGRADED
THERE
IS
A
POSSIBILITY
THAT
THE
NEW
GRADE
WILL
BE
LOWER
THAN
THE
ORIGINAL
GRADE
OF
COURSE
ANY
CLERICAL
ERRORS
CAN
BE
CORRECTED
DISABILITY
POLICY
IF
YOU
HAVE
A
DISABILITY
FOR
WHICH
YOU
ARE
OR
MAY
BE
REQUESTING
AN
ACCOMMODATION
YOU
ARE
ENCOURAGED
TO
CONTACT
BOTH
YOUR
INSTRUCTOR
AND
DISABILITY
RESOURCES
AND
SERVICES
WILLIAM
PITT
UNION
TTY
AS
EARLY
AS
POSSIBLE
IN
THE
TERM
DRS
WILL
VERIFY
YOUR
DISABILITY
AND
DETERMINE
REASONABLE
ACCOMMODATIONS
FOR
THIS
COURSE
MISSING
TESTS
IF
YOU
ARE
GOING
TO
MISS
A
TEST
FOR
UNAVOIDABLE
REASONS
THEN
BEFORE
THE
EXAM
OR
AS
SOON
AS
POSSIBLE
YOU
MUST
CONTACT
ME
CHEATING
POLICY
I
HAVE
NO
TOLERANCE
FOR
CHEATING
IF
YOU
ARE
CAUGHT
CHEATING
YOU
WILL
RECEIVE
AN
F
GRADE
FOR
THE
COURSE
CS
FINAL
EXAM
FALL
DIRECTIONS
THE
TEST
IS
CLOSED
BOOK
AND
CLOSED
NOTES
ANSWER
AT
MOST
PART
B
QUESTIONS
ANSWER
AT
MOST
PART
A
QUESTIONS
ONE
QUARTER
CREDIT
WILL
BE
GIVEN
FOR
UNANSWERED
QUESTIONS
ANSWERS
THAT
ARE
WAY
O
THE
MARK
WILL
GET
NO
CREDIT
FOR
THE
PART
A
QUESTIONS
USUALLY
IT
IS
THEN
A
GOOD
IDEA
TO
HAVE
A
PARAGRAPH
GIVING
AN
OVERVIEW
OF
THE
PROOF
STRATEGY
TECHNIQUE
THAT
YOU
WILL
USE
AND
WHAT
THE
KEY
IDEAS
ARE
BEFORE
LAUNCHING
INTO
THE
DETAILS
PART
B
QUESTIONS
DE
NE
ENTROPY
AND
STATE
SHANNON
SOURCE
CODING
THEOREM
STATE
LADNER
THEOREM
FORMALLY
DE
NE
PSEUDO
RANDOM
GENERATOR
STATE
LANDAUER
PRINCIPLE
GIVE
ONE
SITUATION
WHERE
THE
PRINCIPLE
IS
APPLICABLE
AND
ONE
SITUATION
WHERE
THE
PRINCIPLE
IS
NOT
APPLICABLE
EXPLAIN
WHY
THE
LANGUAGE
OF
ISOMORPHIC
GRAPHS
IS
IN
NP
EXPLAIN
WHY
IT
IS
UNLIKELY
THAT
THIS
LANGUAGE
IS
NP
COMPLETE
WHICH
OF
THESE
COMPLEXITY
CLASS
ARE
KNOWN
TO
HAVE
COMPLETE
LANGUAGES
UNDER
THAT
NATURAL
REDUCTIONS
NP
CO
NP
RP
PSPACE
P
NP
N
CO
NP
SP
EXPLAIN
WHAT
IS
DI
ERENT
ABOUT
THE
COMPLEXITY
CLASSES
THAT
ARE
KNOWN
TO
HAVE
COMPLETE
LANGUAGES
AND
THOSE
THAT
ARE
NOT
KNOWN
TO
HAVE
COMPLETE
LANGUAGES
GIVE
THE
WALSH
HADAMARD
CODE
FOR
SHOW
YOUR
WORK
IN
THE
PROOF
OF
GODEL
INCOMPLETENESS
THEOREM
WE
SHOWED
THAT
NDING
PROOFS
FOR
PARTICULAR
TYPES
NUMBER
THEORETIC
STATEMENTS
IS
NOT
POSSIBLE
EXPLAIN
INTUITIVELY
WHAT
THESE
NUMBER
THEORETIC
STATEMENTS
ARE
ON
WHICH
PRINCIPLE
DID
THE
SECURITY
OF
THE
QUANTUM
CRYPTOGRAPHIC
PROTOCOL
THAT
WE
CONSIDERED
IN
CLASS
REST
STATE
THIS
PRINCIPLE
EXPLAIN
IN
ONE
SENTENCE
HOW
THIS
PRINCIPLE
IS
RELATED
TO
SECURITY
DRAW
A
VENN
DIAGRAM
EXPLAINING
THE
KNOWN
INCLUSION
RELATIONSHIPS
FOR
THE
COMPLEXITY
CLASSES
EXPONENTIALSPACE
P
EXPONENTIALTIME
LOGSPACE
PSPACE
STATE
TWO
GEN
ERAL
THEOREMS
FROM
WHICH
ALL
THE
INCLUSIONS
FOLLOWS
FROM
STATE
WHICH
INCLUSIONS
ARE
KNOWN
TO
BE
PROPER
AND
STATE
TWO
GENERAL
THEOREMS
FROM
THE
PROPERNESS
OF
THESE
INCLUSIONS
FOLLOW
FROM
WHAT
IS
THE
STANDARD
CIRCA
PROOF
TECHNIQUE
TO
SHOW
THAT
ONE
COMPLEXITY
CLASS
PROPERLY
CONTAINS
ANOTHER
EXPLAIN
WHY
IT
IS
BELIEVED
THAT
THIS
TECHNIQUE
WON
T
BE
ABLE
TO
RESOLVE
THE
P
NP
QUESTION
DE
NE
PERFECT
SECRECY
OF
A
PRIVATE
KEY
CRYPTOGRAPHIC
PROTOCOL
PART
A
QUESTIONS
CONSIDER
A
PROGRAMMING
LANGUAGE
MINI
JAVA
THAT
ONLY
HAS
ONE
TYPE
OF
LOOP
AND
THE
NUMBER
OF
ITERATIONS
OF
THE
LOOP
MUST
BE
DETERMINED
WHEN
THE
LOOP
IS
RST
ENCOUNTERED
SO
A
LOOP
STATEMENT
MIGHT
LOOK
LIKE
REPEAT
N
TIMES
AND
THE
VARIABLE
N
IS
EVALUATED
WHEN
THE
STATE
MENT
IS
REACHED
YOU
CAN
ASSUME
THAT
THE
PROGRAM
HAS
A
VARIABLE
SIZE
THAT
IS
INSTANTIATED
TO
THE
INPUT
SIZE
WHEN
THE
PROGRAM
STARTS
RUNNING
OTHERWISE
YOU
COULDN
T
EVEN
READ
THE
IN
PUT
SO
ALL
MINI
JAVA
PROGRAMS
MUST
HALT
ON
ALL
INPUTS
SHOW
BY
DIAGONALIZATION
THAT
THERE
IS
A
LANGUAGE
ACCEPTED
BY
A
JAVA
PROGRAM
THAT
IS
NOT
ACCEPTED
BY
ANY
MINI
JAVA
PROGRAM
USE
DIAGONALIZATION
GIVE
A
CONCRETE
EXAMPLE
OF
A
LANGUAGE
THAT
IS
NOT
ACCEPTABLE
BY
ANY
MINI
JAVA
PROGRAM
BUT
THAT
IS
ACCEPTED
BY
A
JAVA
PROGRAM
EXPLAIN
THE
SETUP
OF
THE
HALF
SILVERED
MIRROR
EXPERIMENT
EXPLAIN
HOW
THIS
IS
FORMALLY
MODELED
WITHIN
QUANTUM
MECHANICS
THAT
IS
HOW
IS
THE
DIRECTION
OF
THE
PHOTON
MODELED
HOW
ARE
THE
MIRRORS
MODELED
AND
HOW
IS
MEASUREMENT
MODELED
THEN
SHOW
THAT
CALCULATIONS
WITHIN
THIS
MODEL
GIVE
THE
RESULT
OF
THE
EXPERIMENT
IN
THE
REAL
WORLD
CONSIDER
THE
FOLLOWING
GAME
PLAYED
BY
TWO
PLAYERS
A
AND
B
ON
A
DIRECTED
GRAPH
G
WITH
A
DESIGNATED
START
VERTEX
ON
THE
RST
MOVE
PLAYER
A
PICKS
AN
EDGE
V
LEAVING
THEN
AND
V
ARE
DESIGNATED
AS
VISITED
ON
EACH
EVEN
NUMBERED
MOVE
PLAYER
B
PICKS
AN
EDGE
V
W
FROM
THE
CURRENT
VERTEX
V
TO
A
VERTEX
W
HASN
T
BEEN
VISITED
BEFORE
IF
NO
SUCH
VERTEX
W
EXISTS
THEN
PLAYER
B
LOSES
VERTEX
W
THEN
IS
DESIGNATED
AS
VISITED
AND
BECOMES
THE
CURRENT
VERTEX
ON
EACH
ODD
NUMBERED
MOVE
PLAYER
A
PICKS
AN
EDGE
V
W
FROM
THE
CURRENT
VERTEX
V
TO
A
VERTEX
W
HASN
T
BEEN
VISITED
BEFORE
IF
NO
SUCH
VERTEX
W
EXISTS
THEN
PLAYER
A
LOSES
VERTEX
W
THEN
IS
DESIGNATED
AS
VISITED
AND
BECOMES
THE
CURRENT
VERTEX
SO
THE
PLAYERS
A
AND
B
TAKING
TURNS
PICKING
EDGES
IN
A
DIRECTED
PATH
P
STARTING
AT
WITH
A
PLAYER
LOSING
IF
HE
SHE
CAN
T
EXTEND
THE
PATH
PROVE
THAT
DETERMINING
FOR
A
PARTICULAR
G
AND
WHETHER
THE
RST
PLAYER
HAS
A
WINNING
STRATEGY
IS
PSPACE
COMPLETE
UNDER
POLYNOMIAL
TIME
REDUCTIONS
YOU
MUST
PROVE
HARDNESS
BY
REDUCTION
FROM
THE
PROBLEM
OF
DETERMINING
WHETHER
A
QUANTI
ED
BOOLEAN
FORMULA
F
IS
TRUE
PROVE
THAT
DETERMINING
THE
LANGUAGE
OF
SATIS
ABLE
BOOLEAN
FORMULAS
IS
NP
COMPLETE
FROM
RST
PRINCIPLES
THAT
IS
PROVE
COOK
THEOREM
GIVE
AN
INTERACTIVE
PROTOCOL
FOR
PROVING
THE
LOWER
BOUND
ON
THE
SIZE
OF
A
SET
WITHIN
A
FACTOR
OF
YOU
NEED
ONLY
DE
NE
PAIRWISE
INDEPENDENT
HASH
FUNCTION
BUT
YOU
NEED
NOT
EXPLAIN
HOW
TO
ND
THEM
E
CIENTLY
PROVE
THAT
THE
PROTOCOL
IS
CORRECT
WITH
HIGH
PROBABILITY
STATE
THE
PCP
THEOREM
AND
THEN
USE
THE
PCP
THEOREM
TO
PROVE
THAT
THERE
EXISTS
AN
SUCH
THAT
IT
IS
NP
HARD
TO
APPROXIMATE
MAXSAT
WITHIN
A
FACTOR
OF
CS
MIDTERM
SPRING
DIRECTIONS
THE
TEST
IS
CLOSED
BOOK
AND
CLOSED
NOTES
THERE
ARE
PART
B
QUESTIONS
ANSWER
AT
MOST
PART
B
QUESTIONS
PLEASE
TRY
TO
LIMIT
YOUR
ANSWERS
TO
ONE
SENTENCE
PART
B
QUESTIONS
ARE
WORTH
POINTS
PER
QUESTION
THERE
ARE
PART
A
QUESTIONS
ANSWER
AT
MOST
PART
A
QUESTIONS
PART
A
QUESTIONS
ARE
WORTH
POINTS
PER
QUESTION
TIME
WILL
LIKELY
BE
AN
ISSUE
FOR
MOST
STUDENTS
SO
USE
TIME
WISELY
INITIALLY
CONCENTRATE
ON
THE
MAIN
IDEAS
AND
THEN
LL
IN
DETAILS
WITH
ANY
REMAINING
TIME
IN
PARTICULAR
FOR
THE
PART
A
QUESTIONS
USUALLY
IT
IS
THEN
A
GOOD
IDEA
FOR
THE
START
OF
YOUR
ANSWER
TO
DE
NE
RELEVANT
TERMS
GIVE
AN
OVERVIEW
OF
THE
PROOF
STRATEGY
TECHNIQUE
THAT
YOU
WILL
USE
AND
TO
EXPLAIN
THE
KEY
IDEAS
ARE
AFTER
THIS
YOU
MAY
LAUNCH
INTO
DETAILS
PART
B
QUESTIONS
STATE
THE
CHURCH
TURING
THESIS
AND
EXPLAIN
WHY
IT
IS
GENERALLY
BELIEVED
TO
BE
TRUE
SOMEONE
GIVES
YOU
A
PROGRAM
IAMF
AMOUS
P
I
THAT
THEY
CLAIM
WILL
DETERMINE
WHETHER
THE
PROGRAM
P
HALTS
ON
THE
INPUT
I
GIVE
AN
EXAMPLE
OF
A
PROGRAM
P
AND
INPUT
I
ON
WHICH
THE
PROGRAM
IAMF
AMOUS
WILL
NOT
BE
CORRECT
STATE
GODEL
RST
INCOMPLETENESS
THEOREM
AND
EXPLAIN
HOW
ITS
PROOF
IS
RELATED
TO
THE
HALTING
PROBLEM
GIVE
AN
EXAMPLE
OF
A
LANGUAGE
THAT
CAN
BE
ACCEPTED
USING
LOG
SPACE
BUT
THAT
CAN
NOT
BE
ACCEPTED
USING
CONSTANT
SPACE
FOR
EACH
OF
THE
FOLLOWING
TWO
SENTENCES
REPLACE
WITH
THE
SMALLEST
FUNCTION
THAT
WILL
MAKE
THE
SENTENCE
TRUE
A
TIME
F
N
IS
SUBSET
OF
SP
ACE
B
SP
ACE
F
N
IS
A
SUBSET
OF
TIME
DE
NE
THE
LANGUAGE
TQBF
REFERRED
TO
IN
LECTURE
AS
JUST
QBF
AND
STATE
THE
COMPLEXITY
CLASS
THIS
LANGUAGE
IS
COMPLETE
FOR
EXPLAIN
HOW
TO
PROVE
THAT
A
LANGUAGE
L
IS
COMPLETE
FOR
A
COMPLEXITY
CLASS
C
UNDER
A
TYPE
R
OF
REDUCTION
DRAW
A
VENN
DIAGRAM
FOR
THE
COMPLEXITY
CLASSES
BP
P
RP
CORP
AND
ZPP
MAKE
SURE
THAT
AREAS
THAT
ARE
KNOWN
TO
BE
EMPTY
HAVE
ZERO
AREA
IN
YOUR
DRAWING
FOR
EXAMPLE
IT
IS
KNOWN
THAT
THE
INTERSECTION
OF
CLASSES
X
AND
Y
IS
EMPTY
THEN
IN
YOUR
DRAWING
X
AND
Y
SHOULD
NOT
INTERSECT
GIVE
AN
EXAMPLE
OF
A
DECIDABLE
LANGUAGE
THAT
IS
IN
P
POLY
BUT
NOT
IN
P
IF
YOU
PICK
A
FUNCTION
F
UNIFORMLY
AT
RANDOM
FROM
ALL
FUNCTIONS
FROM
N
TO
THE
SMALLEST
CIRCUIT
THAT
COMPUTES
F
WILL
LIKELY
CONTAIN
HOW
MANY
GATES
IGNORING
MULTIPLICATIVE
CONSTANTS
ACCORDING
TO
THE
KARP
LIPTON
THEOREM
WHAT
IS
THE
CONSEQUENCE
IF
THE
BOOLEAN
SATIS
ABILITY
PROBLEM
SAT
CAN
BE
SOLVED
BY
BOOLEAN
CIRCUITS
WITH
A
POLYNOMIAL
NUMBER
OF
LOGIC
GATES
DE
NE
THE
COMPLEXITY
CLASS
P
PART
A
QUESTIONS
PROVE
TIME
IS
A
STRICT
SUBSET
OF
TIME
THAT
IS
SHOW
THAT
THERE
IS
A
LANGUAGE
IN
TIME
THAT
IS
NOT
IN
TIME
LET
P
BE
SOME
PROPERTY
OF
LANGUAGES
FURTHER
ASSUME
THERE
IS
A
TURING
MACHINE
THAT
ACCEPTS
A
LANGUAGE
THAT
HAS
PROPERTY
P
AND
A
TURING
MACHINE
THAT
ACCEPTS
A
LANGUAGE
THAT
DOES
NOT
HAVE
HAS
PROPERTY
P
SHOW
BY
REDUCTION
FROM
THE
HALTING
PROBLEM
THAT
THERE
IS
NO
TURING
MACHINE
THAT
TAKES
AS
INPUT
A
TURING
MACHINE
M
AND
DETERMINES
WHETHER
THE
LANGUAGE
L
M
ACCEPTED
BY
M
SATIS
ES
PROPERTY
P
ASSUME
A
LOG
SPACE
REDUCTION
FROM
A
LANGUAGE
A
TO
A
LANGUAGE
B
SO
MORE
PRECISELY
THERE
IS
A
TURING
MACHINE
T
WITH
THREE
TAPES
A
READ
ONLY
INPUT
TAPE
A
READ
WRITE
WORK
TAPE
AND
A
WRITE
ONLY
OUTPUT
TAPE
T
ONLY
USES
LOG
OF
THE
INPUT
SIZE
MANY
CELLS
ON
THE
READ
WRITE
WORK
TAPE
FURTHER
T
NEVER
BACKS
UP
THE
TAPE
HEAD
ON
THE
WRITE
ONLY
OUTPUT
TAPE
SO
THE
TAPE
HEAD
ON
THE
WRITE
ONLY
TAPE
EITHER
STAYS
IN
POSITION
OR
MOVES
TO
THE
RIGHT
THE
MACHINE
T
HAS
THE
PROPERTY
THAT
A
STRING
X
IS
IN
A
IF
AND
ONLY
IF
THE
CONTENTS
OF
THE
WRITE
TAPE
WHEN
T
ENDS
COMPUTATION
ON
INPUT
X
IS
IN
B
NOW
SHOW
THAT
IF
THERE
IS
A
LOG
SPACE
TURING
MACHINE
THAT
ACCEPTS
B
THEN
THERE
IS
A
LOG
SPACE
TURING
MACHINE
U
THAT
ACCEPTS
A
A
NONDETERMINISTIC
CIRCUIT
HAS
TWO
INPUTS
X
AND
Y
WE
SAY
THAT
C
ACCEPTS
X
IF
AND
ONLY
IF
THERE
EXISTS
A
Y
SUCH
THAT
C
X
Y
THE
SIZE
OF
THE
CIRCUIT
IS
MEASURED
AS
A
FUNCTION
OF
THE
SIZE
OF
X
LET
NP
POLY
BE
THE
LANGUAGES
THAT
ARE
DECIDED
BY
POLYNOMIAL
SIZE
NONDETERMINISTIC
CIRCUITS
SHOW
BP
NP
NP
POLY
RECALL
THAT
BP
NP
IS
THE
SET
OF
LANGUAGES
L
THAT
SUCH
THAT
THERE
EXISTS
A
RANDOMIZED
POLYNOMIAL
TIME
TURING
MACHINE
M
SUCH
THAT
FOR
ALL
X
WITH
PROBABILITY
AT
LEAST
IT
IS
THE
CASE
THAT
THE
BOOLEAN
FORMULA
OUTPUT
BY
M
X
IS
SATIS
ABLE
IF
AND
ONLY
IF
X
L
SHOW
THAT
BP
P
IS
A
SUBSET
OF
SP
CS
MIDTERM
SPRING
DIRECTIONS
THE
TEST
IS
CLOSED
BOOK
AND
CLOSED
NOTES
THERE
ARE
PART
B
QUESTIONS
ANSWER
AT
MOST
PART
B
QUESTIONS
PLEASE
TRY
TO
LIMIT
YOUR
ANSWERS
TO
ONE
SENTENCE
WHEN
POSSIBLE
PART
B
QUESTIONS
ARE
WORTH
POINTS
PER
QUESTION
THERE
ARE
PART
A
QUESTIONS
ANSWER
AT
MOST
PART
A
QUESTIONS
PART
A
QUESTIONS
ARE
WORTH
POINTS
PER
QUESTION
TIME
WILL
LIKELY
BE
AN
ISSUE
FOR
MOST
STUDENTS
SO
USE
TIME
WISELY
INITIALLY
CONCENTRATE
ON
THE
MAIN
IDEAS
AND
THEN
LL
IN
DETAILS
WITH
ANY
REMAINING
TIME
IN
PARTICULAR
FOR
THE
PART
A
QUESTIONS
USUALLY
IT
IS
THEN
A
GOOD
IDEA
FOR
THE
START
OF
YOUR
ANSWER
TO
DE
NE
RELEVANT
TERMS
GIVE
AN
OVERVIEW
OF
THE
PROOF
STRATEGY
TECHNIQUE
THAT
YOU
WILL
USE
AND
TO
EXPLAIN
THE
KEY
IDEAS
ARE
AFTER
THIS
YOU
MAY
LAUNCH
INTO
DETAILS
PART
B
QUESTIONS
STATE
THE
PROTOCOL
FOR
THE
INTERACTIVE
PROOF
FOR
GRAPH
NON
ISOMORPHISM
GNI
GIVEN
IN
THE
TEXT
AND
IN
CLASS
YOU
CAN
ASSUME
THAT
THE
VERI
ER
HAS
ACCESS
TO
PRIVATE
RANDOM
BITS
THAT
CAN
NOT
BE
SEEN
BY
THE
PROVER
STATE
THE
PERFECT
ZERO
KNOWLEDGE
INTERACTIVE
PROOF
FOR
GRAPH
ISOMORPHISM
GIVE
A
FORMAL
AS
YOU
CAN
DE
NITION
OF
WHAT
IT
MEANS
FOR
A
PRIVATE
KEY
PROTOCOL
PRESUMABLY
WITH
SMALL
KEYS
TO
BE
SEMANTICALLY
SECURE
THE
CHRISTIAN
SCIENCE
MONITOR
ARTICLE
YOU
READ
AS
HOMEWORK
REPORTED
ON
THE
CONSTRUCTION
OF
A
PARTICULAR
KIND
OF
QUANTUM
GATE
A
STATE
THE
NAME
OF
THIS
TYPE
OF
GATE
B
GIVE
THE
FUNCTIONALITY
INPUT
OUTPUT
RELATION
OF
THIS
TYPE
OF
GATE
GIVE
THE
MATRIX
THAT
REPRESENTS
THE
BIT
HADAMARD
QUANTUM
OPERATION
A
DE
NE
A
F
N
G
N
RESTRICTED
VERI
ER
WITHIN
THE
CONTEXT
OF
PROBABILISTICALLY
CHECKABLE
PROOFS
B
DE
NE
PCP
F
N
G
N
C
STATE
THE
PCP
THEOREM
LET
BE
THE
SUM
OF
TWO
INDEPENDENT
SIX
SIDED
DICE
SO
THE
PROBABILITY
IS
EQUAL
TO
X
IS
X
FOR
X
THE
PROBABILITY
IS
EQUAL
TO
X
IS
X
FOR
X
WRITE
AN
ARITHMETIC
EXPRESSION
FOR
THE
ENTROPY
OF
YOU
NEED
NOT
SIMPLIFY
THIS
EXPRESSION
A
DE
NE
THE
KOMOGOROV
COMPLEXITY
OF
A
STRING
X
B
LET
L
BE
THE
LANGUAGE
CONSISTING
OF
PAIRS
X
K
WHERE
X
IS
A
STRING
K
IS
AN
INTEGER
AND
THE
KOLMOGOROV
COMPLEXITY
OF
X
IS
EQUAL
TO
K
IS
L
IN
PSPACE
JUSTIFY
YOUR
ANSWER
EXPLAIN
HOW
A
PSEUDO
RANDOM
GENERATOR
CAN
BE
USED
TO
DERANDOMIZE
A
RANDOMIZED
ALGORITHM
TO
GET
A
DETERMINISTIC
ALGORITHM
THAT
IS
MORE
E
CIENT
THAN
THE
NAIVE
DERANDOMIZATION
A
GIVE
THE
VALUE
OF
U
U
WHEN
U
WHERE
IS
THE
OUTER
TENSOR
PRODUCT
B
GIVE
THE
WALSH
HADAMARD
ENCODING
OF
U
U
WHEN
U
GIVE
A
DIAGRAM
TO
SHOW
WHICH
OF
THE
FOLLOWING
STATEMENTS
IMPLY
OTHER
STATEMENTS
SO
I
M
LOOKING
FOR
AN
ORGANIZED
LIST
OF
IMPLICATIONS
E
G
A
C
C
B
ETC
A
THE
EXISTENCE
OF
GOOD
PSEUDO
RANDOM
GENERATORS
B
P
NP
C
THE
EXISTENCE
OF
COMPUTATIONALLY
SECURE
PRIVATE
KEY
CRYPTOGRAPHY
WITH
SMALL
KEYS
D
THE
EXISTENCE
OF
SECURE
PUBLIC
KEY
CRYPTOGRAPHY
E
THE
EXISTENCE
OF
ONE
WAY
FUNCTIONS
IN
THE
HOMEWORK
YOU
WERE
ASSIGNED
TO
READ
A
BLOG
ARTICLE
BY
SCOTT
AARONSON
ON
ON
PETER
SHOR
QUANTUM
ALGORITHM
FOR
FACTORING
A
ACCORDING
TO
THIS
ARTICLE
THE
PROBLEM
OF
FACTORING
WAS
REDUCED
TO
NDING
A
PARTICULAR
PROPERTY
OF
A
SEQUENCE
STATE
THIS
PROPERTY
B
TO
ILLUSTRATE
THE
INTUITION
BEHIND
THE
ALGORITHM
PROFESSOR
AARONSON
USED
A
PARTICULAR
TYPE
OF
DEVICE
THAT
STUDENTS
FREQUENTLY
ENCOUNTER
IN
THEIR
DAY
TO
DAY
LIFE
WHAT
IS
THIS
DEVICE
PART
A
QUESTIONS
GIVE
A
COMPUTATIONALLY
ZERO
KNOWLEDGE
INTERACTIVE
PROOF
THAT
A
GRAPH
HAS
A
HAMILTONIAN
CYCLE
GIVE
A
SHORT
INFORMAL
EXPLANATION
WHAT
COMPUTATIONALLY
ZERO
KNOWLEDGE
MEANS
AND
INTUITIVELY
WHY
THIS
PROOF
THIS
PROPERTY
GIVE
THE
INTERACTIVE
PROOF
IP
PROTOCOL
FOR
SHOWING
THAT
A
PARTICULAR
BOOLEAN
FORMULA
F
HAS
A
PARTICULAR
NUMBER
K
OF
SATISFYING
ASSIGNMENTS
EXPLAIN
WHY
THE
PROOF
IS
CORRECT
THE
GOAL
OF
THIS
PROBLEM
IS
TO
ND
A
WAY
TO
TRANSMIT
INFORMATION
ABOUT
A
QUBIT
BY
SENDING
TWO
CLASSICAL
BITS
ALICE
AND
BOB
SPLIT
UP
ENTANGLED
BITS
A
AND
B
IN
STATE
V
ASSUME
THAT
NOW
ALICE
IS
GIVEN
QUBIT
X
SO
X
IS
IN
SOME
UNKNOWN
SUPERPOSITION
BETWEEN
STATES
AND
ALICE
NOW
PERFORMS
THE
FOLLOWING
REVERSIBLE
CNOT
OPERATION
ON
X
IF
A
THEN
NEGATE
X
ALICE
THEN
RUNS
QUBIT
A
THROUGH
A
BIT
HADAMARD
GATE
ALICE
NOW
MEASURES
THE
CURRENT
VALUES
OF
A
AND
X
AND
SENDS
THESE
TWO
CLASSICAL
BITS
TO
BOB
EXPLAIN
WHAT
THE
STATE
OF
ALL
THE
PARTICLES
A
B
AND
X
IS
AFTER
EACH
OF
ALICE
OPERATIONS
THEN
EXPLAIN
HOW
BOB
CAN
USE
THE
TWO
CLASSICAL
PARTICLES
TO
CHANGE
THE
STATE
OF
B
TO
THE
ORIGINAL
STATE
OF
X
CONSIDER
THE
PROOF
THAT
NP
PCP
POLY
N
IN
THE
TEXT
AND
FROM
CLASS
A
STATE
THE
NP
COMPLETE
PROBLEM
FOR
WHICH
A
PROBABILISTICALLY
CHECKABLE
PROOF
IS
GIVEN
B
EXPLAIN
WHAT
THE
FORMAT
OF
THE
PROBABILISTICALLY
CHECKABLE
PROOF
THE
BOOK
C
EXPLAIN
HOW
THE
VERI
ER
DETERMINES
WHETHER
THE
ENCODED
SOLUTION
IS
INDEED
A
SOLUTION
TO
THE
INSTANCE
OF
THE
NP
COMPLETE
PROBLEM
ASSUMING
THAT
THE
ENCODING
IN
THE
PROOF
BOOK
IS
IN
THE
CORRECT
FORMAT
D
LIST
THE
THREE
PROPERTIES
THE
VERI
ER
HAS
TO
CHECK
TO
MAKE
SURE
THE
ENCODING
OF
THE
PROOF
BOOK
IS
OF
THE
CORRECT
FORM
E
PICK
ONE
OF
THESE
THREE
PROPERTIES
AND
EXPLAIN
HOW
THE
VERI
ER
CHECKS
THAT
THE
PROOF
BOOK
HAS
THIS
PROPERTY
ASSUME
X
IS
A
LETTER
THAT
A
SENDER
WANTS
TO
SEND
TO
A
RECEIVER
OVER
A
NOISY
CHANNEL
AND
LET
Y
BE
THE
LETTER
RECEIVED
BY
THE
RECEIVER
BECAUSE
THE
CHANNEL
IS
NOISY
Y
MAY
NOT
EQUAL
X
FOR
EACH
PAIR
X
Y
THERE
IS
A
PROBABILITY
THAT
PX
Y
THAT
THE
LETTER
Y
IS
RECEIVED
WHEN
THE
LETTER
X
IS
SENT
LET
X
BE
A
PROBABILITY
DISTRIBUTION
OF
THE
SENT
LETTER
X
AND
Y
THE
CORRESPONDING
DISTRIBUTION
OF
THE
RECEIVED
LETTER
Y
LET
I
X
Y
BE
THE
AMOUNT
OF
INFORMATION
ONE
GETS
ABOUT
THE
SENT
LETTER
X
WHEN
ONE
SEES
THE
RECEIVED
LETTER
Y
LET
I
Y
X
BE
THE
AMOUNT
OF
INFORMATION
ONE
GETS
ABOUT
THE
RECEIVED
LETTER
Y
WHEN
ONE
SEES
THE
SENT
LETTER
X
IS
I
X
Y
I
Y
X
OR
IS
I
Y
X
I
X
Y
OR
IS
I
X
Y
I
Y
X
JUSTIFY
PROVE
THAT
YOUR
ANSWER
IS
CORRECT
START
WITH
THE
STANDARD
DE
NITION
OF
I
X
Y
CS
SYLLABUS
SPRING
COURSE
HOME
PAGE
HTTPS
PEOPLE
CS
PITT
EDU
KIRK
INDEX
HTML
COURSE
PIAZZA
GROUP
HTTP
PIAZZA
COM
PITT
HOME
THIS
GROUP
WILL
BE
USED
FOR
ANNOUNCEMENTS
THE
COURSE
GROUP
IS
THE
BEST
PLACE
TO
ASK
GENERAL
QUESTIONS
E
G
A
QUESTION
ABOUT
A
PARTICULAR
HOMEWORK
PROBLEM
THIS
GROUP
WILL
BE
MONITORED
BY
THE
INSTRUCTOR
AND
TA
BUT
OFTEN
OTHER
STUDENTS
CAN
PROVIDE
A
QUICKER
ANSWER
THAN
THE
INSTRUCTOR
COURSE
MEETING
THE
COURSE
WILL
MEET
ON
SELECTED
MONDAYS
WEDNESDAYS
AND
FRIDAYS
FROM
IN
SENNOTT
SQUARE
A
NORMAL
SEMESTER
CLASS
HAS
SCHEDULED
CLASS
MEETINGS
OF
WHICH
OFTEN
ONE
OR
TWO
ARE
CANCELED
WE
WILL
HAVE
A
SIMILAR
NUMBER
OF
CLASS
MEETINGS
TEXT
COMPUTATIONAL
COMPLEXITY
A
MODERN
APPROACH
BY
ARORA
AND
BARAK
A
ROUGH
DRAFT
CAN
BE
FOUND
AT
HTTP
THEORY
CS
PRINCETON
EDU
COMPLEXITY
BOOK
PDF
PREREQUISITES
CS
IF
YOU
TAKE
THIS
CLASS
WITHOUT
THESE
PREREQUISITES
YOU
FORFEIT
ANY
RIGHT
TO
COMPLAIN
THAT
THE
CLASS
IS
AT
AN
INAPPROPRIATE
LEVEL
COURSE
CONTENT
AND
GRADING
WE
WILL
LOOSELY
FOLLOW
THE
RST
ELEVEN
CHAPTERS
OF
THE
TEXT
BY
ARORA
AND
BARAK
THERE
WILL
BE
DAILY
HOMEWORK
ASSIGNMENTS
AND
TWO
MIDTERM
EXAMS
GRADING
GRADES
WILL
BE
BASED
ON
HOMEWORK
CLASSROOM
PARTICIPATION
AND
TWO
MIDTERM
EXAMS
HOMEWORK
WILL
CONSTITUTE
OF
THE
NAL
GRADE
EACH
MIDTERM
EXAM
WILL
CONSTITUTE
OF
THE
NAL
GRADE
THERE
WILL
NOT
BE
A
CUMULATIVE
NAL
EXAM
ATTENDANCE
WILL
BE
TAKEN
AND
ALONG
WITH
CLASS
PARTICIPATION
INCLUDING
PARTICIPATION
ON
PIAZZA
WILL
COUNT
FOR
THE
REMAINING
OF
THE
GRADE
I
WILL
SUBJECTIVELY
SET
THE
GRADING
SCALE
AT
THE
END
OF
THE
SEMESTER
YOU
ARE
NOT
IN
COMPETITION
WITH
OTHER
STUDENTS
I
HAVE
NO
SET
NUMBERS
OF
A
B
ETC
I
STRONGLY
SUGGEST
YOU
COOPERATE
WITH
EACH
OTHER
TO
UNDERSTAND
THE
MATERIAL
THIS
IS
IN
ALL
STUDENTS
BEST
INTERESTS
IF
A
STUDENT
HOMEWORK
SCORES
ARE
CONSPICUOUSLY
SUSPICIOUSLY
HIGHER
THAN
A
STUDENT
EXAM
GRADES
I
RESERVE
THE
RIGHT
TO
BASE
THE
COURSE
GRADE
ON
ONLY
THE
EXAM
SCORES
AND
CLASSROOM
PARTICIPATION
GENERALLY
SPEAKING
I
USUALLY
DON
T
GIVE
OUT
A
LOT
OF
A
BECAUSE
I
THINK
THE
TOP
GRADE
SHOULD
REALLY
REPRESENT
MASTERY
OF
THE
MATERIAL
BUT
I
TEND
TO
BE
SYMPATHETIC
IN
GIVING
OUT
C
IF
A
STUDENT
ATTENDS
CLASS
REGULARLY
PARTICIPATES
FULLY
IN
CLASS
AND
REGULARLY
MAKES
A
GOOD
FAITH
ATTEMPT
ON
HOMEWORK
ASSIGNMENTS
HOMEWORK
POLICY
YOU
SHOULD
DO
YOUR
HOMEWORK
IN
GROUPS
OF
OR
PEOPLE
GROUPS
OF
DI
ERENT
CARDINAL
ITIES
INCLUDING
MUST
BE
APPROVED
BY
ME
EACH
GROUP
NEED
ONLY
PROVIDE
ONE
WRITE
UP
PER
GROUP
WRITE
UPS
MUST
USE
LATEX
HTTP
EN
WIKIPEDIA
ORG
WIKI
LATEX
FIGURES
MAY
BE
HAND
DRAWN
YOU
MAY
DISCUSS
PROBLEMS
WITH
ANY
STUDENT
IN
THE
CLASS
WITH
THE
PROVISOS
THAT
YOU
SHOULDN
T
FEED
OTHERS
COMPLETE
SOLUTIONS
AND
YOU
MUST
ACKNOWLEDGE
YOUR
COLLABORATORS
AND
THE
NATURE
OF
THE
COLLABORATIONS
AT
THE
END
OF
YOUR
THE
WRITE
UP
YOU
MAY
NOT
SEEK
SOLUTIONS
TO
ASSIGNED
PROBLEMS
ON
THE
WWW
IN
OTHER
BOOKS
FROM
FRIENDS
OUTSIDE
THE
CLASS
ETC
ALL
HOMEWORK
IS
DUE
AT
THE
START
OF
CLASS
ON
THE
DATE
DUE
NO
LATE
HOMEWORK
IS
ACCEPTED
THE
HOMEWORK
WILL
BE
GRADED
BY
THE
TA
MANY
STUDENTS
WILL
ND
SOME
PROBLEMS
DEMANDING
IT
IS
NOT
EXPECTED
THAT
ALL
STUDENTS
WILL
BE
ABLE
TO
ANSWER
ALL
THE
HOMEWORK
QUESTIONS
EXAM
SCORING
APPEAL
POLICY
YOU
MAY
SUBMIT
AN
APPEAL
IN
WRITING
IF
YOU
BELIEVE
THAT
YOUR
SOLUTION
FOR
A
PROBLEM
ON
AN
EXAM
IS
ESSENTIALLY
FULLY
CORRECT
NO
APPEALS
ARE
ALLOWED
FOR
ADDITIONAL
PARTIAL
CREDIT
PARTIAL
CREDIT
IS
TOO
SUBJECTIVE
APPEALS
WILL
NOT
BE
ACCEPTED
EARLIER
THAN
CLASS
AFTER
THE
EXAMS
WERE
RETURNED
AND
WILL
NOT
BE
ACCEPTED
LATER
THAN
CLASSES
AFTER
THE
EXAMS
WERE
RETURNED
NOTE
THAT
THE
PROBLEM
WILL
BE
REGRADED
THERE
IS
A
POSSIBILITY
THAT
THE
NEW
GRADE
WILL
BE
LOWER
THAN
THE
ORIGINAL
GRADE
OF
COURSE
ANY
CLERICAL
ERRORS
CAN
BE
CORRECTED
DISABILITY
POLICY
IF
YOU
HAVE
A
DISABILITY
FOR
WHICH
YOU
ARE
OR
MAY
BE
REQUESTING
AN
ACCOMMODATION
YOU
ARE
ENCOURAGED
TO
CONTACT
BOTH
YOUR
INSTRUCTOR
AND
DISABILITY
RESOURCES
AND
SERVICES
WILLIAM
PITT
UNION
TTY
AS
EARLY
AS
POSSIBLE
IN
THE
TERM
DRS
WILL
VERIFY
YOUR
DISABILITY
AND
DETERMINE
REASONABLE
ACCOMMODATIONS
FOR
THIS
COURSE
MISSING
TESTS
IF
YOU
ARE
GOING
TO
MISS
A
TEST
FOR
UNAVOIDABLE
REASONS
THEN
BEFORE
THE
EXAM
OR
AS
SOON
AS
POSSIBLE
YOU
MUST
CONTACT
ME
CHEATING
POLICY
I
HAVE
NO
TOLERANCE
FOR
CHEATING
IF
YOU
ARE
CAUGHT
CHEATING
YOU
WILL
RECEIVE
AN
F
GRADE
FOR
THE
COURSE
CS
NETWORKS
CROWDS
AND
MARKETS
SYLLABUS
FALL
CLASS
TIMES
MWF
PM
PM
SENSQ
COURSE
HOME
PAGE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
INDEX
HTML
THE
PLAN
IS
TO
COVER
THE
WHOLE
TEXT
PREREQUISITES
CONSENT
OF
THE
INSTRUCTOR
COURSE
CONTENT
THIS
IS
BOTH
THE
RST
TIME
THAT
I
HAVE
TAUGHT
A
COURSE
ON
THIS
TOPIC
AND
THE
RST
TIME
THAT
I
HAVE
TAUGHT
A
SPECIAL
TOPICS
COURSE
THAT
INCLUDES
UNDERGRADUATES
SO
I
VIEW
ALL
PLANS
AS
TENTATIVE
AND
SUBJECT
TO
CHANGE
BASED
ON
EXPERIENCE
THE
CURRENT
PLAN
FOR
THE
RST
OR
SO
CLASSES
IS
AS
FOLLOWS
FOR
EACH
CLASS
THERE
WILL
BE
AN
ASSIGNED
READING
AND
ASSIGNED
HOMEWORK
PROBLEMS
THERE
WILL
BE
A
SHORT
QUIZ
AT
THE
START
OF
CLASS
TO
DETERMINE
TO
WHAT
EXTENT
THE
STUDENTS
LEARNED
THE
MATERIAL
I
WILL
THEN
LECTURE
ON
EITHER
SOME
MORE
PORTION
OF
THE
TEXT
THAT
IS
CONCEPTUALLY
MORE
DI
CULT
USUALLY
THE
PORTIONS
LABEL
ADVANCED
MATERIAL
OR
LECTURE
ABOUT
CONCEPTUALLY
MORE
DI
CULT
EXTENSIONS
OF
THE
MATERIAL
IN
THE
BOOK
WE
SHOULD
NISH
O
COVERING
THE
MATERIAL
IN
THE
TEXT
IN
THESE
LECTURES
THE
REMAINING
CLASSES
WILL
EACH
CONSIST
OF
TWO
MINUTE
CONFERENCE
STYLE
TALKS
GIVEN
BY
STUDENTS
ON
SELECTED
PAPERS
IN
A
RECENT
ACM
CONFERENCE
ON
ECONOMICS
AND
COMPUTATION
EC
FOLLOWED
BY
BRIEF
DISCUS
SIONS
EACH
STUDENT
WILL
GIVE
TWO
SUCH
TALKS
GRADING
GRADES
WILL
BE
BASED
ON
HOMEWORK
DAILY
QUIZZES
CLASS
ATTENDANCE
CLASS
PARTICIPATION
AND
THE
TALKS
THE
EXACT
WEIGHT
OF
EACH
COMPONENT
WILL
BE
DETERMINED
LATER
I
WILL
SUBJECTIVELY
SET
THE
GRADING
SCALE
AT
THE
END
OF
THE
SEMESTER
YOU
ARE
NOT
IN
COMPETITION
WITH
OTHER
STUDENTS
I
HAVE
NO
SET
NUMBERS
OF
A
B
ETC
I
STRONGLY
SUGGEST
YOU
COOPERATE
WITH
EACH
OTHER
TO
UNDERSTAND
THE
MATERIAL
THIS
IS
IN
ALL
STUDENTS
BEST
INTERESTS
DISABILITY
POLICY
IF
YOU
HAVE
A
DISABILITY
FOR
WHICH
YOU
ARE
OR
MAY
BE
REQUESTING
AN
ACCOMMODATION
YOU
ARE
ENCOURAGED
TO
CONTACT
BOTH
YOUR
INSTRUCTOR
AND
DISABILITY
RESOURCES
AND
SERVICES
WILLIAM
PITT
UNION
TTY
AS
EARLY
AS
POSSIBLE
IN
THE
TERM
DRS
WILL
VERIFY
YOUR
DISABILITY
AND
DETERMINE
REASONABLE
ACCOMMODATIONS
FOR
THIS
COURSE
CHEATING
POLICY
I
HAVE
NO
TOLERANCE
FOR
CHEATING
IF
YOU
ARE
CAUGHT
CHEATING
YOU
WILL
RECEIVE
AN
F
GRADE
FOR
THE
COURSE
COMBINATORIAL
AUCTIONS
AND
THE
VCG
MECHANISM
COMBINATORIAL
AUCTIONS
RECALL
THAT
THE
VA
IS
CONCERNED
WITH
AUCTIONING
OFF
A
SINGLE
GOOD
COMBINATORIAL
AUCTIONS
ARE
MOTIVATED
BY
THE
FOLLOWING
NATURAL
QUESTION
QUESTION
WHAT
IF
THERE
IS
A
SET
OF
M
GOODS
TO
BE
AUCTIONED
OFF
TO
N
PLAYERS
HOW
CAN
WE
EXTEND
THE
VA
TO
THIS
MORE
GENERAL
SETTING
A
NATURAL
IDEA
IS
TO
RUN
A
SEPARATE
VICKREY
AUCTION
FOR
EACH
OF
THE
M
GOODS
THIS
WORKS
I
E
PROPERTIES
HOLD
IF
EACH
PLAYER
I
HAS
A
SEPARATE
VALUE
FOR
EACH
ITEM
AND
THE
VALUE
OF
A
SUBSET
T
OF
GOODS
TO
PLAYER
I
IS
THE
SUM
OF
ITS
VALUES
FOR
THE
GOODS
OF
T
EXERCISE
CHECK
THIS
UNFORTUNATELY
THIS
SIMPLE
APPROACH
IGNORES
THE
POSSIBLE
DEPENDENCIES
BETWEEN
THE
OUTCOMES
OF
THE
DIFFERENT
AUCTIONS
FOR
PLAYERS
MORE
SPECIFICALLY
IT
IGNORES
SUBSTITUTES
A
PLAYER
VALUE
OF
GETTING
SAY
TWO
GOODS
IS
LESS
THAN
THE
SUM
OF
ITS
VALUES
FOR
EACH
INDIVIDUALLY
E
G
THEY
ARE
AT
LEAST
PARTIALLY
REDUNDANT
COMPLEMENTS
A
PLAYER
VALUE
OF
GETTING
SAY
TWO
GOODS
IS
GREATER
THAN
THE
SUM
OF
ITS
VALUES
FOR
EACH
INDIVIDUALLY
E
G
THEY
ARE
AT
LEAST
PARTIALLY
CO
DEPENDENT
INDEED
ONE
OF
THE
APPLICATIONS
THAT
KICKED
OFF
THE
SYSTEMATIC
STUDY
OF
COMBINATORIAL
AUCTIONS
WAS
THE
PROBLEM
FACED
BY
THE
FAA
OF
AUCTIONING
OFF
TAKE
OFF
AND
LANDING
SLOTS
AT
AIRPORTS
TO
THE
MAJOR
AIRLINES
TWO
TAKE
OFF
SLOTS
FROM
THE
SAME
AIRPORT
AT
ALMOST
THE
SAME
TIME
ARE
SUBSTITUTES
FROM
AN
AIRLINE
PERSPECTIVE
WHEREAS
A
TAKE
OFF
SLOT
AT
ONE
AIRPORT
AND
A
LANDING
SLOT
AT
A
SECOND
AIRPORT
AT
THE
APPROPRIATE
SUBSEQUENT
TIME
ACT
AS
COMPLEMENTS
INFORMALLY
A
COMBINATORIAL
AUCTION
CA
IS
AN
AUCTION
THAT
ALLOCATES
A
SET
OF
MANY
GOODS
TO
BIDDERS
IN
THE
PRESENCE
OF
SUBSTITUTES
AND
COMPLEMENTS
AS
WE
WILL
SEE
DESIGNING
GOOD
COMBINATORIAL
AUCTIONS
IS
MUCH
MORE
CHALLENGING
THAN
DESIGNING
GOOD
AUCTIONS
FOR
SELLING
A
SINGLE
GOOD
THE
VCG
MECHANISM
OUR
FIRST
COMBINATORIAL
AUCTION
IS
A
CLASSICAL
POWERFUL
MECHANISM
CALLED
THE
VCG
MECHA
NISM
BY
MECHANISM
WE
ESSENTIALLY
MEAN
SOME
SORT
OF
INCENTIVE
COMPATIBLE
PROTOCOL
THE
V
STANDS
FOR
VICKREY
THE
C
FOR
CLARKE
AND
THE
G
FOR
GROVES
THREE
RESEARCHERS
WHO
GAVE
SUCCESSIVELY
MORE
GENERAL
VERSIONS
OF
VICKREY
AUCTION
THE
GOOD
NEWS
ABOUT
THE
VCG
MECHANISM
IS
THAT
IT
SATISFIES
ALL
OF
PROPERTIES
FROM
SUBSECTION
INCENTIVE
CONSTRAINTS
ECONOMIC
EFFICIENCY
AND
GENERAL
VALUATIONS
THE
BAD
NEWS
IS
THAT
IT
IS
HIGHLY
COMPUTATIONALLY
INTRACTABLE
TO
SPECIFY
THE
VCG
MECHANISM
WE
FIRST
NEED
TO
SAY
WHAT
WE
MEAN
BY
A
VALUATION
OF
A
PLAYER
I
WHEN
THERE
IS
A
SET
OF
M
GOODS
FOR
NOW
WE
WILL
ALLOW
A
VERY
GENERAL
DEFINITION
LATER
WE
WILL
LOOK
AT
SEVERAL
SPECIAL
CASES
WE
CALL
A
SUBSET
T
OF
GOODS
A
BUNDLE
THE
VALUATION
VI
OF
THE
PLAYER
I
IS
A
FUNCTION
FROM
THE
SET
OF
ALL
POSSIBLE
BUNDLES
TO
THE
NONNEGATIVE
REALS
IN
OTHER
WORDS
THE
VALUATION
SPECIFIES
THE
VALUE
VI
T
OF
PLAYER
I
OF
EVERY
CONCEIVABLE
BUNDLE
T
OF
GOODS
THAT
IT
MIGHT
RECEIVE
NOTE
THAT
WITH
M
GOODS
THERE
ARE
SUCH
BUNDLES
WE
ASSUME
THAT
VI
FOR
EVERY
I
THOUGH
THIS
IS
NOT
AN
ESSENTIAL
ASSUMPTION
FOR
THIS
SECTION
WE
DO
NOT
EVEN
NEED
TO
ASSUME
THAT
VI
IS
NONNEGATIVE
OR
THAT
IT
IS
MONOTONE
I
E
THAT
T
T
I
IMPLIES
VI
T
VI
T
I
THOUGH
WE
WILL
MAKE
THESE
ASSUMPTIONS
IN
FUTURE
SECTIONS
NOTE
THAT
SUCH
VALUATIONS
ARE
CERTAINLY
EXPRESSIVE
ENOUGH
TO
MODEL
SUBSTITUTES
AND
COM
PLEMENTS
FOR
EXAMPLE
IF
CONTAINS
TWO
GOODS
WHICH
ARE
PERFECT
SUBSTITUTES
FOR
A
PLAYER
I
THEN
I
VALUATION
MIGHT
BE
V
V
V
IF
THE
TWO
GOODS
ARE
COMPLEMENTS
THEN
I
VALUATION
MIGHT
BE
GIVEN
BY
V
V
AND
V
RECALL
THAT
FOR
A
SINGLE
ITEM
AUCTION
THE
JOB
OF
THE
AUCTION
IS
TO
DETERMINE
A
WINNER
AND
WHAT
PRICE
TO
CHARGE
IN
A
COMBINATORIAL
AUCTION
THERE
CAN
BE
MULTIPLE
WINNERS
THE
OUTCOME
OF
A
CA
IS
TO
ALLOCATE
A
BUNDLE
TI
TO
EACH
PLAYER
I
SUCH
THAT
BUNDLES
GIVEN
TO
DISTINCT
PLAYERS
ARE
DISJOINT
NO
GOOD
CAN
BE
ALLOCATED
TO
MORE
THAN
ONE
WINNER
ACCORDINGLY
A
CA
CAN
CHARGE
A
DIFFERENT
PRICE
PI
TO
EACH
PLAYER
I
AS
IN
THE
VA
WE
AGAIN
ASSUME
QUASILINEAR
UTILITIES
MEANING
IF
PLAYER
I
RECEIVES
THE
BUNDLE
TI
AND
IS
CHARGED
THE
PRICE
PI
THEN
ITS
UTILITY
IS
VI
TI
PI
WE
NOW
STATE
THE
VCG
MECHANISM
DEFERRING
THE
DESCRIPTION
OF
THE
PRICES
UNTIL
SEC
TION
COMPARE
TO
THE
THREE
STEPS
OF
THE
VA
EACH
PLAYER
I
SUBMITS
A
BID
BI
T
FOR
EVERY
POSSIBLE
NON
EMPTY
BUNDLE
T
WE
ALWAYS
IMPLICITLY
ASSUME
THAT
BI
IF
THE
PLAYER
IS
TRUTHFUL
THEN
BI
T
VI
T
FOR
EVERY
T
CHOOSE
AN
ALLOCATION
T
T
THAT
MAXIMIZES
N
OVER
ALL
FEASIBLE
ALLOCATIONS
TI
N
N
BI
TI
I
FEASIBLE
MEANS
THAT
TI
TJ
WHENEVER
I
J
CHARGE
EACH
PLAYER
I
AN
APPROPRIATE
PRICE
PI
TO
BE
DETERMINED
BOTH
STEPS
AND
SHOULD
ALARM
THEORETICAL
COMPUTER
SCIENTISTS
MORE
ON
THIS
SHORTLY
NEVERTHELESS
WE
CAN
VERIFY
THE
PROPERTIES
AND
FROM
SUBSECTION
WITHOUT
EVEN
STATING
THE
PRICES
PROPOSITION
THE
VCG
MECHANISM
IS
ECONOMICALLY
EFFICIENT
IN
OTHER
WORDS
IF
ALL
PLAYERS
BID
TRUTHFULLY
THEN
THE
VCG
MECHANISM
OUTPUTS
AN
ALLOCATION
THAT
MAXIMIZES
OVER
ALL
FEASIBLE
ALLOCATIONS
N
VI
TI
I
PROOF
IMMEDIATE
FROM
STEP
OF
THE
MECHANISM
PROPOSITION
THE
VCG
MECHANISM
WORKS
WITH
GENERAL
VALUATIONS
PROOF
BY
DEFINITION
TO
DISCUSS
PROPERTY
WE
NEED
TO
SPECIFY
OUR
CRITERIA
FOR
COMPUTATIONAL
TRACTABILITY
RECALL
WE
ARE
INTERESTED
IN
AUCTIONS
THAT
RUN
IN
POLYNOMIAL
TIME
BUT
POLYNOMIAL
IN
WHAT
QUESTION
RECALL
THAT
MERELY
SPECIFYING
THE
VALUATION
OF
A
PLAYER
REQUIRES
PA
RAMETERS
SHOULD
WE
BE
HAPPY
IF
AN
AUCTION
RUNS
IN
TIME
POLYNOMIAL
IN
THIS
INPUT
SIZE
IN
THIS
COURSE
WE
WILL
BE
AMBITIOUS
OUR
CRITERIA
FOR
POLYNOMIAL
TIME
WILL
BE
POLYNOMIAL
IN
THE
NUMBER
N
OF
PLAYERS
AND
IN
THE
NUMBER
M
OF
GOODS
IN
OTHER
WORDS
WE
ARE
ONLY
INTERESTED
IN
CAS
THAT
SCALE
REASONABLY
WITH
NUMBER
OF
PLAYERS
AND
GOODS
THE
VCG
MECHANISM
CLEARLY
DOES
NOT
SATISFY
THIS
STRINGENT
DEFINITION
OF
COMPUTATIONAL
TRACTABILITY
MERELY
COMMUNICATING
THE
BID
OF
A
SINGLE
PLAYER
IN
STEP
REQUIRES
EXPONENTIAL
RESOURCES
THE
VCG
MECHANISM
IS
ALSO
COMPUTATIONALLY
INEFFICIENT
IN
A
SECOND
SENSE
AS
WE
WILL
SEE
IN
SECTION
EVEN
IN
SPECIAL
CASES
WHERE
BIDDERS
CAN
COMMUNICATE
THEIR
ENTIRE
VALUATION
IN
POLYNOMIAL
TIME
THE
OPTIMIZATION
PROBLEM
THAT
THE
VCG
MECHANISM
MUST
SOLVE
IN
STEP
CAN
BE
HIGHLY
INTRACTABLE
VCG
PRICES
AND
STRATEGYPROOFNESS
TO
DETERMINE
WHETHER
OR
NOT
THE
VCG
MECHANISM
HAS
PROPERTY
I
E
SATISFIES
INCENTIVE
CONSTRAINTS
WE
MUST
SPECIFY
THE
PRICES
CHARGED
IN
STEP
QUESTION
SUPPOSE
WE
ALWAYS
SET
PI
FOR
ALL
I
WOULD
THIS
MAKE
THE
VCG
MECHANISM
TRUTHFUL
QUESTION
WE
WILL
GIVE
PRICES
THAT
GENERALIZE
THOSE
IN
THE
VA
CAN
YOU
THINK
OF
WHAT
THIS
WOULD
LOOK
LIKE
FOR
A
CA
SAY
WITH
TWO
GOODS
WE
SPECIFY
THE
VCG
PRICES
IN
A
FORM
DUE
TO
CLARKE
IN
ENGLISH
THE
DEFINITION
IS
A
SET
PI
EQUAL
TO
THE
DAMAGE
CAUSED
TO
THE
OTHER
PLAYERS
BY
I
PRESENCE
MATHEMATICALLY
WE
HAVE
PI
MAX
TJ
J
I
BJ
TJ
BJ
T
J
I
J
I
WHERE
THE
MAXIMUM
RANGES
OVER
ALL
FEASIBLE
ALLOCATIONS
OF
THE
GOODS
TO
THE
N
PLAYERS
OTHER
THAN
I
AS
USUAL
WE
INSIST
THAT
TJ
TK
FOR
ALL
J
K
SEVERAL
COMMENTS
FIRST
TO
INTERPRET
THESE
PRICES
IT
IS
OFTEN
HELPFUL
TO
THINK
OF
EACH
OF
THE
BIDS
BI
IN
AS
THE
CORRESPONDING
TRUE
VALUATION
VI
AFTER
ALL
AT
THE
END
OF
THE
DAY
WE
WILL
PROVE
THAT
THE
VCG
MECHANISM
IS
TRUTHFUL
AND
THUS
EXPECT
BIDDERS
TO
BID
THEIR
TRUE
VALUATIONS
OF
COURSE
THE
PRICE
PI
CANNOT
EXPLICITLY
REFER
TO
A
TRUE
VALUATION
VI
SINCE
THESE
ARE
UNKNOWN
TO
THE
MECHANISM
IT
CAN
ONLY
USE
THE
RECEIVED
BIDS
AS
PROXIES
FOR
THE
TRUE
VALUATIONS
THE
FIRST
TERM
ON
THE
RIGHT
HAND
SIDE
OF
IS
THE
MAXIMUM
POSSIBLE
SURPLUS
IF
WE
DELETE
PLAYER
I
BID
AND
OPTIMIZE
ONLY
FOR
THE
N
OTHER
PLAYERS
NOTE
THIS
IS
PRECISELY
THE
RESULT
OF
RERUNNING
STEP
OF
THE
VCG
MECHANISM
AFTER
DELETING
I
BID
FROM
THE
INPUT
SINCE
PLAYER
I
DID
SUBMIT
A
BID
HOWEVER
THE
VCG
MECHANISM
INSTEAD
CHOSE
THE
ALLOCATION
T
N
MAXIMIZING
THE
SURPLUS
N
BJ
T
OF
ALL
OF
THE
PLAYERS
FROM
THE
PERSPECTIVE
OF
THE
N
PLAYERS
OTHER
THAN
I
THEIR
COLLECTIVE
BENEFIT
IN
THIS
ALLOCATION
IS
J
I
BJ
T
THE
SECOND
TERM
ON
THE
RIGHT
HAND
SIDE
OF
THE
RIGHT
HAND
SIDE
OF
IS
THEREFORE
THE
EXTENT
TO
WHICH
THE
COLLECTIVE
BENEFIT
OF
THE
N
PLAYERS
OTHER
THAN
I
WOULD
INCREASE
IF
PLAYER
I
WAS
DELETED
AND
THE
VCG
MECHANISM
CHOSE
AN
ALLOCATION
SOLELY
FOR
THEIR
BENEFIT
THE
DAMAGE
CAUSED
TO
THESE
PLAYERS
BY
I
PRESENCE
THE
IDEA
OF
THESE
PRICES
IS
TO
FORCE
A
PLAYER
TO
CARE
ABOUT
THE
WELFARE
OF
THE
OTHER
PLAYERS
THUS
ALIGNING
THE
OBJECTIVE
OF
THE
PLAYER
WITH
THE
GLOBAL
OBJECTIVE
OF
MAXIMIZING
SOCIAL
SURPLUS
THIS
IDEA
IS
COMMON
IN
ECONOMICS
AND
IS
OFTEN
CALLED
INTERNALIZING
AN
EXTERNALITY
EXAMPLE
IN
THE
SPECIAL
CASE
OF
A
SINGLE
GOOD
AUCTION
THE
PRICE
SPECIALIZES
TO
THE
PRICES
IN
THE
VA
FOR
LOSERS
THE
SECOND
HIGHEST
BID
FOR
THE
WINNER
TO
SEE
THIS
NOTE
THAT
WITH
A
SINGLE
ITEM
EVERY
BUNDLE
T
HAS
THE
FORM
EITHER
FOR
LOSERS
OR
FOR
THE
WINNER
WHERE
DENOTES
THE
ITEM
BEING
SOLD
WHEN
A
PLAYER
SUBMITS
A
BID
BI
IN
THE
VA
IT
CORRESPONDS
TO
A
BID
BI
IN
THE
CURRENT
NOTATION
AS
USUAL
WE
IMPLICITLY
ASSUME
THAT
BI
FOR
EVERY
PLAYER
NOTE
ALSO
THAT
STEP
OF
THE
VCG
MECHANISM
SIMPLY
MEANS
GIVING
THE
ITEM
TO
THE
HIGHEST
BIDDER
WHICH
IS
STEP
OF
THE
VA
FIRST
CONSIDER
A
PLAYER
I
THAT
LOSES
SO
T
AND
BI
T
LET
K
BE
THE
WINNER
SO
T
AND
BK
T
IS
ITS
SEALED
BID
BK
THE
SECOND
TERM
ON
THE
RIGHT
HAND
SIDE
OF
IS
BK
SINCE
PLAYER
I
LOST
I
E
DID
NOT
HAVE
THE
HIGHEST
BID
DELETING
THE
PLAYER
AND
RERUNNING
STEP
OF
THE
VA
WOULD
STILL
RESULT
IN
PLAYER
K
WINNING
THE
ITEM
THE
FIRST
TERM
ON
THE
RIGHT
HAND
SIDE
OF
IS
ALSO
BK
RESULTING
IN
A
PRICE
PI
FOR
PLAYER
I
ON
THE
OTHER
HAND
SUPPOSE
PLAYER
I
WINS
THE
ITEM
SO
BI
T
BI
AND
BJ
T
FOR
EVERY
J
I
THE
SECOND
TERM
ON
THE
RIGHT
HAND
SIDE
OF
IS
IF
PLAYER
I
IS
DELETED
AND
STEP
OF
THE
VA
IS
RERUN
THEN
THE
REMAINING
PLAYER
WITH
THE
HIGHEST
BID
THE
PLAYER
THAT
ORIGINALLY
POSSESSED
THE
SECOND
HIGHEST
BID
WINS
SO
THE
FIRST
TERM
ON
THE
RIGHT
HAND
SIDE
OF
IS
THE
SECOND
HIGHEST
BID
AS
IN
THE
VA
THE
DEFINITION
OF
THE
VCG
PRICES
IMMEDIATELY
GIVES
THE
FOLLOWING
PROPOSITION
VCG
PRICES
ARE
NONNEGATIVE
PROOF
ONE
FEASIBLE
SOLUTION
FOR
THE
MAXIMIZATION
PROBLEM
IN
THE
FIRST
TERM
IN
THE
RIGHT
SIDE
OF
IS
T
J
I
WITH
TOTAL
VALUE
J
I
BJ
T
THE
MAXIMUM
CAN
ONLY
BE
LARGER
WE
NOW
GIVE
A
SECOND
DEFINITION
AND
INTERPRETATION
OF
THE
VCG
PRICES
TO
OBTAIN
IT
WE
SIMPLY
ADD
AND
SUBTRACT
BI
T
FROM
AND
REARRANGE
TERMS
PI
BI
T
N
J
BJ
T
MAX
TJ
J
I
J
I
BJ
TJ
THE
WAY
TO
THINK
ABOUT
IS
THAT
IF
THE
PLAYER
I
RECEIVES
THE
BUNDLE
T
THEN
IT
PAYS
ITS
BID
BI
T
MINUS
A
DISCOUNT
THE
EXPRESSION
IN
THE
SQUARE
BRACKETS
IN
NOTE
THAT
THE
DISCOUNT
TERM
IS
PRECISELY
THE
EXTENT
TO
WHICH
I
PRESENCE
INCREASES
THE
MAXIMUM
ACHIEVABLE
EFFICIENCY
QUESTION
WHAT
IS
THE
DISCOUNT
TERM
IN
A
SINGLE
ITEM
AUCTION
RECALL
THAT
IN
A
FIRST
PRICE
SINGLE
ITEM
AUCTION
THERE
CAN
BE
AN
INCENTIVE
FOR
PLAYERS
TO
UNDERBID
SEE
THE
DISCUSSION
FOLLOWING
PROPOSITION
THE
ROUGH
INTUITION
FOR
THE
DISCOUNT
TERM
ABOVE
IS
THAT
IT
SIMPLY
GIVES
PLAYERS
UP
FRONT
WHATEVER
THEY
COULD
GAIN
BY
UNDERBIDDING
IN
A
FIRST
PRICE
VERSION
OF
THE
VCG
MECHANISM
FROM
THE
SECOND
DEFINITION
OF
THE
VCG
PRICES
WE
IMMEDIATELY
OBTAIN
THAT
THE
VCG
MECHANISM
IS
INDIVIDUALLY
RATIONAL
RECALL
PROPOSITION
PROPOSITION
THE
UTILITY
OF
A
TRUTHTELLING
BIDDER
IN
THE
VCG
MECHANISM
IS
ALWAYS
NONNEGATIVE
PROOF
THE
PROPOSITION
IS
EQUIVALENT
TO
SHOWING
THAT
THE
DISCOUNT
TERM
IN
IS
ALWAYS
NONNEGATIVE
THIS
HOLDS
BECAUSE
ADDING
AN
EXTRA
BIDDER
CAN
ONLY
INCREASE
THE
MAXIMUM
ACHIEVABLE
SURPLUS
IT
ONLY
ENLARGES
THE
SET
OF
FEASIBLE
ALLOCATIONS
ALL
THAT
REMAINS
TO
PROVE
IS
THAT
THE
VCG
MECHANISM
IS
TRUTHFUL
AS
AN
EXERCISE
THE
READER
IS
INVITED
TO
PROVE
THAT
IT
IS
ALSO
STRONGLY
TRUTHFUL
IN
THE
SENSE
OF
PROPOSITION
PROPOSITION
THE
VCG
MECHANISM
IS
STRATEGYPROOF
THAT
IS
FOR
EVERY
PLAYER
I
EVEN
IF
THE
PLAYER
KNOWS
THE
FULL
BIDS
OF
ALL
OF
THE
OTHER
PLAYERS
PLAYER
I
MAXIMIZES
ITS
UTILITY
BY
BIDDING
TRUTHFULLY
SETTING
BI
T
VI
T
FOR
EVERY
NON
EMPTY
BUNDLE
T
PROOF
WE
FOLLOW
THE
MORE
GENERAL
APPROACH
OF
GROVES
WHICH
WILL
MAKE
THE
PROOF
OF
TRUTHFULNESS
MORE
TRANSPARENT
WE
FIRST
PROVE
TRUTHFULNESS
FOR
THE
WRONG
SET
OF
PRICES
AND
THEN
SHOW
HOW
TO
SHIFT
THESE
PRICES
TO
RECOVER
THE
VCG
PRICES
WHILE
MAINTAINING
TRUTHFULNESS
MODIFY
THE
VCG
MECHANISM
SO
THAT
IN
STEP
IT
COMPUTES
THE
FOLLOWING
PRICE
PI
FOR
EACH
PLAYER
I
PI
BJ
T
J
I
WHERE
AS
USUAL
T
N
DENOTES
THE
ALLOCATION
COMPUTED
IN
STEP
OF
THE
VCG
MECHANISM
NOTE
THESE
ARE
NEGATIVE
PRICES
I
E
SUBSIDIES
AND
ARE
CERTAINLY
NOT
THE
VCG
PRICES
OF
AND
FOR
EXAMPLE
FOR
A
SINGLE
ITEM
AUCTION
THESE
PRICES
SAY
THAT
THE
WINNER
SHOULD
BE
CHARGED
NOTHING
WHILE
ALL
THE
LOSERS
SHOULD
BE
PAID
THE
WINNER
BID
QUESTION
DOES
THIS
RESULT
IN
A
STRATEGYPROOF
SINGLE
ITEM
AUCTION
NOTE
THAT
THE
PRICE
IS
DEFINED
SO
THAT
ANY
BENEFIT
TO
SOME
OTHER
PLAYER
ALSO
BENEFITS
THE
PLAYER
I
MORE
PRECISELY
SINCE
PLAYER
I
UTILITY
IS
ITS
VALUE
FOR
ITS
BUNDLE
MINUS
THE
PRICE
PAID
ITS
UTILITY
FOR
A
GIVEN
ALLOCATION
T
N
WITH
THE
PRICE
IN
IS
VI
T
BJ
T
SUGGESTIVELY
THE
VCG
MECHANISM
CHOOSES
IN
STEP
THE
ALLOCATION
T
N
TO
MAXIMIZE
OVER
ALL
FEASIBLE
ALLOCATIONS
TJ
N
N
BJ
TJ
J
GLIBLY
WE
MIGHT
FINISH
THIS
PART
OF
THE
PROOF
BY
SAYING
THAT
IF
PLAYER
I
BIDS
TRUTHFULLY
THEN
THE
VCG
MECHANISM
OBJECTIVE
AND
ITS
OWN
ARE
EXACTLY
ALIGNED
WHICH
THEN
RESULTS
IN
AN
OPTIMAL
OUTCOME
FROM
I
PERSPECTIVE
WHILE
THIS
ARGUMENT
IS
NOT
INCORRECT
WE
PROCEED
A
BIT
MORE
CAREFULLY
AS
A
SANITY
CHECK
NOTE
THAT
THE
ONLY
THING
PLAYER
I
HAS
CONTROL
OVER
IS
ITS
BID
BI
T
T
WHILE
THE
PLAYER
CANNOT
DIRECTLY
CONTROL
THE
ALLOCATION
T
N
CHOSEN
IN
STEP
OF
THE
VCG
MECHANISM
IT
CAN
POTENTIALLY
INFLUENCE
THE
CHOICE
OF
THIS
ALLOCATION
BY
VARYING
ITS
BID
SIMILARLY
IT
CANNOT
INFLUENCE
THE
FUNCTIONS
VI
AND
BJ
FOR
J
I
RECALL
NO
COLLUSION
IS
ALLOWED
ONLY
THE
ALLOCATION
T
N
CHOSEN
BY
THE
VCG
MECHANISM
NOW
VIEW
AS
AN
OBJECTIVE
FUNCTION
FOR
A
DISCRETE
OPTIMIZATION
PROBLEM
OVER
ALLOCATIONS
FROM
PLAYER
I
PERSPECTIVE
THERE
IS
SOME
ALLOCATION
SAY
T
J
N
THAT
MAXIMIZES
THIS
FUNCTION
THE
BEST
CASE
SCENARIO
FOR
PLAYER
I
IS
THAT
SOME
BID
BI
T
T
COAXES
THE
VCG
MECHANISM
INTO
CHOOSING
THIS
ALLOCATION
T
J
N
AS
THE
ALLOCATION
T
N
IN
ITS
STEP
IF
THERE
EXISTS
SUCH
A
BID
THEN
NO
OTHER
BID
CAN
PROVIDE
I
WITH
STRICTLY
MORE
UTILITY
BUT
IF
PLAYER
I
BIDS
TRUTHFULLY
BI
T
VI
T
FOR
ALL
T
THEN
THE
CRITERION
MAXIMIZED
BY
THE
VCG
MECHANISM
OVER
ALL
FEASIBLE
ALLOCATIONS
TJ
N
IS
N
VI
TI
BJ
TJ
J
I
AND
THUS
THE
VCG
MECHANISM
WILL
INDEED
CHOOSE
THE
ALLOCATION
T
J
N
IN
STEP
OR
SOME
OTHER
ALLOCATION
WITH
EQUAL
VALUE
FROM
PLAYER
I
PERSPECTIVE
THUS
PLAYER
I
MAXIMIZES
ITS
UTILITY
BY
BIDDING
TRUTHFULLY
WE
HAVE
SHOWN
THAT
THE
VCG
MECHANISM
IS
TRUTHFUL
PROVIDED
WE
USE
THE
NEGATIVE
PRICES
IN
HERE
THE
KEY
IDEA
OF
GROVES
SUPPOSE
WE
SHIFT
EACH
PRICE
PI
BY
A
FUNCTION
HI
BJ
J
I
THAT
IS
INDEPENDENT
OF
I
BID
BI
HERE
BY
INDEPENDENT
WE
MEAN
THAT
ONCE
WE
FIX
ALL
BIDS
BJ
FOR
J
I
HI
IS
A
CONSTANT
FUNCTION
OF
BI
IN
PARTICULAR
IT
CANNOT
DEPEND
ON
THE
ALLOCATION
T
N
CHOSEN
BY
THE
VCG
MECHANISM
WHICH
IN
TURN
IS
A
FUNCTION
OF
BI
FOR
EXAMPLE
IN
THE
SINGLE
ITEM
CASE
HI
BJ
J
I
COULD
BE
THE
HIGHEST
BID
MAXJ
I
BJ
BY
SOME
OTHER
PLAYER
BELOW
WE
USE
THE
STANDARD
SHORTHAND
B
I
TO
DENOTE
THE
SET
BJ
J
I
OF
BIDS
BY
PLAYERS
OTHER
THAN
I
THE
CLAIM
IS
THAT
ADDING
SUCH
A
FUNCTION
HI
TO
THE
PRICE
PI
CHARGED
TO
PLAYER
I
DOES
NOT
AFFECT
STRATEGYPROOFNESS
THIS
FOLLOWS
FROM
TWO
SIMPLE
FACTS
FIRST
THE
NEW
OBJECTIVE
FOR
PLAYER
I
GIVEN
FIXED
BIDS
B
I
BY
THE
OTHER
PLAYERS
IS
TO
CHOOSE
A
BID
BI
T
T
TO
MAXIMIZE
VI
T
BJ
T
C
WHERE
C
IS
THE
CONSTANT
HI
B
I
NOTE
THAT
THE
SETS
OF
ALLOCATIONS
MAXIMIZING
AND
ARE
EXACTLY
THE
SAME
SECOND
THE
ALLOCATION
T
N
CHOSEN
BY
THE
VCG
MECHANISM
IS
INDEPENDENT
OF
THE
PRICES
AND
OF
HI
IN
PARTICULAR
AND
DEPENDS
ONLY
ON
THE
BIDS
THUS
BIDDING
TRUTHFULLY
STILL
CAUSES
THE
VCG
MECHANISM
TO
CHOOSE
AN
ALLOCATION
THAT
MAXIMIZES
OVER
ALL
FEASIBLE
ALLOCATIONS
THIS
COMPLETES
THE
PROOF
OF
THE
CLAIM
FINALLY
NOTE
THAT
INSTANTIATING
HI
B
I
MAX
TJ
J
I
BJ
TJ
J
I
FOR
EACH
PLAYER
I
GIVES
THE
VCG
PRICES
SUMMARY
IN
THIS
SECTION
WE
DESCRIBED
THE
CLASSICAL
VCG
MECHANISM
FOR
CAS
THE
MECHANISM
CAN
ALSO
BE
DEFINED
MUCH
MORE
GENERALLY
SEE
ON
THE
PLUS
SIDE
IT
HAS
PROPERTIES
FROM
SUBSECTION
IT
SATISFIES
BOTH
INCENTIVE
CONSTRAINTS
AND
ECONOMIC
EFFICIENCY
EVEN
WITH
GENERAL
VALUATIONS
UNFORTUNATELY
IT
IS
COMPUTATIONALLY
INTRACTABLE
EVEN
THE
BIDDING
STEP
STEP
REQUIRES
AN
EXPONENTIAL
IN
M
AMOUNT
OF
COMMUNICATION
AND
TIME
SINGLE
MINDED
BIDDERS
THE
VCG
MECHANISM
HAS
ALL
OF
THE
PROPERTIES
THAT
WE
D
WANT
OF
A
CA
EXCEPT
FOR
COMPU
TATIONAL
TRACTABILITY
IN
THIS
SECTION
WE
BEGIN
EXPLORING
THE
FOLLOWING
QUESTION
WHICH
HAS
BEEN
SYSTEMATICALLY
STUDIED
ONLY
RELATIVELY
RECENTLY
SINCE
THE
LATE
MOSTLY
BY
COM
PUTER
SCIENTISTS
HOW
MUCH
DO
WE
NEED
TO
RELAX
THE
PROPERTIES
OF
SUBSECTION
TO
RECOVER
COMPUTATIONAL
TRACTABILITY
WE
HAVE
ALREADY
NOTED
THAT
IF
WE
WEAKEN
BY
ASSUMING
THAT
BIDDERS
VALUATIONS
HAVE
NO
COMPLEMENTS
OR
SUBSTITUTES
THEN
WE
CAN
EASILY
ACHIEVE
THE
OTHER
THREE
PROPERTIES
BY
RUNNING
A
SEPARATE
VICKREY
AUCTION
FOR
EACH
GOOD
SEE
THE
DISCUSSION
FOLLOWING
QUESTION
WHAT
CAN
WE
ACCOMPLISH
WITH
AT
LEAST
SOME
DEGREE
OF
COMPLEMENTS
AND
OR
SUBSTITUTES
PRELIMINARIES
IN
THIS
SECTION
WE
WILL
FOCUS
ON
A
HIGHLY
RESTRICTED
CLASS
OF
VALUATIONS
WHICH
ESSENTIALLY
MODEL
AN
EXTREME
FORM
OF
COMPLEMENTS
DEFINITION
LET
BE
A
SET
OF
GOODS
AND
I
A
BIDDER
WITH
VALUATION
VI
THE
BIDDER
I
IS
SINGLE
MINDED
IF
THERE
IS
A
SET
AI
OF
GOODS
AND
A
VALUE
I
SUCH
THAT
VI
TI
I
WHENEVER
TI
AI
AND
VI
TI
OTHERWISE
THUS
FROM
I
PERSPECTIVE
THERE
ARE
ONLY
TWO
DISTINCT
OUTCOMES
EITHER
IT
GETS
ALL
OF
THE
GOODS
IT
WANTS
THE
SET
AI
IN
WHICH
CASE
ITS
VALUE
FOR
ITS
BUNDLE
IS
I
OR
IT
FAILS
TO
GET
ALL
OF
THESE
GOODS
IN
WHICH
CASE
ITS
VALUE
FOR
ITS
BUNDLE
IS
THE
MOTIVATION
FOR
THIS
DEFINITION
IS
TWOFOLD
FIRST
IT
IS
A
CONCEPTUALLY
SIMPLE
TYPE
OF
VALUATION
THAT
NEVERTHELESS
MODELS
ONE
OF
THE
QUINTESSENTIAL
ASPECTS
OF
CAS
COMPLEMENTS
SECOND
IT
IMMEDIATELY
GETS
RID
OF
THE
INITIAL
COMPUTATIONAL
STUMBLING
BLOCK
FOR
THE
VCG
MECHANISM
NOW
PLAYERS
VALUATIONS
CAN
BE
IMPLICITLY
BUT
COMPLETELY
SPECIFIED
IN
TIME
POLY
NOMIAL
IN
N
AND
M
SINCE
EACH
PLAYER
I
CAN
SIMPLY
REPORT
PROXIES
FOR
ITS
SET
AI
AND
VALUE
I
WE
SHOULD
THEREFORE
ASK
THE
FOLLOWING
QUESTION
FOR
THE
SPECIAL
CASE
OF
SINGLE
MINDED
BIDDERS
CAN
THE
VCG
MECHANISM
BE
IMPLEMENTED
TO
RUN
IN
POLYNOMIAL
TIME
IF
THE
ANSWER
IS
YES
THEN
WE
CAN
MOVE
ON
TO
MORE
GENERAL
CLASSES
OF
VALUATIONS
IF
THE
ANSWER
IS
NO
THEN
WE
WILL
NEED
TO
DESIGN
A
NEW
COMPUTATIONALLY
TRACTABLE
MECHANISM
EVEN
FOR
THE
CASE
OF
SINGLE
MINDED
BIDDERS
THE
ANSWER
TO
QUESTION
IS
NO
ASSUMING
P
NP
THE
REASON
IS
THAT
THE
VCG
MECHANISM
IS
COMPUTATIONALLY
INEFFICIENT
IN
TWO
DISTINCT
SENSES
FIRST
AS
WE
HAVE
REPEATEDLY
NOTED
THE
BIDDING
STEP
REQUIRES
EXPONENTIAL
COMMUNICATION
FOR
GENERAL
VALUATIONS
SEC
OND
EVEN
WHEN
THIS
PROBLEM
IS
ASSUMED
AWAY
AS
WITH
SINGLE
MINDED
BIDDERS
THE
ALLOCATION
STEP
OF
VCG
CAN
REQUIRE
EXPONENTIAL
COMPUTATION
PRECISELY
CONSIDER
THE
OPTIMIZATION
PROBLEM
OF
MAXIMIZING
THE
SURPLUS
GIVEN
THE
TRUE
VALUATIONS
OF
THE
BIDDERS
THIS
PROBLEM
IS
TYPICALLY
CALLED
THE
WINNER
DETERMINATION
WD
PROBLEM
NOTE
THAT
STEP
OF
THE
VCG
MECHANISM
IS
PRECISELY
THE
WD
PROBLEM
WHERE
BIDS
ARE
USED
AS
SURROGATES
FOR
TRUE
VALUATIONS
FOR
SINGLE
MINDED
BIDDERS
THE
WD
PROBLEM
HAS
THE
FOLLOWING
FORM
GIVEN
THE
VALUATIONS
TRUTHFUL
BIDS
OF
THE
PLAYERS
AS
SPECIFIED
BY
THE
PAIRS
AN
N
GRANT
A
SET
OF
DISJOINT
BIDS
I
E
A
SUBSET
OF
PLAYERS
SUCH
THAT
THE
CORRESPONDING
AI
ARE
PAIRWISE
DISJOINT
TO
MAXIMIZE
THE
SUM
I
OF
THE
VALUES
OF
THE
GRANTED
BIDS
WE
NEXT
SHOW
THAT
THE
WD
PROBLEM
IS
HARD
EVEN
IN
THE
SPECIAL
CASE
OF
SINGLE
MINDED
BIDDERS
PROPOSITION
THE
WD
PROBLEM
FOR
SINGLE
MINDED
BIDDERS
IS
NP
HARD
PROOF
BY
A
REDUCTION
FROM
THE
NP
HARD
PROBLEM
WEIGHTED
INDEPENDENT
SET
WIS
GIVEN
AN
INSTANCE
OF
WIS
SPECIFIED
BY
A
GRAPH
G
V
E
AND
A
WEIGHT
WV
FOR
EACH
VERTEX
V
V
CONSTRUCT
THE
FOLLOWING
INSTANCE
OF
THE
WD
PROBLEM
THE
SET
OF
GOODS
IS
THE
SET
E
OF
EDGES
OF
G
THE
SET
OF
PLAYERS
IS
THE
SET
V
OF
VERTICES
FOR
A
VERTEX
PLAYER
V
V
SET
V
WV
AND
AV
EQUAL
TO
THE
SET
OF
EDGES
OF
G
THAT
ARE
INCIDENT
TO
V
A
SUBSET
OF
VERTICES
PLAYERS
IS
THEN
A
WIS
OF
G
IF
AND
ONLY
IF
IT
IS
A
SUBSET
OF
BIDS
THAT
CAN
BE
SIMULTANEOUSLY
GRANTED
MOREOVER
THIS
BIJECTIVE
CORRESPONDENCE
PRESERVES
THE
TOTAL
WEIGHT
VALUE
OF
THE
SOLUTION
UNFORTUNATELY
WIS
IS
NOT
JUST
AN
NP
HARD
PROBLEM
IT
IS
A
REALLY
HARD
NP
HARD
PROB
LEM
TO
MAKE
THIS
PRECISE
RECALL
THAT
A

APPROXIMATION
ALGORITHM
FOR
A
MAXIMIZATION
PROBLEM
IS
A
POLYNOMIAL
TIME
ALGORITHM
THAT
ALWAYS
RECOVERS
AT
LEAST
A

FRACTION
OF
THE
VALUE
OF
AN
OPTIMAL
SOLUTION
BY
OUR
CONVENTION

IS
ALWAYS
AT
LEAST
FACT
FOR
EVERY
THERE
IS
NO
O
E
APPROXIMATION
ALGORITHM
FOR
WIS
WHERE
N
DENOTES
THE
NUMBER
OF
VERTICES
UNLESS
NP
ZPP
FACT
BASICALLY
SAYS
THAT
THE
WIS
PROBLEM
ADMITS
NO
NON
TRIVIAL
APPROXIMATION
ALGORITHM
NOTE
THAT
SIMPLY
PICKING
THE
MAX
WEIGHT
VERTEX
GIVES
AN
N
APPROXIMATION
FOR
WIS
MORE
RELEVANT
FOR
CAS
IS
THE
FOLLOWING
CONSEQUENCE
OF
FACT
COROLLARY
FOR
EVERY
THERE
IS
NO
O
M
E
APPROXIMATION
ALGORITHM
FOR
WIS
WHERE
M
DENOTES
THE
NUMBER
OF
EDGES
UNLESS
NP
ZPP
COROLLARY
FOLLOWS
FROM
FACT
BECAUSE
THE
NUMBER
OF
EDGES
OF
A
SIMPLE
GRAPH
IS
AT
MOST
QUADRATIC
IN
THE
NUMBER
OF
VERTICES
BECAUSE
THE
REDUCTION
IN
THE
PROOF
OF
PROPOSITION
IS
APPROXIMATION
PRESERVING
IT
GIVES
A
BIJECTION
THAT
PRESERVES
THE
OBJECTIVE
FUNCTION
VALUES
OF
CORRESPONDING
SOLUTIONS
OF
WIS
AND
WD
IT
IMPLIES
THE
FOLLOWING
STRONG
NEGATIVE
RESULT
ABOUT
APPROXIMATING
THE
WD
PROBLEM
WITH
SINGLE
MINDED
BIDDERS
COROLLARY
FOR
EVERY
THERE
IS
NO
O
M
E
APPROXIMATION
ALGORITHM
FOR
WD
WITH
SINGLE
MINDED
BIDDERS
WHERE
M
DENOTES
THE
NUMBER
OF
GOODS
UNLESS
NP
ZPP
THE
UPSHOT
OF
COROLLARY
IS
RATHER
BLEAK
IF
WE
WANT
A
POLYNOMIAL
TIME
CA
PROPERTY
FROM
SUBSECTION
THEN
EVEN
IF
WE
ASSUME
SINGLE
MINDED
BIDDERS
SACRIFICING
SIGNIFICANT
VALUATION
GENERALITY
AND
EVEN
IF
WE
IGNORE
INCENTIVE
COMPATIBILITY
THEN
WE
MUST
TAKE
A
BIG
HIT
ON
PROPERTY
AND
SETTLE
FOR
AT
BEST
AN
O
M
APPROXIMATION
OF
THE
SURPLUS
AT
LEAST
THE
BAD
NEWS
STOPS
HERE
WE
NEXT
DESIGN
A
CA
FOR
SINGLE
MINDED
BIDDERS
THAT
IS
POLY
TIME
IMPLEMENTABLE
ACHIEVES
THE
BEST
POSSIBLE
APPROXIMATION
OF
THE
SURPLUS
UNDER
THIS
CONSTRAINT
O
M
AND
ALSO
SATISFIES
THE
INCENTIVE
CONSTRAINTS
WE
PRESENT
THIS
CA
IN
TWO
PARTS
FIRST
WE
PRESENT
A
POLY
TIME
O
M
APPROXIMATION
ALGORITHM
FOR
WD
WITH
SINGLE
MINDED
BIDDERS
SUBSECTION
THEN
WE
SHOW
HOW
TO
CHARGE
PRICES
TO
TURN
THIS
WD
ALGORITHM
INTO
AN
INCENTIVE
COMPATIBLE
MECHANISM
SUBSECTION
APPROXIMATE
WINNER
DETERMINATION
WE
NOW
DESIGN
AN
APPROXIMATION
ALGORITHM
FOR
THE
FOLLOWING
PROBLEM
GIVEN
A
SET
OF
M
GOODS
AND
TRUTHFUL
BIDS
AN
N
WHICH
BIDS
SHOULD
WE
GRANT
TO
MAXIMIZE
THE
TOTAL
VALUE
OF
GRANTED
BIDS
HERE
BY
GRANT
BID
AI
I
WE
MEAN
ASSIGN
PLAYER
I
THE
BUNDLE
TI
AI
OBVIOUSLY
GRANTED
BIDS
SHOULD
BE
PAIRWISE
DISJOINT
WE
WILL
DESIGN
A
GREEDY
APPROXIMATION
ALGORITHM
FOR
THIS
WD
PROBLEM
TO
MOTIVATE
THE
ALGORITHM
WE
FIRST
CONSIDER
TWO
GREEDY
ALGORITHMS
THAT
FAIL
TO
ACHIEVE
THE
TARGET
PERFORMANCE
GUARANTEE
OF
O
M
EXAMPLE
SUPPOSE
WE
SORT
THE
BIDS
IN
DECREASING
ORDER
OF
VALUE
AND
GRANT
THEM
GREEDILY
IN
OTHER
WORDS
WE
GO
THROUGH
THE
BIDS
ONE
BY
ONE
IN
SORTED
ORDER
AND
WE
GRANT
A
BID
IF
AND
ONLY
IF
ALL
OF
ITS
ITEMS
ARE
STILL
AVAILABLE
THE
FOLLOWING
EXAMPLE
IS
BAD
FOR
THIS
ALGORITHM
THERE
IS
A
SET
OF
M
GOODS
AND
N
M
PLAYERS
SET
AND
WHERE
IS
ARBITRARILY
SMALL
FOR
I
M
SET
I
AND
AI
EQUAL
TO
THE
I
TH
GOOD
OF
OUR
GREEDY
ALGORITHM
GRANTS
THE
FIRST
BID
AND
ACHIEVES
A
SURPLUS
OF
THE
OPTIMAL
SOLUTION
GRANTS
THE
REST
OF
THE
BIDS
AND
ACHIEVES
A
SURPLUS
OF
M
THUS
THIS
ALGORITHM
IS
NO
BETTER
THAN
AN
M
APPROXIMATION
FOR
THE
WD
PROBLEM
THE
GREEDY
ALGORITHM
IN
EXAMPLE
PERFORMS
POORLY
BECAUSE
IT
FAILS
TO
ACCOUNT
FOR
THE
FACT
THAT
A
BIG
BID
I
E
A
BID
FOR
MANY
ITEMS
CAN
BLOCK
A
LARGE
NUMBER
OF
SMALL
BIDS
THAT
EACH
HAVE
ALMOST
THE
SAME
VALUE
AS
THE
BIG
ONE
A
NATURAL
WAY
TO
FIX
THIS
PROBLEM
IS
TO
SOMEHOW
NORMALIZE
THE
VALUE
OF
A
BID
ACCORDING
TO
THE
NUMBER
OF
ITEMS
THAT
IT
REQUIRES
THIS
MOTIVATES
OUR
SECOND
GREEDY
ALGORITHM
EXAMPLE
SUPPOSE
WE
INSTEAD
SORT
THE
BIDS
IN
DECREASING
ORDER
OF
I
AI
VALUE
PER
GOOD
AND
GRANT
BIDS
GREEDILY
THIS
ALGORITHM
CERTAINLY
RETURNS
THE
OPTIMAL
SOLUTION
FOR
THE
INPUT
IN
EXAMPLE
WHAT
IS
ITS
PERFORMANCE
IN
GENERAL
CONSIDER
THE
FOLLOWING
EXAMPLE
A
SET
OF
M
GOODS
ONE
PLAYER
WITH
AND
M
AND
A
SECOND
PLAYER
WITH
AND
THE
ABOVE
GREEDY
ALGORITHM
GRANTS
THE
SECOND
BID
THE
OPTIMAL
SOLUTION
GRANTS
THE
FIRST
BID
THUS
THE
GREEDY
ALGORITHM
IS
NO
BETTER
THAN
AN
M
APPROXIMATION
ALGORITHM
FOR
MAXIMIZING
THE
SURPLUS
THE
GREEDY
ALGORITHM
IN
EXAMPLE
PERFORMS
POORLY
BECAUSE
IT
UNDERVALUES
LARGE
BIDS
THAT
PRIMARILY
COMPRISE
ITEMS
FOR
WHICH
THERE
IS
NO
CONTENTION
OUR
FINAL
ALGORITHM
THE
LOS
ALGORITHM
DUE
TO
LEHMANN
O
CALLAGHAN
AND
SHOHAM
INTERPOLATES
BETWEEN
THE
GREEDY
ALGORITHMS
OF
EXAMPLES
AND
AND
CONSIDERS
BIDS
IN
DECREASING
ORDER
OF
I
AI
SEE
FIGURE
EXERCISE
MODIFY
EXAMPLES
AND
TO
OBTAIN
TWO
DIFFERENT
EXAMPLES
SHOWING
THAT
THE
LOS
ALGORITHM
IS
NO
BETTER
THAN
A
M
APPROXIMATION
ALGORITHM
FOR
THE
WD
PROBLEM
PERHAPS
SURPRISINGLY
THIS
SIMPLE
MODIFICATION
IS
ENOUGH
TO
OBTAIN
AN
ESSENTIALLY
BEST
POSSIBLE
APPROXIMATION
RATIO
RECALL
COROLLARY
THEOREM
THE
LOS
ALGORITHM
IS
A
M
APPROXIMATION
ALGORITHM
FOR
THE
WD
PROBLEM
WITH
SINGLE
MINDED
BIDDERS
INPUT
A
SET
OF
M
GOODS
TRUTHFUL
BIDS
AN
N
REINDEX
THE
BIDS
SO
THAT
N
A
A
A
FOR
I
N
IF
NO
ITEMS
OF
AI
HAVE
ALREADY
BEEN
ASSIGNED
TO
A
PREVIOUS
PLAYER
SET
TI
AI
OTHERWISE
SET
TI
FIGURE
THE
LOS
APPROXIMATE
WINNER
DETERMINATION
ALGORITHM
PROOF
FIX
A
SET
OF
M
GOODS
AND
BIDS
AN
N
LET
X
N
DENOTE
THE
INDICES
OF
THE
BIDS
GRANTED
BY
THE
LOS
GREEDY
ALGORITHM
AND
X
THOSE
OF
AN
OPTIMAL
SET
OF
BIDS
WE
NEED
TO
SHOW
THAT
I
X
I
M
I
I
X
OUR
PROOF
APPROACH
IS
A
NATURAL
ONE
FOR
ANALYZING
A
GREEDY
ALGORITHM
WE
USE
THE
GREEDY
CRI
TERION
TO
ESTABLISH
A
LOCAL
BOUND
BETWEEN
PIECES
OF
THE
GREEDY
AND
OPTIMAL
SOLUTIONS
AND
THEN
COMBINE
THESE
LOCAL
BOUNDS
INTO
THE
GLOBAL
BOUND
WE
NEXT
MAKE
A
SIMPLE
BUT
CRUCIAL
DEFINITION
WE
SAY
THAT
A
BID
I
X
BLOCKS
A
BID
I
X
IF
AI
AI
WE
ALLOW
I
I
IN
THIS
DEFINITION
NOTE
THAT
IF
I
BLOCKS
I
AND
I
I
THEN
THE
BIDS
AI
AND
AI
CANNOT
BOTH
BE
GRANTED
THE
GREEDY
AND
OPTIMAL
ALGORITHMS
MADE
DIFFERENT
DECISIONS
AS
TO
HOW
TO
RESOLVE
THIS
CONFLICT
FOR
A
BID
I
X
LET
FI
X
DENOTE
THE
BIDS
OF
X
FIRST
BLOCKED
BY
I
I
E
I
X
IS
PLACED
IN
FI
IF
AND
ONLY
IF
I
IS
THE
FIRST
BID
IN
THE
GREEDY
ORDERING
THAT
BLOCKS
I
TWO
KEY
POINTS
FIRST
WE
CAN
ALREADY
DESCRIBE
OUR
LOCAL
BOUND
RELATING
PIECES
OF
THE
OPTIMAL
AND
GREEDY
SOLUTIONS
SUPPOSE
I
FI
THE
BID
I
X
IS
FIRST
BLOCKED
BY
I
X
THEN
AT
THE
TIME
THE
GREEDY
ALGORITHM
CHOSE
TO
GRANT
THE
BID
I
THE
BID
I
WAS
NOT
YET
BLOCKED
AND
WAS
A
VIABLE
ALTERNATIVE
BY
WE
MUST
HAVE
I
AI
I
AI
WHENEVER
I
FI
THE
SECOND
KEY
POINT
IS
THAT
EACH
OPTIMAL
BID
I
X
LIES
IN
PRECISELY
ONE
SET
FI
EACH
BID
I
X
MUST
BE
BLOCKED
BY
AT
LEAST
ONE
BID
OF
X
POSSIBLY
BY
ITSELF
SINCE
I
WOULD
ONLY
BY
PASSED
OVER
BY
THE
GREEDY
ALGORITHM
IF
IT
WAS
BLOCKED
BY
SOME
PREVIOUSLY
GRANTED
BID
THUS
THE
FI
ARE
A
PARTITION
OF
X
IN
PARTICULAR
I
X
I
I
I
X
I
FI
THIS
FACT
ALLOWS
US
TO
CONSIDER
EACH
BID
I
X
SEPARATELY
AND
THEN
COMBINE
THE
RESULTS
TO
OBTAIN
THE
GLOBAL
BOUND
NOW
FIX
A
BID
I
X
SUMMING
OVER
ALL
I
FI
IN
WE
HAVE

I
A
COMPARE
TO
THE
KEY
QUESTION
IS
HOW
BIG
CAN
THE
EXPRESSION
IN
PARENTHESES
ON
THE
RHS
OF
BE
FIRST
SINCE
ALL
BIDS
OF
FI
WERE
SIMULTANEOUSLY
GRANTED
BY
THE
OPTIMAL
SOLUTION
THEY
MUST
BE
DISJOINT
AND
HENCE
AI
M
I
FI
THE
WORST
CASE
IS
THAT
THIS
INEQUALITY
HOLDS
WITH
EQUALITY
HOW
WOULD
WE
THEN
PARTITION
AMONG
THE
FI
BIDS
OF
FI
TO
MAXIMIZE
I
FI
AI
THE
ANSWER
IS
THAT
WE
WOULD
SPREAD
THE
GOODS
OUT
EQUALLY
M
FI
GOODS
IN
EACH
SET
FORMALLY
THIS
FOLLOWS
FROM
THE
CAUCHY
SCHWARZ
INEQUALITY
OR
FROM
THE
CONCAVITY
OF
THE
SQUARE
ROOT
FUNCTION
IT
SHOULD
ALSO
BE
EASY
TO
CONVINCE
YOURSELF
OF
THIS
FACT
WITH
SIMPLE
EXAMPLES
E
G
THE
FI
CASE
THESE
FACTS
AND
GIVE


M
M
I
F
FINALLY
SINCE
THE
BID
I
BLOCKS
ALL
OF
THE
BIDS
OF
FI
AND
BIDS
OF
FI
ARE
DISJOINT
IN
THE
WORST
CASE
EACH
ITEM
OF
AI
BLOCKS
A
DISTINCT
BID
OF
FI
CF
EXAMPLE
THUS
FI
AI
WHICH
IMPLIES
I
M
I
I
FI
SUMMING
OVER
ALL
I
X
AND
APPLYING
COMPLETES
THE
PROOF
OF
EXERCISE
SUPPOSE
WE
MODIFY
THE
LOS
ALGORITHM
TO
GRANT
BIDS
GREEDILY
IN
DECREASING
ORDER
OF
I
AI
P
WHERE
P
IS
A
PARAMETER
WHAT
IS
THE
APPROXIMATION
RATIO
OF
THIS
ALGORITHM
AS
A
FUNCTION
OF
P
A
TRUTHFUL
PAYMENT
SCHEME
NOW
THAT
WE
VE
DESIGNED
A
BEST
POSSIBLE
APPROXIMATE
WD
ALGORITHM
SUBJECT
TO
THE
CON
STRAINT
OF
POLY
TIME
COMPUTATION
WE
NEXT
AIM
TO
EXTEND
IT
TO
A
TRUTHFUL
MECHANISM
BY
CHARGING
SUITABLE
PRICES
IN
PARTICULAR
RECALL
THAT
THE
LOS
ALGORITHM
ASSUMES
THAT
ITS
INPUT
IS
A
SET
OF
TRUTHFUL
BIDS
TO
JUSTIFY
THIS
ASSUMPTION
WE
SEEK
PRICES
THAT
RESULT
IN
A
STRATE
GYPROOF
MECHANISM
OTHERWISE
THE
ALGORITHM
IS
OPTIMIZING
USING
THE
WRONG
INPUT
SO
ITS
APPROXIMATION
GUARANTEE
IS
MEANINGLESS
A
NATURAL
IDEA
IS
TO
PLUG
THE
LOS
WD
ALGORITHM
INTO
STEP
OF
THE
VCG
MECHANISM
IN
OTHER
WORDS
FIRST
ALL
PLAYERS
REPORT
THEIR
SET
AI
AND
VALUE
I
THEN
WE
DETERMINE
AN
ALLOCATION
USING
THE
LOS
ALGORITHM
AND
THEN
WE
CHARGE
PLAYER
I
A
PRICE
EQUAL
TO
THE
MONETARY
DAMAGE
IT
CAUSES
THE
OTHER
PLAYERS
NOTE
THAT
THIS
IS
A
POLY
TIME
MECHANISM
BUT
IS
IT
TRUTHFUL
EXAMPLE
CONSIDER
THE
FOLLOWING
MODIFICATION
TO
EXAMPLE
THE
FIRST
PLAYER
HAS
THE
SET
AND
VALUE
M
FOR
I
M
THE
ITH
PLAYER
WANTS
ONLY
THE
I
TH
ITEM
AND
HAS
VALUE
I
IF
ALL
PLAYERS
BID
TRUTHFULLY
THEN
THE
LOS
ALGORITHM
WILL
GRANT
ONLY
THE
FIRST
PLAYER
BID
BUT
IF
WE
DELETE
THE
FIRST
PLAYER
BID
THEN
ALL
OF
THE
OTHER
PLAYERS
BIDS
WILL
BE
GRANTED
BY
THE
LOS
ALGORITHM
THUS
THE
MONETARY
DAMAGE
CAUSED
BY
THE
FIRST
PLAYER
TO
THE
REST
EQUALS
M
BUT
THEN
THE
PRICE
CHARGED
TO
THE
FIRST
PLAYER
BY
THE
VCG
MECHANISM
IS
M
EVEN
THOUGH
ITS
BID
WAS
ONLY
M
AND
THIS
PLAYER
WINDS
UP
WITH
NEGATIVE
UTILITY
THUS
THE
VCG
MECHANISM
TOGETHER
WITH
THE
LOS
ALGORITHM
IS
NOT
TRUTHFUL
E
G
THE
FIRST
PLAYER
COULD
OBTAIN
ZERO
UTILITY
BY
BIDDING
A
VALUE
OF
AND
IS
NOT
EVEN
INDIVIDUALLY
RATIONAL
IN
THE
SENSE
OF
PROPOSITION
IN
FACT
THE
VCG
MECHANISM
IS
INCOMPATIBLE
WITH
APPROXIMATE
WD
ALGORITHMS
IN
A
QUITE
GENERAL
SENSE
SEE
NISAN
AND
RONEN
FOR
A
DETAILED
STUDY
OF
THIS
ISSUE
THE
MORAL
OF
EXAMPLE
IS
THAT
IF
WE
WANT
TO
EXTEND
THE
LOS
ALGORITHM
TO
A
TRUTH
FUL
MECHANISM
THEN
WE
HAVE
TO
CAREFULLY
DESIGN
A
PRICING
SCHEME
THAT
IS
TAILORED
TO
THE
ALGORITHM
THE
SOLUTION
TO
THIS
NON
TRIVIAL
PROBLEM
FOLLOWS
THE
HIGH
LEVEL
IDEA
OF
THE
LOS
PRICING
SCHEME
IS
TO
CHARGE
PRICES
THAT
ARE
VICKREY
LIKE
IN
THE
SENSE
THAT
A
WINNER
I
SHOULD
PAY
ACCORDING
TO
A
SUITABLE
FUNCTION
OF
THE
HIGHEST
VALUE
BID
THAT
I
BID
BLOCKS
THIS
MOTIVATES
A
KEY
DEFINITION
DEFINITION
SUPPOSE
BID
I
WAS
GRANTED
BY
THE
LOS
ALGORITHM
WHILE
BID
J
WAS
DENIED
THE
BID
I
UNIQUELY
BLOCKS
THE
BID
J
IF
AFTER
DELETING
THE
BID
I
FROM
THE
INPUT
THE
LOS
ALGORITHM
GRANTS
THE
BID
J
WE
WILL
USE
THE
TERMINOLOGY
U
BLOCKS
AS
SHORTHAND
FOR
UNIQUELY
BLOCKS
DEFINITION
IS
SOMEWHAT
SUBTLE
WE
GIVE
A
SIMPLE
EXAMPLE
AND
ENCOURAGE
THE
READER
TO
EXPLORE
MORE
COMPLICATED
ONES
EXAMPLE
FIGURE
SHOWS
A
ROUGH
PICTURE
OF
FOUR
BIDS
THE
BIDS
ARE
NUMBERED
ACCORD
ING
TO
THE
LOS
GREEDY
ORDERING
OVERLAP
BETWEEN
TWO
CIRCLES
IS
MEANT
TO
INDICATE
THAT
THE
TWO
BIDS
SHARE
AT
LEAST
ONE
ITEM
GIVEN
THE
FULL
INPUT
THE
LOS
ALGORITHM
WILL
GRANT
THE
FIRST
TWO
BIDS
AND
DENY
THE
LAST
TWO
IF
THE
FIRST
BID
IS
DELETED
THE
LOS
ALGORITHM
WILL
GRANT
THE
SECOND
AND
FOURTH
BIDS
THUS
THE
FIRST
BID
U
BLOCKS
THE
FOURTH
BID
BUT
IT
DOES
NOT
U
BLOCK
THE
THIRD
BID
EXERCISE
SHOW
THAT
THE
TERMINOLOGY
U
BLOCK
IS
SOMEWHAT
MISLEADING
IN
THE
FOLLOWING
SENSE
A
BID
BI
BI
CAN
U
BLOCK
A
BID
BJ
BJ
EVEN
IF
BI
AND
BJ
ARE
DISJOINT
ON
THE
OTHER
HAND
SHOW
THAT
IF
BJ
BJ
IS
THE
FIRST
BID
IN
THE
LOS
ORDERING
THAT
IS
U
BLOCKED
BY
BI
BI
THEN
BI
BJ
FIGURE
ILLUSTRATION
OF
DEFINITION
U
BLOCKING
THE
IDEA
OF
THE
LOS
PRICING
SCHEME
IS
TO
CHARGE
A
WINNING
BIDDER
ACCORDING
TO
THE
HIGHEST
VALUE
BID
THAT
IT
U
BLOCKS
HERE
HIGHEST
VALUE
SHOULD
BE
SUITABLY
NORMALIZED
BY
BID
SIZE
TO
REFLECT
THE
WAY
THE
LOS
ALGORITHM
CHOOSES
ITS
ORDERING
PRECISELY
THE
LOS
PRICES
ARE
AS
FOLLOWS
IF
THE
BIDDER
I
LOSES
OR
IF
ITS
BID
WINS
BUT
U
BLOCKS
NO
OTHER
BID
THEN
PI
OTHERWISE
SUPPOSE
I
BID
IS
BI
BI
AND
LET
BJ
BJ
BE
THE
FIRST
BID
IN
THE
LOS
GREEDY
ORDERING
THAT
I
BID
U
BLOCKS
SET
P
BJ
BJ
BI
BY
THE
LOS
MECHANISM
WE
MEAN
THE
CA
THAT
USES
THE
WD
ALGORITHM
OF
SUBSECTION
FOLLOWED
BY
THE
ABOVE
CHARGING
SCHEME
INDIVIDUAL
RATIONALITY
IS
ALMOST
IMMEDIATE
PROPOSITION
TRUTHTELLING
BIDDERS
ALWAYS
OBTAIN
NONNEGATIVE
UTILITY
IN
THE
LOS
MECH
ANISM
PROOF
WE
NEED
TO
SHOW
THAT
THE
PRICE
PI
CHARGED
TO
A
WINNING
BIDDER
I
IS
AT
MOST
ITS
BID
BI
LET
BJ
BJ
BE
THE
FIRST
BID
THAT
BI
BI
U
BLOCKS
IF
THERE
IS
NO
SUCH
BID
THEN
PI
AND
THERE
NOTHING
TO
PROVE
SINCE
BJ
BJ
MUST
FOLLOW
BI
BI
IN
THE
LOS
ORDERING
BI
BJ
I
J
REARRANGING
GIVES
BI
PI
AS
DESIRED
STRATEGYPROOFNESS
IS
MUCH
LESS
OBVIOUS
THEOREM
THE
LOS
MECHANISM
IS
STRATEGYPROOF
AGAIN
WE
LEAVE
IT
TO
THE
READER
TO
INVESTIGATE
THE
EXTENT
TO
WHICH
THE
LOS
MECHANISM
IS
STRONGLY
TRUTHFUL
IN
THE
SENSE
OF
PROPOSITION
OUR
FIRST
STEP
IN
PROVING
THEOREM
IS
TO
SHOW
THAT
BIDDERS
HAVE
NO
INCENTIVE
TO
LIE
ABOUT
THEIR
DESIRED
SETS
THE
AI
LEMMA
IF
A
PLAYER
I
CAN
BENEFIT
IN
THE
LOS
MECHANISM
FROM
A
FALSE
BID
BI
BI
THEN
IT
CAN
BENEFIT
FROM
SUCH
A
BID
IN
WHICH
BI
AI
PROOF
SUPPOSE
THERE
IS
A
PLAYER
I
AND
A
SET
OF
BIDS
BJ
BJ
J
I
FOR
THE
OTHER
N
PLAYERS
SUCH
THAT
I
OBTAINS
STRICTLY
GREATER
UTILITY
FROM
FALSELY
BIDDING
BI
BI
THAN
FROM
TRUTHFULLY
BIDDING
AI
I
BY
PROPOSITION
THIS
CAN
ONLY
OCCUR
IF
THE
LOS
MECHANISM
GRANTS
THE
BID
BI
BI
WE
AIM
TO
SHOW
THAT
THE
FALSE
BID
AI
BI
ALSO
LEADS
TO
GREATER
UTILITY
THAN
THE
BID
AI
I
FIRST
NOTE
THAT
IN
THE
FALSE
BID
BI
BI
WE
MUST
HAVE
BI
AI
IF
BI
IS
MISSING
ANY
ITEMS
FROM
AI
THEN
THE
LOS
MECHANISM
WILL
NEVER
PRODUCE
AN
OUTCOME
IN
WHICH
I
HAS
STRICTLY
POSITIVE
UTILITY
AND
BY
PROPOSITION
A
TRUTHFUL
BID
ALWAYS
LEADS
TO
NONNEGATIVE
UTILITY
SO
SUPPOSE
BI
CONTAINS
AI
AND
THAT
THE
LOS
MECHANISM
GRANTS
THE
BID
BI
BI
WE
CAN
COMPLETE
THE
PROOF
BY
SHOWING
THAT
THE
LOS
MECHANISM
WOULD
HAVE
ALSO
GRANTED
THE
BID
AI
BI
AND
WOULD
HAVE
ONLY
CHARGED
PLAYER
I
A
SMALLER
PRICE
THE
FIRST
PART
OF
THE
ABOVE
STATEMENT
IS
EASY
TO
SEE
SINCE
AI
BI
THE
BID
AI
BI
WOULD
ONLY
BE
CONSIDERED
EARLIER
IN
THE
GREEDY
LOS
ORDERING
AND
WOULD
THEREFORE
BE
GRANTED
FOR
THE
SECOND
PART
RECALL
FROM
THAT
THE
PRICE
CHARGED
TO
PLAYER
I
BY
THE
LOS
MECHANISM
IS
PI
BJ
BI
BJ
WHERE
J
IS
THE
EARLIEST
BID
U
BLOCKED
BY
I
IF
ANY
BIDDING
AI
INSTEAD
OF
BI
AFFECTS
THIS
PRICE
IN
TWO
WAYS
FIRST
THE
SECOND
TERM
ON
THE
RHS
OF
CLEARLY
ONLY
GOES
DOWN
THE
SECOND
TRICKIER
CONSEQUENCE
IS
THAT
THE
IDENTITY
OF
THE
FIRST
U
BLOCKED
BID
COULD
CHANGE
SO
SUPPOSE
THE
FIRST
BID
U
BLOCKED
BY
THE
BID
BI
BI
IS
BJ
BJ
AND
THAT
BY
AI
BI
IS
BK
BK
TO
RULE
OUT
THE
POSSIBILITY
THAT
THERE
IS
NO
U
BLOCKED
BID
ADD
AN
IMAGINARY
BID
FOR
ALL
OF
THE
ITEMS
THAT
HAS
ZERO
VALUE
THE
FINAL
KEY
CLAIM
WHICH
WE
LEAVE
AS
AN
EXERCISE
IS
THAT
BK
BK
CAN
ONLY
FOLLOW
BJ
BJ
IN
THE
GREEDY
LOS
ORDERING
THIS
IMPLIES
THAT
BIDDING
AI
INSTEAD
OF
BI
CAN
ONLY
DECREASE
THE
FIRST
TERM
ON
THE
RHS
OF
AND
COMPLETES
THE
PROOF
EXERCISE
COMPLETE
THE
PROOF
OF
LEMMA
ASSUME
THAT
BI
AI
AND
SHOW
THAT
IF
BJ
BJ
AND
BK
BK
ARE
THE
FIRST
BIDS
U
BLOCKED
BY
THE
BIDS
BI
BI
AND
AI
BI
RESPECTIVELY
THEN
BK
BK
CAN
ONLY
FOLLOW
BJ
BJ
IN
THE
GREEDY
LOS
ORDERING
SEE
ALSO
THE
PROOF
OF
THEOREM
BELOW
FOR
A
SIMILAR
ARGUMENT
WE
NOW
COMPLETE
THE
PROOF
OF
THEOREM
PROOF
OF
THEOREM
AS
IN
THE
PROOF
OF
LEMMA
ASSUME
FOR
CONTRADICTION
THAT
THERE
IS
A
PLAYER
I
AND
A
SET
OF
BIDS
BJ
BJ
J
I
FOR
THE
OTHER
N
PLAYERS
SUCH
THAT
I
OBTAINS
STRICTLY
GREATER
UTILITY
FROM
FALSELY
BIDDING
BI
BI
THAN
FROM
TRUTHFULLY
BIDDING
AI
I
BY
LEMMA
WE
CAN
ASSUME
THAT
BI
AI
LET
B
I
DENOTE
THE
SET
BJ
BJ
J
I
OF
OTHER
PLAYERS
BIDS
BT
THE
SET
B
I
AI
I
AND
BF
THE
SET
B
I
AI
BI
BY
PROPOSITION
WE
CAN
ASSUME
THAT
THE
LOS
MECHANISM
GRANTED
THE
BID
AI
BI
GIVEN
THE
INPUT
BF
THERE
ARE
TWO
CASES
WE
CONSIDER
ONLY
THE
CASE
WHERE
BI
I
AND
LEAVE
THE
OTHER
CASE
AS
AN
EXERCISE
WE
CAN
ASSUME
THAT
THE
BID
AI
BI
WAS
GRANTED
SINCE
I
BI
THE
BID
AI
I
WOULD
HAVE
ONLY
BEEN
CONSIDERED
EARLIER
IN
THE
LOS
ORDERING
AND
THUS
WOULD
ALSO
HAVE
BEEN
GRANTED
SUPPOSE
THAT
BJ
BJ
IS
THE
FIRST
BID
U
BLOCKED
BY
THE
FALSE
BID
AI
BI
WE
CAN
COMPLETE
THE
PROOF
BY
SHOWING
THAT
AI
I
DOES
NOT
U
BLOCK
ANY
BID
EARLIER
THAN
BJ
BJ
AS
THEN
THE
PRICE
CHARGED
BY
THE
LOS
MECHANISM
ON
INPUT
BT
FOR
THE
BID
AI
I
IS
AT
MOST
THAT
FOR
THE
BID
AI
BI
ON
THE
INPUT
BF
SUPPOSE
FOR
CONTRADICTION
THAT
THE
FIRST
BID
BK
BK
THAT
AI
I
U
BLOCKS
PRECEDES
BJ
BJ
IN
THE
LOS
ORDERING
BY
THE
DEFINITION
OF
U
BLOCKING
REMOVING
THE
BID
AI
I
FROM
BT
AND
RERUNNING
THE
LOS
ALGORITHM
ON
THE
INPUT
B
I
CAUSES
THE
BID
BK
BK
TO
BE
GRANTED
A
KEY
OBSERVATION
IS
THIS
IF
AI
BI
FOLLOWS
BK
BK
IN
THE
LOS
ORDERING
BK
BK
WOULD
ALSO
BE
GRANTED
BY
THE
LOS
ALGORITHM
ON
THE
INPUT
BF
THIS
HOLDS
BECAUSE
THE
LOS
ALGORITHM
MAKES
IDENTICAL
DECISIONS
ON
THE
INPUTS
B
I
AND
BF
UNTIL
THE
POINT
THAT
THE
BID
AI
BI
IS
CONSIDERED
IN
THE
LATTER
EXECUTION
SINCE
EXERCISE
B
IMPLIES
THAT
AI
AND
BK
MUST
HAVE
AT
LEAST
ONE
ITEM
IN
COMMON
AND
SINCE
THE
BID
AI
BI
IS
GRANTED
BY
THE
LOS
ALGORITHM
GIVEN
THE
INPUT
BF
THIS
OBSERVATION
IMPLIES
THAT
AI
BI
PRECEDES
BK
BK
IN
THE
LOS
ORDERING
BUT
THEN
AI
BI
U
BLOCKS
BK
BK
CONTRADICTING
THE
ASSUMPTION
THAT
BK
BK
PRECEDES
THE
FIRST
BID
BJ
BJ
U
BLOCKED
BY
AI
BI
EXERCISE
COMPLETE
THE
PROOF
OF
THEOREM
SHOW
THAT
IF
BI
AI
IS
A
WINNING
BID
AND
BI
I
THEN
PLAYER
I
UTILITY
WOULD
HAVE
BEEN
AT
LEAST
AS
LARGE
HAD
IT
BID
I
AI
EXERCISE
SUPPOSE
WE
MODIFY
THE
LOS
MECHANISM
SO
THAT
THE
PRICE
PI
CHARGED
FOR
A
WINNING
BID
BI
BI
IS
GIVEN
BY
BUT
WHERE
THE
BID
BJ
BJ
IS
DEFINED
AS
THE
FIRST
BID
BLOCKED
BY
BI
BI
THE
FIRST
DENIED
BID
AFTER
BI
BI
WITH
BI
BJ
DOES
THIS
RESULT
IN
A
STRATEGYPROOF
MECHANISM
EXERCISE
RECALL
FROM
EXERCISE
THAT
THE
LOS
WD
ALGORITHM
CAN
BE
EXTENDED
TO
A
FAMILY
OF
GREEDY
ALGORITHMS
PARAMETRIZED
BY
P
CAN
ALL
OF
THESE
WD
ALGORITHMS
BE
EXTENDED
TO
TRUTHFUL
MECHANISMS
VIA
APPROPRIATE
PRICING
SCHEMES
WHAT
ABOUT
FOR
OTHER
CLASSES
OF
GREEDY
CRITERIA
E
G
ORDERING
BIDS
ACCORDING
TO
I
F
AI
WHERE
F
IS
A
MORE
GENERAL
NONDECREASING
FUNCTION
OF
SET
SIZE
SUMMARY
THIS
SECTION
STUDIED
THE
LOS
CA
FOR
SINGLE
MINDED
BIDDERS
ON
THE
PLUS
SIDE
THIS
IS
OUR
FIRST
POLY
TIME
CA
FOR
VALUATIONS
THAT
CAN
HAVE
SOME
DEGREE
OF
COMPLEMENTS
OR
SUBSTITUTES
IN
THIS
CASE
A
RESTRICTED
FORM
OF
COMPLEMENTS
ON
THE
MINUS
SIDE
THE
VALUATIONS
CAN
HAVE
ONLY
A
VERY
RESTRICTED
FORM
AND
THE
CA
GUARANTEES
ONLY
A
RELATIVELY
WEAK
O
M
APPROXIMATION
OF
THE
MAXIMUM
SURPLUS
IN
TERMS
OF
OUR
GUIDING
DESIDERATA
FROM
SUBSECTION
THE
LOS
CA
ACHIEVES
INCENTIVE
COMPATIBILITY
AND
COMPUTATIONAL
TRACTABILITY
WHILE
MAKING
SERIOUS
CONCESSIONS
TO
ECONOMIC
EFFICIENCY
AND
VALUATION
GENERALITY
WE
HAVE
ALREADY
SEEN
COROLLARY
THAT
THE
TRADE
OFF
BETWEEN
ECONOMIC
EFFICIENCY
AND
COMPU
TATIONAL
TRACTABILITY
IS
FUNDAMENTAL
EVEN
FOR
SINGLE
MINDED
BIDDERS
AND
EVEN
IGNORING
INCEN
TIVE
COMPATIBILITY
THE
NEXT
SECTION
SHOWS
THAT
EVEN
A
WEAKER
NOTION
OF
CA
TRACTABILITY
POLY
TIME
COMMUNICATION
AND
UNBOUNDED
COMPUTATION
LEADS
TO
A
FUNDAMENTAL
TRADE
OFF
BETWEEN
ECONOMIC
EFFICIENCY
AND
VALUATION
GENERALITY
COMMUNICATION
COMPLEXITY
OF
CAS
LAST
SECTION
RESTRICTED
ATTENTION
TO
SINGLE
MINDED
BIDDERS
IN
PART
TO
ELIMINATE
COMMUNICATION
DIFFICULTIES
AND
FOCUS
ON
THE
COMPUTATIONAL
COMPLEXITY
OF
WINNER
DETERMINATION
THIS
SECTION
RETURNS
TO
GENERAL
VALUATIONS
WHERE
ALL
WE
KNOW
ABOUT
EACH
VALUATION
VI
IS
THAT
VI
AND
THAT
VI
VI
WHENEVER
AND
SHINES
THE
SPOTLIGHT
SQUARELY
ON
COMMUNICATION
ISSUES
INTUITIVELY
SINCE
A
GENERAL
VALUATION
HAS
AN
EXPONENTIAL
NUMBER
OF
FREE
PARAMETERS
WE
DON
T
EXPECT
TO
ACHIEVE
A
REASONABLE
ALLOCATION
IN
ALL
CASES
WHILE
EXAMINING
ONLY
A
POLYNOMIAL
NUMBER
OF
THEM
TO
MAKE
THIS
PRECISE
WE
CONSIDER
THE
FOLLOWING
MODEL
OF
COMPUTATION
SEE
FOR
AN
OVERVIEW
OF
THE
VARIOUS
STANDARD
MODELS
PLAYERS
PARTICIPATE
IN
A
PROTOCOL
DECIDED
UPON
IN
ADVANCE
AT
EACH
STEP
OF
THE
PROTOCOL
ONE
OF
THE
PLAYERS
TRANSMITS
A
BIT
WHICH
IS
SEEN
BY
ALL
PLAYERS
CRUCIALLY
THE
BIT
TRANSMITTED
BY
A
PLAYER
CAN
ONLY
DEPEND
ON
ITS
OWN
PRIVATE
INFORMATION
AND
THE
PROTOCOL
HISTORY
SO
FAR
I
E
WHO
TRANSMITTED
WHAT
THE
COMMUNICATION
COMPLEXITY
OF
A
PROTOCOL
IS
THE
WORST
CASE
NUMBER
OF
BITS
THAT
ARE
TRANSMITTED
OVER
ALL
POSSIBLE
PRIVATE
INPUTS
OF
THE
PLAYERS
THE
KEY
POINT
TO
TAKE
AWAY
FROM
THIS
DEFINITION
IS
HOW
POWERFUL
THE
MODEL
OF
COMPUTATION
IS
IN
ADDITION
TO
DISPENSING
WITH
ANY
INCENTIVE
CONSTRAINTS
WHICH
WE
WILL
DO
FOR
THIS
ENTIRE
SECTION
UNLIMITED
COMPUTATION
BY
THE
PLAYERS
IS
PERMITTED
WHILE
THE
POINT
OF
THIS
MODEL
IS
LOWER
BOUNDS
WHICH
ARE
ONLY
MORE
COMPELLING
IN
SUCH
AN
UNREALISTICALLY
STRONG
MODEL
LET
DEVELOP
SOME
INTUITION
BY
EXAMINING
SOME
POSITIVE
RESULTS
FIRST
OBSERVE
THAT
WINNER
DETERMINATION
WITH
SINGLE
MINDED
BIDDERS
IS
TRIVIALLY
SOLVABLE
WITH
A
POLYNOMIAL
AMOUNT
OF
COMMUNICATION
THE
FOLLOWING
PROTOCOL
WORKS
EACH
PLAYER
BROADCASTS
THEIR
PRIVATE
SET
AND
VALUE
IN
SOME
PREDETERMINED
ORDER
RECALL
WE
IGNORE
INCENTIVE
CONSTRAINTS
AND
EACH
PLAYER
USES
THESE
TO
COMPUTE
AN
OPTIMAL
SOLUTION
IN
A
CONSISTENT
WAY
THIS
IS
AN
NP
HARD
PROBLEM
BUT
RECALL
WE
ALLOW
UNBOUNDED
COMPUTATION
SECOND
THE
LOS
ALGORITHM
CAN
BE
USED
TO
ACHIEVE
A
NON
TRIVIAL
APPROXIMATION
GUARANTEE
WITH
POLYNOMIAL
COMMUNICATION
EVEN
FOR
GENERAL
VALUATIONS
IN
THIS
MODEL
OF
COMPUTATION
THE
IDEA
IS
TO
CONCEPTUALLY
TREAT
A
SINGLE
PLAYER
WITH
A
GENERAL
VALUATION
VI
AS
DIFFERENT
SINGLE
MINDED
PLAYERS
ONE
SINGLE
MINDED
PLAYER
FOR
EACH
BUNDLE
T
WITH
INHERITED
VALUATION
VI
T
TO
PREVENT
DIFFERENT
SUB
PLAYERS
CORRESPONDING
TO
A
SINGLE
ORIGINAL
PLAYER
FROM
SIMULTANEOUSLY
GETTING
THEIR
BUNDLES
GRANTED
WE
ADD
ONE
DUMMY
GOOD
FOR
EACH
ORIGINAL
PLAYER
I
WE
THEN
SUPPLEMENT
THE
DESIRED
SET
OF
EACH
OF
I
SUB
PLAYERS
WITH
THIS
DUMMY
GOOD
THIS
ENSURES
THAT
EVERY
FEASIBLE
ALLOCATION
WITH
THE
SUB
PLAYERS
AND
THE
DUMMY
GOODS
MAPS
NATURALLY
TO
A
FEASIBLE
ALLOCATION
OF
THE
ORIGINAL
INSTANCE
WITH
THE
SAME
SURPLUS
WE
HAVE
SHOWN
HOW
TO
REDUCE
SURPLUS
MAXIMIZATION
WITH
N
PLAYERS
WITH
GENERAL
VALUA
TIONS
AND
M
GOODS
TO
SURPLUS
MAXIMIZATION
WITH
SINGLE
MINDED
PLAYERS
AND
M
N
GOODS
SOLVING
THE
LATTER
SINGLE
MINDED
INSTANCE
BY
BRUTE
FORCE
AS
ABOVE
WOULD
REQUIRE
COMMU
NICATION
EXPONENTIAL
IN
ONE
OF
THE
ORIGINAL
PARAMETERS
OF
INTEREST
NAMELY
M
RUNNING
THE
LOS
ALGORITHM
DIRECTLY
ON
THE
SINGLE
MINDED
INSTANCE
SUFFERS
THE
SAME
PROBLEM
WE
CAN
SIMULATE
THE
DECISIONS
THAT
THE
LOS
ALGORITHM
WOULD
MAKE
ON
THE
SINGLE
MINDED
INSTANCE
USING
ONLY
POLYNOMIAL
IN
N
AND
M
COMMUNICATION
AS
FOLLOWS
WE
DEFINE
A
PROTOCOL
THAT
WORKS
DIRECTLY
ON
THE
ORIGINAL
INSTANCE
WITH
N
PLAYERS
AND
M
GOODS
THE
PROTOCOL
PROCEEDS
IN
ROUNDS
ALL
PLAYERS
ARE
INITIALLY
ACTIVE
AND
ALL
GOODS
ARE
INITIALLY
UNALLOCATED
IN
EACH
ROUND
EACH
ACTIVE
PLAYER
I
BROADCASTS
THE
BUNDLE
T
OF
UNALLOCATED
GOODS
THAT
I
BY
THE
PLAYER
BUT
REMEMBER
THIS
IS
PERMITTED
ALL
PLAYERS
SEE
ALL
PROPOSED
BUNDLES
AND
THE
ONE
THAT
MAXIMIZES
VI
T
T
OVER
ACTIVE
PLAYERS
I
IS
UNDERSTOOD
BY
ALL
OF
THE
PLAYERS
TO
BE
ALLOCATED
THE
WINNING
PLAYER
I
DEACTIVATES
ITSELF
AND
THE
GOODS
IN
ITS
BUNDLE
T
ARE
UNDERSTOOD
BY
ALL
PLAYERS
TO
NOW
BE
ALLOCATED
THE
PROTOCOL
TERMINATES
ONCE
ALL
PLAYERS
ARE
INACTIVE
INTUITIVELY
EACH
ROUND
OF
THE
PROTOCOL
IS
EXECUTING
A
TWO
STAGE
TOURNAMENT
TO
IDENTIFY
THE
BUNDLE
THAT
WOULD
NEXT
BE
SELECTED
BY
THE
LOS
ALGORITHM
ON
THE
INDUCED
SINGLE
MINDED
INSTANCE
IN
THE
FIRST
STAGE
EACH
ORIGINAL
PLAYER
RUNS
A
TOURNAMENT
TO
ELECT
THE
MOST
VIABLE
CANDIDATE
FROM
ITS
INDUCED
SINGLE
MINDED
PLAYERS
THIS
CAN
BE
DONE
PRIVATELY
WITHOUT
ANY
COMMUNICATION
AND
THE
SECOND
ROUND
ELECTS
A
FINAL
WINNER
FROM
THE
POLYNOMIALLY
MANY
CANDIDATES
THAT
SURVIVE
THE
FIRST
STAGE
EXERCISE
PROVE
THAT
THE
ALLOCATION
DECISIONS
MADE
BY
THE
ABOVE
PROTOCOL
FOR
THE
ORIGINAL
INSTANCE
ARE
ISOMORPHIC
TO
THOSE
THAT
THE
LOS
WINNER
DETERMINATION
ALGORITHM
WOULD
MAKE
ON
THE
INDUCED
SINGLE
MINDED
INSTANCE
AND
THEREFORE
IT
ACHIEVES
AN
O
M
APPROXIMATION
OF
THE
SURPLUS
THE
MAIN
RESULT
IN
THIS
SECTION
IS
A
MATCHING
LOWER
BOUND
THEOREM
FOR
EVERY
THERE
IS
NO
POLYNOMIAL
COMMUNICATION
O
M
E
APPROXIMATION
FOR
THE
GENERAL
WINNER
DETERMINATION
PROBLEM
THIS
LOWER
BOUND
IS
UNCONDITIONAL
IN
THAT
IT
DOESN
T
DEPEND
ON
ANY
COMPLEXITY
THEORETIC
ASSUMPTIONS
LIKE
P
NP
IT
CAN
BE
EXTENDED
TO
COVER
RANDOMIZED
AND
NONDETERMINIS
TIC
PROTOCOLS
AND
SIMILAR
PROOF
TECHNIQUES
ALSO
YIELD
SOMETIMES
WEAKER
LOWER
BOUNDS
FOR
VARIOUS
RESTRICTED
CLASSES
OF
VALUATIONS
SEE
FOR
FURTHER
DETAILS
AND
REFERENCES
AT
THE
HIGHEST
LEVEL
THE
PROOF
OF
THEOREM
IS
NOT
UNLIKE
THE
FAMILIAR
ARGUMENT
THAT
COMPARISON
BASED
SORTING
REQUIRES

N
LOG
N
COMPARISONS
AN
ALGORITHM
THAT
EMPLOYS
ONLY
K
COMPARISONS
GENERATES
AT
MOST
DISTINCT
EXECUTIONS
AND
N
DIFFERENT
EXECUTIONS
ARE
NEEDED
TO
CORRECTLY
DISTINGUISH
THE
N
ORDINALLY
DISTINCT
POSSIBLE
INPUTS
RECALL
N

N
LOG
N
THE
PROOF
OF
THEOREM
NEEDS
TWO
ADDITIONAL
IDEAS
FIRST
THE
STRUCTURE
OF
THE
PRIVATE
INFORMATION
IMPLIES
THAT
SETS
OF
INPUTS
THAT
GENERATE
IDENTICAL
PROTOCOL
TRANSCRIPTS
SATISFY
A
NATURAL
CLOSURE
PROPERTY
SECOND
TO
PROVE
THE
STRONG
APPROXIMATION
LOWER
BOUND
OF

M
E
WE
REQUIRE
SOME
NEAT
COMBINATORICS
TO
GENERATE
WINNER
DETERMINATION
INSTANCES
THAT
ADMIT
EITHER
A
HIGH
SURPLUS
FEASIBLE
SOLUTION
OR
ONLY
VERY
LOW
SURPLUS
SOLUTIONS
THE
FIRST
POINT
IS
SIMPLE
CONSIDER
A
PROTOCOL
AND
LET
XI
DENOTE
THE
SET
OF
POSSIBLE
PRI
VATE
INPUTS
OF
PLAYER
I
E
G
POSSIBLE
VALUATIONS
SUPPOSE
THERE
ARE
TWO
INPUTS
XN
AND
YN
FOR
WHICH
THE
COMMUNICATION
TRANSCRIPTS
OF
THE
PROTOCOL
I
E
WHO
SENT
WHAT
BITS
WHEN
ARE
IDENTICAL
NOW
CONSIDER
THE
MIXED
INPUT
XN
BY
IN
DUCTION
ON
THE
ROUNDS
OF
THE
PROTOCOL
PLAYER
CANNOT
DISTINGUISH
BETWEEN
THE
INPUTS
XN
AND
YN
AND
THE
OTHER
PLAYERS
CANNOT
DISTINGUISH
BE
TWEEN
THE
INPUTS
XN
AND
XN
AS
PART
OF
THIS
INDUCTION
WE
SEE
THAT
THE
COMMUNICATION
TRANSCRIPT
OF
THE
PROTOCOL
ON
THE
INPUT
XN
MATCHES
THAT
OF
XN
AND
YN
SIMILARLY
ALL
MIXED
VERSIONS
OF
XN
AND
YN
GENERATE
IDENTICAL
COMMUNICATION
TRANSCRIPTS
THIS
IMPLIES
THAT
A
SET
OF
INPUTS
WITH
A
COMMON
COMMUNICATION
TRANSCRIPT
FORM
A
BOX
MEANING
A
SUBSET
A
OF
XN
THAT
ARISES
AS
A
PRODUCT
A
AN
FOR
SOME
AI
XI
FOR
EACH
I
LEMMA
EVERY
PROTOCOL
PARTITIONS
THE
SET
X
XN
OF
POSSIBLE
INPUTS
INTO
BOXES
OVER
WHICH
ITS
COMMUNICATION
TRANSCRIPT
IS
INVARIANT
FOR
THE
WINNER
DETERMINATION
PROBLEM
A
PROTOCOL
WITH
COMMUNICATION
COMPLEXITY
K
PARTI
TIONS
THE
SET
OF
VALUATIONS
INTO
AT
MOST
BOXES
AND
IN
EACH
BOX
EXECUTES
IDENTICALLY
IN
PARTICULAR
A
COMMON
ALLOCATION
IS
PRODUCED
FOR
ALL
INPUTS
IN
THE
SAME
BOX
THE
HEART
OF
THE
PROOF
OF
THEOREM
IS
TO
SHOW
THAT
IF
K
IS
TOO
SMALL
I
E
POLYNOMIAL
THEN
VERY
DIFFERENT
LOOKING
INPUTS
WIND
UP
IN
A
COMMON
BOX
AND
NO
COMMON
ALLOCATION
CAN
BE
SIMULTANEOUSLY
NEAR
OPTIMAL
FOR
BOTH
OF
THEM
TO
CONSTRUCT
A
USEFUL
FAMILY
OF
DIFFERENT
LOOKING
VALUATIONS
FIX
A
SET
OF
M
GOODS
AND
A
SET
OF
N

M
E
PLAYERS
WE
FIRST
CONSIDER
THE
FOLLOWING
THOUGHT
EXPERIMENT
MAKE
T
DIFFERENT
COPIES
OF
THE
GOODS
CALLED
ST
WHERE
T
IS
A
PARAMETER
WE
CHOOSE
BELOW
RANDOMLY
PARTITION
EACH
SJ
INTO
N
CLASSES
ONE
PER
PLAYER
I
E
ASSIGN
EACH
GOOD
OF
SJ
INDEPENDENTLY
AND
UNIFORMLY
AT
RANDOM
TO
ONE
OF
THE
CLASSES
SJ
SJ
OBVIOUSLY
N
TWO
DIFFER
CLASSES
IN
THE
SAME
COPY
SJ
CONTAIN
DISJOINT
SUBSETS
OF
THE
ORIGINAL
SET
OF
GOODS
WHAT
ABOUT
TWO
CLASSES
SJ
BELONGING
TO
DIFFERENT
COPIES
J

FOR
EACH
ORIGINAL
GOOD
OF
THERE
IS
A
PROBABILITY
THAT
IT
IS
ASSIGNED
TO
BOTH
SJ
AND
THUS
FOR
FIXED
H
I
I
H
J
M
M
AND
J

THE
PROBABILITY
THAT
SI
AND
SH
WIND
UP
DISJOINT
IS
N
E
NOTE
THAT
UNDER
OUR
ASSUMPTION
THAT
N

M
E
THIS
PROBABILITY
IS
EXPONENTIALLY
SMALL
INDEED
BY
A
UNION
BOUND
THE
PROBABILITY
THAT
THERE
IS
ANY
PAIR
OF
SETS
SJ
WITH
J

I
H
AND
NO
GOOD
OF
IN
COMMON
IS
LESS
THAN
M
THUS
EVEN
WHEN
T
EM
N
THERE
IS
A
POSITIVE
PROBABILITY
THAT
EVERY
PAIR
SJ
OF
CLASSES
WITH
J

OVERLAPS
ERGO
SUCH
A
COLLECTION
OF
T
PARTITIONS
OF
THE
GOODS
EXISTS
WE
FIX
ONE
SJ
ARBITRARILY
FOR
THE
REST
OF
THE
PROOF
WHY
IS
THIS
CONSTRUCTION
USEFUL
TO
GAIN
INTUITION
SUPPOSE
EACH
BIDDER
I
WAS
SINGLE
MINDED
AND
WANTED
THE
BUNDLE
WITH
VALUE
THEN
WE
CAN
ALLOCATE
ALL
DESIRED
BUNDLES
TO
ALL
BIDDERS
WITHOUT
CONFLICT
AND
ENJOY
SURPLUS
N

M
E
IF
ON
THE
OTHER
HAND
EACH
BIDDER
WANTS
A
BUNDLE
THAT
CORRESPONDS
TO
A
DIFFERENT
COPY
OF
THE
GOODS
WE
CAN
ONLY
OBTAIN
SURPLUS
RECALL
EVERY
PAIR
OF
CLASSES
FROM
DIFFERENT
PARTITIONS
HAS
AT
LEAST
ONE
GOOD
OF
IN
COMMON
THUS
THIS
COLLECTION
OF
T
HIGHLY
OVERLAPPING
PARTITIONS
OF
GENERATES
WINNER
DETERMINATION
INSTANCES
WITH
BOTH
VERY
HIGH
OPTIMAL
SURPLUS
AND
VERY
LOW
OPTIMAL
SURPLUS
WE
NOW
GIVE
THE
GENERAL
ARGUMENT
AND
PROVE
THEOREM
WE
FIRST
DESCRIBE
THE
SET
OF
VALUATIONS
THAT
WE
USE
LET
BI
T
BE
A
BIT
STRING
OF
LENGTH
T
ASSOCIATE
THESE
T
BITS
WITH
THE
T
PARTITIONS
OF
ABOVE
INTERPRET
THE
ONES
OF
BI
AS
THE
PARTITIONS
IN
WHICH
PLAYER
I
IS
INTERESTED
AND
THE
ZEROS
AS
THE
PARTITIONS
IN
WHICH
IT
IS
UNINTERESTED
THE
STRING
BI
INDUCES
A
VALUATION
AS
FOLLOWS
FOR
EVERY
COPY
SJ
IN
WHICH
I
IS
INTERESTED
PLAYER
I
HAS
VALUE
FOR
THE
BUNDLE
SJ
THE
PLAYER
ALSO
HAS
VALUE
FOR
SUPERSETS
OF
SUCH
BUNDLES
AND
VALUE
FOR
EVERYTHING
ELSE
LET
XI
DENOTE
THE
SET
OF
VALUATIONS
OF
THIS
FORM
THE
SET
X
XN
OF
INPUTS
INDUCES
A
FAMILY
OF
WINNER
DETERMINATION
PROBLEMS
CONSIDER
AN
INPUT
OF
X
WHICH
WE
CAN
UNIQUELY
ASSOCIATE
WITH
BIT
STRINGS
BN
CALL
AN
INSTANCE
GOOD
IF
THERE
IS
AN
INDEX
H
SUCH
THAT
FOR
EVERY
PLAYER
I
THE
HTH
BIT
OF
BI
IS
I
E
ALL
PLAYERS
ARE
INTERESTED
IN
THE
HTH
PARTITION
AS
ABOVE
A
GOOD
INSTANCE
ADMITS
A
FEASIBLE
SOLUTION
WITH
SURPLUS
N

M
E
IN
WHICH
EACH
PLAYER
GETS
ITS
BUNDLE
CORRESPONDING
TO
THE
HTH
PARTITION
AT
THE
OTHER
EXTREME
CALL
AN
INSTANCE
BAD
IF
THERE
IS
AT
MOST
ONE
PLAYER
INTERESTED
IN
EACH
PARTITION
I
E
THE
SETS
OF
INDICES
FOR
THE
ONES
IN
BN
ARE
MUTUALLY
DISJOINT
SINCE
ALL
PAIRS
OF
BUNDLES
DRAWN
FROM
DIFFERENT
PARTITIONS
INTERSECT
THE
MAXIMUM
POSSIBLE
SURPLUS
IN
A
BAD
INSTANCE
IS
OF
COURSE
THERE
ARE
PLENTY
OF
INSTANCES
THAT
ARE
NEITHER
GOOD
NOR
BAD
FINALLY
CONSIDER
A
K
BIT
PROTOCOL
THAT
ACHIEVES
A
BETTER
THAN
N
APPROXIMATION
FOR
EVERY
WINNER
DETERMINATION
PROBLEM
IN
X
BY
LEMMA
THIS
PROTOCOL
PARTITIONS
X
INTO
AT
MOST
BOXES
OVER
WHICH
THE
PROTOCOL
HAS
CONSTANT
BEHAVIOR
AND
IN
PARTICULAR
A
CONSTANT
OUTPUT
BY
THE
DEFINITION
OF
GOOD
AND
BAD
INSTANCES
AND
THE
ASSUMPTION
THAT
THE
PROTOCOL
IS
BETTER
THAN
AN
N
APPROXIMATION
ALGORITHM
GOOD
AND
BAD
INSTANCES
CANNOT
INTERMINGLE
IN
A
COMMON
BOX
CRUCIALLY
THIS
RESTRICTS
THE
NUMBER
OF
BAD
INSTANCES
THAT
A
SINGLE
BOX
CAN
CONTAIN
TO
SEE
WHY
CONSIDER
A
BOX
A
AN
OF
X
RECALL
LEMMA
THAT
CONTAINS
NO
GOOD
INSTANCES
WE
CLAIM
THAT
FOR
EACH
PARTITION
OF
THE
GOODS
THERE
IS
A
TOTALLY
UNINTERESTED
PLAYER
I
A
PLAYER
I
WHO
ACROSS
ALL
OF
ITS
VALUATIONS
IN
AI
NEVER
WANTS
ITS
BUNDLE
SJ
FROM
THE
JTH
PARTITION
FOR
OTHERWISE
THERE
IS
A
PARTITION
SJ
AND
FOR
EACH
PLAYER
I
A
VALUATION
VI
AI
SUCH
THAT
WHEN
I
HAS
THIS
VALUATION
IT
WOULD
HAPPILY
ACCEPT
ITS
BUNDLE
FROM
THE
JTH
PARTITION
BUT
THEN
THE
INPUT
VN
BELONGS
TO
THIS
BOX
BY
THE
CLOSURE
PROPERTY
OF
BOXES
AND
BY
DEFINITION
IS
A
GOOD
INSTANCE
SO
THE
CLAIM
IS
TRUE
BUT
WHY
DOES
IT
IMPLY
AN
UPPER
BOUND
ON
THE
BAD
INSTANCE
POPULATION
OF
A
BOX
WITH
NO
GOOD
INSTANCES
THE
TOTAL
NUMBER
OF
BAD
INSTANCES
IS
PRECISELY
N
T
WITH
EACH
ARISING
UNIQUELY
BY
CHOOSING
FOR
EACH
OF
THE
T
PARTITIONS
WHICH
IF
ANY
ONE
OF
THE
N
PLAYERS
IS
INTERESTED
IN
IT
WITHIN
A
BOX
WITH
NO
GOOD
INSTANCE
EACH
BAD
INSTANCE
ARISES
A
CHOICE
ONE
PER
PARTITION
OF
WHICH
IF
ANY
OF
THE
N
PLAYERS
OTHER
THAN
THE
NECESSARILY
PRESENT
TOTALLY
UNINTERESTED
ONE
IS
INTERESTED
IN
IT
THIS
GIVES
AN
UPPER
BOUND
OF
NT
ON
THE
NUMBER
OF
BAD
INSTANCES
PER
BOX
WRAPPING
UP
THE
N
T
BAD
INSTANCES
MUST
BE
DISTRIBUTED
ACROSS
AT
LEAST
N
T
NT
T
DIFFERENT
BOXES
THIS
IMPLIES
THAT
THE
COMMUNICATION
COMPLEXITY
K
OF
THE
PROTOCOL
SATISFIES
T
TAKING
LOGS
AND
USING
THAT
LOG
X
X
FOR
SMALL
X
WE
FIND
THAT
K
T
N
SINCE
T
IS
EXPONENTIAL
IN
M
RECALL
SO
IS
K
SUMMARIZING
THEN
EVERY
PROTOCOL
WITH
APPROXIMATION
FACTOR
O
MIN
N
M
E
USES
EXPONENTIAL
COMMUNICATION
REFERENCES
E
H
CLARKE
MULTIPART
PRICING
OF
PUBLIC
GOODS
PUBLIC
CHOICE
T
GROVES
INCENTIVES
IN
TEAMS
ECONOMETRICA
J
HASTAD
CLIQUE
IS
HARD
TO
APPROXIMATE
WITHIN
E
ACTA
MATHEMATICA
E
KUSHILEVITZ
AND
N
NISAN
COMMUNICATION
COMPLEXITY
CAMBRIDGE
UNIVERSITY
PRESS
D
LEHMANN
L
I
O
CALLAGHAN
AND
Y
SHOHAM
TRUTH
REVELATION
IN
APPROXIMATELY
EFFICIENT
COMBINATORIAL
AUCTIONS
JOURNAL
OF
THE
ACM
PRELIMINARY
VERSION
IN
EC
N
NISAN
THE
COMMUNICATION
COMPLEXITY
OF
APPROXIMATE
SET
PACKING
IN
PROCEEDINGS
OF
THE
ANNUAL
INTERNATIONAL
COLLOQUIUM
ON
AUTOMATA
LANGUAGES
AND
PROGRAMMING
ICALP
VOLUME
OF
LECTURE
NOTES
IN
COMPUTER
SCIENCE
PAGES
N
NISAN
INTRODUCTION
TO
MECHANISM
DESIGN
FOR
COMPUTER
SCIENTISTS
IN
N
NISAN
T
ROUGHGARDEN
E
TARDOS
AND
V
VAZIRANI
EDITORS
ALGORITHMIC
GAME
THEORY
CHAP
TER
PAGES
CAMBRIDGE
UNIVERSITY
PRESS
N
NISAN
AND
A
RONEN
COMPUTATIONALLY
FEASIBLE
VCG
MECHANISMS
JOURNAL
OF
ARTI
FICIAL
INTELLIGENCE
RESEARCH
T
SANDHOLM
ALGORITHM
FOR
OPTIMAL
WINNER
DETERMINATION
IN
COMBINATORIAL
AUCTIONS
ARTIFICIAL
INTELLIGENCE
I
SEGAL
THE
COMMUNICATION
REQUIREMENTS
OF
COMBINATORIAL
ALLOCATION
PROBLEMS
IN
P
CRAMTON
Y
SHOHAM
AND
R
STEINBERG
EDITORS
COMBINATORIAL
AUCTIONS
CHAPTER
MIT
PRESS
W
VICKREY
COUNTERSPECULATION
AUCTIONS
AND
COMPETITIVE
SEALED
TENDERS
JOURNAL
OF
FINANCE
SCHEDULE
MONDAY
AUGUST
CLASS
READ
CHAPTER
QUIZ
AT
THE
START
OF
CLASS
LECTURE
STANDARD
GAME
THEORY
SOLUTION
CONCEPTS
WEDNESDAY
AUGUST
CLASS
READ
CHAPTER
AND
CHAPTER
QUIZ
AT
THE
START
OF
CLASS
WHICH
WILL
CONCENTRATE
ON
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEMS
AND
LECTURE
PROOF
OF
EXISTENCE
OF
MIXED
NASH
EQUILIBRIUM
VIA
BROUWER
FIXED
POINT
AND
SPERNER
LEMMAS
SOURCE
ENDOFLINE
AND
PPADCOMPLETENESS
APPROXIMATE
NASH
IN
PPAD
FRIDAY
AUGUST
CLASS
READ
CHAPTER
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
OVERVIEW
OF
PPADCOMPLETENESS
OF
NASH
JOIN
THE
GOOGLE
GROUP
HTTPS
GROUPS
GOOGLE
COM
FORUM
FORUM
HOMEWORK
CHAPTER
PROBLEM
CHAPTER
PROBLEM
START
PERUSING
PAPERS
FROM
THE
ACM
CONFERENCE
ON
ECONOMICS
AND
COMPUTATION
EC
IN
AND
YOUR
GOAL
IS
TO
FIND
A
FEW
THEORETICALLY
ORIENTED
PAPERS
WITH
NONTRIVIAL
PROOFS
THAT
ARE
RELATED
TO
THE
COURSE
AND
THAT
YOU
FIND
INTERESTING
POST
YOUR
FIRST
CHOICE
OF
PAPER
TO
GIVE
A
TALK
ON
TO
HTTPS
GROUPS
GOOGLE
COM
FORUM
FORUM
WHICH
YOU
WILL
HAVE
TO
JOIN
INCLUDE
THE
FOLLOWING
INFORMATION
TITLE
AUTHORS
AND
ABSTRACT
WHICH
ALL
SHOULD
BE
CUT
AND
PASTE
IF
YOU
DON
T
THINK
THE
ABSTRACT
IS
SUFFICIENTLY
DESCRIPTIVE
ANOTHER
PARAGRAPH
ELABORATING
ON
THE
CONTRIBUTIONS
OF
THE
PAPER
A
PARAGRAPH
EXPLAINING
WHAT
YOU
THINK
THE
PAPER
IS
INTERESTING
AND
A
ONE
SENTENCE
STATEMENT
OF
WHAT
YOU
THINK
THE
TAKE
AWAY
MESSAGE
IS
FOR
THE
PAPER
BEFORE
YOU
POST
CHECK
THAT
NO
ONE
ELSE
HAS
PICKED
THAT
PAPER
SO
FIRST
COME
FIRST
SERVED
LECTURE
NPHARDNESS
OF
SOURCE
HINTS
OF
THE
PROOF
OF
PPADHARDNESS
OF
NASH
WEDNESDAY
SEPTEMBER
CLASS
READ
CHAPTER
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
HOMEWORK
CHAPTER
PROBLEM
LECTURE
EVOLUTIONARY
STABLE
STRATEGIES
USING
THE
HAWKDOVE
GAME
AS
A
RUNNING
EXAMPLE
FRIDAY
SEPTEMBER
CLASS
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
INDEX
HTML
READ
CHAPTER
AND
CHAPTER
EXCEPT
FOR
THE
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEMS
AND
LECTURE
ADVANCED
MATERIAL
SECTION
OF
CHAPTER
BOUND
ON
THE
PRICE
OF
ANARCHY
PRIMARY
SOURCE
SECONDARY
SOURCE
AND
EXAMPLE
OF
WHAT
SLIDES
FOR
A
TALK
IN
THIS
AREA
MIGHT
LOOK
LIKE
MONDAY
SEPTEMBER
CLASS
READ
CHAPTER
EXCEPT
FOR
THE
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
OF
CHAPTER
WEDNESDAY
SEPTEMBER
CLASS
READ
CHAPTER
EXCEPT
FOR
THE
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
DEADLINE
FOR
PICKING
FIRST
EC
PAPER
TO
SPEAK
ABOUT
LECTURE
ADVANCED
MATERIAL
FROM
CHAPTER
FRIDAY
SEPTEMBER
CLASS
READ
CHAPTER
UP
THROUGH
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
CHAPTER
HOMEWORK
CHAPTER
PROBLEM
GIVE
A
FORMAL
PROOF
FOR
PART
B
IF
YOU
CAN
REASONABLY
DO
SO
LECTURE
SECTION
AN
ALGORITHM
FOR
CONSTRUCTING
MARKET
CLEARING
PRICING
MONDAY
SEPTEMBER
CLASS
READ
CHAPTER
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
HOMEWORK
CHAPTER
PROBLEM
DEADLINE
FOR
PICKING
SECOND
EC
PAPER
TO
SPEAKER
ABOUT
POST
YOUR
CHOICE
OF
PAPER
TO
GIVE
A
TALK
ON
TO
HTTPS
GROUPS
GOOGLE
COM
FORUM
FORUM
WHICH
YOU
WILL
HAVE
TO
JOIN
INCLUDE
THE
FOLLOWING
INFORMATION
TITLE
AUTHORS
AND
ABSTRACT
WHICH
ALL
SHOULD
BE
CUT
AND
PASTE
IF
YOU
DON
T
THINK
THE
ABSTRACT
IS
SUFFICIENTLY
DESCRIPTIVE
ANOTHER
PARAGRAPH
ELABORATING
ON
THE
CONTRIBUTIONS
OF
THE
PAPER
A
PARAGRAPH
EXPLAINING
WHAT
YOU
THINK
THE
PAPER
IS
INTERESTING
AND
A
ONE
SENTENCE
STATEMENT
OF
WHAT
YOU
THINK
THE
TAKE
AWAY
MESSAGE
IS
FOR
THE
PAPER
BEFORE
YOU
POST
CHECK
THAT
NO
ONE
ELSE
HAS
PICKED
THAT
PAPER
SO
FIRST
COME
FIRST
SERVED
LECTURE
FINDING
MARKET
CLEARING
PRICES
VIA
CONVEX
PROGRAMMING
SOURCE
TOP
TRADING
CYCLE
ONE
SIDED
PREFERENCE
ALGORITHM
AND
GALESHAPLEY
TWO
SIDED
PREFERENCE
MATCHING
ALGORITHM
NOTES
WEDNESDAY
SEPTEMBER
CLASS
READ
CHAPTER
EXCEPT
FOR
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
INDEX
HTML
LECTURE
ADVANCED
MATERIAL
SECTION
A
GAMETHEORETIC
DERIVATION
OF
THE
NASHBARGAINING
SOLUTION
FRIDAY
SEPTEMBER
CLASS
READ
CHAPTER
AND
CHAPTER
EXCEPT
FOR
THE
ADVANCED
MATERIAL
SECTION
OF
CHAPTER
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
OF
CHAPTER
SPECTRAL
ANALYSIS
OF
HUBS
AND
AUTHORITIES
AND
PAGERANK
AND
RELATION
OF
PAGERANK
TO
RANDOM
WALKS
MONDAY
SEPTEMBER
CLASS
READ
CHAPTER
SECTIONS
AND
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
SECTIONS
AND
HOMEWORK
CHAPTER
PROBLEM
CHAPTER
PROBLEM
DEADLINE
FOR
PREPARATION
OF
PRESENTATION
POWERPOINT
OR
WHATEVER
OF
YOUR
FIRST
MINUTE
TALK
LECTURE
SECTIONS
AND
VCG
AND
PROOF
THAT
IT
IS
A
TRUTHFUL
FOR
COMBINATORIAL
AUCTIONS
LOS
MECHANISM
GREEDY
APPROXIMATION
ALGORITHM
FOR
ASSIGNMENT
AND
TRUTHFUL
ANALYSIS
FOR
SINGLEMINDED
BIDDERS
COMBINATORIAL
AUCTIONS
NOTES
I
BELIEVE
ORIGINALLY
FROM
TIM
ROUGHGARDEN
WEDNESDAY
SEPTEMBER
CLASS
READ
CHAPTER
SECTIONS
TO
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
OF
CHAPTER
PROOF
VCG
GIVES
MARKET
CLEARING
PRICES
FRIDAY
SEPTEMBER
CLASS
READ
CHAPTER
THROUGH
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
CHAPTER
HOMEWORK
CHAPTER
PROBLEM
LECTURE
CHAPTER
ON
INFORMATION
CASCADES
AND
BAYES
RULE
MONDAY
SEPTEMBER
CLASS
READ
CHAPTER
EXCEPT
FOR
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
ANALYSIS
OF
RICHGETRICHER
PROCESS
WEDNESDAY
OCTOBER
CLASS
READ
CHAPTER
EXCEPT
FOR
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
ANALYSIS
OF
CASCADE
CAPACITY
FRIDAY
OCTOBER
CLASS
READ
CHAPTER
EXCEPT
FOR
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
INDEX
HTML
LECTURE
ADVANCED
MATERIAL
SECTION
ANALYSIS
OF
DECENTRALIZED
SEARCH
MONDAY
OCTOBER
CLASS
READ
CHAPTER
EXCEPT
FOR
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
DEADLINE
FOR
PREPARATION
OF
PRESENTATION
POWERPOINT
OR
WHATEVER
OF
YOUR
SECOND
MINUTE
TALK
HOMEWORK
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
ANALYSIS
OF
BRANCHING
AND
COALESCENT
PROCESSES
WEDNESDAY
OCTOBER
CLASS
READ
CHAPTER
EXCEPT
FOR
ADVANCED
MATERIAL
SECTION
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
WEALTH
DYNAMICS
IN
MARKETS
FRIDAY
OCTOBER
CLASS
READ
CHAPTER
UP
THROUGH
SECTION
INCLUSIVE
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
SKIM
THE
ADVANCED
MATERIAL
SECTION
HOMEWORK
CHAPTER
PROBLEM
LECTURE
ADVANCED
MATERIAL
SECTION
PROOF
OF
ARROW
IMPOSSIBILITY
THEOREM
TUESDAY
OCTOBER
CLASS
READ
CHAPTER
FROM
THROUGH
INCLUSIVE
CHAPTER
QUIZ
COVERING
THIS
AT
THE
START
OF
CLASS
HOMEWORK
CHAPTER
PROBLEM
CHAPTER
PROBLEM
LECTURE
STATEMENT
AND
PROOF
OF
GIBBARDSATTERTHWAITE
THEOREM
SOURCE
WEDNESDAY
OCTOBER
NO
CLASS
FRIDAY
OCTOBER
NO
CLASS
MONDAY
OCTOBER
CLASS
NEAL
TALK
MIKE
TALK
WEDNESDAY
OCTOBER
CLASS
SALIM
TALK
VINEET
TALK
FRIDAY
OCTOBER
CLASS
BEN
TALK
ZACH
TALK
MONDAY
OCTOBER
CLASS
NEAL
TALK
MIKE
TALK
WEDNESDAY
OCTOBER
CLASS
SALIM
TALK
VINEET
TALK
FRIDAY
OCTOBER
NO
CLASS
MONDAY
NOVEMBER
CLASS
DISCLAIMER
THESE
NOTES
HAVE
NOT
BEEN
SUBJECTED
TO
THE
USUAL
SCRUTINY
RESERVED
FOR
FORMAL
PUBLICATIONS
THEY
MAY
BE
DISTRIBUTED
OUTSIDE
THIS
CLASS
ONLY
WITH
THE
PERMISSION
OF
THE
INSTRUCTOR
OVERVIEW
WE
BEGIN
BY
LOOKING
AT
A
SET
OF
THEOREMS
FROM
VARIOUS
DISCIPLINES
AND
HOW
THEY
RELATE
TO
ONE
ANOTHER
FROM
COMBINATORICS
WE
TAKE
SPERNER
LEMMA
WHICH
WE
CAN
USE
TO
PROVE
BROUWER
FIXED
POINT
THEOREM
FROM
TOPOLOGY
BROUWER
FIXED
POINT
THEOREM
CAN
BE
USED
TO
PROVE
THE
ARROW
DEBREU
THEOREM
FROM
ECONOMICS
WHICH
STATES
THAT
GENERAL
EQUILIBRIA
EXIST
AND
CAN
ALSO
BE
USED
TO
PROVE
KAKUTANI
FIXED
POINT
THEOREM
KAKUTANI
FIXED
POINT
THEOREM
CAN
BE
USED
TO
PROVE
THAT
NASH
EQUILIBRIA
EXIST
FOR
ALL
GAMES
A
GRAPH
ILLUSTRATING
HOW
THESE
THEOREMS
CAN
BE
USED
TO
PROVE
EACH
OTHER
IS
GIVEN
IN
FIGURE
SPERNER
LEMMA
HERE
WE
CONSIDER
AN
EXAMPLE
APPLICATION
OF
SPERNER
LEMMA
TO
A
SIMPLEX
IN
TWO
DIMENSIONS
THOUGH
THE
LEMMA
CAN
BE
GENERALIZED
TO
HIGHER
DIMENSIONS
TAKE
THE
FOLLOWING
STEPS
TO
SET
UP
THE
PROBLEM
SEE
FIGURE
TRIANGULATE
THE
SIMPLEX
SO
THAT
IT
DIVIDED
INTO
SMALLER
TRIANGLES
NUMBER
THE
CORNERS
OF
THE
SIMPLEX
AND
LABEL
EACH
OF
THE
VERTICES
IN
THE
TRIANGULATION
WITH
EITHER
OR
SUBJECT
TO
THE
FOLLOWING
RULES
A
VERTEX
ON
A
SIDE
OF
THE
SIMPLEX
CANNOT
BE
ASSIGNED
THE
SAME
NUMBER
AS
THE
CORNER
OF
THE
SIMPLEX
OPPOSITE
THAT
SIDE
AND
VERTICES
INSIDE
THE
SIMPLEX
CAN
BE
LABELLED
WITH
ANY
OF
THE
NUMBERS
LEMMA
SPERNER
LEMMA
IF
YOU
LABEL
THE
VERTICES
AS
DESCRIBED
ABOVE
YOU
WILL
ALWAYS
HAVE
A
SMALL
TRIANGLE
SOMEWHERE
IN
THE
SIMPLEX
WITH
ITS
VERTICES
LABELLED
MOREOVER
YOU
WILL
HAVE
AN
ODD
NUMBER
OF
SUCH
TRIANGLES
PROOF
TO
PROVE
SPERNER
LEMMA
WE
TRACE
A
PATH
THROUGH
THE
SIMPLEX
THAT
IS
GUARANTEED
TO
END
IN
A
TRIANGLE
IN
ORDER
TO
MAKE
THE
PROOF
CLEANER
WE
FIRST
ADD
SOME
TRIANGLES
TO
THE
SIDE
OF
THE
SIMPLEX
SEE
FIGURE
WE
BEGIN
OUTSIDE
THE
SIMPLEX
AND
ENTER
THE
SIMPLEX
USING
THE
BOUNDARY
EDGE
THUS
WE
ENTER
A
TRIANGLE
THAT
HAS
AT
LEAST
ONE
EDGE
AT
ANY
POINT
IN
THE
TRACE
IF
WE
ARE
NOT
IN
A
TRIANGLE
THE
TRIANGLE
HAS
EXACTLY
TWO
EDGES
WE
CONTINUE
OUR
TRACE
BY
CROSSING
THE
OTHER
EDGE
WE
CANNOT
EVER
RE
ENTER
ANY
TRIANGLE
SINCE
A
TRIANGLE
HAS
AT
MOST
TWO
EDGES
ALSO
WE
CANNOT
EXIT
THE
FIGURE
GRAPH
SHOWING
WHICH
THEOREMS
CAN
BE
USED
TO
PROVE
OTHERS
FIGURE
EXAMPLE
TRIANGULATED
AND
LABELLED
SIMPLEX
FIGURE
EXAMPLE
SOLUTION
A
C
B
FIGURE
LABELLING
SCHEME
SIMPLEX
BECAUSE
THERE
IS
ONLY
ONE
BOUNDARY
EDGE
SINCE
THE
TRIANGULATION
HAS
FINITELY
MANY
TRIANGLES
OUR
TRACE
MUST
END
AT
A
TRAINGLE
WITH
EXACTLY
ONE
EDGE
WHICH
HAS
TO
BE
A
USING
SPERNER
LEMMA
WE
CAN
NOW
PROVE
BROUWER
FIXED
POINT
THEOREM
BROUWER
FIXED
POINT
THEOREM
TAKE
AN
EQUILATERAL
TRIANGLE
A
TWO
DIMENSIONAL
SIMPLEX
AND
PERFORM
SOME
TRANSFORMATION
SUCH
THAT
ALL
POINTS
ON
THE
MODIFIED
TRIANGLE
LIE
SOMEWHERE
WITHIN
THE
BOUNDARY
OF
THE
ORIGINAL
TRIANGLE
SOME
POSSIBLE
TRANSFORMATIONS
ARE
ROTATING
THE
TRIANGLE
BY
SOME
MULTIPLE
OF

FLIPPING
THE
TRIANGLE
ALONG
A
BISECTOR
OR
SHRINKING
THE
TRIANGLE
THIS
DOES
NOT
INCLUDE
TRANSLATING
THE
TRIANGLE
BECAUSE
SOME
OF
THE
TRANSLATED
POINTS
WOULD
NOT
LIE
WITHIN
THE
BOUNDARY
OF
THE
ORIGINAL
AFTER
ANY
SUCH
TRANSFORMATION

BROUWER
THEOREM
SAYS
THAT
THERE
IS
A
POINT
X
THAT
IS
IN
THE
SAME
POSITION
AS
IT
WAS
IN
THE
ORIGINAL
SIMPLEX
THEOREM
BROUWER
FIXED
POINT
THEOREM
LET
BE
ANY
N
DIMENSIONAL
SIMPLEX
AND
LET

BE
ANY
CONTINUOUS
FUNCTION
THEN

HAS
A
FIXED
POINT
I
E
X
SUCH
THAT

X
X
PROOF
WE
PROVE
THE
THEOREM
HERE
FOR
THE
SPECIAL
CASE
WHERE
THE
SIMPLEX
IS
AN
EQUILATERAL
TRIANGLE
IN
AN
ESSENTIALLY
SIMILAR
ARGUMENT
APPLIES
TO
THE
GENERAL
CASE
THE
PROOF
IS
A
DIRECT
APPLICATION
OF
SPERNER
LEMMA
LET
TN
BE
A
SEQUENCE
OF
SUCCESIVELY
FINER
TRIANGULATIONS
FOR
EXAMPLE
DIAMETER
TN
N
WE
DEFINE
LABELLINGS
LN
FOR
THE
TRIANGULATIONS
AS
FOLLOWS
FOR
A
VERTEX
X
IN
THE
TRIANGULATION
CONSIDER
THE
VECTOR
FROM
X
TO

X
EXTEND
THIS
VECTOR
UNTIL
IT
MEETS
A
BOUNDARY
OF
THE
SIMPLEX
IF
IT
CROSSES
CONSIDER
EACH
TRIANGLE
IN
THE
TRIANGULATION
AS
A
ROOM
IN
A
CASTLE
AND
A
EDGE
AS
A
DOOR
NOTE
THAT
THE
CASTLE
HAS
ONLY
ONE
ENTRY
EXIT
AND
EACH
ROOM
HAS
AT
MOST
TWO
DOORS
WHAT
THE
ARGUMENT
ABOVE
SAYS
IS
THAT
IF
WE
ENTER
THE
CASTLE
AND
MOVE
THROUGH
THE
ROOMS
OUR
PATH
SHOULD
END
IN
A
ROOM
WITH
EXACTLY
ONE
DOOR
FIGURE
GRAPH
OF
TWO
PEOPLE
UTILITIES
AND
ONE
POSSIBLE
PARETO
POINT
EDGE
AB
RESP
BC
CA
WE
LABEL
X
AS
RESP
WE
BREAK
TIES
ARBITRARILY
IT
IS
EASY
TO
SEE
THAT
UNDER
THIS
LABELLING
FOR
ANY

THE
VERTICES
OF
THE
TRIANGLE
GET
LABELS
RESPECTIVELY
NO
VERTEX
ON
THE
EDGE
AB
RESP
BC
AND
CA
GETS
A
LABEL
RESP
AND
THUS
LI
IS
A
LEGAL
SPERNER
LABELLING
FOR
TRIANGLULATION
TI
THUS
BY
SPERNER
LEMMA
THERE
IS
A
TRIANGLE
SAY
TI
IN
TI
LET
MI
BE
THE
CENTROID
OF
TRIANGLE
TI
CONSIDER
THE
SEQUENCE
OF
POINTS
MI
THIS
IS
A
INFINITE
SEQUENCE
IN
AND
THUS
HAS
A
SUBSEQUENCE
XI
THAT
CONVERGES
TO
A
POINT
X
THUS
X
IS
ARBITRARY
CLOSE
TO
THE
CENTROID
OF
SOME
TRIANGLE
WE
CLAIM
THAT
X
IS
A
FIXED
POINT
OF

THIS
IS
SO
BECAUSE
IF

X
IS
DIFFERENT
FROM
X
WE
CAN
FIND
A
SMALL
TRIANGLE
CONTAINING
X
BUT
NOT

X
SINCE

IS
CONTINUOUS
THIS
TRIANGLE
CANNOT
BE
LABELLED
FOR
A
MORE
RIGOROUS
PROOF
THE
READER
IS
REFERRED
TO
APPENDIX
A
ARROW
DEBREU
THEOREM
GENERAL
EQUILIBRIA
EXIST
TO
FRAME
THE
PROBLEM
CONSIDER
A
MARKETPLACE
WITH
N
AGENTS
A
K
DIFFERENT
COMMODITIES
EACH
AGENT
I
COMES
TO
THE
MARKET
PLACE
WITH
AN
ENDOWMENT
WHICH
WE
REPRESENT
AS
A
VECTOR
OF
GOODS
OR
SERVICES
EI
RK
EVERY
AGENT
I
HAS
A
UTILITY
FUNCTION
UI
RK
R
WHICH
DESCRIBES
HOW
MUCH
UTILITY
AGENT
I
GETS
FROM
VARIOUS
AMOUNTS
OF
THE
K
GOODS
THE
UTILITY
FUNCTION
MAY
BE
ARBITRARY
AND
IT
IS
NOT
NECESSARILY
LINEAR
ALSO
WE
ASSUME
THAT
THE
GOODS
ARE
INFINITELY
DIVISIBLE
WHEN
AGENTS
COME
TO
THE
MARKET
THEY
WANT
TO
EXCHANGE
GOODS
WITH
OTHER
AGENTS
SUCH
THAT
THEY
IMPROVE
THEIR
OVERALL
UTILITY
THERE
IS
A
POINT
IN
THIS
EXCHANGE
KNOWN
AS
THE
PARETO
POINT
WHERE
NEITHER
AGENT
CAN
IMPROVE
THEIR
UTILITY
THROUGH
FURTHER
EXCHANGES
SEE
FIGURE
THE
QUESTION
IS
HOW
SHOULD
EXCHANGES
BE
CARRIED
OUT
TO
MAXIMIZE
THE
AGENTS
UTILITIES
AND
AT
WHAT
PRICES
IT
POSSIBLE
THAT
THE
NECESSARY
SEQUENCE
OF
EXCHANGES
IS
COMPLICATED
OR
CREATES
A
CYCLE
AND
SEARCHING
FOR
AN
OPTIMAL
EXCHANGE
SEQUENCE
IS
COMPUTATIONALLY
INTRACTIBLE
INSTEAD
WE
COULD
HAVE
EVERYONE
ANNOUNCE
THEIR
THIS
IS
A
CONSEQUENCE
OF
THE
BOLZANO
WIERSTRASS
THEOREM
E
G
SEE
ROYDEN
PAGE
UTILITY
FUNCTIONS
AND
TRY
TO
SOLVE
FOR
AN
OPTIMUM
BUT
THEN
WE
HAVE
NO
WAY
OF
KNOWING
WHETHER
PEOPLE
ARE
BEING
HONEST
ABOUT
THEIR
UTILITIES
A
SOLUTION
IS
TO
USE
SET
PRICES
FOR
EACH
COMMODITY
PJ
R
WHICH
FOR
NOW
WE
WILL
ASSUME
ARE
GOD
GIVEN
WITH
PRICES
IN
HAND
THERE
IS
NO
LONGER
A
DILEMMA
EACH
AGENT
BUYS
A
VECTOR
OF
GOODS
XI
THAT
MAXIMIZES
UI
XI
SUBJECT
TO
P
XI
P
EI
WHERE
P
XI
IS
THE
AMOUNT
THE
AGENT
PAYS
FOR
THE
GOODS
SHE
WANTS
AND
P
EI
IS
THE
AMOUNT
THE
AGENT
RECEIVED
FOR
HER
ORIGINAL
ENDOWMENT
THIS
CAN
BE
SOLVED
FOR
XI
P
THE
OPTIMAL
PURCHASE
OF
GOODS
FOR
AGENT
I
WHEN
PRICES
ARE
P
WE
ASSUME
THAT
XI
P
IS
CONTINUOUS
AND
HAS
A
UNIQUE
OPTIMUM
AT
SOME
POINT
THE
MARKET
MAY
CLEAR
MEANING
THAT
ALL
THE
GOODS
FOR
SALE
HAVE
BEEN
PURCHASED
THE
TOTAL
AMOUNTS
OF
EACH
COMMODITY
DEMANDED
BY
ALL
AGENTS
IS
DESCRIBED
BY
X
P
N
XI
P
AND
THE
MARKET
CLEARS
IF
WHERE
E
N
X
P
E
EI
IS
THE
TOTAL
AMOUNT
OF
GOODS
BROUGHT
TO
THE
MARKET
THEOREM
ARROW
DEBREU
THEOREM
THERE
IS
ALWAYS
A
PRICE
P
SUCH
THAT
X
P
E
I
E
ONE
CAN
ALWAYS
FIND
A
PRICE
THAT
CLEARS
THE
MARKET
SUCH
A
PRICE
IS
A
GENERAL
EQUILIBRIUM
THIS
PRICE
IS
ALSO
A
PARETO
POINT
NOTE
WHILE
THE
PRICE
EQUILIBRIUM
IS
UNIQUE
THERE
MAY
BE
SEVERAL
PARETO
POINTS
DEPENDING
UPON
THE
AGENTS
INITIAL
ENDOWMENTS
SURPRISINGLY
FINDING
P
CAN
BE
DONE
WITH
REMARKABLY
LITTLE
COMMUNICATION
CONSIDER
THE
SIMPLEX
OF
ALL
PRICES
PJ
J
IF
THE
PRICE
IS
SUCH
THAT
THERE
IS
EXCESS
DEMAND
THEN
THE
PRICE
SHOULD
BE
INCREASED
BY
THE
AMOUNT
THAT
DEMAND
EXCEEDS
THE
ENDOWMENT
ASSUMING
NO
INFLATION
WE
CAN
NORMALIZE
ALL
PRICES
SUCH
THAT
THEY
ADD
UP
TO
ONE

P
PJ
MAX
XJ
EJ
NORMALIZATION
CONSTANT
EITHER
THE
ENDOWMENT
IS
GREATER
THAN
OR
EQUAL
TO
WHAT
THE
AGENTS
WANT
IN
WHICH
CASE
THE
PRICE
STAYS
THE
SAME
OR
THE
PRICE
IS
INCREASED
BY
THE
DIFFERENCE
BETWEEN
WHAT
THE
AGENTS
WANT
AND
THE
TOTAL
ENDOWMENT
THIS
TRANSFORMATION
MAPS
A
VECTOR
OF
PRICES
TO
ANOTHER
POINT
IN
THE
SIMPLEX
AND
BROUWER
FIXED
POINT
THEOREM
SAYS
THAT
THERE
MUST
ALWAYS
BE
A
FIXED
POINT
TO
SUCH
A
TRANFORMATION
CALL
THE
FIXED
POINT
P
CLAIM
AT
FIXED
POINT
P
FOR
EVERY
PRODUCT
J
XJ
EJ
PROOF
LET
D
X
E
LET
DIJ
MAX
DJ
WE
WANT
TO
SHOW
THAT
DJI
FOR
ALL
COMMODITIES
J
WE
HAVE
FROM

P
P
DI
K
FOR
SOME
NORMALIZATION
CONSTANT
K
MOREOVER
ADDING
EQUATIONS
FOR
ALL
AGENTS
I
WE
GET
P
X
P
E
I
E
P
D
SINCE
P
IS
A
FIXED
POINT

P
P
TAKING
DOT
PRODUCT
OF
EQUATION
WITH
D
WE
GET
P
D
K
P
DI
D
REARRANGING
AND
NOTING
THAT
DI
D
DI
D
WE
GET
DI
DI
K
P
D
THUS
DI
MUST
BE
ZERO
NASH
EQUILIBRIA
EXIST
THE
PROOF
OF
NASH
THEOREM
REQUIRES
THE
USE
OF
ANOTHER
FIXED
POINT
THEOREM
MORE
GENERAL
THAN
THE
BROUWER
FIXED
POINT
THEOREM
THEOREM
KAKUTANI
FIXED
POINT
THEOREM
LET

BE
ANY
CONVEX
VALUED
FUNCTION
SUCH
THAT
FOR
ANY
SEQUENCE
XI
YI
CONVERGING
TO
X
Y
IF
I
N
YI

XI
THEN
Y

X
THIS
PROPERTY
IS
CALLED
GRAPH
CONTINUITY
THEN

HAS
A
FIXED
POINT
I
E
X
SUCH
THAT
X

X
PROOF
WE
GIVE
HERE
A
PROOF
SKETCH
FOR
THE
D
SIMPLEX
CASE
AS
IN
THE
PROOF
OF
BROUWER
THEOREM
WE
CONSIDER
A
SEQUENCE
OF
SUCCESIVELY
FINER
TRIANGULATIONS
TN
FOR
A
TRIANGULATION
TI
WE
DEFINE
A
FUNCTION
I
AS
FOLLOWS
FOR
A
VERTEX
X
OF
THE
TRIANGULATION
I
X
IS
SET
TO
SOME
Y

X
CHOSEN
ARBITRARILY
FOR
ANY
OTHER
POINT
X
I
X
IS
DEFINED
BY
LINEAR
INTERPOLATION
IN
THE
TRIANGLE
CONTAINING
X
THUS
I
IS
A
CONTINUOUS
MAP
BY
BROUWER
FIXED
POINT
THEOREM
I
HAS
A
FIXED
POINT
X
I
NOW
CONSIDER
THE
SEQUENCE
X
I
IT
HAS
A
CONVERGENT
SUBSEQUENCE
THAT
CONVERGES
TO
SOME
POINT
X
USING
THE
GRAPH
CONTINUITY
OF

IT
CAN
BE
SHOWN
THAT
X

X
FOR
A
MORE
RIGOROUS
PROOF
OF
KAKUTANI
FIXED
POINT
THEOREM
THE
READER
IS
REFERRED
TO
FOR
ANY
GAME
A
NASH
EQUILIBRIUM
SUGGESTS
THAT
NONE
OF
THE
PLAYERS
HAS
AN
ADVANTAGE
IN
CHANGING
HIS
STRATEGY
WITHOUT
THE
OTHER
PLAYERS
CHANGING
THEIR
STRATEGY
AS
WELL
MORE
FORMALLY
DEFINITION
LET
AND
BE
THE
SET
OF
POSSIBLE
STRATEGIES
FOR
PLAYER
AND
RESPECTIEVELY
LET
R
RESP
BE
THE
PAYOFF
FUNCTION
FOR
PLAYER
RESP
PLAYER
THEN
A
TUPLE
IS
SAID
TO
BE
IN
NASH
EQUILIBRIUM
IF
WHILE
THE
ABOVE
DEFINITION
CAPTURES
ALL
PURE
STRATEGIES
IT
DOES
NOT
CONSIDER
THE
POSSIBILITY
OF
MIXED
STRATEGIES
I
E
STRATEGIES
WHERE
A
PLAYER
CHOOSES
A
MOVE
RANDOMLY
ACCORDING
TO
SOME
DISTRIBUTION

ON
WHEN
WE
ALLOW
MIXED
STRATEGIES
WE
ASSUME
THAT
EACH
PLAYER
TRIES
TO
MAXIMIZE
HIS
EXPECTED
PAYOFF
THUS
IF
PLAYER
I
CHOOSES
FROM
A
DISTRIBUTION
I
ON
SI
EACH
PLAYER
TRIES
TO
MAXIMIZE
PI
PI
A
TUPLE
OF
MIXED
STRATEGIES
IS
SAID
TO
BE
IN
MIXED
NASH
EQUILIBRIUM
IF
PROB
DISTRIBUTIONS
ON
PROB
DISTRIBUTIONS
ON
WHILE
FOR
MANY
GAMES
IT
IS
THE
CASE
THAT
NO
PURE
NASH
EQUILIBRIA
EXIST
MIXED
NASH
EQUILIBRIA
ALWAYS
EXIST
THEOREM
NASH
THEOREM
EVERY
GAME
HAS
A
MIXED
STRATEGY
NASH
EQUILIBRIUM
TO
PROVE
NASH
THEOREM
LET
BE
THE
SET
OF
ALL
MIXED
STRATEGIES
D
THAT
MAXIMIZE
FOR
A
MIXED
STRATEGY
D
OF
PLAYER
SIMILARLY
DEFINE
THE
SET
NOW
LET

IT
IS
EASY
TO
SEE
THAT

D
AS
DEFINED
ABOVE
IS
CONVEX
VALUED
AND
GRAPH
CONTINUOUS
HENCE
BY
KAKUTANI
FIXED
POINT
THEOREM

HAS
A
FIXED
POINT


THIS
BY
DEFINITION
IS
A
MIXED
NASH
EQUILIBRIUM
OVERVIEW
OF
COURSE
TOPICS
A
BRIEF
OVERVIEW
OF
THE
TOPICS
FOR
THE
SEMESTER
BACKGROUND
ON
EQUILIBRIUM
THEOREMS
NOTIONS
OF
EQUILIBRIA
NASH
EQUILIBRIA
ALWAYS
EXIST
BUT
OFTEN
THERE
ARE
TOO
MANY
OF
THEM
MUCH
OF
GAME
THEORY
HAS
BEEN
A
CRITIQUE
OF
NASH
EQUILIBRIA
GAMES
PLAYED
BY
AUTOMATA
TO
EXPLAIN
PEOPLE
STRATEGIES
IN
PRISONER
DILEMMA
WE
NEED
A
MORE
REFINED
THEORY
PERHAPS
REPETITION
AND
REPUTATION
ARE
THE
THE
KEY
IF
WE
CONSIDER
RESOURCE
BOUNDS
THEN
AUTOMATA
BECOME
RELEVANT
TO
GAME
THEORY
PEOPLE
DON
T
HAVE
INFINITE
REASONING
CAPACITY
AND
WE
CAN
MODEL
THEM
USING
AUTOMATA
WITH
LIMITED
STATES
EVOLUTIONARY
GAME
THEORY
DISCUSS
JOHN
MAYNARD
SMITH
TALK
ABOUT
GAME
THEORY
IN
THE
CONTEXT
OF
EVOLUTION
FINDING
AN
EVOLU
TIONARILY
STABLE
STRATEGY
E
G
TIT
FOR
TAT
MECHANISM
DESIGN
INVERSE
GAME
THEORY
GIVEN
DESIRED
OUTCOMES
DESIGN
A
GAME
SO
THAT
AGENTS
ACTING
RATIONALLY
WILL
BEHAVE
IN
A
DESIRED
WAY
AN
EXAMPLE
IS
THE
VICKERO
AUCTION
WHERE
THE
HIGHEST
BIDDER
IS
THE
WINNER
BUT
THE
WINNER
PAYS
THE
AMOUNT
OF
THE
SECOND
HIGHEST
BID
FAIRNESS
AUCTIONS
INCLUDING
COMBINATORIAL
AUCTIONS
PRICE
OF
ANARCHY
TAKE
A
NETWORK
WHERE
IT
IS
POSSIBLE
TO
CONTROL
WHAT
ROUTE
EACH
PACKET
TAKES
TO
ITS
DESTINATION
IF
A
CENTRAL
AUTHORITY
WERE
TO
DETERMINE
AN
OPTIMAL
ROUTING
POLICY
GIVEN
ALL
THE
INFORMATION
IN
THE
NETWORK
THE
IMPROVEMENT
IN
PERFORMANCE
WOULD
BE
AT
MOST
TWICE
OVER
A
SYSTEM
WHERE
EACH
AGENT
OPTIMIZES
ITS
OWN
PACKETS
REFERENCES
H
L
ROYDEN
REAL
ANALYSIS
EDITION
PRENTICE
HALL
KAKUTANI
A
GENERALIZATION
OF
BROUWER
FIXED
POINT
THEOREM
DUKE
MATHEMATICAL
JOURNAL
PP
APPENDIX
A
DETAILS
IN
PROOF
OF
BROUWER
THEOREM
THEOREM
CONSIDER
THE
LABELLING
DEFINED
IN
THEROEM
LET
X
BE
THE
LIMIT
OF
A
SEQUENCE
XI
OF
CENTROID
OF
A
SEQUENCE
OF
TRIANGLES
WITH
DIAMETER
CONVERGING
TO
THEN
X
IS
A
FIXED
POINT
OF

PROOF
ASSUME
THE
CONTRARY
I
E

X
X
THEN
T
L
X
XL
LET
E
T
FOR
SOME
K
SINCE

IS
CONTINUOUS
AND
E
THERE
EXISTS

SUCH
THAT
Y
N
X


Y
N

X
E
LET
EI
MIN
E

SINCE
XI
CONVERGES
TO
X
N
SUCH
THAT
N
XN
N
X
EI
FURTHER
SINCE
THE
DIAMETER
OF
THE
TRIANGULATIONS
CONVERGES
TO
ZERO
N
SUCH
THAT
N
DIAMETER
TN
EI
THUS
FOR
N
MAX
A
TRIANGLE
TN
LIES
WHOLLY
INSIDE
N
X
N
X

THUS
BY
THE
CONTINUITY
CONDITION
ABOVE
EACH
OF
THE
THREE
VERTICES
A
B
C
OF
THE
TRIANGLE
MAPS
TO
SOME
POINT
IN
N

X
E
OUTSIDE
THE
TRIANGLE
SINCE
THE
TRIANGLE
IS
A
TRIANGLE
THE
VECTORS

A
A

B
B

C
C
SPAN
AN
ANGLE
OF
AT
LEAST

BY
OUR
LABELLING
SCHEME
HOWEVER
FOR
K
LARGE
ENOUGH
THE
ANGLE
SPANNED
CAN
BE
MADE
ARBITRARILY
SMALL
SEE
FIGURE
B
WHICH
IS
A
CONTRADICTION
HENCE
THE
CLAIM
B
FIGURE
A
PROOF
DETAILS
B
ANGLE
SPANNED
BY
VECTORS
SHOULD
BE
SMALL
ECONOMICS
LETTERS
THE
GIBBARD
SATTERTHWAITE
THEOREM
A
SIMPLE
PROOF
JEAN
PIERRE
BENOI
T
DEPARTMENT
OF
ECONOMICS
AND
SCHOOL
OF
LAW
NEW
YORK
UNIVERSITY
WASHINGTON
SQUARE
SOUTH
NEW
YORK
NY
USA
RECEIVED
JANUARY
ACCEPTED
APRIL
ABSTRACT
A
SIMPLE
PROOF
OF
THE
GIBBARD
SATTERTHWAITE
THEOREM
IS
PROVIDED
ELSEVIER
SCIENCE
A
ALL
RIGHTS
RESERVED
KEYWORDS
GIBBARD
SATTERTHWAITE
MANIPULABILITY
JEL
CLASSIFICATION
THE
CLASSIC
GIBBARD
SATTERTHWAITE
THEOREM
GIBBARD
SATTERTHWAITE
STATES
ESSENTIALLY
THAT
A
DICTATORSHIP
IS
THE
ONLY
NON
MANIPULABLE
VOTING
MECHANISM
THIS
THEOREM
IS
INTIMATELY
CONNECTED
TO
ARROW
IMPOSSIBILITY
THEOREM
IN
THIS
NOTE
I
PROVIDE
A
SIMPLE
PROOF
OF
THE
THEOREM
ADAPTING
AN
IDEA
USED
BY
GEANAKOPLOS
IN
ONE
OF
HIS
SIMPLE
PROOFS
OF
ARROW
THEOREM
CONSIDER
A
SET
OF
INDIVIDUALS
N
WITH
UNU
N
AND
A
SET
OF
ALTERNATIVES
M
WITH
UMU
M
WE
ASSUME
THAT
EACH
PERSON
HAS
A
STRICT
LINEAR
PREFERENCE
ORDERING
OVER
THE
ALTERNATIVES
A
SOCIAL
CHOICE
FUNCTION
SELECTS
A
SINGLE
ALTERNATIVE
ON
THE
BASIS
OF
THE
REPORTED
PREFERENCE
PROFILE
OF
THE
INDIVIDUALS
THE
RULE
IS
UNANIMOUS
IF
IT
ALWAYS
SELECTS
AN
ALTERNATIVE
THAT
IS
TOP
RANKED
BY
EVERYONE
IT
IS
STRATEGYPROOF
IF
IT
IS
A
DOMINANT
STRATEGY
FOR
AN
INDIVIDUAL
WITH
ANY
PERMISSIBLE
RANKING
TO
TRUTHFULLY
REPORT
HER
PREFERENCES
THEOREM
GIBBARD
SATTERTHWAITE
SUPPOSE
THERE
ARE
AT
LEAST
THREE
ALTERNATIVES
AND
THAT
FOR
EACH
TEL
FAX
E
MAIL
ADDRESS
J
P
BENOI
T
RENY
FURTHER
EMPHASIZES
THE
CONNECTION
BETWEEN
THE
GIBBARD
SATTERTHWAITE
THEOREM
AND
ARROW
THEOREM
BY
INGENIOUSLY
PROVIDING
A
SHARED
SIMPLE
PROOF
FOR
BOTH
RESULTS
HIS
PAPER
WAS
WRITTEN
INDEPENDENTLY
OF
THIS
ONE
BUT
WAS
ALSO
INSPIRED
BY
GEANAKOPLOS
SEN
PROVIDES
A
DIRECT
PROOF
THAT
DOES
NOT
REQUIRE
THE
UNIVERSAL
DOMAIN
OF
PREFERENCES
SEE
ALSO
BARBERA
FOR
AN
EARLIER
RELATIVELY
SIMPLE
PROOF
SEE
FRONT
MATTER
ELSEVIER
SCIENCE
A
ALL
RIGHTS
RESERVED
PII
J
P
BENOIT
ECONOMICS
LETTERS
INDIVIDUAL
ANY
STRICT
RANKING
OF
THESE
ALTERNATIVES
IS
PERMISSIBLE
THEN
THE
ONLY
UNANIMOUS
STRATEGY
PROOF
SOCIAL
CHOICE
FUNCTION
IS
A
DICTATORSHIP
PROOF
SUPPOSE
WE
ARE
GIVEN
A
UNANIMOUS
STRATEGY
PROOF
SOCIAL
CHOICE
FUNCTION
WE
SHOW
THAT
ONE
OF
THE
VOTERS
MUST
BE
A
DICTATOR
WE
FIRST
OBSERVE
THE
FOLLOWING
FACT
FACT
SUPPOSE
THAT
ALTERNATIVE
A
IS
SELECTED
GIVEN
SOME
PREFERENCE
PROFILE
MODIFY
THE
PROFILE
BY
RAISING
SOME
ALTERNATIVE
X
IN
INDIVIDUAL
I
RANKING
HOLDING
EVERYTHING
ELSE
FIXED
THEN
EITHER
A
OR
X
IS
NOW
SELECTED
SUPPOSE
INSTEAD
THAT
WHEN
X
RISES
SOME
ALTERNATIVE
C
DIFFERENT
FROM
A
AND
X
IS
CHOSEN
THEN
IF
I
PREFERS
A
TO
C
HE
WOULD
NOT
REPORT
THE
CHANGE
WHEREAS
IF
HE
PREFERS
C
TO
A
HE
WOULD
HAVE
FALSELY
REPORTED
THIS
CHANGE
EARLIER
STEP
WE
BEGIN
WITH
AN
ARBITRARY
STRICT
PROFILE
IN
WHICH
EVERYONE
RANKS
B
LAST
ALTERNATIVE
B
IS
NOT
SELECTED
OR
ELSE
BY
STRATEGYPROOFNESS
IT
WOULD
STILL
HAVE
TO
BE
SELECTED
IF
THE
VOTERS
ONE
AT
A
TIME
RAISED
A
TO
THE
TOP
OF
THEIR
PROFILES
CONTRADICTING
UNANIMITY
NOW
STARTING
WITH
INDIVIDUAL
AND
CONTINUING
IN
ORDER
WITH
THE
OTHER
VOTERS
ONE
AT
A
TIME
HAVE
B
JUMP
FROM
THE
BOTTOM
OF
EACH
RANKING
TO
THE
TOP
LEAVING
THE
OTHER
RELATIVE
RANKINGS
IN
PLACE
LET
R
BE
THE
PIVOTAL
INDIVIDUAL
FOR
WHOM
THE
JUMP
CAUSES
B
TO
BE
SELECTED
THAT
IS
WITH
THE
PROFILE
PROFILE
B
IS
NOT
SELECTED
WHEREAS
WITH
THE
PROFILE
PROFILE
B
IS
SELECTED
CONSIDER
PROFILE
WHERE
B
IS
SELECTED
ALTERNATIVE
B
MUST
STILL
BE
SELECTED
IF
ANY
PLAYER
I
R
SUBMITS
A
DIFFERENT
RANKING
OR
ELSE
I
WOULD
MISREPRESENT
ALSO
B
MUST
STILL
BE
SELECTED
IF
ANY
PLAYER
I
R
SUBMITS
A
DIFFERENT
RANKING
WITH
B
STILL
RANKED
FIRST
OR
ELSE
I
WOULD
NOT
HONESTLY
REPORT
THIS
RANKING
CONSIDERING
THE
PLAYERS
ONE
AT
A
TIME
WE
HAVE
B
IS
CHOSEN
WHENEVER
THE
FIRST
R
PLAYERS
RANK
B
FIRST
BD
CONSIDER
PROFILE
WHERE
B
IS
NOT
CHOSEN
ALTERNATIVE
B
MUST
STILL
NOT
BE
CHOSEN
IF
ANY
PLAYER
J
P
BENOIT
ECONOMICS
LETTERS
I
R
SUBMITS
A
DIFFERENT
RANKING
OR
ELSE
I
WOULD
DO
JUST
THAT
ALSO
B
MUST
STILL
NOT
BE
CHOSEN
IF
ANY
PLAYER
I
R
SUBMITS
A
DIFFERENT
RANKING
WITH
B
RANKED
LAST
OR
ELSE
I
WOULD
NOT
HONESTLY
REPORT
THIS
RANKING
CONSIDERING
THE
PLAYERS
ONE
AT
A
TIME
WE
HAVE
B
IS
NOT
SELECTED
WHENEVER
VOTERS
R
THROUGH
N
RANK
ALTERNATIVE
B
LAST
NOT
BD
WE
WILL
SHOW
THAT
THE
PIVOTAL
INDIVIDUAL
R
IS
IN
FACT
A
DICTATOR
STEP
PROFILE
FIRST
RAISE
K
TO
THE
TOP
POSITION
FOR
ALL
VOTERS
BY
UNANIMITY
K
IS
CHOSEN
NOW
RAISE
B
TO
THE
TOP
FOR
VOTERS
THROUGH
R
ONE
AT
A
TIME
LEAVING
B
ON
THE
BOTTOM
FOR
THE
REMAINING
VOTERS
PROFILE
BY
NOT
BD
ALTERNATIVE
B
IS
NOT
CHOSEN
SO
BY
FACT
ALTERNATIVE
K
IS
STILL
CHOSEN
FINALLY
RAISE
B
TO
THE
SECOND
POSITION
FOR
VOTER
R
ALTERNATIVE
K
IS
STILL
CHOSEN
OR
ELSE
R
WOULD
NOT
REPORT
THIS
CHANGE
THAT
IS
K
IS
CHOSEN
WITH
THE
PROFILE
PROFILE
NOW
RECONSIDER
PROFILE
AND
SUPPOSE
G
K
IS
CHOSEN
RAISE
B
TO
THE
TOP
POSITION
FOR
THE
FIRST
R
VOTERS
ONE
AT
A
TIME
BY
NOT
BD
B
IS
NOT
CHOSEN
SO
BY
FACT
G
IS
STILL
CHOSEN
NOW
RAISE
B
IN
VOTER
R
PROFILE
TO
THE
SECOND
POSITION
PROFILE
SUPPOSE
B
IS
NOT
SELECTED
BY
FACT
ALTERNATIVE
G
IS
STILL
CHOSEN
FROM
BD
ALTERNATIVE
B
WILL
BE
SELECTED
WHEN
IT
IS
RAISED
TO
THE
TOP
OF
R
PROFILE
HENCE
VOTER
R
SHOULD
NOW
FALSELY
REPORT
THIS
J
P
BENOIT
ECONOMICS
LETTERS
PREFERENCE
SINCE
SHE
PREFERS
B
TO
G
K
CONTRADICTING
STRATEGY
PROOFNESS
THEREFORE
WITH
PROFILE
ALTERNATIVE
B
IS
SELECTED
NOW
RAISE
K
TO
THE
SECOND
POSITION
FOR
VOTERS
THROUGH
R
AND
THE
FIRST
POSITION
FOR
VOTERS
R
THROUGH
N
ALTERNATIVE
B
IS
STILL
CHOSEN
OR
ELSE
THE
FIRST
GROUP
OF
VOTERS
WOULD
NOT
TRUTHFULLY
REPORT
THIS
CHANGE
WHEREAS
THE
SECOND
GROUP
WOULD
HAVE
MISREPORTED
IT
BUT
THIS
MODIFIED
PROFILE
IS
THE
SAME
AS
PROFILE
WHERE
K
IS
CHOSEN
A
CONTRADICTION
SO
THAT
G
K
CANNOT
BE
CHOSEN
WITH
PROFILE
STEP
NOW
CONSIDER
AN
ARBITRARY
PROFILE
IN
WHICH
R
RANKS
SOME
ALTERNATIVE
K
B
ON
TOP
FIRST
MODIFY
THE
PROFILE
BY
DROPPING
B
TO
THE
BOTTOM
FOR
ALL
VOTERS
FROM
STEP
ALTERNATIVE
K
IS
CHOSEN
NOW
RESTORE
B
TO
ITS
INITIAL
POSITION
FOR
ALL
VOTERS
ONE
AT
A
TIME
BY
FACT
EITHER
K
OR
B
IS
CHOSEN
NOW
CONSIDER
R
R
R
N
B
B
B
B
B
A
A
A
PROFILE
WHERE
C
B
AND
C
K
SIMILARLY
TO
STEP
HAVE
C
JUMP
IN
THE
RANKINGS
OF
THE
VOTERS
ONE
AT
A
TIME
UNTIL
WE
DISCOVER
THE
PIVOTAL
VOTER
M
FOR
ALTERNATIVE
C
SYMMETRICALLY
TO
STEP
THIS
PIVOTAL
VOTER
HAS
HIS
TOP
CHOICE
SELECTED
WITH
PROFILE
ON
THE
OTHER
HAND
FROM
BD
WE
ALSO
KNOW
THAT
WITH
PROFILE
ALTERNATIVE
B
IS
CHOSEN
HENCE
THE
PIVOT
M
MUST
BE
SUCH
THAT
M
R
BUT
A
SYMMETRIC
ARGUMENT
BEGINNING
WITH
M
AND
THEN
FINDING
R
SHOWS
THAT
R
M
SO
M
R
AND
VOTER
R
IS
PIVOTAL
WITH
RESPECT
TO
C
AS
WELL
AS
B
THUS
IN
ADDITION
TO
KNOWING
THAT
K
OR
B
IS
CHOSEN
FOR
OUR
INITIAL
ARBITRARY
PROFILE
WE
HAVE
THAT
EITHER
K
OR
C
IS
CHOSEN
SINCE
C
B
ALTERNATIVE
K
IS
CHOSEN
FINALLY
IF
K
B
A
SIMILAR
ARGUMENT
SHOWS
THAT
VOTER
R
IS
PIVOTAL
FOR
A
AS
WELL
AS
C
AND
THAT
B
IS
SELECTED
HENCE
R
IS
A
DICTATOR
GIBBARD
SATTERTHWAITE
THEOREM
FROM
WIKIPEDIA
THE
FREE
ENCYCLOPEDIA
THE
GIBBARD
SATTERTHWAITE
THEOREM
NAMED
AFTER
ALLAN
GIBBARD
AND
MARK
SATTERTHWAITE
IS
A
RESULT
ABOUT
THE
DETERMINISTIC
VOTING
SYSTEMS
THAT
CHOOSE
A
SINGLE
WINNER
USING
ONLY
BALLOTS
FROM
VOTERS
WITH
A
FINITE
NUMBER
OF
POSSIBLE
BALLOT
TYPES
THE
GIBBARD
SATTERTHWAITE
THEOREM
STATES
THAT
FOR
THREE
OR
MORE
CANDIDATES
ONE
OF
THE
FOLLOWING
THREE
THINGS
MUST
HOLD
FOR
EVERY
VOTING
RULE
THE
RULE
IS
DICTATORIAL
I
E
THERE
IS
A
SINGLE
INDIVIDUAL
WHO
CAN
CHOOSE
THE
WINNER
OR
THERE
IS
SOME
CANDIDATE
WHO
CAN
NEVER
WIN
UNDER
THE
RULE
OR
THE
RULE
IS
SUSCEPTIBLE
TO
TACTICAL
VOTING
IN
THE
SENSE
THAT
THERE
ARE
CONDITIONS
UNDER
WHICH
A
VOTER
WITH
FULL
KNOWLEDGE
OF
HOW
THE
OTHER
VOTERS
ARE
TO
VOTE
AND
OF
THE
RULE
BEING
USED
WOULD
HAVE
AN
INCENTIVE
TO
VOTE
IN
A
MANNER
THAT
DOES
NOT
REFLECT
HIS
OR
HER
PREFERENCES
RULES
THAT
FORBID
PARTICULAR
ELIGIBLE
CANDIDATES
FROM
WINNING
OR
ARE
DICTATORIAL
ARE
DEFECTIVE
HENCE
EVERY
DETERMINISTIC
VOTING
SYSTEM
THAT
SELECTS
A
SINGLE
WINNER
EITHER
IS
MANIPULABLE
OR
DOES
NOT
MEET
THE
PRECONDITIONS
OF
THE
THEOREM
THE
THEOREM
DOES
NOT
APPLY
TO
RANDOMIZED
VOTING
SYSTEMS
SUCH
AS
THE
SYSTEM
THAT
CHOOSES
A
VOTER
RANDOMLY
AND
SELECTS
THE
FIRST
CHOICE
OF
THAT
VOTER
CONTENTS
DEFINITIONS
FORMAL
STATEMENT
PROOF
RELATED
RESULTS
HISTORY
REFERENCES
EXTERNAL
LINKS
DEFINITIONS
A
SOCIALCHOICEFUNCTION
IS
A
FUNCTION
THAT
MAPS
A
SET
OF
INDIVIDUAL
PREFERENCES
TO
A
SOCIAL
OUTCOME
AN
EXAMPLE
FUNCTION
IS
THE
PLURALITY
FUNCTION
WHICH
SAYS
CHOOSE
THE
OUTCOME
THAT
IS
THE
PREFERRED
OUTCOME
OF
THE
LARGEST
NUMBER
OF
VOTERS
WE
DENOTE
A
SOCIAL
CHOICE
FUNCTION
BY
AND
ITS
RECOMMENDED
OUTCOME
GIVEN
A
SET
OF
PREFERENCES
BY
A
SOCIALCHOICE
FUNCTION
IS
CALLED
MANIPULABLE
BY
PLAYER
IF
THERE
IS
A
SCENARIO
IN
WHICH
PLAYER
CAN
GAIN
BY
REPORTING
UNTRUE
PREFERENCES
I
E
IF
THE
PLAYER
REPORTS
THE
TRUE
PREFERENCES
THEN
IF
THE
PLAYER
REPORTS
UNTRUE
PREFERENCES
THEN
AND
PLAYER
PREFERS
TO
A
SOCIALCHOICE
FUNCTION
IS
CALLED
INCENTIVECOMPATIBLE
IF
IT
IS
NOT
MANIPULABLE
BY
ANY
PLAYER
A
SOCIALCHOICE
FUNCTION
IS
CALLED
MONOTONE
IF
WHENEVER
THE
FOLLOWING
IS
TRUE
WHEN
HAS
SOME
PREFERENCES
WHEN
HAS
OTHER
PREFERENCES
GIBBARD
SATTERTHWAITE
THEOREM
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
GIBBARD
THEN
UNDER
THE
PREFERENCES
PLAYER
PREFERS
OUTCOME
AND
UNDER
THE
PREFERENCES
PLAYER
PREFERS
OUTCOME
IT
CAN
BE
DEMONSTRATED
THAT
INCENTIVECOMPATIBILITY
AND
MONOTONICITY
ARE
EQUIVALENT
FOR
EXAMPLE
WHEN
THERE
ARE
ONLY
TWO
POSSIBLE
OUTCOMES
THE
MAJORITY
RULE
IS
INCENTIVECOMPATIBLE
AND
MONOTONE
WHEN
A
PLAYER
SWITCHES
HIS
PREFERENCE
FROM
ONE
OPTION
TO
THE
OTHER
THIS
CAN
ONLY
BE
BETTER
FOR
THE
OTHER
OPTION
A
PLAYER
IS
CALLED
A
DICTATOR
IN
A
SOCIALCHOICE
FUNCTION
IF
ALWAYS
SELECTS
THE
OUTCOME
THAT
PLAYER
PREFERS
OVER
ALL
OTHER
OUTCOMES
IS
CALLED
A
DICTATORSHIP
IF
THERE
IS
A
PLAYER
WHO
IS
A
DICTATOR
IN
IT
FORMAL
STATEMENT
IF
IS
INCENTIVECOMPATIBLE
AND
RETURNS
AT
LEAST
THREE
DIFFERENT
OUTCOMES
THEN
IS
A
DICTATORSHIP
PROOF
THE
GS
THEOREM
CAN
BE
PROVED
BASED
ON
ARROW
IMPOSSIBILITY
THEOREM
ARROW
IMPOSSIBILITY
THEOREM
IS
A
SIMILAR
THEOREM
THAT
DEALS
WITH
SOCIAL
RANKING
FUNCTIONS
VOTING
SYSTEMS
DESIGNED
TO
YIELD
A
COMPLETE
PREFERENCE
ORDER
OF
THE
CANDIDATES
RATHER
THAN
SIMPLY
CHOOSING
A
WINNER
GIVEN
A
SOCIAL
CHOICE
FUNCTION
IT
IS
POSSIBLE
TO
BUILD
A
SOCIAL
RANKING
FUNCTION
AS
FOLLOWS
IN
ORDER
TO
DECIDE
WHETHER
THE
FUNCTION
CREATES
NEW
PREFERENCES
IN
WHICH
AND
ARE
MOVED
TO
THE
TOP
OF
ALL
VOTERS
PREFERENCES
THEN
EXAMINES
WHETHER
CHOOSES
OR
IT
IS
POSSIBLE
TO
PROVE
THAT
IF
IS
INCENTIVECOMPATIBLE
AND
NOT
A
DICTATORSHIP
THEN
SATISFIES
THE
PROPERTIES
UNANIMITY
AND
INDEPENDENCEOFIRRELEVANTALTERNATIVES
AND
IT
IS
NOT
A
DICTATORSHIP
ARROW
IMPOSSIBILITY
THEOREM
SAYS
THAT
WHEN
THERE
ARE
THREE
OR
MORE
ALTERNATIVES
SUCH
A
FUNCTION
CANNOT
EXIST
HENCE
SUCH
A
FUNCTION
ALSO
CANNOT
EXIST
IN
THIS
LECTURE
WE
ARE
GOING
TO
TALK
ABOUT
THE
COMPLEXITY
OF
FINDING
A
NASH
EQUILIBRIUM
IN
PARTICULAR
THE
CLASS
OF
PROBLEMS
NP
IS
INTRODUCED
AND
SEVERAL
IMPORTANT
SUBCLASSES
ARE
IDENTIFIED
MOST
IMPORTANTLY
WE
ARE
GOING
TO
PROVE
THAT
FINDING
A
NASH
EQUILIBRIUM
IS
PPAD
COMPLETE
DEFINED
IN
SECTION
FOR
AN
EXPOSITORY
ARTICLE
ON
THE
TOPIC
SEE
AND
FOR
A
MORE
DETAILED
ACCOUNT
SEE
COMPUTATIONAL
COMPLEXITY
FOR
US
THE
BEST
WAY
TO
THINK
ABOUT
COMPUTATIONAL
COMPLEXITY
IS
THAT
IT
IS
ABOUT
SEARCH
PROBLEMS
THE
TWO
MOST
IMPORTANT
CLASSES
OF
SEARCH
PROBLEMS
ARE
P
AND
NP
THE
COMPLEXITY
CLASS
NP
NP
STANDS
FOR
NON
DETERMINISTIC
POLYNOMIAL
IT
IS
A
CLASS
OF
PROBLEMS
THAT
ARE
AT
THE
CORE
OF
COMPLEXITY
THEORY
THE
CLASSICAL
DEFINITION
IS
IN
TERMS
OF
YES
NO
PROBLEMS
HERE
WE
ARE
CONCERNED
WITH
THE
SEARCH
PROBLEM
FORM
OF
THE
DEFINITION
DEFINITION
COMPLEXITY
CLASS
NP
THE
CLASS
OF
ALL
SEARCH
PROBLEMS
A
SEARCH
PROBLEM
A
IS
A
BINARY
PREDICATE
A
X
Y
THAT
IS
EFFICIENTLY
IN
POLYNOMIAL
TIME
COMPUTABLE
AND
BALANCED
THE
LENGTH
OF
X
AND
Y
DO
NOT
DIFFER
EXPONENTIALLY
INTUITIVELY
X
IS
AN
INSTANCE
OF
THE
PROBLEM
AND
Y
IS
A
SOLUTION
THE
SEARCH
PROBLEM
FOR
A
IS
THIS
GIVEN
X
FIND
Y
SUCH
THAT
A
X
Y
OR
IF
NO
SUCH
Y
EXISTS
SAY
NO
THE
CLASS
OF
ALL
SEARCH
PROBLEMS
IS
CALLED
NP
EXAMPLES
OF
NP
PROBLEMS
INCLUDE
THE
FOLLOWING
TWO
SAT
SAT

X
GIVEN
A
BOOLEAN
FORMULA

IN
CONJUNCTIVE
NORMAL
FORM
CNF
FIND
A
TRUTH
ASSIGNMENT
X
WHICH
SATISFIES

OR
SAY
NO
IF
NONE
EXISTS
NASH
NASH
G
X
Y
GIVEN
A
GAME
G
FIND
MIXED
STRATEGIES
X
Y
SUCH
THAT
X
Y
IS
A
NASH
EQUILIBRIUM
OF
G
OR
SAY
NO
IF
NONE
EXISTS
NASH
IS
IN
NP
SINCE
FOR
A
GIVEN
SET
OF
MIXED
STRATEGIES
ONE
CAN
ALWAYS
EFFICIENTLY
CHECK
IF
THE
CONDITIONS
OF
A
NASH
EQUILIBRIUM
HOLD
OR
NOT
NOTE
HOWEVER
THAT
A
BIG
DIFFERENCE
BETWEEN
SAT
AND
NASH
IS
THAT
WE
KNOW
THAT
THE
LATTER
ALWAYS
HAS
A
SOLUTION
BY
NASH
THEOREM
COMPLETENESS
AND
REDUCTION
SAT
IS
ACTUALLY
NP
COMPLETE
WHICH
INFORMALLY
MEANS
THAT
IT
IS
A
THE
HARDEST
SEARCH
PROBLEM
THE
CONCEPT
OF
REDUCTION
MAKES
THIS
NOTION
PRECISE
AND
HELPS
US
TO
SEE
THE
RELATIONS
OF
DIFFERENT
PROBLEMS
IN
TERMS
OF
COMPLEXITY
DEFINITION
REDUCTION
WE
SAY
PROBLEM
A
REDUCES
TO
PROBLEM
B
IF
THERE
EXIST
TWO
FUNCTIONS
F
AND
G
MAPPING
STRINGS
TO
STRINGS
SUCH
THAT
F
AND
G
ARE
EFFICIENTLY
COMPUTABLE
FUNCTIONS
I
E
IN
POLYNOMIAL
TIME
IN
THE
LENGTH
OF
THE
INPUT
STRING
IF
X
IS
AN
INSTANCE
OF
A
THEN
F
X
IS
AN
INSTANCE
OF
B
SUCH
THAT
X
IS
A
NO
INSTANCE
FOR
PROBLEM
A
IF
AND
ONLY
IF
F
X
IS
A
NO
INSTANCE
FOR
PROBLEM
B
B
F
X
Y
A
X
G
Y
THE
POINT
IS
THAT
WE
INDIRECTLY
SOLVE
PROBLEM
A
BY
REDUCING
IT
TO
PROBLEM
B
WE
TAKE
AN
INSTANCE
OF
A
COMPUTE
F
X
WHICH
WE
FEED
INTO
OUR
ALGORITHM
FOR
PROBLEM
B
AND
FINALLY
WE
TRANSFORM
THE
SOLUTION
FOR
PROBLEM
B
BACK
TO
A
SOLUTION
FOR
PROBLEM
A
USING
FUNCTION
G
THUS
IF
A
REDUCES
TO
B
THEN
B
IS
AT
LEAST
AS
HARD
AS
A
DEFINITION
NP
COMPLETENESS
A
PROBLEM
IN
NP
IS
NP
COMPLETE
IF
ALL
PROBLEMS
IN
NP
REDUCE
TO
IT
IT
CAN
BE
SHOWN
THAT
SAT
IS
NP
COMPLETE
HOWEVER
NOBODY
BELIEVES
THAT
NASH
IS
NP
COMPLETE
THE
REASON
FOR
THIS
IS
THAT
NASH
ALWAYS
HAS
A
SOLUTION
WHICH
WE
KNOW
FROM
NASH
THEOREM
AND
NP
COMPLETE
PROBLEMS
DRAW
THEIR
HARDNESS
FROM
THE
POSSIBILITY
THAT
A
SOLUTION
MIGHT
NOT
EXIST
FOR
PROBLEMS
THAT
ARE
NP
COMPLETE
THE
YES
INSTANCES
HAVE
CERTIFICATES
SOLUTIONS
VERIFIABLE
IN
POLYNOMIAL
TIME
BUT
THE
NO
INSTANCES
MOST
LIKELY
DO
NOT
IT
IS
VERY
UNLIKELY
THAT
THERE
IS
A
REDUCTION
FROM
SAT
TO
NASH
SINCE
IF
WE
HAVE
AN
INSTANCE
OF
SAT
WHICH
IS
UNSATISFIABLE
THE
REDUCTION
GIVES
US
AN
INSTANCE
OF
NASH
SUCH
THAT
SOME
SOLUTION
TO
THIS
NASH
INSTANCE
IMPLIES
THAT
THE
SAT
INSTANCE
HAS
NO
SOLUTION
DESPITE
THE
FACT
THAT
NASH
IS
VERY
UNLIKELY
TO
BE
NP
COMPLETE
THERE
ARE
MANY
VARIANTS
OF
NASH
IN
WHICH
THE
EXISTENCE
OBSTACLE
IS
NOT
THERE
THAT
ARE
INDEED
NP
COMPLETE
FOR
EXAMPLE
IF
ONE
SEEKS
A
NASH
EQUILIBRIUM
THAT
MAXIMIZES
THE
SUM
OF
PLAYER
UTILITIES
OR
ONE
THAT
USES
A
GIVEN
STRATEGY
WITH
POSITIVE
PROBABILITY
THEN
THE
PROBLEM
BECOMES
NP
COMPLETE
ANOTHER
VARIANT
IS
GIVEN
A
GAME
AND
A
NASH
EQUILIBRIUM
FIND
ANOTHER
ONE
OR
OUTPUT
NO
IF
NONE
EXIST
HERE
THERE
IS
NO
EXISTENCE
THEOREM
AND
INDEED
WE
HAVE
THE
FOLLOWING
RESULT
LEMMA
IS
NP
COMPLETE
PROOF
TO
PROVE
NP
COMPLETENESS
OF
WE
PROVIDE
A
REDUCTION
FROM
TO
EVERY
INSTANCE
OF
IS
IN
CNF
WITH
THREE
LITERALS
PER
CLAUSE
LET

BE
AN
INSTANCE
OF
CONSISTING
OF
N
LITERALS
N
M
XI
I
AND
M
CLAUSES
CJ
J
WE
THEN
CONSTRUCT
A
TWO
PLAYER
SYMMETRIC
GAME
WHERE
EACH
PLAYER
HAS
M
POSSIBLE
STRATEGIES
TWO
FOR
EACH
LITERAL
DENOTED
BY
XI
N
ONE
FOR
EACH
CLAUSE
DENOTED
BY
CJ
J
AND
ONE
EXTRA
STRATEGY
CALLED
D
FOR
DEFAULT
TO
SPECIFY
THE
GAME
IT
REMAINS
TO
DEFINE
THE
PAYOFFS
WE
START
BY
SPECIFYING
THE
PAYOFFS
WHEN
AT
LEAST
ONE
OF
THE
PLAYERS
PLAYS
D
IF
THEY
BOTH
PLAY
D
THEN
BOTH
OF
THEM
GET
A
PAYOFF
OF
IF
ONE
OF
THEM
PLAYS
D
AND
THE
OTHER
PLAYS
A
CLAUSE
CJ
J
M
THEN
THE
PLAYER
PLAYING
D
GETS
A
PAYOFF
OF
WHILE
THE
OTHER
PLAYER
GETS
IF
ONE
OF
THEM
PLAYS
D
AND
THE
OTHER
PLAYS
A
LITERAL

THEN
BOTH
PLAYERS
GET
A
PAYOFF
OF
CONSEQUENTLY
IT
IS
CLEAR
THAT
D
D
IS
A
PURE
NASH
EQUILIBRIUM
WE
NOW
CONSTRUCT
THE
REST
OF
THE
PAYOFFS
SUCH
THAT
THERE
EXISTS
ANOTHER
NASH
EQUILIBRIUM
IF
AND
ONLY
IF
THERE
EXISTS
A
TRUTH
ASSIGNMENT
X
THAT
SATISFIES
THE
FORMULA

WE
FIRST
DEFINE
TWO
GENERALIZATIONS
OF
THE
WELL
KNOWN
ROCK
PAPER
SCISSORS
GAME
GRPSN
GENERALIZED
ROCK
PAPER
SCISSORS
ON
N
OBJECTS
GIVEN
N
OBJECTS
N
ODD
WE
ARRANGE
THEM
IN
A
CYCLE
WHICH
DEFINES
THE
BEATING
ORDER
EACH
OBJECT
LOSES
TO
ITS
LEFT
NEIGHBOR
AND
BEATS
ITS
RIGHT
NEIGHBOR
WITH
PAYOFFS
AND
FOR
THE
WINNER
AND
LOSER
RESPECTIVELY
PLAYING
ANY
OTHER
PAIR
OF
OBJECTS
RESULTS
IN
A
TIE
GIVING
A
PAYOFF
OF
TO
BOTH
PLAYERS
THERE
IS
ONLY
ONE
MIXED
NASH
EQUILIBRIUM
RANDOMIZING
UNIFORMLY
AMONG
ALL
N
OBJECTS
GIVING
EACH
OF
THEM
A
WEIGHT
OF
N
BWGRPSN
BLACK
AND
WHITE
GENERALIZED
ROCK
PAPER
SCISSORS
ON
N
OBJECTS
WE
NOW
HAVE
TWO
COLORED
VERSIONS
OF
EACH
OBJECT
EACH
ONE
IS
AVAILABLE
IN
BLACK
AND
WHITE
IF
THE
PLAYERS
PLAY
TWO
DIFFERENT
OBJECTS
THEN
THE
PAYOFF
IS
DEFINED
EXACTLY
ACCORDING
TO
GRPSN
DISREGARDING
THE
COLORS
HOWEVER
IF
BOTH
PLAYERS
PLAY
THE
SAME
OBJECT
BUT
WITH
DIFFERENT
COLORS
THEN
BOTH
OF
THEM
GET
EXECUTED
LESS
DRASTICALLY
BOTH
RECEIVE
A
HUGE
NEGATIVE
PAYOFF
FINALLY
IF
BOTH
PLAY
THE
SAME
OBJECT
AND
THE
SAME
COLOR
THEN
THERE
IS
A
TIE
WITH
PAYOFF
SO
IN
ANY
NASH
EQUILIBRIUM
THE
TWO
PLAYERS
FIRST
AGREE
AT
THE
BEGINNING
ON
A
COLORING
FOR
EACH
OBJECT
AND
THEN
RANDOMIZE
UNIFORMLY
AMONG
ALL
N
OBJECTS
WITH
THIS
SPECIFIC
COLORING
NOW
IN
THE
SUBMATRIX
OF
THE
PAYOFF
MATRIX
WHERE
BOTH
PLAYERS
PLAY
A
LITERAL
LET
THE
PAYOFF
MATRIX
BE
GIVEN
BY
BWGRPSN
A
COLOR
ASSIGNMENT
OF
THE
OBJECTS
CORRESPONDS
TO
A
TRUTH
ASSIGNMENT
OF
THE
LITERALS
BUT
AT
THE
END
LET
US
GIVE
EACH
PLAYER
A
PAYOFF
OF
THIS
CAN
BE
DONE
BY
SHIFTING
THE
PAYOFFS
OF
THE
GAME
FROM
TO
IF
THE
PAYOFF
MATRIX
WERE
JUST
THIS
SUBMATRIX
THEN
A
NASH
EQUILIBRIUM
WOULD
CORRESPOND
TO
A
TRUTH
ASSIGNMENT
AND
BOTH
PLAYERS
RANDOMIZING
UNIFORMLY
WITH
WEIGHT
N
AMONG
THESE
LITERALS
THE
AVERAGE
PAYOFF
FOR
BOTH
PLAYERS
WOULD
BE
IF
BOTH
PLAYERS
PLAY
A
CLAUSE
THEN
LET
THEM
BOTH
RECEIVE
A
PAYOFF
OF
FINALLY
LET
US
DEFINE
THE
PAYOFFS
WHEN
ONE
PLAYER
PLAYS
A
LITERAL
AND
THE
OTHER
PLAYS
A
CLAUSE
WE
DEFINE
THE
PAYOFFS
SYMMETRICALLY
SO
LET
US
ASSUME
THAT
PLAYER
PLAYS
LITERAL

AND
PLAYER
PLAYS
CLAUSE
CJ
THE
PAYOFFS
ARE
N
IF

CJ
I
E
IF

FALSIFIES
CJ
AND
OTHERWISE
SINCE
EACH
LITERAL
IS
PLAYED
WITH
WEIGHT
N
BY
PLAYER
IF
PLAYED
AT
ALL
PLAYER
RECEIVES
AN
EXTRA
AVERAGE
PAYOFF
OF
N
FOR
EACH
LITERAL
THAT
FALSIFIES
THE
CLAUSE
SO
IF
ALL
LITERALS
ARE
FALSIFIED
IN
A
GIVEN
CLAUSE
THEN
PLAYER
GETS
AN
AVERAGE
PAYOFF
OF
PLAYING
THIS
CLAUSE
WHICH
IS
MORE
THAN
WHAT
HE
SHE
GETS
BY
PLAYING
A
LITERAL
CONSEQUENTLY
IF
THE
TRUTH
ASSIGNMENT
CHOSEN
BY
THE
PLAYERS
BEFORE
PLAYING
THE
BWGRPSN
GAME
DOES
NOT
SATISFY
THE
ORIGINAL
BOOLEAN
FORMULA

THEN
RANDOMIZING
UNIFORMLY
ON
LITERALS
OF
THIS
TRUTH
ASSIGNMENT
DOES
NOT
GIVE
A
NASH
EQUILIBRIUM
SINCE
PLAYER
HAS
AN
INCENTIVE
TO
PLAY
A
CLAUSE
HOWEVER
IF
THE
CHOSEN
TRUTH
ASSIGNMENT
DOES
SATISFY

THEN
NEITHER
PLAYER
HAS
AN
INCENTIVE
TO
DEVIATE
AND
WE
HAVE
A
MIXED
NASH
EQUILIBRIUM
WHICH
IMMEDIATELY
GIVES
US
A
TRUTH
ASSIGNMENT
SATISFYING
OUR
FORMULA

NOTE
THAT
EVERY
NASH
EQUILIBRIUM
OTHER
THAN
THE
PURE
EQUILIBRIUM
D
D
MUST
HAVE
ITS
SUPPORT
IN
THE
SUBMATRIX
OF
THE
PAYOFF
MATRIX
WHERE
BOTH
PLAYERS
PLAY
A
LITERAL
SINCE
IF
E
G
PLAYER
PLAYS
A
CLAUSE
OR
D
THEN
PLAYER
HAS
AN
INCENTIVE
TO
PLAY
D
IN
WHICH
CASE
PLAYER
HAS
AN
INCENTIVE
TO
PLAY
D
THUS
LEADING
US
TO
THE
PURE
EQUILIBRIA
D
D
SO
WE
HAVE
SHOWN
THAT
THIS
GAME
HAS
A
SECOND
NASH
EQUILIBRIUM
OTHER
THAN
D
D
IF
AND
ONLY
IF

IS
SATISFIABLE
MOREOVER
IF
THERE
EXISTS
A
SECOND
NASH
EQUILIBRIUM
AND
WE
CAN
FIND
IT
THEN
WE
IMMEDIATELY
HAVE
A
TRUTH
ASSIGNMENT
SATISFYING
OUR
FORMULA

WE
NOTE
THAT
THIS
PROOF
CAN
BE
MODIFIED
TO
PROVE
THE
NP
COMPLETENESS
OF
OTHER
VARIANTS
OF
NASH
DOES
THE
GAME
HAVE
AT
LEAST
NASH
EQUILIBRIA
DOES
IT
HAVE
ONE
IN
WHICH
THE
PAYOFFS
ARE
THE
SAME
DOES
IT
HAVE
ONE
IN
WHICH
THE
SUM
OF
THE
PAYOFFS
IS
MORE
THAN
HOW
MANY
NASH
EQUILIBRIA
ARE
THERE
THIS
LAST
ONE
IS
P
COMPLETE
AND
SO
ON
TFNP
A
SUBCLASS
OF
NP
DUE
TO
THE
FACT
THAT
NASH
ALWAYS
HAS
A
SOLUTION
WE
ARE
INTERESTED
MORE
GENERALLY
IN
THE
CLASS
OF
SEARCH
PROBLEMS
FOR
WHICH
EVERY
INSTANCE
HAS
A
SOLUTION
WE
CALL
THIS
CLASS
TFNP
WHICH
STANDS
FOR
TOTAL
FUNCTION
NON
DETERMINISTIC
POLYNOMIAL
CLEARLY
NASH
TFNP
NP
IS
NASH
TFNP
COMPLETE
PROBABLY
NOT
BECAUSE
TFNP
PROBABLY
HAS
NO
COMPLETE
PROBLEMS
INTUITIVELY
BECAUSE
THE
CLASS
NEEDS
TO
BE
DIFINED
ON
A
MORE
SOLID
BASIS
THAN
AN
UNCHECKABLE
UNIVERSAL
STATEMENT
SUCH
AS
EVERY
INSTANCE
HAS
A
SOLUTION
HOWEVER
IT
IS
POSSIBLE
TO
DEFINE
SUBCLASSES
OF
TFNP
WHICH
DO
HAVE
COMPLETE
PROBLEMS
NOTICE
THAT
FOR
EVERY
PROBLEM
IN
TFNP
THERE
IS
A
CORRESPONDING
THEOREM
THAT
PROVES
THAT
EVERY
INSTANCE
OF
THE
PROBLEM
HAS
A
SOLUTION
THE
IDEA
SUBDIVIDE
TFNP
ACCORDING
TO
THE
METHOD
OF
PROOF
WE
CAN
DISTINGUISH
SEVERAL
CLASSES
BASED
ON
THE
PROOF
FIRST
OF
ALL
IF
THE
PROOF
IS
CONSTRUCTIVE
AND
CAN
BE
IMPLEMENTED
IN
POLYNOMIAL
TIME
THEN
THE
PROBLEM
LIES
IN
P
THE
EMPIRICAL
OBSERVATION
IS
THAT
FOR
EVERY
PROBLEM
THAT
LIES
IN
TFNP
BUT
HAS
NOT
BEEN
PROVEN
TO
LIE
IN
P
THE
PROOF
OF
EXISTENCE
OF
A
SOLUTION
USES
SOME
SIMPLE
COMBINATORIAL
LEMMA
THAT
IS
EXPONENTIALLY
NONCONSTRUCTIVE
THERE
ARE
ESSENTIALLY
FOUR
SUCH
KNOWN
ARGUMENTS
IF
A
GRAPH
HAS
AN
ODD
DEGREE
NODE
THEN
IT
HAS
ANOTHER
ONE
THIS
IS
THE
PARITY
ARGUMENT
WHICH
GIVES
RISE
TO
THE
CLASS
PPA
POLYNOMIAL
PARITY
ARGUMENT
IF
A
DIRECTED
GRAPH
HAS
AN
UNBALANCED
NODE
A
VERTEX
WITH
DIFFERENT
IN
DEGREE
AND
OUT
DEGREE
THEN
IT
HAS
ANOTHER
ONE
THIS
IS
THE
PARITY
ARGUMENT
FOR
DIRECTED
GRAPHS
WHICH
GIVES
RISE
TO
THE
CLASS
PPAD
WHICH
IS
OUR
MAIN
FOCUS
AS
WE
WILL
SEE
SHORTLY
EVERY
DIRECTED
ACYCLIC
GRAPH
HAS
A
SINK
THIS
GIVES
RISE
TO
THE
CLASS
PLS
POLYNOMIAL
LOCAL
SEARCH
ANY
FUNCTION
MAPPING
N
ELEMENTS
TO
N
ELEMENTS
HAS
AT
LEAST
ONE
COLLISION
THIS
IS
THE
PIGEONHOLE
PRINCIPLE
WHICH
GIVES
RISE
TO
THE
CLASS
PPP
A
REMARK
ON
HOW
THESE
CLASSES
RELATE
TO
EACH
OTHER
ALL
OF
THESE
FOUR
CLASSES
CONTAIN
P
ARE
CONTAINED
IN
TFNP
AND
FURTHERMORE
PPAD
IS
CONTAINED
IN
BOTH
PPA
AND
PPP
THE
QUESTION
REMAINS
HOW
CAN
WE
ACTUALLY
DEFINE
THESE
CLASSES
IN
THE
NEXT
SECTION
WE
FOCUS
SPECIFICALLY
ON
THE
PPAD
CLASS
NASH
IS
PPAD
COMPLETE
WE
CONCENTRATE
ON
THE
CLASS
PPAD
BECAUSE
OF
THE
FOLLOWING
MAIN
THEOREM
THEOREM
NASH
IS
PPAD
COMPLETE
THE
REST
OF
THIS
SECTION
IS
ORGANIZED
AS
FOLLOWS
FIRST
WE
DEFINE
THE
PPAD
CLASS
AND
ALSO
WHAT
IT
MEANS
TO
BE
PPAD
COMPLETE
AND
THEN
WE
SHOW
THAT
NASH
IS
INDEED
PPAD
COMPLETE
FINALLY
WE
CONCLUDE
THE
SECTION
WITH
SOME
PHILOSOPHICAL
REMARKS
THE
CLASS
PPAD
INFORMALLY
PPAD
IS
THE
CLASS
OF
ALL
SEARCH
PROBLEMS
WHICH
ALWAYS
HAVE
A
SOLUTION
AND
WHOSE
PROOF
IS
BASED
ON
THE
PARITY
ARGUMENT
FOR
DIRECTED
GRAPHS
TO
FORMULATE
THIS
IN
A
PRECISE
WAY
WE
FIRST
DEFINE
THE
SEARCH
PROBLEM
END
OF
THE
LINE
THE
SETUP
IS
THE
FOLLOWING
WE
ARE
GIVEN
A
GRAPH
G
WHERE
THE
IN
DEGREE
AND
THE
OUT
DEGREE
OF
EACH
NODE
IS
AT
MOST
I
E
THERE
ARE
FOUR
KINDS
OF
NODES
SOURCES
SINKS
MIDNODES
AND
ISOLATED
VERTICES
IT
TURNS
OUT
SUCH
GRAPHS
CAPTURE
THE
FULL
POWER
OF
THE
ARGUMENT
OUR
GRAPH
G
IS
EXPONENTIAL
IN
SIZE
SINCE
OTHERWISE
WE
WOULD
BE
ABLE
TO
EXPLORE
THE
STRUCTURE
OF
THE
GRAPH
IN
PARTICULAR
WE
CAN
IDENTIFY
SOURCES
AND
SINKS
EFFICIENTLY
TO
BE
SPECIFIC
SUPPOSE
G
HAS
VERTICES
ONE
FOR
EVERY
BIT
STRING
OF
LENGTH
N
HOW
DO
WE
SPECIFY
THIS
GRAPH
SINCE
THE
GRAPH
IS
EXPONENTIAL
IN
SIZE
WE
CANNOT
LIST
ALL
EDGES
INSTEAD
THE
EDGES
OF
G
WILL
BE
REPRESENTED
BY
TWO
BOOLEAN
CIRCUITS
OF
SIZE
POLYNOMIAL
IN
N
EACH
WITH
N
INPUT
BITS
AND
N
OUTPUT
BITS
THE
CIRCUITS
ARE
DENOTED
P
AND
FOR
POTENTIAL
PREDECESSOR
AND
POTENTIAL
SUCCESSOR
THERE
IS
A
DIRECTED
EDGE
FROM
VERTEX
U
TO
VERTEX
V
IF
AND
ONLY
IF
V
U
AND
U
P
V
I
E
GIVEN
INPUT
U
OUTPUTS
V
AND
VICE
VERSA
GIVEN
INPUT
V
P
OUTPUTS
U
ALSO
WE
ASSUME
THAT
THE
SPECIFIC
VECTOR
HAS
NO
PREDECESSOR
THE
CIRCUIT
P
IS
SO
WIRED
THAT
P
THE
SEARCH
PROBLEM
END
OF
THE
LINE
IS
THE
FOLLOWING
GIVEN
P
FIND
A
SINK
OR
ANOTHER
SOURCE
CLEARLY
END
OF
THE
LINE
NP
SINCE
IT
IS
EASY
TO
CHECK
IF
A
GIVEN
NODE
IS
A
SOURCE
OR
A
SINK
MOREOVER
END
OF
THE
LINE
IS
A
TOTAL
PROBLEM
I
E
IT
ALWAYS
HAS
A
SOLUTION
SO
END
OF
THE
LINE
TFNP
WE
ARE
NOW
READY
TO
DEFINE
THE
CLASS
PPAD
DEFINITION
THE
CLASS
PPAD
THE
CLASS
PPAD
CONTAINS
ALL
SEARCH
PROBLEMS
IN
TFNP
THAT
REDUCE
TO
END
OF
THE
LINE
NOTE
THAT
THE
PHRASE
IN
TFNP
IS
UNNECESSARY
IN
THE
DEFINITION
SINCE
EVERY
PROBLEM
IN
NP
THAT
REDUCES
TO
END
OF
THE
LINE
IS
IN
TFNP
BECAUSE
REDUCING
MEANS
THAT
THIS
ARGUMENT
CAN
PROVE
EXISTENCE
FOR
YOU
NASH
PPAD
OUR
FIRST
TASK
IS
TO
SHOW
THAT
NASH
IS
IN
PPAD
I
E
THAT
NASH
REDUCES
TO
END
OF
THE
LINE
BUT
WE
HAD
DONE
JUST
THIS
IN
THE
LAST
LECTURE
WHEN
WE
PROVED
NASH
THEOREM
WE
SHOWED
THAT
NASH
THEOREM
IS
IMPLIED
BY
BROUWER
THEOREM
WHICH
IN
TURN
IS
IMPLIED
BY
SPERNER
LEMMA
WHICH
FOLLOWS
FROM
THE
PARITY
ARGUMENT
FOR
DIRECTED
GRAPHS
CONSEQUENTLY
IF
WE
DEFINE
THE
SEARCH
PROBLEMS
BROUWER
AND
SPERNER
NATURALLY
THEN
NASH
REDUCES
TO
BROUWER
WHICH
REDUCES
TO
SPERNER
WHICH
REDUCES
TO
END
OF
THE
LINE
NASH
IS
PPAD
COMPLETE
WE
NOW
SHOW
THAT
NASH
IS
IN
FACT
PPAD
COMPLETE
I
E
THAT
END
OF
THE
LINE
REDUCES
TO
NASH
WE
DO
THIS
VIA
A
SERIES
OF
REDUCTIONS
WE
FIRST
REDUCE
END
OF
THE
LINE
TO
A
DIMENSIONAL
DISCRETE
VARIANT
OF
BROUWER
THEN
REDUCE
THIS
TO
NASH
FOR
SEPARABLE
NETWORK
GAMES
NASH
FOR
SNG
AND
FINALLY
REDUCE
THIS
TO
NASH
FOR
TWO
PLAYER
GAMES
PICTORIALLY
END
OF
THE
LINE
DISCRETE
BROUWER
NASH
FOR
SNG
NASH
FOR
TWO
PLAYER
GAMES
WE
NOW
SKETCH
THESE
REDUCTIONS
SIMILARLY
TO
FOR
COMPLETE
PROOFS
WE
REFER
TO
BROUWER
IS
PPAD
COMPLETE
WE
NOW
GIVE
THE
MAIN
IDEA
OF
REDUCING
END
OF
THE
LINE
TO
A
DIMENSIONAL
DISCRETE
VERSION
OF
BROUWER
WE
ARE
GIVEN
AN
INSTANCE
OF
END
OF
THE
LINE
I
E
A
PAIR
OF
CIRCUITS
P
THAT
DEFINE
THE
GRAPH
G
ON
VERTICES
OUR
GOAL
IS
TO
ENCODE
THIS
GRAPH
IN
TERMS
OF
A
CONTINUOUS
EASY
TO
COMPUTE
BROUWER
FUNCTION
F
THE
DOMAIN
OF
F
WILL
BE
THE
DIMENSIONAL
UNIT
CUBE
AND
THE
BEHAVIOR
OF
F
WILL
BE
DEFINED
IN
TERMS
OF
ITS
BEHAVIOR
ON
A
VERY
FINE
RECTILINEAR
MESH
OF
GRID
POINTS
IN
THE
CUBE
EACH
GRID
POINT
LIES
AT
THE
CENTER
OF
A
TINY
CUBELET
AND
AWAY
FROM
THESE
GRID
POINTS
THE
BEHAVIOR
OF
F
IS
DETERMINED
BY
INTERPOLATION
EACH
GRID
POINT
X
RECEIVES
ONE
OF
COLORS
THAT
REPRESENT
THE
VALUE
OF
THE
DIMENSIONAL
DISPLACEMENT
VECTORS
F
X
X
OR
OUR
TASK
IS
TO
FIND
A
PANCHROMATIC
CUBELET
AND
THAT
WOULD
BE
CLOSE
TO
A
FIXPOINT
WE
ARE
NOW
READY
TO
ENCODE
OUR
GRAPH
G
INTO
SUCH
A
BROUWER
FUNCTION
F
WE
REPRESENT
EVERY
VERTEX
U
AS
TWO
SMALL
SEGMENTS
ON
TWO
EDGES
OF
THE
CUBE
WHOSE
ENDPOINTS
ARE
DENOTED
BY
AND
RESPECTIVELY
SEE
FIGURE
IF
G
HAS
AN
EDGE
FROM
VERTEX
U
TO
VERTEX
V
THEN
WE
CAN
CREATE
A
LONG
PATH
IN
THE
DIMENSIONAL
UNIT
CUBE
GOING
FROM
TO
THEN
TO
AND
AND
FINALLY
TO
AND
AS
INDICATED
IN
FIGURE
WE
CAN
CHOOSE
THE
RECTILINEAR
MESH
FINE
ENOUGH
SO
THAT
THESE
LINES
DO
NOT
CROSS
OR
COME
CLOSE
TO
EACH
OTHER
NOW
THE
COLORING
IS
DONE
IN
SUCH
A
WAY
THAT
MOST
GRID
POINTS
GET
COLOR
BUT
FOR
EVERY
EDGE
FROM
VERTEX
U
TO
VERTEX
V
IN
G
THE
CORRESPONDING
LONG
PATH
IN
THE
UNIT
CUBE
CONNECTS
GRID
POINTS
THAT
GET
COLORS
AND
MOREOVER
THERE
IS
A
CIRCUIT
F
THAT
COMPUTES
THE
DISPLACEMENT
COLOR
OF
EACH
CENTER
OF
A
CUBELET
BASED
ONLY
OF
THE
LOCATION
OF
THE
CUBELET
F
LOOKS
AT
THE
LOCATION
AND
DETERMINES
MAKING
CALLS
TO
CIRCUITS
AND
P
WHETHER
THE
CUBLET
LIES
ON
THE
PATH
AND
IF
SO
IN
WHICH
DIRECTION
DOES
THE
PATH
TRAVERSE
IT
AND
IF
THIS
IS
THE
CASE
IT
OUTPUTS
THE
CORRECT
COLOR
AMONG
OTHERWISE
AND
IF
THE
CUBELET
DOES
NOT
LIE
ON
ONE
OF
THE
THREE
FACES
ADJACENT
TO
THE
ORIGIN
THEN
ITS
COLOR
DISPLACEMENT
IS
IMPORTANTLY
ALL
COLORS
ARE
ADJACENT
TO
EACH
OTHER
GIVING
AN
APPROXIMATE
FIXED
POINT
ONLY
AT
SITES
THAT
CORRESPOND
TO
AN
END
OF
THE
LINE
OF
G
FROM
BROUWER
TO
NASH
WE
NOW
SKETCH
HOW
TO
REDUCE
BROUWER
TO
NASH
WE
HAVE
TO
SIMULATE
THE
BROUWER
FUNCTION
WITH
A
GAME
THE
PPAD
COMPLETE
CLASS
OF
BROUWER
FUNCTIONS
THAT
APPEAR
ABOVE
HAVE
THE
PROPERTY
THAT
THEIR
FUNCTION
F
CAN
BE
EFFICIENTLY
COMPUTED
USING
ARITHMETIC
CIRCUITS
THAT
ARE
BUILT
UP
FROM
STANDARD
OPERATORS
SUCH
AS
ADDITION
MULTIPLICATION
AND
COMPARISON
THE
CIRCUITS
CAN
BE
WRITTEN
DOWN
AS
A
DATA
FLOW
GRAPH
WITH
ONE
OF
THESE
OPERATORS
AT
EVERY
NODE
THE
KEY
IS
TO
SIMULATE
EACH
STANDARD
OPERATOR
WITH
A
GAME
AND
THEN
COMPOSE
THESE
GAMES
ACCORDING
TO
THE
DATA
FLOW
GRAPH
SO
THAT
THE
AGGREGATE
GAME
SIMULATES
THE
BROUWER
FUNCTION
AND
A
NASH
EQUILIBRIUM
OF
THE
GAME
CORRESPONDS
TO
A
N
APPROXIMATE
FIXED
POINT
OF
THE
BROUWER
FUNCTION
WE
NOW
DEMONSTRATE
HOW
TO
SIMULATE
ADDITION
WITH
A
GAME
CONSIDER
THE
GRAPH
IN
FIGURE
WHICH
SHOWS
WHICH
PLAYERS
AFFECT
OTHER
PLAYERS
PAYOFFS
EACH
OF
THE
FOUR
PLAYERS
WILL
HAVE
TWO
POSSIBLE
STRATEGIES
AND
THE
PAYOFFS
ARE
DEFINED
AS
FOLLOWS
IF
W
PLAYS
STRATEGY
I
E
PLAYS
TO
THE
LEFT
DENOTED
BY
L
THEN
THE
PAYOFF
MATRIX
FOR
W
BASED
ON
WHAT
PLAYERS
X
AND
Y
PLAY
IS
GIVEN
BY
IF
W
PLAYS
STRATEGY
I
E
PLAYS
TO
THE
RIGHT
DENOTED
BY
R
THEN
W
GETS
A
PAYOFF
OF
IF
Z
PLAYS
L
AND
A
PAYOFF
OF
IF
Z
PLAYS
R
PLAYER
Z
GETS
A
PAYOFF
OF
IF
HE
PLAYS
L
AND
ALSO
W
PLAYS
L
OTHERWISE
HE
GETS
A
PAYOFF
OF
Z
WANTS
W
TO
LOOK
THE
OTHER
WAY
IN
THIS
GAME
THE
MIXED
STRATEGY
OF
EVERY
PLAYER
IS
JUST
A
NUMBER
AS
WELL
X
IS
THE
PROBABILITY
THAT
PLAYER
X
PLAYS
STRATEGY
Y
IS
THE
PROBABILITY
THAT
PLAYER
Y
PLAYS
STRATEGY
ETC
IT
TURNS
OUT
THAT
IN
NASH
EQUILIBRIUM
WE
HAVE
Z
MIN
X
Y
WHICH
MEANS
THAT
WE
CAN
DO
ARITHMETIC
WE
CAN
SIMULATE
OTHER
STANDARD
OPERATORS
SUCH
AS
SUBTRACTION
MULTIPLICATION
AND
COMPARISON
VIA
SIMILAR
GAMES
THEN
WE
CAN
PUT
THESE
BASIC
GAMES
TOGETHER
INTO
A
BIG
GAME
WHERE
ANY
NASH
EQUILIBRIUM
CORRESPONDS
FIGURE
EMBEDDING
THE
END
OF
THE
LINE
GRAPH
IN
A
CUBE
FIGURE
FROM
FIGURE
THE
FOUR
PLAYERS
OF
THE
ADDITION
GAME
AND
THE
GRAPH
SHOWING
WHICH
PLAYERS
AFFECT
OTHER
PLAYERS
PAYOFFS
FIGURE
FROM
TO
A
FIXED
POINT
OF
THE
BROUWER
FUNCTION
HOWEVER
THERE
IS
ONE
CATCH
OUR
COMPARISON
SIMULATOR
IS
BRITTLE
IN
THE
SENSE
THAT
IT
CAN
ONLY
DEAL
WITH
STRICT
INEQUALITY
IF
THE
INPUTS
ARE
EQUAL
THEN
IT
OUTPUTS
ANYTHING
THIS
IS
A
PROBLEM
BECAUSE
OUR
COMPUTATION
OF
F
IS
NOW
FAULTY
ON
INPUTS
THAT
CAUSE
THE
CIRCUIT
TO
MAKE
A
COMPARISON
OF
EQUAL
VALUES
WE
CAN
OVERCOME
THIS
PROBLEM
BY
COMPUTING
THE
BROUWER
FUNCTION
AT
A
GRID
OF
MANY
POINTS
NEAR
THE
POINT
OF
INTEREST
AND
AVERAGING
THE
RESULTS
THIS
MAKES
THE
COMPUTATION
OF
F
ROBUST
BUT
INTRODUCES
A
SMALL
ERROR
IN
THE
COMPUTATION
OF
F
SO
IN
FACT
ANY
NASH
EQUILIBRIUM
WE
FIND
CORRESPONDS
TO
AN
APPROXIMATE
FIXED
POINT
OF
THE
BROUWER
FUNCTION
SO
FAR
WE
HAVE
SHOWN
THAT
THE
NASH
EQUILIBRIUM
PROBLEM
FOR
NETWORK
GAMES
IS
PPAD
COMPLETE
WE
NOW
SHOW
THAT
IT
IS
POSSIBLE
TO
SIMULATE
THIS
GAME
WITH
A
TWO
PLAYER
GAME
AS
FOLLOWS
WE
COLOR
THE
PLAYERS
THE
VERTICES
OF
THE
GRAPH
BY
TWO
COLORS
RED
AND
BLUE
SO
THAT
NO
TWO
PLAYERS
WHO
PLAY
TOGETHER
HAVE
THE
SAME
COLOR
THIS
CAN
BE
DONE
BECAUSE
THE
LITTLE
ARITHMETIC
GAMES
THAT
COMPOSE
THE
GRAPH
HAVE
THIS
STRUCTURE
INPUT
OUTPUT
NODES
WHO
PLAY
AGAINST
INTERNAL
NODES
AND
NOT
BETWEEN
THEM
ASSUME
THAT
THERE
ARE
N
RED
AND
N
BLUE
PLAYERS
WE
MAY
ADD
A
FEW
PLAYERS
WHO
DO
NOTHING
AND
N
IS
ODD
HOW
CAN
WE
SIMULATE
THIS
GAME
WITH
TWO
PLAYERS
THE
IDEA
IS
TO
HAVE
TWO
LAWYERS
RED
AND
BLUE
WHO
CORRESPOND
TO
THE
RED
AND
BLUE
PLAYERS
THEIR
CLIENTS
THE
LAWYERS
TASK
IS
TO
THEN
DEAL
WITH
THE
DISPUTES
DESCRIBED
BY
GAMES
BETWEEN
PEOPLE
FROM
THE
TWO
SIDES
SINCE
ONLY
PLAYERS
WITH
DIFFERENT
COLORS
HAVE
DISPUTES
THE
LAWYERS
CAN
DEAL
WITH
THE
DISPUTES
AMONGST
THEMSELVES
SINCE
ALL
CLIENTS
HAVE
POSSIBLE
ACTIONS
THE
LAWYERS
HAVE
POSSIBLE
ACTIONS
WE
JUST
NEED
TO
DEFINE
THE
UTILITIES
WE
DEFINE
THEM
IN
THE
NATURAL
WAY
E
G
UR
IF
PLAYERS
AND
PLAY
A
GAME
AND
OTHERWISE
THE
ONLY
PROBLEM
IS
THAT
WE
HAVE
TO
CONVINCE
THE
LAWYERS
TO
BE
FAIR
TO
DEVOTE
EQUAL
AMOUNT
OF
TIME
PROBABILITY
MASS
THAT
IS
TO
EACH
CLIENT
I
E
TO
PLAY
EVERY
GAME
WITH
PROBABILITY
N
TO
DO
THIS
WE
HAVE
THE
LAWYERS
PLAY
ON
THE
SIDE
A
HIGH
STAKES
GRPSN
GAME
ON
THE
SIDE
MEANS
THAT
THE
HUGE
PAYOFFS
OF
THE
NEW
GAME
ARE
ADDED
TO
THE
PAYOFFS
OF
THE
ORIGINAL
LAWYERS
GAME
DEPENDING
ON
WHICH
CLIENT
EACH
LAWYER
CHOOSES
THAT
IS
THE
OBJECTS
ARE
THE
IDENTITIES
OF
THE
CLIENTS
THIS
ALLOWS
US
TO
MAKE
THE
LAWYERS
ARBITRARILY
CLOSE
TO
FAIR
THIS
IS
MADE
PRECISE
IN
THE
FOLLOWING
LEMMA
LEMMA
IF
X
Y
IS
AN
EQUILIBRIUM
IN
THE
LAWYERS
GAME
FROM
ABOVE
THEN
XRI
XRI
N
M
I
N
WHERE
M
IS
THE
PAYOFF
OF
THE
HIGH
STAKES
GRPSN
AND
UMAX
IS
THE
LARGEST
IN
ABSOLUTE
VALUE
PAYOFF
IN
THE
ORIGINAL
GAME
SO
BY
MAKING
M
LARGE
ENOUGH
WE
CAN
FORCE
THE
LAWYERS
TO
BE
AS
FAIR
AS
WE
WANT
THEREFORE
IF
WE
CAN
SOLVE
THE
LAWYERS
GAME
EXACTLY
THEN
WE
CAN
GET
AN
APPROXIMATE
EQUILIBRIUM
IN
THE
ORIGINAL
GAME
NOTE
THAT
WE
NEED
SOME
KIND
OF
RELAXATION
LIKE
THIS
IN
THE
REDUCTION
SINCE
FOR
TWO
PLAYER
GAMES
WE
KNOW
E
G
FROM
THE
LEMKE
HOWSON
ALGORITHM
THAT
ANY
NASH
EQUILIBRIUM
IS
RATIONAL
I
E
HAS
RATIONAL
PROBABILITIES
IN
THE
MIXED
STRATEGIES
BUT
FOR
MORE
PLAYERS
WE
CAN
HAVE
IRRATIONAL
NUMBERS
IN
A
MIXED
STRATEGY
OF
A
NASH
EQUILIBRIUM
PHILOSOPHICAL
REMARKS
TO
CUT
A
LONG
STORY
SHORT
IN
THIS
SECTION
WE
HAVE
SHOWN
THAT
NASH
IS
INTRACTABLE
IN
THE
REFINED
SENSE
DEFINED
ABOVE
WHAT
DOES
THIS
SAY
ABOUT
NASH
EQUILIBRIUM
AS
A
CONCEPT
OF
PREDICTIVE
BEHAVIOR
NASH
THEOREM
IS
IMPORTANT
BECAUSE
IT
IS
A
UNIVERSALITY
RESULT
ALL
GAMES
HAVE
A
NASH
EQUILIBRIUM
IN
THIS
SENSE
IT
IS
A
CREDIBLE
FORM
OF
PREDICTION
HOWEVER
IF
FINDING
THIS
NASH
EQUILIBRIUM
IS
INTRACTABLE
I
E
THERE
EXIST
SOME
SPECIALIZED
INSTANCES
WHEN
ONE
CANNOT
FIND
IT
IN
ANY
REASONABLE
AMOUNT
OF
TIME
THEN
IT
LOSES
UNIVERSALITY
AND
THEREFORE
LOSES
CREDIBILITY
AS
A
PREDICTOR
OF
BEHAVIOR
APPROXIMATE
NASH
EQUILIBRIA
IF
FINDING
A
NASH
EQUILIBRIUM
IS
INTRACTABLE
IT
MAKES
SENSE
TO
ASK
IF
ONE
CAN
FIND
AN
APPROXIMATE
NASH
EQUILIBRIUM
AND
WHAT
ARE
THE
LIMITS
TO
THIS
AN
APPROXIMATE
NASH
EQUILIBRIUM
INFORMALLY
MEANS
THAT
EVERY
PLAYER
HAS
A
LOW
INCENTIVE
TO
DEVIATE
MORE
FORMALLY
AN

NASH
EQUILIBRIUM
IS
A
PROFILE
OF
MIXED
STRATEGIES
WHERE
ANY
PLAYER
CAN
IMPROVE
HIS
EXPECTED
PAYOFF
BY
AT
MOST

BY
SWITCHING
TO
ANOTHER
STRATEGY
THE
WORK
OF
SEVERAL
RESEARCHERS
HAS
NOW
RULED
OUT
A
FULLY
POLYNOMIAL
TIME
APPROXIMATION
SCHEME
FOR
COMPUTING
APPROXIMATE
NASH
EQUILIBRIA
THE
MAIN
OPEN
QUESTION
IS
WHETHER
THERE
EXISTS
A
POLYNOMIAL
TIME
APPROXIMATION
SCHEME
PTAS
FOR
COMPUTING
APPROXIMATE
NASH
EQUILIBRIA
WE
NOW
PRESENT
A
SUB
EXPONENTIAL
THOUGH
SUPER
POLYNOMIAL
ALGORITHM
TO
COMPUTE
AN
APPROXIMATE
NASH
EQUILIBRIUM
FOR
TWO
PLAYERS
WHICH
IS
DUE
TO
LIPTON
MARKAKIS
AND
MEHTA
THE
ALGORITHM
ALSO
WORKS
FOR
GAMES
WITH
A
CONSTANT
NUMBER
OF
PLAYERS
THEIR
IDEA
IS
THE
FOLLOWING
SUPPOSE
YOU
ACTUALLY
KNEW
A
NASH
EQUILIBRIUM
AND
WERE
ABLE
TO
SAMPLE
FROM
IT
PLAYING
T
GAMES
THE
SAMPLE
STRATEGIES
FOR
THE
TWO
PLAYERS
ARE
XT
AND
YT
RESPECTIVELY
THESE
SAMPLES
ARE
UNIT
VECTORS
REPRESENTING
THE
STRATEGIES
FROM
THESE
T
SAMPLES
WE
CAN
THEN
FORM
MIXED
STRATEGIES
FOR
THE
TWO
PLAYERS
BY
AVERAGING
THE
SAMPLES
X
T
XT
Y
T
YT
THE
FOLLOWING
LEMMA
THEN
TELLS
US
THAT
THE
SET
OF
MIXED
STRATEGIES
X
Y
IS
CLOSE
TO
A
NASH
EQUILIBRIUM
LEMMA
LET
T
LOG
N
AND
DEFINE
X
AND
Y
AS
ABOVE
THEN
X
Y
IS
AN

APPROXIMATE
NASH
EQUILIBRIUM
WITH
HIGH
PROBABILITY
THE
FORM
OF
T
IN
THE
LEMMA
FOLLOWS
FROM
THE
CHERNOFF
BOUND
HOWEVER
THERE
IS
A
CATCH
TO
THIS
PROCEDURE
THIS
DOES
NOT
TELL
US
HOW
TO
FIND
THIS
APPROXIMATE
NASH
EQUILIBRIUM
SINCE
WE
ARE
NOT
ABLE
TO
SAMPLE
FROM
THE
NASH
EQUILIBRIUM
IN
THAT
CASE
WE
WOULD
ALREADY
BE
DONE
THE
SOLUTION
TO
THIS
PROBLEM
IS
BASED
ON
THE
OBSERVATION
THAT
ANY
SUCH
PAIR
OF
MIXED
STRATEGIES
CONSISTS
OF
VECTORS
WHERE
THE
ENTRIES
HAVE
DENOMINATORS
EQUAL
TO
T
SO
WE
CAN
SIMPLY
GO
THROUGH
ALL
POSSIBLE
VECTORS
WITH
DENOMINATORS
EQUAL
TO
T
AND
WE
WILL
FIND
AN

NASH
EQUILIBRIUM
THIS
GIVES
US
AN
O
NLOG
N
ALGORITHM
FOR
FINDING
AN

NASH
EQUILIBRIUM
FOR
TWO
PLAYERS
MARKET
EQUILIBRIUM
VIA
A
PRIMAL
DUAL
ALGORITHM
FOR
A
CONVEX
PROGRAM
NIKHIL
R
DEVANUR
GEORGIA
INSTITUTE
OF
TECHNOLOGY
CHRISTOS
H
PAPADIMITRIOU
UNIVERSITY
OF
CALIFORNIA
AT
BERKELEY
BERKELEY
CALIFORNIA
AMIN
SABERI
STANFORD
UNIVERSITY
STANFORD
CALIFORNIA
AND
VIJAY
V
VAZIRANI
GEORGIA
INSTITUTE
OF
TECHNOLOGY
ABSTRACT
WE
GIVE
THE
FIRST
POLYNOMIAL
TIME
ALGORITHM
FOR
EXACTLY
COMPUTING
AN
EQUILIBRIUM
FOR
THE
LINEAR
UTILITIES
CASE
OF
THE
MARKET
MODEL
DEFINED
BY
FISHER
OUR
ALGORITHM
USES
THE
PRIMAL
DUAL
PARADIGM
IN
THE
ENHANCED
SETTING
OF
KKT
CONDITIONS
AND
CONVEX
PROGRAMS
WE
PINPOINT
THE
ADDED
DIFFICULTY
RAISED
BY
THIS
SETTING
AND
THE
MANNER
IN
WHICH
OUR
ALGORITHM
CIRCUMVENTS
IT
CATEGORIES
AND
SUBJECT
DESCRIPTORS
F
ANALYSIS
OF
ALGORITHMS
AND
PROBLEM
COMPLEXITY
NONNUMERIC
ALGORITHMS
AND
PROBLEMS
GENERAL
TERMS
ALGORITHMS
ECONOMICS
ADDITIONAL
KEY
WORDS
AND
PHRASES
MARKET
EQUILIBRIA
PRIMAL
DUAL
ALGORITHMS
A
SABERI
WAS
SUPPORTED
BY
NATIONAL
SCIENCE
FOUNDATION
NSF
GRANT
CCF
AND
A
GIFT
FROM
GOOGLE
VAZIRANI
WAS
SUPPORTED
BY
NSF
GRANT
CCF
AUTHORS
ADDRESSES
N
R
DEVANUR
AND
V
V
VAZIRANI
COMPUTER
SCIENCE
SYSTEMS
GEORGIA
IN
STITUTE
OF
TECHNOLOGY
ATLANTA
GA
E
MAIL
VIJAY
VAZIRANI
NIKHIL
CC
GATECH
EDU
C
H
PA
PADIMITRIOU
COMPUTER
SCIENCE
DIVISION
UNIVERSITY
OF
CALIFORNIA
AT
BERKELEY
SODA
HALL
EECS
DEPARTMENT
BERKELEY
CA
E
MAIL
CHRISOTS
CS
BERKELEY
EDU
A
SABERI
TERMAN
ENGINEERING
BUILDING
ROOM
STANFORD
CA
E
MAIL
PERMISSION
TO
MAKE
DIGITAL
OR
HARD
COPIES
OF
PART
OR
ALL
OF
THIS
WORK
FOR
PERSONAL
OR
CLASSROOM
USE
IS
GRANTED
WITHOUT
FEE
PROVIDED
THAT
COPIES
ARE
NOT
MADE
OR
DISTRIBUTED
FOR
PROFIT
OR
DIRECT
COMMERCIAL
ADVANTAGE
AND
THAT
COPIES
SHOW
THIS
NOTICE
ON
THE
FIRST
PAGE
OR
INITIAL
SCREEN
OF
A
DISPLAY
ALONG
WITH
THE
FULL
CITATION
COPYRIGHTS
FOR
COMPONENTS
OF
THIS
WORK
OWNED
BY
OTHERS
THAN
ACM
MUST
BE
HONORED
ABSTRACTING
WITH
CREDIT
IS
PERMITTED
TO
COPY
OTHERWISE
TO
REPUBLISH
TO
POST
ON
SERVERS
TO
REDISTRIBUTE
TO
LISTS
OR
TO
USE
ANY
COMPONENT
OF
THIS
WORK
IN
OTHER
WORKS
REQUIRES
PRIOR
SPECIFIC
PERMISSION
AND
OR
A
FEE
PERMISSIONS
MAY
BE
REQUESTED
FROM
PUBLICATIONS
DEPT
ACM
INC
PENN
PLAZA
SUITE
NEW
YORK
NY
USA
FAX
OR
QC
ACM
DOI
ACM
REFERENCE
FORMAT
DEVANUR
N
R
PAPADIMITRIOU
C
H
SABERI
A
AND
VAZIRANI
V
V
MARKET
EQUILIBRIUM
VIA
A
PRIMAL
DUAL
ALGORITHM
FOR
A
CONVEX
PROGRAM
J
ACM
ARTICLE
OCTOBER
PAGES
DOI
INTRODUCTION
WE
PRESENT
THE
FIRST
POLYNOMIAL
TIME
ALGORITHM
FOR
THE
LINEAR
VERSION
OF
AN
OLD
PROBLEM
DEFINED
IN
BY
IRVING
FISHER
BRAINARD
AND
SCARF
CONSIDER
A
MARKET
CONSISTING
OF
BUYERS
AND
DIVISIBLE
GOODS
THE
MONEY
POSSESSED
BY
BUYERS
AND
THE
AMOUNT
OF
EACH
GOOD
ARE
SPECIFIED
ALSO
SPECIFIED
ARE
UTILITY
FUNCTIONS
OF
BUYERS
WHICH
ARE
ASSUMED
TO
BE
LINEAR
FISHER
ORIGINAL
DEFINITION
ASSUMED
CONCAVE
UTILITY
FUNCTIONS
THE
PROBLEM
IS
TO
COMPUTE
PRICES
FOR
THE
GOODS
SUCH
THAT
EVEN
IF
EACH
BUYER
IS
MADE
OPTIMALLY
HAPPY
RELATIVE
TO
THESE
PRICES
THERE
IS
NO
DEFICIENCY
OR
SURPLUS
OF
ANY
OF
THE
GOODS
THAT
IS
THE
MARKET
CLEARS
FISHER
WORK
WAS
DONE
CONTEMPORARILY
AND
INDEPENDENTLY
OF
WALRAS
PIONEERING
WORK
WALRAS
ON
MODELING
MARKET
EQUILIBRIA
THROUGH
THE
ENSUING
YEARS
THE
STUDY
OF
MARKET
EQUILIBRIA
OCCUPIED
CENTER
STAGE
WITHIN
MATHEMATICAL
ECONOMICS
ITS
CROWNING
ACHIEVEMENT
CAME
WITH
THE
WORK
OF
ARROW
AND
DEBREU
WHICH
ESTABLISHED
THE
EXISTENCE
OF
EQUILIBRIUM
PRICES
IN
A
VERY
GENERAL
SETTING
THROUGH
THE
USE
OF
KAKUTANI
FIXED
POINT
THEOREM
FISHER
AND
ARROW
AND
DEBREU
MARKET
EQUILIBRIUM
MODELS
ARE
CONSIDERED
THE
TWO
MOST
FUNDAMENTAL
MODELS
WITHIN
MATHEMATICAL
ECONOMICS
THE
LATTER
CAN
BE
SEEN
AS
A
GENERALIZATION
OF
THE
FORMER
IT
CONSISTS
OF
AGENTS
WHO
COME
TO
THE
MARKET
WITH
INITIAL
ENDOWMENTS
OF
GOODS
AND
AT
ANY
SET
PRICES
WANT
TO
SELL
ALL
THEIR
GOODS
AND
BUY
OPTIMAL
BUNDLES
AT
THESE
PRICES
THE
PROBLEM
AGAIN
IS
TO
FIND
MARKET
CLEARING
PRICES
PRIOR
ALGORITHMIC
RESULTS
GENERAL
EQUILIBRIUM
THEORY
HAS
LONG
EN
JOYED
THE
STATUS
OF
THE
CROWN
JEWEL
WITHIN
MATHEMATICAL
ECONOMICS
HOWEVER
OTHER
THAN
A
FEW
ISOLATED
RESULTS
IT
IS
ESSENTIALLY
A
NON
ALGORITHMIC
THEORY
AMONG
ITS
AL
GORITHMIC
RESULTS
ARE
SCARF
WORK
ON
APPROXIMATELY
COMPUTING
FIXED
POINTS
SCARF
AND
SOME
VERY
IMPRESSIVE
NONLINEAR
CONVEX
PROGRAMS
THAT
CAPTURE
AS
THEIR
OPTIMAL
SOLUTIONS
EQUILIBRIUM
ALLOCATIONS
FOR
THE
CASE
OF
LINEAR
UTILITY
FUNCTIONS
THE
EISENBERG
GALE
PROGRAM
FOR
FISHER
MODEL
EISENBERG
AND
GALE
AND
THE
NENAKOV
PRIMAK
PROGRAM
NENAKOV
AND
PRIMAK
FOR
THE
ARROW
DEBREU
MODEL
SEE
CODENOTTI
ET
AL
FOR
A
SURVEY
OF
THESE
WORKS
THE
ELLIPSOID
ALGO
RITHM
CAN
BE
USED
TO
FIND
APPROXIMATE
SOLUTIONS
TO
THESE
PROGRAMS
SUBSEQUENT
TO
OUR
WORK
EXACT
ALGORITHMS
FOR
SOLVING
THESE
PROGRAMS
HAVE
ALSO
BEEN
FOUND
SEE
SECTION
WITHIN
THEORETICAL
COMPUTER
SCIENCE
THE
QUESTION
OF
POLYNOMIAL
TIME
SOLVABIL
ITY
OF
EQUILIBRIA
MARKET
EQUILIBRIA
AS
WELL
AS
NASH
EQUILIBRIA
WAS
FIRST
CONSID
ERED
BY
MEGIDDO
AND
PAPADIMITRIOU
SUBSEQUENTLY
A
COMPLEXITY
THEORETIC
FRAMEWORK
FOR
ESTABLISHING
EVIDENCE
OF
INTRACTABILITY
FOR
SUCH
ISSUES
WAS
GIVEN
BY
PAPADIMITRIOU
OUR
WORK
FOLLOWS
DENG
ET
AL
WHO
GAVE
POLYNOMIAL
TIME
ALGORITHMS
FOR
THE
ARROW
DEBREU
MODEL
FOR
THE
CASES
THAT
THE
UTILITY
FUNCTIONS
ARE
LINEAR
AND
EITHER
THE
NUMBER
OF
GOODS
OR
THE
NUMBER
OF
AGENTS
IS
BOUNDED
IN
RETROSPECT
ALL
NECESSARY
INGREDIENTS
FOR
OBTAINING
AN
EXACT
THOUGH
NOT
COMBI
NATORIAL
POLYNOMIAL
TIME
ALGORITHM
FOR
FISHER
LINEAR
CASE
WERE
PRESENT
EVEN
BEFORE
OUR
WORK
THE
FACT
THAT
EQUILIBRIUM
PRICES
AND
ALLOCATIONS
FOR
THIS
CASE
ARE
RATIONAL
NUMBERS
THAT
CAN
BE
EXPRESSED
USING
ONLY
POLYNOMIALLY
MANY
BITS
WHICH
IS
SHOWN
IN
THIS
PAPER
AS
A
CONSEQUENCE
OF
OUR
COMBINATORIAL
ALGORITHM
SEE
LEMMA
CAN
ALSO
BE
SHOWN
DIRECTLY
USING
THE
EISENBERG
GALE
PROGRAM
FOR
A
PROOF
SEE
FOR
EXAMPLE
THEOREM
IN
VAZIRANI
THIS
FACT
TOGETHER
WITH
THE
WORK
OF
NEWMAN
AND
PRIMAK
YIELDS
THE
DESIRED
ALGORITHM
ALGORITHMIC
CONTRIBUTIONS
OF
OUR
WORK
FOR
THE
LINEAR
CASE
OF
FISHER
MODEL
IT
IS
NATURAL
TO
SEEK
AN
ALGORITHMIC
ANSWER
IN
THE
THEORY
OF
LINEAR
PROGRAMMING
HOWEVER
THERE
DOES
NOT
SEEM
TO
BE
ANY
NATURAL
LINEAR
PROGRAMMING
FORMULATION
FOR
THIS
PROBLEM
INSTEAD
A
REMARKABLE
NONLINEAR
CONVEX
PROGRAM
GIVEN
BY
EISENBERG
AND
GALE
CAPTURES
AS
ITS
OPTIMAL
SOLUTIONS
EQUILIBRIUM
ALLOCATIONS
FOR
THIS
CASE
OUR
ALGORITHM
USES
THE
PRIMAL
DUAL
PARADIGM
NOT
IN
ITS
USUAL
SETTING
OF
LP
DUALITY
THEORY
BUT
IN
THE
ENHANCED
SETTING
OF
CONVEX
PROGRAMMING
AND
THE
KARUSH
KUHN
TUCKER
KKT
CONDITIONS
AFTER
INTRODUCING
SOME
DEFINITIONS
AND
NOTATION
IN
SECTION
WE
PINPOINT
IN
SECTION
THE
ADDED
DIFFICULTY
OF
WORKING
IN
THIS
ENHANCED
SETTING
AND
THE
MANNER
IN
WHICH
OUR
ALGORITHM
CIRCUMVENTS
THIS
DIFFICULTY
OUR
ALGORITHM
IS
NOT
STRONGLY
POLYNOMIAL
INDEED
OBTAINING
SUCH
AN
ALGORITHM
IS
AN
IMPORTANT
OPEN
QUESTION
REMAINING
IT
WILL
REQUIRE
A
QUALITATIVELY
DIFFERENT
APPROACH
PERHAPS
ONE
WHICH
SATISFIES
KKT
CONDITIONS
IN
DISCRETE
STEPS
AS
IS
THE
RULE
WITH
ALL
OTHER
PRIMAL
DUAL
ALGORITHMS
KNOWN
TODAY
AS
POINTED
OUT
IN
SECTION
WE
START
BY
SUITABLY
RELAXING
THE
KKT
CONDITIONS
AND
OUR
ALGORITHM
SATISFIES
THESE
CONDITIONS
CONTINUOUSLY
RATHER
THAN
IN
DISCRETE
STEPS
THE
USUAL
ADVANTAGES
OF
COMBINATORIAL
ALGORITHMS
APPLY
TO
OUR
WORK
AS
WELL
NAMELY
SUCH
ALGORITHMS
ARE
EASIER
TO
ADAPT
CERTAINLY
HEURISTICALLY
AND
SOMETIMES
EVEN
FORMALLY
TO
RELATED
PROBLEMS
AND
FINE
TUNED
FOR
USE
IN
SPECIAL
CIRCUMSTANCES
SECTION
OFFERS
SPECIFIC
EXAMPLES
OUR
FIRST
EXPOSITION
DEVANUR
ET
AL
OF
THIS
ALGORITHM
SUFFERED
FROM
A
MAJOR
SHORTCOMING
ALTHOUGH
THE
HIGH
LEVEL
ALGORITHMIC
IDEA
GIVEN
IN
DEVANUR
ET
AL
WAS
THE
SAME
AS
THE
ONE
GIVEN
IN
THE
CURRENT
VERSION
SEE
SECTIONS
AND
THE
EXACT
IMPLEMENTATION
USING
THE
NOTION
OF
PRE
EMPTIVE
FREEZING
CONTAINED
A
SUBTLE
THOUGH
FATAL
FLAW
FIXING
THIS
FLAW
INVOLVED
INTRODUCING
THE
NOTION
OF
BALANCED
FLOWS
A
NONTRIVIAL
IDEA
THAT
IS
LIKELY
TO
FIND
FUTURE
APPLICATIONS
SEE
SECTION
WE
EXPLAIN
BRIEFLY
THE
ROLE
PLAYED
BY
THIS
NEW
NOTION
THE
PRIMAL
VARIABLES
IN
THE
EISENBERG
GALE
PROGRAM
ARE
ALLOCATIONS
TO
BUYERS
AND
THE
DUAL
VARIABLES
ARE
LAGRANGIAN
VARIABLES
CORRESPONDING
TO
THE
PACKING
CONSTRAINTS
OCCURRING
IN
THE
PROGRAM
THESE
ARE
INTERPRETED
AS
PRICES
OF
GOODS
AS
IS
USUAL
IN
PRIMAL
DUAL
ALGO
RITHMS
OUR
ALGORITHM
ALTERNATES
BETWEEN
PRIMAL
AND
DUAL
UPDATE
STEPS
THROUGHOUT
THE
ALGORITHM
THE
PRICES
ARE
SUCH
THAT
BUYERS
HAVE
SURPLUS
MONEY
LEFT
OVER
EACH
UPDATE
ATTEMPTS
TO
DECREASE
THIS
SURPLUS
AND
WHEN
IT
VANISHES
THE
PRICES
ARE
RIGHT
FOR
THE
MARKET
TO
CLEAR
EXACTLY
CLEARLY
THE
NUMBER
OF
UPDATE
STEPS
EXECUTED
NEEDS
TO
BE
BOUNDED
BY
A
POLYNO
MIAL
DEVANUR
ET
AL
ATTEMPTED
TO
DO
THIS
BY
ADJUSTING
THE
HIGH
LEVEL
ALGORITHM
TO
ENSURE
THAT
IN
EACH
ITERATION
THE
DECREASE
IN
THE
TOTAL
SURPLUS
MONEY
IS
AT
LEAST
AN
INVERSE
POLYNOMIAL
FRACTION
OF
THE
TOTAL
HOWEVER
DESPITE
NUMEROUS
ATTEMPTS
NO
IMPLEMENTATION
OF
THIS
IDEA
HAS
YET
BEEN
FOUND
THE
MAIN
NEW
IDEA
IS
TO
MEASURE
PROGRESS
WITH
RESPECT
TO
THE
NORM
OF
THE
VECTOR
OF
SURPLUS
MONEY
OF
BUYERS
RATHER
THAN
THE
NORM
THE
LATTER
OF
COURSE
IS
THE
TOTAL
SURPLUS
MONEY
UNLIKE
THE
NORM
THE
NORM
OF
THE
SURPLUS
VECTOR
DEPENDS
ON
THE
PARTICULAR
ALLOCATION
CHOSEN
THE
SPECIAL
ALLOCATION
WE
CHOOSE
IS
THE
ONE
THAT
MINIMIZES
THE
NORM
OF
THE
SURPLUS
VECTOR
IN
TURN
THIS
ALLOCATION
CORRESPONDS
TO
A
BALANCED
FLOW
IN
THE
NETWORK
N
P
DEFINED
IN
SECTION
THE
FOLLOWING
OBSERVATION
MAY
SHED
ADDITIONAL
LIGHT
THE
SPECIAL
ALLOCATION
MEN
TIONED
ABOVE
AND
THE
NOTION
OF
BALANCED
FLOW
IN
NETWORK
N
P
HAS
AN
ALTERNATIVE
DEFINITION
LET
US
COMPARE
THE
VECTOR
OF
SURPLUS
MONEY
WITH
RESPECT
TO
TWO
ALLO
CATIONS
LEXICOGRAPHICALLY
AFTER
SORTING
THE
VECTORS
IN
DECREASING
ORDER
THE
SPECIAL
ALLOCATION
THAT
MINIMIZES
THE
NORM
OF
THE
SURPLUS
VECTOR
IS
ALSO
THE
ONE
THAT
YIELDS
THE
LEXICOGRAPHICALLY
SMALLEST
SURPLUS
VECTOR
THIS
ALTERNATIVE
DEFINITION
CAN
BE
USED
FOR
STATING
AN
ALGORITHM
THAT
IS
IDENTICAL
TO
OURS
CAN
A
POLYNOMIAL
RUNNING
TIME
BE
ESTABLISHED
FOR
THE
ALGORITHM
USING
THE
ALTERNATIVE
DEFINION
THEREBY
DISPENSING
WITH
NORM
ALTOGETHER
AT
PRESENT
WE
SEE
NO
WAY
OF
DOING
THIS
OUR
PROOF
OF
THE
FACT
THAT
GUARANTEES
PROGRESS
NAMELY
COROLLARY
CRUCIALLY
USES
NORM
ANOTHER
INGREDIENT
FOR
ENSURING
POLYNOMIAL
RUNNING
TIME
IS
NEW
COMBINATORIAL
FACTS
IN
PARAMETRIC
BIPARTITE
NETWORKS
SEE
SECTION
SUBSEQUENT
ALGORITHMIC
DEVELOPMENTS
THE
CONFERENCE
VERSION
OF
THIS
ARTICLE
DEVANUR
ET
AL
SPAWNED
OFF
NEW
ALGORITHMIC
WORK
ALONG
SEVERAL
DIFFERENT
DIRECTIONS
JAIN
ET
AL
DEVANUR
AND
VAZIRANI
USED
THIS
ALGO
RITHM
TO
GIVE
AN
APPROXIMATE
MARKET
CLEARING
ALGORITHM
FOR
THE
LINEAR
CASE
OF
THE
ARROW
DEBREU
MODEL
VAZIRANI
GAVE
THE
NOTION
OF
SPENDING
CONSTRAINT
UTIL
ITY
FUNCTIONS
FOR
FISHER
MODEL
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THE
CASE
OF
STEP
FUNCTIONS
AND
SHOWED
THAT
THESE
UTILITIES
ARE
PARTICULARLY
EXPRESSIVE
IN
GOOGLE
AD
WORDS
MARKET
DEVANUR
AND
VAZIRANI
EXTENDED
SPENDING
CONSTRAINT
UTILITIES
TO
THE
ARROW
DEBREU
MODEL
AND
ESTABLISHED
MANY
NICE
PROPERTIES
OF
THESE
UTILITIES
GARG
AND
KAPOOR
GAVE
SOME
VERY
INTERESTING
APPROXIMATE
EQUILIBRIUM
AL
GORITHMS
FOR
THE
LINEAR
CASE
OF
BOTH
MODELS
USING
AN
AUCTION
BASED
APPROACH
THESE
ALGORITHMS
HAVE
MUCH
BETTER
RUNNING
TIMES
THAN
OURS
ANOTHER
EXCITING
DEVELOPMENT
CAME
FROM
A
SIMPLE
OBSERVATION
IN
KELLY
AND
VAZIRANI
THAT
FISHER
LINEAR
CASE
CAN
BE
VIEWED
AS
A
SPECIAL
CASE
OF
THE
RE
SOURCE
ALLOCATION
FRAMEWORK
GIVEN
BY
KELLY
FOR
MODELING
AND
UNDERSTANDING
TCP
CONGESTION
CONTROL
KELLY
AND
VAZIRANI
OBSERVED
THAT
ALTHOUGH
CONTIN
UOUS
TIME
ALGORITHMS
NOT
HAVING
POLYNOMIAL
RUNNING
TIMES
HAD
BEEN
DEVELOPED
FOR
KELLY
PROBLEM
FINDING
DISCRETE
TIME
ALGORITHMS
WOULD
BE
INTERESTING
JAIN
AND
VAZIRANI
EXPLORED
THIS
ISSUE
BY
DEFINING
THE
CLASS
OF
EISENBERG
GALE
MARKETS
MARKETS
WHOSE
EQUILIBRIUM
ALLOCATIONS
CAN
BE
CAPTURED
VIA
CONVEX
PROGRAMS
HAVING
THE
SAME
FORM
AS
THE
EISENBERG
GALE
PROGRAM
AND
STUDYING
ALGORITHMIC
SOLVABILITY
AND
GAME
THEORETIC
PROPERTIES
OF
THESE
MARKETS
THIS
LINE
OF
WORK
WAS
EXTENDED
FURTHER
IN
CHAKRABARTY
ET
AL
THEY
STUDY
ALGORITHMIC
SOLVABILITY
OF
EISENBERG
GALE
MARKETS
WITH
TWO
AGENTS
THEREBY
POSITIVELY
SETTLING
SOME
OF
THE
OPEN
PROBLEMS
OF
JAIN
AND
VAZIRANI
THE
ABOVE
STATED
WORKS
PROVIDE
COMBINATORIAL
ALGORITHMS
FOR
COMPUTING
EQUI
LIBRIA
AN
ADVANTAGE
OF
THIS
APPROACH
IS
ILLUSTRATED
IN
VAZIRANI
AS
STATED
ABOVE
SOME
OF
THE
BASIC
PROPERTIES
OF
EQUILIBRIA
FOR
LINEAR
FISHER
MARKETS
CAN
BE
EASILY
ESTABLISHED
USING
THE
EISENBERG
GALE
CONVEX
PROGRAM
E
G
SEE
THEOREM
IN
VAZIRANI
INTERESTINGLY
ENOUGH
ALL
THESE
PROPERTIES
ALSO
HOLD
FOR
THE
GENERALIZATION
TO
SPENDING
CONSTRAINT
UTILITY
FUNCTIONS
THEY
ARE
ESTABLISHED
IN
VAZIRANI
VIA
A
GENERALIZATION
OF
OUR
COMBINATORIAL
ALGORITHM
TO
THIS
CASE
AT
PRESENT
WE
DO
NOT
KNOW
OF
A
CONVEX
PROGRAM
THAT
CAPTURES
EQUILIBRIUM
ALLOCATIONS
FOR
THIS
CASE
YET
ANOTHER
APPLICATION
OF
THE
COMBINATORIAL
STRUCTURE
OF
MARKETS
WAS
TO
DETER
MINING
CONTINUITY
PROPERTIES
OF
EQUILIBRIUM
PRICES
AND
ALLOCATIONS
FOR
LINEAR
FISHER
MARKETS
AND
SOME
OF
ITS
GENERALIZATIONS
MEGIDDO
AND
VAZIRANI
VAZIRANI
AND
WANG
THE
PROOFS
IN
MEGIDDO
AND
VAZIRANI
FOR
LINEAR
FISHER
MAR
KETS
ARE
BASED
ON
THE
EISNEBERG
GALE
PROGRAM
HOWEVER
IT
WAS
THE
COMBINATORIAL
STRUCTURE
THAT
MADE
THESE
PROPERTIES
APPARENT
PROGRESS
HAS
ALSO
BEEN
MADE
ON
OBTAINING
CONVEX
PROGRAMS
THAT
CAPTURE
EQUILIBRIA
FOR
VARIOUS
UTILITY
FUNCTIONS
FOR
THE
TWO
FUNDAMENTAL
MARKET
MODELS
SEE
CODENOTTI
ET
AL
AS
WELL
AS
ON
THE
QUESTION
OF
FINDING
EXACT
EQUILIBRIA
BY
SOLVING
CONVEX
PROGRAMS
USING
EITHER
THE
ELLIPSOID
METHOD
JAIN
OR
INTERIOR
POINT
ALGORITHMS
YE
FISHER
LINEAR
CASE
AND
THE
EISENBERG
GALE
CONVEX
PROGRAM
FISHER
LINEAR
CASE
IS
THE
FOLLOWING
CONSIDER
A
MARKET
CONSISTING
OF
A
SET
B
OF
BUYERS
AND
A
SET
A
OF
DIVISIBLE
GOODS
ASSUME
A
N
AND
B
NI
WE
ARE
GIVEN
FOR
EACH
BUYER
I
THE
AMOUNT
EI
OF
MONEY
SHE
POSSESSES
AND
FOR
EACH
GOOD
J
THE
AMOUNT
B
J
OF
THIS
GOOD
IN
ADDITION
WE
ARE
GIVEN
THE
UTILITY
FUNCTIONS
OF
THE
BUYERS
OUR
CRITICAL
ASSUMPTION
IS
THAT
THESE
FUNCTIONS
ARE
LINEAR
LET
UIJ
DENOTE
THE
UTILITY
DERIVED
BY
I
ON
OBTAINING
A
UNIT
AMOUNT
OF
GOOD
J
GIVEN
PRICES
PN
OF
THE
GOODS
IT
IS
EASY
TO
COMPUTE
BASKETS
OF
GOODS
THERE
COULD
BE
MANY
THAT
MAKE
BUYER
I
HAPPIEST
WE
WILL
SAY
THAT
PN
ARE
MARKET
CLEARING
PRICES
IF
AFTER
EACH
BUYER
IS
ASSIGNED
SUCH
A
BASKET
THERE
IS
NO
SURPLUS
OR
DEFICIENCY
OF
ANY
OF
THE
GOODS
OUR
PROBLEM
IS
TO
COMPUTE
SUCH
PRICES
IN
POLYNOMIAL
TIME
FIRST
OBSERVE
THAT
WITHOUT
LOSS
OF
GENERALITY
WE
MAY
ASSUME
THAT
EACH
B
J
IS
UNIT
BY
SCALING
THE
UIJ
APPROPRIATELY
THE
UIJ
AND
EI
ARE
IN
GENERAL
RATIONAL
BY
SCALING
APPROPRIATELY
THEY
MAY
BE
ASSUMED
TO
BE
INTEGRAL
NOW
IT
TURNS
OUT
THAT
THERE
IS
A
MARKET
CLEARING
PRICE
IFF
EACH
GOOD
HAS
A
POTENTIAL
BUYER
ONE
WHO
DERIVES
NONZERO
UTILITY
FROM
THIS
GOOD
MOREOVER
IF
THERE
IS
A
SOLUTION
IT
IS
UNIQUE
GALE
EISENBERG
AND
GALE
WE
ASSUME
THAT
WE
ARE
IN
THE
LATTER
CASE
THE
EISENBERG
GALE
CONVEX
PROGRAM
IS
THE
FOLLOWING
NI
MAXIMIZE
SUBJECT
TO
EI
LOG
UI
I
N
U
X
I
B
NI
XIJ
J
A
WHERE
XIJ
IS
THE
AMOUNT
OF
GOOD
J
ALLOCATED
TO
BUYER
I
THE
PRICE
OF
GOOD
J
IN
THE
EQUILIBRIUM
IS
EQUAL
TO
THE
OPTIMUM
VALUE
OF
THE
LAGRANGEAN
VARIABLE
CORRESPONDING
TO
THE
SECOND
CONSTRAINT
IN
THE
ABOVE
PROGRAM
BY
THE
KKT
CONDITIONS
OPTIMAL
SOLUTIONS
TO
XIJ
AND
P
J
MUST
SATISFY
THE
FOLLOWING
CONDITIONS
J
A
P
J
A
P
J
I
A
XIJ
I
B
J
A
UIJ
J
A
UIJXIJ
P
J
I
B
J
A
XIJ
EI
UIJ
P
J
J
A
UIJXIJ
VIA
THESE
CONDITIONS
IT
IS
EASY
TO
SEE
THAT
AN
OPTIMAL
SOLUTION
TO
THE
EISENBERG
AND
GALE
PROGRAM
GIVES
EQUILIBRIUM
ALLOCATIONS
FOR
FISHER
LINEAR
CASE
AND
THE
CORRESPONDING
DUAL
VARIABLES
GIVE
EQUILIBRIUM
PRICES
OF
GOODS
THE
EISENBERG
AND
GALE
PROGRAM
ALSO
HELPS
PROVE
IN
A
VERY
SIMPLE
MANNER
BASIC
PROPERTIES
OF
THE
SET
OF
EQUILIBRIA
EQUILIBRIUM
EXISTS
UNDER
CERTAIN
CONDITIONS
THE
MILD
CONDITIONS
STATED
ABOVE
THE
SET
OF
EQUILIBRIA
IS
CONVEX
EQUILIBRIUM
UTILITIES
AND
PRICES
ARE
UNIQUE
AND
IF
THE
PROGRAM
HAS
ALL
RATIONAL
ENTRIES
THEN
EQUILIBRIUM
ALLOCATIONS
AND
PRICES
ARE
ALSO
RATIONAL
HIGH
LEVEL
IDEA
OF
THE
ALGORITHM
LET
P
PN
DENOTE
A
VECTOR
OF
PRICES
IF
AT
THESE
PRICES
BUYER
I
IS
GIVEN
GOOD
J
SHE
DERIVES
UIJ
PI
AMOUNT
OF
UTILITY
PER
UNIT
AMOUNT
OF
MONEY
SPENT
CLEARLY
SHE
WILL
BE
HAPPIEST
WITH
GOODS
THAT
MAXIMIZE
THIS
RATIO
DEFINE
HER
BANG
PER
BUCK
TO
BE
I
MAX
J
UIJ
P
J
CLEARLY
FOR
EACH
I
B
J
A
I
UIJ
P
J
IF
THERE
ARE
SEVERAL
GOODS
MAXIMIZING
THIS
RATIO
SHE
IS
EQUALLY
HAPPY
WITH
ANY
COMBINATION
OF
THESE
GOODS
THIS
MOTIVATES
DEFINING
THE
FOLLOWING
BIPARTITE
GRAPH
G
ITS
BIPARTITION
IS
A
B
AND
FOR
I
B
J
A
I
J
IS
AN
EDGE
IN
G
IFF
I
UIJ
P
J
WE
WILL
CALL
THIS
GRAPH
THE
EQUALITY
SUBGRAPH
AND
ITS
EDGES
THE
EQUALITY
EDGES
ANY
GOODS
SOLD
ALONG
THE
EDGES
OF
THE
EQUALITY
SUBGRAPH
WILL
MAKE
BUYERS
HAPPIEST
RELATIVE
TO
THE
CURRENT
PRICES
COMPUTING
THE
LARGEST
AMOUNT
OF
GOODS
THAT
CAN
BE
SOLD
IN
THIS
MANNER
WITHOUT
EXCEEDING
THE
BUDGETS
OF
BUYERS
OR
THE
AMOUNT
OF
GOODS
AVAILABLE
ASSUMED
UNIT
FOR
EACH
GOOD
CAN
BE
ACCOMPLISHED
BY
COMPUTING
MAX
FLOW
IN
THE
FOLLOWING
NETWORK
DIRECT
EDGES
OF
G
FROM
A
TO
B
AND
ASSIGN
A
CAPACITY
OF
INFINITY
TO
ALL
THESE
EDGES
INTRODUCE
SOURCE
VERTEX
AND
A
DIRECTED
EDGE
FROM
TO
EACH
VERTEX
J
A
WITH
A
CAPACITY
OF
P
J
INTRODUCE
SINK
VERTEX
T
AND
A
DIRECTED
EDGE
FROM
EACH
VERTEX
I
B
TO
T
WITH
A
CAPACITY
OF
EI
THE
NETWORK
IS
CLEARLY
A
FUNCTION
OF
THE
CURRENT
PRICES
P
AND
WILL
BE
DENOTED
N
P
THE
ALGORITHM
MAINTAINS
THE
FOLLOWING
THROUGHOUT
INVARIANT
THE
PRICES
P
ARE
SUCH
THAT
A
B
T
IS
A
MIN
CUT
IN
N
P
THE
INVARIANT
ENSURES
THAT
AT
CURRENT
PRICES
ALL
GOODS
CAN
BE
SOLD
THE
ONLY
EVEN
TUALITY
IS
THAT
BUYERS
MAY
BE
LEFT
WITH
SURPLUS
MONEY
THE
ALGORITHM
RAISES
PRICES
SYSTEMATICALLY
ALWAYS
MAINTAINING
THE
INVARIANT
SO
THAT
SURPLUS
MONEY
WITH
BUYERS
KEEPS
DECREASING
WHEN
THE
SURPLUS
VANISHES
MARKET
CLEARING
PRICES
HAVE
BEEN
AT
TAINED
THIS
IS
EQUIVALENT
TO
THE
CONDITION
THAT
A
B
T
IS
ALSO
A
MIN
CUT
IN
N
P
THAT
IS
MAX
FLOW
IN
N
P
EQUALS
THE
TOTAL
AMOUNT
OF
MONEY
POSSESSED
BY
THE
BUYERS
REMARK
WITH
THIS
SETUP
WE
CAN
DEFINE
OUR
MARKET
EQUILIBRIUM
PROBLEM
AS
AN
OPTIMIZATION
PROBLEM
FIND
PRICES
P
UNDER
WHICH
NETWORK
N
P
SUPPORTS
MAXIMUM
FLOW
THE
ENHANCED
SETTING
AND
HOW
TO
DEAL
WITH
IT
WE
WILL
USE
THE
NOTATION
SET
UP
IN
THE
PREVIOUS
SECTION
TO
PINPOINT
THE
DIFFICULTIES
INVOLVED
IN
SOLVING
THE
EISENBERG
GALE
PROGRAM
COMBINATORIALLY
AND
THE
MANNER
IN
WHICH
THESE
DIFFICULTIES
ARE
CIRCUMVENTED
AS
IS
WELL
KNOWN
THE
PRIMAL
DUAL
SCHEMA
HAS
YIELDED
COMBINATORIAL
ALGORITHMS
FOR
OBTAINING
EITHER
OPTIMAL
OR
NEAR
OPTIMAL
INTEGRAL
SOLUTIONS
TO
NUMEROUS
LINEAR
PROGRAMMING
RELAXATIONS
OTHER
THAN
ONE
EXCEPTION
NAMELY
EDMONDS
ALGORITHM
FOR
MAXIMUM
WEIGHT
MATCHING
IN
GENERAL
GRAPHS
EDMONDS
ALL
OTHER
ALGO
RITHMS
RAISE
DUAL
VARIABLES
VIA
A
GREEDY
PROCESS
THE
DISADVANTAGE
OF
A
GREEDY
DUAL
GROWTH
PROCESS
IS
OBVIOUS
THE
FACT
THAT
A
RAISED
DUAL
IS
BAD
IN
THE
SENSE
THAT
IT
OBSTRUCTS
OTHER
DUALS
THAT
COULD
HAVE
LED
TO
A
LARGER
OVERALL
DUAL
SOLUTION
MAY
BECOME
CLEAR
ONLY
LATER
IN
THE
RUN
OF
THE
ALGORITHM
IN
VIEW
OF
THIS
THE
ISSUE
OF
USING
MORE
SOPHISTICATED
DUAL
GROWTH
PROCESSES
HAS
RECEIVED
A
LOT
OF
ATTENTION
ESPECIALLY
IN
THE
CONTEXT
OF
APPROXIMATION
ALGORITHMS
INDEED
EDMONDS
ALGORITHM
IS
ABLE
TO
FIND
AN
OPTIMAL
DUAL
FOR
MATCHING
BY
A
PROCESS
THAT
INCREASES
AND
DECREASES
DUALS
THE
PROBLEM
WITH
SUCH
A
PROCESS
IS
THAT
IT
WILL
MAKE
PRIMAL
OBJECTS
GO
TIGHT
AND
LOOSE
AND
THE
NUMBER
OF
SUCH
REVERSALS
WILL
HAVE
TO
BE
UPPER
BOUNDED
IN
THE
RUNNING
TIME
ANALYSIS
THE
IMPECCABLE
COMBINATORIAL
STRUCTURE
OF
MATCHING
SUPPORTS
SUCH
AN
ACCOUNTING
AND
IN
FACT
THIS
LEADS
TO
A
STRONGLY
POLYNOMIAL
ALGORITHM
HOWEVER
THUS
FAR
ALL
ATTEMPTS
AT
MAKING
SUCH
A
SCHEME
WORK
OUT
FOR
OTHER
PROBLEMS
HAVE
FAILED
THE
FUNDAMENTAL
DIFFERENCE
BETWEEN
COMPLIMENTARY
SLACKNESS
CONDITIONS
FOR
LINEAR
PROGRAMS
AND
KKT
CONDITIONS
FOR
NONLINEAR
CONVEX
PROGRAMS
IS
THAT
WHEREAS
THE
FORMER
DO
NOT
INVOLVE
BOTH
PRIMAL
AND
DUAL
VARIABLES
SIMULTANEOUSLY
IN
AN
EQUALITY
CONSTRAINT
OBTAINED
BY
ASSUMING
THAT
ONE
OF
THE
VARIABLES
TAKES
A
NON
ZERO
VALUE
THE
LATTER
DO
NOW
OUR
DUAL
GROWTH
PROCESS
IS
GREEDY
PRICES
OF
GOODS
ARE
NEVER
DECREASED
YET
BECAUSE
OF
THE
MORE
COMPLEX
NATURE
OF
KKT
CONDITIONS
EDGES
IN
THE
EQUALITY
SUBGRAPH
APPEAR
AND
DISAPPEAR
AS
THE
ALGORITHM
PROCEEDS
HENCE
WE
ARE
FORCED
TO
CARRY
OUT
THE
DIFFICULT
ACCOUNTING
PROCESS
ALLUDED
TO
ABOVE
FOR
BOUNDING
THE
RUNNING
TIME
WE
NEXT
POINT
OUT
WHICH
KKT
CONDITIONS
OUR
ALGORITHM
ENFORCES
AND
WHICH
ONES
IT
RELAXES
AS
WELL
AS
THE
EXACT
MECHANISM
BY
WHICH
IT
SATISFIES
THE
LATTER
THROUGHOUT
OUR
ALGORITHM
WE
ENFORCE
THE
FIRST
TWO
CONDITIONS
LISTED
IN
SECTION
AS
MENTIONED
IN
SECTION
AT
ANY
POINT
IN
THE
ALGORITHM
VIA
A
MAX
FLOW
IN
THE
NETWORK
N
P
ALL
GOODS
CAN
BE
SOLD
HOWEVER
BUYERS
MAY
HAVE
SURPLUS
MONEY
LEFT
OVER
WITH
RESPECT
TO
A
BALANCED
FLOW
IN
NETWORK
N
P
SEE
SECTION
FOR
A
DEFINITION
OF
SUCH
A
FLOW
LET
MI
BE
THE
MONEY
SPENT
BY
BUYER
I
THUS
BUYER
I
SURPLUS
MONEY
IS
I
EI
MI
WE
WILL
RELAX
THE
THIRD
AND
FOURTH
KKT
CONDITIONS
TO
THE
FOLLOWING
I
B
J
A
UIJ
J
A
UIJXIJ
P
J
I
B
J
A
XIJ
MI
UIJ
P
J
J
A
UIJXIJ
WE
CONSIDER
THE
FOLLOWING
POTENTIAL
FUNCTION
CT
AND
WE
GIVE
A
PROCESS
BY
WHICH
THIS
POTENTIAL
FUNCTION
DECREASES
BY
AN
INVERSE
POLYNOMIAL
FRACTION
IN
POLYNOMIAL
TIME
IN
EACH
PHASE
AS
DETAILED
IN
LEMMA
WHEN
CT
DROPS
ALL
THE
WAY
TO
ZERO
ALL
KKT
CONDITIONS
ARE
EXACTLY
SATISFIED
THERE
IS
A
MARKED
DIFFERENCE
BETWEEN
THE
WAY
WE
SATISFY
KKT
CONDITIONS
AND
THE
WAY
PRIMAL
DUAL
ALGORITHMS
FOR
LP
DO
THE
LATTER
SATISFY
COMPLIMENTARY
CONDITIONS
IN
DISCRETE
STEPS
THAT
IS
IN
EACH
ITERATION
THE
ALGORITHM
SATISFIES
AT
LEAST
ONE
NEW
CONDITION
SO
IF
EACH
ITERATION
CAN
BE
IMPLEMENTED
IN
STRONGLY
POLYNOMIAL
TIME
THE
ENTIRE
ALGORITHM
HAS
A
SIMILAR
RUNNING
TIME
ON
THE
OTHER
HAND
WE
SATISFY
KKT
CONDITIONS
CONTINUOUSLY
AS
THE
ALGORITHM
PROCEEDS
THE
KKT
CONDITIONS
CORRESPONDING
TO
EACH
BUYER
GET
SATISFIED
TO
A
GREATER
EXTENT
NEXT
LET
US
CONSIDER
THE
SPECIAL
CASE
OF
FISHER
MARKET
IN
WHICH
ALL
UIJ
ARE
THERE
IS
NO
KNOWN
LP
THAT
CAPTURES
EQUILIBRIUM
ALLOCATIONS
IN
THIS
CASE
AS
WELL
AND
THE
ONLY
RECOURSE
SEEMS
TO
BE
THE
SPECIAL
CASE
OF
THE
EISENBERG
GALE
PROGRAM
IN
WHICH
ALL
UIJ
ARE
RESTRICTED
TO
ALTHOUGH
THIS
IS
A
NONLINEAR
CONVEX
PROGRAM
IT
IS
EASY
TO
DERIVE
A
STRONGLY
POLYNOMIAL
COMBINATORIAL
ALGORITHM
FOR
SOLVING
IT
OF
COURSE
IN
THIS
CASE
AS
WELL
THE
KKT
CONDITIONS
INVOLVE
BOTH
PRIMAL
AND
DUAL
VARIABLES
SIMULTANEOUSLY
HOWEVER
THE
SETTING
IS
SO
EASY
THAT
THIS
DIFFICULTY
NEVER
MANIFESTS
ITSELF
THE
ALGORITHM
SATISFIES
KKT
CONDITIONS
IN
DISCRETE
STEPS
MUCH
THE
SAME
WAY
THAT
A
PRIMAL
DUAL
ALGORITHM
FOR
SOLVING
AN
LP
DOES
IN
RETROSPECT
MEGIDDO
AND
PERHAPS
OTHER
PAPERS
IN
THE
PAST
HAVE
IMPLIC
ITLY
GIVEN
STRONGLY
POLYNOMIAL
PRIMAL
DUAL
ALGORITHMS
FOR
SOLVING
NONLINEAR
CONVEX
PROGRAMS
SOME
VERY
RECENT
PAPERS
HAVE
ALSO
ALSO
DONE
SO
EXPLICITLY
FOR
EXAMPLE
JAIN
AND
VAZIRANI
HOWEVER
THE
PROBLEMS
CONSIDERED
IN
THESE
PAPERS
ARE
SO
SIMPLE
E
G
MULTICOMMODITY
FLOW
IN
WHICH
THERE
IS
ONLY
ONE
SOURCE
THAT
THE
ENHANCED
DIFFICULTY
OF
SATISFYING
KKT
CONDITIONS
IS
MITIGATED
AND
THE
PRIMAL
DUAL
ALGORITHMS
ARE
NOT
MUCH
DIFFERENT
THAN
THOSE
FOR
SOLVING
LP
A
SIMPLE
ALGORITHM
IN
THIS
SECTION
WE
GIVE
A
SIMPLE
ALGORITHM
WITHOUT
THE
USE
OF
BALANCED
FLOWS
ALTHOUGH
WE
DO
NOT
KNOW
HOW
TO
ESTABLISH
POLYNOMIAL
RUNNING
TIME
FOR
IT
IT
STILL
PROVIDES
VALUABLE
INSIGHTS
INTO
THE
PROBLEM
AND
SHOWS
CLEARLY
EXACTLY
WHERE
THE
IDEA
OF
BALANCED
FLOWS
FITS
IN
WE
PICK
UP
THE
EXPOSITION
FROM
THE
END
OF
SECTION
HOW
DO
WE
PICK
PRICES
SO
THE
INVARIANT
HOLDS
AT
THE
START
OF
THE
ALGORITHM
THE
FOLLOWING
TWO
CONDITIONS
GUARANTEE
THIS
THE
INITIAL
PRICES
ARE
LOW
ENOUGH
PRICES
THAT
EACH
BUYER
CAN
AFFORD
ALL
THE
GOODS
FIXING
PRICES
AT
N
SUFFICES
SINCE
THE
GOODS
TOGETHER
COST
ONE
UNIT
AND
ALL
EI
ARE
INTEGRAL
EACH
GOOD
J
HAS
AN
INTERESTED
BUYER
HAS
AN
EDGE
INCIDENT
AT
IT
IN
THE
EQUALITY
SUBGRAPH
COMPUTE
I
FOR
EACH
BUYER
I
AT
THE
PRICES
FIXED
IN
THE
PREVIOUS
STEP
AND
COMPUTE
THE
EQUALITY
SUBGRAPH
IF
GOOD
J
HAS
NO
EDGE
INCIDENT
REDUCE
ITS
PRICE
TO
P
MAX
UIJ
L
THE
ITERATIVE
IMPROVEMENT
STEPS
FOLLOW
THE
SPIRIT
OF
THE
PRIMAL
DUAL
SCHEMA
THE
PRIMAL
VARIABLES
ARE
THE
FLOWS
IN
THE
EDGES
OF
N
P
AND
THE
DUAL
VARIABLES
ARE
THE
CURRENT
PRICES
THE
CURRENT
FLOW
SUGGESTS
HOW
TO
IMPROVE
THE
PRICES
AND
VICE
VERSA
FOR
B
DEFINE
ITS
MONEY
M
P
I
B
EI
WITH
RESPECT
TO
PRICES
P
FOR
SET
P
FOR
A
DEFINE
ITS
NEIGHBORHOOD
IN
N
P
F
J
B
I
WITH
I
J
G
BY
THE
ASSUMPTION
THAT
EACH
GOOD
HAS
A
POTENTIAL
BUYER
F
A
B
THE
INVARIANT
CAN
NOW
BE
MORE
CLEARLY
STATED
LEMMA
FOR
GIVEN
PRICES
P
NETWORK
N
P
SATISFIES
THE
INVARIANT
IFF
A
M
M
F
PROOF
THE
FORWARD
DIRECTION
IS
TRIVIAL
SINCE
UNDER
MAX
FLOW
OF
VALUE
M
A
EVERY
SET
A
MUST
BE
SENDING
M
AMOUNT
OF
FLOW
TO
ITS
NEIGHBORHOOD
LET
PROVE
THE
REVERSE
DIRECTION
ASSUME
T
IS
A
MIN
CUT
IN
P
WITH
A
AND
B
THE
CAPACITY
OF
THIS
CUT
IS
M
M
NOW
F
SINCE
OTHERWISE
THE
CUT
WILL
HAVE
INFINITE
CAPACITY
MOVING
AND
F
TO
THE
T
SIDE
ALSO
RESULTS
IN
A
CUT
BY
THE
CONDITION
STATED
IN
THE
LEMMA
THE
CAPACITY
OF
THIS
CUT
IS
NO
LARGER
THAN
THE
PREVIOUS
ONE
THEREFORE
THIS
IS
ALSO
A
MIN
CUT
IN
N
P
HENCE
THE
INVARIANT
HOLDS
IF
THE
INVARIANT
HOLDS
IT
IS
EASY
TO
SEE
THAT
THERE
IS
A
UNIQUE
MAXIMAL
SET
A
SUCH
THAT
M
M
F
SAY
THAT
THIS
IS
THE
TIGHT
SET
WITH
RESPECT
TO
PRICES
P
CLEARLY
THE
PRICES
OF
GOODS
IN
THE
TIGHT
SET
CANNOT
BE
INCREASED
WITHOUT
VIOLATING
THE
INVARIANT
HENCE
OUR
ALGORITHM
ONLY
RAISES
PRICES
OF
GOODS
IN
THE
ACTIVE
SUBGRAPH
CONSISTING
OF
THE
BIPARTITION
A
B
F
WE
WILL
SAY
THAT
THE
ALGORITHM
FREEZES
THE
SUBGRAPH
F
OBSERVE
THAT
IN
GENERAL
THE
BIPARTITE
GRAPH
F
MAY
CONSIST
OF
SEVERAL
CONNECTED
COMPONENTS
WITH
RESPECT
TO
EQUALITY
EDGES
LET
THESE
BE
SK
TK
CLEARLY
AS
SOON
AS
PRICES
OF
GOODS
IN
A
ARE
RAISED
EDGES
I
J
WITH
I
F
AND
J
A
WILL
NOT
REMAIN
IN
THE
EQUALITY
SUBGRAPH
ANYMORE
WE
WILL
ASSUME
THAT
THESE
EDGES
ARE
DROPPED
BEFORE
PROCEEDING
FURTHER
WE
MUST
BE
SURE
THAT
THESE
CHANGES
DO
NOT
VIOLATE
THE
INVARIANT
THIS
FOLLOWS
FROM
LEMMA
IF
THE
INVARIANT
HOLDS
AND
A
IS
THE
TIGHT
SET
THEN
EACH
GOOD
J
A
HAS
AN
EDGE
IN
THE
EQUALITY
SUBGRAPH
TO
SOME
BUYER
I
B
F
PROOF
SINCE
THE
INVARIANT
HOLDS
J
A
MUST
HAVE
AN
EQUALITY
GRAPH
EDGE
INCIDENT
AT
IT
IF
ALL
SUCH
EDGES
ARE
INCIDENTS
AT
BUYERS
IN
F
THEN
F
J
F
AND
THEREFORE
M
J
M
M
F
M
F
J
THIS
CONTRADICTS
THE
FACT
THAT
THE
INVARIANT
HOLDS
WE
WOULD
LIKE
TO
RAISE
PRICES
OF
GOODS
IN
THE
ACTIVE
SUBGRAPH
IN
SUCH
A
WAY
THAT
THE
EQUALITY
EDGES
IN
IT
ARE
RETAINED
THIS
IS
ENSURED
BY
MULTIPLYING
PRICES
OF
ALL
THESE
GOODS
BY
X
AND
GRADUALLY
INCREASING
X
STARTING
WITH
X
TO
SEE
THAT
THIS
HAS
THE
DESIRED
EFFECT
OBSERVE
THAT
I
J
AND
I
L
ARE
BOTH
EQUALITY
EDGES
IFF
P
J
PL
UIJ
UIL
THE
ALGORITHM
RAISES
X
STARTING
WITH
X
UNTIL
ONE
OF
THE
FOLLOWING
HAPPENS
EVENT
A
SET
R
GOES
TIGHT
IN
THE
ACTIVE
SUBGRAPH
EVENT
AN
EDGE
I
J
WITH
I
B
F
AND
J
BECOMES
AN
EQUALITY
EDGE
OBSERVE
THAT
AS
PRICES
OF
GOODS
IN
A
ARE
INCREASING
GOODS
IN
ARE
BECOMING
MORE
AND
MORE
DESIRABLE
TO
BUYERS
IN
B
F
WHICH
IS
THE
REASON
FOR
THIS
EVENT
IF
EVENT
HAPPENS
WE
REDEFINE
THE
ACTIVE
SUBGRAPH
TO
BE
A
R
B
F
R
AND
PROCEED
WITH
THE
NEXT
ITERATION
SUPPOSE
EVENT
HAPPENS
AND
THAT
J
SL
BECAUSE
OF
THE
NEW
EQUALITY
EDGE
I
J
F
SL
TL
I
THEREFORE
SL
IS
NOT
TIGHT
ANYMORE
HENCE
WE
MOVE
SL
TL
INTO
THE
ACTIVE
SUBGRAPH
TO
COMPLETE
THE
ALGORITHM
WE
SIMPLY
NEED
TO
COMPUTE
THE
SMALLEST
VALUES
OF
X
AT
WHICH
EVENT
AND
EVENT
HAPPEN
AND
CONSIDER
ONLY
THE
SMALLER
OF
THESE
FOR
EVENT
THIS
IS
STRAIGHTFORWARD
BELOW
WE
GIVE
AN
ALGORITHM
FOR
EVENT
FINDING
TIGHT
SETS
LET
P
DENOTE
THE
CURRENT
PRICE
VECTOR
I
E
AT
X
WE
FIRST
PRESENT
A
LEMMA
THAT
DESCRIBES
HOW
THE
MIN
CUT
CHANGES
IN
N
X
P
AS
X
INCREASES
THROUGHOUT
THIS
SECTION
WE
WILL
USE
THE
FUNCTION
M
TO
DENOTE
MONEY
WITH
RESPECT
TO
PRICES
P
WITHOUT
LOSS
OF
GENERALITY
ASSUME
THAT
WITH
RESPECT
TO
PRICES
P
THE
TIGHT
SET
IN
G
IS
EMPTY
SINCE
WE
CAN
ALWAYS
RESTRICT
ATTENTION
TO
THE
ACTIVE
SUBGRAPH
FOR
THE
PURPOSES
OF
FINDING
THE
NEXT
TIGHT
SET
DEFINE
X
MIN
A
M
F
M
THE
VALUE
OF
X
AT
WHICH
A
NONEMPTY
SET
GOES
TIGHT
LET
DENOTE
THE
TIGHT
SET
AT
PRICES
X
P
IF
T
IS
A
CUT
IN
THE
NETWORK
WE
WILL
ASSUME
THAT
A
AND
B
LEMMA
WITH
RESPECT
TO
PRICES
X
P
IF
X
X
THEN
A
B
T
IS
A
MIN
CUT
IF
X
X
THEN
A
B
T
IS
NOT
A
MIN
CUT
MOREOVER
IF
T
IS
A
MIN
CUT
IN
N
X
P
THEN
PROOF
SUPPOSE
X
X
BY
DEFINITION
OF
X
A
X
M
M
F
THEREFORE
BY
LEMMA
WITH
RESPECT
TO
PRICES
X
P
THE
INVARIANT
HOLDS
HENCE
A
B
T
IS
A
MIN
CUT
NEXT
SUPPOSE
THAT
X
X
SINCE
X
M
X
M
M
F
WITH
RESPECT
TO
PRICES
X
P
THE
CUT
F
T
HAS
STRICTLY
SMALLER
CAPACITY
THAN
THE
CUT
A
B
T
THEREFORE
THE
LATTER
CANNOT
BE
A
MIN
CUT
LET
AND
SUPPOSE
CLEARLY
F
OTHERWISE
THE
CUT
WILL
HAVE
INFINITE
CAPACITY
IF
M
F
X
M
THEN
BY
MOVING
AND
F
TO
THE
SIDE
WE
CAN
GET
A
SMALLER
CUT
CONTRADICTING
THE
MINIMALITY
OF
THE
CUT
PICKED
IN
PARTICULAR
IF
THEN
THIS
INEQUALITY
MUST
HOLD
LEADING
TO
A
CONTRADICTION
HENCE
FURTHERMORE
M
F
X
M
X
M
ON
THE
OTHER
HAND
M
F
M
F
X
M
M
THE
TWO
IMPLY
THAT
M
F
X
M
CONTRADICTING
THE
DEFINITION
OF
X
HENCE
AND
REMARK
A
MORE
COMPLETE
STATEMENT
FOR
THE
FIRST
PART
OF
LEMMA
WHICH
IS
NOT
ESSENTIAL
FOR
OUR
PURPOSES
IS
IF
X
X
THEN
A
B
T
IS
THE
UNIQUE
MIN
CUT
IN
N
X
P
IF
X
X
THEN
THE
MIN
CUTS
ARE
OBTAINED
BY
MOVING
A
BUNCH
OF
CONNECTED
COMPONENTS
OF
F
TO
THE
SIDE
OF
THE
CUT
A
B
T
LEMMA
LET
X
M
B
M
A
AND
SUPPOSE
THAT
X
X
IF
T
BE
A
MIN
CUT
IN
N
X
P
THEN
MUST
BE
A
PROPER
SUBSET
OF
A
PROOF
IF
A
THEN
B
OTHERWISE
THIS
CUT
HAS
CAPACITY
AND
A
B
T
IS
A
MIN
CUT
BUT
FOR
THE
CHOSEN
VALUE
OF
X
THIS
CUT
HAS
THE
SAME
CAPACITY
AS
A
B
T
SINCE
X
X
THE
LATTER
IS
NOT
A
MIN
CUT
BY
LEMMA
HENCE
IS
A
PROPER
SUBSET
OF
A
LEMMA
X
AND
CAN
BE
FOUND
USING
N
MAX
FLOW
COMPUTATIONS
PROOF
LET
X
M
B
M
A
CLEARLY
X
X
IF
A
B
T
IS
A
MIN
CUT
IN
N
X
P
THEN
BY
LEMMA
X
X
IF
SO
A
OTHERWISE
LET
T
BE
A
MIN
CUT
IN
N
X
P
BY
LEMMAS
AND
A
THEREFORE
IT
IS
SUFFICIENT
TO
RECURSE
ON
THE
SMALLER
GRAPH
F
TERMINATION
WITH
MARKET
CLEARING
PRICES
LET
M
BE
THE
TOTAL
MONEY
POSSESSED
BY
THE
BUYERS
AND
LET
F
BE
THE
MAX
FLOW
COMPUTED
IN
NETWORK
N
P
AT
CURRENT
PRICES
P
THUS
M
F
IS
THE
SURPLUS
MONEY
WITH
THE
BUYERS
LET
US
PARTITION
THE
RUNNING
OF
THE
ALGORITHM
INTO
PHASES
EACH
PHASE
TERMINATES
WITH
THE
OCCURRENCE
OF
EVENT
EACH
PHASE
IS
PARTITIONED
INTO
ITERATIONS
WHICH
CONCLUDE
WITH
A
NEW
EDGE
ENTERING
THE
EQUALITY
SUBGRAPH
WE
WILL
SHOW
THAT
F
MUST
BE
PROPORTIONAL
TO
THE
NUMBER
OF
PHASES
EXECUTED
SO
FAR
HENCE
SHOWING
THAT
THE
SURPLUS
MUST
VANISH
IN
BOUNDED
TIME
LET
U
MAXI
B
J
A
UIJ
AND
LET
NUN
LEMMA
AT
THE
TERMINATION
OF
A
PHASE
THE
PRICES
OF
GOODS
IN
THE
NEWLY
TIGHT
SET
MUST
BE
RATIONAL
NUMBERS
WITH
DENOMINATOR
PROOF
LET
BE
THE
NEWLY
TIGHT
SET
AND
CONSIDER
THE
EQUALITY
SUBGRAPH
INDUCED
ON
THE
BIPARTITION
F
ASSUME
WITHOUT
LOSS
OF
GENERALITY
THAT
THIS
GRAPH
IS
CONNECTED
OTHERWISE
WE
PROVE
THE
LEMMA
FOR
EACH
CONNECTED
COMPONENT
OF
THIS
GRAPH
LET
J
PICK
A
SUBGRAPH
IN
WHICH
J
CAN
REACH
ALL
OTHER
VERTICES
J
I
CLEARLY
AT
MOST
EDGES
SUFFICE
IF
J
REACHES
J
I
WITH
A
PATH
OF
LENGTH
THEN
P
JI
APJ
B
WHERE
A
AND
B
ARE
PRODUCTS
OF
L
UTILITY
PARAMETERS
UIK
EACH
SINCE
ALTERNATE
EDGES
OF
THIS
PATH
CONTRIBUTE
TO
A
AND
B
WE
CAN
PARTITION
THE
UIK
IN
THIS
SUBGRAPH
INTO
TWO
SETS
SUCH
THAT
A
AND
B
USE
UIK
FROM
DISTINCT
SETS
THESE
CONSIDERATIONS
LEAD
EASILY
TO
SHOWING
THAT
M
P
JC
D
WHERE
C
NOW
P
J
M
F
D
C
HENCE
PROVING
THE
LEMMA
LEMMA
EACH
PHASE
CONSISTS
OF
AT
MOST
N
ITERATIONS
PROOF
EACH
ITERATION
BRINGS
GOODS
FROM
THE
TIGHT
SET
TO
THE
ACTIVE
SUBGRAPH
CLEARLY
THIS
CANNOT
HAPPEN
MORE
THAN
N
TIMES
WITHOUT
A
SET
GOING
TIGHT
LEMMA
CONSIDER
TWO
PHASES
P
AND
PI
NOT
NECESSARILY
CONSECUTIVE
SUCH
THAT
GOOD
J
LIES
IN
THE
NEWLY
TIGHT
SETS
AT
THE
END
OF
P
AS
WELL
AS
PI
THEN
THE
INCREASE
IN
THE
PRICE
OF
J
GOING
FROM
P
TO
PI
IS
PROOF
LET
THE
PRICES
OF
J
AT
THE
END
OF
P
AND
PI
BE
P
Q
AND
R
RESPECTIVELY
CLEARLY
R
P
Q
BY
LEMMA
Q
AND
R
THEREFORE
THE
INCREASE
IN
PRICE
OF
J
R
P
Q
LEMMA
AFTER
K
PHASES
F
K
PROOF
CONSIDER
PHASE
P
AND
LET
J
BE
A
GOOD
THAT
LIES
IN
THE
NEWLY
TIGHT
SET
AT
THE
END
OF
THIS
PHASE
LET
PI
BE
THE
LAST
PHASE
EARLIER
THAN
P
SUCH
THAT
J
LIES
IN
THE
NEWLY
TIGHT
SET
AT
THE
END
OF
PI
AS
WELL
IF
THERE
IS
NO
SUCH
PHASE
BECAUSE
P
IS
THE
FIRST
PHASE
IN
WHICH
J
APPEARS
IN
A
TIGHT
SET
THEN
LET
PI
BE
THE
START
OF
THE
ALGORITHM
LET
US
CHARGE
TO
P
THE
ENTIRE
INCREASE
IN
THE
PRICE
OF
J
GOING
FROM
PI
TO
P
EVEN
THOUGH
THIS
INCREASE
TAKES
PLACE
GRADUALLY
OVER
ALL
THE
INTERMEDIATE
PHASES
BY
LEMMA
THIS
IS
IN
THIS
MANNER
EACH
PHASE
CAN
BE
CHARGED
THE
LEMMA
FOLLOWS
COROLLARY
ALGORITHM
TERMINATES
WITH
MARKET
CLEARING
PRICES
IN
AT
MOST
M
PHASES
AND
EXECUTES
O
MAX
FLOW
COMPUTATIONS
REMARK
THE
UPPER
BOUND
GIVEN
ABOVE
IS
QUITE
LOOSE
FOR
EXAMPLE
IT
IS
EASY
TO
SHAVE
OFF
A
FACTOR
OF
N
BY
GIVING
A
TIGHTER
VERSION
OF
LEMMA
ALGORITHM
THE
BASIC
ALGORITHM
INITIALIZATION
J
A
P
J
N
I
B
I
MIN
J
UIJ
P
J
COMPUTE
EQUALITY
SUBGRAPH
G
J
A
IF
DEGREEG
J
THEN
P
J
MAXI
UIJ
I
RECOMPUTE
G
F
F
I
THE
FROZEN
SUBGRAPH
H
H
I
A
B
THE
ACTIVE
SUBGRAPH
WHILE
H
DO
X
DEFINE
J
H
PRICE
OF
J
TO
BE
P
J
X
RAISE
X
CONTINUOUSLY
UNTIL
ONE
OF
TWO
EVENTS
HAPPENS
IF
H
BECOMES
TIGHT
THEN
MOVE
F
FROM
H
H
I
TO
F
F
I
REMOVE
ALL
EDGES
FROM
F
I
TO
H
IF
AN
EDGE
I
J
I
H
I
J
F
ATTAINS
EQUALITY
I
UIJ
P
J
THEN
ADD
I
J
TO
G
MOVE
CONNECTED
COMPONENT
OF
J
FROM
F
F
I
TO
H
H
I
ESTABLISHING
POLYNOMIAL
RUNNING
TIME
FOR
A
GIVEN
FLOW
F
IN
THE
NETWORK
N
P
DEFINE
THE
SURPLUS
OF
BUYER
I
I
P
F
TO
BE
THE
RESIDUAL
CAPACITY
OF
THE
EDGE
I
T
WITH
RESPECT
TO
F
WHICH
IS
EQUAL
TO
EI
MINUS
THE
FLOW
SENT
THROUGH
THE
EDGE
I
T
IN
THIS
SECTION
WE
ARE
TRYING
TO
SPEED
UP
ALGORITHM
BY
INCREASING
THE
PRICES
OF
GOODS
ADJACENT
ONLY
TO
HIGH
SURPLUS
BUYERS
HOWEVER
THE
SURPLUS
OF
A
BUYER
MIGHT
BE
DIFFERENT
FOR
TWO
DIFFERENT
MAXIMUM
FLOWS
IN
THE
SAME
GRAPH
THEREFORE
WE
WILL
RESTRICT
OURSELVES
TO
A
SPECIFIC
FLOW
SO
THAT
THE
SURPLUS
OF
A
BUYER
IS
WELL
DEFINED
THE
FOLLOWING
DEFINITION
SERVES
THIS
PURPOSE
DEFINE
THE
SURPLUS
VECTOR

P
F
P
F
P
F
N
P
F
LET
IVI
DENOTE
THE
NORM
OF
VECTOR
V
DEFINITION
BALANCED
FLOW
FOR
ANY
GIVEN
P
A
MAXIMUM
FLOW
THAT
MINI
MIZES
I
P
F
I
OVER
ALL
CHOICES
OF
F
IS
CALLED
A
BALANCED
FLOW
IF
I
P
F
I
I
P
F
I
I
THEN
WE
SAY
F
IS
MORE
BALANCED
THAN
F
I
FOR
A
GIVEN
P
AND
A
FLOW
F
IN
N
P
LET
R
P
F
BE
THE
RESIDUAL
NETWORK
OF
N
P
WITH
RESPECT
TO
THE
FLOW
F
WE
WILL
GIVE
A
CHARACTERIZATION
OF
BALANCED
FLOW
VIA
R
P
F
LEMMA
LET
F
AND
F
I
BE
ANY
TWO
MAXIMUM
FLOWS
IN
N
P
IF
I
P
F
I
I
P
F
FOR
SOME
I
B
THEN
THERE
EXIST
A
J
B
SUCH
THAT

J
P
F
J
P
F
I
AND
THERE
IS
A
PATH
FROM
J
TO
I
IN
R
P
F
T
THERE
IS
A
PATH
FROM
I
TO
J
IN
R
P
F
I
T
PROOF
CONSIDER
THE
FLOW
F
I
F
IT
DEFINES
A
FEASIBLE
CIRCULATION
IN
THE
NETWORK
R
P
F
SINCE
I
P
F
I
I
P
F
THERE
IS
A
POSITIVE
FLOW
ALONG
THE
EDGE
I
T
IN
F
I
F
BY
FOLLOWING
THIS
FLOW
ALL
THE
WAY
BACK
TO
T
IN
THE
CIRCULATION
ONE
CAN
FIND
A
NODE
J
SUCH
THAT
THERE
IS
A
POSITIVE
FLOW
FROM
T
TO
J
AND
THEN
TO
I
IN
F
I
F
SINCE
BOTH
FLOWS
ARE
MAXIMUM
IS
AN
ISOLATED
VERTEX
IN
F
I
F
AND
THIS
FLOW
DOES
NOT
GO
THROUGH
NOW
F
I
F
IS
A
VALID
FLOW
IN
R
P
F
AND
THEREFORE
THERE
EXISTS
A
PATH
FROM
J
TO
I
IN
R
P
F
T
MOREOVER
HAVING
A
POSITIVE
FLOW
FROM
T
TO
J
IMPLIES
THAT

J
P
F
J
P
F
I
A
SIMILAR
ARGUMENT
SHOWS
THAT
THERE
IS
ALSO
A
PATH
FROM
I
TO
J
IN
R
P
F
I
T
LEMMA
IF
A
BI
I
N
AND

N

J
WHERE


J
J
N
THEN
I
A
BN
I
J
I
A

BN
N
I
PROOF
N
N
N
A

BI
I
BI

I
THE
FOLLOWING
PROPERTY
CHARACTERIZES
ALL
BALANCED
FLOWS
IT
DEFINES
THE
FLOWS
FOR
WHICH
THERE
IS
NO
PATH
FROM
A
LOW
SURPLUS
NODE
TO
A
HIGH
SURPLUS
NODE
IN
THE
RESIDUAL
NETWORK
PROPERTY
THERE
IS
NO
PATH
FROM
NODE
I
B
TO
NODE
J
B
IN
R
P
F
IF
SURPLUS
I
IS
MORE
THAN
SURPLUS
OF
J
IN
N
P
F
ALGORITHM
INITIALIZATION
J
A
P
J
N
B
I
MIN
J
UIJ
P
J
DEFINE
G
A
B
E
WITH
I
J
E
IFF
I
UIJ
P
J
A
IF
DEGREEG
J
THEN
P
J
MAXI
UIJ
I
RECOMPUTE
G

M
REPEAT
COMPUTE
A
BALANCED
FLOW
F
IN
G
DEFINE

TO
BE
THE
MAXIMUM
SURPLUS
IN
B
DEFINE
H
TO
BE
THE
SET
OF
BUYERS
WITH
SURPLUS

REPEAT
LET
H
I
BE
THE
SET
OF
NEIGHBORS
OF
H
IN
A
REMOVE
ALL
EDGES
FROM
B
H
TO
H
I
X
DEFINE
J
H
I
PRICE
OF
J
TO
BE
P
J
X
RAISE
X
CONTINUOUSLY
UNTIL
ONE
OF
THE
TWO
EVENTS
HAPPENS
EVENT
AN
EDGE
I
J
I
H
J
A
H
I
ATTAINS
EQUALITY
I
UIJ
P
J
ADD
I
J
TO
G
RECOMPUTE
F
IN
THE
RESIDUAL
NETWORK
CORRESPONDING
TO
F
IN
G
DEFINE
I
TO
BE
THE
SET
OF
BUYERS
THAT
CAN
REACH
H
H
H
I
EVENT
H
BECOMES
TIGHT
UNTIL
SOME
SUBSET
H
IS
TIGHT
UNTIL
A
IS
TIGHT
THEOREM
A
MAXIMUM
FLOW
F
IS
BALANCED
IFF
IT
HAS
PROPERTY
PROOF
SUPPOSE
F
IS
A
BALANCED
FLOW
LET
I
P
F
J
P
F
FOR
SOME
I
AND
J
AND
SUPPOSE
FOR
THE
SAKE
OF
CONTRADICTION
THAT
THERE
IS
A
PATH
FROM
J
TO
I
IN
R
P
F
T
THEN
ONE
CAN
SEND
A
CIRCULATION
OF
POSITIVE
VALUE
ALONG
T
J
I
T
IN
R
P
F
DECREASING
I
AND
INCREASING

J
FROM
LEMMA
THE
RESULTING
FLOW
IS
MORE
BALANCED
THAN
F
CONTRADICTING
THE
FACT
THAT
F
IS
A
BALANCED
FLOW
TO
PROVE
THE
OTHER
DIRECTION
SUPPOSE
THAT
F
IS
NOT
A
BALANCED
MAXIMUM
FLOW
LET
F
I
BE
A
BALANCED
FLOW
SINCE

P
F
I

P
F
THERE
EXISTS
I
B
SUCH
THAT
I
P
F
I
I
P
F
BY
LEMMA
THERE
EXISTS
J
B
SUCH
THAT

J
P
F
J
P
F
I
AND
THERE
IS
A
PATH
FROM
J
TO
I
IN
R
P
F
T
SINCE
F
HAS
PROPERTY
I
P
F

J
P
F
THE
ABOVE
THREE
INEQUALITIES
IMPLY
I
P
F
I
J
P
F
BUT
AGAIN
BY
LEMMA
THERE
IS
A
PATH
FROM
I
TO
J
IN
R
P
F
I
T
SO
F
I
DOESN
T
HAVE
PROPERTY
THIS
CONTRADICTS
THE
ASSUMPTION
THAT
F
I
IS
A
BALANCED
FLOW
BY
WHAT
WE
PROVED
IN
THE
FIRST
HALF
THE
THEOREM
THE
FOLLOWING
LEMMA
PROVIDES
OUR
MAIN
TOOL
FOR
PROVING
POLYNOMIAL
RUNNING
TIME
OF
ALGORITHM
WE
WILL
USE
IT
TO
PROVE
AN
UPPER
BOUND
ON
THE
NORM
OF
THE
SURPLUS
VECTOR
OF
BUYERS
AT
THE
END
OF
EVERY
PHASE
LEMMA
IF
F
AND
F
ARE
RESPECTIVELY
A
FEASIBLE
AND
A
BALANCED
FLOW
IN
N
P
AND
FOR
SOME
I
B
AND

I
F
I
F

THEN
THERE
IS
A
FLOW
F
I
AND
FOR
SOME
K
THERE
IS
A
SET
OF
VERTICES
IK
AND
VALUES
K
SUCH
THAT
K
L
L

I
F
I
I
F

IL
F
I
IL
F
L
I
F
I
IL
F
I
PROOF
CONSIDER
F
F
IN
R
P
F
AND
IN
A
SIMILAR
FASHION
AS
IN
LEMMA
FOLLOW
THE
INCOMING
FLOW
OF
NODE
I
UNTIL
YOU
REACH
OR
THE
NODE
I
ITSELF
LET
F
I
BE
THE
FLOW
AUGMENTED
FROM
F
BY
SENDING
BACK
THE
FLOW
THROUGH
ALL
THESE
CIRCULATIONS
AND
PATHS
WE
WILL
HAVE
I
F
I
I
F

AND
FOR
A
SET
OF
VERTICES
IK
AND
VALUES
K
SUCH
THAT
K
L

WE
HAVE
I
F
I
I
F
L
COROLLARY
I
P
F
I
P
F
PROOF
BY
LEMMA
I
F
P
I
F
I
P
AND
SINCE
F
IS
A
BALANCED
FLOW
IN
N
P
I
F
I
P
I
F
P
COROLLARY
FOR
ANY
GIVEN
P
ALL
BALANCED
FLOWS
IN
N
P
HAVE
THE
SAME
SURPLUS
VECTOR
AS
A
RESULT
ONE
CAN
DEFINE
THE
SURPLUS
VECTOR
FOR
A
GIVEN
PRICE
AS

P

P
F
WHERE
F
IS
THE
BALANCED
FLOW
IN
N
P
THIS
VECTOR
CAN
BE
FOUND
BY
COMPUTING
A
BALANCED
FLOW
IN
THE
EQUALITY
SUBGRAPH
IN
THE
FOLLOWING
WAY
COROLLARY
FOR
A
GIVEN
PRICE
VECTOR
P
THE
BALANCED
FLOW
CAN
BE
COMPUTED
BY
AT
MOST
N
MAX
FLOW
COMPUTATION
PROOF
WE
WILL
USE
THE
DIVIDE
AND
CONQUER
METHOD
LET
MAVG
NI
EI
MAVG
FROM
THE
CAPACITY
OF
EACH
EDGE
ADJACENT
T
LET
T
BE
THE
MAXIMAL
MIN
CUT
IN
THAT
NETWORK
T
T
IF
A
THEN
THE
CURRENT
MAXIMUM
FLOW
IS
BALANCED
OTHERWISE
LET
AND
BE
THE
NETWORKS
INDUCED
BY
T
AND
T
RESPECTIVELY
CLAIM
THAT
THE
UNION
OF
BALANCED
FLOWS
IN
AND
IS
A
BALANCED
FLOW
IN
N
IN
ORDER
TO
PROVE
THE
CLAIM
IT
IS
ENOUGH
FROM
THEOREM
TO
SHOW
THAT
THE
SURPLUS
OF
ALL
BUYERS
IN
IN
A
BALANCED
FLOW
IS
AT
LEAST
MAVG
AND
THAT
OF
ALL
BUYERS
IN
IS
AT
MOST
MAVG
WE
WILL
PROVE
THE
FORMER
THE
PROOF
OF
THE
LATTER
IS
SIMILAR
LET
L
BE
THE
SET
OF
ALL
BUYERS
IN
WITH
THE
LOWEST
SURPLUS
SAY
SUPPOSE
MAVG
LET
K
BE
THE
SET
OF
GOODS
REACHABLE
BY
L
IN
THE
RESIDUAL
NETWORK
OF
W
R
T
A
BALANCED
FLOW
BY
THEOREM
NO
OTHER
BUYERS
ARE
REACHABLE
FROM
L
IN
THIS
NETWORK
HENCE
F
K
L
SINCE
THE
SURPLUS
OF
ALL
BUYERS
IN
L
IS
M
K
M
L
L
M
L
MAVG
L
THIS
IS
A
CONTRADICTION
TO
THE
FACT
THAT
T
WAS
A
MIN
CUT
IN
A
SET
OF
FEASIBLE
VECTORS
A
VECTOR
V
IS
CALLED
MIN
MAX
FAIR
IFF
FOR
EVERY
FEASIBLE
VECTOR
U
AND
AN
INDEX
I
SUCH
THAT
UI
VI
THERE
IS
A
J
FOR
WHICH
U
J
V
J
AND
V
J
VI
SIMILARLY
V
IS
MAX
MIN
FAIR
IFF
UI
VI
IMPLIES
THAT
THERE
IS
A
J
FOR
WHICH
U
J
V
J
AND
V
J
VI
REMARK
THE
SURPLUS
VECTOR
OF
A
BALANCED
FLOW
IS
BOTH
MIN
MAX
AND
MAX
MIN
FAIR
THE
POLYNOMIAL
TIME
ALGORITHM
THE
MAIN
IDEA
OF
ALGORITHM
IS
THAT
IT
TRIES
TO
REDUCE

P
F
IN
EVERY
PHASE
INTUITIVELY
THIS
GOAL
IS
ACHIEVED
BY
FINDING
A
SET
OF
HIGH
SURPLUS
BUYERS
IN
THE
BALANCED
FLOW
AND
INCREASING
THE
PRICES
OF
GOODS
IN
WHICH
THEY
ARE
INTERESTED
IF
A
SUBSET
BECOMES
TIGHT
AS
A
RESULT
OF
THIS
INCREASE
WE
HAVE
REDUCED

P
F
BECAUSE
THE
SURPLUS
OF
A
FORMERLY
HIGH
SURPLUS
BUYER
IS
DROPPED
TO
ZERO
THE
OTHER
EVENT
THAT
CAN
HAPPEN
IS
THAT
A
NEW
EDGE
IS
ADDED
TO
THE
EQUALITY
SUBGRAPH
IN
THAT
CASE
THIS
EDGE
WILL
HELP
US
TO
MAKE
THE
SURPLUS
VECTOR
MORE
BALANCED
WE
CAN
REDUCE
THE
SURPLUS
OF
HIGH
SURPLUS
BUYERS
AND
INCREASE
THE
SURPLUS
OF
LOW
SURPLUS
ONES
THIS
OPERATION
WILL
RESULT
IN
THE
REDUCTION
OF
I
P
F
I
THE
ALGORITHM
STARTS
WITH
FINDING
A
PRICE
VECTOR
THAT
DOES
NOT
VIOLATE
THE
INVARIANT
THE
REST
OF
THE
ALGORITHM
IS
PARTITIONED
INTO
PHASES
IN
EACH
PHASE
WE
HAVE
AN
ACTIVE
GRAPH
H
H
I
WITH
H
B
AND
H
I
A
AND
WE
INCREASE
THE
PRICES
OF
GOODS
IN
H
I
LIKE
ALGORITHM
LET

BE
THE
MAXIMUM
SURPLUS
IN
B
THE
SUBSET
H
IS
INITIALLY
THE
SET
OF
BUYERS
WHOSE
SURPLUS
IS
EQUAL
TO

H
I
IS
THE
SET
OF
GOODS
ADJACENT
TO
BUYERS
IN
H
EACH
PHASE
IS
DIVIDED
INTO
ITERATIONS
IN
EACH
ITERATION
WE
INCREASE
THE
PRICES
OF
GOODS
IN
H
I
UNTIL
EITHER
A
NEW
EDGE
JOINS
THE
EQUALITY
SUBGRAPH
OR
A
SUBSET
BECOMES
TIGHT
IF
A
NEW
EDGE
IS
ADDED
TO
THE
EQUALITY
SUBGRAPH
WE
RECOMPUTE
THE
BALANCED
FLOW
F
THEN
WE
ADD
TO
H
ALL
VERTICES
THAT
CAN
REACH
A
MEMBER
OF
H
IN
R
P
F
T
IF
A
SUBSET
BECOMES
TIGHT
AS
A
RESULT
OF
INCREASE
OF
THE
PRICES
THEN
THE
PHASE
TERMINATES
CONSIDER
A
PHASE
IN
THE
EXECUTION
OF
ALGORITHM
DEFINE
PI
AND
HI
TO
BE
THE
PRICE
VECTOR
AND
THE
SET
OF
NODES
IN
H
AFTER
EXECUTING
THE
I
TH
ITERATION
IN
THAT
PHASE
LET
DENOTE
THE
SET
OF
NODES
IN
H
BEFORE
THE
FIRST
ITERATION
LEMMA
THE
NUMBER
OF
ITERATIONS
EXECUTED
IN
A
PHASE
IS
AT
MOST
N
MORE
OVER
IN
EVERY
PHASE
THERE
IS
AN
ITERATION
IN
WHICH
SURPLUS
OF
AT
LEAST
ONE
OF
THE
VERTICES
IS
REDUCED
BY
AT
LEAST

PROOF
LET
K
DENOTE
THE
NUMBER
OF
ITERATIONS
IN
THE
PHASE
EVERY
TIME
AN
EDGE
IS
ADDED
TO
THE
EQUALITY
SUBGRAPH
H
I
IS
INCREASED
BY
AT
LEAST
ONE
THEREFORE
K
IS
AT
MOST
N
DEFINE
I
MIN
J
HI

J
PI
FOR
I
K

AND
THE
PHASE
ENDS
WHEN
THE
SURPLUS
OF
ONE
BUYER
IN
H
BECOMES
ZERO
SO
K
SO
THERE
IS
AN
ITERATION
T
IN

N
CONSIDER
THE
RESIDUAL
NETWORK
CORRESPONDING
TO
THE
BALANCED
FLOW
COMPUTED
AT
ITERATION
T
IN
THAT
NETWORK
EVERY
VERTEX
IN
HT
HT
CAN
REACH
A
VERTEX
IN
HT
AND
THEREFORE
BY
THEOREM
ITS
SURPLUS
IS
GREATER
THAN
OR
EQUAL
TO
THE
SURPLUS
OF
THAT
VERTEX
THIS
MEANS
THAT
MINIMUM
SURPLUS
T
IS
ACHIEVED
BY
A
VERTEX
I
IN
HT
HENCE
THE
SURPLUS
OF
VERTEX
I
IS
DECREASED
BY
AT
LEAST
T
T
DURING
ITERATION
T
LEMMA
IF
AND
P
ARE
PRICE
VECTORS
BEFORE
AND
AFTER
A
PHASE
I
P
I
PROOF
IN
EVERY
ITERATION
WE
INCREASE
PRICES
OF
GOODS
IN
H
OR
ADD
NEW
EDGES
TO
THE
EQUALITY
SUBGRAPH
MOREOVER
ALL
THE
EDGES
OF
THE
NETWORK
THAT
ARE
DELETED
IN
THE
BEGINNING
OF
A
PHASE
HAVE
ZERO
FLOW
THEREFORE
THE
BALANCED
FLOW
COMPUTED
AT
ITERATION
I
IS
A
FEASIBLE
FLOW
FOR
N
PI
THEREFORE
BY
LEMMA
I
I
I
I
I
I
I
PK
I
FURTHERMORE
BY
THE
PREVIOUS
LEMMA
THERE
IS
AN
ITERATION
T
AND
NODE
I
SUCH
THAT
I
PT
I
PT

SO
WE
HAVE
I
PT
I
PT

WHICH
MEANS
THAT
I
P
I
PT
I
PT
NOW
I
SO

I
I

I
P
I
P
REMARK
THE
UPPER
BOUND
GIVEN
ABOVE
IS
QUITE
LOOSE
FOR
EXAMPLE
ONE
CAN
REDUCE
THE
UPPER
BOUND
TO
BY
CONSIDERING
ALL
ITERATIONS
T
IN
WHICH
T
T
BY
THE
BOUND
GIVEN
IN
THE
ABOVE
IT
IS
EASY
TO
SEE
THAT
AFTER
O
PHASES

P
IS
REDUCED
TO
AT
MOST
HALF
OF
ITS
PREVIOUS
VALUE
IN
THE
BEGINNING

P
M
ONCE
THE
VALUE
OF

P
THE
ALGORITHM
TAKES
AT
MOST
ONE
MORE
STEP
THIS
IS
BECAUSE
LEMMA
AND
CONSEQUENTLY
LEMMA
HOLDS
FOR
ALGORITHM
AS
WELL
HENCE
THE
NUMBER
OF
PHASES
IS
AT
MOST
O
LOG
O
LOG
N
N
LOG
U
LOG
M
AS
NOTED
BEFORE
THE
NUMBER
OF
ITERATIONS
IN
EACH
PHASE
IS
AT
MOST
N
EACH
ITERATION
REQUIRES
AT
MOST
O
N
MAX
FLOW
COMPUTATIONS
HENCE
WE
GET
THEOREM
ALGORITHM
EXECUTES
AT
MOST
O
LOG
N
N
LOG
U
LOG
M
MAX
FLOW
COMPUTATIONS
AND
FINDS
MARKET
CLEARING
PRICES
DISCUSSION
AN
IMPORTANT
QUESTION
REMAINING
IS
WHETHER
THERE
IS
A
STRONGLY
POLYNOMIAL
ALGO
RITHM
FOR
COMPUTING
EQUILIBRIUM
FOR
FISHER
LINEAR
CASE
AND
SOLVING
THE
EISENBERG
GALE
PROGRAM
ANOTHER
ISSUE
IS
WHETHER
THE
MACHINERY
DEVELOPED
IN
SECTION
IS
NECESSARY
FOR
OBTAINING
A
POLYNOMIAL
TIME
ALGORITHM
THAT
IS
DOES
THE
ALGORITHM
GIVEN
IN
SECTIONS
AND
HAVE
A
POLYNOMIAL
RUNNING
TIME
IF
NOT
IT
WOULD
BE
NICE
TO
FIND
A
FAMILY
OF
INSTANCES
ON
WHICH
IT
TAKES
SUPER
POLYNOMIAL
TIME
ACKNOWLEDGMENTS
WE
WISH
TO
THANK
LISA
FLEISCHER
AND
MOHAMMAD
MAHDIAN
FOR
POINTING
OUT
A
SUBTLE
THOUGH
FATAL
BUG
IN
THE
PRE
EMPTIVE
FREEZING
PART
IN
DEVANUR
ET
AL
WHICH
HAS
BEEN
CORRECTED
IN
THIS
ARTICLE
THE
NOBEL
PRIZE
IN
ECONOMICS
AWARDED
TO
ALVIN
E
ROTH
AND
LLOYD
SHAPLEY
FOR
THE
THEORY
OF
STABLE
ALLOCATIONS
AND
THE
PRACTICE
OF
MARKET
DESIGN
THE
RELATED
BRANCH
OF
GAME
THEORY
IS
OFTEN
REFERRED
TO
AS
MATCHING
THEORY
WHICH
STUDIES
THE
DESIGN
AND
PERFORMANCE
OF
PLATFORMS
FOR
TRANSACTIONS
BETWEEN
AGENTS
ROUGHLY
SPEAKING
IT
STUDIES
WHO
IN
TERACTS
WITH
WHOM
AND
HOW
WHICH
APPLICANT
GETS
WHICH
JOB
WHICH
STUDENTS
GO
TO
WHICH
UNIVERSITIES
WHICH
DONORS
GIVE
ORGANS
TO
WHICH
PATIENTS
AND
SO
ON
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
MANY
METHODS
FOR
FINDING
DESIRABLE
ALLOCATIONS
IN
MATCHING
PROBLEMS
ARE
VARIANTS
OF
TWO
ALGORITHMS
THE
TOP
TRADING
CYCLE
ALGORITHM
THE
DEFERRED
ACCEPTANCE
ALGORITHM
FOR
EACH
OF
THE
TWO
ALGORITHMS
I
WILL
DO
THE
FOLLOWING
STATE
THE
ALGORITHM
STATE
NICE
PROPERTIES
OF
OUTCOMES
GENERATED
BY
THE
ALGORITHM
SOLVE
AN
EXAMPLE
USING
THE
ALGORITHM
DESCRIBE
APPLICATION
GIVE
YOU
A
HOMEWORK
EXERCISE
L
SHAPLEY
AND
H
SCARF
ON
CORES
AND
INDIVISIBILITY
JOURNAL
OF
MATHEMATICAL
ECONOMICS
THE
ALGORITHM
IS
DESCRIBED
IN
SECTION
P
AND
ATTRIBUTED
TO
DAVID
GALE
INPUT
EACH
OF
N
N
AGENTS
OWNS
AN
INDIVISIBLE
GOOD
A
HOUSE
AND
HAS
STRICT
PREFERENCES
OVER
ALL
HOUSES
CONVENTION
AGENT
I
INITIALLY
OWNS
HOUSE
HI
QUESTION
CAN
THE
AGENTS
BENEFIT
FROM
SWAPPING
HOUSES
TTC
ALGORITHM
EACH
AGENT
I
POINTS
TO
HER
MOST
PREFERRED
HOUSE
POSSIBLY
I
OWN
EACH
HOUSE
POINTS
BACK
TO
ITS
OWNER
THIS
CREATES
A
DIRECTED
GRAPH
IN
THIS
GRAPH
IDENTIFY
CYCLES
FINITE
CYCLE
EXISTS
STRICT
PREFERENCES
EACH
AGENT
IS
IN
AT
MOST
ONE
CYCLE
GIVE
EACH
AGENT
IN
A
CYCLE
THE
HOUSE
SHE
POINTS
AT
AND
REMOVE
HER
FROM
THE
MARKET
WITH
HER
ASSIGNED
HOUSE
IF
UNMATCHED
AGENTS
HOUSES
REMAIN
ITERATE
THE
TTC
ASSIGNMENT
IS
SUCH
THAT
NO
SUBSET
OF
OWNERS
CAN
MAKE
ALL
OF
ITS
MEMBERS
BETTER
O
BY
EXCHANGING
THE
HOUSES
THEY
INITIALLY
OWN
IN
A
DI
ERENT
WAY
IN
TECHNICAL
LINGO
THE
TTC
OUTCOME
IS
A
CORE
ALLOCATION
THE
TTC
ASSIGNMENT
IS
THE
ONLY
SUCH
ASSIGNMENT
UNIQUE
CORE
ALLOCATION
IT
IS
NEVER
ADVANTAGEOUS
TO
AN
AGENT
TO
LIE
ABOUT
PREFERENCES
IF
THE
TTC
ALGORITHM
IS
USED
THE
TTC
ALGORITHM
IS
STRATEGY
PROOF
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
AGENTS
RANKING
FROM
BEST
LEFT
TO
WORST
RIGHT
ONLY
AGENTS
AND
LEFT
WITH
UPDATED
PREFERENCES
H
H
CYCLE
SO
GET
AND
GETS
REMOVE
THEM
AND
ITERATE
CYCLE
SO
GETS
AND
GETS
DONE
FINAL
MATCH
A
ABDULKADIRO
GLU
AND
T
ONMEZ
SCHOOL
CHOICE
A
MECHANISM
DESIGN
APPROACH
AMERICAN
ECONOMIC
REVIEW
HOW
TO
ASSIGN
CHILDREN
TO
SCHOOLS
SUBJECT
TO
PRIORITIES
FOR
SIBLINGS
AND
DISTANCE
INPUT
STUDENTS
SUBMIT
STRICT
PREFERENCES
OVER
SCHOOLS
SCHOOLS
SUBMIT
STRICT
PREFERENCES
OVER
STUDENTS
BASED
ON
PRIORITY
CRITERIA
AND
IF
NECESSARY
A
RANDOM
NUMBER
GENERATOR
MODIFIED
TTC
ALGORITHM
EACH
REMAINING
STUDENT
POINTS
AT
HER
MOST
PREFERRED
UNFILLED
SCHOOL
EACH
UNFILLED
SCHOOL
POINTS
AT
ITS
MOST
PREFERRED
REMAINING
STUDENT
CYCLES
ARE
IDENTIFIED
AND
STUDENTS
IN
CYCLES
ARE
MATCHED
TO
THE
SCHOOL
THEY
POINT
AT
REMOVE
ASSIGNED
STUDENTS
AND
FULL
SCHOOLS
IF
UNMATCHED
STUDENTS
REMAIN
ITERATE
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
A
E
ROTH
T
ONMEZ
M
U
U
NVER
KIDNEY
EXCHANGE
QUARTERLY
JOURNAL
OF
ECONOMICS
A
CASE
WITH
PATIENT
DONOR
PAIRS
A
PATIENT
IN
NEED
OF
A
KIDNEY
AND
A
DONOR
FAMILY
FRIEND
WHO
IS
WILLING
TO
DONATE
ONE
COMPLICATIONS
ARISE
DUE
TO
INCOMPATIBILITY
BLOOD
TISSUE
GROUPS
ETC
SO
LOOK
AT
TRADING
CYCLES
PATIENT
MIGHT
GET
THE
KIDNEY
OF
DONOR
IF
PATIENT
GETS
THE
KIDNEY
OF
DONOR
ETC
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
APPLY
THE
TTC
ALGORITHM
TO
THE
FOLLOWING
CASE
H2
D
GALE
AND
L
SHAPLEY
COLLEGE
ADMISSIONS
AND
THE
STABILITY
OF
MARRIAGE
AMERICAN
MATHEMATICAL
MONTHLY
ONLY
SEVEN
PAGES
AND
YES
STABILITY
OF
MARRIAGE
MEN
AND
WOMEN
HAVE
STRICT
PREFERENCES
OVER
PARTNERS
OF
THE
OPPOSITE
SEX
YOU
MAY
PREFER
STAYING
SINGLE
TO
MARRYING
A
CERTAIN
PARTNER
A
MATCH
IS
A
SET
OF
PAIRS
OF
THE
FORM
M
W
M
M
OR
W
W
SUCH
THAT
EACH
PERSON
HAS
EXACTLY
ONE
PARTNER
PERSON
I
IS
UNMATCHED
IF
THE
MATCH
INCLUDES
I
I
I
IS
ACCEPTABLE
TO
J
IF
J
PREFERS
I
TO
BEING
UNMATCHED
GIVEN
A
PROPOSED
MATCH
A
PAIR
M
W
IS
BLOCKING
IF
BOTH
PREFER
EACH
OTHER
TO
THE
PERSON
THEY
RE
MATCHED
WITH
M
PREFERS
W
TO
HIS
MATCH
PARTNER
W
PREFERS
M
TO
HER
MATCH
PARTNER
A
MATCH
IS
UNSTABLE
IF
SOMEONE
HAS
AN
UNACCEPTABLE
PARTNER
OR
IF
THERE
IS
A
BLOCKING
PAIR
OTHERWISE
IT
IS
STABLE
A
MATCH
IS
MAN
OPTIMAL
IF
IT
IS
STABLE
AND
THERE
IS
NO
OTHER
STABLE
MATCH
THAT
SOME
MAN
PREFERS
WOMAN
OPTIMAL
ANALOGOUSLY
INPUT
A
NONEMPTY
FINITE
SET
M
OF
MEN
AND
W
OF
WOMEN
EACH
MAN
WOMAN
RANKS
ACCEPTABLE
WOMEN
MEN
FROM
BEST
TO
WORST
DA
ALGORITHM
MEN
PROPOSING
EACH
MAN
PROPOSES
TO
THE
HIGHEST
RANKED
WOMAN
ON
HIS
LIST
WOMEN
HOLD
AT
MOST
ONE
O
ER
HER
MOST
PREFERRED
ACCEPTABLE
PROPOSER
REJECTING
ALL
OTHERS
EACH
REJECTED
MAN
REMOVES
THE
REJECTING
WOMAN
FROM
HIS
LIST
IF
THERE
ARE
NO
NEW
REJECTIONS
STOP
OTHERWISE
ITERATE
AFTER
STOPPING
IMPLEMENT
PROPOSALS
THAT
HAVE
NOT
BEEN
REJECTED
REMARKS
DA
ALGORITHM
WOMEN
PROPOSING
SWITCH
ROLES
DEFERRED
ACCEPTANCE
RECEIVING
SIDE
DEFERS
FINAL
ACCEPTANCE
OF
PROPOSALS
UNTIL
THE
VERY
END
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
THE
ALGORITHM
ENDS
WITH
A
STABLE
MATCH
BY
CONSTRUCTION
NO
PERSON
IS
MATCHED
TO
AN
UNACCEPTABLE
CANDIDATE
NO
M
W
CAN
BE
A
BLOCKING
PAIR
IF
M
STRICTLY
PREFERS
W
TO
HIS
CURRENT
MATCH
HE
MUST
HAVE
PROPOSED
TO
HER
AND
BEEN
REJECTED
IN
FAVOR
OF
A
CANDIDATE
THAT
W
LIKED
BETTER
THAT
IS
W
FINDS
HER
MATCH
BETTER
THAN
M
THIS
MATCH
IS
MAN
OPTIMAL
WOMAN
PESSIMAL
MEN
HAVE
NO
INCENTIVES
TO
LIE
ABOUT
THEIR
PREFERENCES
WOMEN
MIGHT
STRATEGY
PROOF
FOR
MEN
SEE
HOMEWORK
EXERCISE
THERE
IS
NO
MECHANISM
THAT
ALWAYS
ENDS
IN
A
STABLE
MATCH
AND
THAT
IS
STRATEGY
PROOF
FOR
ALL
PARTICIPANTS
FOR
CONVENIENCE
M
W
ALL
PARTNERS
OF
OPPOSITE
SEX
ARE
ACCEPTABLE
RANKING
MATRIX
INTERPRETATION
ENTRY
IN
THE
FIRST
ROW
AND
FIRST
COLUMN
INDICATES
THAT
RANKS
FIRST
AMONG
THE
WOMEN
AND
THAT
RANKS
THIRD
AMONG
THE
MEN
IS
THE
ONLY
PERSON
TO
RECEIVE
MULTIPLE
PROPOSALS
SHE
COMPARES
RANK
WITH
RANK
AND
REJECTS
STRIKE
THIS
ENTRY
FROM
THE
MATRIX
AND
ITERATE
IS
THE
ONLY
PERSON
TO
RECEIVE
MULTIPLE
PROPOSALS
SHE
COMPARES
RANK
WITH
RANK
AND
REJECTS
STRIKE
THIS
ENTRY
FROM
THE
MATRIX
AND
ITERATE
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
IS
THE
ONLY
PERSON
TO
RECEIVE
MULTIPLE
PROPOSALS
SHE
COMPARES
RANK
WITH
RANK
AND
REJECTS
STRIKE
THIS
ENTRY
FROM
THE
MATRIX
AND
ITERATE
IS
THE
ONLY
PERSON
TO
RECEIVE
MULTIPLE
PROPOSALS
SHE
COMPARES
RANK
WITH
RANK
AND
REJECTS
STRIKE
THIS
ENTRY
FROM
THE
MATRIX
AND
ITERATE
M
IS
THE
ONLY
PERSON
TO
RECEIVE
MULTIPLE
PROPOSALS
SHE
COMPARES
RANK
WITH
RANK
AND
REJECTS
STRIKE
THIS
ENTRY
FROM
THE
MATRIX
AND
ITERATE
NO
REJECTIONS
THE
ALGORITHM
STOPS
WITH
STABLE
MATCH
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
MARK
VOORNEVELD
GAME
THEORY
EXTENSIVE
FORM
GAMES
A
VARIANT
OF
THE
MARRIAGE
PROBLEM
IS
THE
COLLEGE
ADMISSION
PROBLEM
EACH
STUDENT
CAN
BE
MATCHED
TO
AT
MOST
ONE
COLLEGE
BUT
A
COLLEGE
CAN
ACCEPT
MANY
STUDENTS
THIS
CAN
BE
MAPPED
INTO
THE
MARRIAGE
PROBLEM
STUDENTS
ONE
SIDE
OF
THE
MARRIAGE
PROBLEM
E
G
M
COLLEGES
OTHER
SIDE
OF
THE
MARRIAGE
PROBLEM
E
G
W
SPLIT
COLLEGE
C
WITH
QUOTA
N
INTO
N
DI
ERENT
WOMEN
CN
CREATE
ARTIFICIAL
PREFERENCES
BY
REPLACING
COLLEGE
C
IN
STUDENTS
RANKINGS
BY
CN
IN
THAT
ORDER
CONSIDER
THE
RANKING
MATRIX
FIND
A
STABLE
MATCHING
USING
THE
MEN
PROPOSING
DA
ALGORITHM
FIND
A
STABLE
MATCHING
USING
THE
WOMEN
PROPOSING
DA
ALGORITHM
SUPPOSE
THAT
LIES
ABOUT
HER
PREFERENCES
AND
SAYS
THAT
SHE
ONLY
FINDS
ACCEPTABLE
WHAT
IS
THE
OUTCOME
OF
THE
MEN
PROPOSING
DA
ALGORITHM
NOW
VERIFY
THAT
BOTH
WOMEN
ARE
BETTER
O
THAN
UNDER
A
IT
MAY
PAY
FOR
THE
WOMEN
TO
LIE
THE
COMPLEXITY
OF
COMPUTING
A
NASH
EQUILIBRIUM
ABSTRACT
HOW
LONG
DOES
IT
TAKE
UNTIL
ECONOMIC
AGENTS
CONVERGE
TO
AN
EQUILIBRIUM
BY
STUDYING
THE
COMPLEXITY
OF
THE
PROBLEM
OF
COMPUTING
A
MIXED
NASH
EQUILIBRIUM
IN
A
GAME
WE
PROVIDE
EVIDENCE
THAT
THERE
ARE
GAMES
IN
WHICH
CONVERGENCE
TO
SUCH
AN
EQUILIBRIUM
TAKES
PROHIBITIVELY
LONG
TRADITIONALLY
COM
PUTATIONAL
PROBLEMS
FALL
INTO
TWO
CLASSES
THOSE
THAT
HAVE
A
POLYNOMIAL
TIME
ALGORITHM
AND
THOSE
THAT
ARE
NP
HARD
HOWEVER
THE
CONCEPT
OF
NP
HARDNESS
CANNOT
BE
APPLIED
TO
THE
RARE
PROBLEMS
WHERE
EVERY
INSTANCE
HAS
A
SOLUTION
FOR
EXAMPLE
IN
THE
CASE
OF
GAMES
NASH
THEOREM
ASSERTS
THAT
EVERY
GAME
HAS
A
MIXED
EQUILIBRIUM
NOW
KNOWN
AS
THE
NASH
EQUILIBRIUM
IN
HONOR
OF
THAT
RESULT
WE
SHOW
THAT
FINDING
A
NASH
EQUILIBRIUM
IS
COMPLETE
FOR
A
CLASS
OF
PROBLEMS
CALLED
PPAD
CONTAINING
SEVERAL
OTHER
KNOWN
HARD
PROBLEMS
ALL
PROBLEMS
IN
PPAD
SHARE
THE
SAME
STYLE
OF
PROOF
THAT
EVERY
INSTANCE
HAS
A
SOLUTION
INTRODUCTION
IN
A
RECENT
CACM
ARTICLE
SHOHAM
REMINDS
US
OF
THE
LONG
RELATIONSHIP
BETWEEN
GAME
THEORY
AND
COMPUTER
SCI
ENCE
GOING
BACK
TO
JOHN
VON
NEUMANN
AT
PRINCETON
IN
THE
AND
HOW
THIS
CONNECTION
BECAME
STRONGER
AND
MORE
CRUCIAL
IN
THE
PAST
DECADE
DUE
TO
THE
ADVENT
OF
THE
INTER
NET
STRATEGIC
BEHAVIOR
BECAME
RELEVANT
TO
THE
DESIGN
OF
COMPUTER
SYSTEMS
WHILE
MUCH
ECONOMIC
ACTIVITY
NOW
TAKES
PLACE
ON
COMPUTATIONAL
PLATFORMS
GAME
THEORY
IS
ABOUT
THE
STRATEGIC
BEHAVIOR
OF
RATIONAL
AGENTS
IT
STUDIES
GAMES
THOUGHT
EXPERIMENTS
MODELING
VAR
IOUS
SITUATIONS
OF
CONFLICT
ONE
COMMONLY
STUDIED
MODEL
AIMS
TO
CAPTURE
TWO
PLAYERS
INTERACTING
IN
A
SINGLE
ROUND
FOR
EXAMPLE
THE
WELL
KNOWN
SCHOOL
YARD
GAME
OF
ROCK
PAPER
SCISSORS
CAN
BE
DESCRIBED
BY
THE
MATHEMATICAL
GAME
SHOWN
IN
FIGURE
THERE
ARE
TWO
PLAYERS
ONE
CHOOSING
A
ROW
AND
ONE
CHOOSING
A
COLUMN
THE
CHOICES
OF
A
PLAYER
ARE
HIS
HER
ACTIONS
ONCE
THE
TWO
PLAYERS
CHOOSE
SIMULTANEOUSLY
AN
ACTION
THEY
RECEIVE
THE
CORRESPONDING
PAYOFFS
SHOWN
IN
THE
TABLE
THE
FIRST
NUMBER
DENOTES
THE
PAYOFF
OF
ROW
THE
SEC
OND
THAT
OF
COLUMN
NOTICE
THAT
EACH
OF
THESE
PAIRS
OF
NUMBERS
SUM
TO
ZERO
IN
THE
CASE
OF
FIGURE
SUCH
GAMES
A
FULL
VERSION
OF
THIS
PAPER
IS
TO
APPEAR
IN
SICOMP
PERMISSION
TO
MAKE
DIGITAL
OR
HARD
COPIES
OF
ALL
OR
PART
OF
THIS
WORK
FOR
PERSONAL
OR
CLASSROOM
USE
IS
GRANTED
WITHOUT
FEE
PROVIDED
THAT
COPIES
ARE
NOT
MADE
OR
DISTRIBUTED
FOR
PROFIT
OR
COMMERCIAL
ADVANTAGE
AND
THAT
COPIES
BEAR
THIS
NOTICE
AND
THE
FULL
CITATION
ON
THE
FIRST
PAGE
TO
COPY
OTHERWISE
TO
REPUBLISH
TO
POST
ON
SERVERS
OR
TO
REDISTRIBUTE
TO
LISTS
REQUIRES
PRIOR
SPECIFIC
PERMISSION
AND
OR
A
FEE
COPYRIGHT
ACM
ARE
CALLED
ZERO
SUM
GAMES
THREE
OTHER
WELL
KNOWN
GAMES
CALLED
CHICKEN
PRISONER
DILEMMA
AND
PENALTY
SHOT
GAME
RESPECTIVELY
ARE
SHOWN
IN
FIGURE
THE
PENALTY
SHOT
GAME
IS
ZERO
SUM
BUT
THE
OTHER
TWO
ARE
NOT
ALL
THESE
GAMES
HAVE
TWO
PLAYERS
GAME
THEORY
STUDIES
GAMES
WITH
MANY
PLAYERS
BUT
THESE
ARE
HARDER
TO
DISPLAY
FIGURE
ROCK
PAPER
SCISSORS
THE
PURPOSE
OF
GAMES
IS
TO
HELP
US
UNDERSTAND
ECONOMIC
BEHAVIOR
BY
PREDICTING
HOW
PLAYERS
WILL
ACT
IN
EACH
PARTICU
LAR
GAME
THE
PREDICTIONS
GAME
THEORISTS
MAKE
ABOUT
PLAYER
BEHAVIOR
ARE
CALLED
EQUILIBRIA
ONE
SUCH
PREDICTION
IS
THE
PURE
NASH
EQUILIBRIUM
EACH
PLAYER
CHOOSES
AN
ACTION
THAT
IS
A
BEST
RESPONSE
TO
THE
OTHER
PLAYER
CHOICE
I
E
IT
IS
THE
HIGHEST
PAYOFF
FOR
THE
PLAYER
IN
THE
LINE
ROW
OR
COLUMN
CHO
SEN
BY
THE
OTHER
PLAYER
IN
THE
GAME
OF
CHICKEN
IN
FIGURE
A
PURE
NASH
EQUILIBRIUM
IS
WHEN
ONE
PLAYER
CHOOSES
DARE
AND
THE
OTHER
CHOOSES
CHICKEN
IN
THE
PRISONER
DILEMMA
THE
ONLY
PURE
NASH
EQUILIBRIUM
IS
WHEN
BOTH
PLAYERS
CHOOSE
DEFECT
UNFORTUNATELY
NOT
ALL
GAMES
HAVE
A
PURE
NASH
EQUILIB
RIUM
FOR
EXAMPLE
IT
IS
EASY
TO
SEE
THAT
THE
ROCK
PAPER
SCISSORS
GAME
IN
FIGURE
HAS
NONE
THIS
LACK
OF
UNIVERSALITY
IS
AN
IMPORTANT
DEFECT
OF
THE
CONCEPT
OF
PURE
NASH
EQUILIB
RIUM
AS
A
PREDICTOR
OF
BEHAVIOR
BUT
THE
ROCK
PAPER
SCISSORS
GAME
DOES
HAVE
A
MORE
SOPHISTICATED
KIND
OF
EQUILIBRIUM
CALLED
A
MIXED
NASH
EQUILIBRIUM
AND
IN
FACT
ONE
THAT
IS
FA
MILIAR
TO
ALL
WHO
HAVE
PLAYED
THIS
GAME
BOTH
PLAYERS
PICK
AN
ACTION
UNIFORMLY
AT
RANDOM
THAT
IS
A
MIXED
NASH
EQUI
LIBRIUM
IS
A
PROBABILISTIC
DISTRIBUTION
ON
THE
SET
OF
ACTIONS
OF
EACH
PLAYER
EACH
OF
THE
DISTRIBUTIONS
SHOULD
HAVE
THE
PROP
ERTY
THAT
IT
IS
A
BEST
RESPONSE
TO
THE
OTHER
DISTRIBUTIONS
THIS
MEANS
THAT
EACH
ACTION
ASSIGNED
POSITIVE
PROBABILITY
IS
AMONG
THE
ACTIONS
THAT
ARE
BEST
RESPONSES
IN
EXPECTATION
TO
THE
DISTRIBUTION
CHOSEN
BY
THE
OPPONENT
ABOUT
GAMES
SUCH
AS
CHESS
WE
CAN
CAPTURE
THIS
AND
OTHER
SIMILAR
GAMES
IN
THE
PRESENT
FRAMEWORK
BY
CONSIDERING
TWO
PLAYERS
BLACK
AND
WHITE
EACH
WITH
A
HUGE
ACTION
SET
CONTAINING
ALL
POSSIBLE
MAPS
FROM
POSITIONS
TO
MOVES
BUT
OF
COURSE
SUCH
FORMALISM
IS
NOT
VERY
HELPFUL
FOR
ANALYZING
CHESS
AND
SIMILAR
GAMES
FIGURE
THREE
OTHER
PLAYER
GAMES
IN
JOHN
NASH
PROVED
THAT
ALL
GAMES
HAVE
A
MIXED
NASH
EQUILIBRIUM
THAT
IS
IN
ANY
GAME
DISTRIBUTIONS
OVER
THE
PLAYERS
ACTIONS
EXIST
SUCH
THAT
EACH
IS
A
BEST
RE
SPONSE
TO
WHAT
EVERYBODY
ELSE
IS
DOING
THIS
IMPORTANT
AND
FAR
FROM
OBVIOUS
UNIVERSALITY
THEOREM
ESTABLISHED
THE
MIXED
NASH
EQUILIBRIUM
AS
GAME
THEORY
CENTRAL
EQUILIB
RIUM
CONCEPT
THE
BASELINE
AND
GOLD
STANDARD
AGAINST
WHICH
ALL
SUBSEQUENT
REFINEMENTS
AND
COMPETING
EQUILIBRIUM
CON
CEPTS
WERE
JUDGED
UNIVERSALITY
IS
A
DESIRABLE
ATTRIBUTE
FOR
AN
EQUILIBRIUM
CON
CEPT
OF
COURSE
SUCH
A
CONCEPT
MUST
ALSO
BE
NATURAL
AND
CREDIBLE
AS
A
PREDICTION
OF
BEHAVIOR
BY
A
GROUP
OF
AGENTS
FOR
EXAMPLE
PURE
NASH
SEEMS
PREFERABLE
TO
MIXED
NASH
IN
GAMES
THAT
DO
HAVE
A
PURE
NASH
EQUILIBRIUM
BUT
THERE
IS
A
THIRD
IMPORTANT
DESIDERATUM
ON
EQUILIBRIUM
CONCEPTS
OF
A
COMPUTATIONAL
NATURE
AN
EQUILIBRIUM
CONCEPT
SHOULD
BE
EFFICIENTLY
COMPUTABLE
IF
IT
IS
TO
BE
TAKEN
SERIOUSLY
AS
A
PREDICTION
OF
WHAT
A
GROUP
OF
AGENTS
WILL
DO
BECAUSE
IF
COMPUTING
A
PARTICULAR
KIND
OF
EQUILIBRIUM
IS
AN
INTRACTABLE
PROBLEM
OF
THE
KIND
THAT
TAKE
LIFETIMES
OF
THE
UNIVERSE
TO
SOLVE
ON
THE
WORLD
FASTEST
COMPUTERS
IT
IS
LUDICROUS
TO
EX
SEARCHERS
HAVE
SOUGHT
ALGORITHMS
FOR
FINDING
MIXED
NASH
EQUILIBRIA
THAT
IS
FOR
SOLVING
THE
COMPUTATIONAL
PROBLEM
WHICH
WE
WILL
CALL
NASH
IN
THIS
PAPER
IF
A
GAME
IS
ZERO
SUM
LIKE
THE
ROCK
PAPER
SCISSORS
GAME
THEN
IT
FOLLOWS
FROM
THE
WORK
OF
JOHN
VON
NEUMANN
IN
THE
THAT
NASH
CAN
BE
FORMULATED
IN
TERMS
OF
LINEAR
PROGRAMMING
A
SUBJECT
IDENTIFIED
BY
GEORGE
DANTZIG
IN
THE
LINEAR
PROGRAMS
CAN
BE
SOLVED
EFFICIENTLY
EVEN
THOUGH
WE
ONLY
REALIZED
THIS
IN
THE
BUT
WHAT
ABOUT
GAMES
THAT
ARE
NOT
ZERO
SUM
SEVERAL
ALGORITHMS
HAVE
BEEN
PROPOSED
OVER
THE
PAST
HALF
CENTURY
BUT
ALL
OF
THEM
ARE
EITHER
OF
UNKNOWN
COMPLEXITY
OR
KNOWN
TO
REQUIRE
IN
THE
WORST
CASE
EXPONENTIAL
TIME
DURING
THE
SAME
DECADES
THAT
THESE
CONCEPTS
WERE
BEING
EXPLORED
BY
GAME
THEORISTS
COMPUTER
SCIENCE
THEORISTS
WERE
BUSY
DEVELOPING
INDEPENDENTLY
A
THEORY
OF
ALGORITHMS
AND
COMPLEXITY
ADDRESSING
PRECISELY
THE
KIND
OF
PROBLEM
RAISED
IN
THE
LAST
TWO
PARAGRAPHS
GIVEN
A
COMPUTATIONAL
PROB
LEM
CAN
IT
BE
SOLVED
BY
AN
EFFICIENT
ALGORITHM
FOR
MANY
COMMON
COMPUTATIONAL
TASKS
SUCH
AS
FINDING
A
SOLUTION
OF
A
SET
OF
LINEAR
EQUATIONS
THERE
IS
A
POLYNOMIAL
TIME
ALGO
RITHM
THAT
SOLVES
THEM
THIS
CLASS
OF
PROBLEMS
IS
CALLED
P
FOR
OTHER
SUCH
PROBLEMS
SUCH
AS
FINDING
A
TRUTH
ASSIGNMENT
THAT
SATISFIES
A
SET
OF
BOOLEAN
CLAUSES
A
PROBLEM
KNOWN
AS
SAT
OR
THE
TRAVELING
SALESMAN
PROBLEM
NO
SUCH
ALGORITHM
COULD
BE
FOUND
AFTER
MANY
ATTEMPTS
MANY
OF
THESE
PROB
LEMS
CAN
BE
PROVED
NP
COMPLETE
MEANING
THEY
CANNOT
BE
SOLVED
EFFICIENTLY
UNLESS
P
NP
AN
EVENT
CONSIDERED
VERY
UNLIKELY
FROM
THE
PREVIOUS
DISCUSSION
OF
FAILED
ATTEMPTS
TO
DEVELOP
AN
EFFICIENT
ALGORITHM
FOR
NASH
ONE
MIGHT
BE
TEMPTED
TO
SUPPOSE
THAT
THIS
PROBLEM
TOO
IS
NP
COMPLETE
BUT
THE
SIT
UATION
IS
NOT
THAT
SIMPLE
NASH
IS
UNLIKE
ANY
NP
COMPLETE
PROBLEM
BECAUSE
BY
NASH
THEOREM
IT
IS
GUARANTEED
TO
AL
WAYS
HAVE
A
SOLUTION
IN
CONTRAST
NP
COMPLETE
PROBLEMS
LIKE
SAT
DRAW
THEIR
INTRACTABILITY
FROM
THE
POSSIBILITY
THAT
A
SOLUTION
MIGHT
NOT
EXIST
THIS
POSSIBILITY
IS
USED
HEAVILY
IN
THE
NP
COMPLETENESS
PROOF
SEE
FIGURE
FOR
AN
ARGU
MENT
DUE
TO
NIMROD
MEGIDDO
WHY
IT
IS
VERY
UNLIKELY
THAT
NP
COMPLETENESS
CAN
CHARACTERIZE
THE
COMPLEXITY
OF
NASH
NOTE
HOWEVER
THAT
IF
ONE
SEEKS
A
NASH
EQUILIBRIUM
WITH
ADDITIONAL
PROPERTIES
SUCH
AS
THE
ONE
THAT
MAXIMIZES
THE
SUM
OF
PLAYER
UTILITIES
OR
ONE
THAT
USES
A
GIVEN
STRATEGY
WITH
POSITIVE
PROBABILITY
THEN
THE
PROBLEM
DOES
BECOME
NP
COMPLETE
SINCE
NP
COMPLETENESS
IS
NOT
AN
OPTION
TO
UNDERSTAND
THE
COMPLEXITY
OF
NASH
ONE
MUST
ESSENTIALLY
START
ALL
OVER
IN
THE
PATH
THAT
LED
US
TO
NP
COMPLETENESS
WE
MUST
DEFINE
A
CLASS
OF
PROBLEMS
WHICH
CONTAINS
ALONG
WITH
NASH
SOME
OTHER
WELL
KNOWN
HARD
PROBLEMS
AND
THEN
PROVE
THAT
NASH
IS
COMPLETE
FOR
THAT
CLASS
INDEED
IN
THIS
PAPER
WE
DESCRIBE
A
PROOF
THAT
NASH
IS
PPAD
COMPLETE
WHERE
PPAD
IS
A
SUBCLASS
OF
NP
THAT
CONTAINS
SEVERAL
IMPORTANT
PROBLEMS
THAT
ARE
SUSPECTED
TO
BE
HARD
INCLUDING
NASH
PECT
THAT
IT
CAN
BE
ARRIVED
AT
IN
REAL
LIFE
THIS
CONSIDERATION
SUGGESTS
THE
FOLLOWING
IMPORTANT
QUESTION
IS
THERE
AN
EF
FICIENT
ALGORITHM
FOR
COMPUTING
A
MIXED
NASH
EQUILIBRIUM
IN
THIS
ARTICLE
WE
REPORT
ON
RESULTS
THAT
INDICATE
THAT
THE
ANSWER
IS
NEGATIVE
OUR
OWN
WORK
OBTAINED
THIS
FOR
GAMES
WITH
OR
MORE
PLAYERS
AND
SHORTLY
AFTERWARDS
THE
PAPERS
EXTENDED
THIS
UNEXPECTEDLY
TO
THE
IM
PORTANT
CASE
OF
PLAYER
GAMES
EVER
SINCE
NASH
PAPER
WAS
PUBLISHED
IN
MANY
RE
BUT
WHAT
ABOUT
THE
TRAVELING
SALESMAN
PROBLEM
ONE
MIGHT
ASK
DOESN
T
IT
ALWAYS
HAVE
A
SOLUTION
TO
COM
PARE
FAIRLY
THE
TRAVELING
SALESMAN
PROBLEM
WITH
SAT
AND
NASH
ONE
HAS
TO
FIRST
TRANSFORM
IT
INTO
A
SEARCH
PROBLEM
OF
THE
FORM
GIVEN
A
DISTANCE
MATRIX
AND
A
BUDGET
B
FIND
A
TOUR
THAT
IS
CHEAPER
THAN
B
OR
REPORT
THAT
NONE
EXISTS
NO
TICE
THAT
AN
INSTANCE
OF
THIS
PROBLEM
MAY
OR
MAY
NOT
HAVE
A
SOLUTION
BUT
AN
EFFICIENT
ALGORITHM
FOR
THIS
PROBLEM
COULD
BE
USED
TO
FIND
AN
OPTIMAL
TOUR
KNOW
OF
EFFICIENT
ALGORITHMS
THAT
SOLVE
THE
PROBLEM
WHEREAS
FOR
NASH
EQUILIBRIA
WE
DO
NOT
WE
ARE
NOW
READY
TO
DEFINE
THE
COMPUTATIONAL
PROBLEM
NASH
GIVEN
THE
DESCRIPTION
OF
A
GAME
BY
EXPLICITLY
GIV
ING
THE
UTILITY
OF
EACH
PLAYER
CORRESPONDING
TO
EACH
STRAT
EGY
PROFILE
AND
A
RATIONAL
NUMBER
E
COMPUTE
AN
E
APPROXIMATE
NASH
EQUILIBRIUM
THIS
SHOULD
BE
AT
LEAST
AS
TRACTABLE
AS
FINDING
AN
EXACT
EQUILIBRIUM
HENCE
ANY
HARD
NESS
RESULT
FOR
APPROXIMATE
EQUILIBRIA
CARRIES
OVER
TO
EXACT
EQUILIBRIA
NOTE
THAT
AN
APPROXIMATE
EQUILIBRIUM
AS
DE
FINED
ABOVE
NEED
NOT
BE
AT
ALL
CLOSE
TO
AN
EXACT
EQUILIBRIUM
SEE
FOR
A
COMPLEXITY
THEORY
OF
EXACT
NASH
EQUILIBRIA
FIGURE
MEGIDDO
PROOF
THAT
NASH
IS
UNLIKELY
TO
BE
NP
COMPLETE
PROBLEM
STATEMENT
NASH
AND
APPROXI
MATE
NASH
EQUILIBRIA
A
GAME
IN
NORMAL
FORM
HAS
SOME
NUMBER
K
OF
PLAYERS
AND
FOR
EACH
PLAYER
P
P
K
A
FINITE
SET
SP
OF
PURE
ACTIONS
OR
STRATEGIES
THE
SET
OF
PURE
STRATEGY
PROFILES
IS
THE
CARTESIAN
PRODUCT
OF
THE
SP
THUS
A
PURE
STRATEGY
PROFILE
REPRESENTS
A
CHOICE
FOR
EACH
PLAYER
OF
ONE
OF
HIS
ACTIONS
FINALLY
FOR
EACH
PLAYER
P
AND
THE
GAME
WILL
SPECIFY
A
PAYOFF
OR
UTILITY
UP
WHICH
IS
THE
VALUE
OF
THE
OUTCOME
TO
PLAYER
P
WHEN
ALL
THE
PLAYERS
INCLUDING
P
CHOOSE
THE
STRATE
GIES
IN
IN
A
NASH
EQUILIBRIUM
PLAYERS
CHOOSE
PROBABILITY
DISTRIBUTIONS
OVER
THEIR
SP
CALLED
MIXED
STRATEGIES
SO
THAT
NO
PLAYER
CAN
DEVIATE
FROM
HIS
MIXED
STRATEGY
AND
IMPROVE
ON
HIS
EXPECTED
PAYOFF
SEE
FIGURE
FOR
DETAILS
FOR
TWO
PLAYER
GAMES
THE
NUMERICAL
QUANTITIES
THAT
DEFINE
A
NASH
EQUILIBRIUM
I
E
THE
PROBABILITIES
USED
BY
THE
PLAY
ERS
ARE
RATIONAL
NUMBERS
ASSUMING
THE
UTILITIES
ARE
ALSO
RATIONAL
SO
IT
IS
CLEAR
HOW
TO
WRITE
DOWN
THE
SOLUTION
OF
A
PLAYER
GAME
HOWEVER
AS
POINTED
OUT
IN
NASH
ORIGINAL
PAPER
WHEN
THERE
ARE
MORE
THAN
TWO
PLAYERS
THERE
MAY
BE
ONLY
IRRATIONAL
SOLUTIONS
IN
THIS
GENERAL
SITUATION
THE
PROB
LEM
OF
COMPUTING
A
NASH
EQUILIBRIUM
HAS
TO
DEAL
WITH
ISSUES
OF
NUMERICAL
ACCURACY
THUS
WE
INTRODUCE
NEXT
THE
CONCEPT
OF
APPROXIMATE
NASH
EQUILIBRIUM
IF
NASH
EQUILIBRIUM
MEANS
NO
INCENTIVE
TO
DEVIATE
THEN
APPROXIMATE
NASH
EQUILIBRIUM
STANDS
FOR
LOW
INCENTIVE
TO
DEVIATE
SPECIFICALLY
IF
E
IS
A
SMALL
POSITIVE
QUANTITY
WE
CAN
DEFINE
AN
E
NASH
EQUILIBRIUM
AS
A
PROFILE
OF
MIXED
STRATEGIES
WHERE
ANY
PLAYER
CAN
IMPROVE
HIS
EXPECTED
PAYOFF
BY
AT
MOST
E
BY
SWITCHING
TO
ANOTHER
STRATEGY
FIGURE
GIVES
A
PRECISE
DEFINITION
AND
SHOWS
HOW
THE
PROBLEM
REDUCES
TO
SOLVING
A
SET
OF
ALGEBRAIC
INEQUALITIES
OUR
FOCUS
ON
APPROXIMATE
SO
LUTIONS
IS
ANALOGOUS
TO
THE
SIMPLER
PROBLEM
OF
POLYNOMIAL
ROOT
FINDING
SUPPOSE
THAT
WE
ARE
GIVEN
A
POLYNOMIAL
F
WITH
A
SINGLE
VARIABLE
AND
WE
HAVE
TO
FIND
A
REAL
ROOT
A
REAL
NUMBER
R
SATISFYING
F
R
IN
GENERAL
A
SOLUTION
TO
THIS
PROBLEM
THE
NUMBER
R
CANNOT
BE
WRITTEN
DOWN
AS
A
FRACTION
SO
WE
SHOULD
REALLY
BE
ASKING
FOR
SOME
SORT
OF
NUMERICAL
APPROXIMATION
TO
R
FOR
EXAMPLE
COMPUTING
A
RA
TIONAL
NUMBER
R
SUCH
THAT
F
R
E
FOR
SOME
SMALL
E
IF
F
HAPPENS
TO
HAVE
ODD
DEGREE
WE
CAN
EVEN
SAY
IN
ADVANCE
THAT
A
SOLUTION
MUST
EXIST
IN
A
FURTHER
ANALOGY
WITH
NASH
OF
COURSE
THE
ANALOGY
BREAKS
DOWN
IN
THAT
FOR
ROOT
FINDING
WE
FIGURE
WRITING
DOWN
THE
PROBLEM
ALGEBRAICALLY
TOTAL
SEARCH
PROBLEMS
WE
THINK
OF
NP
AS
THE
CLASS
OF
SEARCH
PROBLEMS
OF
THE
FORM
GIVEN
AN
INPUT
FIND
A
SOLUTION
WHICH
THEN
CAN
BE
EASILY
CHECKED
OR
REPORT
THAT
NONE
EXISTS
THERE
IS
AN
ASYMMETRY
BETWEEN
THESE
OUTCOMES
IN
THAT
NONE
EXISTS
IS
NOT
REQUIRED
TO
BE
EASY
TO
VERIFY
WE
CALL
SUCH
A
SEARCH
PROBLEM
TOTAL
IF
THE
SOLUTION
AL
WAYS
EXISTS
THERE
ARE
MANY
APPARENTLY
HARD
TOTAL
SEARCH
PROBLEMS
IN
NP
EVEN
THOUGH
AS
WE
ARGUED
IN
THE
INTRO
DUCTION
THEY
ARE
UNLIKELY
TO
BE
NP
COMPLETE
PERHAPS
THE
BEST
KNOWN
IS
FACTORING
THE
PROBLEM
OF
TAKING
AN
INTEGER
AS
AN
INPUT
AND
OUTPUTTING
ITS
PRIME
FACTORS
NASH
AND
SEVERAL
OTHER
PROBLEMS
INTRODUCED
BELOW
ARE
ALSO
TOTAL
A
USEFUL
CLASSIFICATION
OF
TOTAL
SEARCH
PROBLEMS
WAS
PRO
POSED
IN
THE
IDEA
IS
THIS
IF
A
PROBLEM
IS
TOTAL
THE
FACT
THAT
EVERY
INSTANCE
HAS
A
SOLUTION
MUST
HAVE
A
MATHEMATICAL
PROOF
UNLESS
THE
PROBLEM
CAN
BE
EASILY
SOLVED
EFFICIENTLY
IN
THAT
PROOF
THERE
MUST
BE
A
NON
CONSTRUCTIVE
STEP
IT
TURNS
OUT
THAT
FOR
ALL
KNOWN
TOTAL
SEARCH
PROBLEMS
IN
THE
FRINGES
OF
P
THESE
NON
CONSTRUCTIVE
STEPS
ARE
ONE
OF
VERY
FEW
SIMPLE
ARGUMENTS
IF
A
GRAPH
HAS
A
NODE
OF
ODD
DEGREE
THEN
IT
MUST
HAVE
ANOTHER
THIS
IS
THE
PARITY
ARGUMENT
GIVING
RISE
TO
THE
CLASS
PPA
IF
A
DIRECTED
GRAPH
HAS
AN
UNBALANCED
NODE
A
VER
TEX
WITH
DIFFERENT
IN
DEGREE
AND
OUT
DEGREE
THEN
IT
MUST
HAVE
ANOTHER
THIS
IS
THE
PARITY
ARGUMENT
FOR
DIRECTED
GRAPHS
GIVING
RISE
TO
THE
CLASS
PPAD
CONSID
ERED
IN
THIS
ARTICLE
FIGURE
DESCRIBES
THE
CORRESPOND
ING
SEARCH
PROBLEMS
EVERY
DIRECTED
ACYCLIC
GRAPH
MUST
HAVE
A
SINK
THE
CORRESPONDING
CLASS
IS
CALLED
PLS
FOR
POLYNOMIAL
LOCAL
SEARCH
IF
A
FUNCTION
MAPS
N
ELEMENTS
TO
N
ELEMENTS
THEN
THERE
IS
A
COLLISION
THIS
IS
THE
PIGEONHOLE
PRINCIPLE
AND
THE
CORRESPONDING
CLASS
IS
PPP
WE
PROCEED
WITH
DEFINING
MORE
PRECISELY
THE
SECOND
CLASS
IN
THE
LIST
ABOVE
THE
CLASS
PPAD
THERE
ARE
TWO
EQUIVALENT
WAYS
TO
DEFINE
NP
FIRST
IT
IS
THE
CLASS
OF
ALL
SEARCH
PROBLEMS
WHOSE
ANSWERS
ARE
VERIFIABLE
IN
POLYNOMIAL
TIME
FOR
EXAMPLE
THE
SEARCH
PROBLEM
SAT
GIVEN
A
BOOLEAN
FORMULA
IN
CNF
FIND
A
SATISFYING
TRUTH
ASSIGNMENT
OR
REPORT
THAT
NONE
EXISTS
IS
IN
NP
BECAUSE
IT
IS
EASY
TO
CHECK
WHETHER
A
TRUTH
ASSIGNMENT
SATISFIES
A
CNF
SINCE
WE
KNOW
THAT
SAT
IS
NP
COMPLETE
WE
CAN
ALSO
DEFINE
NP
AS
THE
CLASS
OF
ALL
PROBLEMS
THAT
CAN
BE
REDUCED
INTO
INSTANCES
OF
SAT
BY
REDUCE
WE
REFER
TO
THE
USUAL
FORM
OF
POLYNOMIAL
TIME
REDUCTION
FROM
SEARCH
PROBLEM
A
TO
SEARCH
PROBLEM
B
AN
EFFICIENT
ALGORITHM
FOR
TRANSFORMING
ANY
INSTANCE
OF
A
TO
AN
EQUIVALENT
INSTANCE
OF
B
TOGETHER
FIGURE
END
OF
THE
LINE
AN
APPARENTLY
HARD
TOTAL
SEARCH
PROBLEM
OF
THE
LINE
AND
THEREFORE
ALL
PROBLEMS
IN
PPAD
CAN
BE
REDUCED
TO
IT
WHY
SHOULD
WE
BELIEVE
THAT
PPAD
CONTAINS
HARD
PROBLEMS
IN
THE
ABSENCE
OF
A
PROOF
THAT
P
NP
WE
CANNOT
HOPE
TO
BE
SURE
THAT
PPAD
CONTAINS
HARD
PROBLEMS
THE
REASON
IS
THAT
PPAD
LIES
BETWEEN
P
AND
NP
IN
THE
SENSE
THAT
IF
P
NP
THEN
PPAD
ITSELF
AS
A
SUBSET
OF
NP
WILL
BE
WITH
AN
EFFICIENT
ALGORITHM
FOR
TRANSLATING
ANY
SOLUTION
OF
THE
EQUAL
TO
P
BUT
EVEN
IF
P
NP
IT
MAY
STILL
BE
THE
CASE
INSTANCE
OF
B
BACK
TO
A
SOLUTION
OF
THE
ORIGINAL
INSTANCE
OF
A
WE
DEFINE
THE
CLASS
PPAD
USING
THE
SECOND
STRATEGY
IN
PARTICULAR
PPAD
IS
THE
CLASS
OF
ALL
SEARCH
PROBLEMS
THAT
CAN
BE
REDUCED
TO
THE
PROBLEM
END
OF
THE
LINE
DEFINED
IN
FIGURE
NOTE
THAT
SINCE
END
OF
THE
LINE
IS
A
TOTAL
PROBLEM
SO
ARE
ALL
PROBLEMS
IN
PPAD
PROCEEDING
NOW
IN
ANALOGY
WITH
NP
WE
CALL
A
PROBLEM
PPAD
COMPLETE
IF
END
THAT
PPAD
COMPLETE
PROBLEMS
ARE
EASY
TO
SOLVE
WE
BE
LIEVE
THAT
PPAD
COMPLETE
PROBLEMS
ARE
HARD
FOR
THE
SAME
REASONS
OF
COMPUTATIONAL
AND
MATHEMATICAL
EXPERIENCE
THAT
CONVINCE
US
THAT
NP
COMPLETE
PROBLEMS
ARE
HARD
BUT
AS
WE
MENTIONED
OUR
CONFIDENCE
IS
NECESSARILY
A
LITTLE
WEAKER
PPAD
CONTAINS
MANY
PROBLEMS
FOR
WHICH
RESEARCHERS
HAVE
TRIED
FOR
DECADES
TO
DEVELOP
EFFICIENT
ALGORITHMS
IN
THE
NEXT
SECTION
WE
INTRODUCE
ONE
SUCH
PROBLEM
CALLED
BROUWER
HOWEVER
END
OF
THE
LINE
ITSELF
IS
A
PRETTY
CONVINCINGLY
HARD
PROBLEM
HOW
CAN
ONE
HOPE
TO
DEVISE
AN
ALGORITHM
THAT
TELESCOPES
EXPONENTIALLY
LONG
PATHS
IN
EVERY
IMPLICITLY
GIVEN
GRAPH
FROM
NASH
TO
PPAD
OUR
MAIN
RESULT
IS
THE
FOLLOWING
THEOREM
NASH
IS
PPAD
COMPLETE
IN
THE
REMAINDER
OF
THIS
ARTICLE
WE
OUTLINE
THE
MAIN
IDEAS
OF
THE
PROOF
FOR
FULL
DETAILS
SEE
WE
NEED
TO
PROVE
TWO
THINGS
FIRST
THAT
NASH
IS
IN
PPAD
THAT
IS
IT
CAN
BE
RE
DUCED
TO
END
OF
THE
LINE
SECOND
SEE
SECTION
THAT
IT
IS
COMPLETE
THE
REVERSE
REDUCTION
AS
IT
TURNS
OUT
BOTH
DIREC
TIONS
ARE
ESTABLISHED
THROUGH
A
COMPUTATIONAL
PROBLEM
IN
SPIRED
BY
A
FUNDAMENTAL
RESULT
IN
TOPOLOGY
CALLED
BROUWER
FIXED
POINT
THEOREM
DESCRIBED
NEXT
BROUWER
FIXED
POINTS
IMAGINE
A
CONTINUOUS
FUNCTION
MAPPING
A
CIRCLE
TOGETHER
WITH
ITS
INTERIOR
TO
ITSELF
FOR
EXAMPLE
A
ROTATION
AROUND
THE
CENTER
NOTICE
THAT
THE
CENTER
IS
FIXED
IT
HASN
T
MOVED
UNDER
THIS
FUNCTION
YOU
COULD
FLIP
THE
CIRCLE
BUT
THEN
ALL
POINTS
ON
A
DIAGONAL
WOULD
STAY
PUT
OR
YOU
COULD
DO
SOME
THING
MORE
ELABORATE
SHRINK
THE
CIRCLE
TRANSLATE
IT
SO
IT
STILL
LIES
WITHIN
THE
ORIGINAL
LARGER
CIRCLE
AND
THEN
ROTATE
IT
A
LITTLE
THOUGHT
REVEALS
THAT
THERE
IS
STILL
AT
LEAST
ONE
FIXED
POINT
OR
STRETCH
AND
COMPRESS
THE
CIRCLE
LIKE
A
SHEET
OF
RUB
BER
ANY
WAY
YOU
WANT
AND
STICK
IT
ON
THE
ORIGINAL
CIRCLE
STILL
POINTS
WILL
BE
FIXED
UNLESS
OF
COURSE
YOU
TEAR
THE
CIRCLE
THE
FUNCTION
MUST
BE
CONTINUOUS
THERE
IS
A
TOPOLOGICAL
REASON
WHY
YOU
CAN
T
MAP
CONTINUOUSLY
THE
CIRCLE
ON
ITSELF
WITHOUT
LEAVING
A
POINT
UNMOVED
AND
THAT
BROUWER
THEOREM
IT
STATES
THAT
ANY
CONTINUOUS
MAP
FROM
A
COMPACT
THAT
IS
CLOSED
AND
BOUNDED
AND
CONVEX
THAT
IS
WITHOUT
HOLES
SUBSET
OF
THE
EUCLIDEAN
SPACE
INTO
ITSELF
ALWAYS
HAS
A
FIXED
POINT
BROUWER
THEOREM
IMMEDIATELY
SUGGESTS
AN
INTERESTING
COMPUTATIONAL
TOTAL
SEARCH
PROBLEM
CALLED
BROUWER
GIVEN
A
CONTINUOUS
FUNCTION
FROM
SOME
COMPACT
AND
CONVEX
SET
TO
ITSELF
FIND
A
FIXED
POINT
BUT
OF
COURSE
FOR
A
MEANINGFUL
DEF
INITION
OF
BROUWER
WE
NEED
TO
FIRST
ADDRESS
TWO
QUESTIONS
HOW
DO
WE
SPECIFY
A
CONTINUOUS
MAP
FROM
SOME
COMPACT
AND
CONVEX
SET
TO
ITSELF
AND
HOW
DO
WE
DEAL
WITH
IRRA
TIONAL
FIXED
POINTS
FIRST
WE
FIX
THE
COMPACT
AND
CONVEX
SET
TO
BE
THE
UNIT
CUBE
M
IN
THE
CASE
OF
MORE
GENERAL
DOMAINS
E
G
THE
CIRCULAR
DOMAIN
DISCUSSED
ABOVE
WE
CAN
TRANSLATE
IT
TO
THIS
SETTING
BY
SHRINKING
THE
CIRCLE
EMBEDDING
IT
INTO
THE
UNIT
SQUARE
AND
EXTENDING
THE
FUNCTION
TO
THE
WHOLE
SQUARE
SO
THAT
NO
NEW
FIXED
POINTS
ARE
INTRODUCED
WE
THEN
ASSUME
THAT
THE
FUNCTION
F
IS
GIVEN
BY
AN
EFFICIENT
ALGORITHM
F
WHICH
FOR
EACH
POINT
X
OF
THE
CUBE
WRITTEN
IN
BINARY
COM
PUTES
F
X
WE
ASSUME
THAT
F
OBEYS
A
LIPSCHITZ
CONDITION
FOR
ALL
M
D
F
F
K
D
WHERE
D
IS
THE
EUCLIDEAN
DISTANCE
AND
K
IS
THE
LIPS
CHITZ
CONSTANT
OF
F
THIS
BENIGN
WELL
BEHAVEDNESS
CONDITION
ENSURES
THAT
APPROXIMATE
FIXED
POINTS
CAN
BE
LOCALIZED
BY
EXAMINING
THE
VALUE
F
X
WHEN
X
RANGES
OVER
A
DISCRETIZED
GRID
OVER
THE
DOMAIN
HENCE
WE
CAN
DEAL
WITH
IRRATIONAL
SO
LUTIONS
IN
A
SIMILAR
MANOEUVRE
AS
WITH
NASH
BY
ONLY
SEEK
ING
APPROXIMATE
FIXED
POINTS
IN
FACT
WE
HAVE
THE
FOLLOWING
STRONG
GUARANTEE
FOR
ANY
E
THERE
IS
AN
E
APPROXIMATE
FIXED
POINT
THAT
IS
A
POINT
X
SUCH
THAT
D
F
X
X
E
WHOSE
COORDINATES
ARE
INTEGER
MULTIPLES
OF
D
WHERE
D
DEPENDS
ON
K
E
AND
THE
DIMENSION
M
IN
THE
ABSENCE
OF
A
LIPSCHITZ
CON
STANT
K
THERE
WOULD
BE
NO
SUCH
GUARANTEE
AND
THE
PROBLEM
OF
COMPUTING
FIXED
POINTS
WOULD
BECOME
INTRACTABLE
FOR
MALLY
THE
PROBLEM
BROUWER
IS
DEFINED
AS
FOLLOWS
BROUWER
AN
EFFICIENT
ALGORITHM
F
FOR
THE
EVALUATION
OF
A
FUNCTION
F
M
M
A
CONSTANT
INPUT
K
SUCH
THAT
F
SATISFIES
AND
THE
DESIRED
ACCURACY
E
OUTPUT
A
POINT
X
SUCH
THAT
D
F
X
X
E
IT
TURNS
OUT
THAT
BROUWER
IS
IN
PPAD
GIVES
A
SIM
ILAR
RESULT
FOR
A
MORE
RESTRICTIVE
CLASS
OF
BROUWER
FUNCTIONS
TO
PROVE
THIS
WE
WILL
NEED
TO
CONSTRUCT
AN
END
OF
THE
LINE
GRAPH
ASSOCIATED
WITH
A
BROUWER
INSTANCE
WE
DO
THIS
BY
CONSTRUCTING
A
MESH
OF
TINY
TRIANGLES
OVER
THE
DOMAIN
WHERE
EACH
TRIANGLE
WILL
BE
A
VERTEX
OF
THE
GRAPH
EDGES
BETWEEN
PAIRS
OF
ADJACENT
TRIANGLES
WILL
BE
DEFINED
WITH
RESPECT
TO
A
COLORING
OF
THE
VERTICES
OF
THE
MESH
VERTICES
GET
COLORED
ACCORDING
TO
THE
DIRECTION
IN
WHICH
F
DISPLACES
THEM
WE
ARGUE
THAT
IF
A
TRIANGLE
VERTICES
GET
ALL
POSSIBLE
COLORS
THEN
F
IS
TRYING
TO
SHIFT
THESE
POINTS
IN
CONFLICTING
DIRECTIONS
AND
WE
MUST
BE
CLOSE
TO
AN
APPROXIMATE
FIXED
POINT
WE
ELAB
ORATE
ON
THIS
IN
THE
NEXT
FEW
PARAGRAPHS
FOCUSING
ON
THE
DIMENSIONAL
CASE
TRIANGULATION
FIRST
WE
SUBDIVIDE
THE
UNIT
SQUARE
INTO
SMALL
SQUARES
OF
SIZE
DETERMINED
BY
E
AND
K
AND
THEN
DIVIDE
EACH
LIT
TLE
SQUARE
INTO
TWO
RIGHT
TRIANGLES
SEE
FIGURE
IGNORING
FOR
NOW
THE
COLORS
SHADING
AND
ARROWS
IN
THE
M
DIMENSIONAL
CASE
WE
SUBDIVIDE
THE
M
DIMENSIONAL
CUBE
INTO
M
DIMENSIONAL
CUBELETS
AND
WE
SUBDIVIDE
EACH
CUBELET
INTO
THE
M
DIMENSIONAL
ANALOG
OF
A
TRIANGLE
CALLED
AN
M
SIMPLEX
COLORING
WE
COLOR
EACH
VERTEX
X
OF
THE
TRIANGLES
BY
ONE
OF
THREE
COLORS
DEPENDING
ON
THE
DIRECTION
IN
WHICH
F
MAPS
X
IN
TWO
DIMENSIONS
THIS
CAN
BE
TAKEN
TO
BE
THE
ANGLE
BETWEEN
VECTOR
F
X
X
AND
THE
HORIZONTAL
SPECIFICALLY
WE
COLOR
IT
RED
IF
THE
DIRECTION
LIES
BETWEEN
AND
DEGREES
BLUE
IF
IT
RANGES
BETWEEN
AND
DEGREES
AND
YELLOW
OTHERWISE
AS
SHOWN
IN
FIGURE
IF
THE
DIRECTION
IS
DEGREES
WE
ALLOW
EITHER
YELLOW
OR
RED
SIMILARLY
FOR
THE
OTHER
TWO
BORDERLINE
CASES
USING
THE
ABOVE
COLORING
CONVENTION
THE
VERTICES
GET
COLORED
IN
SUCH
A
WAY
THAT
THE
FOLLOWING
PROPERTY
IS
SATISFIED
NONE
OF
THE
VERTICES
ON
THE
LOWER
SIDE
OF
THE
SQUARE
USES
RED
NO
VERTEX
ON
THE
LEFT
SIDE
USES
BLUE
AND
NO
VERTEX
ON
THE
OTHER
TWO
SIDES
USES
YELLOW
FIGURE
SHOWS
A
COLORING
OF
THE
VERTICES
THAT
COULD
RESULT
FROM
THE
FUNCTION
F
IGNORE
THE
ARROWS
AND
THE
SHADING
OF
TRIANGLES
SPERNER
LEMMA
IT
NOW
FOLLOWS
FROM
AN
ELEGANT
RESULT
IN
COMBINATORICS
CALLED
SPERNER
LEMMA
THAT
IN
ANY
COLORING
SATISFYING
PROPERTY
THERE
WILL
BE
AT
LEAST
ONE
SMALL
TRIANGLE
WHOSE
VERTICES
HAVE
ALL
THREE
COLORS
VERIFY
THIS
IN
FIGURE
THE
FIGURE
THE
COLORS
ASSIGNED
TO
THE
DIFFERENT
DIREC
TIONS
OF
F
X
X
THERE
IS
A
TRANSITION
FROM
RED
TO
YELLOW
AT
DEGREES
FROM
YELLOW
TO
BLUE
AT
DE
GREES
AND
FROM
BLUE
TO
RED
AT
DEGREES
TRICHROMATIC
TRIANGLES
ARE
SHADED
BECAUSE
WE
HAVE
CHOSEN
THE
TRIANGLES
TO
BE
SMALL
ANY
VERTEX
OF
A
TRICHROMATIC
TRIAN
GLE
WILL
BE
AN
APPROXIMATE
FIXED
POINT
INTUITIVELY
SINCE
F
SATISFIES
THE
LIPSCHITZ
CONDITION
GIVEN
IN
IT
CANNOT
FLUC
TUATE
TOO
FAST
HENCE
THE
ONLY
WAY
THAT
THERE
CAN
BE
THREE
POINTS
CLOSE
TO
EACH
OTHER
IN
DISTANCE
WHICH
ARE
MAPPED
IN
THREE
DIFFERENT
DIRECTIONS
IS
IF
THEY
ARE
ALL
APPROXIMATELY
FIXED
THE
CONNECTION
WITH
PPAD
IS
THE
PROOF
OF
SPERNER
LEMMA
THINK
OF
ALL
THE
TRIANGLES
CONTAINING
AT
LEAST
ONE
RED
AND
YELLOW
VERTEX
AS
THE
NODES
OF
A
DIRECTED
GRAPH
G
THERE
IS
A
DIRECTED
EDGE
FROM
A
TRIANGLE
T
TO
ANOTHER
TRIANGLE
T
I
IF
T
AND
T
I
SHARE
A
RED
YELLOW
EDGE
WHICH
GOES
FROM
RED
TO
YELLOW
CLOCKWISE
IN
T
SEE
FIGURE
THE
GRAPH
G
THUS
CREATED
CONSISTS
OF
PATHS
AND
CYCLES
SINCE
FOR
EVERY
T
THERE
IS
AT
MOST
ONE
T
I
AND
VICE
VERSA
VERIFY
THIS
IN
FIGURE
NOW
WE
MAY
ALSO
ASSUME
ON
THE
LEFT
SIDE
OF
THE
SQUARE
THERE
IS
ONLY
ONE
CHANGE
FROM
YELLOW
TO
RED
UNDER
THIS
ASSUMPTION
LET
T
BE
THE
UNIQUE
TRIANGLE
CON
TAINING
THE
EDGE
WHERE
THIS
CHANGE
OCCURS
IN
FIGURE
T
IS
MARKED
BY
A
DIAMOND
OBSERVE
THAT
IF
T
IS
NOT
TRICHRO
MATIC
AS
IS
THE
CASE
IN
FIGURE
THEN
THE
PATH
STARTING
AT
T
IS
GUARANTEED
TO
HAVE
A
SINK
SINCE
IT
CANNOT
INTER
SECT
ITSELF
AND
IT
CANNOT
ESCAPE
OUTSIDE
THE
SQUARE
NOTICE
THAT
THERE
IS
NO
RED
YELLOW
EDGE
ON
THE
BOUNDARY
THAT
CAN
BE
CROSSED
OUTWARD
BUT
THE
ONLY
WAY
A
TRIANGLE
CAN
BE
A
SINK
OF
THIS
PATH
IS
IF
THE
TRIANGLE
IS
TRICHROMATIC
THIS
ESTABLISHES
THAT
THERE
IS
AT
LEAST
ONE
TRICHROMATIC
TRIANGLE
THERE
MAY
OF
COURSE
BE
OTHER
TRICHROMATIC
TRIANGLES
WHICH
WOULD
CORRESPOND
TO
ADDITIONAL
SOURCES
AND
SINKS
IN
G
AS
IN
FIGURE
G
IS
A
GRAPH
OF
THE
KIND
IN
FIGURE
TO
FINISH
THE
REDUCTION
FROM
BROUWER
TO
END
OF
THE
LINE
NOTICE
THAT
GIVEN
A
TRIANGLE
IT
IS
EASY
TO
COMPUTE
ITS
COLORS
BY
INVOKING
F
AND
FIND
ITS
NEIGHBORS
IN
G
OR
ITS
SINGLE
NEIGHBOR
IF
IT
IS
TRICHROMATIC
FINALLY
FROM
NASH
TO
BROUWER
TO
FINISH
OUR
PROOF
THAT
NASH
IS
IN
PPAD
WE
NEED
A
REDUCTION
FROM
NASH
TO
BROUWER
SUCH
A
REDUCTION
WAS
ESSENTIALLY
GIVEN
BY
NASH
HIMSELF
IN
HIS
PROOF
SUP
POSE
THAT
THE
PLAYERS
IN
A
GAME
HAVE
CHOSEN
SOME
MIXED
STRATEGIES
UNLESS
THESE
ALREADY
CONSTITUTE
A
NASH
EQUILIB
F
GIVES
RISE
TO
MULTIPLE
YELLOW
RED
ADJACENCIES
ON
THE
LEFT
HAND
SIDE
WE
DEAL
WITH
THIS
SITUATION
BY
ADDING
AN
EXTRA
ARRAY
OF
VERTICES
TO
THE
LEFT
OF
THE
LEFT
SIDE
OF
THE
SQUARE
AND
COLOR
ALL
THESE
VERTICES
RED
EXCEPT
FOR
THE
BOTTOM
ONE
WHICH
WE
COLOR
YELLOW
THIS
ADDITION
DOES
NOT
VIOLATE
AND
DOES
NOT
CREATE
ANY
ADDITIONAL
TRICHROMATIC
TRIANGLES
SINCE
THE
LEFT
SIDE
OF
THE
SQUARE
BEFORE
THE
ADDITION
DID
NOT
CONTAIN
ANY
BLUE
FIGURE
THE
SUBDIVISION
OF
THE
SQUARE
INTO
SMALLER
SQUARES
AND
THE
COLORING
OF
THE
VERTICES
OF
THE
SUBDI
VISION
ACCORDING
TO
THE
DIRECTION
OF
F
X
X
THE
AR
ROWS
CORRESPOND
TO
THE
END
OF
THE
LINE
GRAPH
ON
THE
TRIANGLES
OF
THE
SUBDIVISION
THE
SOURCE
T
IS
MARKED
BY
A
DIAMOND
FIGURE
AN
ILLUSTRATION
OF
NASH
FUNCTION
FN
FOR
THE
PENALTY
SHOT
GAME
THE
HORIZONTAL
AXIS
COR
RESPONDS
TO
THE
PROBABILITY
BY
WHICH
THE
PENALTY
KICKER
KICKS
RIGHT
AND
THE
VERTICAL
AXIS
TO
THE
PROBA
BILITY
BY
WHICH
THE
GOALKEEPER
DIVES
LEFT
THE
ARROWS
SHOW
THE
DIRECTION
AND
MAGNITUDE
OF
FN
X
X
THE
UNIQUE
FIXED
POINT
OF
FN
IS
CORRESPONDING
TO
THE
UNIQUE
MIXED
NASH
EQUILIBRIUM
OF
THE
PENALTY
SHOT
GAME
THE
COLORS
RESPECT
FIGURE
BUT
OUR
PALETTE
HERE
IS
CONTINUOUS
RIUM
SOME
OF
THE
PLAYERS
WILL
BE
UNSATISFIED
AND
WILL
WISH
TO
CHANGE
TO
SOME
OTHER
STRATEGIES
THIS
SUGGESTS
THAT
ONE
CAN
CONSTRUCT
A
PREFERENCE
FUNCTION
FROM
THE
SET
OF
PLAYERS
STRATEGIES
TO
ITSELF
THAT
INDICATES
THE
MOVEMENT
THAT
WILL
BE
MADE
BY
ANY
UNSATISFIED
PLAYERS
AN
EXAMPLE
OF
HOW
SUCH
A
FUNCTION
MIGHT
LOOK
IS
SHOWN
IN
FIGURE
A
FIXED
POINT
OF
SUCH
A
FUNCTION
IS
A
POINT
THAT
IS
MAPPED
TO
ITSELF
A
NASH
EQUILIBRIUM
AND
BROUWER
FIXED
POINT
THEOREM
EXPLAINED
ABOVE
GUARANTEES
THAT
SUCH
A
FIXED
POINT
EXISTS
IN
FACT
IT
CAN
BE
SHOWN
THAT
AN
APPROXIMATE
FIXED
POINT
CORRESPONDS
TO
AN
APPROXIMATE
NASH
EQUILIBRIUM
THEREFORE
NASH
RE
DUCES
TO
BROUWER
FROM
PPAD
BACK
TO
NASH
TO
SHOW
THAT
NASH
IS
COMPLETE
FOR
PPAD
WE
SHOW
HOW
TO
CONVERT
AN
END
OF
THE
LINE
GRAPH
INTO
A
CORRESPONDING
GAME
SO
THAT
FROM
AN
APPROXIMATE
NASH
EQUILIBRIUM
OF
THE
GAME
WE
CAN
EFFICIENTLY
CONSTRUCT
A
CORRESPONDING
END
OF
THE
LINE
WE
DO
THIS
IN
TWO
STAGES
THE
GRAPH
IS
CONVERTED
INTO
A
BROUWER
FUNCTION
WHOSE
DOMAIN
IS
THE
UNIT
DIMENSIONAL
CUBE
THE
BROUWER
FUNCTION
IS
THEN
REPRESENTED
AS
A
GAME
THE
RESULTING
GAME
HAS
TOO
MANY
PLAYERS
THEIR
NUMBER
DE
PENDS
ON
THE
SIZE
OF
THE
CIRCUITS
THAT
COMPUTE
THE
EDGES
OF
THE
END
OF
THE
LINE
GRAPH
AND
SO
THE
FINAL
STEP
OF
THE
PROOF
IS
TO
ENCODE
THIS
GAME
IN
TERMS
OF
ANOTHER
GAME
WITH
THREE
PLAYERS
FROM
PATHS
TO
FIXED
POINTS
THE
PPAD
COMPLETENESS
OF
BROUWER
WE
HAVE
TO
SHOW
HOW
TO
ENCODE
A
GRAPH
G
AS
DESCRIBED
IN
FIGURE
IN
TERMS
OF
A
CONTINUOUS
EASY
TO
COMPUTE
BROUWER
FUNCTION
F
A
VERY
DIFFERENT
LOOKING
MATHEMATICAL
OBJECT
THE
ENCODING
IS
UNFORTUNATELY
RATHER
COMPLICATED
BUT
IS
KEY
TO
THE
PPAD
COMPLETENESS
RESULT
WE
PROCEED
BY
FIRST
USING
THE
DIMENSIONAL
UNIT
CUBE
AS
THE
DOMAIN
OF
THE
FUNCTION
F
NEXT
THE
BEHAVIOR
OF
F
SHALL
BE
DEFINED
IN
TERMS
OF
ITS
BEHAVIOR
ON
A
VERY
FINE
RECTILINEAR
MESH
OF
GRID
POINTS
IN
THE
CUBE
THUS
EACH
GRID
POINT
LIES
AT
THE
CENTER
OF
A
TINY
CUBELET
AND
THE
BEHAVIOR
OF
F
AWAY
FROM
THE
CENTERS
OF
THE
CUBELETS
SHALL
BE
GOTTEN
BY
INTERPOLATION
WITH
THE
CLOSEST
GRID
POINTS
EACH
GRID
POINT
X
SHALL
RECEIVE
ONE
OF
COLORS
THAT
REPRESENT
THE
VALUE
OF
THE
DIMENSIONAL
DISPLACEMENT
VECTOR
F
X
X
THE
POSSIBLE
VECTORS
CAN
BE
CHOSEN
TO
POINT
AWAY
FROM
EACH
OTHER
SUCH
THAT
F
X
X
CAN
ONLY
BE
APPROXIMATELY
ZERO
IN
THE
VICINITY
OF
ALL
COLORS
WE
ARE
NOW
READY
TO
FIT
G
ITSELF
INTO
THE
ABOVE
FRAMEWORK
EACH
OF
THE
VERTICES
OF
G
SHALL
CORRESPOND
WITH
SPECIAL
SITES
IN
THE
CUBE
ONE
OF
WHICH
LIES
ALONG
THE
BOTTOM
LEFT
HAND
EDGE
IN
FIGURE
AND
THE
OTHER
ONE
ALONG
THE
TOP
LEFT
EDGE
WE
USE
LOCATIONS
THAT
ARE
EASY
TO
COMPUTE
FROM
THE
IDENTITY
OF
A
VERTEX
OF
G
WHILE
MOST
OTHER
GRID
POINTS
IN
THE
CUBE
GET
COLOR
FROM
F
AT
ALL
THE
SPECIAL
SITES
A
PARTICULAR
CONFIGURATION
OF
THE
OTHER
COLORS
APPEARS
IF
G
HAS
AN
EDGE
FROM
NODE
U
TO
NODE
V
THEN
F
SHALL
ALSO
COLOR
A
LONG
SEQUENCE
OF
POINTS
BETWEEN
THE
CORRESPONDING
SITES
IN
THE
CUBE
AS
SHOWN
IN
FIGURE
SO
AS
TO
CONNECT
THEM
WITH
SEQUENCES
OF
GRID
POINTS
THAT
GET
COLORS
THE
PRECISE
ARRANGEMENT
OF
THESE
COLORS
CAN
BE
CHOSEN
TO
BE
EASY
TO
COMPUTE
USING
THE
CIRCUITS
P
AND
THAT
DEFINE
G
AND
SUCH
THAT
ALL
COLORS
ARE
ADJACENT
TO
EACH
OTHER
AN
APPROXIMATE
FIXED
POINT
ONLY
AT
SITES
THAT
CORRESPOND
TO
AN
END
OF
THE
LINE
OF
G
HAVING
SHOWN
EARLIER
THAT
BROUWER
IS
IN
PPAD
WE
ES
TABLISH
THE
FOLLOWING
THEOREM
BROUWER
IS
PPAD
COMPLETE
FROM
BROUWER
TO
NASH
THE
PPAD
COMPLETE
CLASS
OF
BROUWER
FUNCTIONS
THAT
WE
IDENTIFIED
ABOVE
HAVE
THE
PROPERTY
THAT
THEIR
FUNCTION
F
CAN
BE
EFFICIENTLY
COMPUTED
USING
ARITHMETIC
CIRCUITS
THAT
ARE
BUILT
UP
USING
A
SMALL
REPERTOIRE
OF
STANDARD
OPERATORS
SUCH
AS
ADDITION
MULTIPLICATION
AND
COMPARISON
THESE
CIRCUITS
CAN
BE
WRITTEN
DOWN
AS
A
DATA
FLOW
GRAPH
WITH
ONE
OF
THESE
OPERATORS
AT
EACH
NODE
IN
ORDER
TO
TRANSFORM
THIS
INTO
A
GAME
WHOSE
NASH
EQUILIBRIA
CORRESPOND
TO
APPROXIMATE
FIXED
POINTS
OF
THE
BROUWER
FUNCTION
WE
INTRODUCE
PLAYERS
FOR
EVERY
NODE
ON
THIS
DATA
FLOW
GRAPH
GAMES
THAT
DO
ARITHMETIC
FIGURE
EMBEDDING
THE
END
OF
THE
LINE
GRAPH
IN
A
CUBE
THE
EMBEDDING
IS
USED
TO
DEFINE
A
CONTINUOUS
FUNCTION
F
WHOSE
APPROXIMATE
FIXED
POINTS
CORRE
SPOND
TO
THE
UNBALANCED
NODES
OF
THE
END
OF
THE
LINE
GRAPH
THE
IDEA
IS
TO
SIMULATE
EACH
ARITHMETIC
GATE
IN
THE
CIRCUIT
BY
A
GAME
AND
THEN
COMPOSE
THE
GAMES
TO
GET
THE
EFFECT
OF
COMPOSING
THE
GATES
THE
WHOLE
CIRCUIT
IS
REPRESENTED
BY
A
GAME
WITH
MANY
PLAYERS
EACH
OF
WHOM
HOLDS
A
VALUE
THAT
IS
COMPUTED
BY
THE
CIRCUIT
WE
GIVE
EACH
PLAYER
TWO
ACTIONS
STOP
AND
GO
TO
SIMULATE
SAY
MULTIPLICATION
OF
TWO
VALUES
WE
CAN
CHOOSE
PAYOFFS
FOR
PLAYERS
X
Y
AND
Z
SUCH
THAT
IN
ANY
NASH
EQUILIBRIUM
THE
PROBABILITY
THAT
Z
REPRESENTING
THE
OUTPUT
OF
THE
MULTIPLICATION
WILL
GO
IS
EQUAL
TO
THE
PRODUCT
OF
THE
PROBABILITIES
THAT
X
AND
Y
WILL
GO
THE
RESULTING
MULTIPLICATION
GADGET
SEE
FIGURE
HAS
A
PLAYER
W
WHO
MEDIATES
BETWEEN
X
Y
AND
Z
THE
DIRECTED
EDGES
SHOW
THE
DIRECT
DEPENDENCIES
AMONG
THE
PLAY
ERS
PAYOFFS
ELSEWHERE
IN
THE
GAME
Z
MAY
INPUT
HIS
VALUE
INTO
OTHER
RELATED
GADGETS
HERE
IS
HOW
WE
DEFINE
PAYOFFS
TO
INDUCE
THE
PLAYERS
TO
IMPLEMENT
MULTIPLICATION
LET
X
Y
Z
AND
W
DENOTE
THE
MIXED
STRATEGIES
GO
PROBABILITIES
OF
X
Y
Z
AND
W
WE
PAY
W
THE
AMOUNT
X
Y
FOR
CHOOSING
STRATEGY
STOP
AND
Z
FOR
CHOOSING
GO
WE
ALSO
PAY
Z
TO
PLAY
THE
OPPOSITE
FROM
PLAYER
W
IT
IS
NOT
HARD
TO
CHECK
THAT
IN
ANY
NASH
EQUILIBRIUM
OF
THE
GAME
THUS
DEFINED
IT
MUST
BE
THE
CASE
THAT
Z
X
Y
FOR
EXAMPLE
IF
Z
X
Y
THEN
W
WOULD
PREFER
STRATEGY
GO
AND
THEREFORE
Z
WOULD
PREFER
STOP
WHICH
WOULD
MAKE
Z
AND
WOULD
VIOLATE
THE
ASSUMPTION
Z
X
Y
HENCE
THE
RULES
OF
THE
GAME
INDUCE
THE
PLAYERS
TO
IMPLEMENT
MULTIPLICATION
IN
THE
CHOICE
OF
THEIR
MIXED
STRATEGIES
BY
CHOOSING
DIFFERENT
SETS
OF
PAYOFFS
WE
COULD
ENSURE
THAT
Z
X
Y
OR
Z
X
IT
IS
A
LITTLE
MORE
CHALLENGING
TO
SIMULATE
THE
COMPARISON
OF
TWO
REAL
VALUES
WHICH
ALSO
IS
NEEDED
TO
SIMULATE
THE
BROUWER
FUNCTION
BELOW
WE
DISCUSS
THAT
ISSUE
IN
MORE
DETAIL
COMPUTING
A
BROUWER
FUNCTION
WITH
GAMES
SUPPOSE
WE
HAVE
A
BROUWER
FUNCTION
F
DEFINED
ON
THE
UNIT
CUBE
INCLUDE
PLAYERS
WHOSE
GO
PROBABILITIES
REPRESENT
A
POINT
X
IN
THE
CUBE
USE
ADDITIONAL
PLAYERS
TO
COMPUTE
F
X
VIA
GADGETS
AS
DESCRIBED
ABOVE
EVENTUALLY
WE
CAN
END
UP
WITH
PLAYERS
WHOSE
GO
PROBA
BILITIES
REPRESENT
F
X
FINALLY
WE
CAN
GIVE
PAYOFFS
TO
AND
THAT
ENSURE
THAT
IN
ANY
NASH
EQUILIBRIUM
THEIR
PROBABILITIES
AGREE
WITH
AND
THEN
IN
ANY
NASH
EQUILIBRIUM
THESE
PROBABILITIES
MUST
BE
A
FIXED
POINT
OF
F
FIGURE
THE
PLAYERS
OF
THE
MULTIPLICATION
GAME
THE
GRAPH
SHOWS
WHICH
PLAYERS
AFFECT
OTHER
PLAYERS
PAYOFFS
THE
BRITTLE
COMPARATOR
PROBLEM
THERE
JUST
ONE
CATCH
OUR
COMPARATOR
GADGET
WHOSE
PUR
POSE
IS
TO
COMPARE
ITS
INPUTS
AND
OUTPUT
A
BINARY
SIGNAL
ACCORDING
TO
THE
OUTCOME
OF
THE
COMPARISON
IS
BRITTLE
IN
THAT
IF
THE
INPUTS
ARE
EQUAL
THEN
IT
OUTPUTS
ANYTHING
THIS
IS
INHERENT
BECAUSE
ONE
CAN
SHOW
THAT
IF
A
NON
BRITTLE
COM
PARATOR
GADGET
EXISTED
THEN
WE
COULD
CONSTRUCT
A
GAME
THAT
HAS
NO
NASH
EQUILIBRIA
CONTRADICTING
NASH
THEOREM
WITH
BRITTLE
COMPARATORS
OUR
COMPUTATION
OF
F
IS
FAULTY
ON
IN
PUTS
THAT
CAUSE
THE
CIRCUIT
TO
MAKE
A
COMPARISON
OF
EQUAL
VALUES
WE
SOLVE
THIS
PROBLEM
BY
COMPUTING
THE
BROUWER
FUNCTION
AT
A
GRID
OF
MANY
POINTS
NEAR
THE
POINT
OF
INTEREST
AND
AVERAGING
THE
RESULTS
WHICH
MAKES
THE
COMPUTATION
RO
BUST
BUT
INTRODUCES
A
SMALL
ERROR
IN
THE
COMPUTATION
OF
F
THEREFORE
THE
CONSTRUCTION
DESCRIBED
ABOVE
APPROXIMATELY
WORKS
AND
THE
THREE
SPECIAL
PLAYERS
OF
THE
GAME
HAVE
TO
PLAY
AN
APPROXIMATE
FIXED
POINT
AT
EQUILIBRIUM
THE
FINAL
STEP
THREE
PLAYERS
THE
GAME
THUS
CONSTRUCTED
HAS
MANY
PLAYERS
THE
NUM
BER
DEPENDS
MAINLY
ON
HOW
COMPLICATED
THE
PROGRAM
FOR
COMPUTING
THE
FUNCTION
F
WAS
AND
TWO
STRATEGIES
FOR
EACH
PLAYER
THIS
PRESENTS
A
PROBLEM
TO
REPRESENT
SUCH
A
GAME
WITH
N
PLAYERS
WE
NEED
NUMBERS
THE
UTILITY
OF
EACH
PLAYER
FOR
EACH
OF
THE
STRATEGY
CHOICES
OF
THE
N
PLAY
ERS
BUT
OUR
GAME
HAS
A
SPECIAL
STRUCTURE
CALLED
A
GRAPHICAL
GAME
SEE
THE
PLAYERS
ARE
VERTICES
OF
A
GRAPH
ESSEN
TIALLY
THE
DATA
FLOW
GRAPH
OF
F
AND
THE
UTILITY
OF
EACH
PLAYER
DEPENDS
ONLY
ON
THE
ACTIONS
OF
ITS
NEIGHBORS
THE
FINAL
STEP
IN
THE
REDUCTION
IS
TO
SIMULATE
THIS
GAME
BY
A
THREE
PLAYER
NORMAL
FORM
GAME
THIS
ESTABLISHES
THAT
NASH
IS
PPAD
COMPLETE
EVEN
IN
THE
CASE
OF
THREE
PLAYERS
THIS
IS
ACCOMPLISHED
AS
FOLLOWS
WE
COLOR
THE
PLAYERS
NODES
OF
THE
GRAPH
BY
THREE
COLORS
SAY
RED
BLUE
AND
YELLOW
SO
THAT
NO
TWO
PLAYERS
WHO
PLAY
TOGETHER
OR
TWO
PLAYERS
WHO
ARE
INVOLVED
IN
A
GAME
WITH
THE
SAME
THIRD
PLAYER
HAVE
THE
SAME
COLOR
IT
TAKES
SOME
TWEAKING
AND
ARGUMENT
TO
MAKE
SURE
THE
NODES
CAN
BE
SO
COLORED
THE
IDEA
IS
NOW
TO
HAVE
THREE
LAWYERS
THE
RED
LAWYER
THE
BLUE
LAWYER
AND
THE
YELLOW
LAWYER
EACH
REPRESENT
ALL
NODES
WITH
THEIR
COLOR
IN
A
GAME
INVOLVING
ONLY
THE
LAWYERS
A
LAWYER
REPRESENTING
M
NODES
HAS
ACTIONS
AND
HIS
MIXED
STRATEGY
A
PROBABILITY
DISTRIBUTION
OVER
THE
ACTIONS
CAN
BE
USED
TO
ENCODE
THE
SIMPLER
STOP
GO
STRATEGIES
OF
THE
M
NODES
SINCE
NO
TWO
ADJACENT
NODES
ARE
COLORED
THE
SAME
COLOR
THE
LAWYERS
CAN
REPRESENT
THEIR
NODES
WITHOUT
A
CONFLICT
OF
INTEREST
AND
SO
A
MIXED
NASH
EQUILIBRIUM
OF
THE
LAWYERS
GAME
WILL
CORRESPOND
TO
A
MIXED
NASH
EQUILIBRIUM
OF
THE
ORIGINAL
GRAPHICAL
GAME
BUT
THERE
IS
A
PROBLEM
WE
NEED
EACH
OF
THE
LAWYERS
TO
ALLOCATE
EQUAL
AMOUNTS
OF
PROBABILITY
TO
THEIR
CUSTOMERS
HOWEVER
WITH
THE
CONSTRUCTION
SO
FAR
IT
MAY
BE
BEST
FOR
A
LAWYER
TO
ALLOCATE
MORE
PROBABILITY
MASS
TO
HIS
MORE
LUCRA
TIVE
CUSTOMERS
WE
TAKE
CARE
OF
THIS
LAST
DIFFICULTY
BY
HAVING
THE
LAWYERS
PLAY
ON
THE
SIDE
AND
FOR
HIGH
STAKES
A
GENER
ALIZATION
OF
THE
ROCK
PAPER
SCISSORS
GAME
OF
FIGURE
ONE
THAT
FORCES
THEM
TO
BALANCE
THE
PROBABILITY
MASS
ALLOCATED
TO
THE
NODES
OF
THE
GRAPH
THIS
COMPLETES
THE
REDUCTION
FROM
GRAPHICAL
GAMES
TO
THREE
PLAYER
GAMES
AND
THE
PROOF
RELATED
TECHNICAL
CONTRIBUTIONS
OUR
PAPER
WAS
PRECEDED
BY
A
NUMBER
OF
IMPORTANT
PAPERS
THAT
DEVELOPED
THE
IDEAS
APPLIED
IN
SCARF
ALGO
RITHM
WAS
PROPOSED
AS
A
GENERAL
METHOD
FOR
FINDING
AP
PROXIMATE
FIXED
POINTS
WHICH
SHOULD
BE
MORE
EFFICIENT
THAN
BRUTE
FORCE
IT
ESSENTIALLY
WORKS
BY
FOLLOWING
THE
LINE
IN
THE
ASSOCIATED
END
OF
THE
LINE
GRAPH
DESCRIBED
IN
SECTION
IN
THE
CONTEXT
OF
GAMES
THE
LEMKE
HOWSON
ALGORITHM
COMPUTES
A
NASH
EQUILIBRIUM
FOR
PLAYER
GAMES
BY
FOLLOW
ING
A
SIMILAR
END
OF
THE
LINE
PATH
THE
SIMILARITY
OF
THESE
ALGORITHMS
AND
THE
TYPE
OF
PARITY
ARGUMENT
USED
IN
SHOWING
THAT
THEY
WORK
INSPIRED
THE
DEFINITION
OF
PPAD
IN
THREE
DECADES
AGO
BUBELIS
CONSIDERED
REDUCTIONS
AMONG
GAMES
AND
SHOWED
HOW
TO
TRANSFORM
ANY
K
PLAYER
GAME
TO
A
PLAYER
GAME
FOR
K
IN
SUCH
A
WAY
THAT
GIVEN
ANY
SOLU
TION
OF
THE
PLAYER
GAME
A
SOLUTION
OF
THE
K
PLAYER
GAME
CAN
BE
RECONSTRUCTED
WITH
SIMPLE
ALGEBRAIC
OPERATIONS
WHILE
HIS
MAIN
INTEREST
WAS
IN
THE
ALGEBRAIC
PROPERTIES
OF
SOLU
TIONS
HIS
REDUCTION
IS
COMPUTATIONALLY
EFFICIENT
OUR
WORK
IMPLIES
THIS
RESULT
BUT
OUR
REDUCTION
IS
DONE
VIA
THE
USE
OF
GRAPHICAL
GAMES
WHICH
ARE
CRITICAL
IN
ESTABLISHING
OUR
PPAD
COMPLETENESS
RESULT
ONLY
A
FEW
MONTHS
AFTER
WE
ANNOUNCED
OUR
RESULT
CHEN
AND
DENG
MADE
THE
FOLLOWING
CLEVER
AND
SURPRISING
OB
SERVATION
THE
GRAPHICAL
GAMES
RESULTING
FROM
OUR
CONSTRUC
TION
ARE
NOT
USING
THE
MULTIPLICATION
OPERATION
EXCEPT
FOR
MULTIPLICATION
BY
A
CONSTANT
AND
THEREFORE
CAN
EVEN
BE
SIM
ULATED
BY
A
TWO
PLAYER
GAME
LEADING
TO
AN
IMPROVEMENT
OF
OUR
HARDNESS
RESULT
FROM
THREE
TO
TWO
PLAYER
GAMES
THIS
RESULT
WAS
UNEXPECTED
ONE
REASON
BEING
THAT
THE
PROBA
BILITIES
THAT
ARISE
IN
A
PLAYER
NASH
EQUILIBRIUM
ARE
ALWAYS
RATIONAL
NUMBERS
WHICH
IS
NOT
THE
CASE
FOR
GAMES
WITH
THREE
OR
MORE
PLAYERS
OUR
RESULTS
IMPLY
THAT
FINDING
AN
E
NASH
EQUILIBRIUM
IS
PPAD
COMPLETE
IF
E
IS
INVERSELY
PROPORTIONAL
TO
AN
EX
PONENTIAL
FUNCTION
OF
THE
GAME
SIZE
CHEN
ET
AL
EX
TENDED
THIS
RESULT
TO
THE
CASE
WHERE
E
IS
INVERSELY
PROPOR
TIONAL
TO
A
POLYNOMIAL
IN
THE
GAME
SIZE
THIS
RULES
OUT
A
FULLY
POLYNOMIAL
TIME
APPROXIMATION
SCHEME
FOR
COMPUTING
APPROXIMATE
EQUILIBRIA
FINALLY
IN
THIS
PAPER
WE
HAVE
FOCUSED
ON
THE
COMPLEXITY
OF
COMPUTING
AN
APPROXIMATE
NASH
EQUILIBRIUM
ETESSAMI
AND
YANNAKAKIS
DEVELOP
A
VERY
INTERESTING
COMPLEXITY
THEORY
OF
THE
PROBLEM
OF
COMPUTING
THE
EXACT
EQUILIBRIUM
OR
OTHER
FIXED
POINTS
A
PROBLEM
THAT
IS
IMPORTANT
IN
APPLICATIONS
OUTSIDE
GAME
THEORY
SUCH
AS
PROGRAM
VERIFICATION
CONCLUSIONS
AND
FUTURE
WORK
OUR
HARDNESS
RESULT
FOR
COMPUTING
A
NASH
EQUILIBRIUM
RAISES
CONCERNS
ABOUT
THE
CREDIBILITY
OF
THE
MIXED
NASH
EQUI
LIBRIUM
AS
A
GENERAL
PURPOSE
FRAMEWORK
FOR
BEHAVIOR
PRE
DICTION
IN
VIEW
OF
THESE
CONCERNS
THE
MAIN
QUESTION
THAT
EMERGES
IS
WHETHER
THERE
EXISTS
A
POLYNOMIAL
TIME
APPROX
IMATION
SCHEME
PTAS
FOR
COMPUTING
APPROXIMATE
NASH
EQUILIBRIA
THAT
IS
IS
THERE
AN
ALGORITHM
FOR
E
NASH
EQUI
LIBRIA
WHICH
RUNS
IN
TIME
POLYNOMIAL
IN
THE
GAME
SIZE
IF
WE
ALLOW
ARBITRARY
DEPENDENCE
OF
ITS
RUNNING
TIME
ON
E
SUCH
AN
ALGORITHM
WOULD
GO
A
LONG
WAY
TOWARDS
ALLEVIATING
THE
NEGATIVE
IMPLICATIONS
OF
OUR
COMPLEXITY
RESULT
WHILE
THIS
QUESTION
REMAINS
OPEN
ONE
MAY
FIND
HOPE
AT
LEAST
FOR
GAMES
WITH
A
FEW
PLAYERS
IN
THE
EXISTENCE
OF
A
SUB
EXPONENTIAL
AL
GORITHM
RUNNING
IN
TIME
O
NLOG
N
WHERE
N
IS
THE
SIZE
OF
THE
GAME
HOW
ABOUT
CLASSES
OF
CONCISELY
REPRESENTED
GAMES
WITH
MANY
PLAYERS
FOR
A
CLASS
OF
TREE
LIKE
GRAPHICAL
GAMES
A
PTAS
HAS
BEEN
GIVEN
IN
BUT
THE
COMPLEXITY
OF
THE
PROB
LEM
IS
UNKNOWN
FOR
MORE
GENERAL
LOW
DEGREE
GRAPHS
FINALLY
ANOTHER
POSITIVE
RECENT
DEVELOPMENT
HAS
BEEN
A
PTAS
FOR
A
BROAD
AND
IMPORTANT
CLASS
OF
GAMES
CALLED
ANONYMOUS
THESE
ARE
GAMES
IN
WHICH
THE
PLAYERS
ARE
OBLIVIOUS
TO
EACH
OTHER
IDENTITIES
THAT
IS
EACH
PLAYER
IS
AFFECTED
NOT
BY
WHO
PLAYS
EACH
STRATEGY
BUT
BY
HOW
MANY
PLAY
EACH
STRATEGY
ANONYMOUS
GAMES
ARISE
IN
MANY
SETTINGS
INCLUDING
NETWORK
CONGESTION
MARKETS
AND
SOCIAL
INTERACTIONS
AND
SO
IT
IS
RE
ASSURING
THAT
IN
THESE
GAMES
APPROXIMATE
NASH
EQUILIBRIA
CAN
BE
COMPUTED
EFFICIENTLY
AN
ALTERNATIVE
FORM
OF
COMPUTATIONAL
HARDNESS
EXEMPLI
FIED
IN
ARISES
WHERE
INSTEAD
OF
IDENTIFYING
PROBLEMS
THAT
ARE
RESISTANT
TO
ANY
EFFICIENT
ALGORITHM
ONE
IDENTIFIES
PROBLEMS
THAT
ARE
RESISTANT
TO
SPECIFIC
NATURAL
ALGORITHMS
IN
LOWER
BOUNDS
ARE
SHOWN
FOR
DECOUPLED
DYNAMICS
A
MODEL
OF
STRATEGIC
INTERACTION
IN
WHICH
THERE
IS
NO
CENTRAL
CONTROLLER
TO
FIND
AN
EQUILIBRIUM
INSTEAD
THE
PLAYERS
NEED
TO
OBTAIN
ONE
IN
A
DECENTRALIZED
MANNER
THE
STUDY
AND
COMPARISON
OF
THESE
MODELS
WILL
CONTINUE
TO
BE
AN
INTEREST
ING
RESEARCH
THEME
FINALLY
AN
OVERARCHING
RESEARCH
QUESTION
FOR
THE
COM
PUTER
SCIENCE
RESEARCH
COMMUNITY
INVESTIGATING
GAME
THEORETIC
ISSUES
ALREADY
RAISED
IN
BUT
MADE
A
LITTLE
MORE
URGENT
BY
THE
PRESENT
WORK
IS
TO
IDENTIFY
NOVEL
CONCEPTS
OF
RATIO
NALITY
AND
EQUILIBRIUM
ESPECIALLY
APPLICABLE
IN
THE
CONTEXT
OF
THE
INTERNET
AND
ITS
COMPUTATIONAL
PLATFORMS
CS
FINAL
EXAM
FALL
THIS
TEST
IS
CLOSED
BOOK
YOU
WILL
GET
REASONABLE
PARTIAL
CREDIT
FOR
ATTEMPTING
THE
CORRECT
TECHNIQUE
BUT
RECOGNIZING
THAT
YOU
GET
STUCK
AT
SOME
POINT
YOU
WILL
GET
SIGNI
CANTLY
LESS
PARTIAL
CREDIT
FOR
INCORRECT
SOLUTIONS
THAT
YOU
CLAIM
ARE
CORRECT
THAN
FOR
PARTIAL
SOLUTIONS
WHERE
YOU
STATE
THAT
YOU
DON
T
SEE
HOW
TO
NISH
THE
PROOF
FEEL
FREE
TO
ASK
QUESTIONS
CONCENTRATE
ON
COMMUNICATING
THE
MAIN
IDEAS
IN
YOUR
ANSWERS
DON
T
DWELL
UNNECESSARILY
ON
DETAILS
MANAGE
YOUR
TIME
KEEP
YOUR
ANSWERS
TO
THE
RST
SIX
QUESTIONS
TO
AT
MOST
A
FEW
SENTENCES
YOU
ARE
WELCOME
TO
QUOTE
WELL
KNOWN
THEOREMS
POINTS
YOU
HAVE
A
DATABASE
CONSISTING
OF
A
SINGLE
BINARY
RELATION
R
A
A
THE
QUERY
LANGUAGE
FOR
THE
DATABASE
IS
EXISTENTIAL
SECOND
ORDER
LOGIC
USING
THE
RELATION
R
ARE
THERE
ANY
QUERIES
THAT
CAN
NOT
BE
EXPRESSED
IN
THIS
QUERY
LANGUAGE
EXPLAIN
POINTS
A
LANGUAGE
A
IS
IN
THE
CLASS
PARITY
P
IF
THERE
IS
A
NONDETERMINISTIC
POLYNOMIAL
TIME
TURING
MACHINE
M
WITH
THE
PROPERTY
THAT
IF
X
L
THEN
M
ACCEPTS
X
ON
AN
ODD
NUMBER
OF
COMPUTATION
PATHS
AND
IF
X
L
THEN
M
ACCEPTS
X
ON
AN
EVEN
POSSIBLY
NUMBER
OF
COMPUTATION
PATHS
CONSIDER
THE
FOLLOWING
PROBLEM
PARITY
SAT
THE
INPUT
FOR
THIS
PROBLEM
IS
A
BOOLEAN
FORMULA
F
IN
CONJUNCTIVE
NORMAL
FORM
THE
OUTPUT
IS
IF
AN
ODD
NUMBER
OF
THE
POSSIBLE
ASSIGNMENTS
TO
THE
VARIABLES
SATISFY
F
AND
IS
OTHERWISE
DO
YOU
THINK
YOU
COULD
PROVE
THAT
PARITY
SAT
IS
LOG
SPACE
COMPLETE
FOR
PARITY
P
EXPLAIN
POINTS
ARE
THERE
ANY
LANGUAGES
THAT
ARE
NOT
ACCEPTED
BY
A
FAMILY
OF
BOOLEAN
CIRCUITS
EXPLAIN
POINTS
EXPLAIN
WHY
IF
RP
N
CORP
P
THEN
P
NP
POINTS
ASSUME
THAT
SOMEONE
WAS
ABLE
TO
PROVE
THAT
ONE
WAY
FUNCTIONS
DID
NOT
EXIST
WOULD
THAT
NECESSARILY
RESOLVE
THE
P
NP
PROBLEM
EXPLAIN
POINTS
MARTHA
BROUGHT
IN
A
NEW
YORK
TIMES
ARTICLE
AT
THE
END
OF
CLASS
YESTERDAY
TRUM
PETING
SOME
AMAZING
NEW
MATHEMATICAL
THEOREM
PROVED
BY
AN
AUTOMATED
THEOREM
PROVING
PROGRAM
THE
ARTICLE
IMPLIED
THAT
MATHEMATICIANS
MAY
SOMEDAY
BE
UNNECESSARY
SINCE
ALL
THEOREMS
MAY
SOMEDAY
BE
PROVABLE
BY
A
COMPUTER
IT
THIS
POSSIBLE
THAT
IS
IS
IT
POSSIBLE
TO
WRITE
A
PROGRAM
THAT
HAS
THE
ABILITY
TO
EITHER
PROVE
OR
DISPROVE
EVERY
MATHEMATICAL
STATEMENT
EXPLAIN
POINTS
SHOW
THAT
THE
FOLLOWING
PROBLEM
IS
NP
COMPLETE
THE
INPUT
IS
A
GRAPH
G
WITH
N
V
VERTICES
AND
THE
QUESTION
IS
WHETHER
G
HAS
A
SIMPLE
CYCLE
SPANNING
B
NC
VERTICES
USE
THE
FACT
THAT
THE
HAMILTONIAN
CYCLE
PROBLEM
IS
NP
COMPLETE
RECALL
THAT
THE
THE
INPUT
FOR
THE
HAMILTONIAN
CYCLE
PROBLEM
IS
A
GRAPH
G
WITH
N
VERTICES
AND
THE
QUESTION
IS
WHETHER
G
HAS
A
SIMPLE
CYCLE
THAT
SPANS
ALL
OF
THE
VERTICES
IN
G
POINTS
SHOW
THAT
THE
FOLLOWING
PROBLEM
IS
UNDECIDABLE
THE
INPUT
IS
A
TWO
TURING
MACHINE
M
AND
N
THE
PROBLEM
IS
TO
DETERMINE
IF
L
M
L
N
USE
A
REDUCTION
FROM
THE
STANDARD
HALTING
PROBLEM
DETERMINING
WHETHER
A
TURING
MACHINE
M
HALTS
ON
AN
INPUT
X
POINTS
DE
NE
A
ROBUST
ORACLE
MACHINE
M
DECIDING
A
LANGUAGE
B
TO
BE
ONE
SUCH
THAT
L
MA
B
FOR
ALL
ORACLES
A
THAT
IS
THE
ANSWERS
ARE
ALWAYS
CORRECT
INDEPENDENTLY
OF
THE
ORACLE
ALTHOUGH
THE
NUMBER
OF
STEPS
MAY
VARY
FROM
ORACLE
TO
ORACLE
IF
FURTHERMORE
MA
WORKS
IN
POLYNOMIAL
TIME
WE
SAY
THAT
ORACLE
A
HELPS
THE
ROBUST
MACHINE
M
LET
PH
BE
THE
CLASS
OF
LANGUAGES
DECIDABLE
IN
POLYNOMIAL
TIME
BY
DETERMINISTIC
ROBUST
ORACLE
MACHINES
THAT
CAN
BE
HELPED
SHOW
THAT
PH
NP
N
CONP
POINTS
CONSIDER
A
PROGRAMMING
LANGUAGE
H
THAT
HAS
NO
RECURSION
OR
GOTO
STATEMENTS
IT
ONLY
HAS
ONE
TYPE
OF
LOOP
A
FOR
LOOP
A
FOR
LOOP
HAS
THE
PROPERTY
THAT
THE
NUMBER
OF
ITERATIONS
OF
THE
LOOP
IS
XED
AND
KNOWN
BEFORE
THE
LOOP
IS
EXECUTED
HENCE
ALL
PROGRAMS
IN
H
MUCH
HALT
IN
NITE
TIME
ON
ALL
INPUTS
SHOW
THAT
THERE
IS
A
RECURSIVE
LANGUAGE
THAT
CAN
NOT
BE
ACCEPTED
BY
AN
H
PROGRAM
POINTS
SHOW
THAT
IF
TIME
SP
ACE
N
THEN
TIME
SP
ACE
POINTS
SHOW
THAT
RE
IS
CLOSED
UNDER
KLEENE
STAR
RECALL
THAT
IF
L
IS
A
LANGUAGE
THEN
THE
KLEENE
STAR
OF
L
DENOTED
L
IS
THE
COLLECTION
OF
STRINGS
X
SUCH
THAT
X
IS
EQUAL
TO
THE
CONCATENATION
OF
K
STRINGS
XK
WITH
EACH
XI
L
FOR
I
K
CS
FINAL
EXAM
AND
THEORY
OF
COMPUTATION
PRELIMINARY
EXAM
FALL
DIRECTIONS
THE
TEST
IS
CLOSED
BOOK
AND
CLOSED
NOTES
ANSWER
AT
MOST
PART
B
QUESTIONS
PART
B
QUESTIONS
ARE
WORTH
POINTS
EACH
ANSWER
AT
MOST
PART
A
QUESTIONS
PART
A
QUESTIONS
ARE
WORTH
POINTS
EACH
ONE
QUARTER
CREDIT
WILL
BE
GIVEN
FOR
UNANSWERED
QUESTIONS
ANSWERS
THAT
ARE
WAY
O
THE
MARK
WILL
GET
NO
CREDIT
FOR
THE
PART
A
QUESTIONS
USUALLY
IT
IS
THEN
A
GOOD
IDEA
TO
HAVE
A
PARAGRAPH
GIVING
AN
OVERVIEW
OF
THE
PROOF
STRATEGY
TECHNIQUE
THAT
YOU
WILL
USE
AND
WHAT
THE
KEY
IDEAS
ARE
BEFORE
LAUNCHING
INTO
THE
DETAILS
PART
B
QUESTIONS
THE
FOLLOWING
SENTENCE
IS
ESSENTIALLY
FROM
A
PAPER
ON
THE
P
VS
NP
PROBLEM
FROM
THE
ARXIV
ARCHIVE
IT
HAS
BEEN
PREVIOUSLY
DEMONSTRATED
BY
THE
PRESENT
AUTHOR
THAT
THE
DNA
STRING
CONCATENATION
PROBLEM
CAN
BE
REDUCED
TO
THE
PROBLEM
OF
NDING
A
LARGE
CLIQUE
IN
A
GRAPH
AND
THEREFORE
THE
DNA
CONCATENATION
PROBLEM
IS
NP
COMPLETE
EXPLAIN
THE
ERROR
WITH
THIS
REASONING
EXPLAIN
THE
FAMOUS
RESULT
OF
BAKER
GILL
AND
SOLOWAY
FROM
THE
EXPLAIN
THE
RELEVANCE
OF
THIS
RESULT
FOR
RESOLVING
THE
P
VS
NP
QUESTION
EXPLAIN
NASH
FAMOUS
THEOREM
ABOUT
GAMES
START
WITH
A
DE
NITION
OF
A
GAME
THAT
IS
APPROPRIATE
FOR
THIS
SETTING
CONSIDER
THE
FOLLOWING
SITUATION
ALICE
NEEDS
TO
IP
A
FAIR
COIN
UNTIL
SHE
GETS
A
HEADS
LET
K
BE
THE
NUMBER
OF
IPS
UNTIL
ALICE
SEES
A
HEADS
ALICE
NEEDS
TO
SEND
SOME
BITS
TO
BOB
OVER
A
NETWORK
CONNECTION
IN
ORDER
TO
COMMUNICATE
K
TO
BOB
ALICE
AND
BOB
CAN
COMMUNICATE
A
PRIORI
TO
DETERMINE
THEIR
PROTOCOL
GIVE
AN
EXPRESSION
FOR
THE
EXPECTED
NUMBER
OF
BITS
THAT
ALICE
MUST
SEND
TO
BOB
EXPLAIN
WHY
YOU
KNOW
THAT
APPROXIMATELY
THIS
MANY
BITS
IS
NECESSARY
AND
SU
CIENT
NOTE
THAT
I
AM
NOT
ASKING
FOR
A
PROTOCOL
OR
A
PROOF
THAT
A
CERTAIN
NUMBER
IS
NECESSARY
I
AM
LOOKING
FOR
YOU
TO
CITE
AND
EXPLAIN
WELL
KNOWN
THEOREM
THAT
WE
COVERED
IN
CLASS
FOR
WHICH
OF
THE
FOLLOWING
TWO
COMPLEXITY
CLASSES
IS
IT
LIKELY
EASIER
TO
ND
A
COMPLETE
PROB
LEM
EXPLAIN
YOUR
ANSWER
PP
IS
THE
CLASS
OF
LANGUAGES
L
FOR
WHICH
WHICH
THERE
EXISTS
A
PROBABILISTIC
POLYNOMIAL
TIME
TURING
MACHINE
M
SUCH
THAT
IF
X
L
THEN
M
ACCEPTS
X
WITH
PROBABILITY
AND
IF
X
L
THEN
M
ACCEPTS
X
WITH
PROBABILITY
QQ
IS
THE
CLASS
OF
LANGUAGES
L
FOR
WHICH
WHICH
THERE
EXISTS
A
PROBABILISTIC
POLYNOMIAL
TIME
TURING
MACHINE
M
SUCH
THAT
IF
X
L
THEN
M
ACCEPTS
X
WITH
PROBABILITY
AND
IF
X
L
THEN
M
ACCEPTS
X
WITH
PROBABILITY
CONSIDER
THE
FOLLOWING
LANGUAGE
G
K
THE
LARGEST
SIMPLE
CYCLE
IN
GRAPH
G
CONTAINS
EXACTLY
K
EDGES
SHOW
THAT
THIS
LANGUAGE
IS
IN
START
WITH
A
DE
NITION
OF
IS
P
IS
A
SUBSET
OF
P
POLY
IS
P
POLY
IS
A
SUBSET
OF
P
START
WITH
DE
NITIONS
OF
P
AND
P
POLY
THEN
GIVE
ONE
SENTENCE
JUSTI
CATIONS
FOR
YOUR
ANSWER
TO
EACH
QUESTION
RESULTS
BY
SOLOWAY
AND
STRASSEN
IN
THE
MID
AND
BY
SHOR
IN
THE
MID
HAD
ANALO
GOUS
E
ECTS
ON
COMPUTER
SCIENTISTS
UNDERSTANDING
OF
E
CIENT
COMPUTATION
IN
ONE
SENTENCE
STATE
EACH
RESULT
THEN
EXPLAIN
WHAT
THE
ANALOGOUS
E
ECT
OF
EACH
RESULT
WAS
DE
NE
WHAT
A
PERFECT
ZERO
KNOWLEDGE
PROTOCOL
IS
EXPLAIN
WHY
BP
P
IS
CONTAINED
IN
P
POLY
START
WITH
A
DE
NITION
OF
BP
P
AND
P
POLY
STATE
A
PROBLEM
THAT
IS
COMPLETE
FOR
THE
CLASS
P
WITH
RESPECT
TO
NC
REDUCTIONS
DE
NE
NC
EXPLAIN
WHY
THE
EXISTENCE
OF
A
REALLY
GOOD
PSEUDO
RANDOM
GENERATOR
WOULD
ALLOW
ONE
TO
CONCLUDE
THAT
BP
P
P
START
WITH
DE
NITIONS
OF
BP
P
AND
PSEUDO
RANDOM
GENERATOR
GIVE
THE
INTERACTIVE
PROTOCOL
FOR
THE
GRAPH
NONISOMORPHISM
PROBLEM
FROM
THE
BOOK
AND
CLASS
YOU
NEED
NOT
ARGUE
ABOUT
THE
CORRECTNESS
OF
THE
PROTOCOL
JUST
TRY
TO
STATE
IT
CLEARLY
EXPLAIN
THE
SETUP
OF
EXPERIMENT
WITH
THE
SILVERED
MIRRORS
THAT
WE
DISCUSSED
IN
CLASS
WHEN
WE
RST
DISCUSSED
QUANTUM
COMPUTATION
WHAT
IS
UNEXPECTED
OUTCOME
WHEN
ONE
CARRIES
OUT
THIS
EXPERIMENT
BRIE
Y
EXPLAIN
WHY
THIS
OUTCOME
OCCURS
YOU
HAVE
TWO
ENTANGLED
QUBITS
IN
STATE
A
B
C
D
ANSWER
THE
FOLLOWING
QUESTIONS
YOU
NEED
NOT
JUSTIFY
YOUR
ANSWERS
WHAT
MUST
BE
TRUE
ABOUT
THE
RELATIONSHIP
OF
THE
VALUES
A
B
C
AND
D
IF
YOU
MEASURE
THE
RST
QUBIT
WHAT
IS
THE
PROBABILITY
THAT
YOU
OBSERVE
A
IF
YOU
MEASURE
THE
RST
QUBIT
AND
OBSERVE
A
WHAT
IS
THE
RESULTING
STATE
OF
THE
TWO
BITS
IF
B
C
AND
YOU
ROTATED
THE
RST
BIT
BY
P
RADIANS
WHAT
BE
THE
RESULTING
STATE
OF
THE
BITS
YOU
CAN
WRITE
AN
EXPRESSION
FOR
THE
STATE
YOU
NEED
NOT
SIMPLIFY
THE
PCP
THEOREM
GIVES
AN
ALTERNATIVE
CHARACTERIZATION
OF
THE
COMPLEXITY
CLASS
NP
STATE
THE
PCP
THEOREM
AND
GIVE
A
DE
NITION
OF
THE
TYPE
OF
MACHINE
PROTOCOL
SYSTEM
IN
THE
ALTERNATIVE
CHARACTERIZATION
PART
A
QUESTIONS
PROVE
FROM
RST
PRINCIPLES
THAT
THERE
ARE
LANGUAGES
THAT
CAN
BE
ACCEPTED
IN
EXPONENTIAL
TIME
THAT
CAN
NOT
BE
ACCEPTED
IN
POLYNOMIAL
TIME
STATE
G
ODEL
INCOMPLETENESS
THEOREM
AND
SHOW
THAT
IT
FOLLOWS
AS
A
LOGICAL
CONSEQUENCE
OF
THE
FACT
THAT
THE
HALTING
PROBLEM
IS
NOT
COMPUTABLE
DECIDABLE
GIVE
THE
PERFECT
ZERO
KNOWLEDGE
PROTOCOL
FOR
GRAPH
ISOMORPHISM
FROM
THE
BOOK
AND
PROVE
THAT
THE
PROTOCOL
IS
PERFECT
ZERO
KNOWLEDGE
PROVE
FROM
RST
PRINCIPLES
THAT
THE
CIRCUIT
SATIS
ABILITY
PROBLEM
IS
NP
HARD
THE
CIRCUIT
SATIS
ABLE
PROBLEM
TAKES
AS
INPUT
A
CIRCUIT
AND
ASKS
WHETHER
THERE
IS
ANY
INPUTS
TO
THE
CIRCUIT
THAT
CAUSE
A
PARTICULAR
OUTPUT
TO
BE
SO
BASICALLY
I
AM
ASKING
YOU
TO
GIVE
A
PROOF
OF
COOK
THEOREM
HERE
PROVE
THAT
IF
NP
HAS
POLYNOMIAL
TIME
CIRCUITS
THEN
THE
POLYNOMIAL
TIME
HIERARCHY
COLLAPSES
PROVE
THAT
IF
GRAPH
ISOMORPHISM
IS
NP
HARD
THEN
THE
POLYNOMIAL
TIME
HIERARCHY
COLLAPSES
STATE
WHAT
PROBLEM
SIMON
ALGORITHM
SOLVES
GIVE
SIMON
ALGORITHM
PROVE
THAT
IT
SOLVES
THIS
PROBLEM
PROVE
THAT
SIMON
ALGORITHM
RUNS
IN
POLYNOMIAL
TIME
PROVE
THAT
THERE
EXISTS
SOME
CONSTANT
SUCH
THAT
IT
IS
NP
HARD
TO
APPROXIMATE
MAXSAT
TO
WITHIN
A
FACTOR
OF
YOU
MAY
ASSUME
THE
PCP
THEOREM
CS
FINAL
EXAM
FALL
DIRECTIONS
THE
TEST
IS
CLOSED
BOOK
AND
CLOSED
NOTES
THE
TEST
CONSISTS
OF
QUESTIONS
EACH
WITH
A
PART
A
AND
A
PART
B
ANSWER
AT
MOST
PART
A
QUESTIONS
THESE
ARE
WORTH
POINTS
EACH
ANSWER
AT
MOST
PART
B
QUESTIONS
THESE
ARE
WORTH
POINTS
EACH
IF
YOU
ARE
NOT
REAONABLY
CERTAIN
OF
YOUR
ANSWERS
PLEASE
DON
T
TAKE
RANDOM
GUESSES
IT
IS
BETTER
JUST
TO
LEAVE
IT
BLANK
YOU
DON
T
NEED
TO
GIVE
EVERY
SINGLE
DETAIL
IN
YOUR
ANSWERS
JUST
HIT
THE
MAIN
POINTS
PART
A
QUESTIONS
SHOULD
BE
ANSWERED
IN
SAY
TO
SENTENCES
PLEASE
CONCENTRATE
ON
PROVIDING
CLEAR
ANSWERS
TO
THE
QUESTIONS
THAT
YOU
HAVE
TIME
TO
ANSWER
RATHER
THAN
ON
ANSWERING
THE
MAXIMUM
NUMBER
OF
QUESTIONS
IT
COULD
WELL
BE
THAT
IT
IS
NOT
REASONABLE
TO
PROVIDE
REASONABLE
ANSWERS
TO
THE
MAXIMUM
NUMBER
OF
QUESTIONS
WITHIN
THE
ALLOTTED
TIME
A
STATE
GODEL
INCOMPLETENESS
THEOREM
B
SKETCH
THE
PROOF
OF
GODEL
INCOMPLETENESS
THEOREM
THAT
USES
THE
FACT
THAT
THERE
IS
NO
ALGORITHM
FOR
THE
HALTING
PROBLEM
THIS
PROOF
INVOLVES
THE
CONSTRUCTION
OF
A
FORMULA
F
YOU
DO
NOT
NEED
TO
EXPLAIN
HOW
TO
CONSTRUCT
F
YOU
NEED
ONLY
EXPLAIN
WHAT
PROPERTIES
F
HAS
A
DE
NE
KOLMOGOROV
COMPLEXITY
B
PROVE
THAT
THERE
IS
NO
ALGORITHM
THAT
CAN
DETERMINE
THE
KOLMOGOROV
COMPLEXITY
OF
A
STRING
A
DRAW
A
VENN
DIAGRAM
SHOWING
THE
INCLUSION
RELATIONSHIP
BETWEEN
THE
COMPLEXITY
CLASSES
LOG
SPACE
POLYNOMIAL
TIME
P
P
P
P
AND
POLYNOMIAL
SPACE
STATE
WHICH
INCLUSIONS
ARE
KNOWN
TO
BE
PROPER
STRICT
B
PROVE
THE
STRICTNESS
OF
THESE
INCLUSIONS
FROM
RST
PRINCIPLES
A
GIVE
AN
EXAMPLE
OF
A
LOGIC
PROBLEM
THAT
IS
KNOWN
TO
BE
POLYNOMIAL
TIME
COMPLETE
FOR
THE
COMPLEXITY
CLASS
OF
POLYNOMIAL
SPACE
B
PROVE
FROM
RST
PRINCIPLES
THAT
THIS
PROBLEM
IS
COMPLETE
FOR
POLYNOMIAL
SPACE
A
DE
NE
P
POLY
UNIFORM
NC
AND
NON
UNIFORM
NC
B
SHOW
THAT
IF
NP
P
POLY
THEN
P
P
A
DE
NE
THE
RANDOMIZED
COMPLEXITY
CLASSES
RP
CO
RP
ZPP
AND
BP
P
B
PROVE
ZPP
RP
N
CO
RP
A
DE
NE
IP
K
THAT
IS
DE
NE
WHAT
A
K
ROUND
INTERACTIVE
PROTOCOL
IS
HOW
DO
YOU
DECIDE
WHO
SENDS
THE
RST
MESSAGE
IN
SUCH
A
PROTOCOL
B
GIVE
AN
IP
PROTOCOL
THAT
TAKES
AS
INPUT
A
PROPOSITIONAL
BOOLEAN
FORMULA
F
AND
AN
INTEGER
K
AND
ACCEPTS
IF
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
TO
F
IS
AT
LEAST
K
AND
REJECTS
IF
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
TO
F
IS
LESS
THAN
K
THE
PROTOCOL
MAY
ACCEPT
OR
REJECT
IF
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
IS
IN
BETWEEN
K
AND
K
GIVE
SOME
INTUITION
NOT
NECESSARILY
A
FORMAL
PROOF
WHY
THIS
PROTOCOL
IS
CORRECT
A
DE
NE
WHAT
IS
MEANT
BY
SEMANTIC
SECURITY
WITHIN
THE
CONTEXT
OF
A
CRYPTOGRAPHIC
PROTOCOL
B
CONSTRUCT
A
DIRECT
ACYCLIC
GRAPH
WHERE
THE
NODES
REPRESENT
THE
FOLLOWING
STATEMENTS
I
ONE
TIME
PAD
PRIVATE
KEY
CRYPTOGRAPHY
WITH
SHORT
KEYS
IS
POSSIBLE
II
BPP
ALGORITHMS
CAN
BE
DERANDOMIZED
TO
GIVE
SUBEXPONENTIAL
TIME
DETERMINISTIC
ALGORITHMS
III
PUBLIC
KEY
CRYPTOGRAPHY
IS
POSSIBLE
IV
ONE
WAY
FUNCTIONS
EXIST
V
PSEUDO
RANDOM
GENERATORS
EXIST
WHERE
A
DIRECTED
EDGE
X
Y
FROM
A
VERTEX
X
TO
A
VERTEX
Y
MEANS
THAT
STATEMENT
X
LOGICALLY
IMPLIES
STATEMENT
Y
IF
YOUR
GRAPH
CONTAINS
EDGES
X
Y
AND
Y
Z
THEN
IT
SHOULDN
T
CONTAIN
THE
EDGE
X
Z
AS
THIS
IS
A
LOGICAL
CONSEQUENCE
SO
IN
SOME
SENSE
YOUR
GRAPH
SHOULD
HAVE
THE
MINIMAL
NUMBER
OF
EDGES
PROVE
ONE
OF
THE
IMPLICATIONS
HINT
PICK
AN
EASY
IMPLICATION
SOME
OF
THESE
IMPLICATIONS
ARE
VERY
EASY
TO
PROVE
AND
SOME
ARE
VERY
HARD
TO
PROVE
A
EXPLAIN
THE
EPR
EXPERIMENT
YOU
CAN
JUST
EXPLAIN
WHAT
ALICE
CAN
BOB
ARE
SUPPOSED
TO
ACCOMPLISH
NOT
HOW
THEY
ACCOMPLISH
IT
WHY
IS
THIS
PROTOCOL
FAMOUS
OR
TWO
ASK
THE
QUESTION
A
DI
ERENT
WAY
WHAT
DID
THE
TEXTBOOK
WANT
US
TO
LEARN
FROM
THIS
EXAMPLE
B
GIVE
ALICE
AND
BOB
PROTOCOL
FROM
THE
TEXT
CALCULATE
THE
PROBABILITY
OF
BOB
AND
ALICE
WINNING
GIVEN
THAT
THEY
SEE
DI
ERENT
INPUTS
SHOW
YOUR
WORK
A
WHEN
PROVING
NP
PCP
POLY
EXPLAIN
HOW
ERROR
CORRECTING
CODES
COME
INTO
THE
PICTURE
START
WITH
A
DE
NITION
OF
PCP
POLY
B
TO
PROVE
THAT
NP
PCP
POLY
THE
BOOK
SHOWED
THAT
AN
NP
COMPLETE
PROBLEM
WAS
IN
PCP
POLY
THIS
NP
COMLETE
PROBLEM
INVOLVED
SHOWING
THAT
THERE
WERE
SOLUTIONS
TO
A
SEQUENCE
OF
EQUATIONS
PART
OF
THE
PROTOCOL
INVOLVED
CHECKING
THE
ASSIGNMENT
TO
THE
VARIABLES
EXPLAIN
HOW
THE
ASSIGNMENT
WAS
ENCODED
USING
AS
AN
EXAMPLE
ASSIGNMENT
EXPLAIN
WHAT
PROPERTY
OF
THIS
ENCODING
IS
CHECKED
HOW
IT
IS
CHECKED
AND
WHY
THIS
CHECK
WORKS
COMPUTATIONAL
COMPLEXITY
OF
GAMES
AND
PUZZLES
MANY
OF
THE
GAMES
AND
PUZZLES
PEOPLE
PLAY
ARE
INTERESTING
BECAUSE
OF
THEIR
DIFFICULTY
IT
REQUIRES
CLEVERNESS
TO
SOLVE
THEM
OFTEN
THIS
DIFFICULTY
CAN
BE
SHOWN
MATHEMATICALLY
IN
THE
FORM
OF
COMPUTATIONAL
INTRACTIBILITY
RESULTS
EVERY
NPCOMPLETE
PROBLEM
IS
IN
SOME
SENSE
A
PUZZLE
AND
CONVERSELY
MANY
PUZZLES
ARE
NPCOMPLETE
TWOPLAYER
GAMES
OFTEN
HAVE
HIGHER
COMPLEXITIES
SUCH
AS
BEING
PSPACECOMPLETE
WW
PP
SEE
REFERENCES
BELOW
IS
DISPARAGING
OF
THIS
SORT
OF
RESULT
WRITING
THAT
THIS
ASYMPTOTIC
RESULT
SAYS
LITTLE
ABOUT
THE
DIFFICULTIES
OF
CALCULATING
GOOD
STRATEGIES
DESCRIBING
NPHARD
GAME
POSITIONS
AS
DEGENERATE
AND
RELATIVELY
DULL
AND
ADVOCATING
AS
A
RESPONSE
TO
HARDNESS
PROOFS
LOOKING
FOR
ADDITIONAL
RULES
AND
CONDITIONS
THAT
WOULD
MAKE
THE
GAME
EASIER
BUT
TO
ME
NPCOMPLETENESS
IS
NOT
THE
END
BUT
THE
BEGINNING
OF
THE
STUDY
OF
A
GAME
IT
SHOWS
THAT
THE
GAME
IS
COMPLEX
ENOUGH
THAT
WE
CAN
ENCODE
INTERESTING
COMPUTATIONAL
PROBLEMS
WITHIN
IT
IF
A
GAME
IS
IN
P
IT
BECOMES
NO
FUN
ONCE
YOU
LEARN
THE
TRICK
TO
PERFECT
PLAY
BUT
HARDNESS
RESULTS
IMPLY
THAT
THERE
IS
NO
SUCH
TRICK
TO
LEARN
THE
GAME
IS
INEXHAUSTIBLE
AND
OF
COURSE
NPCOMPLETENESS
OR
PSPACECOMPLETENESS
DOESN
T
EVEN
RULE
OUT
THE
POSSIBILITY
OF
COMPUTING
GAME
VALUES
EXACTLY
TRUE
IT
SEEMS
TO
IMPLY
THAT
WORSTCASEEXPONENTIAL
ALGORITHMS
ARE
REQUIRED
BUT
THERE
IS
STILL
PLENTY
OF
INTERESTING
WORK
IN
DESIGNING
ANALYZING
AND
IMPLEMENTING
SUCH
ALGORITHMS
THERE
IS
A
CURIOUS
RELATIONSHIP
BETWEEN
COMPUTATIONAL
DIFFICULTY
AND
PUZZLE
QUALITY
TO
ME
THE
BEST
PUZZLES
ARE
NPCOMPLETE
ALTHOUGH
SOME
GOOD
PUZZLES
ARE
IN
P
RELYING
ON
GAPS
IN
HUMAN
INTUITION
RATHER
THAN
ON
COMPUTATIONAL
COMPLEXITY
FOR
THEIR
DIFFICULTY
SOME
PUZZLES
ARE
EVEN
HARDER
THAN
NP
FOR
INSTANCE
SLIDING
BLOCK
PUZZLES
AND
SOKOBAN
ARE
PSPACECOMPLETE
BUT
TO
ME
THIS
MEANS
ONLY
THAT
THE
PROBLEM
CAN
HAVE
AN
ANNOYINGLY
LONG
SEQUENCE
OF
MANIPULATIONS
IN
ITS
SOLUTION
FOR
TWOPLAYER
GAMES
ONE
ENCOUNTERS
A
SIMILAR
PHENOMENON
AT
A
HIGHER
LEVEL
OF
COMPLEXITY
THE
TREE
OF
POTENTIAL
INTERACTIONS
IN
A
GAME
TYPICALLY
GIVES
RISE
TO
PSPACECOMPLETENESS
RESULTS
OF
A
SORT
I
FIND
MORE
INTERESTING
THAN
PSPACECOMPLETENESS
IN
PUZZLES
HOWEVER
SOME
GAMES
ARE
HARDER
EXPTIMECOMPLETE
WHICH
TO
ME
MEANS
THAT
IT
MAY
SOMETIMES
BE
NECESSARY
FOR
A
WELLPLAYED
GAME
TO
GO
ON
FOR
A
TEDIOUSLY
LONG
SEQUENCE
OF
MOVES
PERHAPS
SOME
GAMES
OR
PUZZLES
IN
WHICH
THE
PLAYERS
START
WITH
INCOMPLETE
KNOWLEDGE
OF
THE
GAME
OR
PUZZLE
CONFIGURATION
MIGHT
LEAD
TO
OTHER
TYPES
OF
COMPLETENESS
E
G
MACOMPLETENESS
OR
PCOMPLETENESS
FOR
FINDING
THE
STARTING
MOVE
MOST
LIKELY
TO
SUCCEED
BUT
I
KNOW
OF
NO
SUCH
RESULTS
I
PRIMARILY
LIST
HERE
REAL
GAMES
AND
PUZZLES
GAMES
THAT
WERE
INVENTED
TO
BE
PLAYED
RATHER
THAN
TO
BE
ANALYZED
SO
I
M
NOT
INCLUDING
SOME
OF
THE
MORE
ARTIFICIAL
ENTRIES
IN
E
G
WW
OR
GJ
SUCH
AS
SEQUENTIAL
TRUTH
ASSIGNMENT
IF
SOMEONE
CAN
POINT
ME
TO
A
TOURNAMENT
FOR
THESE
GAMES
A
COPY
OF
THE
GAME
SOLD
IN
STORES
OR
A
PROGRAM
FOR
PEOPLE
TO
PLAY
THEM
AGAINST
THEIR
COMPUTERS
I
LL
CONSIDER
ADDING
THEM
ONE
CAVEAT
NPCOMPLETENESS
IS
NOT
A
CONCEPT
THAT
APPLIES
TO
A
SINGLE
PUZZLE
OR
GAME
POSITION
OR
EVEN
A
FINITE
COLLECTION
OF
POSITIONS
IT
ONLY
MAKES
SENSE
TO
TALK
ABOUT
AN
INFINITE
FAMILY
OF
PROBLEMS
AS
BEING
NPCOMPLETE
FOR
THIS
REASON
GAMES
LIKE
CHESS
CANNOT
THEMSELVES
BE
NPCOMPLETE
AS
THEY
ONLY
HAVE
A
FINITE
ALBEIT
UNTHINKABLY
LARGE
NUMBER
OF
POSSIBLE
POSITIONS
IN
MANY
CASES
HOWEVER
THERE
IS
A
NATURAL
GENERALIZATION
FROM
SOME
FINITE
GAME
OR
PUZZLE
TO
AN
INFINITE
FAMILY
OF
GAME
POSITIONS
ON
ARBITRARILY
LARGE
GAME
BOARDS
IN
WHICH
IT
MAKES
SENSE
TO
TALK
ABOUT
NPCOMPLETENESS
THE
FACT
THAT
THESE
INFINITE
GENERALIZATIONS
ARE
COMPUTATIONALLY
HARD
GIVES
US
SOME
JUSTIFICATION
FOR
BELIEVING
THAT
THE
ORIGINAL
FINITE
GAMES
ARE
ALSO
HARD
IN
SOME
LESS
WELLDEFINED
SENSE
AMAZONS
DESCRIPTION
PLAYERS
MOVE
QUEENS
ON
AN
N
N
BOARD
AS
PART
OF
EACH
MOVE
SHOOTING
AN
ARROW
FROM
THE
MOVED
PIECE
ARROWS
MOVE
LIKE
A
CHESS
QUEEN
WHEN
SHOT
BUT
ARE
IMMOVABLE
AFTERWARDS
THE
ARROWS
EVENTUALLY
BLOCK
THE
MOVEMENT
OF
THE
QUEENS
THE
LAST
PLAYER
TO
COMPLETE
A
MOVE
WINS
GAMEPLAY
COMBINES
GOLIKE
GOALS
OF
SURROUNDING
TERRITORY
WITH
CHESSLIKE
TACTICS
OF
BLOCKING
OPPOSING
PIECES
LINES
OF
PLAY
THE
MOST
COMMONLY
USED
STARTING
CONFIGURATION
INVOLVES
FOUR
QUEENS
OF
EACH
COLOR
PLACED
AROUND
THE
EDGES
OF
A
BOARD
STATUS
PSPACECOMPLETE
ENDGAMES
IN
WHICH
PIECES
OF
OPPOSING
COLORS
ARE
SEPARATED
FROM
EACH
OTHER
ARE
NPHARD
CHECKERS
AND
DRAUGHTS
DESCRIPTION
PLAYERS
MOVE
PIECES
DIAGONALLY
FORWARD
ONE
SQUARE
AT
A
TIME
ON
ALTERNATING
SQUARES
OF
AN
N
N
BOARD
REMOVING
THE
OTHER
PLAYERS
PIECES
BY
JUMPING
DIAGONALLY
OVER
THEM
OBJECT
IS
TO
LEAVE
OPPONENT
WITH
NO
MOVE
BY
BLOCKING
OR
JUMPING
ALL
PIECES
THE
VERSION
IS
CALLED
CHECKERS
BUT
ON
LARGER
BOARDS
IT
IS
CALLED
DRAUGHTS
STATUS
EXPTIMECOMPLETE
CHESS
DESCRIPTION
THIS
GAME
IS
BOTH
TOO
COMPLICATED
AND
TOO
WELLKNOWN
TO
DESCRIBE
HERE
IN
DETAIL
BUT
THE
BASIC
IDEA
IS
TO
MOVE
PIECES
AROUND
AN
BOARD
CAPTURING
ONE
OPPONENTS
PIECES
UNTIL
THE
GAME
IS
ENDED
EITHER
BY
CHECKMATE
ONE
PLAYER
WINNING
BY
FORCING
THE
CAPTURE
OF
THE
OPPOSING
PLAYER
KING
OR
BY
VARIOUS
KINDS
OF
DRAWS
STATUS
THIS
IS
A
FINITE
GAME
BUT
GENERALIZATIONS
TO
N
N
BOARDS
ARE
EXPTIMECOMPLETE
DOTS
AND
BOXES
DESCRIPTION
THIS
CHILDHOOD
GAME
IS
PLAYED
WITH
PENCIL
AND
PAPER
STARTING
FROM
A
DRAWING
OF
A
RECTANGULAR
LATTICE
OF
DOTS
THE
PLAYERS
ALTERNATELY
CONNECT
ADJACENT
DOTS
WITH
LINE
SEGMENTS
IF
A
PLAYER
FORMS
A
FOURSEGMENT
SQUARE
HE
OR
SHE
SCORES
A
POINT
AND
GETS
ANOTHER
MOVE
STATUS
WW
DESCRIBES
A
GENERALIZED
VERSION
OF
THE
GAME
THAT
IS
NPHARD
BY
A
REDUCTION
FROM
FINDING
MANY
VERTEXDISJOINT
CYCLES
IN
GRAPHS
THE
SAME
RESULT
WOULD
SEEM
TO
APPLY
AS
WELL
TO
POSITIONS
FROM
THE
ACTUAL
GAME
BY
SPECIALIZING
THEIR
REDUCTION
TO
TRIVALENT
PLANAR
GRAPHS
THIS
IS
VERY
CLOSELY
RELATED
TO
BUT
NOT
QUITE
THE
SAME
AS
MAXIMUM
INDEPENDENT
SETS
IN
MAXIMAL
PLANAR
GRAPHS
DESCRIPTION
OF
THE
POSITIONS
IN
A
MATRIX
ARE
FILLED
BY
TILES
LEAVING
ONE
UNFILLED
HOLE
TILES
ADJOINING
THE
HOLE
CAN
BE
SHIFTED
INTO
THE
HOLE
THE
OBJECT
BEING
TO
FORM
SOME
PARTICULAR
PERMUTATION
OF
THE
TILES
TYPICALLY
FORMING
A
PICTURE
OUT
OF
FRAGMENTS
PRINTED
ON
THE
TILES
STATUS
THIS
IS
A
FINITE
PROBLEM
BUT
CAN
EASILY
BE
GENERALIZED
TO
N
N
MATRICES
TESTING
WHETHER
A
SOLUTION
EXISTS
IS
IN
P
BUT
FINDING
THE
SOLUTION
WITH
THE
FEWEST
MOVES
IS
NPCOMPLETE
CUBIC
DESCRIPTION
SOMETHING
OF
A
CROSS
BETWEEN
SOKOBAN
AND
SAME
GAME
THIS
PUZZLE
INVOLVES
PUSHING
BLOCKS
LEFT
OR
RIGHT
IN
A
POLYGONAL
REGION
WHERE
THEY
ARE
SUBJECT
TO
A
GRAVITY
THAT
PULLS
THEM
DOWNWARD
WHENEVER
POSSIBLE
BLOCKS
HAVE
COLORS
AND
WHEN
MULTIPLE
BLOCKS
OF
THE
SAME
COLOR
BECOME
ADJACENT
THEY
VANISH
THE
GOAL
IS
TO
ELIMINATE
ALL
BLOCKS
STATUS
FRIEDMAN
CLAIMS
TO
PROVE
THAT
CUBIC
IS
NPCOMPLETE
HIS
REDUCTION
CLEARLY
SHOWS
THAT
IT
IS
NPHARD
BUT
IT
IS
LESS
OBVIOUS
TO
ME
THAT
IT
IS
IN
NP
GO
DESCRIPTION
THIS
ANCIENT
GAME
IS
PLAYED
BY
PLACING
STONES
ON
A
BOARD
WHEN
A
GROUP
OF
STONES
OF
ONE
COLOR
IS
COMPLETELY
SURROUNDED
BY
STONES
OF
THE
OTHER
COLOR
THE
SURROUNDED
GROUP
IS
REMOVED
FROM
THE
BOARD
THE
OBJECT
IS
TO
CONTROL
EMPTY
SQUARES
BY
SURROUNDING
THEM
AFTER
BOTH
PLAYERS
ARE
UNWILLING
TO
CONTINUE
PLAY
THESE
SQUARES
ARE
COUNTED
AND
THE
SCORES
ADJUSTED
BY
THE
NUMBERS
OF
STONES
THAT
HAD
BEEN
REMOVED
STATUS
THIS
IS
A
FINITE
GAME
BUT
CAN
BE
GENERALIZED
TO
N
N
BOARDS
EVEN
WITHOUT
KO
SPECIAL
RULES
RELATED
TO
REPETITION
OF
POSITIONS
THE
GAME
IS
PSPACEHARD
WITH
KO
JAPANESE
RULES
IT
IS
EXPTIMECOMPLETE
IT
IS
APPARENTLY
STILL
OPEN
WHETHER
CHINESE
OR
US
RULES
GO
IS
EXPTIMECOMPLETE
EVEN
CERTAIN
SIMPLE
ENDGAMES
IN
WHICH
THE
GO
BOARD
HAS
BEEN
DECOMPOSED
INTO
MANY
SMALL
INDEPENDENT
REGIONS
OF
PLAY
ARE
PSPACEHARD
HEX
DESCRIPTION
PLAYERS
TAKE
TURNS
PLACING
PIECES
ON
A
DIAMONDSHAPED
BOARD
COMPOSED
OF
HEXAGONAL
TILES
EACH
PLAYER
OWNS
TWO
OPPOSITE
SIDES
OF
THE
BOARD
AND
AIMS
TO
CONNECT
THOSE
SIDES
BY
A
CONTIGUOUS
PATH
OF
PIECES
STATUS
FIRST
PLAYER
WINS
BY
A
STRATEGYSTEALING
ARGUMENT
BUT
PSPACECOMPLETE
IN
GENERAL
THE
SHANNON
SWITCHING
GAME
IN
WHICH
PIECES
ARE
PLACED
ON
EDGES
KNOWN
ON
THE
SQUARE
GRID
AS
GALE
A
RELATED
GAME
HAS
BEEN
SOLD
AS
BRIDGEIT
IS
IN
P
HEX
DESCRIPTION
PLAYERS
TAKE
TURNS
PLACING
PIECES
ON
A
DIAMONDSHAPED
BOARD
COMPOSED
OF
HEXAGONAL
TILES
EACH
PLAYER
OWNS
TWO
OPPOSITE
SIDES
OF
THE
BOARD
AND
AIMS
TO
CONNECT
THOSE
SIDES
BY
A
CONTIGUOUS
PATH
OF
PIECES
STATUS
FIRST
PLAYER
WINS
BY
A
STRATEGYSTEALING
ARGUMENT
BUT
PSPACECOMPLETE
IN
GENERAL
THE
SHANNON
SWITCHING
GAME
IN
WHICH
PIECES
ARE
PLACED
ON
EDGES
KNOWN
ON
THE
SQUARE
GRID
AS
GALE
A
RELATED
GAME
HAS
BEEN
SOLD
AS
BRIDGEIT
IS
IN
P
KPLUMBER
DESCRIPTION
ROTATE
TILES
CONTAINING
DRAWINGS
OF
PIPES
TO
MAKE
THE
PIPES
FORM
A
CONNECTED
NETWORK
STATUS
NPCOMPLETE
MASTERMIND
DESCRIPTION
ONE
PLAYER
SETS
UP
A
SECRET
CONFIGURATION
OF
COLORED
PINS
AND
THE
OTHER
PLAYER
MAKES
A
SEQUENCE
OF
GUESSES
ABOUT
THE
CONFIGURATION
AFTER
EACH
GUESS
THE
PLAYER
WITH
THE
SECRET
TELLS
THE
OTHER
PLAYER
HOW
MANY
MANY
PINS
ARE
CORRECT
AND
HOW
MANY
ARE
THE
CORRECT
COLOR
BUT
IN
THE
INCORRECT
POSITION
THE
OBJECT
IS
TO
MAKE
AS
FEW
GUESSES
AS
POSSIBLE
STATUS
SINCE
THIS
GAME
RELIES
ON
SECRET
INFORMATION
IT
CAN
BE
TREATED
USING
CLASSICAL
GAME
THEORY
BUT
THE
RELEVANT
PAYOFF
MATRICES
ARE
SO
LARGE
AS
TO
MAKE
COMPUTATION
WITH
THEM
INTRACTIBLE
FINDING
A
SOLUTION
COMPATIBLE
WITH
THE
GUESSES
MADE
SO
FAR
IS
NPCOMPLETE
THE
COMPLEXITY
OF
DETERMINING
WHETHER
SUCH
A
SOLUTION
IS
UNIQUE
OR
OF
PLAYING
EITHER
SIDE
OF
THE
GAME
OPTIMALLY
REMAIN
OPEN
OTHELLO
DESCRIPTION
THIS
GAME
ALSO
KNOWN
AS
REVERSI
IS
PLAYED
WITH
REVERSIBLE
PIECES
ON
A
SQUARE
BOARD
PLAYERS
ALTERNATE
PLACING
PIECES
ON
THE
BOARD
PLACED
WITH
THE
PLAYER
COLOR
UP
WHEN
A
PIECE
IS
PLACED
THE
PLAYER
ALSO
REVERSES
LINES
OF
PIECES
OF
THE
OPPOSITE
COLOR
SANDWICHED
BETWEEN
THE
NEW
PIECE
AND
OLD
PIECES
OF
THE
SAME
COLOR
SO
THAT
THOSE
LINES
ALSO
BECOME
PIECES
OF
THE
PLAYER
COLOR
THE
OBJECT
IS
TO
HAVE
THE
MOST
PIECES
WHEN
THE
BOARD
BECOMES
FILLED
PHUTBALL
DESCRIPTION
PLAYED
ON
A
GO
BOARD
WITH
ONE
BLACK
STONE
AND
MANY
WHITE
STONES
PLAYERS
ON
EACH
TURN
EITHER
PLACE
A
SINGLE
WHITE
STONE
ON
ANY
VACANT
POSITION
OR
MAKE
A
SEQUENCE
OF
JUMPS
OF
THE
BLACK
STONE
OVER
CONTIGUOUS
GROUPS
OF
WHITE
STONES
REMOVING
THE
JUMPED
STONES
THE
OBJECT
IS
TO
MOVE
THE
BLACK
STONE
TO
THE
EDGE
OF
THE
BOARD
NEAREST
THE
OPPONENT
STATUS
TESTING
FOR
THE
EXISTANCE
OF
A
WINNING
MOVE
IS
NPCOMPLETE
THE
COMPLEXITY
OF
DETERMINING
THE
CORRECT
OUTCOME
OF
A
GAME
POSITION
IS
PSPACEHARD
PEARL
PUZZLES
DESCRIPTION
A
JAPANESE
PENCIL
AND
PAPER
PUZZLE
IN
WHICH
BLACK
AND
WHITE
PEARLS
ARE
PLACED
IN
A
SQUARE
GRID
THE
OBJECT
IS
TO
DRAW
A
POLYGON
WITH
EDGES
PARALLEL
TO
THE
GRID
LINES
THROUGH
ALL
THE
PEARLS
WITH
VERTICES
AT
EACH
BLACK
PEARL
AND
ADJACENT
TO
EACH
WHITE
PEARL
BUT
NO
VERTICES
ADJACENT
TO
ANY
BLACK
PEARL
OR
AT
ANY
WHITE
PEARL
STATUS
NPCOMPLETE
RUSH
HOUR
DESCRIPTION
THIS
IS
A
COMMERCIAL
SLIDING
BLOCK
PUZZLE
IN
WHICH
PIECES
REPRESENTING
CARS
ARE
PLACED
ON
A
GRID
WITH
WALLS
SURROUNDING
ITS
PERIMETER
EXCEPT
FOR
ONE
EXIT
EDGE
THE
CARS
TAKE
UP
TWO
OR
THREE
ADJACENT
GRID
CELLS
AND
CAN
ONLY
MOVE
FORWARDS
OR
BACKWARDS
THE
GOAL
IS
TO
MOVE
A
SPECIALLY
MARKED
TARGET
CAR
OUT
THROUGH
THE
EXIT
SIMILAR
JAVA
APPLETS
ARE
AVAILABLE
AT
PUZZLEWORLD
AND
RHYMEZONE
STATUS
THIS
IS
A
FINITE
PUZZLE
BUT
GENERALIZATIONS
TO
ARBITRARILY
LARGE
RECTANGLES
ARE
PSPACECOMPLETE
RUSH
HOUR
DESCRIPTION
THIS
IS
A
COMMERCIAL
SLIDING
BLOCK
PUZZLE
IN
WHICH
PIECES
REPRESENTING
CARS
ARE
PLACED
ON
A
GRID
WITH
WALLS
SURROUNDING
ITS
PERIMETER
EXCEPT
FOR
ONE
EXIT
EDGE
THE
CARS
TAKE
UP
TWO
OR
THREE
ADJACENT
GRID
CELLS
AND
CAN
ONLY
MOVE
FORWARDS
OR
BACKWARDS
THE
GOAL
IS
TO
MOVE
A
SPECIALLY
MARKED
TARGET
CAR
OUT
THROUGH
THE
EXIT
SIMILAR
JAVA
APPLETS
ARE
AVAILABLE
AT
PUZZLEWORLD
AND
RHYMEZONE
STATUS
THIS
IS
A
FINITE
PUZZLE
BUT
GENERALIZATIONS
TO
ARBITRARILY
LARGE
RECTANGLES
ARE
PSPACECOMPLETE
SHANGHAI
DESCRIPTION
THIS
SOLITAIRE
GAME
IS
PLAYED
WITH
MAHJONGG
TILES
WHICH
LIKE
PLAYING
CARDS
CAN
BE
ARRANGED
IN
GROUPS
OF
FOUR
SIMILAR
OR
IDENTICAL
TILES
THE
TILES
ARE
PLACED
RANDOMLY
FACEUP
INTO
STACKS
FORMING
SOME
PARTICULAR
SHAPE
MOST
COMPUTER
SOLITAIRE
IMPLEMENTATIONS
INCLUDE
SEVERAL
SHAPES
OF
VARYING
DIFFICULTY
ONLY
THE
TOP
TILE
OF
A
STACK
IS
VISIBLE
ALTHOUGH
SOME
SHAPES
INVOLVE
TILES
PARTIALLY
COVERED
BY
OTHER
TILES
WHICH
CAN
BE
SEEN
BUT
NOT
REMOVED
THE
OBJECT
IS
TO
REMOVE
MATCHING
PAIRS
OF
UNCOVERED
TILES
UNTIL
ALL
TILES
HAVE
BEEN
REMOVED
STATUS
NPCOMPLETE
EVEN
IF
ALL
TILE
POSITIONS
ARE
KNOWN
PSPACEHARD
EVEN
TO
APPROXIMATE
THE
STRATEGY
WITH
MAXIMUM
PROBABILITY
OF
SUCCESS
WHEN
SOME
TILES
ARE
COVERED
AND
UNKNOWN
PCOMPLETE
TO
COUNT
SOLUTIONS
PERSONAL
COMMUNICATION
FROM
MICHIEL
DE
BONDT
PROOF
OF
NPCOMPLETENESS
REDUCTION
FROM
JOINT
WITH
MICHIEL
DE
BONDT
AN
EARLIER
REDUCTION
LISTED
HERE
UNTIL
EARLY
WAS
NOT
VALID
WE
HAVE
A
DIFFERENT
TYPE
OF
TILE
FOR
EACH
VARIABLE
CLAUSE
AND
TERM
APPEARANCE
OF
A
VARIABLE
IN
A
CLAUSE
OF
THE
INSTANCE
WITH
FOUR
COPIES
OF
EACH
TYPE
OF
TILE
WE
ARRANGE
THESE
INTO
STACKS
OF
THE
FOLLOWING
TYPES
A
BIG
STACK
WITH
THREE
LAYERS
THE
TOP
AND
BOTTOM
LAYERS
EACH
INCLUDE
ONE
COPY
OF
EACH
VARIABLE
TILE
THE
MIDDLE
LAYER
INCLUDES
ONE
COPY
OF
EACH
CLAUSE
TILE
FOR
EACH
TERM
A
STACK
WITH
TWO
COPIES
OF
THAT
TERM
ON
TOP
OF
A
TILE
FOR
THE
CLAUSE
IN
WHICH
THE
TERM
APPEARS
FOR
EACH
VARIABLE
TWO
STACKS
EACH
WITH
A
VARIABLE
TILE
ON
TOP
OF
A
STACK
OF
TERM
TILES
ONE
OF
THESE
STACKS
HAS
TWO
COPIES
OF
EACH
TERM
TILE
IN
WHICH
THE
VARIABLE
TILE
APPEARS
POSITIVELY
AND
THE
OTHER
STACK
HAS
TWO
COPIES
OF
EACH
TERM
TILE
IN
WHICH
THE
VARIABLE
APPEARS
NEGATIVELY
THE
VARIABLE
TILES
CAN
ONLY
BE
MATCHED
BY
PAIRING
ONE
TILE
FROM
THE
BIG
STACK
WITH
ONE
TILE
FROM
ONE
OF
THE
TWO
TERM
STACKS
IF
THIS
PAIRING
IS
DONE
ACCORDING
TO
A
SATISFYING
ASSIGNMENT
IT
WILL
THEN
BE
POSSIBLE
TO
MATCH
THE
TERM
TILES
FROM
ALL
OF
THE
CHOSEN
VARIABLE
STACKS
FREEING
AT
LEAST
ONE
COPY
OF
EACH
CLAUSE
TILE
THE
FREED
CLAUSE
TILES
CAN
THEN
BE
USED
TO
COMPLETE
THE
PAIRING
OF
THE
BIG
STACK
WHICH
IN
TURN
ALLOWS
THE
REMAINING
VARIABLE
TERM
AND
CLAUSE
TILES
TO
BE
PAIRED
ON
THE
OTHER
HAND
IF
THERE
IS
NO
SATISFYING
ASSIGNMENT
THEN
THERE
IS
NO
WAY
OF
FREEING
ONE
COPY
OF
EACH
CLAUSE
GADGET
AND
THE
PROBLEM
CANNOT
BE
SOLVED
SOKOBAN
DESCRIPTION
A
WAREHOUSEMAN
MOVES
AROUND
A
RECTILINEAR
MAZE
PUSHING
PALLETS
ONE
AT
A
TIME
FROM
INITIAL
LOCATIONS
SCATTERED
THROUGHOUT
THE
MAZE
UNTIL
THEY
ARE
ALL
PLACED
IN
A
DESIGNATED
LOADING
DOCK
STATUS
PSPACECOMPLETE
TWIXT
DESCRIPTION
PLAYERS
ALTERNATE
PLACING
VERTICES
ON
A
SQUARE
GRID
EACH
PLAYER
VERTICES
MAY
BE
CONNECTED
WITH
EDGES
CONNECTING
PAIRS
OF
VERTICES
A
KNIGHT
MOVE
APART
AFTER
PLACING
A
VERTEX
THE
PLAYER
MAY
REMOVE
SOME
OF
HIS
OWN
EDGES
OR
ADD
MORE
OF
THEM
NO
TWO
EDGES
MAY
CROSS
THE
OBJECT
IS
LIKE
HEX
TO
CONNECT
OPPOSITE
SIDES
OF
THE
BOARD
BY
A
PATH
STATUS
NPCOMPLETE
TO
DETERMINE
WHETHER
A
SINGLE
SET
OF
VERTICES
CAN
SUPPORT
A
CONNECTING
PATH
PSPACECOMPLETE
TO
DETERMINE
THE
GAME
VALUE
BY
A
REDUCTION
FROM
HEX
COURSE
FORMAT
I
WILL
GIVE
ALL
OF
THE
LECTURES
THERE
WILL
BE
HOMEWORK
ASSIGNMENTS
AND
A
FINAL
EXAM
THAT
WILL
COUNT
EQUALLY
IN
THE
FINAL
GRADE
YOU
MAY
WORK
IN
GROUPS
OF
SIZE
OR
ON
THE
HOMEWORKS
YOU
MAY
TALK
TO
OTHERS
IN
THE
CLASS
ABOUT
THE
HOMEWORK
BUT
MAY
NOT
CONSULT
ANY
OUTSIDE
SOURCE
E
G
OTHER
STUDENTS
THE
WWW
OTHER
TEXTS
TO
HELP
SOLVE
THE
HOMEWORK
PROBLEMS
SOLUTIONS
ARE
DUE
AT
THE
START
OF
CLASS
WHEN
THEY
ARE
DUE
AND
MUST
BE
WRITTEN
USING
LATEX
FIGURES
MAY
BE
HAND
DRAWN
TENTATIVE
SCHEDULE
HISTORICAL
PRE
RESULTS
CHAPTER
FORMALIZING
COMPUTATION
CHURCH
TURING
NOTES
FINITE
STATE
MACHINES
CANNOT
COUNT
CHURCH
TURING
THESIS
EVIDENCE
SIMULATION
UNDECIDABLE
PROBLEMS
CHURCH
TURING
NOTES
HALTING
PROOF
DIAGONIZATION
TERM
REWRITING
PROOF
REDUCTION
LOGIC
PROOFS
AND
COMPUTATION
NOTES
GOEDEL
INCOMPLETENESS
THEOREMS
FORMALIZING
INFORMATION
NOTES
ENTROPY
SOURCE
CODING
THEOREM
SHANNON
CIRCA
KOLMOGOROV
COMPLEXITY
CIRCA
NONCOMPUTABILITY
OF
KOLMOGOROV
COMPLEXITY
P
PH
AND
PSPACE
CHAPTERS
AND
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
TIME
AND
SPACE
DEFINITION
OF
LOGSPACE
P
PSPACE
EXPTIME
CONSTANT
TIME
AND
SPACE
SPEED
UP
THEOREMS
LOGSPACE
IN
P
AND
PSPACE
IS
IN
EXPTIME
TIME
AND
SPACE
HIEARCHY
THEOREMS
MACHINE
BASED
COMPLETE
PROBLEMS
FOR
P
PSPACE
EXPTIME
CIRCUIT
VALUE
PROBLEM
IS
LOG
SPACE
COMPLETE
FOR
P
TQBF
IS
POLYNOMIAL
TIME
COMPLETE
FOR
PSPACE
PSPACE
HARDNESS
OF
SOME
GAME
SEE
FOR
EXAMPLE
THIS
LIST
PH
AND
ALTERNATION
DEFINITION
OF
PH
PH
IN
PSPACE
MACHINE
BASED
COMPLETE
PROBLEMS
FOR
PH
WHY
NO
OBVIOUS
COMPLETE
PROBLEMS
FOR
NP
INTERSECT
CONP
COOK
LEVIN
THEOREM
NP
COMPLETENESS
OF
THEOREMS
PSPACE
APTIME
BAKER
GILL
SOLOWAY
LADNER
THEOREM
CIRCUITS
CHAPTER
DEFINITION
OF
UNIFORM
NC
PARALLEL
COMPUTATION
THESIS
WIKEPEDIA
NLOGSPACE
AND
LOGSPACE
IN
NC
DEFINITION
OF
P
POLY
KARP
LIPTON
THEOREM
RANDOMIZATION
CHAPTER
RANDOM
POLYNOMIAL
TIME
ALGORITHM
FOR
PRIMALITY
SOLOWAY
AND
STRASSEN
DEFINITION
OF
BPP
RP
CO
RP
ZPP
WHY
THESE
CLASSES
SEEM
TO
NOT
HAVE
COMPLETE
PROBLEMS
ZPP
IN
BPP
BPP
IN
P
POLY
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
BPP
IN
POLYNOMIAL
TIME
HIERARCHY
INTERACTIVE
PROOFS
CHAPTER
EXAMPLES
UNO
CARD
COLOR
GRAPH
NON
ISOMORPHISM
DEFINITIONS
OF
AM
AND
IP
AM
PROTOCOL
FOR
APPROXIMATE
SET
SIZE
GNI
IN
AM
AND
IP
K
IN
AM
K
P
IN
IP
IP
PSPACE
IF
GI
IS
NP
COMPLETE
THEN
THE
POLYNOMIAL
TIME
HIERACHY
COLLAPSES
HISTORY
OF
IP
PSPACE
RESULT
GREAT
READING
ABOUT
HOW
RESEARCH
HAPPENS
IN
THE
REAL
WORLD
CRYPTOGRAPHY
CHAPTER
MOSTLY
ONE
TIME
PAD
PRIVATE
KEY
PUBLIC
KEY
CRYPTOGRAPHY
DEFINITION
OF
ONE
WAY
FUNCTION
DEFINITION
OF
PSEUDO
RANDOM
GENERATORS
DEFINITION
OF
SEMANTIC
SECURITY
ONE
WAY
FUNCTIONS
IMPLY
PSEUDO
RANDOM
GENERATORS
WHICH
IMPLY
PRIVATE
KEY
CRYPTOGRAPHY
WITH
SMALLISH
KEYS
PSEUDO
RANDOM
GENERATORS
IMPLY
DERANDOMIZATION
OF
BPP
AND
BPP
SUBSET
SUBEXPONENTIAL
TIME
DEFINITION
OF
PERFECT
ZERO
KNOWLEDGE
ZERO
KNOWLEDGE
PROOF
OF
GRAPH
ISOMORPHISM
ENERGY
BILLIARD
BALL
CIRCUITS
REVERSABLE
COMPUTATION
MINIMUM
ENERGY
COMPUTATION
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
QUANTUM
COMPUTATION
CHAPTER
MOSTLY
TWO
SILVERED
MIRROR
EXPERIMENT
EPR
AND
THE
PARITY
GAME
PROVABLY
SECURE
QUANTUM
CYRPTOGRAPHY
HEISENBERG
UNCERTAINTY
PRINCIPLE
SIMON
ALGORITHM
GROVER
ALGORITHM
SHOR
ALGORITHM
POPULAR
DESCRIPTION
APPROXIMATION
ALGORITHMS
CHAPTER
MOSTLY
STATEMENT
OF
PCP
THEOREM
HARDNESS
OF
APPROXIMATION
OF
MAXSAT
HOW
TO
USE
PCP
TO
PROVE
HARDNESS
OF
APPROXIMATION
BY
REDUCTION
NP
SUBSET
PCP
POLY
INFORMATION
THEORETIC
LOWER
BOUNDS
CHAPERS
AND
SORTING
LOWER
BOUND
ELEMENT
UNIQUENESS
LOWER
BOUND
COMMUNICATION
COMPLEXITY
AND
THE
TILING
LOWER
BOUND
FOR
EQUALITY
YAO
MINIMAX
TECHNIQUE
FOR
SORTING
DUE
WEDNESDAY
AUGUST
ASSUME
ALICE
AND
BOB
FOLLOW
SOME
COMMUNICATION
PROTOCOL
THAT
IS
OVERHEARD
BY
THAT
PESKY
EAVESDROPPER
EVE
ALICE
AND
BOB
WOULD
LIKE
THAT
THEIR
COMMUNICATION
IS
CRYPTOGRAPHICALLY
SECURE
IN
THAT
EVE
DOESN
T
LEARN
ANYTHING
FROM
WHAT
SHE
HEARS
DO
YOU
BEST
TO
COME
UP
WITH
A
FORMAL
DEFINITION
OF
CRYPTOGRAPHICALLY
SECURE
YOU
MAY
NOT
LOOK
IN
THE
TEXT
OR
USE
ANY
OUTSIDE
SOURCES
THE
POINT
OF
THIS
EXERCISE
IS
NOT
FOR
YOU
TO
FIND
THE
RIGHT
DEFINITION
BUT
TO
UNDERSTAND
THE
DIFFICULTIES
OF
COMING
UP
WITH
SUCH
A
DEFINITION
BY
GOING
THROUGH
THE
THOUGHT
PROCESS
YOURSELF
YOU
PROPOSED
DEFINITION
WILL
NOT
BE
GRADED
ON
CORRECTNESS
IF
YOU
CAN
T
THINK
OF
A
DEFINITION
WRITE
A
PARAGRAPH
OR
TWO
ON
THINGS
THAT
YOU
THOUGHT
ABOUT
EVERYONE
THAT
TURNS
IN
SOMETHING
WILL
GET
FULL
CREDIT
HERE
DUE
FRIDAY
AUGUST
SHOW
FROM
FIRST
PRINCIPLES
THAT
THERE
IS
NO
FINITE
STATE
MACHINE
THAT
ACCEPTS
THE
LANGUAGE
OF
FORMULAS
OF
THE
FORM
X
Y
Z
WHERE
NATURAL
NUMBERS
X
Y
AND
Z
ENCODED
IN
BINARY
IN
THE
STANDARD
WAY
AND
WHERE
X
PLUS
Y
IS
INDEED
EQUAL
TO
Z
SO
FOR
EXAMPLE
THE
INPUT
IS
IN
THE
LANGUAGE
SO
INTUITIVELY
THIS
SHOWS
THAT
FINITE
STATE
MACHINES
CAN
NOT
ADD
IN
THE
MOST
OBVIOUS
INTERPRETATION
OF
ADD
SHOW
THAT
THERE
IS
A
FINITE
STATE
MACHINE
THAT
CAN
ACCEPT
THE
LANGUAGE
OVER
A
STRING
OF
SYMBOLS
THAT
INTUITIVELY
MEAN
WHERE
THE
FIRST
COLUMN
PLUS
THE
SECOND
COLUMN
IS
EQUAL
TO
THE
THIRD
COLUMN
SO
TO
REUSE
OUR
EXAMPLE
FROM
PROBLEM
THE
SYMBOL
INPUT
IS
IN
THE
LANGUAGE
BECAUSE
FOR
SIMPLICITY
YOU
MAY
ASSUME
THAT
YOU
CAN
READ
THE
INPUT
TAPE
IN
EITHER
DIRECTION
THOUGH
THIS
ASSUMPTION
ISN
T
STRICTLY
NECESSARY
SO
INTUITIVELY
THIS
SAYS
THAT
FINITE
STATE
MACHINES
CAN
ADD
FOR
SOME
REASONABLE
INTEPRETATION
OF
ADD
DUE
MONDAY
SEPTEMBER
PROBLEM
FROM
THE
TEXT
BASICALLY
YOU
WANT
TO
SHOW
HOW
TO
SIMULATE
A
TURING
MACHINE
WITH
A
DIMENSIONAL
TAPE
BY
A
TURING
MACHINE
WITH
A
ONE
DIMENSIONAL
TAPE
THE
PURPOSE
OF
ASSIGNING
THIS
PROBLEM
IS
TO
GAIN
SOME
SOME
FAMILIARITY
WITH
SIMULATION
ARGUMENTS
SUGGESTION
USE
THE
PROOF
OF
CLAIM
IN
THE
BACK
OF
THE
BOOK
BOTH
TO
GET
AN
IDEA
OF
HOW
TO
SOLVE
THIS
PROBLEM
AND
AS
A
MODEL
AS
TO
THE
LEVEL
OF
DETAIL
THAT
YOU
SHOULD
HAVE
IN
YOUR
WRITE
UP
NOTE
THIS
IS
PROBLEM
IN
THE
ONLINE
PRELIMINARY
VERSION
OF
THE
BOOK
AT
HTTP
WWW
CS
PRINCETON
EDU
THEORY
COMPLEXITY
MODELCHAP
PDF
IN
GENERAL
PROBLEM
NUMBERINGS
WILL
BE
FROM
THE
FINAL
VERSION
OF
THE
TEXT
NOT
THE
ONLINE
PRELIMINARY
VERSION
DUE
WEDNESDAY
SEPTEMBER
CONSIDER
A
PROGRAMMING
LANGUAGE
MINI
JAVA
THAT
ONLY
HAS
ONE
TYPE
OF
LOOP
AND
THE
NUMBER
OF
ITERATIONS
OF
THE
LOOP
MUST
BE
DETERMINED
WHEN
THE
LOOP
IS
FIRST
ENCOUNTERED
SO
A
LOOP
STATEMENT
MIGHT
LOOK
LIKE
REPEAT
N
TIMES
AND
THE
VARIABLE
N
IS
EVALUATED
WHEN
THE
STATEMENT
IS
REACHED
YOU
CAN
ASSUME
THAT
THE
PROGRAM
HAS
A
VARIABLE
SIZE
THAT
IS
INSTANTIATED
TO
THE
INPUT
SIZE
WHEN
THE
PROGRAM
STARTS
RUNNING
OTHERWISE
YOU
COULDN
T
EVEN
READ
THE
INPUT
SO
ALL
MINI
JAVA
PROGRAMS
MUST
HALT
ON
ALL
INPUTS
SHOW
BY
DIAGONALIZATION
THAT
THERE
IS
A
LANGUAGE
ACCEPTED
BY
A
JAVA
PROGRAM
THAT
IS
NOT
ACCEPTED
BY
ANY
MINI
JAVA
PROGRAM
USE
DIAGONALIZATION
GIVE
A
CONCRETE
EXAMPLE
OF
A
LANGUAGE
THAT
IS
NOT
ACCEPTABLE
BY
ANY
MINI
JAVA
PROGRAM
BUT
THAT
IS
ACCEPTED
BY
A
JAVA
PROGRAM
THE
PURPOSE
OF
ASSIGNING
THIS
PROBLEM
IS
TO
GAIN
SOME
FAMILIARITY
WITH
DIAGONALIZATION
ARGUMENTS
DUE
FRIDAY
SEPTEMBER
CONSIDER
THE
FOLLOWING
DECISION
PROBLEM
THE
INPUT
CONSISTS
OF
A
COLLECTION
OF
TYPES
OF
UNIT
SQUARES
FOUR
SPECIAL
COLORS
THAT
WE
WILL
CALL
L
R
T
AND
B
AND
A
COLLECTION
OF
COLOR
RULES
A
UNIT
SQUARE
TYPE
IS
AN
ORDERED
TUPLE
OF
COLORS
THERE
IS
NO
A
PRIORI
BOUND
ON
THE
NUMBER
OF
POSSIBLE
COLORS
AND
YOU
CAN
USE
AS
MANY
UNIT
SQUARES
AS
YOU
LIKE
THAT
HAVE
THESE
FOUR
COLORS
IN
CLOCKWISE
ORDER
AROUND
THE
OUTSIDE
FOR
EXAMPLE
A
UNIT
SQUARE
TYPE
MIGHT
BE
RED
RED
BLUE
GREEN
A
COLOR
RULE
IS
A
PAIR
OF
COLORS
MEANING
THAT
SQUARE
SIDES
OF
THESE
COLORS
ARE
ALLOWED
TO
TOUCH
FOR
EXAMPLE
A
COLOR
RULE
MIGHT
BE
RED
BLUE
EACH
OF
THE
FOUR
FINITE
AUTOMATA
TAKE
AS
INPUT
A
STRING
OF
COLORS
AND
EITHER
REJECT
OR
ACCEPT
THE
STRING
THE
DECISION
IS
TO
DETERMINE
WHETHER
THERE
IS
A
RECTANGLE
FILLED
WITH
AVAILABLE
TYPES
OF
UNIT
SQUARES
PLACED
TO
OBEY
THE
COLOR
RULES
WHERE
THE
COLORS
ON
THE
TOP
ARE
ALL
T
THE
COLORS
ON
THE
LEFT
ARE
ALL
L
THE
COLORS
ON
THE
RIGHT
ARE
ALL
R
AND
THE
COLORS
ON
THE
BOTTOM
ARE
ALL
B
SHOW
THAT
THERE
IS
NO
ALGORITHM
TO
SOLVE
THIS
PROBLEM
HINT
RECALL
THE
PROOF
THAT
THE
TERM
REWRITING
PROBLEM
IS
NOT
COMPUTABLE
THINK
OF
ROW
I
OF
THE
RECTANGLE
AS
BEING
THE
CONFIGURATION
OF
A
TURING
MACHINE
AFTER
STEP
I
THINK
OF
A
SEQUENCE
OF
ROWS
AS
BEING
A
COMPUTATION
HISTORY
THINK
OF
MANY
OF
THE
COLORS
ENCODING
EITHER
SOME
SMALL
STRING
OF
TAPE
SYMBOLS
OR
A
POSITION
OF
THE
TAPE
HEAD
THE
STATE
IN
THE
FINITE
STATE
CONTROL
AND
SOME
TAPE
SYMBOLS
THE
ONLY
ISSUE
THAT
IS
NOT
STRAIGHTFORWARD
IS
HOW
TO
GUARANTEE
CONSISTENCY
WHEN
THE
TAPE
HEAD
MOVES
TO
HANDLE
THIS
THINK
ABOUT
THERE
BEING
SOME
OVERLAP
IN
INFORMATION
BETWEEN
CONSECUTIVE
COLORS
ON
THE
BOTTOM
TOP
OF
A
ROW
FURTHER
HINT
NOTE
THAT
THERE
IS
NO
ALGORITHM
TO
DETERMINE
WHETHER
A
TURING
MACHINE
HALTS
WHEN
GIVEN
THE
EMPTY
TAPE
AS
INPUT
YOU
MIGHT
PROVE
THIS
AS
A
WARMUP
OR
JUST
LOOK
IN
THE
CLASS
NOTES
THE
PURPOSE
OF
THE
PROBLEM
IS
TO
GET
USED
TO
THE
CONCEPTS
OF
CONFIGURATION
AND
COMPUTATION
HISTORY
AND
PROVING
HARDNESS
VIA
A
REDUCTION
DUE
MONDAY
SEPTEMBER
THE
GOAL
OF
THIS
PROBLEM
IS
TO
FINISH
UP
THE
PROOF
IN
CLASS
OF
A
VERSION
OF
GOEDEL
INCOMPLETENESS
THEOREM
THAT
THERE
IS
NO
COMPLETE
SOUND
AXIOMATIZATION
OF
STANDARD
ARITHMETIC
CONSIDER
AN
STRING
THAT
REPRESENTS
THE
COMPUTATION
HISTORY
OF
A
PARTICULAR
TURING
MACHINE
T
E
G
SK
FOR
A
COMPUTATION
THAT
TAKES
K
STEPS
HERE
SI
IS
THE
STATE
ON
THE
ITH
STEP
THE
NUMBER
OF
SYMBOLS
J
IN
EACH
SI
IS
THE
NUMBER
OF
STATES
IN
T
PLUS
THE
SIZE
OF
THE
TAPE
ALPHABET
FOR
T
PLUS
ONE
SYMBOL
TO
REPRESENT
THE
POSITION
OF
THE
TAPE
HEAD
CONSIDER
AS
A
BASE
J
INTEGER
EXPLAIN
HOW
TO
EXPRESS
THE
INFORMAL
SENTENCE
REPRESENTS
A
VALID
COMPUTATION
FOR
T
AS
A
FIRST
ORDER
LOGICAL
SENTENCE
USING
STANDARD
ARITHMETIC
OPERATORS
SUCH
AS
PLUS
MINUS
TIMES
DIVISION
MOD
FLOOR
CEILING
EQUALS
LESS
THAN
ETC
AND
STANDARD
LOGICAL
OPERATORS
AND
OR
NOT
ETC
NOTE
THAT
THIS
IS
REQUIRED
FOR
THE
PROOF
OF
THAT
THERE
IS
NO
COMPLETE
AXIOMATIZATION
OF
STANDARD
ARITHMETIC
THE
PURPOSE
OF
THIS
PROBLEM
IS
TO
REINFORCE
THE
PROOF
OF
GODEL
INCOMPLETENESS
THEOREM
AND
GET
COMFORTABLE
WITH
THE
ARITHMETIZATION
OF
COMPUTATION
DUE
WEDNESDAY
SEPTEMBER
EMAIL
TO
PITT
EDU
BY
NOON
CONSIDER
FIRST
ORDER
LOGICAL
SENTENCES
OF
ARITHMETIC
WHERE
YOUR
ARE
ALLOWED
TO
USE
AND
WITHOUT
LOSS
OF
GENERALITY
WE
MAY
ASSUME
THAT
THE
ONLY
LOGICAL
OPERATORS
ARE
AND
AND
NOT
AND
THAT
ALL
QUANTIFIERS
APPEAR
FIRST
SO
YOU
MIGHT
HAVE
A
FORMULA
LIKE
THEREEXISTS
X
FORALL
Y
FORALL
Z
THEREEXISTS
W
SUCH
THAT
X
Y
Z
AND
NOT
Y
Z
W
X
OUR
GOAL
HERE
IS
TO
SHOW
THAT
THERE
IS
AN
ALGORITHM
TO
ACCEPT
EXACTLY
THE
LANGUAGE
OF
TRUE
FORMULA
USING
THE
FOLLOWING
STRATEGY
RECALL
FROM
PROBLEM
THAT
WE
KNOW
HOW
TO
BUILD
A
FINITE
STATE
MACHINE
THAT
ACCEPT
TUPLES
X
Y
Z
W
PROPERLY
ENCODED
THAT
SATISFY
X
Y
Z
AND
A
FINITE
STATE
MACHINE
THAT
ACCEPTS
TUPLES
X
Y
Z
W
PROPERLY
ENCODE
THAT
SATISFY
Y
Z
W
X
EXPLAIN
WHY
IF
YOU
HAVE
FINITE
STATE
MACHINES
FOR
X
Y
Z
AND
Y
Z
W
X
YOU
CAN
GET
A
FINITE
STATE
MACHINE
TO
TUPLES
X
Y
Z
W
PROPERLY
ENCODE
THAT
SATISFY
X
Y
Z
AND
NOT
Y
Z
W
X
NOW
CONSIDER
THE
QUANTIFIERS
FROM
THE
INSIDE
OUT
EXPLAIN
HOW
TO
CONSTRUCT
A
FINITE
STATE
MACHINE
THAT
ACCEPTS
TUPLES
X
Y
Z
PROPERLY
ENCODED
WITH
THE
PROPERTY
THAT
THEREEXISTS
W
SUCH
THAT
X
Y
Z
AND
NOT
Y
Z
W
X
EXPLAIN
HOW
TO
CONSTRUCT
A
FINITE
STATE
MACHINE
THAT
ACCEPTS
TUPLES
X
Y
PROPERLY
ENCODED
WITH
THE
PROPERTY
THAT
FORALL
Z
THEREEXISTS
W
SUCH
THAT
X
Y
Z
AND
NOT
Y
Z
W
X
EXTEND
THIS
TO
THE
WHOLE
FORMULA
THEN
EXPLAIN
HOW
TO
USE
THE
FINAL
FINITE
STATE
MACHINE
TO
GET
YOUR
FINAL
ANSWER
IT
IS
OK
FOR
YOUR
WRITE
UP
TO
USE
THIS
EXAMPLE
BUT
IT
SHOULD
ALSO
EXPLAIN
HOW
THE
ALGORITHM
WOULD
WORK
ON
A
GENERIC
INSTANCE
CONCENTRATE
ON
HIGH
LEVEL
IDEAS
NOT
LOW
LEVEL
DETAILS
THE
PURPOSE
OF
THE
PROBLEM
IS
TO
INCREASE
YOUR
COMFORT
WITH
FIRST
ORDER
LOGIC
DUE
FRIDAY
SEPTEMBER
EMAIL
TO
PITT
EDU
BY
NOON
RECALL
THE
DEFINITION
OF
ENTROPY
OF
A
PROBABILITY
DISTRIBUTION
X
OVER
A
SET
U
H
X
X
IN
U
PROB
X
LG
PROB
X
NOW
DEFINE
THE
CONDITIONAL
ENTROPY
OF
NOT
NECESSARILY
INDEPENDENT
PROBABILITY
DISTRIBUTIONS
X
AND
Y
TO
BE
H
X
Y
Y
PROB
Y
X
PROB
X
Y
LG
PROB
X
Y
SUBPROBLEM
A
PROVE
THAT
H
X
Y
X
Y
PROB
X
Y
LG
PROB
X
Y
SUBPROBLEM
B
EXPLAIN
WHY
INTUITIVELY
H
X
Y
TELLS
YOU
HOW
MUCH
INFORMATION
ONE
GAINS
FROM
SEEING
THE
OUTCOME
OF
X
GIVEN
THAT
ONE
HAS
ALREADY
SEEN
THE
OUTCOME
OF
Y
SUBPROBLEM
C
PROVE
THAT
H
X
H
X
Y
H
Y
H
Y
X
SUBPROBLEM
D
CONSIDER
THE
PROCESS
OF
DRAWING
CARDS
WITHOUT
REPLACEMENT
FROM
A
DECK
AND
THEN
LOOKING
AT
THE
CARDS
IN
SOME
ORDER
WHAT
DOES
THE
ABOVE
STATEMENT
SAY
ABOUT
HOW
THE
ORDER
THAT
YOU
LOOK
AT
THE
CARDS
AFFECTS
THE
AMOUNT
OF
INFORMATION
THAT
YOU
RECEIVE
AFTER
EACH
TIME
YOU
LOOK
AT
THE
CARDS
THE
PURPOSE
OF
THIS
PROBLEM
IS
TO
GET
MORE
CONFORTABLE
WITH
BOTH
THE
INTUITION
AND
FORMAL
DEFINITIONS
OF
ENTROPY
DUE
MONDAY
SEPTEMBER
ASSUME
A
LOG
SPACE
REDUCTION
FROM
A
LANGUAGE
A
TO
A
LANGUAGE
B
SO
MORE
PRECISELY
THERE
IS
A
TURING
MACHINE
T
WITH
THREE
TAPES
A
READ
ONLY
INPUT
TAPE
A
READ
WRITE
WORK
TAPE
AND
A
WRITE
ONLY
OUTPUT
TAPE
T
ONLY
USES
LOG
OF
THE
INPUT
SIZE
MANY
CELLS
ON
THE
READ
WRITE
WORK
TAPE
FURTHER
T
NEVER
BACKS
UP
THE
TAPE
HEAD
ON
THE
WRITE
ONLY
OUTPUT
TAPE
SO
THE
TAPE
HEAD
ON
THE
WRITE
ONLY
TAPE
EITHER
STAYS
IN
POSITION
OR
MOVES
TO
THE
RIGHT
THE
MACHINE
T
HAS
THE
PROPERTY
THAT
A
STRING
X
IN
IN
A
IFF
THE
CONTENTS
OF
THE
WRITE
TAPE
WHEN
T
ENDS
COMPUTATION
ON
INPUT
X
IS
IN
B
NOW
SHOW
THAT
IF
THERE
IS
A
LOG
SPACE
TURING
MACHINE
THAT
ACCEPTS
B
THEN
THERE
IS
A
LOG
SPACE
TURING
MACHINE
U
THAT
ACCEPTS
A
NOTE
THAT
THIS
IS
NOT
TRIVIAL
BECAUSE
U
WILL
HAVE
ENOUGH
WORK
TAPE
TO
WRITE
DOWN
THE
OUTPUT
OF
T
THIS
IS
A
GOOD
PROBLEM
TO
SHOW
HOW
TO
MAKE
USE
OF
THE
FACT
THAT
SPACE
IS
REUSABLE
DUE
WEDNESDAY
OCTOBER
CONSIDER
THE
FOLLOWING
GAME
PLAYED
BY
TWO
PLAYERS
A
AND
B
ON
A
DIRECTED
GRAPH
G
WITH
A
DESIGNATED
START
VERTEX
ON
THE
FIRST
MOVE
PLAYER
A
PICKS
AN
EDGE
V
LEAVING
THEN
AND
V
ARE
DESIGNATED
AS
VISITED
ON
EACH
EVEN
NUMBERED
MOVE
PLAYER
B
PICKS
AN
EDGE
V
W
FROM
THE
CURRENT
VERTEX
V
TO
A
VERTEX
W
HASN
T
BEEN
VISITED
BEFORE
IF
NO
SUCH
VERTEX
W
EXISTS
THEN
PLAYER
B
LOSES
VERTEX
W
THEN
IS
DESIGNATED
AS
VISITED
AND
BECOMES
THE
CURRENT
VERTEX
ON
EACH
ODD
NUMBERED
MOVE
PLAYER
A
PICKS
AN
EDGE
V
W
FROM
THE
CURRENT
VERTEX
V
TO
A
VERTEX
W
HASN
T
BEEN
VISITED
BEFORE
IF
NO
SUCH
VERTEX
W
EXISTS
THEN
PLAYER
A
LOSES
VERTEX
W
THEN
IS
DESIGNATED
AS
VISITED
AND
BECOMES
THE
CURRENT
VERTEX
SO
THE
PLAYERS
A
AND
B
TAKING
TURNS
PICKING
EDGES
IN
A
DIRECTED
PATH
P
STARTING
AT
WITH
A
PLAYER
LOSING
IF
HE
SHE
CAN
T
EXTEND
THE
PATH
PROVE
THAT
DETERMINING
FOR
A
PARTICULAR
G
AND
WHETHER
THE
FIRST
PLAYER
HAS
A
WINNING
STRATEGY
IS
PSPACE
COMPLETE
UNDER
POLYNOMIAL
TIME
REDUCTIONS
YOU
CAN
PROVE
HARDNESS
BY
REDUCTION
FROM
THE
PROBLEM
OF
DETERMINING
WHETHER
A
QUANTIFIED
BOOLEAN
FORMULA
F
IS
TRUE
HINT
CONCEPTUALLY
THE
GRAPH
G
WILL
HAVE
TWO
PARTS
AND
THAT
P
WILL
TRAVERSE
IN
THAT
ORDER
IN
SOME
SENSE
REPRESENTS
THE
QUANTIFIERS
IN
F
SO
THERE
WILL
ONE
VERTEX
IN
FOR
EACH
QUANTIFIER
IN
F
AND
FOR
EACH
SUCH
VERTEX
THERE
WILL
BE
TWO
EXITING
EDGES
CORRESPONDING
TO
TRUE
AND
FALSE
THEN
NEEDS
TO
VERIFY
THAT
THERE
ARE
CHOICES
FOR
THE
FIRST
PLAYER
CORRESPONDING
TO
THE
EXISTENTIAL
QUANTIFICATIONS
IN
F
IN
SUCH
THAT
FOR
ALL
CHOICES
OF
THE
SECOND
PLAYER
CORRESPONDING
TO
THE
UNIVERSAL
QUANTIFICATIONS
IN
THE
FIRST
PLAYER
WILL
WIN
IFF
F
IS
TRUE
DUE
FRIDAY
OCTOBER
SHOW
THAT
IF
SAT
IS
POLYNOMIAL
TIME
MANY
TO
ONE
REDUCIBLE
TO
THE
COMPLEMENT
OF
SAT
THAT
THE
POLYNOMIAL
TIME
HIERARCHY
IS
EQUAL
TO
NP
THIS
IS
PROBLEM
FROM
THE
TEXT
THE
PURPOSE
OF
THE
PROBLEM
IS
TO
GET
COMFORTABLE
WITH
THE
DEFINITION
OF
THE
POLYNOMIAL
TIME
HIERARCHY
THE
PROBLEM
IS
ALMOST
TRIVIAL
IF
ONE
WAS
COMFORTABLE
WITH
THIS
DEFINITION
DUE
MONDAY
OCTOBER
EMAIL
TO
MICHAEL
PITT
EDU
BY
NOON
THE
TIME
HIERARCHY
THEOREM
LEAVES
OPEN
THE
POSSIBILITY
THAT
TIME
N
TIME
N
LOG
LOG
N
SHOW
THAT
IT
IS
UNLIKELY
THAT
ONE
CAN
SHOW
THAT
TIME
N
TIME
N
LOG
LOG
N
BY
SIMULATION
BY
SHOWING
THAT
THERE
IS
AN
LANGUAGE
B
SUCH
THAT
TIME
N
B
IS
NOT
EQUAL
TIME
N
LOG
LOG
N
B
HINT
TRY
TO
MIMIC
THE
PROOF
THAT
THERE
IS
A
LANGUAGE
B
SUCH
THAT
P
B
IS
NOT
EQUAL
NP
B
FIRST
ASK
YOURSELF
WHAT
QUESTION
ABOUT
B
CAN
A
TIME
N
LOG
LOG
N
MACHINE
CAN
EASILY
ANSWER
THAT
A
TIME
N
MACHINE
CAN
NOT
ANSWER
OBVIOUSLY
THE
PURPOSE
OF
THIS
PROBLEM
IS
TO
GET
MORE
COMFORTABLE
WITH
THE
BAKER
GILL
AND
SOLOWAY
RESULT
DUE
FRIDAY
OCTOBER
EMAIL
TO
MICHAEL
PITT
EDU
BY
NOON
SHOW
THAT
VC
DIMENSION
IS
P
COMPLETE
THIS
IS
EXERCISE
IN
THE
HARD
COPY
FO
THE
BOOK
AND
EXERCISE
IN
THE
ONLINE
PRELIMINARY
COPY
HINT
THE
ONLINE
COPY
OF
THE
TEXT
HAS
A
SUGGESTION
I
M
NOT
SURE
HOW
HARD
THIS
PROBLEM
IS
SO
IT
MAY
BE
HARD
THE
PURPOSE
OF
THE
PROBLEM
IS
TO
GAIN
COMFORT
WITH
THE
CONCEPT
OF
COMPLETENESS
AND
THE
DEFINITION
OF
THE
POLYNOMIAL
TIME
HIERARCHY
DUE
MONDAY
OCTOBER
SHOW
THAT
NC
IS
A
SUBSET
OF
LOGSPACE
HINT
THIS
OF
THE
NC
COMPUTATION
AS
A
CIRCUIT
SHOW
HOW
TO
COMPUTE
THE
VALUE
OF
THE
CIRCUIT
USING
LOG
SPACE
DFS
DUE
WEDNESDAY
OCTOBER
PROBLEMS
AND
FROM
THE
TEXT
THEY
ARE
RELATED
AND
QUITE
EASY
SHOW
THAT
FOR
EVERY
K
THAT
P
HAS
LANGUAGES
WHOSE
CIRCUIT
COMPLEXITY
IS
OMEGA
N
K
THE
CIRCUIT
COMPLEXITY
IS
THE
SIZE
OF
THE
MINIMUM
SIZED
CIRCUIT
THAT
DECIDES
THE
LANGUAGE
SHOW
THAT
IF
P
NP
THEN
THERE
IS
A
LANGUAGE
IN
EXPONENTIAL
TIME
THAT
REQUIRES
CIRCUITS
OF
SIZE
OMEGA
N
N
HINT
THE
ANSWER
FOR
SHOULD
BE
USEFUL
DUW
FRIDAY
OCTOBER
PROVE
THAT
ZPP
RP
INTERSECT
CO
RP
PROBLEM
FROM
THE
TEXT
THIS
IS
PROBLEM
IN
CHAPTER
IN
THE
ONNLINE
PRELIMINARY
VERSION
OF
THE
TEXT
DUE
WEDNESDAY
OCTOBER
THIS
HOMEWORK
IS
TO
BE
DONE
IDIVIDUALLY
NOT
IN
YOUR
GROUP
READ
THE
HISTORY
OF
THE
IP
PSPACE
RESULT
GIVEN
IN
HTTP
WWW
CS
PITT
EDU
KIRK
BABAIIPSTORY
PDF
WRITE
A
PARAGRAPH
EXPLAINING
WHAT
YOU
THINK
WAS
THE
RIGHT
WAY
TO
HANDLE
THE
PUBLICATION
ISSUE
THAT
IS
WHAT
PAPERS
SHOULD
HAVE
COME
OUT
OF
THIS
AND
WHO
SHOULD
THE
AUTHORS
HAVE
BEEN
DUE
MONDAY
OCTOBER
PROBLEM
FROM
THE
TEXT
THIS
IS
THE
SAME
AS
PROBLEM
MINUS
PART
C
IN
CHAPTER
IN
THE
ONLINE
PRELIMINARY
VERSION
OF
THE
TEXT
DUE
WEDNESDAY
OCTOBER
SHOW
THAT
MAM
IS
A
SUBSET
OF
AM
NOTE
THAT
THIS
IS
A
SPECIAL
CASE
OF
IN
THE
TEXT
AND
THAT
THERE
IS
A
HINT
IN
THE
BOOK
DUE
MONDAY
NOVEMBER
EMAIL
TO
THE
TA
BY
NOON
PROBLEM
FROM
THE
TEXT
I
STRONGLY
ENCOURAGE
YOU
TO
FIRST
DO
THE
PROOF
FOR
WHEN
N
DUE
FRIDAY
NOBEMBER
EMAIL
TO
THE
TA
BY
NOON
FROM
THE
TEXT
DUE
WEDNESDAY
NOVEMBER
PROBLEM
FROM
THE
TEXT
DUE
FRIDAY
NOVEMBER
READ
AND
UNDERSTAND
THE
PROTOCOL
IN
PROBLEM
EXERCISE
PART
B
FROM
THE
TEXT
WRITE
A
ONE
PARAGRAPH
SUMMARY
OF
THE
PROTOCOL
IN
YOUR
OWN
WORDS
THEN
WRITE
A
PARAGRAPH
EXPLAINING
INTUITIVELY
WHAT
IT
MEANS
FOR
AN
INTERACTIVE
PROOF
TO
BE
COMPUTATIONALLY
ZERO
KNOWLEDGE
THEN
WRITE
A
PARAGRAPH
TO
EXPLAIN
WHY
IT
IS
INTUITIVELY
BELIEVABLE
WHY
THIS
PROTOCOL
IS
COMPUTATIONALLY
ZERO
KNOWLEDGE
RECALL
THE
SILVERED
MIRROR
EXPERIMENT
WHICH
WAS
ESSENTIALLY
A
HADAMARD
GATE
FOLLOWED
BY
A
NOT
FOLLOWED
BY
A
HADAMARD
GATE
IN
THIS
EXPERIMENT
THE
STATE
OF
THE
BIT
COMING
OUT
OF
THE
HADAMARD
GATE
WAS
THE
SAME
AS
THE
STATE
OF
THE
BIT
ENTERING
IF
THE
ENTERING
BIT
WAS
NOT
IN
SUPERPOSITION
SHOW
BY
BASIC
CALCULATIONS
THAT
THIS
REMAINS
TRUE
IF
THE
ENTERING
BIT
IS
IN
SUPERPOSITION
DUE
MONDAY
OCTOBER
DUE
MONDAY
NOVEMBER
PART
A
SHOW
THAT
IF
YOU
HAVE
A
BIT
SYSTEM
IN
STATE
A
B
C
D
CONSIDER
TWO
EXPERIMENTS
IN
ONE
YOU
MEASURE
THE
FIRST
QUBIT
AND
THEN
MEASURE
THE
SECOND
QUBIT
AND
IN
THE
OTHER
YOU
MEASURE
THE
SECOND
QUBIT
AND
THEN
MEASURE
THE
FIRST
QUBIT
SHOW
THAT
THE
PROBABILITY
DISTRIBUTIONS
THAT
THE
CLASSICAL
BITS
THAT
YOU
OBSERVE
IN
THE
END
IS
INDEPENDENT
THE
ORDER
THAT
YOU
LOOK
AT
THE
BITS
THIS
IS
VERY
EASY
BUT
AND
IS
JUST
A
WARM
UP
PROBLEM
TO
GET
YOUR
BRAIN
FLOWING
PART
B
WORK
OUT
IN
DETAIL
THE
PROBABILITY
THAT
ALICE
AND
BOB
OBSERVE
A
B
IN
THE
CASE
THAT
X
Y
IN
THE
EPR
EXPERIMENT
IN
THE
BOOK
SHOW
EVERY
STEP
OF
YOUR
CALCULATIONS
AND
GIVE
LOTS
OF
EXPLANATION
DUE
WEDNESDAY
NOVEMBER
CONSIDER
THE
SAME
SET
UP
AS
THE
PARITY
GAME
ALICE
AND
BOB
SPLIT
TWO
ENTANGLED
BITS
ALICE
AND
BOB
ARE
THEN
SPLIT
UP
ALICE
IS
THEN
GIVEN
CLASSICAL
BITS
X
AND
Y
DEPENDING
ON
THE
VALUE
OF
X
AND
Y
ALICE
SENDS
BOB
QUBIT
FROM
THIS
SINGLE
QUBIT
BOB
DETERMINES
WITH
CERTAINTY
THE
TWO
CLASSICAL
BITS
X
AND
Y
FROM
HIS
ENTANGLED
BIT
AND
THE
SENT
QUBIT
EXPLAIN
HOW
TO
ACCOMPLISH
THIS
YOU
NEED
TO
EXPLAIN
ALICE
ENCODING
STRATEGY
BOB
DECODING
STRATEGY
AND
WHY
THESE
STRATEGIES
WORK
NOTE
THAT
YOU
CAN
EXTEND
THIS
TO
ALLOW
FOR
THE
TRANSMISSION
OF
CLASSICAL
BITS
USING
ONLY
N
QUANTUM
BITS
HINT
THE
POSSIBLE
STATES
OF
THE
SENT
QUBIT
WILL
BE
SQRT
SQRT
SQRT
SQRT
SQRT
SQRT
SQRT
SQRT
DUE
FRIDAY
NOVEMBER
THE
GOAL
OF
THIS
PROBLEM
IS
TO
FIND
A
WAY
TO
TRANSMIT
INFORMATION
ABOUT
A
QUBIT
BY
SENDING
TWO
CLASSICAL
BITS
ALICE
AND
BOB
SPLIT
UP
ENTANGLED
BITS
AB
IN
STATE
ASSUME
THAT
NOW
ALICE
IS
GIVEN
QUBIT
X
SO
X
IS
IN
SOME
UNKNOWN
SUPERPOSITION
BETWEEN
STATES
AND
ALICE
NOW
PERFORMS
THE
FOLLOWING
REVERSIBLE
OPERATION
ON
X
IF
A
THEN
NEGATE
X
ALICE
THEN
RUNS
QUBIT
A
THROUGH
A
HADAMARD
GATE
ALICE
NOW
MEASURES
THE
CURRENT
VALUES
OF
A
AND
X
AND
SENDS
THESE
TWO
CLASSICAL
BITS
TO
BOB
EXPLAIN
WHAT
THE
STATE
OF
ALL
THE
PARTICLES
A
B
AND
X
IS
AFTER
EACH
OF
ALICE
OPERATIONS
THEN
EXPLAIN
HOW
BOB
CAN
USE
THE
TWO
CLASSICAL
PARTICLES
TO
CHANGE
THE
STATE
OF
B
TO
THE
ORIGINAL
STATE
OF
X
NOTE
THAT
WHEN
ALICE
MEASURES
A
AND
X
THEN
SHE
CAN
NO
LONGER
RECOVER
THE
ORIGINAL
STATE
OF
QUBIT
X
DUE
MONDAY
NOVEMBER
PROBLEM
FROM
THE
TEXT
THIS
IS
VERY
EASY
PROBLEM
FROM
THE
TEXT
THIS
SHOULD
BE
PRETTY
STRAIGHTFORWARD
JUST
CONVERT
THE
INTERACTIVE
PROOF
FOR
THE
PERMANENT
FROM
CHAPTER
AS
THE
INTERACTIVE
PROOF
FOR
GRAPH
NON
ISOMORPHISM
WAS
CONVERTED
IN
EXAMPLE
DUE
WEDNESDAY
NOVEMBER
THERE
IS
NO
CLASS
ON
THIS
DAY
EMAIL
TO
THE
TA
BY
PROBLEM
FROM
THE
TEXT
NOTE
THAT
THE
PROBLEM
ALLOWS
FOR
RATIONAL
SOLUTIONS
PROBLEM
FROM
THE
TEXT
HINT
THERE
IS
A
SIMPLE
REDUCTION
FROM
MAXSAT
DUE
MONDAY
MONDAY
DECEMBER
THERE
IS
NO
CLASS
ON
THIS
DAY
EMAIL
TO
PEOPLE
CS
PITT
EDU
KIRK
NOTES
INFORMATIONNOTES
TXT
STRINGS
AMOUNT
OF
INFORMATION
APPROPRIATE
CONCEPT
TERABIT
OF
LOW
KOLMOGOROV
COMPLEXITY
TERABIT
OF
RANDOM
BITS
HIGH
ENTROPY
TERBIT
OF
BITS
OF
PI
LOW
KOLMOGOROV
COMPLEXITY
TERBIT
OF
WWW
PAGES
MEDIUM
KOLMOGOROV
COMPLEXITY
ENTROPY
EXAMPLES
COIN
FLIP
PROB
A
PROB
C
PROB
G
PROB
T
LEMMA
IF
X
AND
Y
ARE
INDEPENDENT
RANDOM
EVENTS
THEN
ENTROPY
H
SHOULD
SATISFY
H
X
Y
H
X
H
Y
ANOTHER
EXAMPLE
PROB
A
PROB
C
PROB
G
PROB
T
DEFINITION
ENTROPY
OF
A
PROBABILITY
DISTRIBUTION
X
OVER
A
SET
U
H
X
X
IN
U
PROB
X
LG
PROB
X
HERE
H
X
LG
PROB
X
IS
THE
ENTROPY
IN
BITS
OF
THE
STRING
X
NOTE
THAT
PROB
X
H
X
SO
H
X
IS
ABOUT
HOW
MANY
BITS
YOU
EXPECT
TO
SEE
SOURCE
CODING
THEOREM
SHANNON
ASSUMING
THAT
YOU
HAVE
AN
INPUT
THAT
IS
A
STRING
WHERE
EACH
ELEMENT
OF
IS
DRAWN
INDEPENDENTLY
ACCORDING
TO
A
DISTRIBUTION
X
THE
IS
A
SCHEME
THAT
CAN
TRANSMIT
USING
ONLY
ABOUT
H
X
BIT
EVERY
POSSIBLE
SCHEME
USES
AT
LEAST
ABOUT
H
X
BITS
PROOF
DIVIDE
INTO
BLOCKS
OF
SIZE
N
FOR
SOME
REASONABLY
LARGE
N
THE
PROBABILITY
THAT
A
BLOCK
WILL
BE
THE
STRING
VALUE
B
IS
X
IN
B
PROB
X
THE
EXPECTED
PROBABILITY
THAT
YOU
WILL
SEE
A
STRING
B
IS
X
IN
B
PROB
X
KEY
INSIGHT
IT
IS
VERY
LIKELY
THAT
YOU
WILL
SEE
A
BLOCK
B
WHOSE
PROBABLITY
IS
ABOUT
N
H
X
SO
THE
DISTRIBUTION
YOU
SEE
FOR
A
PARTICULAR
BLOCK
IS
VERY
CLOSE
TO
A
UNIFORM
DISTRIBUTION
OVER
N
H
X
ACHIEVABILITY
SO
MOSTLY
YOU
SEE
BLOCKS
OF
SIZE
N
OF
EQUAL
PROBABILITY
SO
YOU
USE
NH
X
BITS
FOR
EACH
SUCH
EQUALLY
PROBABLE
BLOCK
USE
ANY
REASONABLE
ENCODING
ON
THE
UNLIKELY
BLOCKS
OPTIMALITY
FORGET
ABOUT
ENCODING
UNLIKELY
STRINGS
YOU
CAN
T
DO
BETTER
THAN
USING
AN
EQUAL
NUMBER
OF
BITS
FOR
EQUALLY
PROBABLE
OUTCOMES
KOLMOGOROV
COMPLEXITY
INTUITION
MEASURES
INFORMATION
OF
A
FIXED
STRING
RATHER
THAN
A
DISTRIBUTION
OVER
STRINGS
OBJECTS
AS
DOES
ENTROPY
DEFINITION
THE
KOLMOGOROV
COMPLEXITY
K
X
OF
A
STRING
X
IS
DEFINED
TO
BE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
NOTES
INFORMATIONNOTES
TXT
PEOPLE
CS
PITT
EDU
KIRK
NOTES
INFORMATIONNOTES
TXT
K
X
STRINGS
Y
AND
DECODERS
D
SUCH
THAT
D
Y
X
LENGTH
OF
Y
PLUS
LENGTH
OF
D
PROGRAMS
P
THAT
WRITE
X
ON
AN
EMPTY
INPUT
LENGTH
OF
P
THEOREM
THE
PROGRAMMING
LANGUAGE
ONLY
AFFECTS
K
X
BY
AN
ADDITIVE
CONSTANT
THEOREM
THERE
ARE
INCOMPRESSABLE
STRINGS
STRINGS
WHERE
K
X
LENGTH
OF
X
OF
EVERY
LENGTH
N
PROOF
PIGEON
HOLE
PRINCIPLE
THEOREM
THERE
IS
NO
ALGORITHM
M
TO
COMPUTE
K
X
PROOF
TO
REACH
A
CONTRADICTION
ASSUME
M
EXISTS
CONSIDER
THE
PROGRAM
FOR
I
TO
N
DO
IF
M
ITH
STRING
OF
LENGTH
N
N
THEN
OUTPUT
THIS
STRING
AND
HALT
NOTE
THAT
BY
THE
PREVIOUS
THOEREM
ALWAYS
HALTS
AND
OUTPUTS
A
STRING
WITH
KOLMOGOROV
COMPLEXITY
AT
LEAST
N
BUT
AS
HAS
ONLY
O
LOG
N
SO
FOR
SOME
SUFFICIENTLY
LARGE
N
WE
GET
A
CONTRADICTION
TO
THE
OUTPUT
OF
HAVING
KOLMOGOROV
COMPLEXITY
N
SINCE
IS
A
PROGRAM
OF
LENGTH
O
LOG
N
THAT
OUTPUTS
THIS
STRING
HTTP
PEOPLE
CS
PITT
EDU
KIRK
NOTES
INFORMATIONNOTES
TXT
PEOPLE
CS
PITT
EDU
KIRK
NOTES
LOGICNOTES
TXT
HISTORY
AND
BACKGROUND
HILBERT
PROBLEMS
FOR
THE
NEXT
CENTURY
HTTP
EN
WIKIPEDIA
ORG
WIKI
HILBERT
PROBLEM
PROVE
THAT
THE
AXIOMS
OF
ARITHMETIC
ARE
CONSISTENT
GODEL
INCOMPLETENESS
THEOREM
KIND
OF
KILL
HILBERT
SECOND
PROBLEM
THERE
IS
NO
SOUND
AND
COMPLETE
AXIOMIZATION
OF
ARITHMETIC
DEFINITION
AN
AXIOMIZATION
IS
SOUND
IF
AXIOMS
PHI
THEN
AXIOMS
PHI
THAT
IS
ONE
CAN
ONLY
DERIVE
TRUE
STATEMENTS
FROM
PHI
DEFINITION
AN
AXIOMIZATION
IS
COMPLETE
IF
AXIOMS
PHI
THEN
AXIOMS
PHI
THAT
IS
ONE
CAN
DERIVE
EVERY
TRUE
STATEMENT
USING
PHI
EXAMPLE
AXIOMS
OF
GROUP
THEORY
CLOSURE
FOR
ALL
A
B
IN
G
THE
RESULT
OF
THE
OPERATION
A
B
IS
ALSO
IN
G
ASSOCIATIVITY
FOR
ALL
A
B
AND
C
IN
G
THE
EQUATION
A
B
C
A
B
C
HOLDS
IDENTITY
ELEMENT
THERE
EXISTS
AN
ELEMENT
E
IN
G
SUCH
THAT
FOR
ALL
ELEMENTS
A
IN
G
THE
EQUATION
E
A
A
E
A
HOLDS
INVERSE
ELEMENT
FOR
EACH
A
IN
G
THERE
EXISTS
AN
ELEMENT
B
IN
G
SUCH
THAT
A
B
B
A
E
WHERE
E
IS
THE
IDENTITY
ELEMENT
VENN
DIAGRAM
NT
SOME
THEORY
OR
AXIOMIZATION
OF
NUMBERS
AND
N
IS
THE
STANDARD
MODEL
OF
ARITHMETIC
PHI
NT
PHI
N
PHI
NEITHER
N
PHI
NOT
N
NOT
PHI
N
NOT
PHI
NT
NOT
PHI
NOT
PHI
DETOUR
TO
REVIEW
SOME
BASIC
FIRST
ORDER
LOGIC
HTTP
PEOPLE
CS
PITT
EDU
KIRK
NOTES
LOGICNOTES
TXT
PEOPLE
CS
PITT
EDU
KIRK
NOTES
LOGICNOTES
TXT
GENERIC
MODEL
M
GENERIC
THEORY
T
GENERIC
STATEMENT
T
IS
A
THEORY
OF
M
IFF
T
IS
THE
SET
OF
LOGICAL
PROPOSITIONS
THAT
ARE
TRUE
FOR
M
DEFINITION
IF
ANY
MODEL
SATISFYING
ALSO
SATISFIES
DEFINITION
T
IF
ANY
MODEL
SATISFYING
T
ALSO
SATISFIES
DEFINITION
T
IF
THERE
IS
A
PROOF
OF
USING
T
AS
AXIOMS
DEFINITION
PROOF
SEQUENCE
OF
SENTENCES
SUCH
THAT
EACH
FORMULA
IS
AN
AXIOM
OR
EACH
FORMULA
FOLLOWS
FROM
SENTENCES
BY
A
PROOF
RULE
USUALLY
THE
PROOF
RULES
ARE
STANDARD
E
G
MODUS
PONENS
INDEPENDENT
OF
THE
SYSTEM
IN
QUESTION
TWO
WARM
UP
LEMMAS
DEFINITION
A
SET
IS
RECURSIVELY
ENUMERABLE
IFF
THERE
IS
A
PROGRAM
THAT
OUTPUTS
ONLY
MEMBERS
OF
THAT
SET
AND
EVERY
MEMBER
OF
THE
THAT
SET
IS
EVENTUALLY
OUTPUT
WARM
UP
LEMMA
THEOREMHOOD
AXIOMS
IS
RECURSIVELY
ENUMERABLE
IF
THE
AXIOMIZATION
IS
FINITE
IF
THERE
ONLY
ONLY
FINITELY
MANY
CONSEQUENCE
OF
ANY
PROOF
RULE
THEN
JUST
DO
A
BREADTH
FIRST
SEARCH
OF
THE
PROOF
TREE
OF
POSSIBLE
PROVES
WHAT
IF
YOU
HAVE
A
PROOF
RULE
LIKE
FORALL
X
PHI
X
YIELDS
PHI
PHI
ANSWER
ON
I
TH
ITERATION
CONSIDER
ALL
NODES
IN
DERIVATION
TREE
OF
DEPTH
I
WHERE
EACH
NODE
ON
PATH
FROM
THE
ROOT
IS
ONE
OF
THE
FIRST
I
CHILDREN
WARM
UP
LEMMA
IF
THERE
IS
A
SOUND
AND
COMPLETE
AXIOMIZATION
OF
ARITHMETIC
THEN
PHI
NUMBER
THEORY
PHI
IS
RECURSIVE
DECIDABLE
PROOF
SEARCH
FOR
ALL
PROOFS
FOR
PHI
AND
NOT
PHI
DOVETAILING
THE
SEARCHES
AND
NOW
THE
PROOF
PROOF
OF
GODEL
INCOMPLETENESS
THEOREM
BY
REDUCTION
FROM
THE
HALTING
PROBLEM
LET
P
AND
I
BE
THE
INPUT
TO
THE
HALTING
PROBLEM
WE
WANT
TO
CREATE
A
FIRST
ORDER
SENTENCE
OF
THE
FORM
THEREEXISTS
W
P
W
WHERE
P
W
VERIFIES
THAT
W
IS
A
VALID
COMPUTATION
HISTORY
OF
P
ON
I
NOW
SINCE
PHI
NUMBER
THEORY
PHI
IS
RECURSIVE
WE
CAN
TO
DETERMINE
WHETHER
THEREEXISTS
W
P
W
OR
NOT
THEREEXISTS
W
P
W
IS
TRUE
THIS
ALLOWS
US
TO
DECIDE
WHETHER
P
HALTS
ON
I
HOW
FIND
P
W
CONFIGURATIONS
ARE
ENCODED
AS
STRINGS
AS
PROOF
OF
TERM
REWRITING
IF
THERE
ARE
B
SYMBOLS
THEN
THESE
STRINGS
ARE
THEN
READ
AS
BASE
B
INTEGERS
YIELDS
C
D
WHERE
C
ARE
D
ARE
INTEGERS
THAT
ENCODE
CONFIGURATIONS
CAN
BE
EXPRESSED
IN
FIRST
ORDER
LOGIC
THE
DIV
AND
MOD
OPERATORS
ALLOW
YOU
TO
CUT
THE
STRING
THERE
EXIST
TWO
PLACES
TO
CUT
C
AND
D
SUCH
THAT
C
AND
D
ARE
EQUAL
TO
THE
LEFT
OF
THE
LEFT
CUT
AND
TO
THE
RIGHT
OF
THE
RIGHT
CUT
AND
ARE
RELATED
BY
THE
TABLE
RELATION
IN
THE
FIXED
NUMBER
OF
PLACES
BETWEEN
THE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
NOTES
LOGICNOTES
TXT
PEOPLE
CS
PITT
EDU
KIRK
NOTES
LOGICNOTES
TXT
CUTS
THE
FACT
THAT
A
SEQUENCE
OF
CONFIGURATIONS
PUT
A
NEW
SYMBOL
BETWEEN
EACH
CONFIGURATION
ENCODES
A
COMPUTATION
CAN
BE
EXPRESSED
IN
FIRST
ORDER
LOGIC
IN
THE
FOLLOWING
WAY
EACH
CONFIGURATION
YIELDS
THE
NEXT
THE
FIRST
CONFIGURATION
IS
THE
STARTING
CONFIGURATION
AND
THE
LAST
CONFIGURATION
IS
THE
ACCEPTING
CONFIGURATION
PROOF
BY
EXAMPLE
CONSIDER
THE
TURING
MACHINE
STATES
P
START
Q
H
HALT
INPUT
SYMBOLS
SPACE
P
Q
RIGHT
P
P
RIGHT
Q
P
LEFT
Q
P
RIGHT
P
SPACE
H
SPACE
STAY
Q
SPACE
H
SPACE
STAY
INPUT
PARALLEL
COMPUTATION
THESIS
FROM
WIKIPEDIA
THE
FREE
ENCYCLOPEDIA
IN
COMPUTATIONAL
COMPLEXITY
THEORY
THE
PARALLEL
COMPUTATION
THESIS
IS
A
HYPOTHESIS
WHICH
STATES
THAT
THE
TIME
USED
BY
A
REASONABLE
PARALLEL
MACHINE
IS
POLYNOMIALLY
RELATED
TO
THE
SPACE
USED
BY
A
SEQUENTIAL
MACHINE
THE
PARALLEL
COMPUTATION
THESIS
WAS
SET
FORTH
BY
CHANDRA
AND
STOCKMEYER
IN
IN
OTHER
WORDS
FOR
A
COMPUTATIONAL
MODEL
WHICH
ALLOWS
COMPUTATIONS
TO
BRANCH
AND
RUN
IN
PARALLEL
WITHOUT
BOUND
A
FORMAL
LANGUAGE
WHICH
IS
DECIDABLE
UNDER
THE
MODEL
USING
NO
MORE
THAN
STEPS
FOR
INPUTS
OF
LENGTH
N
IS
DECIDABLE
BY
A
NONBRANCHING
MACHINE
USING
NO
MORE
THAN
UNITS
OF
STORAGE
FOR
SOME
CONSTANT
K
SIMILARLY
IF
A
MACHINE
IN
THE
UNBRANCHING
MODEL
DECIDES
A
LANGUAGE
USING
NO
MORE
THAN
STORAGE
A
MACHINE
IN
THE
PARALLEL
MODEL
CAN
DECIDE
THE
LANGUAGE
IN
NO
MORE
THAN
STEPS
FOR
SOME
CONSTANT
K
THE
PARALLEL
COMPUTATION
THESIS
IS
NOT
A
RIGOROUS
FORMAL
STATEMENT
AS
IT
DOES
NOT
CLEARLY
DEFINE
WHAT
CONSTITUTES
AN
ACCEPTABLE
PARALLEL
MODEL
A
PARALLEL
MACHINE
MUST
BE
SUFFICIENTLY
POWERFUL
TO
EMULATE
THE
SEQUENTIAL
MACHINE
IN
TIME
POLYNOMIALLY
RELATED
TO
THE
SEQUENTIAL
SPACE
COMPARE
TURING
MACHINE
NONDETERMINISTIC
TURING
MACHINE
AND
ALTERNATING
TURING
MACHINE
N
BLUM
INTRODUCED
A
MODEL
FOR
WHICH
THE
THESIS
DOES
NOT
HOLD
HOWEVER
THE
MODEL
ALLOWS
PARALLEL
THREADS
OF
COMPUTATION
AFTER
STEPS
SEE
BIG
O
NOTATION
PARBERRY
SUGGESTED
A
MORE
REASONABLE
BOUND
WOULD
BE
OR
IN
DEFENSE
OF
THE
THESIS
GOLDSCHLAGER
PROPOSED
A
MODEL
WHICH
IS
SUFFICIENTLY
UNIVERSAL
TO
EMULATE
ALL
REASONABLE
PARALLEL
MODELS
WHICH
ADHERES
TO
THE
THESIS
CHANDRA
AND
STOCKMEYER
ORIGINALLY
FORMALIZED
AND
PROVED
RESULTS
RELATED
TO
THE
THESIS
FOR
DETERMINISTIC
AND
ALTERNATING
TURING
MACHINES
WHICH
IS
WHERE
THE
THESIS
ORIGINATED
TOFFOLI
GATE
FROM
WIKIPEDIA
THE
FREE
ENCYCLOPEDIA
IN
LOGIC
CIRCUITS
THE
TOFFOLI
GATE
ALSO
CCNOT
GATE
INVENTED
BY
TOMMASO
TOFFOLI
IS
A
UNIVERSAL
REVERSIBLE
LOGIC
GATE
WHICH
MEANS
THAT
ANY
REVERSIBLE
CIRCUIT
CAN
BE
CONSTRUCTED
FROM
TOFFOLI
GATES
IT
IS
ALSO
KNOWN
AS
THE
CONTROLLEDCONTROLLEDNOT
GATE
WHICH
DESCRIBES
ITS
ACTION
IT
HAS
INPUTS
AND
OUTPUTS
IF
THE
FIRST
TWO
BITS
ARE
SET
IT
INVERTS
THE
THIRD
BIT
OTHERWISE
ALL
BITS
STAY
THE
SAME
CONTENTS
BACKGROUND
UNIVERSALITY
AND
TOFFOLI
GATE
RELATED
LOGIC
GATES
RELATION
TO
QUANTUM
COMPUTING
SEE
ALSO
REFERENCES
EXTERNAL
LINKS
BACKGROUND
AN
INPUTCONSUMING
LOGIC
GATE
L
IS
REVERSIBLE
IF
FOR
ANY
OUTPUT
Y
THERE
IS
A
UNIQUE
INPUT
X
SUCH
THAT
APPLYING
L
X
Y
IF
A
GATE
L
IS
REVERSIBLE
THERE
IS
AN
INVERSE
GATE
L
WHICH
MAPS
Y
TO
X
FOR
WHICH
L
Y
X
FROM
COMMON
LOGIC
GATES
NOT
IS
REVERSIBLE
AS
CAN
BE
SEEN
FROM
ITS
TRUTH
TABLE
BELOW
INPUT
OUTPUT
THE
COMMON
AND
GATE
IS
NOT
REVERSIBLE
HOWEVER
THE
INPUTS
AND
ARE
ALL
MAPPED
TO
THE
OUTPUT
REVERSIBLE
GATES
HAVE
BEEN
STUDIED
SINCE
THE
THE
ORIGINAL
MOTIVATION
WAS
THAT
REVERSIBLE
GATES
DISSIPATE
LESS
HEAT
OR
IN
PRINCIPLE
NO
HEAT
IF
WE
THINK
OF
A
LOGIC
GATE
AS
CONSUMING
ITS
INPUT
INFORMATION
IS
LOST
SINCE
LESS
INFORMATION
IS
PRESENT
IN
THE
OUTPUT
THAN
WAS
PRESENT
AT
THE
INPUT
THIS
LOSS
OF
INFORMATION
LOSES
ENERGY
TO
THE
SURROUNDING
AREA
AS
HEAT
BECAUSE
OF
THERMODYNAMIC
ENTROPY
ANOTHER
WAY
TO
UNDERSTAND
THIS
IS
THAT
CHARGES
ON
A
CIRCUIT
ARE
GROUNDED
AND
THUS
FLOW
AWAY
TAKING
A
SMALL
QUANTITY
OF
ENERGY
WITH
THEM
WHEN
THEY
CHANGE
STATE
A
REVERSIBLE
GATE
ONLY
MOVES
THE
STATES
AROUND
AND
SINCE
NO
INFORMATION
IS
LOST
ENERGY
IS
CONSERVED
MORE
RECENT
MOTIVATION
COMES
FROM
QUANTUM
COMPUTING
QUANTUM
MECHANICS
REQUIRES
THE
TRANSFORMATIONS
TO
BE
REVERSIBLE
BUT
ALLOWS
MORE
GENERAL
STATES
OF
THE
COMPUTATION
SUPERPOSITIONS
THUS
THE
REVERSIBLE
GATES
FORM
A
SUBSET
OF
GATES
ALLOWED
BY
QUANTUM
MECHANICS
AND
IF
WE
CAN
COMPUTE
SOMETHING
REVERSIBLY
WE
CAN
ALSO
COMPUTE
IT
ON
A
QUANTUM
COMPUTER
UNIVERSALITY
AND
TOFFOLI
GATE
TOFFOLI
GATE
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
ANY
REVERSIBLE
GATE
THAT
CONSUMES
ITS
INPUTS
AND
ALLOWS
ALL
INPUT
COMPUTATIONS
MUST
HAVE
NO
MORE
INPUT
BITS
THAN
OUTPUT
BITS
BY
THE
PIGEONHOLE
PRINCIPLE
FOR
ONE
INPUT
BIT
THERE
ARE
TWO
POSSIBLE
REVERSIBLE
GATES
ONE
OF
THEM
IS
NOT
THE
OTHER
IS
THE
IDENTITY
GATE
WHICH
MAPS
ITS
INPUT
TO
THE
OUTPUT
UNCHANGED
FOR
TWO
INPUT
BITS
THE
ONLY
NONTRIVIAL
GATE
IS
THE
CONTROLLED
NOT
GATE
WHICH
XORS
THE
FIRST
BIT
TO
THE
SECOND
BIT
AND
LEAVES
THE
FIRST
BIT
UNCHANGED
TRUTH
TABLE
PERMUTATION
MATRIX
FORM
INPUT
OUTPUT
UNFORTUNATELY
THERE
ARE
REVERSIBLE
FUNCTIONS
THAT
CANNOT
BE
COMPUTED
USING
JUST
THOSE
GATES
IN
OTHER
WORDS
THE
SET
CONSISTING
OF
NOT
AND
XOR
GATES
IS
NOT
UNIVERSAL
IF
WE
WANT
TO
COMPUTE
AN
ARBITRARY
FUNCTION
USING
REVERSIBLE
GATES
WE
NEED
ANOTHER
GATE
ONE
POSSIBILITY
IS
THE
TOFFOLI
GATE
PROPOSED
IN
BY
TOFFOLI
THIS
GATE
HAS
INPUTS
AND
OUTPUTS
IF
THE
FIRST
TWO
BITS
ARE
SET
IT
FLIPS
THE
THIRD
BIT
THE
FOLLOWING
IS
A
TABLE
OF
THE
INPUT
AND
OUTPUT
BITS
TRUTH
TABLE
PERMUTATION
MATRIX
FORM
INPUT
OUTPUT
IT
CAN
BE
ALSO
DESCRIBED
AS
MAPPING
BITS
A
B
C
TO
A
B
C
XOR
A
AND
B
THE
TOFFOLI
GATE
IS
UNIVERSAL
THIS
MEANS
THAT
FOR
ANY
BOOLEAN
FUNCTION
F
XM
THERE
IS
A
CIRCUIT
CONSISTING
OF
TOFFOLI
GATES
THAT
TAKES
XM
AND
SOME
EXTRA
BITS
SET
TO
OR
TO
OUTPUTS
XM
F
XM
AND
SOME
EXTRA
BITS
CALLED
GARBAGE
ESSENTIALLY
THIS
MEANS
THAT
ONE
CAN
USE
TOFFOLI
GATES
TO
BUILD
SYSTEMS
THAT
WILL
PERFORM
ANY
DESIRED
BOOLEAN
FUNCTION
COMPUTATION
IN
A
REVERSIBLE
MANNER
RELATED
LOGIC
GATES
THE
FREDKIN
GATE
IS
A
UNIVERSAL
REVERSIBLE
GATE
THAT
SWAPS
THE
LAST
TWO
BITS
IF
THE
FIRST
BIT
IS
A
CONTROLLEDSWAP
OPERATION
TOFFOLI
GATE
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
FREDKIN
TOFFOLI
BILLIARD
BALL
MODEL
FOR
GATES
THE
NBIT
TOFFOLI
GATE
IS
A
GENERALIZATION
OF
TOFFOLI
GATE
IT
TAKES
N
BITS
XN
AS
INPUTS
AND
OUTPUTS
N
BITS
THE
FIRST
N
OUTPUT
BITS
ARE
JUST
XN
THE
LAST
OUTPUT
BIT
IS
AND
AND
XN
XOR
XN
THE
TOFFOLI
GATE
CAN
BE
REALIZED
BY
FIVE
TWOQUBIT
QUANTUM
GATES
THIS
GATE
IS
ONE
OF
THE
REVERSIBLEGATE
CASES
THAT
CAN
BE
MODELED
WITH
BILLIARD
BALLS
SEE
BILLIARDBALL
COMPUTER
THE
BILLIARD
BALL
MODELING
WAS
INTRODUCED
BY
FREDKIN
AND
TOFFOLI
AN
EXAMPLE
OF
HOW
THE
COLLISIONS
ARE
USED
TO
MODEL
AN
ELECTRONIC
GATE
IS
SHOWN
IN
THE
FIGURE
RELATION
TO
QUANTUM
COMPUTING
ANY
REVERSIBLE
GATE
CAN
BE
IMPLEMENTED
ON
A
QUANTUM
COMPUTER
AND
HENCE
THE
TOFFOLI
GATE
IS
ALSO
A
QUANTUM
OPERATOR
HOWEVER
THE
TOFFOLI
GATE
CAN
NOT
BE
USED
FOR
UNIVERSAL
QUANTUM
COMPUTATION
THOUGH
IT
DOES
MEAN
THAT
A
QUANTUM
COMPUTER
CAN
IMPLEMENT
ALL
POSSIBLE
CLASSICAL
COMPUTATIONS
THE
TOFFOLI
GATE
HAS
TO
BE
IMPLEMENTED
ALONG
WITH
SOME
INHERENTLY
QUANTUM
GATE
IN
ORDER
TO
BE
UNIVERSAL
FOR
QUANTUM
COMPUTATION
IN
FACT
ANY
SINGLEQUBIT
GATE
WITH
REAL
COEFFICIENTS
THAT
CAN
CREATE
A
NONTRIVIAL
QUANTUM
STATE
SUFFICES
A
QUANTUM
MECHANICSBASED
TOFFOLI
GATE
HAS
BEEN
SUCCESSFULLY
REALIZED
IN
JANUARY
AT
THE
UNIVERSITY
OF
INNSBRUCK
AUSTRIA
SEE
ALSO
FREDKIN
GATE
REVERSIBLE
COMPUTING
BIJECTION
QUANTUM
COMPUTING
QUANTUM
GATE
QUANTUM
PROGRAMMING
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
IFYOUARETAKING
THE
FNALFORPRELIMINARY
EXAMCREDIT
THENWRITEYOURPRELIMINARY
NUMBER
GIVEN
TO
YOU
BY
KEENA
ON
THE
EXAM
ANSWER
SHEET
BUT
DO
NOT
WRITE
YOUR
NAME
IF
YOU
ARE
NOTTAKING
THE
FNALFORPRELIMINARY
EXAMCREDIT
WRITEYOURNAMEONTHEEXAMANSWERSHEET
IFYOUARETAKING
THECOURSEFOR
SOMEGRADING
OPTION
OTHERTHANTHESTANDARDLETTERGRADING
OPTION
PLEASE
SPECIFY
THAT
ON
YOUR
EXAM
ANSWER
SHEET
FORMOST
OF
THEPROBLEMS
I
AMINTERESTEDINTESTING
WHETHERYOUUNDERSTAND
THETECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IFI
ASKYOUTOPROVETHAT
APROBLEMISNP
HARD
I
AM
MOREINTERESTEDINLEARNINGIF
YOUKNOWHOWTOPROVETHATAPROBLEMISNP
HARD
THANI
AMINTHE
SPECIFCS
OFTHEPROBLEM
IFI
ASKYOUPROBLEMTHAT
AGREEDY
ALGORITHMIS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECIFCS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECIFC
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECIFCS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
YOUMUSTFULLYJUSTIFYALL
ASSERTIONSUNLESSSPECIFCALLYINSTRUCTED
NOTTODOSO
ALLARGUMENTS
SHOULDBEFROM
FRSTPRINCIPLES
E
G
YOUSHOULD
NOTUSERESULTSFROMCLASS
THEBOOK
ETC
UNLESS
IT
IS
EXPLICITLY
STATED
THAT
YOU
MAY
DO
SO
FOR
THAT
PARTICULAR
PROBLEM
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETEDAS
IDON
TKNOW
FALSEORCOMPLETELYUNSUBSTANTIATED
ASSERTIONSWILL
RECEIVELESSER
CREDIT
SOLVE
UP
TO
OF
THE
QUESTIONS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
SOLVING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
ASSUME
THE
FOLLOWING
THREE
STATEMENTS
THE
WORST
CASE
TIME
COMPLEXITY
OF
PROBLEM
P
IS
THE
WORST
CASE
TIME
COMPLEXITY
OF
PROBLEM
P
IS
O
A
IS
AN
ALGORITHM
FOR
PROBLEM
P
WHICH
STATEMENTS
OF
THE
FORM
THE
WORST
CASE
TIME
COMPLEXITY
OF
A
IS
O
F
N
ARE
LOGICALLY
IMPLIED
BY
THE
ABOVE
THREE
ASSUMED
STATEMENTS
THAT
IS
FOR
WHICH
F
N
IS
THE
RESULTING
STATEMENTLOGICALLY
IMPLIEDBY
THE
ABOVETHREE
ASSUMED
STATEMENTS
WHICH
STATEMENTS
OF
THE
FORM
THE
WORST
CASE
TIME
COMPLEXITY
OF
A
IS
O
F
N
ARE
LOGICALLY
CONSISTENT
WITH
THE
ABOVE
THREE
ASSUMED
STATEMENTS
THAT
IS
FOR
WHICH
F
N
ISTHE
RESULTINGSTATEMENTLOGICALLY
CONSISTENTBY
THEABOVETHREEASSUMED
STATEMENTS
WHICH
STATEMENTS
OF
THE
FORM
THE
WORST
CASE
TIME
COMPLEXITY
OF
A
IS
F
N
ARE
LOGICALLY
IMPLIED
BY
THE
ABOVE
THREE
ASSUMED
STATEMENTS
THAT
IS
FOR
WHICH
F
N
IS
THE
RESULTING
STATEMENTLOGICALLY
IMPLIEDBY
THE
ABOVETHREE
ASSUMED
STATEMENTS
WHICH
STATEMENTS
OF
THE
FORM
THE
WORST
CASE
TIME
COMPLEXITY
OF
A
IS
F
N
ARE
LOGICALLY
CONSISTENT
WITH
THE
ABOVE
THREE
ASSUMED
STATEMENTS
THAT
IS
FOR
WHICH
F
N
IS
THE
RESULTING
STATEMENT
LOGICALLY
CONSISTENT
WITH
THE
ABOVE
THREE
ASSUMED
STATEMENTS
GIVEAPROOF
OF
CORRECTNESSOFPRIM
SMINIMUMSPANNING
TREE
ALGORITHM
USING
AN
EXCHANGE
ARGUMENT
START
YOUR
ANSWER
WITH
A
ONE
OR
TWO
SENTENCE
EXPLANATION
OF
PRIM
ALGORITHM
IF
IT
IS
NOT
OBVIOUS
FROM
YOUR
WRITE
UP
ADDITIONALLY
EXPLAIN
WHY
AN
EXCHANGE
ARGUMENT
IS
SUCIENTTOPROVE
CORRECTNESS
PROVE
THAT
INTEGER
LINEAR
PROGRAMMING
IS
NP
HARD
USING
THE
FACT
THAT
IS
NP
HARD
START
YOUR
ANSWER
WITH
A
DEFNITION
OF
THE
INTEGER
LINEAR
PROGRAMMING
PROBLEM
AND
THE
CONSIDERTHEFOLLOWINGAUCTIONPROBLEM
YOUHAVENBIDDERS
BIDDER
I
SUBMITTED
APOSITIVE
INTEGER
BID
BI
IN
DOLLARS
AND
A
POSITIVE
INTEGER
SEAT
COUNT
CI
BIDDER
I
IS
WILLING
TO
PAY
UP
TO
BI
DOLLARS
TO
BUY
CI
TICKETS
TO
SOME
EVENT
THERE
IS
A
LIMIT
C
ON
THE
NUMBER
OF
SEATS
THAT
YOU
CAN
SELL
GIVEN
THIS
INFORMATION
YOU
WANT
TO
ASSIGN
A
PRICE
PI
TO
EACH
PERSON
A
PERSON
WILL
BUY
IF
AND
ONLY
IF
PI
BI
YOU
NEED
THAT
THE
TOTAL
NUMBER
OF
BOUGHT
SEATS
CAN
BE
AT
MOST
C
YOU
ALSO
NEED
THAT
YOUR
PRICING
IS
MONOTONE
IN
THE
SEAT
COUNT
SO
IF
CI
CJ
THEN
YOU
MUST
GUARANTEE
THAT
PI
PJ
OTHERWISE
CUSTOMERS
WILL
COMPLAIN
ABOUT
UNFAIRNESS
GIVENTHESE
CONSTRAINTS
YOU
WANTTO
MAXIMIZETHEPROFT
WHICHISTHE
SUM
OF
THE
PRICES
THAT
YOU
SET
GIVE
A
DYNAMIC
PROGRAMMING
ALGORITHM
WHOSE
RUNNING
TIME
IS
POLYNOMIAL
IN
N
AND
C
ASSUME
THAT
YOU
WISH
TO
APPLY
YAO
TECHNIQUE
TO
SHOW
THAT
ANY
O
TIME
RANDOMIZED
ALGORITHMFOR
APARTICULARPROBLEM
MUSTHAVEHIGHPROBABILITY
OF
ERROR
A
GIVE
A
ONE
OR
TWO
SENTENCE
EXPLANATION
OF
STATEMENT
OF
THE
APPROPRIATE
FORM
OF
YAO
TECHNIQUE
LEMMA
FOR
THIS
SETTING
THAT
IS
WHAT
DOES
YAO
TECHNIQUE
TELL
YOU
TO
PROVE
IF
YOU
WANT
TO
PROVE
THIS
LOWER
BOUND
B
GIVEAPROOF
THATYAO
STECHNIQUE
LEMMA
INTHISCONTEXT
ISCORRECT
AFTERYOUDEFNE
YOUR
NOTATION
THEPROOFISJUST
AFEWINEQUALITIES
JUST
STATE
EACHINEQUALITY
ANDGIVE
A
GOOD
SENTENCE
OR
TWO
OF
EXPLANATION
WHY
THAT
INEQUALITY
IS
TRUE
GIVEAN
ALGORITHMFORTHEPARALLELPREFXPROBLEMTHAT
WILL
RUNON
AMACHINEWHERECONCUR
RENT
READING
AND
OR
WRITING
OF
MEMORY
IS
NOT
ALLOWED
YOUR
ALGORITHM
SHOULD
RUN
IN
TIME
O
LOGN
ON
AN
INPUT
OF
SIZE
N
WITH
N
PROCESSORS
CONSIDER
A
STANDARD
BLOOM
FLTER
OF
SIZE
M
WITH
HASH
FUNCTIONS
HK
A
GIVEPSEUDO
CODE
TO
INSERT
AN
ITEM
INTO
A
BLOOM
FLTER
B
GIVEPSEUDO
CODE
TO
SEARCH
IF
AN
ITEM
WAS
PREVIOUSLY
INSERTED
INTO
A
BLOOM
FLTER
C
ASSUMETHATYOUHAVEPREVIOUSLYINSERTED
N
ITEMS
GIVE
A
FORMULAFOR
THEPROBABILITY
OF
AFALSEPOSITIVEFORA
SEARCH
THE
FORMULA
SHOULDBE
A
FUNCTION
OF
N
M
AND
K
THE
FORMULA
CAN
BE
A
BIT
COMPLICATED
BUT
IT
SHOULDN
T
BE
RIDICULOUSLY
COMPLICATED
YOU
DO
NOT
NEED
SIMPLIFY
THE
FORMULA
CONSIDERTHEEUCLIDEANTRAVELINGSALESMANPROBLEM
THEINPUTIS
ACOLLECTIONOFPOINTSIN
THE
EUCLIDEAN
PLANE
THE
OUTPUT
IS
THE
SHORTEST
WAY
TO
VISIT
ALL
THE
POINTS
STARTING
FROM
THE
ORIGIN
WITHOUT
LOSS
OF
GENERALITY
YOU
CAN
ASSUME
THAT
THE
ORIGIN
IS
ONE
OF
THE
INPUT
POINTS
GIVEAPOLYNOMIAL
APPROXIMATION
ALGORITHMFORTHISPROBLEM
MAKESURETO
CLEARLY
STATE
WHAT
LOWER
BOUND
YOU
ARE
USING
FOR
OPTIMAL
IN
YOUR
PROOF
OF
CORRECTNESS
ASSUME
THAT
YOU
HASH
N
ITEMS
INTO
A
CLOSED
ADDRESSED
HASH
TABLE
OF
SIZE
N
ASSUME
THAT
EACH
ITEM
IS
EQUALLY
LIKE
TO
HASH
TO
EACH
TABLE
ENTRY
INDEPENDENT
OF
THE
OTHER
ITEMS
LET
XI
BE
THE
NUMBER
OF
ITEMS
THAT
HASH
TO
TABLE
ENTRY
I
LET
X
MAXI
XI
SHOW
HOW
TO
COMPUTE
E
USING
INDICATOR
RANDOM
VARIABLES
AND
LINEARITY
OF
EXPEC
TATION
KK
N
NE
SHOW
THAT
E
X
O
LOGN
LOGLOGN
YOU
MAYASSUME
WITHOUTPROOF
THAT
K
KK
YOU
MAY
ALSO
ASSUME
WITHOUT
PROOF
THAT
IF
A
B
AND
C
ARE
CONSTANTS
THE
SOLUTION
TO
AK
BK
C
NIS
K
LOGN
LOGLOGN
ASSUME
THAT
YOU
HAVE
A
COLLECTION
OF
N
DI
ERENT
KINDS
OF
PILLS
THERE
ARE
ALSO
K
N
DI
ERENT
KINDS
OF
VITAMINS
FOR
EACH
PILL
AND
EACH
VITAMIN
YOU
KNOW
WHETHER
THAT
PILL
CONTAINS
THAT
VITAMIN
OR
NOT
IF
A
PILL
CONTAINS
A
VITAMIN
THEN
YOU
KNOW
THAT
IT
CONTAINS
EXACTLY
MILLIGRAM
OF
THAT
VITAMIN
PILL
I
COSTS
CI
DOLLARS
YOU
CAN
BUY
PART
OF
A
PILL
SO
OF
PILL
I
WILL
COST
DOLLARS
THE
GOAL
IS
SPEND
THE
LEAST
AMOUNT
OF
MONEY
SO
AS
TO
GET
AT
LEAST
MILLIGRAM
OF
EACH
TYPE
OF
VITAMIN
EXPLAINHOWTO
EXPRESSTHISPROBLEM
AS
ALINEARPROGRAM
GIVE
THE
DUAL
OF
THIS
LINEAR
PROGRAM
GIVE
AN
ENGLISH
INTERPRETATION
TO
THE
DUAL
PROBLEM
EXPLAIN
HOW
TO
SHOW
USING
THE
DUAL
A
LOWER
BOUND
ON
THE
AMOUNT
OF
MONEY
REQUIRED
FOR
APARTICULARINSTANCE
CONSIDER
THE
STANDARD
NETWORK
FOW
PROBLEM
LET
V
BE
THE
NUMBER
OF
VERTICES
IN
THE
INSTANCE
E
THE
NUMBER
OF
EDGES
IN
THE
INSTANCE
AND
F
THE
MAXIMUM
CAPACITY
OF
AN
EDGE
INTHEINSTANCE
WE
LL
ASSUME
ALL
EDGESHAVEINTEGERCAPACITY
ALGORITHM
A
HAS
RUNNING
TIME
V
EF
ALGORITHM
B
HAS
RUNNING
TIME
VE
LOGF
ALGORITHM
C
HAS
RUNNING
TIME
VE
IDENTIFYWHICH
ALGORITHMS
RUN
INPOLYNOMIAL
TIME
IDENTIFYWHICH
ALGORITHMS
RUN
IN
PSEUDO
POLYNOMIAL
TIME
IDENTIFY
WHICH
ALGORITHMS
RUN
IN
STRONG
POLYNOMIAL
TIME
STARTWITHDEFNITIONS
OFPOLYNOMIALTIME
PSEUDO
POLYNOMIAL
TIME
AND
STRONGLYPOLYNOMIAL
TIME
CONSIDER
THE
ONLINE
LIST
UPDATE
PROBLEM
THE
ONLINE
ALGORITHM
MAINTAINS
A
LIST
THE
INPUT
IN
EACH
ROUND
IS
AN
ITEM
I
IN
THE
LIST
IF
THE
ITEM
I
IS
IN
POSITION
K
IN
THE
LIST
THEN
THE
ALGORITHM
PAYS
A
COST
OF
K
FURTHER
AT
NO
COST
THE
ITEM
I
MAY
BE
TO
ANY
POSITION
IN
THE
LIST
THAT
IS
NOT
FURTHER
FROM
THE
FRONT
OF
THE
LIST
THAN
I
CURRENT
POSITION
PROVE
USING
AN
ADVERSARIAL
ARGUMENTTHATTHE
COMPETITIVE
RATIO
OR
EQUIVALENTLY
THE
APPROXIMATION
RATIO
OR
EQUIVALENTLYTHE
WORST
CASE
RATIO
OF
EVERYDETERMINISTIC
ONLINE
ALGORITHMFORTHISPROBLEM
MUST
BE
AT
LEAST
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
IF
YOU
ARE
TAKING
THE
FNAL
FOR
PRELIMARY
EXAM
CREDIT
THEN
WRITE
YOUR
PRELIMARY
NUMBER
GIVEN
TO
YOU
BY
KEENA
ON
THE
EXAM
ANSWER
SHEET
BUT
DO
NOT
WRITE
YOUR
NAME
IF
YOU
ARE
NOTTAKING
THE
FNALFORPRELIMINARY
EXAMCREDIT
WRITEYOURNAMEONTHEEXAMANSWERSHEET
IFYOUARETAKING
THECOURSEFOR
SOMEGRADING
OPTION
OTHERTHANTHESTANDARDLETTERGRADING
OPTION
PLEASE
SPECIFY
THAT
ON
YOUR
EXAM
ANSWER
SHEET
FORMOST
OF
THEPROBLEMS
I
AMINTERESTEDINTESTING
WHETHERYOUUNDERSTAND
THETECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IFI
ASKYOUTOPROVETHAT
APROBLEMISNP
HARD
I
AM
MOREINTERESTEDINLEARNINGIF
YOUKNOWHOWTOPROVETHATAPROBLEMISNP
HARD
THANI
AMINTHE
SPECIFCS
OFTHEPROBLEM
IFI
ASKYOUPROBLEMTHAT
AGREEDY
ALGORITHMIS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECIFCS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECIFC
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECIFCS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
YOUMUSTFULLYJUSTIFYALL
ASSERTIONSUNLESSSPECIFCALLYINSTRUCTED
NOTTODOSO
ALLARGUMENTS
SHOULD
BE
FROM
FRST
PRINCIPLES
YOU
SHOULD
NOT
USE
RESULTS
FROM
CLASS
THE
BOOK
ETC
AS
A
BLACK
BOX
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETEDAS
IDON
TKNOW
FALSEORCOMPLETELYUNSUBSTANTIATED
ASSERTIONSWILL
RECEIVELESSER
CREDIT
SOLVE
UP
TO
OF
THE
QUESTIONS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
SOLVING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
GIVE
A
GENERAL
SOLUTION
TO
THE
RECURRENCE
RELATION
T
N
AT
N
A
N
LGK
N
FOR
CONSTANTS
A
AND
K
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
IS
A
COLLECTION
OF
INTERVALS
AND
THE
OUTPUT
IS
A
MAXIMUM
CARDINALITY
COLLECTION
OF
DISJOINT
INTERVALS
GIVE
A
GREEDY
ALGORITHM
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
TWO
OF
THE
THREE
FOLLOWING
DEFNITIONS
OF
BIG
OH
AREA
LOGICALLY
EQUIVALENT
IDENTIFY
THE
TWO
THAT
ARE
LOGICALLY
EQUIVALENT
AND
PROVE
THAT
THEY
ARE
EQUIVALENT
TAKE
CARE
IN
YOUR
EXPOSITION
PROVE
THAT
THE
THIRDDEFNITIONIS
NOT
LOGICALLY
EQUIVALENTTO
THE
OTHER
TWO
YOU
MAY
ASSUME
THAT
WE
ARE
ONLY
CONSIDERINGFUNCTIONS
THAT
AREDEFNED
ON
THEPOSITIVEINTEGERS
AND
ARE
POSITIVE
AND
NON
DECREASING
A
F
N
O
G
N
I
N
F
N
CG
N

B
F
N
O
G
N
I
N
CG
N
C
F
N
O
G
N
I
N
N
CG
N
ASSUME
THAT
PROBLEM
P
HAS
WORST
CASE
TIME
COMPLEXITY
O
ASSUME
THAT
PROBLEM
P
HAS
WORST
CASE
TIME
COMPLEXITY
ASSUME
THAT
A
IS
AN
ALGORITHM
FOR
PROBLEM
P
FOR
EACH
OF
THE
FOLLOWING
STATEMENTS
STATE
WHETHER
THE
STATEMENT
IS
LOGICALLY
IMPLIED
BY
THE
ABOVE
INFORMATION
AND
STATE
WHETHER
THE
STATEMENT
IS
LOGICALLY
CONSISTENT
WITH
THE
ABOVE
INFORMATION
SO
I
AM
LOOKING
FOR
YES
NO
ANSWERS
YOU
NEED
NOT
JUSTIFY
YOUR
ANSWERS
BUT
THIS
QUESTION
WILL
BE
GRADED
ON
AN
ALL
OR
NOTHING
BASIS
SO
TAKE
THAT
INTO
ACCOUNT
A
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
O
B
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
C
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
N
D
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
O
N
CONSIDERTHEFOLLOWINGPROBLEM
THEINPUTISAN
N
BY
N
ARRAY
E
ENTRY
E
I
J
SPECIFES
THE
AMOUNT
OF
CURRENCY
J
WILLBEPAIDIN
EXCHANGEFOR
ONE
UNIT
OF
CURRENCY
I
THEPROBLEMIS
TO
DETERMINE
WHETHER
YOU
HAVE
ANY
ARBITRAGE
OPPORTUNITIES
THAT
IS
YOU
WANT
TO
DETERMINE
WHETHERTHEREISANY
SEQUENCEOF
EXCHANGESTHAT
WOULD
ALLOWTHEAMOUNT
OF
MONEYINSOME
PARTICULAR
CURRENCY
TO
GROW
IN
AN
UNBOUNDED
WAY
YOU
CAN
ASSUME
THAT
YOU
START
WITH
ONE
UNIT
OF
EACH
CURRENCY
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
YOU
MUST
JUSTIFYTHE
CORRECTNESS
OF
YOUR
ALGORITHM
ASSUME
THAT
YOU
HAVE
A
SERVER
THAT
FAILS
ON
A
PARTICULAR
DAY
OF
N
DAYS
WITH
PROBABILITY
PERCENTINDEPENDENTOF
WHETHERITFAILS
ON
OTHERDAYS
LETXI
BE
A
RANDOM
VARIABLEDENOTING
THE
MAXIMUM
NUMBER
OF
DAYS
THAT
THE
SERVER
FAILS
STARTING
FROM
DAY
I
SO
IF
XI
K
THEN
THE
SERVERFAILS
ONDAYS
I
I
I
K
BUT
EITHER
THE
SERVER
DOESN
T
FAIL
ON
DAY
I
K
OR
I
K
N
COMPUTE
THE
EXPECTED
VALUE
OF
MAX
XI
XN
WE
CONSIDER
THE
QUICKSORT
ALGORITHM
FOR
SORTING
N
NUMBERS
LET
XI
J
BE
AN
INDICATOR
RANDOM
VARIABLEDENOTING
WHETHER
THE
ITH
SMALLEST
NUMBERIS
COMPARED
TO
THE
JTH
SMALLEST
NUMBER
SO
XI
J
IS
IF
THE
ITH
SMALLEST
NUMBER
IS
COMPARED
TO
THE
JTH
SMALLEST
NUMBER
AND
OTHERWISE
WHAT
IS
E
XI
J
AS
A
FUNCTION
OF
I
J
AND
N
USE
THIS
TO
COMPUTE
THE
EXPECTED
NUMBER
OF
COMPARISONS
USEDBYQUICKSORT
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
IS
N
KEYS
KN
WITH
ACCESS
PROBABILITIES
PN
THE
OUTPUT
SHOULD
BE
A
BINARY
SEARCH
TREE
T
ON
THESE
KEYS
THAT
MINIMIZES
THE
P
EXPECTED
ACCESS
TIME
IN
PIDEPTH
T
KI
GIVE
AN
POLYNOMIAL
TIME
DYNAMIC
PROGRAMMING
ALGORITHMFORTHISPROBLEM
MAKE
SURETO
EXPLAINHOWINFORMATIONIS
STOREDINYOUR
ARRAY
RECALL
THAT
THE
K
CNF
SAT
PROBLEM
TAKES
AS
INPUT
A
BOOLEAN
FORMULA
F
IN
CONJUNCTIVE
NORMALFORM
WITH
EXACTLYKLITERALSPER
CLAUSE
ANDDETERMINES
WHETHER
OR
NOT
F
IS
SATISF
ABLE
ASSUME
THAT
YOU
KNOW
THAT
CNF
SAT
IS
NP
COMPLETE
USE
THIS
FACT
TO
ESTABLISH
THAT
CNF
SAT
IS
NP
HARD
WE
CONSIDERTHE
SETTING
OF
ATWOPLAYERZERO
SUMGAMEDESCRIBEDBY
ATWODIMENSIONTABLE
SPECIFYING
HOW
MUCH
THE
COLUMN
PLAYER
PAYS
THE
ROW
PLAYER
FOR
EACH
POSSIBLE
SITUATION
ASSUMETHEROWPLAYERGOES
FRST
AND
SPECIFESAPROBABILITY
DISTRIBUTIONOVERHISPOSSIBLE
MOVES
THE
COLUMNPLAYERTHEN
REPLIESWITH
THE
MOVETHAT
MINIMIZESHER
EXPECTEDPAYOUT
TOTHE
ROWPLAYER
WE
CONSIDERTHEPROBLEM
OFDETERMINING
THEPROBABILITYDISTRIBUTIONFOR
THE
ROW
PLAYER
THAT
WILL
MAXIMIZE
HIS
EXPECTED
PAYOUT
EXPLAIN
HOW
TO
CONSTRUCT
A
LINEAR
PROGRAMMING
FORMULATION
OF
THIS
PROBLEM
IT
IS
SUCIENT
TO
CONSTRUCT
THE
LINEAR
PROGRAM
FOR
THE
FOLLOWING
INSTANCE
X
Y
Z
A
B
C
THENGIVETHEDUALLINEARPROGRAMFORYOURLINEARPROGRAMFORTHE
ABOVEINSTANCE
CONSIDER
THE
RED
ANDBLUEJUGPROBLEM
INTHISPROBLEMYOUHAVE
N
REDJUGS
AND
N
BLUE
JUGS
YOUKNOW
THATFOR
EACHJUG
THAT
THEREIS
A
UNIQUEJUG
OF
THE
OTHER
COLOR
WITH
THE
SAME
VOLUME
THE
ONLY
WAY
THATYOU
CANLEARNABOUTTHE
VOLUMESOF
THEJUGSISTO
COMPARETWO
JUGS
OFDI
ERENT
COLORS
THIS
OPERATION
TELLSYOU
WHETHERTHE
REDJUGHASGREATER
VOLUME
OR
WHETHERTHEBLUEJUG
HASGREATER
VOLUME
OR
WHETHERTHEY
HAVETHE
SAME
VOLUME
SHOW
USING
AN
ADVERSARIAL
ARGUMENT
THAT
ANY
DETERMINISTIC
ALGORITHM
THAT
SOLVES
THIS
PROBLEM
REQUIRES
N
LOGN
OPERATIONS
CONSIDER
AGAIN
THE
SAME
RED
ANDBLUEJUGPROBLEM
INTHISPROBLEMYOUHAVE
N
REDJUGS
AND
N
BLUEJUGS
YOUKNOWTHATFOR
EACHJUG
THATTHEREIS
A
UNIQUEJUG
OFTHE
OTHER
COLOR
WITHTHE
SAME
VOLUME
THE
ONLY
WAYTHATYOUCANLEARN
ABOUTTHEVOLUMESOFTHEJUGS
ISTO
COMPARETWOJUGS
OFDI
ERENTCOLORS
THIS
OPERATIONTELLSYOU
WHETHERTHE
REDJUG
HASGREATER
VOLUME
OR
WHETHERTHEBLUEJUG
HASGREATER
VOLUME
OR
WHETHERTHEY
HAVETHE
SAME
VOLUME
ASSUME
THAT
YOU
KNOW
THAT
EVERY
LINEAR
TIME
DETERMINISTIC
ALGORITHM
A
IS
WRONG
ON
ATLEASTHALF
OFTHE
N
POSSIBLE
INPUTS
IN
THE
COLLECTION
I
OF
POSSIBLE
INPUTS
EXPLAIN
WHY
FOR
EVERY
RANDOMIZED
ALGORITHM
A
IT
MUST
BE
THE
CASE
THAT
THERE
EXISTS
AN
INPUT
I
ON
WHICH
A
IS
WRONG
WITH
PROBABILITY
AT
LEAST
HALF
YOUR
ARGUMENT
MUST
BE
FROM
FRST
PRINCIPLES
WECONSIDERTHESTANDARD
NETWORKFOWPROBLEM
LETV
BE
THE
NUMBER
OFVERTICESINTHE
NET
WORK
E
BE
THE
NUMBER
OF
EDGESINTHE
NETWORK
AND
F
BE
THE
MAXIMUM
EDGE
CAPACITYINTHE
NETWORK
ASSUME
THAT
YOU
HAVE
NETWORK
FOW
ALGORITHMS
A
B
AND
C
WITH
WORST
CASE
RUN
NING
TIMES
A
V
E
F
V
F
B
V
E
F
V
F
ANDC
V
E
F
V
WHICH
OF
THESE
ALGORITHMS
ARE
POLYNOMIAL
TIME
ALGORITHMS
START
WITH
A
DEFNITION
OF
POLYNOMIAL
TIME
ALGORITHM
ANDJUSTIFYYOUR
ANSWER
ASSUMETHATYOUHAVEN
ITEMS
WITHWEIGHTS
WN
THATYOU
WISHTOPACKINTOK
TRUCKS
SO
AS
TO
MINIMIZE
THE
WEIGHT
OF
THE
MOST
HEAVILYLOADED
TRUCK
CONSIDER
THEGREEDY
ALGORITHM
THAT
CONSIDERS
THAT
ITEMS
IN
AN
ARBITRARY
ORDER
AND
PACKS
THAT
ITEM
ONTO
THE
TRUCK
THAT
CURRENTLYHASTHELEASTLOAD
PROVETHATTHEGREEDY
ALGORITHMHAS
WORST
CASE
RATIO
AT
MOST
TWOFORTHISPROBLEM
STATE
WHICH
TWOLOWERBOUNDSTO
OPTIMAL
THATYOU
USE
CONSIDER
THE
ONLINE
LIST
UPDATE
PROBLEM
THE
ONLINE
ALGORITHM
MAINTAINS
A
LIST
THE
INPUT
IN
EACH
ROUND
IS
AN
ITEM
I
IN
THE
LIST
IF
THE
ITEM
I
IS
IN
POSITION
K
IN
THE
LIST
THEN
THE
ALGORITHM
PAYS
A
COST
OF
K
FURTHER
AT
NO
COST
THE
ITEM
I
MAY
BE
TO
ANY
POSITION
IN
THE
LIST
THAT
IS
NOT
FURTHER
FROM
THE
FRONT
OF
THE
LIST
THAN
I
CURRENT
POSITION
CONSIDER
THE
ALGORITHM
MTF
THAT
ALWAYS
MOVES
THE
ACCESSED
ITEM
CLOSER
TO
THE
FRONT
SHOW
THAT
MTFHAS
COST
AT
MOSTTWICETHE
OPTIMAL
COSTFOR
EVERYINPUT
SEQUENCE
USING
THEPOTENTIAL
FUNCTION
THE
NUMBER
OF
TRANSPOSITIONS
BETWEEN
MTF
LIST
AND
THE
OPTIMAL
LIST
A
PAIR
I
J
OF
ITEMS
IS
A
TRANSPOSITION
IF
I
AND
J
OCCUR
IN
DI
ERENT
ORDER
IN
MTF
AND
THE
OPTIMAL
LIST
CS
SYLLABUS
SPRING
TIMES
MWF
PM
SENSQ
COURSE
HOME
PAGE
HTTP
WWW
CS
PITT
EDU
KIRK
INDEX
HTML
COURSE
GROUP
HOME
PAGE
HTTP
PIAZZA
COM
PITT
HOME
I
WILL
USE
THIS
GROUP
FOR
GENERAL
ANNOUNCEMENTS
ABOUT
THE
COURSE
THIS
GROUP
SHOULD
BE
USED
FOR
QUESTIONS
OF
GENERAL
INTEREST
THE
COURSE
GROUP
IS
THE
BEST
PLACE
TO
ASK
GENERAL
QUESTIONS
E
G
A
QUESTION
ABOUT
A
PARTICULAR
HOMEWORK
PROBLEM
THIS
GROUP
WILL
BE
MONITORED
BY
THE
INSTRUCTOR
AND
THE
TA
BUT
OFTEN
OTHER
STUDENTS
CAN
PROVIDE
A
QUICKER
ANSWER
THAN
THE
TA
OR
INSTRUCTOR
INSTRUCTOR
KIRK
PRUHS
O
CE
SENNOTT
SQUARE
PHONE
EMAIL
KIRK
CS
PITT
EDU
PLEASE
USE
THE
COURSE
GROUP
FOR
GENERAL
QUESTIONS
ABOUT
ASSIGNMENTS
ETC
I
DO
NOT
MONITOR
ANY
OTHER
EMAIL
ADDRESS
O
CE
HOURS
MWF
AND
MW
TA
NATHAN
ONG
O
CE
SENNOTT
SQUARE
EMAIL
PITT
EDU
O
CE
HOURS
AM
NOON
TUESDAY
AND
THURSDAYS
TEXT
THE
O
CIAL
TEXT
IS
INTRODUCTION
TO
ALGORITHMS
EDITION
BY
CORMEN
LEISERSON
RIVEST
AND
STEIN
I
WILL
ONLY
LOOSELY
FOLLOW
THE
TEXT
HAVING
A
HARD
COPY
OF
THE
TEXT
MAY
BE
HELPFUL
BUT
IT
PROBABLY
ISN
T
CRITICAL
ALTHOUGH
I
WILL
ASSIGN
SOME
PROBLEMS
FROM
THE
TEXT
SO
YOU
WILL
NEED
TO
ARRANGE
TO
HAVE
SOME
ACCESS
TO
THE
TEXT
PREREQUISITES
CS
AND
CS
OR
MORE
GENERALLY
A
SOLID
KNOWLEDGE
OF
MATHEMATICAL
PROOFS
AND
AN
UNDERGRADUATE
ALGORITHMS
CLASS
THAT
INVOLVES
PROOFS
MOST
STUDENTS
THAT
TAKE
THE
COURSE
WITHOUT
SUCH
PREREQUISITE
KNOWLEDGE
STRUGGLE
COURSE
CONTENT
IN
APPROXIMATE
ORDER
OF
IMPORTANCE
LEARN
HOW
TO
THINK
ALGORITHMICALLY
LEARN
HOW
TO
BE
YOUR
OWN
ADVERSARY
LEARN
A
LITTLE
ABOUT
THE
RESEARCH
PROCESS
LEARN
HOW
TO
THINK
ON
MANY
LEVELS
AT
THE
SAME
TIME
ESPECIALLY
ON
THE
PROGRAM
AND
ALGORITHM
LEVELS
LEARN
WIDELY
APPLICABLE
ALGORITHMS
DESIGN
AND
ANALYSIS
TECHNIQUES
AND
LEARN
SOME
OF
THE
MORE
COMMONLY
USED
ALGORITHMS
WE
WILL
CONCENTRATE
MORE
ON
UNDERSTANDING
THE
BASICS
AT
A
REASONABLY
MATURE
LEVEL
RATHER
THAN
ON
MORE
ADVANCED
MATERIAL
THIS
IS
NOT
A
SURVEY
CLASS
OF
USEFUL
ALGORITHMS
NOR
WILL
WE
DISCUSS
MANY
LOWER
LEVEL
IMPLEMENTATION
ISSUES
THE
CLASS
IS
TARGETED
TOWARD
PHD
PROFESSIONAL
COMPUTER
SCIENTISTS
THE
GOAL
IS
TO
PREPARE
ALL
STUDENTS
TO
BE
ABLE
TO
READ
AND
UNDERSTAND
REASONABLY
SOPHISTICATED
ALGORITHMS
PAPERS
AND
TO
PREPARE
SOME
STUDENTS
TO
BE
ABLE
TO
DESIGN
AND
ANALYZE
NEW
ALGORITHMS
ON
THEIR
OWN
MY
GOAL
IS
TO
GET
AS
MANY
PEOPLE
TO
THE
A
LEVEL
AS
POSSIBLE
THERE
WILL
BE
HOMEWORK
ASSIGNMENTS
DUE
ALMOST
EVERY
CLASS
IT
IS
EXPECTED
THAT
MOST
OF
YOUR
LEARNING
WILL
COME
FROM
THE
PROCESS
OF
SOLVING
THE
HOMEWORK
PROBLEMS
THE
MAIN
PURPOSE
OF
THE
LECTURES
IS
TO
PREPARE
YOU
FOR
THE
HOMEWORK
THE
NAL
EXAM
WILL
IN
LARGE
PART
BE
BASED
ON
THE
HOMEWORK
GRADING
GRADES
WILL
BE
BASED
ON
HOMEWORK
CLASSROOM
ATTENDANCE
PARTICIPATION
AND
A
NAL
EXAM
THE
NAL
EXAM
IS
OF
THE
GRADE
HOMEWORK
WILL
CONSTITUTE
OF
THE
NAL
GRADE
ATTENDANCE
WILL
BE
TAKEN
AND
ATTENDANCE
AND
PARTICIPATION
IN
DISCUSSIONS
AND
THE
CLASS
GROUP
WILL
COUNT
FOR
OF
THE
GRADE
BUT
STUDENTS
WHO
HAVE
HIGH
ATTENDANCE
HIGH
CLASS
PARTICIPATION
AND
WHO
HAVE
MADE
A
GOOD
FAITH
E
ORT
TO
SOLVE
ESSENTIALLY
ALL
OF
THE
HOMEWORK
ASSIGNMENTS
WILL
HAVE
THE
OPTION
TO
SKIP
TAKING
THE
NAL
EXAM
AND
INSTEAD
ACCEPT
A
GRADE
OF
B
STUDENTS
MUST
RECEIVE
PRIOR
PERMISSION
OF
THE
INSTRUCTOR
IF
THEY
WISH
TO
CHOOSE
THIS
OPTION
I
WILL
SUBJECTIVELY
SET
THE
GRADING
SCALE
AT
THE
END
OF
THE
SEMESTER
YOU
ARE
NOT
IN
COMPETITION
WITH
OTHER
STUDENTS
I
HAVE
NO
SET
NUMBERS
OF
A
B
ETC
I
STRONGLY
SUGGEST
YOU
COOPERATE
WITH
EACH
OTHER
TO
UNDERSTAND
THE
MATERIAL
THIS
IS
IN
ALL
STUDENTS
BEST
INTERESTS
IF
A
STUDENT
HOMEWORK
SCORES
ARE
CONSPICUOUSLY
SUSPICIOUSLY
HIGHER
THAN
A
STUDENT
EXAM
GRADES
I
RESERVE
THE
RIGHT
TO
BASE
THE
COURSE
GRADE
ON
ONLY
THE
EXAM
SCORES
AND
CLASSROOM
PARTICIPATION
STUDENTS
THAT
ATTEND
THE
REGULARLY
AND
ARE
DOING
THE
HOMEWORK
REGULARLY
SHOULD
EXPECT
TO
GET
A
GRADE
OF
AT
LEAST
B
TO
EARN
A
HIGHER
GRADE
STUDENTS
NEED
TO
DEMONSTRATE
MASTERY
OF
THE
MATERIAL
ON
THE
NAL
EXAM
HOMEWORK
POLICY
YOU
SHOULD
DO
YOU
HOMEWORK
IN
GROUPS
OF
OR
PEOPLE
OTHER
GROUPS
SIZES
INCLUDING
ARE
POSSIBLE
WITH
INSTRUCTOR
APPROVAL
EACH
GROUP
NEED
ONLY
PROVIDE
ONE
WRITE
UP
WRITE
UPS
MUST
USE
LATEX
HTTP
EN
WIKIPEDIA
ORG
WIKI
LATEX
YOU
MAY
DISCUSS
PROBLEMS
WITH
ANY
STUDENT
IN
THE
CLASS
WITH
THE
PROVISOS
THAT
YOU
SHOULDN
T
FEED
OTHERS
COMPLETE
SOLUTIONS
AND
YOU
MUST
ACKNOWLEDGE
COLLABORATIONS
IN
THE
WRITE
UP
YOU
MAY
NOT
SEEK
SOLUTIONS
ON
THE
WWW
IN
OTHER
BOOKS
FORMER
STUDENTS
FROM
FRIENDS
OUTSIDE
THE
CLASS
ETC
ALL
HOMEWORK
IS
DUE
AT
THE
START
OF
CLASS
ON
THE
DATE
DUE
IN
HARDCOPY
FIGURES
MAY
BE
HAND
DRAWN
NO
LATE
HOMEWORK
IS
ACCEPTED
THE
HOMEWORK
WILL
BE
GRADED
BY
THE
TA
MANY
STUDENTS
WILL
ND
SOME
PROBLEMS
DEMANDING
IT
IS
NOT
EXPECTED
THAT
ALL
STUDENTS
WILL
BE
ABLE
TO
ANSWER
ALL
THE
HOMEWORK
QUESTIONS
DISABILITY
POLICY
IF
YOU
HAVE
A
DISABILITY
FOR
WHICH
YOU
ARE
OR
MAY
BE
REQUESTING
AN
ACCOMMODATION
YOU
ARE
ENCOURAGED
TO
CONTACT
BOTH
YOUR
INSTRUCTOR
AND
DISABILITY
RESOURCES
AND
SERVICES
WILLIAM
PITT
UNION
TTY
AS
EARLY
AS
POSSIBLE
IN
THE
TERM
DRS
WILL
VERIFY
YOUR
DISABILITY
AND
DETERMINE
REASONABLE
ACCOMMODATIONS
FOR
THIS
COURSE
MISSING
TESTS
IF
YOU
ARE
GOING
TO
MISS
A
TEST
FOR
UNAVOIDABLE
REASONS
THEN
BEFORE
THE
EXAM
OR
AS
SOON
AS
POSSIBLE
YOU
MUST
CONTACT
ME
IF
THIS
IS
NOT
POSSIBLE
CONTACT
THE
COMPUTER
SCIENCE
DEPARTMENTAL
SECRETARY
AT
CHEATING
POLICY
I
HAVE
NO
TOLERANCE
FOR
CHEATING
IF
YOU
ARE
CAUGHT
CHEATING
YOU
WILL
RECEIVE
AN
F
GRADE
FOR
THE
COURSE
PROBLEM
PART
A
FROM
THE
CLRS
TEXT
YOU
NEED
NOT
PROVIDE
JUSTI
CATIONS
FOR
YOUR
ORDER
IF
YOU
AREN
T
ABLE
TO
ND
A
GROUP
YOU
CAN
DO
THIS
INDIVIDUALLY
WHILE
I
ENCOURAGE
YOU
TO
USE
LATEX
IT
IS
NOT
STRICTLY
REQUIRED
FOR
THIS
ASSIGNMENT
YOU
MAY
HAND
WRITE
THESE
SOLUTIONS
DUE
FRIDAY
JANUARY
PROBLEM
FOR
CONJECTURES
THAT
ARE
UNTRUE
EXPLAIN
WHICH
REASONABLE
CLASS
OF
FUNC
TIONS
THE
STATEMENT
IS
TRUE
FOR
FOR
EXAMPLE
YOU
MIGHT
SAY
THE
STATEMENT
IS
UNTRUE
IN
GENERAL
AND
HERE
IS
AN
EXAMPLE
BUT
THE
STATEMENT
IS
TRUE
IF
THE
FUNCTIONS
ARE
STRICTLY
INCREASING
AND
HERE
IS
WHY
DUE
MONDAY
JANUARY
CONSIDER
THE
FOLLOWING
DE
NITIONS
FOR
F
N
M
O
G
N
M
STATE
WHICH
DE
NITIONS
ARE
LOGICALLY
EQUIVALENT
FULLY
JUSTIFY
YOUR
ANSWERS
ARGUE
ABOUT
WHICH
DE
NITION
YOU
THINK
IS
THE
BEST
ONE
IN
THE
CONTEXT
WHERE
F
AND
G
ARE
RUN
TIMES
OF
ALGORITHMS
AND
THE
INPUT
SIZE
IS
MONOTONICALLY
GROWING
IN
N
AND
M
FOR
EXAMPLE
N
MIGHT
BE
THE
NUMBER
OF
VERTICES
IN
A
GRAPH
AND
M
MIGHT
BE
THE
NUMBER
OF
EDGES
IN
A
GRAPH
A
THERE
EXISTS
POSITIVE
CONSTANTS
C
SUCH
THAT
FOR
ALL
N
M
WHERE
N
AND
M
IT
IS
THE
CASE
THAT
F
N
M
CG
N
M
B
THERE
EXISTS
POSITIVE
CONSTANTS
C
SUCH
THAT
FOR
ALL
N
M
WHERE
N
OR
M
IT
IS
THE
CASE
THAT
F
N
M
CG
N
M
C
THERE
EXISTS
A
CONSTANT
C
SUCH
THAT
LIM
SUP
LIM
SUP
F
N
M
G
N
M
C
N
M
NOTE
THAT
THIS
MEANS
THAT
YOU
RST
TAKE
THE
LIMIT
SUPERIOR
WITH
RESPECT
TO
M
THE
RESULT
WILL
BE
A
FUNCTION
OF
JUST
N
YOU
THEN
TAKE
THE
LIMIT
SUPERIOR
OF
THIS
FUNCTION
WITH
RESPECT
TO
N
IF
YOU
DON
T
KNOW
WHAT
LIMIT
SUPERIOR
MEANS
YOU
CAN
JUST
ASSUME
THAT
THE
LIMIT
EXISTS
IN
WHICH
CASE
THE
LIMIT
AND
LIMIT
SUPERIOR
ARE
THE
SAME
D
THERE
EXISTS
A
CONSTANT
C
SUCH
THAT
LIM
SUP
LIM
SUP
F
N
M
G
N
M
C
M
N
NOTE
THAT
THIS
MEANS
THAT
YOU
RST
TAKE
THE
LIMIT
SUPERIOR
WITH
RESPECT
TO
N
THE
RESULT
WILL
BE
A
FUNCTION
OF
JUST
M
YOU
THEN
TAKE
THE
LIMIT
SUPERIOR
OF
THIS
FUNCTION
WITH
RESPECT
TO
M
IF
YOU
DON
T
KNOW
WHAT
LIMIT
SUPERIOR
MEANS
YOU
CAN
JUST
ASSUME
THAT
THE
LIMIT
EXISTS
IN
WHICH
CASE
THE
LIMIT
AND
LIMIT
SUPERIOR
ARE
THE
SAME
NOTE
THAT
ON
THE
SURFACE
THAT
THIS
DE
NITION
IS
DI
ERENT
THAN
THE
LAST
ON
IN
THAT
THE
ORDER
THAT
YOU
TAKE
THE
LIMITS
IS
SWITCHED
E
THERE
EXISTS
A
CONSTANT
C
SUCH
THAT
FOR
ALL
BUT
NITELY
MANY
PAIRS
M
N
IT
IS
THE
CASE
THAT
F
N
M
CG
N
M
DUE
MONDAY
JANUARY
PROBLEM
FROM
THE
CLRS
TEXT
EXCEPT
PARTS
D
AND
F
APPLY
THE
MASTER
THEOREM
THEOREM
WHENEVER
APPLICABLE
OTHERWISE
DRAW
THE
RECURSIVE
CALL
TREE
AND
SUM
UP
THE
COSTS
LEVEL
BY
LEVEL
DUE
WEDNESDAY
JANUARY
PROBLEM
PARTS
D
AND
F
USE
INDUCTION
YOU
WILL
NEED
INDUCTIVE
PROOFS
ONE
FOR
THE
UPPER
BOUND
AND
ONE
FOR
THE
LOWER
BOUND
DUE
FRIDAY
JANUARY
PROBLEM
PARTS
D
AND
E
FROM
THE
CLRS
TEXT
DUE
FRIDAY
JANUARY
PROBLEM
FROM
THE
CLRS
TEXT
GIVE
AN
ADVERSARIAL
STRATEGY
AND
PROVE
THAT
IT
IS
CORRECT
DUE
FRIDAY
JANUARY
PROBLEM
FROM
THE
CLRS
TEXT
GIVE
AN
ADVERSARIAL
STRATEGY
AND
PROVE
THAT
IT
IS
CORRECT
EXPLAIN
THE
LAST
SENTENCE
OF
THE
PROBLEM
STATEMENT
FROM
THE
BOOK
THAT
IS
EXPLAIN
WHY
ITS
NOT
RIGOROUS
CORRECT
TO
SIMPLY
COMBINE
THE
LOWER
BOUNDS
FOR
THE
INDIVIDUAL
SUBSEQUENCES
DUE
FRIDAY
JANUARY
PROBLEM
FROM
THE
CLRS
TEXT
A
FOR
PART
A
AND
B
IT
IS
ESSENTIALLY
ASKING
YOU
TO
CONSIDER
THE
ADVERSARIAL
STRATEGY
THAT
ANSWERS
SO
AS
TO
MAXIMIZE
THE
NUMBER
OF
THE
ORIGINAL
WAYS
OF
MERGING
TWO
SORTED
LISTS
THAT
ARE
CONSISTENT
WITH
THE
ANSWER
YOU
WILL
LIKELY
ND
STIRLING
APPROXIMATION
FOR
N
USEFUL
B
FOR
PARTS
C
AND
D
COME
UP
WITH
A
DI
ERENT
ADVERSARIAL
STRATEGY
C
EXPLAIN
WHY
THE
BOUND
THAT
YOU
GET
USING
THE
METHOD
PROPOSED
IN
PARTS
A
AND
B
ISN
T
AS
GOOD
AS
THE
BOUND
YOU
GET
USING
AN
ADVERSARIAL
STRATEGY
THAT
IS
IN
WHAT
WAY
ARE
YOU
BEING
TOO
GENEROUS
TO
THE
ALGORITHM
IN
PARTS
A
AND
B
IN
THIS
GENEROSITY
IN
THE
ADVERSARIAL
STRATEGY
OR
IN
ITS
ANALYSIS
DUE
MONDAY
JANUARY
CONSIDER
THE
PROBLEM
OF
DETERMINING
WHETHER
A
COLLECTION
OF
REAL
NUMBERS
XN
IS
NICE
A
COLLECTION
OF
NUMBERS
IS
NICE
I
THE
DI
ERENCE
BETWEEN
CONSECUTIVE
NUMBERS
IN
THE
SORTED
ORDER
IS
AT
MOST
SO
IS
NICE
BUT
IS
NOT
NICE
SINCE
THE
DI
ERENCE
BETWEEN
AND
IS
MORE
THAN
WE
WANT
TO
SHOW
THAT
EVERY
COMPARISON
BASED
ALGORITHM
TO
DETERMINE
IF
A
COLLECTION
OF
N
NUMBERS
IS
NICE
REQUIRES
O
N
LOG
N
COMPARISONS
OF
THE
FORM
XI
XJ
C
WHERE
C
IS
SOME
CONSTANT
THAT
THE
ALGORITHM
CAN
SPECIFY
SO
IF
C
THIS
IS
A
STANDARD
COMPARISON
HINT
THIS
IS
SIMILAR
TO
THE
LOWER
BOUND
FOR
ELEMENT
UNIQUENESS
ANOTHER
HINT
CONSIDER
THE
N
PERMUTATIONS
P
OF
N
WHERE
P
AND
THE
CORRESPONDING
POINTS
IN
N
DIMENSIONAL
SPACE
NOTE
THAT
ALL
N
OF
THESE
POINTS
ARE
NICE
SHOW
THE
MIDPOINT
OF
ANY
PAIR
OF
THESE
NICE
POINTS
IS
NOT
NICE
THEN
EXPLAIN
HOW
TO
USE
THIS
FACT
TO
GIVE
AN
ADVERSARIAL
STRATEGY
SHOWING
THE
O
N
LOG
N
LOWER
BOUND
DUE
MONDAY
JANUARY
CONSIDER
A
SETTING
WHERE
YOU
HAVE
TWO
COMPUTER
NETWORKING
ROUTERS
A
AND
B
EACH
ROUTER
HAS
COLLECTED
A
LIST
LA
AND
LB
OF
IP
SOURCE
ADDRESSES
FOR
THE
PACKETS
THAT
HAVE
PASSED
THROUGH
THE
ROUTER
THAT
DAY
AN
IP
ADDRESS
IS
N
BITS
AND
THUS
THERE
ARE
POSSIBLE
IP
ADDRESSES
NOW
THE
TWO
ROUTERS
WANT
TO
COMMUNICATE
VIA
A
TWO
WAY
CHANNEL
TO
WHETHER
THERE
WAS
SOME
SOURCE
THAT
SENT
A
PACKET
THROUGH
ONE
OF
THE
ROUTERS
BUT
NOT
THE
OTHER
SO
MORE
PRECISELY
AT
THE
END
OF
THE
PROTOCOL
EACH
ROUTER
SHOULD
COMMIT
TO
A
BIT
SPECIFYING
THE
ANSWER
TO
THIS
QUESTION
AND
THE
BITS
FOR
BOTH
ROUTERS
SHOULD
BE
CORRECT
YOU
CAN
ASSUME
THAT
EACH
ROUTER
CAN
SEND
A
BIT
PER
UNIT
TIME
AND
THAT
A
BIT
SENT
ON
THE
CHANNEL
IS
GUARANTEED
TO
ARRIVE
ON
THE
OTHER
END
IN
ONE
TIME
UNIT
WE
WANT
TO
CONSIDER
PROTOCOLS
FOR
ACCOMPLISHING
THIS
GOAL
A
WARM
UP
CONSIDER
THE
FOLLOWING
PROTOCOL
A
SENDS
TO
B
THE
LIST
OF
ALL
OF
THE
IP
SOURCE
ADDRESSES
THAT
IT
HAS
SEEN
B
COMPARES
A
LIST
TO
ITS
LIST
AND
THEN
B
SENDS
A
A
BIT
IF
THE
LISTS
ARE
IDENTICAL
AND
A
BIT
OTHERWISE
SHOW
THAT
USES
PROTOCOL
ABOUT
USES
BITS
IN
THE
WORST
CASE
B
WARM
UP
GIVE
A
PROTOCOL
THAT
USES
O
BITS
IN
THE
WORST
CASE
ANOTHER
TRIVIAL
WARMUP
PROBLEM
C
WARM
UP
SHOW
THAT
THERE
IS
NO
PROTOCOL
THAT
CAN
SOLVE
THIS
PROBLEM
WITHOUT
EXCHANGING
ANY
BITS
HINT
ITS
OBVIOUS
THAT
THIS
IS
TRUE
THAT
ISN
T
THE
POINT
THE
POINT
IS
TO
UNDERSTAND
WHAT
ARGUMENTS
YOU
HAVE
TO
MAKE
TO
MAKE
THIS
FORMALLY
CORRECT
D
SHOW
THAT
THERE
IS
NO
PROTOCOL
THAT
CAN
SOLVE
THIS
PROBLEM
THAT
INVOLVES
A
SENDING
ONE
BIT
TO
B
AND
NO
MORE
BITS
ARE
EXCHANGED
HINT
AGAIN
ITS
OBVIOUS
THAT
THIS
IS
TRUE
AGAIN
THAT
ISN
T
THE
POINT
AGAIN
THE
POINT
IS
TO
UNDERSTAND
WHAT
ARGUMENTS
YOU
HAVE
TO
MAKE
TO
MAKE
THIS
FORMALLY
CORRECT
ASK
YOURSELF
HOW
SHOULD
THE
ADVERSARIAL
STRATEGY
SHOULD
DECIDE
WHETHER
THIS
RST
BIT
IS
A
OR
A
E
SHOW
THAT
THERE
IS
NO
PROTOCOL
THAT
CAN
SOLVE
THIS
PROBLEM
THAT
INVOLVES
A
SENDING
ONE
BIT
TO
B
AND
B
REPLYING
WITH
ONE
BIT
TO
A
AND
NO
MORE
BITS
ARE
EXCHANGED
HINT
AGAIN
ITS
OBVIOUS
THAT
THIS
IS
TRUE
AGAIN
THAT
ISN
T
THE
POINT
AGAIN
THE
POINT
IS
TO
UNDERSTAND
WHAT
ARGUMENTS
YOU
HAVE
TO
MAKE
TO
MAKE
THIS
FORMALLY
CORRECT
F
PROVE
THAT
EVERY
PROTOCOL
FOR
THIS
PROBLEM
MUST
SEND
O
BITS
FOR
ITS
WORST
CASE
INSTANCE
OF
COURSE
YOUR
ARGUMENT
SHOULD
INVOLVE
AN
ADVERSARIAL
ARGUMENT
G
ASSUME
THAT
YOU
HAVE
A
COMPUTER
NETWORKING
ROUTER
THAT
SEES
A
STREAM
OF
K
IP
PACKETS
EACH
WITH
A
SOURCE
IP
ADDRESS
CONSISTING
OF
N
BITS
THE
ROUTER
SEES
A
PACKET
OPTIONALLY
RECORDS
SOME
INFORMATION
IN
MEMORY
AND
THEN
PASSES
THE
PACKET
ON
THEN
SEES
THE
NEXT
PACKET
OPTIONALY
RECORDS
SOME
INFORMATION
IN
MEM
ORY
AND
THEN
PASSES
THAT
PACKET
ON
ETC
THE
ROUTERS
GOAL
IS
TO
ALWAYS
KNOW
A
IP
SOURCE
ADDRESS
THAT
IT
HAS
SEEN
MOST
FREQUENTLY
TO
DATE
THE
MOST
OBVIOUS
WAY
TO
ACCOMPLISH
THIS
IS
TO
KEEP
A
COUNT
FOR
EACH
IP
SOURCE
ADDRESS
SEEN
TO
DATE
SHOW
THAT
IF
K
THEN
EVERY
ALGORITHM
MUST
USE
O
K
BITS
OF
MEMORY
HINT
THIS
IS
AN
EASY
CONSEQUENCE
OF
THE
PREVIOUS
SUBPROBLEM
PROVIDED
THAT
YOU
THINK
ABOUT
IT
THE
RIGHT
WAY
ASSUME
THAT
YOU
HAD
A
METHOD
THAT
SOLVED
THIS
PROBLEM
USING
O
K
BITS
OF
MEMORY
EXPLAIN
HOW
TO
USE
THIS
METHOD
TO
GET
AN
ALGORITHM
FOR
THE
PREVIOUS
SUBPROBLEM
THAT
USES
LESS
THAN
BITS
OF
COMMUNICA
TION
DUE
WEDNESDAY
JANUARY
SHOW
THAT
ANY
COMPARISON
BASED
ALGORITHM
FOR
COMPUTING
THE
MEDIAN
OF
N
NUMBERS
YOU
CAN
ASSUME
FOR
SIMPLICITY
THAT
N
IS
ODD
REQUIRES
O
COMPARISONS
HINT
SOME
VARIATION
OF
THE
LOWER
BOUND
TO
COMPUTE
THE
LARGEST
AND
SMALLEST
NUMBER
WILL
WORK
BUT
THERE
ARE
A
COUPLE
OF
ADDITIONAL
COMPLICATIONS
DUE
FRIDAY
JANUARY
PROBLEM
FROM
THE
CLRS
TEXT
FOR
PART
B
GIVE
AN
ADVERSARIAL
STRATEGY
FOR
PART
C
USE
LINEARITY
OF
EXPECTATIONS
IN
YOUR
ALGORITHM
ANALYSIS
DUE
FRIDAY
JANUARY
CONSIDER
THE
PROBLEM
OF
NDING
THE
LARGEST
K
NUMBERS
IN
SORTED
ORDER
FROM
A
LIST
OF
N
NUMBERS
SEE
PROBLEM
IN
THE
TEXT
CONSIDER
THE
FOLLOWING
ALGORITHM
YOU
CONSIDER
THE
NUMBERS
ONE
BY
ONE
MAINTAINING
AN
AUXILIARY
DATA
STRUCTURE
OF
THE
LARGEST
K
NUMBERS
SEEN
TO
DATE
WE
GET
VARIOUS
ALGORITHMS
DEPENDING
ON
WHAT
THE
AUXILIARY
DATA
STRUCTURE
IS
AND
HOW
ONE
SEARCHES
AND
UPDATES
IT
FOR
EACH
OF
THE
FOLLOWING
VARIATIONS
GIVE
THE
WORST
CASE
TIME
COMPLEXITY
AS
A
FUNCTION
OF
N
AND
K
FOR
EACH
OF
THE
FOLLOWING
VARIATIONS
GIVE
THE
AVERAGE
CASE
TIME
COMPLEXITY
AS
A
FUNCTION
OF
N
AND
K
UNDER
THE
ASSUMPTION
THAT
EACH
INPUT
PERMUTATION
IS
EQUALLY
LIKELY
HINT
USE
LINEARITY
OF
EXPECTATIONS
THESE
ARE
ALL
SIMILAR
AND
EASY
IF
YOU
LOOK
AT
THEM
THE
RIGHT
WAY
A
THE
AUXILIARY
DATA
STRUCTURE
IS
AN
ORDERED
LIST
AND
YOU
USE
LINEAR
SEARCH
STARTING
FROM
THE
END
THAT
CONTAINS
THE
LARGEST
NUMBER
B
THE
AUXILIARY
DATA
STRUCTURE
IS
AN
ORDERED
LIST
AND
YOU
USE
LINEAR
SEARCH
STARTING
FROM
THE
END
THAT
CONTAINS
THE
SMALLEST
NUMBER
C
THE
AUXILIARY
DATA
STRUCTURE
IS
A
BALANCED
BINARY
SEARCH
TREE
AND
YOU
USE
STANDARD
LOG
TIME
SEARCH
INSERT
AND
DELETE
OPERATIONS
D
THE
AUXILIARY
DATA
STRUCTURE
IS
A
BALANCED
BINARY
SEARCH
TREE
AND
YOU
USE
STANDARD
LOG
TIME
INSERT
AND
DELETE
OPERATIONS
BUT
YOU
START
YOUR
SEARCH
FROM
THE
SMALLEST
ITEM
IN
THE
TREE
DUE
FRIDAY
JANUARY
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
N
DISJOINT
LINE
SEGMENTS
CONTAINED
IN
AN
L
BY
L
SQUARE
IN
THE
EUCLIDEAN
PLANE
THE
GOAL
IS
TO
PARTITION
INTO
CONVEX
POLYGONS
SO
THAT
EVERY
POLYGON
INTERSECTS
AT
MOST
ONE
LINE
SEGMENT
SO
IT
IS
OK
FOR
A
LINE
SEGMENT
TO
BE
IN
MULTIPLE
POLYGONS
BUT
EACH
POLYGON
CAN
INTERSECT
AT
MOST
ONE
LINE
SEGMENT
CONSIDER
THE
FOLLOWING
ALGORITHM
THAT
STARTS
WITH
THE
POLYGON
LET
P
BE
A
RANDOM
PERMUTATION
OF
THE
LINE
SEGMENTS
WHILE
THERE
IS
A
POLYGON
P
THAT
CONTAINS
MORE
THAN
ONE
LINE
SEGMENT
LET
BE
THE
RST
LINE
SEGMENT
IN
THE
P
ORDER
THAT
INTERSECTS
P
THEN
CUT
P
INTO
TWO
POLYGONS
USING
THE
LINEAR
EXTENSION
OF
SO
YOU
EXTEND
THE
LINE
SEGMENT
INTO
A
LINE
AND
THEN
USE
THAT
TO
CUT
P
INTO
TWO
POLYGONS
SHOW
THAT
THE
EXPECTED
NUMBER
OF
RESULTING
POLYGONS
IS
O
N
LOG
N
HINT
USE
LINEARITY
OF
EXPECTATIONS
FIRST
ASK
YOURSELF
HOW
THE
NUMBER
OF
POLYGONS
IS
RELATED
TO
THE
NUMBER
OF
TIMES
THAT
LINE
SEGMENTS
GET
CUT
IN
THE
PROCESS
CONSIDER
TO
LINE
SEGMENTS
U
AND
V
LET
CU
V
BE
A
RANDOM
VARIABLE
THAT
IS
IF
THE
LINEAR
EXTENSION
OF
U
CUTS
V
LET
N
U
V
DENOTE
THE
NUMBER
OF
LINE
SEGMENTS
W
WHERE
THE
LINEAR
EXTENSION
OF
U
HITS
W
BEFORE
HITTING
V
IN
OTHER
WORDS
IF
YOU
STARTING
WALKING
FROM
U
ON
U
LINEAR
EXTENSION
TOWARDS
V
N
U
V
IS
HOW
MANY
LINE
SEGMENTS
YOU
CROSS
BEFORE
HITTING
V
IF
YOU
DON
T
HIT
V
THEN
N
U
V
WHAT
IS
THE
RELATIONSHIP
BETWEEN
THE
PROBABILITY
THAT
CU
V
AND
N
U
V
DUE
MONDAY
JANUARY
ASSUME
YOU
HAVE
A
SOURCE
OF
RANDOM
BITS
SO
IN
ONE
TIME
UNIT
THIS
SOURCE
WILL
PRODUCE
ONE
RANDOM
BIT
THAT
IS
WITH
PROBABILITY
INDEPENDENT
OF
OTHER
BITS
CONSIDER
THE
PROBLEM
OF
OUTPUTTING
A
RANDOM
PERMUTATION
OF
THE
INTEGERS
FROM
TO
N
SO
EACH
OF
THE
N
PERMUTATIONS
SHOULD
BE
PRODUCED
WITH
PROBABILITY
EXACTLY
N
A
GIVE
AN
ALGORITHM
TO
SOLVE
THIS
PROBLEM
AND
SHOW
THAT
THE
EXPECTED
TIME
OF
THE
ALGORITHM
IS
O
N
LOG
N
THIS
INCLUDES
BOTH
THE
TIME
THAT
YOUR
ALGORITHM
TAKES
PLUS
UNIT
OF
TIME
FOR
EACH
RANDOM
BIT
USED
B
NOW
ASSUME
THAT
THERE
IS
A
LIMITED
SOURCE
OF
AT
MOST
RANDOM
BITS
SHOW
THAT
THERE
IS
NO
ALGORITHM
THAT
CAN
SOLVE
THE
PROBLEM
USING
EXPECTED
TIME
O
HINT
SHOW
THE
RESULT
FOR
N
WHY
CAN
T
YOU
PRODUCE
A
RANDOM
PERMUTATION
OF
USING
BITS
THEN
GENERALIZE
TO
AN
ARBITRARY
N
FURTHER
HINT
OFTEN
STUDENTS
WILL
SAY
THAT
THERE
TWO
SUBPROBLEMS
ARE
CONTRADICTORY
MAYBE
START
BY
UNDERSTANDING
WHY
THEY
ARE
NOT
CONTRADICTORY
DUE
MONDAY
JANUARY
FROM
THE
CLRS
TEXT
DUE
WEDNESDAY
FEBRUARY
A
LET
P
BE
A
PROBLEM
THE
WORST
CASE
TIME
COMPLEXITY
OF
P
IS
O
THE
WORST
CASE
TIME
COMPLEXITY
OF
P
IS
N
LOG
N
LET
A
BE
AN
ALGORITHM
THAT
SOLVES
P
WHICH
OF
THE
FOLLOWING
STATEMENTS
ARE
CONSISTENT
WITH
THIS
INFORMATION
ABOUT
THE
COMPLEXITY
OF
P
I
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
II
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
III
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
N
LOG
N
IV
A
HAS
WORST
CASE
TIME
COMPLEXITY
T
V
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
N
LOG
N
VI
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
N
B
LET
P
BE
A
PROBLEM
THE
WORST
CASE
TIME
COMPLEXITY
OF
P
IS
O
THE
WORST
CASE
TIME
COMPLEXITY
OF
P
IS
N
LET
A
BE
AN
ALGORITHM
THAT
SOLVES
P
WHICH
OF
THE
FOLLOWING
STATEMENTS
ARE
LOGICALLY
CONSISTENT
WITH
THIS
INFORMATION
ABOUT
THE
COMPLEXITY
OF
P
I
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
II
A
HAS
WORST
CASE
TIME
COMPLEXITY
T
III
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
N
LOG
N
IV
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
N
V
A
HAS
WORST
CASE
TIME
COMPLEXITY
N
LOG
N
VI
A
HAS
WORST
CASE
TIME
COMPLEXITY
O
N
LOG
N
C
ASSUME
THAT
PROBLEM
P
HAS
WORST
CASE
TIME
COMPLEXITY
O
ASSUME
THAT
PROBLEM
P
HAS
WORST
CASE
TIME
COMPLEXITY
O
ASSUME
THAT
A
IS
AN
ALGORITHM
FOR
PROBLEM
P
FOR
EACH
OF
THE
FOLLOWING
STATEMENTS
STATE
WHETHER
THE
STATEMENT
IS
LOGICALLY
IMPLIED
BY
THE
ABOVE
INFORMATION
AND
STATE
WHETHER
THE
STATEMENT
IS
LOGICALLY
CONSISTENT
WITH
THE
ABOVE
INFORMATION
SO
I
AM
LOOKING
FOR
YES
NO
ANSWERS
I
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
O
II
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
O
III
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
N
IV
ALGORITHM
A
HAS
WORST
CAST
TIME
COMPLEXITY
O
N
DUE
FRIDAY
FEBRUARY
FROM
THE
CLRS
TEXT
DUE
FRIDAY
FEBRUARY
A
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
IS
A
SORTED
ARRAY
A
CONTAINING
N
REAL
NUM
BERS
AND
A
REAL
NUMBER
X
AND
THE
OUTPUT
IS
AN
INTEGER
K
SUCH
THAT
IF
X
IS
IN
A
V
THEN
IT
MUST
LIE
BETWEEN
POSITIONS
K
AND
K
N
ASSUME
THAT
EACH
ELEMENT
OF
A
AND
X
ARE
INDEPENDENTLY
AND
UNIFORMLY
DISTRIBUTED
IN
THE
INTERVAL
SHOW
THAT
THE
FOLLOWING
ALGORITHM
SOLVES
THIS
PROBLEM
IN
O
AVERAGE
CASE
TIME
LAST
X
N
IF
A
LAST
X
THEN
NEXT
LAST
SQRT
N
WHILE
A
NEXT
X
DO
LAST
NEXT
NEXT
NEXT
SQRT
N
RETURN
K
LAST
ELSE
IF
A
LAST
X
THEN
NEXT
LAST
SQRT
N
WHILE
A
NEXT
X
DO
LAST
NEXT
NEXT
NEXT
SQRT
N
RETURN
K
NEXT
HINT
FIND
THE
BERNOULLI
TRIALS
FIGURE
OUT
HOW
TO
THINK
ABOUT
THE
OUTCOME
OF
THIS
ALGORITHM
IN
TERMS
OF
THE
NUMBER
OF
SUCCESSES
FAILURES
IN
SOME
BERNOULLI
TRIALS
USE
A
CHERNO
TAIL
BOUND
SEE
APPENDIX
C
YOU
CAN
USE
THE
RESULT
OF
EXERCISE
C
WITHOUT
PROOF
B
EXPLAIN
HOW
TO
USE
THE
ABOVE
ALGORITHM
TO
OBTAIN
AN
ALGORITHM
WITH
O
LOG
LOG
N
AVERAGE
CASE
RUNNING
TIME
FOR
THE
SEARCHING
PROBLEM
NDING
THE
LOCATION
OF
THE
ELEMENT
IN
A
WHOSE
VALUE
IS
CLOSEST
TO
X
AGAIN
ASSUME
THAT
EACH
ELEMENT
OF
A
AND
X
ARE
INDEPENDENTLY
AND
UNIFORMLY
DISTRIBUTED
IN
THE
INTERVAL
DUE
MONDAY
FEBRUARY
THE
PURPOSE
OF
THIS
PROBLEM
IS
TO
DEVELOP
A
VERSION
OF
YAO
TECHNIQUE
FOR
MONTE
CARLO
RANDOMIZED
ALGORITHMS
WITHIN
THE
CONTEXT
OF
THE
RED
AND
BLUE
JUG
PROBLEM
FROM
PROBLEM
IN
THE
CLRS
TEXT
ASSUME
THAT
IF
YOU
SORTED
THE
JUGS
BY
VOLUME
THAT
EACH
PERMUTATION
IS
EQUALLY
LIKELY
A
SHOW
THAT
IF
A
DETERMINISTIC
ALGORITHM
A
ALWAYS
STOPS
IN
O
N
LOG
N
STEPS
THEN
THE
PROBABILITY
THAT
A
IS
CORRECT
FOR
LARGE
N
IS
LESS
THAN
PERCENT
B
SHOW
IF
THERE
IS
A
DISTRIBUTION
OF
THE
INPUT
ON
WHICH
NO
DETERMINISTIC
ALGORITHM
WITH
RUNNING
TIME
A
N
IS
CORRECT
WITH
PROBABILITY
PERCENT
THEN
THERE
IS
NO
MONTE
CARLO
ALGORITHM
WITH
RUNNING
TIME
A
N
THAT
CAN
BE
CORRECT
WITH
PROBA
BILITY
PERCENT
HINT
MIMIC
THE
PROOF
OF
YAO
TECHNIQUE
LEMMA
FOR
THE
CASE
OF
LAS
VEGAS
ALGO
RITHMS
CONSIDER
A
TWO
DIMENSIONAL
TABLE
MATRIX
T
WHERE
ENTRY
T
A
I
IS
IF
ALGORITHM
A
IS
CORRECT
ON
INPUT
I
AND
OTHERWISE
C
CONCLUDE
THAT
ANY
MONTE
CARLO
ALGORITHM
FOR
THIS
JUG
PROBLEM
MUST
HAVE
TIME
COMPLEXITY
O
N
LOG
N
DUE
WEDNESDAY
FEBRUARY
CONSIDER
THE
FOLLOWING
ONLINE
PROBLEM
YOU
GIVEN
A
SEQUENCE
OF
BITS
BN
OVER
TIME
EACH
BIT
IS
IN
AN
ENVELOPE
YOU
RST
SEE
THE
ENVELOPE
FOR
THEN
THE
ENVELOPE
FOR
WHEN
YOU
GET
THE
ITH
ENVELOPE
YOU
CAN
EITHER
LOOK
INSIDE
TO
SEE
THE
BIT
OR
DESTROY
THE
ENVELOPE
IN
WHICH
CASE
YOU
WILL
NEVER
KNOW
WHAT
THE
BIT
IS
YOU
KNOW
A
PRIORI
THAT
AT
LEAST
N
OF
THE
BITS
ARE
YOU
GOAL
IS
TO
ND
AN
ENVELOPE
CONTAINING
A
BIT
YOU
WANT
TO
OPEN
AS
FEW
ENVELOPES
AS
POSSIBLE
A
GIVE
A
DETERMINISTIC
ALGORITHM
THAT
WILL
OPEN
AT
MOST
N
O
ENVELOPES
HINT
THIS
IS
COMPLETELY
STRAIGHT
FORWARD
B
GIVE
AN
ADVERSARIAL
STRATEGY
TO
SHOW
THAT
EVERY
DETERMINISTIC
ALGORITHM
MUST
OPEN
AT
LEAST
N
O
ENVELOPES
HINT
THIS
IS
COMPLETELY
STRAIGHT
FORWARD
C
ASSUME
THAT
EACH
OF
THE
N
PERMUTATIONS
OF
THE
INPUTS
IS
EQUALLY
LIKELY
SHOW
THAT
THERE
IS
A
DETERMINISTIC
ALGORITHM
WHERE
THE
EXPECTED
NUMBER
OF
ENVELOPES
THAT
IS
OPENS
IS
O
HINT
THIS
IS
A
STRAIGHT
FORWARD
CONSEQUENCE
OF
SOME
FACTS
THAT
WE
LEARNED
ABOUT
BERNOULLI
TRIALS
D
GIVE
A
MONTE
CARLO
ALGORITHM
THAT
OPENS
O
LOG
N
ENVELOPES
AND
HAS
PROBABILITY
OF
ERROR
N
SHOW
THAT
THE
PROBABILITY
OF
ERROR
IS
THIS
SMALL
HINT
THIS
IS
A
STRAIGHT
FORWARD
CONSEQUENCE
OF
SOME
FACTS
THAT
WE
LEARNED
ABOUT
BERNOULLI
TRIALS
E
SHOW
USING
THE
VERSION
OF
YAO
TECHNIQUE
FOR
MONTE
CARLO
ALGORITHMS
THAT
YOU
DEVELOPED
IN
THE
LAST
HOMEWORK
ASSIGNMENT
TO
SHOW
THAT
EVERY
MONTE
CARLO
AL
GORITHM
MUST
OPEN
O
LOG
N
ENVELOPES
IF
IT
IS
TO
BE
INCORRECT
WITH
PROBABILITY
N
HINT
THIS
IS
A
STRAIGHT
FORWARD
APPLICATION
OF
THE
YAO
TECHNIQUE
FOR
MONTE
CARLO
ALGORITHMS
THAT
YOU
DEVELOPED
IN
THE
PREVIOUS
HOMEWORK
PROBLEM
F
GIVE
A
LAS
VEGAS
ALGORITHM
WHERE
THE
EXPECTED
NUMBER
OF
OPENED
ENVELOPES
IS
O
HINT
TAKE
SOME
RANDOM
GUESSES
FOR
THE
RST
HALF
OF
THE
ENVELOPES
AND
THEN
IF
YOU
DON
T
ND
A
BIT
GIVE
UP
AND
DO
THE
MOST
OBVIOUS
THING
SEE
THE
DISCUSSION
OF
THE
BIRTHDAY
PARADOX
IN
SECTION
YOU
MAY
USE
FACTS
FROM
THE
ANALYSIS
OF
THE
BIRTHDAY
PARADOX
IN
THE
CLRS
TEXT
OR
FROM
THE
WIKIPEDIA
HTTP
EN
WIKIPEDIA
ORG
WIKI
WITHOUT
PROOF
DUE
FRIDAY
FEBRUARY
SHOW
THAT
EVERY
LAS
VEGAS
ALGORITHM
FOR
THE
PREVIOUS
ENVELOPE
PROBLEM
MUST
OPEN
O
ENVELOPES
IN
EXPECTATION
HINT
USE
YAO
TECHNIQUE
AND
THE
FOLLOWING
PROBABILITY
DISTRIBUTION
WITH
PROBABILITY
V
HALF
N
UNIFORMLY
DISTRIBUTED
RANDOM
BITS
IN
ENVELOPES
N
ARE
SET
TO
THE
OTHER
V
BITS
IN
THE
RST
HALF
OF
THE
ENVELOPES
ARE
SET
TO
BITS
IN
THE
ENVELOPES
N
N
N
V
ARE
ALL
SET
TO
AND
THE
REMAINING
BITS
ARE
FOR
K
N
WITH
PROBABILITY
V
N
THE
BITS
IN
ENVELOPES
ARE
DISTRIBUTED
ACCORDING
TO
DISTRIBUTION
DK
IN
DK
ENVELOPES
N
CONTAIN
A
UNIFORMLY
DISTRIBUTED
RANDOM
SET
OF
K
AND
N
K
V
THEN
ENVELOPES
N
N
N
CONTAIN
A
UNIFORMLY
DISTRIBUTED
SET
OF
V
N
K
AND
K
THE
REMAINING
BITS
ARE
THIS
IS
ONE
OF
THE
HARDEST
HOMEWORK
PROBLEMS
OF
THE
SEMESTER
FEEL
FREE
TO
CONSIDER
THIS
TO
BE
EXTRA
CREDIT
IF
YOU
LIKE
DUE
MONDAY
FEBRUARY
PROBLEM
PART
C
USE
AN
EXCHANGE
ARGUMENT
THE
OBVIOUS
EXCHANGE
WORKS
BUT
THE
PROOF
OF
OPTIMALITY
IS
A
BIT
SUBTLE
YOU
CAN
ND
SOME
NOTES
ABOUT
WHAT
AN
EXCHANGE
AR
GUMENT
IS
HERE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
NOTES
GREEDYNOTES
PDF
DUE
WEDNESDAY
FEBRUARY
PROBLEM
HINT
FIRST
GURE
OUT
HOW
TO
EXHAUSTIVELY
GENERATE
ALL
FEASIBLE
SOLUTIONS
AS
THE
LEAVES
OF
SOME
TREE
THEN
CONSTRUCT
A
PRUNING
RULE
THAT
YOU
APPLY
TO
EACH
LEVEL
OF
THE
TREE
TO
PRUNE
OUT
SOME
SUBTREES
ROOTED
AT
THIS
LEVEL
THE
NATURAL
PRUNING
RULE
IS
SIMILAR
TO
THE
ONE
USED
BY
BELLMAN
FORD
DUE
WEDNESDAY
FEBRUARY
THE
INPUT
TO
THIS
PROBLEM
IS
TWO
SEQUENCES
T
TN
AND
P
PK
SUCH
THAT
K
N
AND
A
POSITIVE
INTEGER
COST
CI
ASSOCIATED
WITH
EACH
TI
THE
PROBLEM
IS
TO
ND
A
SUBSEQUENCE
OF
OF
T
THAT
MATCHES
P
WITH
MAXIMUM
AGGREGATE
COST
THAT
IS
ND
THE
PK
SEQUENCE
IK
SUCH
THAT
FOR
ALL
J
J
K
WE
HAVE
TIJ
PJ
AND
J
CIJ
IS
MAXIMIZED
SO
FOR
EXAMPLE
IF
N
T
XY
XXY
K
P
XY
AND
THEN
THE
OPTIMAL
SOLUTION
IS
TO
PICK
THE
SECOND
X
IN
T
AND
THE
SECOND
Y
IN
T
FOR
A
COST
OF
A
GIVE
A
DYNAMIC
PROGRAMMING
ALGORITHM
BASED
ON
ENUMERATING
SUBSEQUENCES
OF
T
AND
USING
THE
PRUNING
METHOD
B
GIVE
A
DYNAMIC
PROGRAMMING
ALGORITHM
BASED
ON
ENUMERATING
SUBSEQUENCES
OF
P
AND
USING
THE
PRUNING
METHOD
DUE
FRIDAY
FEBRUARY
THERE
ARE
THREE
SHORTEST
PATH
ALGORITHMS
COVERED
IN
CHAPTER
BELLMAN
FORD
DIJKSTRA
AND
THE
TOPOLOGICAL
SORT
ALGORITHM
FOR
DIRECTED
ACYCLIC
GRAPHS
FOR
EACH
OF
THE
FOLLOWING
PROBLEMS
PICK
THE
MOST
APPROPRIATE
OF
THESE
THREE
SHORTEST
PATH
ALGORITHMS
TO
APPLY
TO
OBTAIN
AN
ALGORITHM
FOR
THE
PROBLEM
THIS
MAY
OR
MAY
NOT
INVOLVE
MODIFYING
THE
ALGORITHM
SLIGHTLY
IF
YOU
NEED
TO
MODIFY
THE
ALGORITHM
EXPLAIN
HOW
YOU
MAY
NEED
TO
RST
BRIE
Y
EXPLAIN
WHY
THE
PROBLEM
IS
INDEED
JUST
A
SHORTEST
PATH
PROBLEM
IN
DISGUISE
THAT
IS
STATE
HOW
ONE
OBTAINS
THE
GRAPH
AND
WHY
THE
SHORTEST
PATH
IN
THIS
GRAPH
CORRESPONDS
TO
A
SOLUTION
TO
THE
PROBLEM
GIVE
THE
RUNNING
TIME
OF
THE
RESULTING
ALGORITHM
A
THE
PROBLEM
DESCRIBED
IN
B
THE
PROBLEM
DESCRIBED
IN
C
THE
PROBLEM
DESCRIBED
IN
D
THE
PROBLEM
OF
NDING
THE
PATH
WHERE
THE
MINIMUM
EDGE
WEIGHT
IS
MAXIMIZED
YOU
NEED
SUCH
AN
ALGORITHM
TO
IMPLEMENT
ONE
OF
THE
KARP
EDMONDS
VARIATIONS
ON
FORD
FULKERSON
DUE
MONDAY
FEBRUARY
FOR
EACH
OF
THE
NEXT
ALGORITHMS
STATE
WHETHER
THE
ALGORITHM
IS
A
POLYNOMIAL
TIME
ALGORITHM
WHETHER
THE
ALGORITHM
IS
A
PSEUDO
POLYNOMIAL
TIME
ALGORITHM
AND
WHETHER
THE
ALGORITHM
IS
A
STRONGLY
POLYNOMIAL
TIME
ALGORITHM
JUSTIFY
YOUR
ANSWERS
A
READ
XN
Y
FOR
I
TO
N
DO
FOR
I
TO
N
DO
Y
Y
XJ
XI
B
READ
XN
Y
FOR
I
TO
N
DO
FOR
I
TO
XI
DO
Y
Y
XJ
XI
C
READ
XN
Y
FOR
I
TO
N
DO
FOR
I
TO
LOG
XI
DO
Y
Y
XJ
XI
D
READ
XN
Y
FOR
I
TO
N
DO
FOR
I
TO
N
DO
Y
Y
Y
HINT
THIS
ONE
IS
A
BIT
TRICKY
IF
THE
ANSWER
IS
NOT
CLEAR
EXPLAIN
WHY
DUE
MONDAY
FEBRUARY
SHOW
HOW
EACH
OF
PROBLEMS
DESCRIBED
PROBLEMS
AND
FROM
THE
CLRS
TEXT
CAN
BE
E
CIENTLY
REDUCED
TO
NETWORK
OW
GIVE
THE
RUNNING
TIME
OF
THE
RESULT
ING
ALGORITHMS
FOR
EACH
PROBLEM
ASSUMING
THAT
YOU
CAN
SOLVE
NETWORK
OW
IN
TIME
T
V
E
F
WHERE
T
IS
SOME
FUNCTION
OF
THE
NUMBER
OF
VERTICES
V
IN
THE
NETWORK
THE
NUMBER
OF
EDGES
E
IN
THE
NETWORK
AND
THE
MAX
OW
F
IN
THE
NETWORK
DUE
WEDNESDAY
FEBRUARY
PROBLEM
FROM
THE
CLRS
TEXT
DUE
WEDNESDAY
FEBRUARY
CONSIDER
THE
PROBLEM
OF
CONSTRUCTING
A
MAXIMUM
CARDINALITY
BIPARTITE
MATCHING
THE
INPUT
IS
A
BIPARTITE
GRAPH
WHERE
ONE
BIPARTITION
ARE
THE
GIRLS
AND
ONE
BIPARTITION
IS
THE
BOYS
THERE
IS
AN
EDGE
BETWEEN
A
BOY
AND
A
GIRL
IF
THEY
ARE
WILLING
TO
DANCE
TOGETHER
THE
PROBLEM
IS
TO
MATCH
THE
BOYS
AND
GIRLS
FOR
ONE
DANCE
SO
THAT
AS
MANY
COUPLES
ARE
DANCING
AS
POSSIBLE
SEE
SECTION
IN
THE
BOOK
IF
YOU
WANT
MORE
DETAILS
A
CONSTRUCT
AN
INTEGER
LINEAR
PROGRAM
FOR
THIS
PROBLEM
SO
YOU
WANT
TO
EXPLAIN
HOW
TO
COMPUTE
MAXIMUM
CARDINALITY
MATCHINGS
BY
NDING
AN
OPTIMAL
INTEGER
SOLUTION
TO
A
PARTICULAR
LINEAR
PROGRAM
B
CONSIDER
THE
RELAXED
LINEAR
PROGRAM
WHERE
THE
INTEGRALITY
REQUIREMENTS
ARE
DROPPED
EXPLAIN
HOW
TO
ND
AN
INTEGER
OPTIMAL
SOLUTION
FROM
ANY
RATIONAL
OPTIMAL
SOLUTION
HINT
FIND
CYCLES
OF
EDGES
WITH
ASSOCIATED
VARIABLES
THAT
ARE
NOT
INTEGER
DUE
FRIDAY
FEBRUARY
CONSIDER
THE
MINIMUM
SPANNING
TREE
PROBLEM
DE
NED
IN
CHAPTER
OF
THE
TEXT
A
GIVE
AN
INTEGER
LINEAR
PROGRAMMING
FORMULATION
USING
THE
FOLLOWING
INTUITION
AND
PROVE
THAT
YOUR
FORMULATION
IS
CORRECT
THERE
IS
AN
INDICATOR
RANDOM
VARIABLE
FOR
EACH
EDGE
YOU
MUST
CHOOSE
AT
LEAST
N
EDGES
N
IS
THE
NUMBER
OF
VERTICES
IN
THE
GRAPH
FOR
EACH
SUBSET
OF
K
VERTICES
YOU
CAN
CHOOSE
AT
MOST
K
EDGES
CONNECTING
VERTICES
IN
EXPLAIN
WHY
THE
SIZE
OF
THIS
LINEAR
PROGRAM
CAN
BE
EXPONENTIAL
IN
THE
SIZE
OF
THE
GRAPH
B
GIVE
AN
INTEGER
LINEAR
PROGRAMMING
FORMULATION
USING
THE
FOLLOWING
INTUITION
AND
PROVE
THAT
YOUR
FORMULATION
IS
CORRECT
THERE
IS
AN
INDICATOR
RANDOM
VARIABLE
FOR
EACH
EDGE
YOU
MUST
CHOOSE
AT
EXACTLY
N
EDGES
FOR
EACH
SUBSET
OF
VERTICES
NOT
THE
EMPTY
SET
AND
NOT
ALL
THE
VERTICES
YOU
MUST
CHOOSE
AT
LEAST
ONE
EDGE
WITH
ONE
ENDPOINT
IN
AND
ONE
ENDPOINT
NOT
IN
EXPLAIN
WHY
THE
SIZE
OF
THIS
LINEAR
PROGRAM
CAN
BE
EXPONENTIAL
IN
THE
SIZE
OF
THE
GRAPH
HINT
THEOREM
IN
THE
TEXT
MAY
BE
USEFUL
C
GIVE
A
POLYNOMIAL
SIZED
INTEGER
LINEAR
PROGRAMMING
FORMULATION
USING
THE
FOLLOW
ING
INTUITION
AND
PROVE
THAT
YOUR
FORMULATION
IS
CORRECT
CALL
AN
ARBITRARY
VERTEX
THE
ROOT
R
THINK
OF
A
SPANNING
TREE
AS
ROUTING
OW
AWAY
FROM
R
TO
THE
REST
OF
THE
TREE
BUT
NOW
YOU
DO
NOT
HAVE
OW
CONSERVATION
AT
THE
VERTICES
EXPLAIN
WHY
THE
SIZE
OF
THIS
LINEAR
PROGRAM
IS
POLYNOMIALLY
BOUNDED
IN
THE
SIZE
OF
THE
GRAPH
D
CONSIDER
A
RELAXATION
OF
THE
INTEGER
LINEAR
PROGRAM
IN
THE
LAST
SUBPROBLEM
IN
THAT
NOW
THE
OWS
ON
THE
EDGES
MAY
BE
RATIONAL
AND
NOT
NECESSARILY
INTEGER
SHOW
HOW
TO
EXPRESS
AN
OPTIMAL
RATIONAL
SOLUTION
TO
THE
LINEAR
PROGRAM
AS
AN
A
NE
COMBINATION
OF
OPTIMAL
ROOTED
SPANNING
TREES
CONCLUDE
THAT
ONE
CAN
COMPUTE
IN
POLYNOMIAL
TIME
AN
OPTIMAL
SPANNING
GIVEN
THE
OPTIMAL
RATIONAL
SOLUTION
TO
THIS
LINEAR
PROGRAM
HINT
THE
COE
CIENT
FOR
THE
RST
TREE
WILL
BE
THE
LEAST
OW
ON
ANY
EDGE
AND
THEN
REPEAT
THIS
IDEA
DUE
FRIDAY
FEBRUARY
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
CONSISTS
OF
A
DIRECTED
GRAPH
G
WITH
A
SPECI
ED
SOURCE
VERTEX
AND
A
POSITIVE
INTEGER
PRO
T
FOR
EACH
VERTEX
OF
G
THE
OBJECTIVE
IS
TO
ND
A
SUBSET
H
OF
THE
VERTICES
OF
MAXIMUM
TOTAL
PRO
T
SUBJECT
TO
THE
CONSTRAINT
THAT
THERE
IS
A
COLLECTION
OF
VERTEX
DISJOINT
PATHS
FROM
TO
THE
VERTICES
IN
H
THAT
IS
IF
H
VK
THERE
THERE
MUST
BE
PATHS
PK
SUCH
THAT
EACH
PATH
PI
STARTS
AT
AND
ENDS
AT
VI
AND
NO
PAIR
OF
PATHS
SHARE
A
VERTEX
OTHER
THAN
A
WRITE
AN
INTEGER
LINEAR
PROGRAMMING
FORMULATION
FOR
THIS
PROBLEM
HINT
AS
IS
USUALLY
THE
CASE
THE
KEY
IS
TO
GURE
OUT
WHAT
THE
VARIABLES
WILL
BE
PROBABLY
THE
MOST
NATURAL
FORMULATION
HAS
TWO
TYPES
OF
VARIABLES
B
CONSIDER
THE
RELAXED
LINEAR
PROGRAM
WHERE
THE
INTEGRALITY
REQUIREMENTS
ARE
DROPPED
EXPLAIN
HOW
TO
ND
AN
INTEGER
OPTIMAL
SOLUTION
FROM
ANY
RATIONAL
OPTIMAL
SOLU
TION
HINT
MORALLY
THIS
ROUNDING
IS
THE
SAME
AS
FOR
MATCHING
BUT
THE
IMPLEMENTATION
IS
A
BIT
MORE
COMPLICATED
C
GIVE
A
STRONGLY
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
NOTE
THAT
NO
ONE
KNOWS
OF
A
STRONGLY
POLYNOMIAL
TIME
ALGORITHM
FOR
LINEAR
PROGRAMMING
YOU
MUST
PROVE
YOUR
ALGORITHM
IS
BOTH
CORRECT
AND
RUNS
IN
STRONGLY
POLYNOMIAL
TIME
HINT
WHAT
IS
GORDON
GEKKO
MOST
FAMOUS
QUOTE
YOU
CAN
GOOGLE
IT
IF
YOU
DON
T
KNOW
DUE
MONDAY
FEBRUARY
CONSIDER
A
TWO
PERSON
GAME
SPECI
ED
BY
AN
M
BY
N
PAYO
MATRIX
P
THE
TWO
PLAYERS
CAN
CAN
BE
THOUGHT
OF
AS
A
ROW
PLAYER
AND
A
COLUMN
PLAYER
THE
NUMBER
OF
POSSIBLE
MOVES
FOR
THE
ROW
PLAYER
IS
M
AND
THE
NUMBER
OF
POSSIBLE
MOVES
FOR
THE
COLUMN
PLAYER
IS
N
EACH
PLAYER
PICKS
ONE
OF
ITS
MOVES
AND
THEN
MONEY
IS
EXCHANGED
IF
THE
ROW
PLAYER
MAKES
MOVE
R
AND
THE
COLUMN
PLAYER
MAKES
MOVE
C
THEN
THE
ROW
PLAYER
PAYS
THE
COLUMN
PLAYER
PR
C
DOLLARS
NOTE
THAT
PR
C
COULD
BE
NEGATIVE
IN
WHICH
CASE
REALLY
THE
COLUMN
PLAYER
IS
PAYING
MONEY
TO
THE
ROW
PLAYER
WE
ASSUME
THAT
THE
GAME
IS
PLAYED
SEQUENTIALLY
SO
THAT
ONE
PLAYER
SPECI
ES
HIS
MOVE
THE
OTHER
PLAYERS
SEES
THAT
MOVE
AND
THEN
SPECI
ES
A
RESPONSE
MOVE
WE
CAM
ASSUME
THAT
THIS
PLAYER
MAKES
THE
BEST
POSSIBLE
RESPONSE
OBVIOUSLY
EACH
PLAYER
WANTS
TO
BE
PAYED
AS
MUCH
MONEY
AS
POSSIBLE
AND
IF
THIS
IS
NOT
POSSIBLE
TO
PAY
AS
LITTLE
AS
POSSIBLE
A
GIVE
A
SIMPLE
E
CIENT
ALGORITHM
THAT
WILL
COMPUTE
THE
BEST
RESPONSE
FOR
THE
COLUMN
PLAYER
GIVE
A
SPECI
C
MOVE
BY
THE
ROW
PLAYER
B
GIVE
A
SIMPLE
E
CIENT
ALGORITHM
THAT
WILL
COMPUTE
THE
BEST
RST
MOVE
BY
THE
ROW
PLAYER
GIVEN
THAT
THE
COLUMN
PLAYER
WILL
GIVE
ITS
BEST
RESPONSE
C
EITHER
GIVE
AN
EXAMPLE
OF
A
PAYO
MATRIX
WHERE
IT
IS
STRICTLY
BETTER
FOR
EACH
PLAYER
TO
GO
SECOND
OR
ARGUE
THAT
THERE
IS
NO
SUCH
PAYO
MATRIX
HINT
ROSHAMBO
NOW
WE
CHANGE
THE
PROBLEM
SO
THAT
EACH
PLAYER
SPECI
ES
A
PROBABILITY
DISTRIBUTION
OVER
HIS
MOVES
AND
THEN
THE
ROW
PLAYER
PAYS
THE
COLUMN
PLAYER
E
PR
C
WHERE
THE
EXPECTATION
IS
TAKEN
OVER
THE
TWO
PROBABILITY
DISTRIBUTIONS
IN
THE
NATURAL
WAY
D
GIVE
A
SIMPLE
E
CIENT
ALGORITHM
THAT
WILL
E
CIENTLY
COMPUTE
THE
BEST
RESPONSE
WHICH
IS
PROBABILITY
DISTRIBUTION
OVER
COLUMN
MOVES
FOR
THE
COLUMN
PLAYER
GIVEN
A
PROBABILITY
DISTRIBUTION
SPECI
ED
BY
THE
ROW
PLAYER
E
GIVE
A
LINEAR
PROGRAM
THAT
WILL
COMPUTE
THE
BEST
RST
MOVE
PROBABILITY
DISTRIBU
TION
OVER
ROW
MOVES
FOR
THE
ROW
PLAYER
GIVEN
THAT
THE
COLUMN
PLAYER
MAKES
THE
BEST
RESPONSE
F
SHOW
THE
LINEAR
PROGRAM
YOU
WOULD
GET
FOR
THE
FOLLOWING
PAYO
MATRIX
G
GIVE
A
LINEAR
PROGRAM
TO
COMPUTE
THE
BEST
RST
MOVE
PROBABILITY
DISTRIBUTION
OVER
COLUMN
MOVES
FOR
THE
COLUMN
PLAYER
GIVEN
THAT
THE
ROW
PLAYER
MAKES
THE
BEST
RESPONSE
H
SHOW
THE
LINEAR
PROGRAM
YOU
WOULD
GET
FOR
THE
FOLLOWING
PAYO
MATRIX
I
EITHER
GIVE
AN
EXAMPLE
OF
A
PAYO
MATRIX
WHERE
IT
IS
STRICTLY
BETTER
FOR
EACH
PLAYER
TO
GO
SECOND
OR
ARGUE
THAT
THERE
IS
NO
SUCH
PAYO
MATRIX
HINT
STRONG
LINEAR
PROGRAMMING
DUALITY
DUE
WEDNESDAY
MARCH
CONSIDER
THE
PROBLEM
OF
CONSTRUCTING
MAXIMUM
CARDINALITY
BIPARTITE
MATCHING
SEE
SECTION
IN
THE
CLR
TEXT
A
CONSTRUCT
AN
INTEGER
LINEAR
PROGRAM
FOR
THIS
PROBLEM
B
CONSTRUCT
THE
DUAL
LINEAR
PROGRAM
C
GIVE
A
NATURAL
ENGLISH
INTERPRETATION
OF
THE
DUAL
PROBLEM
E
G
SIMILAR
TO
HOW
WE
INTERPRETED
THE
DUAL
OF
DIET
PROBLEM
AS
THE
PILL
PROBLEM
D
EXPLAIN
HOW
TO
GIVE
A
SIMPLE
PROOF
THAT
A
GRAPH
DOESN
T
HAVE
A
MATCHING
OF
A
PARTICULAR
SIZE
YOU
SHOULD
BE
ABLE
TO
COME
UP
WITH
A
METHOD
THAT
WOULD
CONVINCE
SOMEONE
WHO
KNOWS
NOTHING
ABOUT
LINEAR
PROGRAMMING
DUE
WEDNESDAY
MARCH
CONSIDER
THE
PROBLEM
OF
SCHEDULING
A
COLLECTION
OF
PROCESSES
ON
ONE
PROCESSOR
EACH
PROCESS
JI
HAS
A
WORK
XI
A
RELEASE
TIME
RI
AND
A
DEADLINE
DI
ALL
THESE
VALUES
ARE
POSITIVE
INTEGERS
A
JOB
CAN
NOT
BE
RUN
BEFORE
ITS
RELEASE
TIME
OR
AFTER
ITS
DEADLINE
THE
GOAL
IS
TO
ND
THE
SLOWEST
POSSIBLE
SPEED
THAT
WILL
ALLOW
YOU
TO
NISH
DO
ALL
THE
WORK
FROM
EACH
JOB
IF
A
JOB
IS
PROCESSED
AT
SPEED
FOR
T
UNITS
OF
TIME
THIS
WILL
COMPLETE
T
UNITS
OF
WORK
FROM
THAT
JOB
THE
PROCESSOR
CAN
PROCESS
AT
MOST
ONE
JOB
AT
EACH
MOMENT
OF
TIME
BUT
A
PROCESSOR
CAN
SWITCH
BETWEEN
PROCESSES
ARBITRARILY
FOR
EXAMPLE
THE
PROCESSOR
CAN
RUN
FOR
A
WHILE
THEN
SWITCH
TO
THEN
BACK
TO
THEN
TO
ETC
THE
TIMES
OF
THESE
SWITCHES
NEED
NOT
BE
INTEGER
A
EXPRESS
THIS
PROBLEM
AS
A
LINEAR
PROGRAM
B
CONSTRUCT
THE
DUAL
PROGRAM
C
GIVE
A
NATURAL
ENGLISH
INTERPRETATION
OF
THE
DUAL
PROBLEM
E
G
SIMILAR
TO
HOW
WE
INTERPRETED
THE
DUAL
OF
THE
MAX
OW
PROBLEM
AS
THE
MIN
CUT
PROBLEM
D
EXPLAIN
HOW
TO
GIVE
A
SIMPLE
PROOF
THAT
THE
INPUT
IS
INFEASIBLE
FOR
A
PARTICULAR
SPEED
YOU
SHOULD
BE
ABLE
TO
COME
UP
WITH
A
METHOD
THAT
WOULD
CONVINCE
SOMEONE
WHO
KNOWS
NOTHING
ABOUT
LINEAR
PROGRAMMING
HINT
FIND
THE
RELATIONSHIP
BETWEEN
THIS
PROBLEM
AND
THE
PREVIOUS
PROBLEM
THAT
IS
GURE
OUT
WHAT
THIS
PROBLEM
HAS
TO
DO
WITH
BIPARTITE
MATCHING
YOU
ARE
WELCOME
TO
USE
FACTS
YOU
DEVELOPED
IN
SOLVING
THE
PREVIOUS
PROBLEM
DUE
FRIDAY
MARCH
ASSUME
THAT
YOU
HAVE
A
PARK
MATHEMATICALLY
A
DIMENSIONAL
PLANE
CONTAINING
K
LIGHTS
AND
N
STATUES
IN
PARTICULAR
YOU
KNOW
FOR
EACH
LIGHT
LAND
FOR
EACH
STATUE
WHETHER
LIGHT
L
WILL
ILLUMINATE
STATUE
IF
LIGHT
L
IS
LIT
THIS
IS
A
BINARY
VALUE
THERE
IS
NO
POSSIBILITY
OF
PARTIAL
ILLUMINATION
FURTHER
YOU
ARE
TOLD
FOR
EACH
LIGHT
L
THE
COST
CL
FOR
TURNING
L
ON
THE
GOAL
IS
TO
LIGHT
ALL
THE
STATUES
WHILE
SPENDING
AS
LITTLE
MONEY
AS
POSSIBLE
A
CONSTRUCT
AN
INTEGER
LINEAR
PROGRAM
FOR
THIS
PROBLEM
WHERE
THERE
ARE
BINARY
IN
DICATOR
VARIABLES
FOR
EACH
LIGHT
SIGNIFYING
WHETHER
THE
LIGHT
IS
LIT
OR
NOT
B
CONSIDER
THE
RELAXED
LINEAR
PROGRAM
WHERE
THE
VARIABLES
ARE
ALLOWED
TO
BE
ANY
RATIONAL
BETWEEN
AND
GIVE
AN
ENGLISH
EXPLANATION
OF
THE
PROBLEM
THAT
THIS
MODELS
HINT
IMAGINE
THE
LIGHTS
HAVE
A
DIMMER
CONTROL
C
SHOW
THAT
THE
RELAXED
LINEAR
PROGRAM
WHERE
THE
VARIABLES
ARE
ALLOWED
TO
BE
ANY
RATIONAL
BETWEEN
AND
CAN
HAVE
A
STRICTLY
SMALLER
OBJECTIVE
THAN
THE
OPTIMAL
OBJECTIVE
FOR
THE
INTEGER
LINEAR
PROGRAM
FOR
SOME
INSTANCES
D
CONSTRUCT
THE
DUAL
PROGRAM
FOR
THE
RELAXED
LINEAR
PROGRAM
E
GIVE
A
NATURAL
ENGLISH
INTERPRETATION
OF
THE
DUAL
PROBLEM
THE
PROBLEM
MODELED
BY
THE
DUAL
LINEAR
PROGRAM
F
EXPLAIN
HOW
TO
GIVE
A
SIMPLE
PROOF
THAT
A
CERTAIN
COST
IS
REQUIRED
FOR
THE
PROBLEM
MODELED
BY
THE
RELAXED
LINEAR
PROGRAM
THE
ONE
WITH
DIMMER
CONTROLS
USING
THIS
NATURAL
INTERPRETATION
OF
THE
DUAL
DUE
MONDAY
MARCH
PROVE
THAT
EACH
OF
THE
PROBLEMS
DE
NED
IN
AND
ARE
NP
HARD
USING
A
REDUCTION
USING
A
REDUCTION
FROM
AN
NP
COMPLETE
PROBLEM
OF
YOUR
CHOICE
THAT
IS
DE
NED
EARLIER
IN
CHAPTER
SO
FOR
EACH
PROBLEM
YOU
NEED
TO
GIVE
ONE
POLYNOMIAL
TIME
REDUCTION
THE
DI
CULTY
OF
NDING
THE
REDUCTIONS
RANGES
FROM
TRIVIAL
TO
REASONABLY
STRAIGHT
FORWARD
DUE
WEDNESDAY
MARCH
SHOW
THAT
THE
COLOR
PROBLEM
IS
NP
HARD
BY
REDUCTION
FROM
THE
CNF
SAT
PROB
LEM
COLOR
IS
DE
NED
IN
PROBLEM
IN
THE
TEXT
WHICH
ALSO
CONTAINS
COPIOUS
HINTS
DUE
FRIDAY
MARCH
WE
CONSIDER
A
GENERALIZATION
OF
THE
FOX
GOOSE
AND
BAG
OF
BEANS
PUZZLE
HTTP
EN
WIKIPEDIA
ORG
WIKI
FOX
THE
INPUT
IS
A
GRAPH
G
AN
INTEGER
K
THE
VERTICES
OF
G
ARE
OBJECTS
THAT
THE
FARMER
HAS
TO
TRANSPORT
OVER
THE
RIVER
THERE
ARE
AN
EDGE
BETWEEN
TWO
OBJECTS
IF
THEY
CAN
NOT
BE
LEFT
ALONE
WITHOUT
THE
FARMER
SUPERVISION
ON
THE
SAME
SIZE
OF
THE
RIVER
THE
GOAL
IS
TO
DETERMINE
IF
A
BOAT
OF
SIZE
K
IS
SU
CIENT
TO
SAFELY
TRANSPORT
THE
OBJECTS
ACROSS
THE
RIVER
THE
SIZE
OF
THE
BOAT
IS
THE
NUMBER
OF
OBJECTS
THAT
THE
FARMER
CAN
HAUL
IN
THE
BOAT
SHOW
THAT
THIS
PROBLEM
IS
NP
HARD
USING
A
REDUCTION
FROM
ONE
OF
THE
PROBLEMS
DEPICTED
IN
GURE
IN
THE
CLRS
TEXT
SO
I
AM
LETTING
YOU
PICK
THE
PROBLEM
TO
REDUCE
FROM
HERE
YOU
SHOULD
TAKE
SOME
TIME
TO
RE
ECT
WHICH
PROBLEM
WOULD
BE
EASIEST
TO
REDUCE
FROM
DUE
MONDAY
MARCH
PROBLEM
PARTS
A
B
AND
D
FROM
THE
CLRS
TEXT
DUE
MONDAY
MARCH
FROM
THE
CLRS
TEXT
DUE
WEDNESDAY
MARCH
PROBLEM
FROM
THE
CLRS
TEXT
DUE
FRIDAY
MARCH
PROBLEM
FROM
THE
CLRS
TEXT
DUE
FRIDAY
MARCH
PROVE
THAT
IF
THERE
IS
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THE
MAXIMUM
CLIQUE
PROBLEM
THAT
HAS
APPROXIMATION
RATIO
THEN
THERE
IS
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
WITH
APPROXIMATION
RATIO
THIS
IS
ACTUALLY
A
SLIGHTLY
EASIER
PROBLEM
THAN
PROBLEM
PART
B
IN
THE
CLRS
TEXT
WHICH
I
SUGGEST
THAT
YOU
LOOK
AT
FOR
INSPIRATION
NOTE
THAT
IN
SOME
SENSE
THIS
CAN
BE
VIEWED
AS
A
GAP
REDUCTION
DUE
MONDAY
MARCH
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
A
GRAPH
G
V
E
FEASIBLE
SOLUTIONS
ARE
SUBSETS
OF
THE
VERTICES
V
THE
OBJECTIVE
IS
TO
MAXIMIZE
THE
NUMBER
OF
EDGES
WITH
ONE
ENDPOINT
IN
AND
ONE
ENDPOINT
IN
V
A
GIVE
A
SIMPLE
POLYNOMIAL
TIME
RANDOMIZED
ALGORITHM
FOR
THIS
PROBLEM
AND
SHOW
THAT
IT
IS
APPROXIMATE
HINT
FLIP
A
COIN
FOR
VERTEX
AND
CONSIDER
ANALYSIS
FOR
FROM
CLASS
B
DEVELOP
A
DETERMINISTIC
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THIS
PROB
LEM
USING
THE
METHOD
OF
CONDITIONAL
EXPECTATIONS
WHICH
CONSIDERS
THE
VERTICES
ONE
BY
ONE
BUT
INSTEAD
OF
IPPING
A
COIN
FOR
EACH
VERTEX
V
PUTS
V
IN
THE
BIPARTITION
THAT
WOULD
MAXIMIZE
THE
EXPECTED
NUMBER
OF
EDGES
IN
THE
CUT
IF
COIN
IPS
WERE
USED
FOR
THE
REMAINING
VERTICES
C
GIVE
A
SIMPLE
GREEDY
ALGORITHM
THAT
ENDS
UP
IMPLEMENTING
THIS
POLICY
D
PROVE
THAT
THIS
GREEDY
ALGORITHM
HAS
APPROXIMATION
RATIO
AT
MOST
DUE
MONDAY
MARCH
CONSIDER
THE
MAX
SAT
PROBLEM
SEE
HTTPS
EN
WIKIPEDIA
ORG
WIKI
A
GIVEN
AN
INTEGER
LINEAR
PROGRAMMING
FORMULATION
OF
MAX
SAT
HINT
THERE
SHOULD
BE
TWO
TYPES
OF
VARIABLES
IN
THE
LINEAR
PROGRAM
ONE
LINEAR
PROGRAMMING
VARIABLE
XV
FOR
EACH
VARIABLE
V
IN
THE
MAX
SAT
INSTANCE
AND
ONE
LINEAR
PROGRAMMING
VARIABLE
YC
FOR
EACH
CLAUSE
C
IN
THE
MAX
SAT
INSTANCE
B
LET
XV
BE
AN
OPTIMAL
SOLUTION
TO
THE
RELAXED
RATIONAL
LINEAR
PROGRAM
SHOW
THAT
SETTING
THE
VARIABLE
V
TO
WITH
PROBABILITY
XV
AND
TO
OTHERWISE
INDEPENDENT
OF
THE
SETTING
OF
THE
OTHER
VARIABLES
YIELDS
A
E
APPROXIMATION
HINT
USE
THE
FACT
THAT
THE
GEOMETRIC
MEAN
IS
AT
MOST
THE
ARITHMETIC
MEAN
HTTPS
EN
WIKIPEDIA
ORG
WIKI
ALSO
USE
THE
FACT
THAT
IF
F
X
IS
A
CONCAVE
FUNCTION
ON
AN
INTERVAL
A
B
YOU
CAN
LOWER
BOUND
F
X
IN
THIS
INTERVAL
THE
LINE
THAT
PASSES
THROUGH
A
F
A
AND
B
F
B
DUE
WEDNESDAY
MARCH
PROBLEM
FROM
THE
CLRS
TEXT
YOU
MUST
USE
A
POTENTIAL
FUNCTION
ANALYSIS
TO
PROVE
O
AMORTIZED
TIME
HINT
THE
POTENTIAL
FUNCTION
FOR
DYNAMIC
TABLES
WILL
BE
USEFUL
DUE
FRIDAY
MARCH
PROBLEM
FROM
THE
CLRS
TEXT
DUE
FRIDAY
MARCH
ASSUME
THAT
YOU
HAVE
A
COLLECTION
OF
N
BOXES
ARRIVING
ONLINE
OVER
TIME
THAT
MUST
BE
LOADED
ONTO
M
TRUCKS
WHEN
A
BOX
ARRIVES
THE
ONLINE
ALGORITHM
LEARNS
THE
WEIGHT
OF
THE
BOX
AND
A
LIST
OF
TRUCKS
THAT
THAT
BOX
CAN
BE
LOADED
ON
SO
NOT
EVERY
BOX
IS
ALLOWED
TO
BE
LOADED
ON
EVERY
TRUCK
AT
THE
TIME
THAT
A
BOX
ARRIVES
THE
ONLINE
ALGORITHM
MUST
PICK
A
TRUCK
TO
LOAD
THE
BOX
ON
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
WEIGHT
OF
THE
MOST
HEAVILY
LOADED
TRUCK
GIVE
AN
ADVERSARIAL
ARGUMENT
TO
SHOW
NO
DETERMINISTIC
ONLINE
ALGORITHM
CAN
ACHIEVE
APPROXIMATION
RATIO
O
HINT
IN
YOUR
ADVERSARIAL
STRATEGY
LATER
ARRIVING
BOXES
SHOULD
BE
MADE
ONLY
ASSIGNABLE
TO
TRUCKS
THAT
THE
ONLINE
ALGORITHM
ASSIGNED
BOXES
TO
EARLIER
DUE
MONDAY
APRIL
CONSIDER
THE
PAGING
PROBLEM
CONSIDER
THE
FOLLOWING
RANDOMIZED
ONLINE
ALGORITHM
ALGORITHM
DESCRIPTION
EACH
PAGE
P
HAS
AN
ASSOCIATED
BIT
DENOTING
WHETHER
THE
PAGE
IS
FRESH
OR
STALE
IF
REQUESTED
PAGE
P
IN
FAST
MEMORY
THEN
P
ASSOCIATED
BIT
IS
SET
TO
FRESH
IF
THE
REQUESTED
PAGE
P
IS
NOT
IN
FAST
MEMORY
THEN
A
STALE
PAGE
IS
SELECTED
UNIFORMLY
AT
RANDOM
FROM
THE
STALE
PAGES
IN
FAST
MEMORY
AND
EJECTED
AND
P
ASSOCIATED
BIT
IS
SET
TO
FRESH
IF
THE
REQUEST
PAGE
P
IS
NOT
IN
FAST
MEMORY
AND
ALL
PAGES
IN
FAST
MEMORY
ARE
FRESH
THEN
MAKE
ALL
PAGES
IN
FAST
MEMORY
STALE
SELECT
A
STALE
PAGE
UNIFORMLY
AT
RANDOM
FROM
THE
STALE
PAGES
IN
FAST
MEMORY
TO
EVICT
AND
P
ASSOCIATED
BIT
IS
SET
TO
FRESH
SHOW
THAT
THIS
ALGORITHM
IS
O
LOG
K
COMPETITIVE
APPROXIMATE
USING
THE
FOLLOWING
STRAT
EGY
RECALL
K
IS
THE
SIZE
OF
THE
FAST
MEMORY
PARTITION
THE
INPUT
SEQUENCE
INTO
CONSEC
UTIVE
SUBSEQUENCES
PHASES
WHERE
THERE
ARE
EXACTLY
K
DISTINCT
PAGES
REQUESTED
IN
EACH
SUBSEQUENCE
PHASE
THE
PHASE
BREAKS
ARE
WHEN
ALL
PAGES
IN
FAST
MEMORY
ARE
MADE
STALE
LET
MI
BE
THE
NUMBER
OF
PAGES
REQUESTED
IN
PHASE
I
THAT
WERE
NOT
REQUESTED
IN
PHASE
I
P
A
SHOW
THAT
THE
OPTIMAL
NUMBER
OF
PAGE
FAULTS
IS
O
I
MI
B
SHOW
THAT
THE
EXPECTED
NUMBER
OF
PAGE
FAULTS
FOR
THE
RANDOMIZED
ALGORITHM
ON
THE
PAGE
REQUESTS
IN
PHASE
I
IS
O
MI
LOG
K
DUE
WEDNESDAY
APRIL
CONSIDER
AN
ONLINE
OR
APPROXIMATION
PROBLEM
WHERE
THERE
ARE
ONLY
NITELY
MANY
POS
SIBLE
ALGORITHMS
AND
NITELY
MANY
POSSIBLE
INPUTS
WE
GENERALIZE
YAO
TECHNIQUE
TO
APPROXIMATION
RATIOS
THE
CORRECT
ANSWER
IS
YES
TO
THREE
OF
THE
FOLLOWING
FOUR
QUES
TIONS
AND
THE
CORRECT
ANSWER
IS
NO
FOR
THE
REMAINING
QUESTION
IDENTIFY
THE
THREE
QUESTIONS
WHERE
THE
ANSWER
IS
YES
AND
GIVE
A
PROOF
THAT
THE
ANSWER
IS
YES
HINT
FIRST
ASSUME
THAT
THERE
ARE
TWO
POSSIBLE
DETERMINISTIC
ALGORITHMS
AND
TWO
POS
SIBLE
INPUTS
THE
GENERAL
PROOF
IS
MORE
OR
LESS
THE
SAME
BUT
IT
MAY
BE
EASIER
TO
THINK
ABOUT
THIS
SPECIAL
CASE
A
ASSUME
THAT
THE
PROBLEM
IS
A
MINIMIZATION
PROBLEM
I
ASSUME
THAT
YOU
HAVE
AN
INPUT
DISTRIBUTION
I
SUCH
THAT
FOR
ALL
DETERMINISTIC
ALGORITHMS
A
IT
IS
THE
CASE
THAT
E
A
I
E
OPT
I
C
CAN
YOU
LOGICALLY
CONCLUDE
THAT
THE
EXPECTED
COMPETITIVE
RATIO
FOR
EVERY
RANDOMIZED
ALGORITHM
IS
AT
LEAST
C
II
ASSUME
THAT
YOU
HAVE
AN
INPUT
DISTRIBUTION
I
SUCH
THAT
FOR
ALL
DETERMINISTIC
ALGORITHMS
A
IT
IS
THE
CASE
THAT
E
A
I
OPT
I
C
CAN
YOU
LOGICALLY
CONCLUDE
THAT
THE
EXPECTED
COMPETITIVE
RATIO
FOR
EVERY
RANDOMIZED
ALGORITHM
IS
AT
LEAST
C
B
ASSUME
THAT
THE
PROBLEM
IS
A
MAXIMIZATION
PROBLEM
I
ASSUME
THAT
YOU
HAVE
AN
INPUT
DISTRIBUTION
I
SUCH
THAT
FOR
ALL
DETERMINISTIC
ALGORITHMS
A
IT
IS
THE
CASE
THAT
E
OPT
I
E
A
I
C
CAN
YOU
LOGICALLY
CONCLUDE
THAT
THE
EXPECTED
COMPETITIVE
RATIO
FOR
EVERY
RANDOMIZED
ALGORITHM
IS
AT
LEAST
C
II
ASSUME
THAT
YOU
HAVE
AN
INPUT
DISTRIBUTION
I
SUCH
THAT
FOR
ALL
DETERMINISTIC
ALGORITHMS
A
IT
IS
THE
CASE
THAT
E
OPT
I
A
I
C
CAN
YOU
LOGICALLY
CONCLUDE
THAT
THE
EXPECTED
COMPETITIVE
RATIO
FOR
EVERY
RANDOMIZED
ALGORITHM
IS
AT
LEAST
C
C
FOR
EXTRA
CREDIT
PROVE
THAT
THE
CORRECT
ANSWER
IS
NO
FOR
THE
REMAINING
QUESTION
THERE
IS
A
SIMPLE
EXAMPLE
BUT
THAT
DOES
NOT
MEAN
IT
IS
EASY
TO
ND
DUE
FRIDAY
APRIL
SHOW
THAT
THE
EXPECTED
COMPETITIVE
RATIO
FOR
EVERY
RANDOMIZED
PAGING
ALGORITHMS
IS
O
LOG
K
HINT
USE
YOUR
RESULTS
FROM
THE
PREVIOUS
PROBLEM
ASSUME
THAT
THE
NUMBER
OF
PAGES
IS
ONE
MORE
THAN
THE
SIZE
OF
FAST
MEMORY
DUE
MONDAY
APRIL
CONSIDER
THE
FOLLOWING
ONLINE
PROBLEM
THERE
ARE
TWO
TAXIS
ON
A
LINE
THAT
INITIALLY
START
AT
THE
ORIGIN
AT
POSITIVE
INTEGER
TIME
T
A
REQUEST
POINT
HT
ON
THE
LINE
ARRIVES
IN
RESPONSE
EACH
TAXI
CAN
MOVE
TO
A
DI
ERENT
LOCATION
ON
THE
LINE
OR
STAY
PUT
AT
ITS
CURRENT
POINT
THE
PATH
TRAVELED
BY
AT
LEAST
ONE
OF
THE
TWO
TAXIS
MUCH
CROSS
HT
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
TOTAL
MOVEMENT
OF
THE
TAXIS
A
AS
A
WARMUP
SHOW
THAT
IF
THERE
IS
A
C
COMPETITIVE
ALGORITHM
A
FOR
THIS
PROBLEM
THEN
THERE
IS
A
C
COMPETITIVE
ALGORITHM
B
THAT
ONLY
MOVES
ONE
TAXI
IN
RESPONSE
TO
EACH
REQUEST
AND
THAT
ONE
TAXI
MOVES
DIRECTLY
FROM
ITS
POSITION
TO
THE
REQUEST
B
GIVE
AN
ADVERSARIAL
STRATEGY
TO
SHOW
THAT
THE
COMPETITIVE
RATIO
OF
EVERY
DETER
MINISTIC
ALGORITHM
IS
AT
LEAST
HINT
COME
UP
WITH
A
REQUEST
SEQUENCE
THAT
MAKES
IT
HARD
TO
DECIDE
IF
ONE
OF
THE
TAXIS
SHOULD
MOVE
C
CONSIDER
THE
FOLLOWING
ALGORITHM
A
IF
BOTH
TAXIS
ARE
TO
THE
LEFT
OF
HT
THEN
A
RIGHTMOST
TAXI
MOVES
TO
HT
IF
BOTH
TAXIS
ARE
TO
THE
RIGHT
OF
HT
THEN
A
LEFTMOST
TAXI
MOVES
TO
HT
IF
HT
IS
BETWEEN
THE
TWO
TAXIS
THEN
BOTH
TAXIS
MOVE
TOWARD
HT
AT
THE
SAME
RATE
UNTIL
ONE
OF
THE
TAXIS
REACHES
HT
AT
WHICH
POINT
BOTH
TAXIS
STOP
MOVING
SHOW
THAT
THIS
ALGORITHM
IS
COMPETITIVE
USING
THE
FOLLOWING
POTENTIAL
FUNCTION
F
TWICE
THE
DISTANCE
BETWEEN
THE
LEFTMOST
TAXI
FOR
A
AND
THE
LEFTMOST
TAXI
FOR
OPTIMAL
PLUS
TWICE
THE
DISTANCE
BETWEEN
THE
RIGHTMOST
TAXI
FOR
A
AND
THE
RIGHTMOST
TAXI
FOR
OPTIMAL
PLUS
THE
DISTANCE
BETWEEN
THE
LEFTMOST
AND
THE
RIGHTMOST
TAXIS
FOR
A
SO
YOU
NEED
TO
SHOW
THAT
FOR
EACH
REQUEST
THE
COST
TO
A
THE
CHANGE
IN
THE
POTENTIAL
F
IS
AT
MOST
TIMES
THE
COST
TO
OPTIMAL
DUE
WEDNESDAY
APRIL
DEFNITIONS
AN
INSTANCE
CONSISTS
OF
N
JOBS
WHERE
JOB
I
HASA
RELEASE
TIME
RI
IMPLICITLY
EACHJOBHASAWORK
A
WEIGHT
OF
WE
ASSUME
WITHOUT
LOSS
OF
GENERALITY
THAT
RN
AN
ONLINE
SCHEDULER
IS
NOT
AWARE
OF
JOB
I
UNTIL
TIME
RI
AND
AT
TIME
RI
LEARNS
YI
FOR
EACH
TIME
A
SCHEDULE
SPECIFES
A
JOB
TO
BE
RUN
AND
ASPEEDAT
WHICHTHEJOBIS
RUN
AJOB
I
COMPLETES
ONCE
UNIT
OF
WORK
HAS
BEEN
PERFORMED
ON
I
THE
SPEED
Y
IS
THE
RATE
AT
WHICH
WORK
IS
COMPLETED
A
JOB
WITH
WORK
Y
RUN
AT
A
CONSTANT
SPEED
COMPLETES
IN
SECONDS
EVERY
NONNEGATIVE
REAL
NUMBER
IS
AN
ALLOWABLE
SPEED
THE
POWER
CONSUMED
WHEN
RUNNING
AT
SPEED
IS
THE
ENERGY
USEDISPOWER
INTEGRATEDOVER
TIME
WE
ASSUME
THAT
PREEMPTIONIS
ALLOWED
THATIS
AJOBMAYBE
SUSPENDED
AND
LATER
RESTARTED
FROM
THE
POINT
OF
SUSPENSION
AJOB
IS
ACTIVE
AT
TIME
T
IF
IT
HAS
BEEN
RELEASED
BUT
NOT
COMPLETED
AT
TIMET
LET
X
BE
AN
ARBITRARY
ALGORITHM
LET
WX
T
DENOTE
THE
AGGREGATE
FRACTIONAL
WEIGHT
OF
THE
ACTIVE
JOBS
AT
TIME
T
FOR
ALGORITHM
X
SO
FOREXAMPLE
IFAJOB
I
IS
COMPLETED
AT
TIME
T
THEN
ITS
FRACTIONAL
WEIGHT
AT
TIME
T
IS
LET
SX
T
BE
THE
SPEED
AT
TIME
RT
FOR
ALGORITHM
X
AND
LET
PX
T
SX
T
BE
THE
POWER
CONSUMED
T
AT
TIME
T
BY
ALGORITHM
X
LET
EX
T
K
DK
BE
THE
ENERGY
SPENT
UP
UNTIL
TIME
T
BY
ALGORITHM
A
R
K
PX
T
LET
WX
T
K
DK
BE
THE
FRACTIONAL
WEIGHTED
FOW
UP
UNTIL
TIME
T
FOR
ALGORITHM
X
OUR
K
WXOBJECTIVE
FUNCTION
COMBINES
FOW
AND
ENERGY
AND
WE
LET
GX
T
WX
T
EX
T
BE
THE
FRACTIONAL
WEIGHTED
FOW
AND
ENERGY
UP
UNTIL
TIME
T
FOR
ALGORITHM
X
LET
EX
EX
WX
WX
GX
GX
BE
THE
ENERGY
FRACTIONAL
WEIGHTED
FOW
AND
FRACTIONAL
WEIGHTED
FOW
PLUS
ENERGY
RESPECTIVELY
FOR
ALGORITHM
X
WEUSEOPTTO
DENOTETHEOFFINEADVERSARY
AND
SUBSCRIPTAVARIABLEBY
O
TO
DENOTE
THE
VALUE
OF
A
VARIABLE
FOR
THE
ADVERSARY
SO
WO
IS
THE
FRACTIONAL
WEIGHTED
FOW
FOR
THE
ADVERSARY
AMORTIZED
LOCAL
COMPETITIVENESS
A
COMMON
NOTION
TO
MEASURE
AN
ON
LINE
SCHEDULING
ALGORITHM
IS
LOCAL
COMPETITIVENESS
MEANING
ROUGHLY
THAT
THE
ALGORITHM
IS
COMPETITIVE
AT
ALL
TIMES
DURING
THE
EXECUTION
LOCAL
COMPETITIVENESS
IS
GENERALLY
NOT
ACHIEVABLE
IN
SPEED
SCALING
PROBLEMS
BECAUSE
THE
ADVERSARY
MAY
SPEND
ESSENTIALLY
ALL
OF
ITS
ENERGY
IN
SOME
SMALL
PERIOD
OF
TIME
MAKING
IT
IMPOSSIBLE
FOR
ANYONLINE
ALGORITHM
TO
BE
LOCALLY
COMPETITIVE
AT
THAT
TIME
THUS
WE
WILL
ANALYZE
OUR
ALGORITHMS
USING
AMORTIZED
LOCAL
COMPETITIVENESS
WHICH
WE
NOW
DEFNE
LET
X
BE
AN
ARBITRARY
ONLINE
SCHEDULING
ALGORITHM
AND
H
AN
ARBITRARY
OBJECTIVE
FUNCTION
LET
DH
T
BE
THE
RATE
DT
OF
INCREASE
OF
THE
OBJECTIVE
H
AT
TIME
T
THE
ONLINE
ALGORITHM
X
IS
AMORTIZED
LOCALLY
COMPETITIVE
WITH
POTENTIAL
FUNCTION
F
T
FOR
OBJECTIVE
FUNCTION
H
IF
THE
FOLLOWING
TWO
CONDITIONS
HOLD
BOUNDARY
CONDITION
F
IS
INITIALLY
AND
AND
FNALLY
NONNEGATIVE
THAT
IS
F
AND
THERE
EXISTS
SOME
TIME
SUCH
THAT
FOR
ALL
T
IT
IS
THE
CASE
THAT
F
T
GENERAL
CONDITION
FOR
ALL
TIMEST
DHX
T
DHO
T
DF
T
DT
DTDT
WE
BREAK
THE
GENERAL
CONDITION
INTO
THREE
CASES
RUNNING
CONDITION
FOR
ALL
TIMEST
WHEN
NO
JOB
ARRIVES
HOLDS
JOB
ARRIVAL
CONDITION
F
DOES
NOT
INCREASE
WHEN
A
NEW
JOB
ARRIVES
COMPLETION
CONDITION
F
DOES
NOT
INCREASE
WHEN
EITHER
THE
ONLINE
ALGORITHM
OR
THE
ADVERSARY
COMPLETE
A
JOB
OBSERVE
THAT
WHEN
F
T
IS
IDENTICALLY
ZERO
WE
HAVE
ORDINARY
LOCAL
COMPETITIVENESS
IT
IS
WELL
KNOWN
THAT
AMORTIZED
LOCAL
COMPETITIVENESS
IMPLIES
THAT
WHEN
THE
ALGORITHM
COMPLETES
THE
TOTAL
COST
OF
THE
ONLINE
ALGORITHM
IS
AT
MOST
TIMES
THE
TOTAL
COST
OF
THE
OPTIMAL
OFFINE
ALGORITHM
IF
ONLINE
ALGORITHM
X
IS
AMORTIZED
LOCALLY
COMPETITIVE
WITH
POTENTIAL
FUNCTION
F
T
FOR
OBJEC
TIVE
FUNCTION
H
THEN
HX
HO
PROOF
LET
BE
THE
EVENTS
THAT
EITHER
A
JOB
IS
RELEASED
THE
ONLINE
ALGORITHM
X
COMPLETES
A
JOB
OR
THE
ADVERSARY
COMPLETES
A
JOB
LET
F
TI
DENOTETHE
CHANGEIN
POTENTIALIN
RESPONSETOEVENT
TI
LET
AND
INTEGRATING
OVERTIME
WEGETTHAT
X
HX
F
TI
HO
I
BYTHE
JOB
ARRIVAL
CONDITION
AND
THE
COMPLETION
CONDITION
WE
CAN
CONCLUDE
THATHX
F
F
HO
AND
FNALLY
BY
THE
BOUNDARY
CONDITION
WE
CAN
CONCLUDE
THAT
HX
HO
NOW
CONSIDER
THE
CASE
THAT
THE
OBJECTIVE
FUNCTION
IS
G
THE
FRACTIONAL
WEIGHTED
FOW
PLUS
ENERGY
THEN
DG
T
W
T
P
T
W
T
T
AND
EQUIVALENT
TO
DT
DF
T
WX
T
SX
T
WO
T
SO
T
DT
FOR
OUR
PURPOSES
WE
WILL
ALWAYS
CONSIDER
THE
ALGORITHM
A
WHERE
SA
T
WA
T
THUS
IS
EQUIVALENT
TO
DF
T
T
WO
T
SO
T
DT
IF
WO
T
SO
T
THEN
DF
T
DT
THUS
WE
ARE
ESSENTIALLY
REQUIRED
TO
PICK
A
POTENTIAL
FUNCTION
SATISFYING
EQUATION
NOTE
THAT
IF
WO
T
SO
T
THEN
IT
MUST
BE
THE
CASE
THAT
THE
ADVERSARY
HAS
NO
ACTIVE
JOBS
AT
TIME
T
AND
WO
T
SO
T
IF
WO
T
T
THEN
CANBE
REWRITTEN
AS
DF
T
T
DT
WO
T
SO
T
SINCE
WEWANT
TO
CHOOSE
TO
BE
AS
SMALL
AS
POSSIBLE
WHILE
STILL
SATISFYING
INEQUALITY
THE
RIGHT
SIDE
OF
THIS
INEQUALITY
WILL
DENOTE
OUR
COMPETITIVE
RATIO
THE
RESULT
WE
FRST
SHOW
THAT
THE
SPEED
SCALING
ALGORITHMA
WHERE
SA
T
WA
T
IS
COMPETITIVE
FOR
THE
OBJECTIVE
FUNCTION
OF
FRACTIONAL
FOW
TIME
PLUS
ENERGY
WE
FRST
RECALL
THE
FOLLOWING
CLASSIC
INEQUALITY
AND
ITS
COROLLARY
YOUNG
INEQUALITY
LET
F
BE
A
REAL
VALUED
CONTINUOUS
AND
STRICTLY
INCREASING
FUNCTION
ON
C
WITH
C
IF
F
AND
A
B
SUCHTHAT
A
C
AND
B
F
C
THEN
ZZ
B
A
F
X
DX
F
X
DX
AB
WHERE
F
IS
THE
INVERSE
FUNCTION
OF
F
FOR
POSITIVE
REALSA
B

P
AND
Q
SUCHTHAT
P
Q
THE
FOLLOWING
HOLDS
P
Q
P
BQ

AB
P
Q
NOTE
THAT
FOR

THISIS
THE
CLASSICH
OLDER
INEQUALITY
WE
NOW
PROVE
THE
MAIN
RESULT
OF
THIS
SECTION
THE
SPEED
SCALING
ALGORITHM
A
WHERE
SA
T
WA
T
A
IS
COMPETITIVE
WITH
RESPECT
TO
THE
OBJECTIVE
G
OF
FRACTIONAL
FOW
PLUS
ENERGY
PROOF
WE
PROVE
THAT
ALGORITHMA
IS
AMORTIZED
LOCALLY
COMPETITIVE
USING
THE
POTENTIAL
FUNCTION
F
T
MAX
WA
T
WO
T
WE
FRST
NEED
TO
VERIFY
THE
BOUNDARY
CONDITION
CLEARLY
F
AS
WA
WO
AND
F
T
IS
ALWAYS
NON
NEGATIVE
F
SATISFESTHEJOB
COMPLETION
CONDITIONSINCETHE
FRACTIONALWEIGHTOFAJOB
APPROACHES
ZERO
CONTINUOUSLY
AS
THE
JOB
NEARS
COMPLETION
AND
THERE
IS
NO
DISCONTINUITY
IN
WA
T
OR
WO
T
WHEN
A
JOB
COMPLETES
F
SATISFES
THE
JOB
ARRIVAL
CONDITION
SINCE
BOTH
WA
T
AND
WO
T
INCREASE
WHEN
A
NEW
JOB
ARRIVES
WE
ARE
LEFT
TO
ESTABLISH
THE
RUNNING
CONDITION
WE
NOW
BREAK
THE
ARGUMENT
INTO
TWO
CASES
IN
THE
FRST
CASE
ASSUME
THAT
THAT
WA
T
WO
T
THIS
CASE
IS
SIMPLER
SINCE
THE
OFFINE
ADVERSARY
HAS
LARGE
FRACTIONAL
WEIGHT
HERE
F
T
AND
DF
T
BY
THE
DEFNITION
OF
F
SINCE
WE
KNOW
THAT
WA
T
WO
T
IT
MUST
BE
DT
THE
CASE
THAT
WO
T
T
ANDTHENTHATTHERIGHTSIDEOF
WE
NOW
TURN
TO
THE
INTERESTING
CASE
THAT
WA
T
WO
T
FOR
NOTATIONAL
EASE
WE
WILL
DROP
THE
TIME
T
FROM
THE
NOTATION
SINCE
ALL
VARIABLES
ARE
UNDERSTOOD
TO
BE
FUNCTIONS
OF
T
WE
CONSIDER
DF
DT
D
WA
WO
D
WA
WO
WA
WO
DT
DT
DT
SINCE
JOBS
HAVE
UNIT
DENSITY
THE
RATE
AT
WHICH
THE
FRACTIONAL
WEIGHT
DECREASES
IS
EXACTLY
THE
RATE
AT
WHICH
DW
UNFNISHED
WORK
DECREASES
WHICH
IS
JUST
THE
SPEED
OF
THE
ALGORITHM
THUS
MOREOVER
SINCE
DT
SA
WA
BY
THE
DEFNITION
OF
A
WRITTEN
AS
DF
WA
WO
SA
SO
WA
WO
W
SO
A
DT
SINCE
WA
WA
WO
IT
FOLLOWS
THAT
WA
WA
WO
AND
THAT
DF
WA
WO
WA
WOSO
DT
APPLYINGYOUNG
INEQUALITY
CF
WITH

A
P
B
WA
WO
AND
Q
WE
OBTAIN
THAT
WA
WOSO
WA
WO
THUS
WRITTEN
AS
O
DF
WA
WO
WA
WO
WA
WO
OO
DT
IF
WO
THEN
IMPLIES
THAT
AND
HOLDS
IF
WO
THEN
ODT
O
PLUGGING
THE
RIGHT
SIDEOF
WE
OBTAINA
BOUND
ON
THE
COMPETITIVE
RATIOOF
LECTURE
FIXED
PARAMETER
ALGORITHMS
SPRING
LECTURE
FIXED
PARAMETER
ALGORITHMS
VERTEX
COVER
FIXED
PARAMETER
TRACTABILITY
KERNELIZATION
CONNECTION
TO
APPROXIMATION
FIXED
PARAMETER
ALGORITHMS
FIXED
PARAMETER
ALGORITHMS
ARE
AN
ALTERNATIVE
WAY
TO
DEAL
WITH
NP
HARD
PROBLEMS
INSTEAD
OF
APPROXIMATION
ALGORITHMS
THERE
ARE
THREE
GENERAL
DESIRED
FEATURES
OF
AN
ALGORITHM
SOLVE
NP
HARD
PROBLEMS
RUN
IN
POLYNOMIAL
TIME
FAST
GET
EXACT
SOLUTIONS
IN
GENERAL
UNLESS
P
NP
AN
ALGORITHM
CAN
HAVE
TWO
OF
THESE
THREE
FEATURES
BUT
NOT
ALL
THREE
AN
ALGORITHM
THAT
HAS
FEATURES
AND
IS
AN
ALGORITHM
IN
P
POLY
TIME
EXACT
AN
APPROXIMATION
ALGORITHM
HAS
FEATURES
AND
IT
SOLVES
HARD
PROBLEMS
AND
IT
RUNS
FAST
BUT
IT
DOES
NOT
GIVE
EXACT
SOLUTIONS
FIXED
PARAMETER
ALGORITHMS
WILL
HAVE
FEATURES
AND
THEY
WILL
SOLVE
HARD
PROBLEMS
AND
GIVE
EXACT
SOLUTIONS
BUT
THEY
WILL
NOT
RUN
VERY
FAST
IDEA
THE
IDEA
IS
TO
AIM
FOR
AN
EXACT
ALGORITHM
BUT
ISOLATE
EXPONENTIAL
TERMS
TO
A
SPECI
C
PARAMETER
WHEN
THE
VALUE
OF
THIS
PARAMETER
IS
SMALL
THE
ALGORITHM
GETS
FAST
INSTANCES
HOPEFULLY
THIS
PARAMETER
WILL
BE
SMALL
IN
PRACTICE
PARAMETER
A
PARAMETER
IS
A
NONNEGATIVE
INTEGER
K
X
WHERE
X
IS
THE
PROBLEM
INPUT
TYPICALLY
THE
PARAMETER
IS
A
NATURAL
PROPERTY
OF
THE
PROBLEM
SOME
K
IN
INPUT
IT
MAY
NOT
NECESSARILY
BE
E
CIENTLY
COMPUTABLE
E
G
OPT
PARAMETERIZED
PROBLEM
A
PARAMETERIZED
PROBLEM
IS
SIMPLY
THE
PROBLEM
PLUS
THE
PARAMETER
OR
THE
PROBLEM
AS
SEEN
WITH
RESPECT
TO
THE
PARAMETER
THERE
ARE
POTENTIALLY
MANY
INTERESTING
PARAMETERIZATIONS
FOR
ANY
GIVEN
PROBLEM
LECTURE
FIXED
PARAMETER
ALGORITHMS
SPRING
GOAL
THE
GOAL
OF
XED
PARAMETER
ALGORITHMS
IS
TO
HAVE
AN
ALGORITHM
THAT
IS
POLY
NOMIAL
IN
THE
PROBLEM
SIZE
N
BUT
POSSIBLY
EXPONENTIAL
IN
THE
PARAMETER
K
AND
STILL
GET
AN
EXACT
SOLUTION
K
VERTEX
COVER
GIVEN
A
GRAPH
G
V
E
AND
A
NONNEGATIVE
INTEGER
K
IS
THERE
A
SET
V
OF
VERTICES
OF
SIZE
AT
MOST
K
K
THAT
COVERS
ALL
EDGES
THIS
IS
A
DECISION
PROBLEM
FOR
VERTEX
COVER
AND
IS
ALSO
NP
HARD
WE
WILL
USE
K
AS
THE
PARAMETER
TO
DEVELOP
A
XED
PARAMETER
ALGORITHM
FOR
K
VERTEXCOVER
NOTETHATWECAN
HAVE
K
V
AS
THE
GURE
BELOW
SHOWS
BRUTE
FORCE
SOLUTION
BAD
VVV
V
TRYALL
SETS
OF
K
VERTICES
CAN
SKIP
ALL
TERMS
SMALLER
THAN
KK
BECAUSE
BIGGER
SETS
HAVE
MORE
COVERAGE
TESTING
COVERAGE
TAKES
O
M
TIME
WHERE
M
IS
THE
NUMBER
OF
EDGES
THEREFORE
THE
TOTAL
RUNTIME
IS
O
V
K
E
IT
IS
POLYNOMIAL
FOR
XED
K
BUT
NOT
THE
SAME
POLYNOMIAL
FOR
ALL
K
IT
IS
INE
CIENT
IN
MOST
CASES
HENCE
WE
DE
NE
NF
K
TO
BE
BAD
WHERE
N
V
E
IS
THE
INPUT
SIZE
BOUNDED
SEARCH
TREE
ALGORITHM
GOOD
THIS
IS
A
GENERAL
TECHNIQUE
USED
TO
IMPROVE
BRUTE
FORCE
SEARCHES
IT
WORKS
AS
FOLLOWS
PICK
ARBITRARY
EDGE
E
U
V
WE
KNOW
THAT
EITHER
U
OR
V
OR
BOTH
BUT
DON
T
KNOW
WHICH
GUESS
WHICH
ONE
TRY
BOTH
POSSIBILITIES
ADD
U
TO
DELETE
U
AND
INCIDENT
EDGES
FROM
G
AND
RECURSE
WITH
K
K
DO
THE
SAME
BUT
WITH
V
INSTEAD
OF
U
RETURN
THE
OR
OF
THE
TWO
OUTCOMES
LECTURE
FIXED
PARAMETER
ALGORITHMS
SPRING
THIS
IS
LIKE
GUESSING
IN
DYNAMIC
PROGRAMMING
BUT
MEMOIZATION
DOESN
T
HELP
HERE
THE
RECURSION
TREE
LOOKS
LIKE
THE
FOLLOWING
AT
A
LEAF
K
RETURN
YES
IF
E
ALL
EDGES
COVERED
IT
TAKES
O
V
TIME
TO
DELETE
U
OR
V
THEREFORE
THIS
HAS
A
TOTAL
RUNTIME
OF
V
O
V
FOR
XED
K
DEGREE
OF
POLYNOMIAL
IS
INDEPENDENT
OF
K
ALSO
POLYNOMIAL
FOR
K
O
LG
V
PRACTICAL
FOR
E
G
K
HENCE
WE
DE
NE
F
K
NO
TO
BE
GOOD
FIXED
PARAMETER
TRACTABILITY
A
PARAMETERIZED
PROBLEM
IS
XED
PARAMETER
TRACTABLE
FPT
IF
THERE
IS
AN
ALGORITHM
WITH
RUNNING
TIME
F
K
NO
SUCH
THAT
F
N
N
NON
NEGATIVE
AND
K
IS
THE
PARAMETER
AND
THE
O
DEGREE
OF
THE
POLYNOMIAL
IS
INDEPENDENT
OF
K
AND
N
O
QUESTION
WHY
F
K
NO
AND
NOT
F
K
N
T
CC
THEOREM
F
K
NALGORITHM
F
K
N
PROOF
T
C
TRIVIAL
ASSUMING
F
K
AND
NARE
C
F
K
C
IF
N
F
K
THEN
F
K
N
LECTURE
FIXED
PARAMETER
ALGORITHMS
SPRING
CC
IF
F
K
N
THEN
F
K
N
N
CC
F
K
C
NC
C
THEREFORE
F
K
N
MAX
F
K
C
N
F
K
NT
D
ALTERNATIVELY
SINCE
XY
CAN
JUST
MAKE
F
K
F
K
AND
C
EXAMPLE
O
N
O
KERNELIZATION
KERNELIZATION
IS
A
SIMPLIFYING
SELF
REDUCTION
IT
IS
A
POLYNOMIAL
TIME
ALGORITHM
THAT
CONVERTS
AN
INPUT
X
K
INTOA
SMALL
AND
EQUIVALENT
INPUT
X
K
HERE
SMALL
MEANS
X
F
K
AND
EQUIVALENT
MEANS
THE
ANSWER
TO
X
IS
THESAMEASTHE
ANSWER
TO
X
THEOREM
A
PROBLEM
IS
FPT
A
KERNELIZATION
PROOF
KERNELIZE
N
F
K
RUN
ANY
NITE
G
N
ALGORITHM
TOTALS
TO
NO
G
F
K
TIME
LET
A
BE
AN
F
K
NC
ALGORITHM
THEN
ASSUMING
K
IS
KNOWN
IF
N
F
K
IT
ALREADY
KERNELIZED
IF
F
K
N
THEN
CC
RUN
A
F
K
N
NTIME
OUTPUT
O
SIZED
YES
NO
INSTANCE
AS
APPROPRIATE
TO
KERNELIZE
IF
K
IS
UNKNOWN
RUN
A
FOR
NC
TIME
AND
IF
IT
IS
STILL
NOT
DONE
WE
KNOW
IT
IS
ALREADY
KERNELIZED
SO
WE
KNOW
EXPONENTIAL
KERNEL
EXISTS
RECENT
WORK
AIMS
TO
ND
POLYNOMIAL
EVEN
LINEAR
KERNELS
WHEN
POSSIBLE
POLYNOMIAL
KERNEL
FOR
K
VERTEX
COVER
TO
CREATE
A
KERNEL
FOR
K
VERTEX
COVER
THE
ALGORITHM
FOLLOWS
THE
FOLLOWING
STEPS
MAKE
GRAPH
SIMPLE
BY
REMOVING
ALL
SELF
LOOPS
AND
MULTI
EDGES
ANY
VERTEX
OF
DEGREE
K
MUST
BE
IN
THE
COVER
ELSE
WOULD
NEED
TO
ADD
K
VERTICES
TO
COVER
INCIDENT
EDGES
LECTURE
FIXED
PARAMETER
ALGORITHMS
SPRING
REMOVE
SUCH
VERTICES
AND
INCIDENT
EDGES
ONE
AT
A
TIME
DECREASING
K
ACCORD
INGLY
REMAINING
GRAPH
HAS
MAXIMUM
DEGREE
K
EACH
REMAINING
VERTEX
COVERS
K
EDGES
IF
THE
NUMBER
OF
REMAINING
EDGES
IS
K
ANSWER
NO
AND
OUTPUT
CANONICAL
NO
INSTANCE
ELSE
E
REMOVE
ALL
ISOLATED
VERTICES
DEGREE
VERTICES
NOW
V
THE
INPUT
HAS
BEEN
REDUCED
TO
INSTANCE
V
E
OFSIZE
O
THE
RUNTIME
OF
THE
KERNELIZATION
ALGORITHM
IS
NAIVELY
O
VE
O
V
E
WITHMORE
WORK
AFTER
THIS
WE
CAN
APPLY
EITHER
A
BRUTE
FORCE
ALGORITHM
ON
THE
KERNEL
WHICH
YIELDS
AN
OVERALL
RUNTIME
O
V
E
O
V
E
ORWECAN
APPLY
A
BOUNDED
SEARCH
TREE
SOLUTION
WHICH
YIELDS
A
RUNTIME
OF
O
V
E
THE
BEST
ALGORITHM
TO
DATE
O
KV
BY
CHEN
KANJ
XIA
TCS
CONNECTION
TO
APPROXIMATION
ALGORITHMS
TAKE
AN
OPTIMIZATION
PROBLEM
INTEGRAL
OPT
AND
CONSIDER
ITS
ASSOCIATED
DECISION
PROBLEM
OPT
K
AND
PARAMETERIZE
BY
K
THEOREM
OPTIMIZATION
PROBLEM
HAS
EPTAS
EPTAS
E
CIENT
PTAS
F
NO
E
G
APPROXP
ARTITION
DECISION
PROBLEM
IS
FPT
PROOF
LIKE
FPTAS
PSEUDOPOLYNOMIAL
ALGORITHM
SAY
MAXIMIZATION
PROBLEM
AND
K
DECISION
RUN
EPTAS
WITH
T
K
IN
F
NO
TIME
RELATIVE
ERROR
K
K
ABSOLUTE
ERROR
K
LECTURE
FIXED
PARAMETER
ALGORITHMS
SPRING
SO
IF
WE
ND
A
SOLUTION
WITH
VALUE
K
THENOPT
K
K
K
INTEGRAL
OPT
K
YES
ELSE
OPT
K
D
ALSO
DECISION
PROBLEMS
ARE
EQUIVALENT
WITH
RESPECT
TO
FPT
CAN
USE
THIS
RELATION
TO
PROVE
THAT
EPTASS
DON
T
EXISTS
IN
SOME
CASES
TENTATIVE
COURSE
OUTLINE
TOPIC
INTRODUCTION
TO
ALGORITHM
ANALYSIS
AZDND
ASYMPTOTIC
NOTATION
READING
CHAPTERS
AND
OF
CLRS
READ
THE
APPENDIX
COVERING
MATHEMATICAL
BACKGROUND
IF
YOU
NEED
TO
PRINCIPLES
OF
ALGORITHM
ANALYSIS
ASYMPTOTIC
NOTATION
COMPARING
GROWTH
RATE
OF
FUNCTIONS
GROWTH
RATE
AS
A
MEASURE
OF
EFFICIENCY
OF
USE
OF
A
FASTER
PROCESSOR
TOPIC
BASIC
ANALYSIS
OF
ALGORITHMS
READING
CHAPTERS
AND
EXAMPLE
POLYNOMIAL
MULTIPLICATION
NAIVE
DIVIDE
AND
CONQUER
STRASSEN
ALGORITHM
FFT
ALGORITHM
LOOPS
AND
SUMS
SUM
OF
POLYNOMIALLY
UPPER
BOUNDED
INCREASING
FUNCTION
SUM
OF
EXPONENTIALLY
LOWER
BOUNDED
FUNCTION
RELATION
OF
SUM
AND
INTEGRAL
RECURSION
AND
RECURRENCES
DRAWING
THE
RECURSION
TREE
AND
SUMMING
LEVEL
BY
LEVEL
MASTER
THEOREM
INDUCTION
INCLUDING
STRENGTHENING
THE
INDUCTION
HYPOTHESIS
TOPIC
PROBLEM
COMPLEXITY
INFORMATION
THEORETIC
AND
ADVERSARIAL
LOWER
BOUNDS
READING
CHAPTER
TIME
COMPLEXITY
OF
A
PROBLEM
EXAMPLE
SEARCHING
LOWER
BOUND
EXAMPLE
SORTING
LOWER
BOUND
EXAMPLE
ELEMENT
UNIQUENESS
LOWER
BOUND
EXAMPLE
LOWER
BOUND
FOR
FIND
THE
MAXIMUM
EXAMPLE
LOWER
BOUND
FOR
COMPUTING
SMALLEST
AND
LARGEST
NUMBER
NOT
IN
THE
BOOK
TOPIC
AVERAGECASE
ANALYSIS
RANDOMIZED
ALGORITHMS
AND
BOUNDING
TAILS
OF
DISTRIBUTIONS
READING
CHAPTERS
AND
AND
HANDOUT
ON
RANDOMIZED
ALGORITHMS
LINEARITY
OF
EXPECTATIONS
EXAMPLE
HIRING
PROBLEM
EXAMPLE
QUICKSORT
EXPECTED
LINEAR
TIME
SELECTION
RANDOMLY
BUILT
SEARCH
TREES
EXAMPLE
EXPECTED
TIME
FOR
INSERT
IN
CLOSED
ADDRESSED
HASH
TABLE
EXAMPLE
EXPECTED
TIME
FOR
INSERT
IN
OPEN
ADDRESSED
HASH
TABLE
USING
UNIFORM
HASHING
EXAMPLE
UNIVERSAL
HASH
FUNCTIONS
EXAMPLE
RANDOMIZED
MONTECARLO
MINCUT
ALGORITHM
LAS
VEGAS
VS
MONTE
CARLO
ALGORITHMS
COURSE
OUTLINE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
SCHED
HTML
BOUNDING
TAILS
AND
UNION
BOUNDS
EXAMPLE
ANALYSIS
OF
STREAKS
IN
BERNOULLI
TRIALS
EXAMPLE
HIGH
CONFIDENCE
ANALYSIS
OF
QUICKSORT
EXPECTED
LINEAR
TIME
SELECTION
RANDOMLY
BUILT
SEARCH
TREES
BINOMIALLY
DISTRIBUTED
RANDOM
VARIABLE
AND
CHERNOFF
BOUNDS
YAO
TECHNIQUE
EXAMPLE
AVERAGE
CASE
INFORMATION
THEORETIC
LOWER
BOUND
FOR
SORTING
EXAMPLE
RANDOMIZED
LAS
VEGAS
LOWER
BOUND
FOR
SORTING
TOPIC
SINGLE
SOURCE
SHORTEST
PATH
ALGORITHMS
READING
CHAPTER
EXAMPLE
DIJKSTRA
GREEDY
AND
EXCHANGE
ARGUMENT
PROOF
OF
CORRECTNESS
EXAMPLE
BELLMANFORD
DYNAMIC
PROGRAMMING
EXAMPLE
LINEAR
TIME
ALGORITHM
FOR
DIRECTED
ACYCLIC
GRAPHS
TOPIC
NETWORK
FLOW
READING
CHAPTER
EXAMPLE
FORDFULKERSON
ALGORITHM
EXAMPLE
KARPEDMONDS
ALGORITHMS
POLYTIME
PSEUDO
POLYTIME
AND
STRONG
POLYTIME
EXAMPLE
PUSHRELABEL
ALGORITHM
SKIPPING
ON
FIRST
PASS
TOPIC
LINEAR
PROGRAMMING
READING
CHAPTER
EXAMPLE
WRITING
NETWORK
FLOW
AS
A
LINEAR
PROGRAM
EXAMPLE
WRITING
SHORTEST
PATH
AS
A
LINEAR
PROGRAM
SIMPLEX
GREEDY
ALGORITHM
VS
DIVIDE
AND
CONQUER
INTERIOR
POINT
METHODS
WEAK
DUALITY
COMPLEMENTARY
SLACKNESS
AND
STATEMENT
OF
STRONG
DUALITY
EXAMPLE
WRITING
THE
DIET
PROBLEM
AS
A
LINEAR
PROGRAM
AND
COMPUTING
ITS
DUAL
EXAMPLE
DUAL
OF
NETWORK
FLOW
EXAMPLE
DUAL
OF
THE
SHORTEST
PATH
PROBLEM
TOPIC
NPCOMPLETENESS
READ
CHAPTER
EXAMPLE
NPHARDNESS
OF
VERTEX
COVER
EXAMPLE
DYNAMIC
PROGRAM
FOR
SUBSET
SUM
AND
NPHARDNESS
OF
SUBSET
SUM
TOPIC
APPROXIMATION
ALGORITHMS
READING
CHAPTER
EXAMPLE
AND
APPROXIMATIONS
FOR
TRAVELING
SALESMAN
EXAMPLE
VERTEX
COVER
USING
MAXIMAL
MATCHING
LOWER
BOUND
EXAMPLE
MAXIMUM
WEIGHT
VERTEX
COVER
USING
LINEAR
PROGRAMMING
LOWER
BOUND
EXAMPLE
GREEDY
WEIGHTED
SET
COVER
USING
DUAL
FEASIBLE
SOLUTION
AS
A
LOWER
BOUND
COURSE
OUTLINE
HTTP
PEOPLE
CS
PITT
EDU
KIRK
SCHED
HTML
EXAMPLE
RANDOMIZED
APPROXIMATION
FOR
DERANDOMIZATION
USING
METHOD
OF
CONDITIONAL
EXPECTATIONS
EXAMPLE
FPTAS
FOR
KNAPSACK
SKIPPING
ON
FIRST
PASS
EXAMPLE
GAP
REDUCTION
FOR
TSP
WITHOUT
TRIANGLE
INEQUALITY
TO
PROVE
NONAPPROXIMATABILITY
TOPIC
FIXED
PARAMETER
TRACTABILITY
SKIPPING
ON
FIRST
PASS
READING
MIT
OPENCOURSEWARE
NOTES
LOCAL
COPY
EXAMPLE
KERNALIZATION
FOR
VERTEX
COVER
TOPIC
AMORTIZATION
AND
POTENTIAL
FUNCTIONS
READING
CHAPTER
EXAMPLE
MULTIPOP
EXAMPLE
COUNTING
IN
BINARY
EXAMPLE
DYNAMIC
TABLE
TOPIC
ONLINE
ALGORITHMS
READING
PAPER
EXAMPLE
PAGING
GENERAL
LOWER
BOUND
AND
RESOURCE
AUGMENTATION
ANALYSIS
OF
LRU
EXAMPLE
MOVE
TO
FRONT
FOR
LIST
UPDATE
AND
GENERAL
LOWER
BOUND
EXAMPLE
SPEED
SCALING
FOR
THE
OBJECTIVE
OF
FRACTIONAL
FLOW
PLUS
ENERGY
NOTES
SURVEY
PAPER
CHERNOFF
BOUND
FROM
WIKIPEDIA
THE
FREE
ENCYCLOPEDIA
IN
PROBABILITY
THEORY
THE
CHERNOFF
BOUND
NAMED
AFTER
HERMAN
CHERNOFF
BUT
DUE
TO
HERMAN
RUBIN
GIVES
EXPONENTIALLY
DECREASING
BOUNDS
ON
TAIL
DISTRIBUTIONS
OF
SUMS
OF
INDEPENDENT
RANDOM
VARIABLES
IT
IS
A
SHARPER
BOUND
THAN
THE
KNOWN
FIRST
OR
SECOND
MOMENT
BASED
TAIL
BOUNDS
SUCH
AS
MARKOV
INEQUALITY
OR
CHEBYSHEV
INEQUALITY
WHICH
ONLY
YIELD
POWERLAW
BOUNDS
ON
TAIL
DECAY
HOWEVER
THE
CHERNOFF
BOUND
REQUIRES
THAT
THE
VARIATES
BE
INDEPENDENT
A
CONDITION
THAT
NEITHER
THE
MARKOV
NOR
THE
CHEBYSHEV
INEQUALITIES
REQUIRE
IT
IS
RELATED
TO
THE
HISTORICALLY
PRIOR
BERNSTEIN
INEQUALITIES
AND
TO
HOEFFDING
INEQUALITY
CONTENTS
THE
GENERIC
BOUND
EXAMPLE
ADDITIVE
FORM
ABSOLUTE
ERROR
MULTIPLICATIVE
FORM
RELATIVE
ERROR
SPECIAL
CASES
APPLICATIONS
MATRIX
BOUND
THEOREM
WITHOUT
THE
DEPENDENCY
ON
THE
DIMENSIONS
SAMPLING
VARIANT
PROOFS
CHERNOFFHOEFFDING
THEOREM
ADDITIVE
FORM
MULTIPLICATIVE
FORM
SEE
ALSO
REFERENCES
ADDITIONAL
READING
THE
GENERIC
BOUND
THE
GENERIC
CHERNOFF
BOUND
FOR
A
RANDOM
VARIABLE
X
IS
ATTAINED
BY
APPLYING
MARKOV
INEQUALITY
TO
ETX
FOR
EVERY
WHEN
X
IS
THE
SUM
OF
N
RANDOM
VARIABLES
XN
WE
GET
FOR
ANY
T
IN
PARTICULAR
OPTIMIZING
OVER
T
AND
USING
THE
ASSUMPTION
THAT
XI
ARE
INDEPENDENT
WE
OBTAIN
CHERNOFF
BOUND
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
SIMILARLY
AND
SO
SPECIFIC
CHERNOFF
BOUNDS
ARE
ATTAINED
BY
CALCULATING
FOR
SPECIFIC
INSTANCES
OF
THE
BASIC
VARIABLES
EXAMPLE
LET
XN
BE
INDEPENDENT
BERNOULLI
RANDOM
VARIABLES
WHOSE
SUM
IS
X
EACH
HAVING
PROBABILITY
P
OF
BEING
EQUAL
TO
FOR
A
BERNOULLI
VARIABLE
SO
FOR
ANY
TAKING
AND
GIVES
AND
AND
THE
GENERIC
CHERNOFF
BOUND
GIVES
THE
PROBABILITY
OF
SIMULTANEOUS
OCCURRENCE
OF
MORE
THAN
N
OF
THE
EVENTS
XK
HAS
AN
EXACT
VALUE
A
LOWER
BOUND
ON
THIS
PROBABILITY
CAN
BE
CALCULATED
BASED
ON
CHERNOFF
INEQUALITY
INDEED
NOTICING
THAT

NP
WE
GET
BY
THE
MULTIPLICATIVE
FORM
OF
CHERNOFF
BOUND
SEE
BELOW
OR
COROLLARY
IN
SINCLAIR
CLASS
NOTES
CHERNOFF
BOUND
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
THIS
RESULT
ADMITS
VARIOUS
GENERALIZATIONS
AS
OUTLINED
BELOW
ONE
CAN
ENCOUNTER
MANY
FLAVOURS
OF
CHERNOFF
BOUNDS
THE
ORIGINAL
ADDITIVE
FORM
WHICH
GIVES
A
BOUND
ON
THE
ABSOLUTE
ERROR
OR
THE
MORE
PRACTICAL
MULTIPLICATIVE
FORM
WHICH
BOUNDS
THE
ERROR
RELATIVE
TO
THE
MEAN
ADDITIVE
FORM
ABSOLUTE
ERROR
THE
FOLLOWING
THEOREM
IS
DUE
TO
WASSILY
HOEFFDING
AND
HENCE
IS
CALLED
THE
CHERNOFFHOEFFDING
THEOREM
CHERNOFFHOEFFDING
THEOREM
SUPPOSE
XN
ARE
I
I
D
RANDOM
VARIABLES
TAKING
VALUES
IN
LET
P
E
XI
AND

THEN
WHERE
IS
THE
KULLBACK
LEIBLER
DIVERGENCE
BETWEEN
BERNOULLI
DISTRIBUTED
RANDOM
VARIABLES
WITH
PARAMETERS
X
AND
Y
RESPECTIVELY
IF
P
THEN
A
SIMPLER
BOUND
FOLLOWS
BY
RELAXING
THE
THEOREM
USING
D
P

P
WHICH
FOLLOWS
FROM
THE
CONVEXITY
OF
D
P

P
AND
THE
FACT
THAT
THIS
RESULT
IS
A
SPECIAL
CASE
OF
HOEFFDING
INEQUALITY
SOMETIMES
THE
BOUND
WHICH
IS
STRONGER
FOR
P
IS
ALSO
USED
MULTIPLICATIVE
FORM
RELATIVE
ERROR
MULTIPLICATIVE
CHERNOFF
BOUND
SUPPOSE
X
X
ARE
INDEPENDENT
RANDOM
VARIABLES
TAKING
VALUES
IN
CHERNOFF
BOUND
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
MULTIPLICATIVE
CHERNOFF
BOUND
SUPPOSE
XN
ARE
INDEPENDENT
RANDOM
VARIABLES
TAKING
VALUES
IN
LET
X
DENOTE
THEIR
SUM
AND
LET

E
X
DENOTE
THE
SUM
EXPECTED
VALUE
THEN
FOR
ANY

A
SIMILAR
PROOF
STRATEGY
CAN
BE
USED
TO
SHOW
THAT
THE
ABOVE
FORMULA
IS
OFTEN
UNWIELDY
IN
PRACTICE
SO
THE
FOLLOWING
LOOSER
BUT
MORE
CONVENIENT
BOUNDS
ARE
OFTEN
USED
SPECIAL
CASES
WE
CAN
OBTAIN
STRONGER
BOUNDS
USING
SIMPLER
PROOF
TECHNIQUES
FOR
SOME
SPECIAL
CASES
OF
SYMMETRIC
RANDOM
VARIABLES
SUPPOSE
XN
ARE
INDEPENDENT
RANDOM
VARIABLES
AND
LET
X
DENOTE
THEIR
SUM
IF
THEN
AND
THEREFORE
ALSO
IF
THEN
APPLICATIONS
CHERNOFF
BOUNDS
HAVE
VERY
USEFUL
APPLICATIONS
IN
SET
BALANCING
AND
PACKET
ROUTING
IN
SPARSE
NETWORKS
CHERNOFF
BOUND
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
THE
SET
BALANCING
PROBLEM
ARISES
WHILE
DESIGNING
STATISTICAL
EXPERIMENTS
TYPICALLY
WHILE
DESIGNING
A
STATISTICAL
EXPERIMENT
GIVEN
THE
FEATURES
OF
EACH
PARTICIPANT
IN
THE
EXPERIMENT
WE
NEED
TO
KNOW
HOW
TO
DIVIDE
THE
PARTICIPANTS
INTO
DISJOINT
GROUPS
SUCH
THAT
EACH
FEATURE
IS
ROUGHLY
AS
BALANCED
AS
POSSIBLE
BETWEEN
THE
TWO
GROUPS
REFER
TO
THIS
BOOK
SECTION
HTTPS
BOOKS
GOOGLE
COM
BOOKS
ID
PRINTSEC
FRONTCOVER
SOURCE
GBS
CAD
FOR
MORE
INFO
ON
THE
PROBLEM
CHERNOFF
BOUNDS
ARE
ALSO
USED
TO
OBTAIN
TIGHT
BOUNDS
FOR
PERMUTATION
ROUTING
PROBLEMS
WHICH
REDUCE
NETWORK
CONGESTION
WHILE
ROUTING
PACKETS
IN
SPARSE
NETWORKS
REFER
TO
THIS
BOOK
SECTION
HTTPS
BOOKS
GOOGLE
COM
BOOKS
I
D
PRINTSEC
FRONTCOVER
SOURCE
CAD
FOR
A
THOROUGH
TREATMENT
OF
THE
PROBLEM
CHERNOFF
BOUNDS
CAN
BE
EFFECTIVELY
USED
TO
EVALUATE
THE
ROBUSTNESS
LEVEL
OF
AN
APPLICATION
ALGORITHM
BY
EXPLORING
ITS
PERTURBATION
SPACE
WITH
RANDOMIZATION
THE
USE
OF
THE
CHERNOFF
BOUND
PERMITS
TO
ABANDON
THE
STRONG
AND
MOSTLY
UNREALISTICSMALL
PERTURBATION
HYPOTHESIS
THE
PERTURBATION
MAGNITUDE
IS
SMALL
THE
ROBUSTNESS
LEVEL
CAN
BE
IN
TURN
USED
EITHER
TO
VALIDATE
OR
REJECT
A
SPECIFIC
ALGORITHMIC
CHOICE
A
HARDWARE
IMPLEMENTATION
OR
THE
APPROPRIATENESS
OF
A
SOLUTION
WHOSE
STRUCTURAL
PARAMETERS
ARE
AFFECTED
BY
UNCERTAINTIES
MATRIX
BOUND
RUDOLF
AHLSWEDE
AND
ANDREAS
WINTER
INTRODUCED
A
CHERNOFF
BOUND
FOR
MATRIXVALUED
RANDOM
VARIABLES
IF
M
IS
DISTRIBUTED
ACCORDING
TO
SOME
DISTRIBUTION
OVER
D
D
MATRICES
WITH
ZERO
MEAN
AND
IF
MT
ARE
INDEPENDENT
COPIES
OF
M
THEN
FOR
ANY

WHERE
HOLDS
ALMOST
SURELY
AND
C
IS
AN
ABSOLUTE
CONSTANT
NOTICE
THAT
THE
NUMBER
OF
SAMPLES
IN
THE
INEQUALITY
DEPENDS
LOGARITHMICALLY
ON
D
IN
GENERAL
UNFORTUNATELY
SUCH
A
DEPENDENCY
IS
INEVITABLE
TAKE
FOR
EXAMPLE
A
DIAGONAL
RANDOM
SIGN
MATRIX
OF
DIMENSION
D
THE
OPERATOR
NORM
OF
THE
SUM
OF
T
INDEPENDENT
SAMPLES
IS
PRECISELY
THE
MAXIMUM
DEVIATION
AMONG
D
INDEPENDENT
RANDOM
WALKS
OF
LENGTH
T
IN
ORDER
TO
ACHIEVE
A
FIXED
BOUND
ON
THE
MAXIMUM
DEVIATION
WITH
CONSTANT
PROBABILITY
IT
IS
EASY
TO
SEE
THAT
T
SHOULD
GROW
LOGARITHMICALLY
WITH
D
IN
THIS
SCENARIO
THE
FOLLOWING
THEOREM
CAN
BE
OBTAINED
BY
ASSUMING
M
HAS
LOW
RANK
IN
ORDER
TO
AVOID
THE
DEPENDENCY
ON
THE
DIMENSIONS
THEOREM
WITHOUT
THE
DEPENDENCY
ON
THE
DIMENSIONS
LET

AND
M
BE
A
RANDOM
SYMMETRIC
REAL
MATRIX
WITH
AND
ALMOST
SURELY
ASSUME
THAT
EACH
ELEMENT
ON
THE
SUPPORT
OF
M
HAS
AT
MOST
RANK
R
SET
IF
HOLDS
ALMOST
SURELY
THEN
CHERNOFF
BOUND
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
WHERE
MT
ARE
I
I
D
COPIES
OF
M
SAMPLING
VARIANT
THE
FOLLOWING
VARIANT
OF
CHERNOFF
BOUND
CAN
BE
USED
TO
BOUND
THE
PROBABILITY
THAT
A
MAJORITY
IN
A
POPULATION
WILL
BECOME
A
MINORITY
IN
A
SAMPLE
OR
VICE
VERSA
SUPPOSE
THERE
IS
A
GENERAL
POPULATION
A
AND
A
SUBPOPULATION
B
A
MARK
THE
RELATIVE
SIZE
OF
THE
SUBPOPULATION
B
A
BY
R
SUPPOSE
WE
PICK
AN
INTEGER
K
AND
A
RANDOM
SAMPLE
A
OF
SIZE
K
MARK
THE
RELATIVE
SIZE
OF
THE
SUBPOPULATION
IN
THE
SAMPLE
B
BY
RS
THEN
FOR
EVERY
FRACTION
D
IN
PARTICULAR
IF
B
IS
A
MAJORITY
IN
A
I
E
R
WE
CAN
BOUND
THE
PROBABILITY
THAT
B
WILL
REMAIN
MAJORITY
IN
RS
BY
TAKING
D
R
THIS
BOUND
IS
OF
COURSE
NOT
TIGHT
AT
ALL
FOR
EXAMPLE
WHEN
R
WE
GET
A
TRIVIAL
BOUND
PROB
PROOFS
CHERNOFFHOEFFDING
THEOREM
ADDITIVE
FORM
LET
Q
P

TAKING
A
NQ
IN
WE
OBTAIN
NOW
KNOWING
THAT
PR
XI
P
PR
XI
P
WE
HAVE
THEREFORE
WE
CAN
EASILY
COMPUTE
THE
INFIMUM
USING
CALCULUS
CHERNOFF
BOUND
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
SETTING
THE
EQUATION
TO
ZERO
AND
SOLVING
WE
HAVE
SO
THAT
THUS
AS
Q
P

P
WE
SEE
THAT
T
SO
OUR
BOUND
IS
SATISFIED
ON
T
HAVING
SOLVED
FOR
T
WE
CAN
PLUG
BACK
INTO
THE
EQUATIONS
ABOVE
TO
FIND
THAT
WE
NOW
HAVE
OUR
DESIRED
RESULT
THAT
TO
COMPLETE
THE
PROOF
FOR
THE
SYMMETRIC
CASE
WE
SIMPLY
DEFINE
THE
RANDOM
VARIABLE
YI
XI
APPLY
THE
SAME
PROOF
AND
PLUG
IT
INTO
OUR
BOUND
MULTIPLICATIVE
FORM
SET
PR
XI
PI
ACCORDING
TO
CHERNOFF
BOUND
WIKIPEDIA
HTTPS
EN
WIKIPEDIA
ORG
WIKI
THE
THIRD
LINE
ABOVE
FOLLOWS
BECAUSE
TAKES
THE
VALUE
ET
WITH
PROBABILITY
PI
AND
THE
VALUE
WITH
PROBABILITY
PI
THIS
IS
IDENTICAL
TO
THE
CALCULATION
ABOVE
IN
THE
PROOF
OF
THE
THEOREM
FOR
ADDITIVE
FORM
ABSOLUTE
ERROR
REWRITING
AS
AND
RECALLING
THAT
WITH
STRICT
INEQUALITY
IF
X
WE
SET
THE
SAME
RESULT
CAN
BE
OBTAINED
BY
DIRECTLY
REPLACING
A
IN
THE
EQUATION
FOR
THE
CHERNOFF
BOUND
WITH


THUS
IF
WE
SIMPLY
SET
T
LOG

SO
THAT
T
FOR

WE
CAN
SUBSTITUTE
AND
FIND
THIS
PROVES
THE
RESULT
DESIRED
FINAL
EXAM
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
FOR
MOST
OF
THE
PROBLEMS
I
AM
INTERESTED
IN
TESTING
WHETHER
YOU
UNDERSTAND
THE
TECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IF
I
ASK
YOU
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
IF
I
ASK
YOU
TO
PROVE
THAT
A
GREEDY
ALGORITHM
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECI
C
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECI
CS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETED
AS
I
DON
T
KNOW
AN
ANSWER
THAT
DISPLAYS
A
MAJOR
CONCEPTUAL
ERROR
WILL
LIKELY
RECEIVE
A
GRADE
OF
ZERO
IT
IS
PERFECTLY
NE
TO
GIVE
AN
INCOMPLETE
ANSWER
E
G
HERE
HOW
ONE
PROVES
A
PROBLEM
NP
HARD
BUT
I
DON
T
KNOW
HOW
TO
PROVE
THIS
PROBLEM
NP
HARD
I
WILL
MAKE
A
JUDGEMENT
CALL
ON
HOW
MUCH
CREDIT
SUCH
ANSWERS
SHOULD
RECEIVE
BUT
GENERALLY
IT
WILL
BE
AROUND
I
WILL
ASSUME
THAT
IF
YOU
WRITE
SOMETHING
THAT
YOU
ARE
ASSERTING
THAT
YOU
HAVE
GOOD
CON
DENCE
IN
THE
CORRECTNESS
OF
WHAT
YOU
WRITE
IT
IS
A
BAD
STRATEGY
TO
GIVE
AN
ANSWER
THAT
YOU
DO
NOT
HAVE
GOOD
CON
DENCE
IN
ANSWER
UP
TO
OF
THE
PROBLEMS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
ANSWERING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
CONSIDER
A
SETTING
WHERE
YOU
HAVE
TWO
COMPUTER
NETWORKING
ROUTERS
A
AND
B
EACH
ROUTER
HAS
COLLECTED
A
LIST
LA
AND
LB
OF
IP
SOURCE
ADDRESSES
FOR
THE
PACKETS
THAT
HAVE
PASSED
THROUGH
THE
ROUTER
THAT
DAY
AN
IP
ADDRESS
IS
N
BITS
AND
THUS
THERE
ARE
POSSIBLE
IP
ADDRESSES
NOW
THE
TWO
ROUTERS
WANT
TO
COMMUNICATE
VIA
A
TWO
WAY
CHANNEL
TO
WHETHER
THERE
WAS
SOME
SOURCE
THAT
SENT
A
PACKET
THROUGH
ONE
OF
THE
ROUTERS
BUT
NOT
THE
OTHER
SO
MORE
PRECISELY
AT
THE
END
OF
THE
PROTOCOL
EACH
ROUTER
SHOULD
COMMIT
TO
A
BIT
SPECIFYING
THE
ANSWER
TO
THIS
QUESTION
AND
THE
BITS
FOR
BOTH
ROUTERS
SHOULD
BE
CORRECT
YOU
CAN
ASSUME
THAT
A
BIT
SENT
ON
THE
CHANNEL
IS
GUARANTEED
TO
ARRIVE
ON
THE
OTHER
END
IN
ONE
TIME
UNIT
WE
WANT
TO
CONSIDER
PROTOCOLS
FOR
ACCOMPLISHING
THIS
GOAL
PROVE
THAT
EVERY
PROTOCOL
FOR
THIS
PROBLEM
MUST
SENT
BITS
FOR
ITS
WORST
CASE
INSTANCE
SUPPOSE
THAT
WE
USE
AN
OPEN
ADDRESSED
HASH
TABLE
OF
SIZE
M
TO
STORE
N
M
ITEMS
ASSUMING
UNIFORM
HASHING
SHOW
THAT
THE
EXPECTED
LENGTH
OF
THE
LONGEST
PROBE
SEQUENCE
AMONG
THE
N
INSERTS
IS
O
LOG
N
A
PALINDROME
IS
A
NONEMPTY
STRING
OVER
SOME
ALPHABET
THAT
READS
THE
SAME
FORWARD
AND
BACKWARD
EXAMPLES
OF
PALINDROMES
ARE
ALL
STRINGS
OF
LENGTH
CIVIC
RACECAR
AND
AIBOHPHO
BIA
FEAR
OF
PALINDROMES
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
TO
ND
THE
LONGEST
PALINDROME
THAT
IS
A
SUBSEQUENCE
OF
A
GIVEN
INPUT
STRING
CONSIDER
A
TWO
PERSON
GAME
SPECI
ED
BY
AN
M
BY
N
PAYO
MATRIX
P
THE
TWO
PLAYERS
CAN
CAN
BE
THOUGHT
OF
AS
A
ROW
PLAYER
AND
A
COLUMN
PLAYER
THE
NUMBER
OF
POSSIBLE
MOVES
FOR
THE
ROW
PLAYER
IS
M
AND
THE
NUMBER
OF
POSSIBLE
MOVES
FOR
THE
COLUMN
PLAYER
IS
N
EACH
PLAYER
PICKS
A
PROBABILITY
DISTRIBUTION
OVER
ITS
MOVES
AND
THEN
MONEY
IS
EXCHANGED
THE
ROW
PLAYER
PAYS
THE
COLUMN
PLAYER
E
PR
C
DOLLARS
WHERE
THE
EXPECTATION
IS
OVER
BOTH
THE
PROBABILITY
DISTRIBUTION
FOR
THE
ROW
PLAYER
AND
THE
PROBABILITY
DISTRIBUTION
FOR
THE
COLUMN
PLAYER
WE
ASSUME
THAT
THE
GAME
IS
PLAYED
SEQUENTIALLY
SO
THAT
ONE
PLAYER
SPECI
ES
HIS
PROBABILITY
DISTRIBUTION
THE
OTHER
PLAYERS
SEES
IT
AND
THEN
SPECI
ES
A
RESPONSE
OBVIOUSLY
EACH
PLAYER
WANTS
TO
BE
PAYED
AS
MUCH
MONEY
AS
POSSIBLE
AND
IF
THIS
IS
NOT
POSSIBLE
TO
PAY
AS
LITTLE
AS
POSSIBLE
A
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
TO
DETERMINE
THE
OPTIMAL
PROBABILITY
DISTRIBUTION
FOR
THE
ROW
PLAYER
ASSUMING
THAT
THE
ROW
PLAYER
GOES
RST
AND
THAT
THE
COLUMN
PLAYER
RESPONDS
WITH
HIS
OPTIMAL
PROBABILITY
DISTRIBUTION
B
EXPLAIN
HOW
ONE
COULD
SIMPLY
PROVE
TO
THE
ROW
PLAYER
THAT
THERE
IS
NO
PROBABILITY
DISTRIBUTION
THAT
HE
COULD
PICK
THAT
WOULD
RESULT
IN
HIM
NOT
HAVING
TO
PAY
MONEY
YOU
ARE
GIVEN
N
BOXES
WITH
WEIGHTS
WN
THAT
ONE
WANTS
TO
PARTITION
AMONG
M
TRUCKS
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
WEIGHT
ON
THE
MOST
HEAVILY
LOADED
TRUCK
GIVE
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THIS
PROBLEM
YOU
MUST
PROVE
THAT
THE
ALGORITHM
IS
A
APPROXIMATION
ALGORITHM
SHOW
THAT
THE
EXPECTED
COMPETITIVE
APPROXIMATION
RATIO
FOR
EVERY
RANDOMIZED
PAGING
AL
GORITHMS
IS
O
LOGK
WHERE
K
IS
THE
SIZE
OF
THE
FAST
MEMORY
USING
A
VARIATION
OF
YAO
TECHNIQUE
SHOW
THAT
THE
SUBSET
SUM
PROBLEM
IS
NP
HARD
VIA
A
REDUCTION
FROM
ASSUME
THAT
YOU
WANT
TO
MAINTAIN
A
DYNAMIC
TABLE
UNDER
THE
OPERATIONS
INSERT
AND
DELETE
ASSUME
BOTH
THERE
OPERATIONS
HAVE
COST
IF
THE
TABLE
BECOMES
FULL
THEN
THE
SIZE
OF
THE
TABLE
IS
DOUBLED
ASSUME
THE
COST
OF
THIS
OPERATION
IS
THE
SIZE
OF
THE
NEW
LARGER
TABLE
IF
THE
TABLE
BECOMES
FULL
THEN
THE
SIZE
OF
THE
TABLE
IS
HALVED
ASSUME
THAT
THE
COST
OF
THIS
OPERATION
IS
THE
SIZE
OF
THE
OLD
LARGER
TABLE
SHOW
THAT
THE
TOTAL
COST
OF
N
OPERATIONS
WHICH
MAY
BE
AN
ARBITRARY
COMBINATION
OF
INSERT
AND
DELETE
IS
O
N
USING
A
POTENTIAL
FUNCTION
CONSIDER
THE
STANDARD
CACHINE
PAGING
PROBLEM
FOR
EACH
REQUEST
THE
CACHE
MANAGEMENT
ALGORITHM
CHECKS
WHETHER
THAT
ELEMENT
IS
ALREADY
IN
THE
CACHE
IF
IT
IS
THEN
WE
HAVE
A
CACHE
HIT
OTHERWISE
WE
HAVE
A
CACHE
MISS
UPON
A
CACHE
MISS
THE
SYSTEM
RETRIEVES
THE
ELEMENT
FROM
THE
MAIN
MEMORY
AND
THE
CACHE
MANAGEMENT
ALGORITHM
MUST
DECIDE
WHETHER
TO
KEEP
THE
ELEMENT
IN
THE
CACHE
IF
IT
DECIDES
TO
KEEP
ELEMENT
IN
CACHE
AND
THE
CACHE
ALREADY
HOLDS
K
ELEMENTS
THEN
IT
MUST
EVICT
ONE
ELEMENT
TO
MAKE
ROOM
THE
CACHE
MANAGEMENT
ALGORITHM
EVICTS
DATA
WITH
THE
GOAL
OF
MINIMIZING
THE
NUMBER
OF
CACHE
MISSES
OVER
THE
ENTIRE
SEQUENCE
OF
REQUESTS
GIVE
A
POLYNOMIAL
TIME
O
INE
GREEDY
ALGORITHM
FOR
THIS
PROBLEM
WE
CONSIDER
THE
STANDARD
NETWORK
OW
PROBLEM
A
STATE
THE
FORD
FULKERSON
ALGORITHM
B
PROVE
THE
FORD
FULKERSON
ALGORITHM
IS
CORRECT
C
IS
FORD
FULKERSON
A
POLYNOMIAL
TIME
ALGORITHM
FULLY
JUSTIFY
YOUR
ANSWER
D
IS
FORD
FULKERSON
A
PSEUDO
POLYNOMIAL
TIME
ALGORITHM
FULLY
JUSTIFY
YOUR
ANSWER
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
FOR
MOST
OF
THE
PROBLEMS
I
AM
INTERESTED
IN
TESTING
WHETHER
YOU
UNDERSTAND
THE
TECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IF
I
ASK
YOU
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
IF
I
ASK
YOU
TO
PROVE
THAT
A
GREEDY
ALGORITHM
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECI
C
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECI
CS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETED
AS
I
DON
T
KNOW
AN
ANSWER
THAT
DISPLAYS
A
MAJOR
CONCEPTUAL
ERROR
WILL
LIKELY
RECEIVE
A
GRADE
OF
ZERO
IT
IS
PERFECTLY
NE
TO
GIVE
AN
INCOMPLETE
ANSWER
E
G
HERE
HOW
ONE
PROVES
A
PROBLEM
NP
HARD
BUT
I
DON
T
KNOW
HOW
TO
PROVE
THIS
PROBLEM
NP
HARD
I
WILL
MAKE
A
JUDGEMENT
CALL
ON
HOW
MUCH
CREDIT
SUCH
ANSWERS
SHOULD
RECEIVE
BUT
GENERALLY
IT
WILL
BE
AROUND
I
WILL
ASSUME
THAT
IF
YOU
WRITE
SOMETHING
THAT
YOU
ARE
ASSERTING
THAT
YOU
HAVE
GOOD
CON
DENCE
IN
THE
CORRECTNESS
OF
WHAT
YOU
WRITE
IT
IS
A
BAD
STRATEGY
TO
GIVE
AN
ANSWER
THAT
YOU
DO
NOT
HAVE
GOOD
CON
DENCE
IN
ANSWER
UP
TO
OF
THE
PROBLEMS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
ANSWERING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
CONSIDER
THE
PROBLEM
OF
NDING
A
MINIMUM
WEIGHT
SPANNING
TREE
IN
A
GRAPH
A
GIVE
A
POLYNOMIAL
SIZED
INTEGER
LINEAR
PROGRAMMING
FORMULATION
F
B
CONSIDER
THE
RELAXATION
R
OF
F
WHERE
THE
VARIABLES
ARE
ALLOWED
TO
BE
ARBITRARY
RATIONAL
NUMBERS
NOT
NECESSARILY
INTEGERS
EXPLAIN
HOW
TO
ROUND
A
RATIONAL
OPTIMAL
SOLUTION
TO
R
TO
OBTAIN
AN
INTEGER
OPTIMAL
SOLUTION
TO
F
STATE
YAO
THEOREM
WITHIN
THE
CONTEXT
OF
MONTE
CARLO
ALGORITHMS
USE
YAO
THEOREM
TO
PROVE
THAT
NO
COMPARISON
BASED
MONTE
CARLO
ALGORITHM
CAN
SORT
N
NUMBERS
USING
COMPARISONS
PROVE
THAT
THE
VERTEX
COVER
PROBLEM
DECIDING
WHETHER
A
GIVEN
GRAPH
HAS
A
VERTEX
COVER
OF
A
GIVEN
SIZE
IS
NP
HARD
USING
THE
FACT
THAT
DETERMINING
WHETHER
A
BOOLEAN
FORMULA
IN
CONJUNCTIVE
NORMAL
FORM
WITH
EXACTLY
LITERALS
PER
CLAUSE
IS
SATIS
ABLE
IS
KNOWN
TO
BE
NP
HARD
ASSUME
THAT
YOU
HAVE
A
COLLECTION
OF
N
BOXES
ARRIVING
ONLINE
OVER
TIME
THAT
MUST
BE
LOADED
ONTO
M
TRUCKS
WHEN
A
BOX
ARRIVES
THE
ONLINE
ALGORITHM
LEARNS
THE
WEIGHT
OF
THE
BOX
AND
A
LIST
OF
TRUCKS
THAT
THAT
BOX
CAN
BE
LOADED
ON
SO
NOT
EVERY
BOX
IS
ALLOWED
TO
BE
LOADED
ON
EVERY
TRUCK
AT
THE
TIME
THAT
A
BOX
ARRIVES
THE
ONLINE
ALGORITHM
MUST
PICK
A
TRUCK
TO
LOAD
THE
BOX
ON
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
WEIGHT
OF
THE
MOST
HEAVILY
LOADED
TRUCK
GIVE
AN
ADVERSARIAL
ARGUMENT
TO
SHOW
NO
DETERMINISTIC
ONLINE
ALGORITHM
CAN
ACHIEVE
APPROXIMATION
RATIO
O
CONSIDER
THE
FOLLOWING
ONLINE
PROBLEM
THERE
ARE
TWO
TAXIS
ON
A
LINE
THAT
INITIALLY
START
AT
THE
ORIGIN
AT
POSITIVE
INTEGER
TIME
T
A
REQUEST
POINT
HT
ON
THE
LINE
ARRIVES
IN
RESPONSE
EACH
TAXI
CAN
MOVE
TO
A
DI
ERENT
LOCATION
ON
THE
LINE
OR
STAY
PUT
AT
THE
CURRENT
POINT
THE
PATH
TRAVELED
BY
AT
LEAST
ONE
OF
THE
TWO
TAXIS
MUST
CROSS
HT
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
TOTAL
MOVEMENT
OF
THE
TAXIS
CONSIDER
THE
FOLLOWING
ALGORITHM
A
IF
BOTH
TAXIS
ARE
TO
THE
LEFT
OF
HT
THEN
THE
RIGHTMOST
TAXI
MOVES
TO
HT
IF
BOTH
TAXIS
ARE
TO
THE
RIGHT
OF
HT
THEN
THE
LEFTMOST
TAXI
MOVES
TO
HT
IF
HT
IS
BETWEEN
THE
TWO
TAXIS
THEN
BOTH
TAXIS
MOVE
TOWARD
HT
AT
THE
SAME
RATE
UNTIL
ONE
OF
THE
TAXIS
REACHES
HT
AT
WHICH
POINT
BOTH
TAXIS
STOP
MOVING
SHOW
THAT
THIS
ALGORITHM
IS
COMPETITIVE
USING
THE
FOLLOWING
POTENTIAL
FUNCTION
F
THE
DISTANCE
BETWEEN
THE
LEFTMOST
TAXI
FOR
A
AND
THE
LEFTMOST
TAXI
FOR
OPTIMAL
THE
DISTANCE
BETWEEN
THE
RIGHTMOST
TAXI
FOR
A
AND
THE
RIGHTMOST
TAXI
FOR
OPTIMAL
THE
DISTANCE
BETWEEN
THE
LEFTMOST
AND
THE
RIGHTMOST
TAXIS
FOR
A
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
A
COLLECTION
C
XN
YN
OF
POINTS
IN
TWO
DIMENSIONS
THE
OUTPUT
IS
THE
MINIMUM
PERIMETER
VERTICALLY
SIMPLE
POLYGON
WITH
FOR
WHICH
ALL
THE
POINTS
IN
C
ARE
ON
THE
PERIMETER
A
POLYGON
IS
VERTICALLY
SIMPLE
IF
NO
VERTICAL
LINE
INTERSECTS
THE
POLYGON
MORE
THAN
TWICE
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
CONSIDER
THE
FOLLOWING
PROBLEM
THE
INPUT
IS
N
DISJOINT
LINE
SEGMENTS
CONTAINED
IN
AN
L
BY
L
SQUARE
IN
THE
EUCLIDEAN
PLANE
THE
GOAL
IS
TO
PARTITION
INTO
CONVEX
POLYGONS
SO
THAT
THE
INTERIOR
OF
EVERY
POLYGON
INTERSECTS
AT
MOST
ONE
LINE
SEGMENT
SO
IT
IS
OK
FOR
A
LINE
SEGMENT
TO
BE
IN
MULTIPLE
POLYGONS
BUT
EACH
POLYGON
CAN
INTERSECT
AT
MOST
ONE
LINE
SEGMENT
CONSIDER
THE
FOLLOWING
ALGORITHM
THAT
MAINTAINS
A
PARTITION
C
OF
INTO
POLYGONS
INITIALLY
THIS
COLLECTION
IS
JUST
THE
SINGLE
POLYGON
THAT
IS
C
LET
P
BE
A
RANDOM
PERMUTATION
OF
THE
THE
LINE
SEGMENTS
WHILE
THERE
IS
A
POLYGON
P
C
THAT
CONTAINS
MORE
THAN
ONE
LINE
SEGMENT
LET
L
BE
THE
RST
LINE
SEGMENT
IN
THE
P
ORDER
THAT
INTERSECTS
P
AND
CUT
P
INTO
TWO
POLYGONS
USING
THE
LINEAR
EXTENSION
OF
L
SO
YOU
EXTEND
THE
LINE
SEGMENT
L
INTO
A
LINE
AND
THEN
USE
THAT
TO
CUT
P
SHOW
THAT
THE
EXPECTED
NUMBER
OF
RESULTING
POLYGONS
IS
O
N
LOGN
STATE
THE
BELLMAN
FORD
ALGORITHM
AND
EXPLAIN
EXPLAIN
HOW
IT
CAN
BE
USED
TO
DETERMINE
WHETHER
ONE
CAN
MAKE
A
PRO
T
IN
CURRENCY
ARBITRAGE
IN
THE
CURRENCY
ARBITRAGE
PROBLEM
YOU
GIVEN
N
CURRENCIES
CN
AND
FOR
EACH
ORDERED
PAIR
CI
CJ
YOU
ARE
GIVEN
AN
EXCHANGE
RATE
EI
J
WHICH
IS
THE
AMOUNT
OF
CURRENCY
CJ
YOU
CAN
OBTAIN
FROM
ONE
UNIT
OF
CURRENCY
CI
THE
PROBLEM
IS
TO
DETERMINE
WHETHER
THERE
IS
A
CURRENCY
CI
AND
A
SEQUENCE
OF
EXCHANGES
WHERE
YOU
CAN
END
UP
WITH
MORE
OF
CURRENCY
CI
THAN
YOU
STARTED
WITH
CONSIDER
THE
PARALLEL
PRE
X
PROBLEM
THE
INPUT
IS
N
INTEGERS
XN
THE
OUTPUT
IS
N
NUMBERS
REPRESENTING
THE
SUMS
OF
ALL
N
NONEMPTY
PRE
XES
SO
IF
THE
INPUT
WAS
THE
OUTPUT
WOULD
BE
GIVE
A
PARALLEL
ALGORITHM
FOR
THIS
PROBLEM
THAT
WOULD
RUN
ON
A
PRAM
WHERE
NEITHER
CONCURRENT
READING
OR
CONCURRENT
WRITING
IS
ALLOWED
THAT
WOULD
RUN
IN
TIME
O
LOG
N
IF
THE
NUMBER
P
OF
PROCESSORS
WAS
N
CONSIDER
THE
FOLLOWING
VARIANT
OF
THE
TRAVELING
SALESMAN
PROBLEM
TSP
THE
INPUT
IS
N
POINTS
IN
THE
PLANE
OR
SOME
OTHER
NITE
METRIC
SPACE
THE
OUTPUT
SHOULD
BE
THE
SHORTEST
ROUTE
TO
VISIT
ALL
POINTS
AND
RETURN
TO
THE
STARTING
POINT
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
THAT
HAS
AN
APPROXIMATION
RATIO
OF
AT
MOST
PROVE
THAT
THE
APPROXIMATION
RATIO
OF
YOUR
ALGORITHM
IS
AT
MOST
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
FOR
MOST
OF
THE
PROBLEMS
I
AM
INTERESTED
IN
TESTING
WHETHER
YOU
UNDERSTAND
THE
TECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IF
I
ASK
YOU
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
IF
I
ASK
YOU
PROBLEM
THAT
A
GREEDY
ALGORITHM
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECI
C
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECI
CS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETED
AS
I
DON
T
KNOW
AN
ANSWER
THAT
DISPLAYS
A
MAJOR
CONCEPTUAL
ERROR
WILL
LIKELY
RECEIVE
A
GRADE
OF
ZERO
IT
IS
PERFECTLY
NE
TO
GIVE
AN
INCOMPLETE
ANSWER
E
G
HERE
HOW
ONE
PROVES
A
PROBLEM
NP
HARD
BUT
I
DON
T
KNOW
HOW
TO
PROVE
THIS
PROBLEM
NP
HARD
I
WILL
MAKE
A
JUDGEMENT
CALL
ON
HOW
MUCH
CREDIT
SUCH
ANSWERS
SHOULD
RECEIVE
BUT
GENERALLY
IT
WILL
BE
AROUND
I
WILL
ASSUME
THAT
IF
YOU
WRITE
SOMETHING
THAT
YOU
ARE
ASSERTING
THAT
YOU
HAVE
GOOD
CON
DENCE
IN
THE
CORRECTNESS
OF
WHAT
YOU
WRITE
IT
IS
A
BAD
STRATEGY
TO
GIVE
AN
ANSWER
THAT
YOU
DO
NOT
HAVE
REASONABLE
CON
DENCE
IN
ANSWER
UP
TO
OF
THE
PROBLEMS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
ANSWERING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
CONSIDER
THE
FOLLOWING
POSSIBLE
DE
NITIONS
FOR
F
N
M
O
G
N
M
STATE
WHICH
DE
NI
TIONS
ARE
LOGICALLY
EQUIVALENT
FULLY
JUSTIFY
YOUR
ANSWERS
A
THERE
EXISTS
POSITIVE
CONSTANTS
C
SUCH
THAT
F
N
M
C
G
N
M
FOR
ALL
N
M
SUCH
THAT
N
AND
M
B
THERE
EXISTS
POSITIVE
CONSTANTS
C
SUCH
THAT
F
N
M
C
G
N
M
FOR
ALL
N
M
SUCH
THAT
N
OR
M
C
THERE
EXISTS
A
CONSTANT
C
SUCH
THAT
LIM
SUPN
LIM
SUPM
F
N
M
G
N
M
C
D
THERE
EXISTS
A
CONSTANT
C
SUCH
THAT
LIM
SUPM
LIM
SUPN
F
N
M
G
N
M
C
E
THERE
EXISTS
A
CONSTANT
C
SUCH
THAT
FOR
ALL
BUT
NITELY
MANY
PAIRS
M
N
IT
IS
THE
CASE
THAT
F
N
M
C
G
N
M
CONSIDER
THE
PROBLEM
WHOSE
INPUT
IS
N
JOBS
WHERE
JOB
I
HAS
AN
INTEGER
RELEASE
TIME
RI
AND
AN
INTEGER
VOLUME
XI
AND
WHOSE
OUTPUT
IS
A
FEASIBLE
SCHEDULE
THAT
MINIMIZES
THE
TOTAL
OW
TIME
OF
THE
JOBS
A
SCHEDULE
A
FUNCTION
FROM
SOME
SUBSET
OF
THE
UNIT
INTERVALS
WHICH
START
AND
END
AT
AN
INTEGER
TO
A
JOB
THAT
IS
RUN
DURING
THAT
INTERVAL
A
SCHEDULE
IS
FEASIBLE
IF
NO
JOB
IS
RUN
BEFORE
ITS
RELEASE
TIME
AND
EACH
JOB
I
IS
RUN
FOR
XI
UNITS
THE
COMPETITION
TIME
CI
OF
A
JOB
I
IS
THE
LAST
TIME
THAT
IT
WAS
RUN
THE
OW
TIME
OF
JOB
I
IS
CI
RI
THE
TOTAL
P
OW
TIME
IS
I
CI
RI
PROVE
USING
AN
EXCHANGE
ARGUMENT
THAT
ALWAYS
RUNNING
THE
JOB
WITH
THE
LEAST
REMAINING
UNPROCESSED
UNRUN
VOLUME
IS
A
CORRECT
OPTIMAL
ALGORITHM
GIVE
AN
O
TIME
DYNAMIC
PROGRAMMING
ALGORITHM
TO
ND
THE
LONGEST
INCREASING
SUBSE
QUENCE
IN
A
SEQUENCE
XN
OF
INTEGERS
LET
XN
BE
A
SEQUENCE
OF
BERNOULLI
TRIALS
LET
YI
BE
THE
MAXIMUM
K
SUCH
THAT
XI
XI
XI
K
ARE
ALL
FAILURES
SHOW
E
MAXI
YI
O
LOG
N
CONSIDER
THE
PROBLEM
OF
NDING
THE
MAXIMUM
CARDINALITY
MATCHING
IN
A
BIPARTITE
GRAPH
GIVE
A
POLYNOMIAL
SIZED
INTEGER
LINEAR
PROGRAM
FOR
THIS
PROBLEM
EXPLAIN
HOW
TO
OBTAIN
IN
POLYNOMIAL
TIME
A
MINIMUM
MATCHING
FROM
THE
POTENTIALLY
FRACTIONAL
SOLUTION
PRODUCED
BY
A
BLACK
BOX
LINEAR
PROGRAMMING
SOLVER
GIVE
THE
DUAL
OF
THE
LINEAR
PROGRAM
EXPLAIN
WHAT
NATURAL
PROBLEM
THE
DUAL
IS
A
LINEAR
PROGRAM
FOR
EXPLAIN
HOW
ONE
CAN
SIMPLY
PROVE
THAT
THERE
IS
NO
MATCHING
OF
SIZE
K
SOMEONE
WHO
DOESN
T
KNOW
LINEAR
PROGRAMMING
DUALITY
SHOULD
BE
ABLE
TO
UNDERSTAND
YOUR
ARGUMENT
PROVE
USING
YAO
TECHNIQUE
THAT
EVERY
RANDOMIZED
ONLINE
ALGORITHM
FOR
THE
PAGING
PROBLEM
HAS
APPROXIMATION
RATIO
O
LOG
K
HERE
K
IS
THE
NUMBER
OF
PAGES
IN
FAST
MEMORY
RECALL
THE
OBJECTIVE
WAS
TO
MINIMIZE
THE
NUMBER
OF
ACCESSES
TO
SLOW
MEMORY
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
CONSISTS
OF
N
BOXES
WITH
WEIGHTS
WN
AND
AN
INTEGER
K
THE
PROBLEM
IS
TO
PARTITION
THE
BOXES
INTO
K
PARTITIONS
SUCH
THAT
THE
MAXIMUM
AGGREGATE
WEIGHT
OF
ANY
PARTITION
IS
MINIMIZED
GIVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
THIS
PROBLEM
AND
PROVE
THAT
IT
IS
A
APPROXIMATION
ALGORITHM
PROVE
THAT
THE
PROBLEM
OF
SOLVING
INTEGER
LINEAR
PROGRAMS
IS
NP
HARD
USING
THE
FACT
THAT
DE
CIDING
WHETHER
A
BOOLEAN
FORMULA
IN
CONJUNCTIVE
NORMAL
FORM
IS
SATIS
ABLE
IS
NP
COMPLETE
PROVE
USING
AN
ADVERSARIAL
ARGUMENT
THAT
ANY
COMPARISON
BASED
ALGORITHM
MUST
USE
O
COMPARISONS
TO
ND
THE
LARGEST
AND
THE
SMALLEST
NUMBER
IN
A
LIST
OF
N
NUMBERS
STATE
THE
FORD
FULKERSON
ALGORITHM
FOR
THE
NETWORK
OW
PROBLEM
AND
PROVE
THAT
IT
IS
CORRECT
IF
CAPACITIES
ARE
INTEGERS
PROVE
USING
A
POTENTIAL
FUNCTION
THE
AMORTIZED
COST
OF
INSERTING
INTO
A
DYNAMIC
TABLE
WHICH
DOUBLES
IN
SIZE
WHEN
IT
IS
TWO
THIRDS
FULL
IS
O
ASSUME
THAT
YOU
HAD
TO
SOLVE
THE
HIRING
PROBLEM
AT
A
LARGE
ACADEMIC
INSTITUTION
WHERE
E
ECTIVELY
YOU
COULDN
T
RE
ANYONE
NOTE
THAT
THIS
IS
A
REALISTIC
ASSUMPTION
THUS
ONCE
YOU
HIRE
SOMEONE
THE
GAME
IS
OVER
FIND
A
STRATEGY
THAT
WILL
HIRE
THE
BEST
PERSON
WITH
PROBABILITY
APPROXIMATELY
E
ASSUMING
THAT
EACH
PERMUTATION
IS
EQUALLY
LIKELY
THE
PERSON
HIRING
KNOWS
N
THE
NUMBER
OF
APPLICANTS
A
PRIORI
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
FALL
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
FOR
MOST
OF
THE
PROBLEMS
I
AM
INTERESTED
IN
TESTING
WHETHER
YOU
UNDERSTAND
THE
TECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IF
I
ASK
YOU
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
IF
I
ASK
YOU
PROBLEM
THAT
A
GREEDY
ALGORITHM
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECI
C
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECI
CS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETED
AS
I
DON
T
KNOW
AN
ANSWER
THAT
DISPLAYS
A
MAJOR
CONCEPTUAL
ERROR
WILL
LIKELY
RECEIVE
A
GRADE
OF
ZERO
IT
IS
PERFECTLY
NE
TO
GIVE
AN
INCOMPLETE
ANSWER
E
G
HERE
HOW
ONE
PROVES
A
PROBLEM
NP
HARD
BUT
I
DON
T
KNOW
HOW
TO
PROVE
THIS
PROBLEM
NP
HARD
I
WILL
MAKE
A
JUDGEMENT
CALL
ON
HOW
MUCH
CREDIT
SUCH
ANSWERS
SHOULD
RECEIVE
BUT
GENERALLY
IT
WILL
BE
AROUND
I
WILL
ASSUME
THAT
IF
YOU
WRITE
SOMETHING
THAT
YOU
ARE
ASSERTING
THAT
YOU
HAVE
GOOD
CON
DENCE
IN
THE
CORRECTNESS
OF
WHAT
YOU
WRITE
IT
IS
A
BAD
STRATEGY
TO
GIVE
AN
ANSWER
THAT
YOU
DO
NOT
HAVE
REASONABLE
CON
DENCE
IN
ANSWER
UP
TO
OF
THE
PROBLEMS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
ANSWERING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
PROVE
THE
CORRECTNESS
OF
DIJKSTRA
SINGLE
SOURCE
SHORTEST
PATH
ALGORITHM
USING
AN
EXCHANGE
ARGUMENT
START
WITH
A
BRIEF
DESCRIPTION
OF
DIJKSTRA
ALGORITHM
THEN
EXPLAIN
HOW
AN
EXCHANGE
ARGUMENT
WORKS
A
PALINDROME
IS
A
NONEMPTY
STRING
THAT
READS
THE
SAME
FORWARD
AND
BACKWARDS
GIVE
AN
O
TIME
DYNAMIC
PROGRAMMING
ALGORITHM
TO
ND
THE
LONGEST
PALINDROME
THAT
IS
A
SUBSEQUENCE
OF
A
GIVEN
INPUT
STREAM
GIVE
A
POLYNOMIAL
SIZED
LINEAR
PROGRAM
FOR
THE
PROBLEM
OF
NDING
THE
MINIMUM
SPANNING
TREE
OF
AN
UNDIRECTED
EDGE
WEIGHTED
GRAPH
EXPLAIN
HOW
TO
OBTAIN
IN
POLYNOMIAL
TIME
A
MINIMUM
SPANNING
TREE
FROM
THE
POTENTIALLY
FRACTIONAL
SOLUTION
PRODUCED
BY
A
BLACK
BOX
LINEAR
PROGRAMMING
SOLVER
CONSIDER
COMPARISON
BASED
ALGORITHMS
FOR
SOME
O
INE
PROBLEM
STATE
YAO
THEOREM
IN
THIS
CONTEXT
FOR
LOWER
BOUNDING
THE
TIME
REQUIRED
BY
LAS
VEGAS
ALGORITHMS
INCLUDE
A
DE
NITION
OF
LAS
VEGAS
ALGORITHMS
EXPLAIN
WHY
YAO
THEOREM
IN
THIS
CONTEXT
IS
A
CONSEQUENCE
OF
WEAK
DUALITY
OF
LINEAR
PROGRAMS
INCLUDE
A
DE
NITION
OF
WEAK
DUALITY
CONSIDER
THE
FOLLOWING
ONLINE
PROBLEM
YOU
GIVEN
A
SEQUENCE
OF
BITS
BN
THAT
ARRIVE
OVER
TIME
EACH
BIT
IS
IN
AN
ENVELOPE
YOU
RST
SEE
THE
ENVELOPE
FOR
THEN
THE
ENVELOPE
FOR
ETC
WHEN
YOU
GET
THE
ENVELOPE
I
YOU
CAN
EITHER
LOOK
INSIDE
TO
SEE
THE
BIT
OR
DESTROY
THE
ENVELOPE
IN
WHICH
CASE
YOU
WILL
NEVER
KNOW
WHAT
THE
BIT
IS
YOU
KNOW
A
PRIORI
THAT
AT
LEAST
N
OF
THE
BITS
ARE
THE
GOAL
IS
TO
ND
AN
ENVELOPE
CONTAINING
A
BIT
YOU
WANT
TO
OPEN
AS
FEW
ENVELOPES
AS
POSSIBLE
SHOW
USING
YAO
TECHNIQUE
FOR
MONTE
CARLO
ALGORITHMS
THAT
EVERY
MONTE
CARLO
ALGORITHM
MUST
OPEN
O
LOG
N
ENVELOPES
IF
IT
IS
TO
BE
INCORRECT
WITH
PROBABILITY
N
START
BY
STATING
PRECISELY
THE
VERSION
OF
YAO
TECHNIQUE
THEOREM
THAT
YOU
WILL
USE
YOU
DO
NOT
NEED
TO
PROVE
YAO
THEOREM
JUST
STATE
IT
CORRECTLY
AND
APPLY
IT
CORRECTLY
ASSUME
THAT
YOU
HAVE
A
COLLECTION
OF
N
BOXES
BN
ARRIVING
ONLINE
OVER
TIME
THAT
MUST
BE
LOADED
ONTO
M
TRUCKS
WHEN
A
BOX
ARRIVES
THE
ONLINE
ALGORITHM
LEARNS
THE
WEIGHT
OF
THE
BOX
AND
A
LIST
OF
TRUCKS
THAT
THAT
BOX
CAN
BE
LOADED
ON
SO
NOT
EVERY
BOX
IS
ALLOWED
TO
BE
LOADED
ON
EVERY
TRUCK
AT
THE
TIME
THAT
A
BOX
ARRIVES
THE
ONLINE
ALGORITHM
MUST
PICK
A
TRUCK
TO
LOAD
THE
BOX
ON
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
WEIGHT
OF
THE
MOST
HEAVILY
LOADED
TRUCK
GIVE
AN
ADVERSARIAL
ARGUMENT
TO
SHOW
NO
DETERMINISTIC
ONLINE
ALGORITHM
CAN
ACHIEVE
APPROXIMATION
RATIO
O
THE
INPUT
FOR
THE
BOTTLENECK
TRAVELING
SALESMAN
PROBLEM
IS
A
COMPLETE
UNDIRECTED
GRAPH
WITH
POSITIVE
EDGE
WEIGHTS
SATISFYING
THE
TRIANGLE
INEQUALITY
FEASIBLE
SOLUTIONS
ARE
TOURS
THAT
VISIT
EACH
VERTEX
EXACTLY
ONCE
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
LENGTH
OF
THE
LONGEST
EDGE
IN
THE
TOUR
GIVE
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THIS
PROBLEM
YOU
MUST
PROVE
YOUR
ALGORITHM
PRODUCES
A
APPROXIMATION
START
WITH
A
DE
NITION
OF
WHAT
IT
MEANS
FOR
AN
ALGORITHM
TO
BE
A
APPROXIMATION
ALGORITHM
IN
THIS
SETTING
CONSIDER
THE
ONLINE
PAGING
CACHING
PROBLEM
THE
INPUT
IS
A
SEQUENCE
OF
PAGES
IF
A
PAGE
IS
NOT
CURRENTLY
IN
A
CACHE
A
CACHE
MISS
OCCURS
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
NUMBER
OF
CACHE
MISSES
SHOW
THAT
EJECTING
THE
LEAST
RECENTLY
USED
PAGE
FROM
CACHE
OF
SIZE
K
RESULTS
IN
AT
MOST
TWICE
AS
MANY
CACHE
MISSES
AS
THE
MINIMUM
POSSIBLE
NUMBER
OF
MISSES
FOR
A
SIZE
K
CACHE
PROVE
THAT
IF
THERE
IS
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THE
MAXIMUM
CLIQUE
PROBLEM
THAT
HAS
APPROXIMATION
RATIO
THEN
THERE
IS
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
WITH
APPROXIMATION
RATIO
STATE
THE
PUSH
RELABEL
ALGORITHM
FOR
NETWORK
OW
EXPLAIN
WHY
THE
ALGORITHM
TERMINATES
IN
POLYNOMIAL
TIME
WITH
THE
CORRECT
ANSWER
WHEN
THE
NETWORK
IS
A
SINGLE
PATH
FROM
THE
SOURCE
TO
THE
SINK
ASSUME
THAT
YOU
HAVE
TO
SOLVE
THE
HIRING
PROBLEM
AT
A
LARGE
INSTITUTION
WHERE
E
ECTIVELY
YOU
CAN
T
RE
ANYONE
NOTE
THAT
THIS
IS
A
REALISTIC
ASSUMPTION
THUS
ONCE
YOU
HIRE
SOMEONE
THE
GAME
IS
OVER
FIND
A
STRATEGY
THAT
WILL
HIRE
THE
BEST
PERSON
WITH
PROBABILITY
O
ASSUMING
THAT
EACH
PERMUTATION
IS
EQUALLY
LIKELY
NOTE
THAT
FOR
THE
PURPOSES
OF
THIS
PROBLEM
HIRING
THE
SECOND
BEST
PERSON
HIRING
NO
ONE
AND
HIRING
THE
WORST
PERSON
ARE
ALL
EQUIVALENT
THE
ONLY
THING
THAT
MATTERS
IS
HIRING
THE
BEST
PERSON
THE
PERSON
HIRING
KNOWS
N
THE
NUMBER
OF
APPLICANTS
A
PRIORI
JUSTIFY
THAT
THE
ALGORITHM
HIRES
THE
BEST
PERSON
WITH
PROBABILITY
O
YOU
HAVE
A
SORTED
ARRAY
A
OF
CONTAINING
N
REAL
NUMBERS
EACH
SELECTED
INDEPENDENTLY
AND
UNIFORMLY
AT
RANDOM
FROM
THE
INTERVAL
YOU
HAVE
AN
REAL
X
IN
THE
PROBLEM
IS
V
TO
ND
A
SUBARRAY
OF
SIZE
N
THAT
CONTAINS
X
GIVE
AN
ALGORITHM
WITH
EXPECTED
RUNNING
TIME
O
YOU
MUST
PROVE
THIS
CLAIMED
RUNNING
TIME
YOU
MAY
USE
WITHOUT
PROOF
THE
FACT
THAT
THE
PROBABILITY
THAT
A
BINOMIALLY
DISTRIBUTED
RANDOM
VARIABLE
X
IS
MORE
THAN
D
TIMES
ITS
MEAN

IS
AT
MOST
E
AND
THE
FACT
THAT
THE
PROBABILITY
THAT
A
BINOMIALLY
DISTRIBUTED
RANDOM
VARIABLE
X
IS
LESS
THAN
D
TIMES
ITS
MEAN

IS
AT
MOST
E
A
BINARY
SEARCH
TREE
IS
A
BALANCED
IF
FOR
EVERY
NODE
X
THE
SIZE
OF
THE
LEFT
SUBTREE
OF
X
IS
AT
MOST
A
TIMES
THE
SIZE
OF
THE
SUBTREE
ROOTED
AT
X
AND
THE
SIZE
OF
THE
RIGHT
SUBTREE
OF
X
IS
AT
MOST
A
TIMES
THE
SIZE
OF
THE
SUBTREE
ROOTED
AT
X
CONSIDER
A
BINARY
SEARCH
TREE
WITH
STANDARD
INSERT
AND
DELETE
OPERATIONS
WITH
THE
FOLLOWING
EXCEPTION
LET
X
BE
THE
HIGHEST
NODE
THAT
IS
NO
LONGER
BALANCED
THEN
EVERY
NODE
IN
THE
SUBTREE
ROOTED
AT
X
IS
MADE
BALANCED
YOU
MAY
ASSUME
WITHOUT
JUSTI
CATION
THAT
THE
TIME
REQUIRED
IS
LINEAR
IN
THE
SIZE
OF
THE
TREE
ROOTED
AT
X
SHOW
USING
THE
FOLLOWING
POTENTIAL
FUNCTION
THAT
THE
AMORTIZED
TIME
FOR
N
INSERT
AND
DELETE
OPERATIONS
IS
O
LOG
N
DE
NE
X
TO
BE
THE
ABSOLUTE
VALUE
OF
THE
DI
ERENCE
IN
THE
SIZE
OF
THE
LEFT
SUBTREE
OF
NODE
X
AND
THE
RIGHT
SUBTREE
OF
NODE
X
THEN
THE
POTENTIAL
FUNCTION
X
F
C
X
X
X
START
BY
EXPLAINING
HOW
A
POTENTIAL
FUNCTION
ARGUMENT
WORKS
IN
THIS
SETTING
AND
WHAT
YOU
NEED
TO
PROVE
IN
ORDER
TO
ESTABLISH
O
LOG
N
AMORTIZED
TIME
STATE
AND
PROVE
THE
MASTER
THEOREM
FOR
RECURRENCES
OF
THE
FORM
T
N
AT
N
B
NK
FOR
INTEGER
CONSTANTS
A
B
AND
K
YOU
ARE
GIVEN
THE
EXCHANGES
RATES
BETWEEN
N
DI
ERENT
CURRENCIES
GIVE
AN
O
TIME
ALGORITHM
TO
DETERMINE
WHETHER
YOU
CAN
MAKE
MONEY
MONEY
VIA
ARBITRAGE
ASSUME
NO
COSTS
FOR
CONVERSION
BETWEEN
CURRENCIES
PROVE
THE
CORRECTNESS
OF
THIS
ALGORITHM
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
FOR
MOST
OF
THE
PROBLEMS
I
AM
INTERESTED
IN
TESTING
WHETHER
YOU
UNDERSTAND
THE
TECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IF
I
ASK
YOU
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
TO
PROVE
THAT
A
PROBLEM
IS
NP
HARD
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
IF
I
ASK
YOU
PROBLEM
THAT
A
GREEDY
ALGORITHM
IS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECI
CS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECI
C
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECI
CS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETED
AS
I
DON
T
KNOW
FALSE
OR
COMPLETELY
UNSUBSTANTIATED
ASSERTIONS
WILL
RECEIVE
LESSER
CREDIT
SOLVE
UP
TO
OF
THE
PROBLEMS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
SOLVING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
IN
THE
KNAPSACK
PROBLEM
THE
INPUT
CONSISTS
OF
THE
WEIGHTS
WN
AND
VALUES
VN
OF
N
COINS
AND
A
WEIGHT
LIMIT
W
A
FEASIBLE
SOLUTION
IS
A
SUBSET
OF
THE
COINS
OF
AGGREGATE
WEIGHT
AT
MOST
W
THE
OBJECTIVE
IS
TO
MAXIMIZE
THE
AGGREGATE
VALUE
GIVE
AN
O
NW
TIME
AND
O
N
W
SPACE
ALGORITHM
TO
COMPUTE
THE
OPTIMAL
SOLUTION
TO
THIS
OPTIMIZATION
PROBLEM
NOTE
THAT
THE
ALGORITHM
NEEDS
TO
OUTPUT
THE
ACTUAL
SUBJECT
OF
COINS
NOT
JUST
THE
SUBSET
AGGREGATE
WEIGHT
AND
VALUE
IN
THE
KNAPSACK
PROBLEM
THE
INPUT
CONSISTS
OF
THE
WEIGHTS
WN
AND
VALUES
VN
OF
N
COINS
AND
A
WEIGHT
LIMIT
W
A
FEASIBLE
SOLUTION
IS
A
SUBSET
OF
THE
COINS
OF
AGGREGATE
WEIGHT
AT
MOST
W
THE
OBJECTIVE
IS
TO
MAXIMIZE
THE
AGGREGATE
VALUE
ASSUME
YOU
HAVE
AN
O
NW
TIME
DYNAMIC
PROGRAMMING
ALGORITHM
THAT
SOLVES
THIS
PROBLEM
SHOW
HOW
TO
DERIVE
A
POLYNOMIAL
TIME
APPROXIMATION
SCHEME
FOR
THE
KNAPSACK
PROBLEM
START
BY
DE
NING
POLYNOMIAL
TIME
APPROXIMATION
SCHEME
NOTE
THAT
YOU
NEED
NOT
HAVE
ANSWERED
THE
PREVIOUS
PROBLEM
IN
ORDER
TO
ANSWER
THIS
PROBLEM
YOU
MUST
HAVE
SOME
REASONABLE
JUSTI
CATION
THAT
YOU
INDEED
HAVE
GIVEN
A
POLYNOMIAL
TIME
APPROXIMATION
SCHEME
CONSIDER
A
SETTING
WHERE
YOU
HAVE
TWO
COMPUTER
NETWORKING
ROUTERS
A
AND
B
EACH
ROUTER
HAS
COLLECTED
A
LIST
LA
AND
LB
OF
IP
SOURCE
ADDRESSES
FOR
THE
PACKETS
THAT
HAVE
PASSED
THROUGH
THE
ROUTER
THAT
DAY
AN
IP
ADDRESS
IS
N
BITS
AND
THUS
THERE
ARE
POSSIBLE
IP
ADDRESSES
NOW
THE
TWO
ROUTERS
WANT
TO
COMMUNICATE
VIA
A
TWO
WAY
CHANNEL
ASSUME
THERE
IS
NO
DELAY
OF
MESSAGES
TO
DETERMINE
WHETHER
THERE
WAS
SOME
SOURCE
THAT
SENT
A
PACKET
THROUGH
ONE
OF
THE
ROUTERS
BUT
NOT
THE
OTHER
PROVE
USING
AN
ADVERSARIAL
ARGUMENT
THAT
EVERY
DETERMINISTIC
PROTOCOL
FOR
THIS
PROBLEM
MUST
SENT
O
BITS
FOR
SOME
POSSIBLE
INSTANCE
ASSUME
THAT
YOU
HASH
N
ITEMS
INTO
A
CLOSED
ADDRESSED
HASH
TABLE
OF
SIZE
N
WITH
THE
PROBABILITY
THAT
EACH
ITEM
HASHES
TO
A
PARTICULAR
TABLE
ENERGY
IS
N
INDEPENDENT
OF
WHERE
THE
OTHER
ITEMS
HASH
LET
XI
BE
THE
NUMBER
OF
ITEMS
THAT
HASH
TO
TABLE
ENTRY
I
SHOW
THAT
K
N
NE
E
MAXI
XI
O
LOG
N
LOG
LOG
N
YOU
MAY
USE
WITHOUT
PROOF
THE
FACT
THAT
K
K
CONSIDER
THE
FOLLOWING
ONLINE
PROBLEM
YOU
GIVEN
A
SEQUENCE
OF
BITS
BN
OVER
TIME
EACH
BIT
IS
IN
AN
ENVELOPE
YOU
RST
SEE
THE
ENVELOPE
FOR
THEN
THE
ENVELOPE
FOR
ETC
WHEN
YOU
GET
THE
ENVELOPE
I
YOU
CAN
EITHER
LOOK
INSIDE
TO
SEE
THE
BIT
OR
DESTROY
THE
ENVELOPE
IN
WHICH
CASE
YOU
WILL
NEVER
KNOW
WHAT
THE
BIT
IS
YOU
KNOW
A
PRIORI
THAT
AT
LEAST
N
OF
THE
BITS
ARE
YOU
GOAL
IS
TO
ND
AN
ENVELOPE
CONTAINING
A
BIT
YOU
WANT
TO
OPEN
AS
FEW
ENVELOPES
AS
POSSIBLE
SHOW
USING
YAO
TECHNIQUE
THAT
EVERY
RANDOMIZED
MONTE
CARLO
ALGORITHM
FOR
THIS
PROBLEM
THAT
FAILS
WITH
PROBABILITY
AT
MOST
N
MUST
OPEN
O
LOG
N
ENVELOPES
IN
EXPECTATION
START
BY
STATING
CLEARLY
THE
VERSION
OF
YAO
TECHNIQUE
THAT
IS
APPLICABLE
HERE
YOU
DO
NOT
NEED
TO
PROVE
THE
CORRECTNESS
OF
THIS
VERSION
OF
YAO
TECHNIQUE
CONSIDER
A
TWO
PERSON
GAME
SPECI
ED
BY
AN
M
BY
N
PAYO
MATRIX
P
NOTE
THAT
SOME
ENTRIES
COULD
BE
NEGATIVE
THE
TWO
PLAYERS
CAN
BE
THOUGHT
OF
AS
A
ROW
PLAYER
AND
A
COLUMN
PLAYER
THE
NUMBER
OF
POSSIBLE
MOVES
FOR
THE
ROW
PLAYER
IS
M
AND
THE
NUMBER
OF
POSSIBLE
MOVES
FOR
THE
COLUMN
PLAYER
IS
N
EACH
PLAYER
PICKS
A
PROBABILITY
DISTRIBUTION
OVER
ITS
MOVES
AND
THEN
MONEY
IS
EXCHANGED
IN
PARTICULAR
THE
ROW
PLAYER
PAYS
THE
COLUMN
PLAYER
ER
C
PR
C
DOLLARS
WHERE
THE
EXPECTATION
IS
OVER
THE
JOINT
PROBABILITY
DISTRIBUTION
OF
THE
ROW
AND
COLUMN
PLAYERS
MOVE
WE
ASSUME
THAT
THE
GAME
IS
PLAYED
SEQUENTIALLY
SO
THAT
ONE
PLAYER
SPECI
ES
HIS
PROBABILITY
DISTRIBUTION
THE
OTHER
PLAYERS
SEES
THAT
PROBABILITY
DISTRIBUTION
AND
THEN
SPECI
ES
A
RESPONSE
PROBABILITY
DISTRIBUTION
WE
WILL
ASSUME
THAT
THIS
PLAYER
MAKES
THE
BEST
POSSIBLE
RESPONSE
EACH
PLAYER
WANTS
TO
BE
PAYED
AS
MUCH
MONEY
AS
POSSIBLE
AND
IF
THIS
IS
NOT
POSSIBLE
TO
PAY
AS
LITTLE
AS
POSSIBLE
IN
EXPECTATION
A
SHOW
THAT
PROBLEM
OF
NDING
THE
BEST
PROBABILITY
DISTRIBUTION
FOR
THE
PLAYER
THAT
GOES
RST
SAY
THE
ROW
PLAYER
FOR
CONCRETENESS
CAN
BE
EXPRESSED
AS
A
LINEAR
PROGRAM
B
EXPLAIN
WHAT
LINEAR
PROGRAMMING
DUALITY
SAYS
ABOUT
HOW
THE
AMOUNT
OF
MONEY
THAT
THE
ROW
PLAYER
MAKES
IF
SHE
GOES
RST
COMPARES
TO
THE
AMOUNT
OF
MONEY
THE
ROW
PLAYER
MAKES
IF
SHE
GOES
SECOND
YOU
MUST
HAVE
SOME
JUSTI
CATION
HERE
THE
INPUT
FOR
THE
MAXIMUM
CUT
PROBLEM
IS
AN
UNDIRECTED
GRAPH
G
V
E
A
FEASIBLE
SOLUTION
IS
A
SUBSET
OF
THE
VERTICES
THE
OBJECTIVE
IS
THE
NUMBER
OF
EDGES
BETWEEN
AND
V
GIVE
A
DETERMINISTIC
ALGORITHM
FOR
THIS
OPTIMIZATION
PROBLEM
AND
SHOW
THAT
IT
IS
APPROXIMATE
INCLUDE
A
DE
NITION
OF
APPROXIMATE
THAT
IS
APPROPRIATE
FOR
THIS
SETTING
CONSIDER
THE
PAGING
PROBLEM
CONSIDER
THE
FOLLOWING
DETERMINISTIC
ONLINE
ALGORITHM
ALGORITHM
DESCRIPTION
EACH
PAGE
P
HAS
AN
ASSOCIATED
BIT
FRESH
OR
STALE
IF
REQUESTED
PAGE
P
IN
FAST
MEMORY
THEN
P
ASSOCIATED
BIT
IS
SET
TO
FRESH
IF
THE
REQUESTED
PAGE
P
IS
NOT
IN
FAST
MEMORY
THEN
AN
ARBITRARY
STALE
PAGE
IS
SELECTED
FROM
THE
STALE
PAGES
IN
FAST
MEMORY
AND
EJECTED
AND
P
ASSOCIATED
BIT
IS
SET
TO
FRESH
IF
THE
REQUEST
PAGE
P
IS
NOT
IN
FAST
MEMORY
AND
ALL
PAGES
IN
FAST
MEMORY
ARE
FRESH
THEN
MAKE
ALL
PAGES
IN
FAST
MEMORY
STALE
SELECT
AN
ARBITRARY
STALE
PAGE
FROM
THE
STALE
PAGES
IN
FAST
MEMORY
TO
EVICT
AND
P
ASSOCIATED
BIT
IS
SET
TO
FRESH
WE
WANT
TO
CONSIDER
THE
HOMEWORK
PROBLEM
THAT
SHOWED
THAT
THIS
ALGORITHM
WITH
K
PAGES
OF
FAST
MEMORY
IS
COMPETITIVE
APPROXIMATE
AGAINST
THE
OPTIMAL
ALGORITHM
FOR
K
PAGES
OF
FAST
MEMORY
USING
THE
FOLLOWING
POTENTIAL
FUNCTION
XX
F
CREDIT
P
CREDIT
P
P
ON
P
OP
T
WHERE
ON
IS
THE
ALGORITHM
CACHE
AND
OP
T
IS
THE
ADVERSARY
OPTIMAL
CACHED
AND
CREDIT
P
IS
EQUAL
TO
IF
PAGE
P
IS
IN
THE
ALGORITHM
FAST
MEMORY
AND
IS
FRESH
AND
CREDIT
P
OTHERWISE
A
WRITE
THE
KEY
EQUATION
THAT
YOU
NEED
TO
SHOW
HOLDS
FOR
EVERY
ACCESS
B
IDENTIFY
THE
CASE
WHERE
YOU
NEED
TO
USE
THE
ASSUMPTION
THAT
THE
ALGORITHM
CACHE
IS
TWICE
AS
LARGE
AS
THE
ADVERSARIAL
OPTIMAL
CACHE
AND
SHOW
THAT
THE
KEY
EQUATION
HOLDS
IN
THIS
CASE
SHOW
THAT
THE
COLORING
PROBLEM
IS
NP
HARD
USING
A
REDUCTION
FROM
CNFSAT
RECALL
THE
THE
INPUT
FOR
THE
COLORING
PROBLEM
IS
AN
UNDIRECTED
GRAPH
AND
THE
QUESTION
IS
WHETHER
EACH
VERTEX
CAN
BE
COLORED
WITH
OF
POSSIBLE
COLORS
SO
THAT
NO
PAIR
OF
ADJACENT
VERTICES
ARE
COLORED
THE
SAME
COLOR
RECALL
THAT
INPUT
TO
THE
CNFSAT
PROBLEM
IS
A
BOOLEAN
FORMULA
IN
CONJUNCTIVE
NORMAL
FORM
AND
OF
OR
OF
VARIABLES
OR
NEGATION
OF
VARIABLES
WITH
EXACTLY
LITERALS
PER
CLAUSE
YOU
MAY
ASSUME
THE
EXISTENCE
OF
A
GRAPH
WITH
THE
FOLLOWING
SPECIAL
PROPERTY
HAS
DESIGNATED
VERTICES
X
Y
Z
AND
T
AND
IS
COLORABLE
IF
AND
ONLY
IF
AT
LAST
ONE
OF
X
Y
OR
Z
IS
COLORED
THE
SAME
COLOR
AS
T
IS
COLORED
SHOW
USING
LINEARITY
OF
EXPECTATIONS
THAT
THE
EXPECTED
RUNNING
TIME
OF
RANDOMIZED
QUICK
SORT
WHERE
THE
SPLITTER
PIVOT
IS
PICKED
UNIFORMLY
AT
RANDOM
FROM
THE
SUBARRAY
BEING
SORTED
IS
O
N
LOG
N
MAKE
SURE
TO
CLEARLY
DE
NE
YOUR
VARIABLES
CONSIDER
THE
FORD
FULKERSON
ALGORITHM
FOR
NETWORK
OW
ON
A
GRAPH
NETWORK
WITH
V
VERTICES
E
EDGES
AND
MAXIMUM
OW
F
WE
GAVE
AN
ALGORITHM
A
WITH
WORST
CASE
RUNNING
TIME
T
FE
WE
GAVE
AN
ALGORITHM
B
WITH
WORST
CASE
RUNNING
TIME
T
WE
GAVE
AN
ALGORITHM
C
WITH
WORST
CASE
RUNNING
TIME
T
VE
LOG
F
STATE
WITH
JUSTI
CATION
WHICH
OF
THESE
ALGORITHMS
ARE
POLYNOMIAL
TIME
ALGORITHMS
WHICH
ARE
STRONGLY
POLYNOMIAL
TIME
ALGORITHMS
AND
WHICH
ARE
PSEUDO
POLYNOMIAL
TIME
ALGORITHMS
YOU
SHOULD
START
WITH
A
DE
NITION
OF
POLYNOMIAL
TIME
ALGORITHM
STRONGLY
POLYNOMIAL
TIME
ALGORITHM
AND
PSEUDO
POLYNOMIAL
TIME
ALGORITHM
THE
INPUT
TO
THE
VERTEX
COVER
PROBLEM
IS
AN
UNDIRECTED
GRAPH
G
THE
FEASIBLE
SOLUTIONS
ARE
SUBSETS
OF
VERTICES
SUCH
THAT
EVERY
EDGE
IS
INCIDENT
ON
AT
LEAST
ONE
VERTEX
IN
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
NUMBER
NUMBER
OF
VERTICES
IN
A
EXPLAIN
HOW
TO
EXPRESS
THIS
PROBLEM
AS
A
INTEGER
LINEAR
PROGRAM
B
EXPLAIN
HOW
TO
USE
THE
RELAXED
LINEAR
PROGRAM
WHERE
VARIABLES
ARE
ALLOWED
TO
BE
NON
INTEGER
RATIONAL
NUMBERS
TO
DEVELOP
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THIS
PROBLEM
THAT
IS
APPROXIMATE
YOU
MUST
JUSTIFY
THAT
THE
ALGORITHM
IS
APPROXIMATE
GIVE
A
DE
NITION
OF
APPROXIMATE
THAT
IS
APPROPRIATE
FOR
THIS
SETTING
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
FORMOST
OF
THEPROBLEMS
I
AMINTERESTEDINTESTING
WHETHERYOUUNDERSTAND
THETECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IFI
ASKYOUTOPROVETHAT
APROBLEMISNP
HARD
I
AM
MOREINTERESTEDINLEARNINGIF
YOUKNOWHOWTOPROVETHATAPROBLEMISNP
HARD
THANI
AMINTHE
SPECIFCS
OFTHEPROBLEM
IFI
ASKYOUPROBLEMTHAT
AGREEDY
ALGORITHMIS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECIFCS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECIFC
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECIFCS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETEDAS
IDON
TKNOW
FALSEORCOMPLETELYUNSUBSTANTIATED
ASSERTIONSWILL
RECEIVELESSER
CREDIT
SOLVE
UP
TO
OF
THE
PROBLEMS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
SOLVING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
GIVE
A
POLYNOMIAL
TIME
DYNAMIC
PROGRAMMING
ALGORITHM
TO
COMPUTE
THE
SHORTEST
BITONIC
TOUR
OF
N
POINTS
IN
THE
EUCLIDEAN
PLANE
RECALL
THAT
A
BITONIC
TOUR
STARTS
AT
THE
LEFTMOST
POINT
MOVES
RIGHT
UNTIL
IS
HITS
THE
RIGHTMOST
POINT
AND
THEN
MOVES
LEFT
UNTIL
IT
RETURNS
TO
THE
LEFTMOST
POINT
GIVEAGREEDY
ALGORITHMFORTHEFOLLOWINGPROBLEM
ANDPROVE
USING
AN
EXCHANGEARGUMENT
THATTHISALGORITHMISCORRECT
THEINPUTTOTHISPROBLEM
CONSISTS
OF
N
JOBS
FOR
EACHJOB
J
YOU
AREGIVEN
A
RELEASETIME
RJ
AND
A
PROCESSING
TIME
PJ
THE
OUTPUT
IS
A
FEASIBLE
SCHEDULE
THAT
MINIMIZESTHE
AVERAGE
COMPLETIONTIME
OF
AJOB
AFEASIBLEPREEMPTIVE
SCHEDULEIS
A
MAPPING
FROM
EACH
TIME
T
TO
AJOB
RELEASEDBEFORETIME
T
THAT
IS
BEING
PROCESSED
AT
TIME
T
AJOB
J
IS
COMPLETED
ONCE
IT
HAS
BEEN
PROCESSED
FOR
PJ
UNITS
OF
TIME
PROVE
THAT
THE
SUBSET
SUM
PROBLEM
IS
NP
HARD
BY
REDUCTION
FROM
VERTEX
COVER
OR
BY
REDUCTION
FROM
SAT
RECALL
THAT
THE
SUBSET
SUM
PROBLEM
TAKES
AS
INPUT
POSITIVE
INTEGERS
XN
L
AND
ASKS
WHETHER
THERE
IS
A
SUBSET
OF
THE
XI
THAT
SUMS
TO
L
RECALL
THAT
THE
INPUT
TO
THEVERTEXCOVERPROBLEMIS
AGRAPH
G
AND
AN
INTEGER
K
AND
THEQUESTION
IS
TO
DETERMINE
WHETHER
G
HAS
A
VERTEX
COVER
OF
SIZE
K
A
VERTEX
COVER
IS
A
COLLECTION
OF
VERTICES
SUCH
THAT
EVERY
EDGEISINCIDENT
ON
ATLEAST
ONE
VERTEXINTHE
COLLECTION
RECALL
THAT
THE
INPUT
TO
THE
SATPROBLEMIS
ABOOLEAN
FORMULAIN
CONJUNCTIVE
NORMAL
FORM
WITH
EXACTLY
CLAUSE
AND
THEQUESTIONISTODETERMINEIF
THEFORMULAIS
SATISFABLE
GIVEANADVERSARIAL
ARGUMENTTOSHOWTHAT
EVERY
COMPARISONBASED
ALGORITHMTODETERMINE
WHETHER
N
INPUT
NUMBERS
ARE
DISTINCT
REQUIRES
N
LOGN
COMPARISONS
CALCULATE
THE
EXPECTED
TIME
TO
INSERT
N
ITEMS
INTO
A
HASH
TABLE
OF
SIZE
N
USING
UNIFORM
OPEN
HASHING
WHICH
MEANS
THAT
EACH
PROBE
INTO
THE
HASH
TABLE
IS
EQUALLY
LIKELY
TO
GO
TO
EVERY
TABLE
ENERGY
INDEPENDENT
OF
OTHER
PROBES
SHOWTHATIF
N
ITEMS
AREINSERTEDINTO
A
CLOSED
ADDRESSEDHASH
TABLE
OF
SIZE
N
THEN
EXPECTED
NUMBER
OF
ITEMS
IN
THE
TABLE
ENTRY
WITH
MOST
ITEMS
IS
O
LOGN
STATE
EXPLAIN
HOW
THE
PUSH
RELABEL
NETWORK
FOW
ALGORITHM
WORKS
YOU
DO
NOT
NEED
TO
PROVETHATITIS
CORRECT
OR
ANALYZETHE
RUNNING
TIME
JUST
STATETHE
ALGORITHM
CONSIDER
THE
PROBLEM
OF
CONSTRUCTING
A
MAXIMUM
CARDINALITY
BIPARTITE
MATCHING
THE
INPUT
IS
A
BIPARTITE
GRAPH
WHERE
ONE
BIPARTITION
ARE
THE
GIRLS
AND
ONE
BIPARTITION
IS
THE
BOYS
THERE
IS
AN
EDGE
BETWEEN
A
BOY
AND
A
GIRL
IF
THEY
ARE
WILLING
TO
DANCE
TOGETHER
THE
PROBLEM
IS
TO
MATCHING
THE
BOYS
AND
GIRLS
FOR
ONE
DANCE
SO
THAT
AS
MANY
COUPLES
ARE
DANCING
AS
POSSIBLE
A
CONSTRUCT
AN
INTEGER
LINEAR
PROGRAM
FOR
THIS
PROBLEM
B
CONSIDERTHEASSOCIATEDLINEARPROGRAMWHERETHEINTEGRALITYREQUIREMENTSAREDROPPED
EXPLAIN
HOW
TO
FND
AN
INTEGER
OPTIMAL
SOLUTION
FROM
ANY
RATIONAL
OPTIMAL
SOLUTION
C
CONSTRUCT
THE
DUAL
PROGRAM
D
GIVE
A
NATURAL
ENGLISH
INTERPRETATION
OF
THE
DUAL
PROBLEM
E
EXPLAINHOWONECANALWAYSGIVEASIMPLEPROOF
THAT
AGRAPHDOESN
THAVEAMATCHING
OF
A
PARTICULAR
SIZE
USING
THE
DUAL
USING
LINEAR
PROGRAMMING
DUALITY
YOU
SHOULD
BE
ABLE
TO
COME
UP
WITH
A
METHOD
THAT
WOULD
CONVINCE
SOMEONE
WHO
KNOWS
NOTHING
ABOUT
LINEARPROGRAMMING
CONSIDER
AN
ONLINE
OR
APPROXIMATION
PROBLEM
WHERE
THERE
ARE
ONLY
FNITELY
MANY
POSSIBLE
ALGORITHMSAND
FNITELY
MANYPOSSIBLEINPUTS
WECONSIDERGENERALIZINGYAO
STECHNIQUETO
APPROXIMATION
RATIOS
ASSUMETHATTHEPROBLEMIS
A
MINIMIZATIONPROBLEM
ASSUMETHAT
YOU
HAVE
AN
INPUT
DISTRIBUTION
I
SUCH
THAT
FOR
ALL
DETERMINISTIC
ALGORITHMS
A
IT
IS
THE
CASE
THAT
E
A
I
E
OPT
I
C
SHOWTHATYOU
CANLOGICALLY
CONCLUDETHATTHE
EXPECTED
APPROXIMATION
RATIO
FOR
EVERY
RANDOMIZED
ALGORITHM
IS
AT
LEAST
C
ASSUME
THAT
YOU
WANT
TO
LOAD
N
CRATES
WITH
WEIGHTS
WN
ONTO
K
TRUCKS
SO
AS
TO
MINIMIZE
THE
WEIGHT
OF
THE
HEAVIEST
LOAD
ON
ANY
ONE
TRUCK
CONSIDER
THE
ALGORITHM
THAT
CONSIDERS
THE
CRATES
IN
AN
ARBITRARY
ORDER
AND
PUTS
THE
NEXT
CRATE
ON
THE
TRUCK
WITH
THE
LIGHTEST
LOAD
TO
DATE
SHOW
THAT
THE
APPROXIMATION
RATIO
FOR
THIS
ALGORITHM
IS
AT
MOST
EXPLICITLY
STATE
WHAT
LOWER
BOUNDS
YOU
ARE
USING
FOR
OPTIMAL
ASSUME
THAT
WE
HAVE
A
DYNAMIC
TABLE
TO
WHICH
WE
CAN
INSERT
AND
DELETE
ITEMS
LET
US
SAY
THAT
EACH
OF
INSERTION
AND
DELETION
COSTS
WHEN
THE
TABLE
IS
FULL
THE
TABLE
SIZE
IS
DOUBLED
IF
THE
TABLE
IS
DOUBLED
FROM
SIZE
N
TO
SIZE
THEN
LET
US
SAY
THAT
THIS
COSTS
WHEN
THE
TABLE
IS
FULL
THE
TABLE
SIZE
IS
HALVED
IF
THE
TABLE
IS
HALVED
FROM
SIZE
TO
SIZE
N
THEN
LET
US
SAY
THAT
THIS
COSTS
PROVE
USING
A
POTENTIAL
FUNCTION
ARGUMENT
THAT
THE
AMORTIZED
COST
PER
INSERTION
AND
DELETION
OPERATION
IS
O
RECALL
THAT
THE
INPUT
TO
THE
KNAPSACK
PROBLEM
WAS
N
COINS
WITH
POSITIVE
INTEGER
WEIGHTS
WN
POSITIVE
INTEGER
VALUES
VN
AND
A
WEIGHT
LIMIT
W
THE
PROBLEM
WAS
TO
FND
A
SUBSET
OF
THE
COINS
WITH
MAXIMUM
AGGREGATE
VALUE
SUBJECT
TO
THE
CONSTRAINT
THAT
THE
AGGREGATE
WEIGHT
IS
AT
MOST
W
GIVE
AN
ALGORITHM
TO
SOLVE
THIS
PROBLEM
IN
O
W
SPACE
AND
O
NW
TIME
YOU
MUSTJUSTIFY
THE
CORRECTNESSOF
THE
CLAIMED
TIMEAND
SPACEBOUNDS
NOTETHATTHE
ALGORITHM
MUSTPRODUCETHE
ACTUAL
SUBSET
OF
COINS
NOTJUSTTHE
WEIGHT
AND
THE
VALUE
AN
ALGORITHM
THAT
SOLVES
THIS
PROBLEM
USING
MORE
TIME
OR
MORE
SPACE
IS
NOT
WORTH
ANY
PARTIAL
CREDIT
CONSIDER
THE
PAGING
PROBLEM
WHERE
THERE
ARE
K
PAGES
OF
FAST
MEMORY
AND
N
K
PAGES
OF
SLOWMEMORY
SOANONLINEALGORITHMSEESOVERTIMEASEQUENCEOF
REQUESTSTOPAGESINSLOW
MEMORY
IF
THEPAGE
REQUESTEDISNOTINFAST
MEMORY
THENAPAGEFAULT
OCCURS
INRESPONSE
TO
A
PAGE
FAULT
THE
ONLINE
ALGORITHM
HAS
TO
EVICT
A
PAGE
OF
ITS
CHOICE
FROM
FAST
MEMORY
AND
COPY
THE
REQUESTED
PAGE
TO
FAST
MEMORY
THE
OBJECTIVE
IS
TO
MINIMIZE
THE
NUMBER
OF
ACCESSES
TO
SLOW
MEMORY
SHOW
THAT
THE
PAGING
ALGORITHM
FIFO
WITH
A
FAST
MEMORY
OF
SIZE
K
HAS
AT
MOST
TWICE
AS
MANY
PAGE
FAULTS
AS
THE
OPTIMAL
PAGING
ALGORITHM
WITH
A
FAST
MEMORY
OF
SIZE
K
RECALL
THAT
FIFO
EVICTS
THE
PAGE
THAT
ENTERED
FAST
MEMORY
AT
THE
EARLIESTPOINT
IN
TIME
STATEANDPROVETHE
MASTERTHEOREM
FORDIVIDEAND
CONQUERRECURRENCERELATIONS
RECALL
THAT
THEMASTERTHEOREMGIVESTHE
SOLUTION
TO
RECURRENCES
OF
THEFORM
T
N
AT
N
B
NK
FOR
CONSTANTS
A
B
AND
K
FINAL
COMPUTER
SCIENCE
INTRODUCTION
TO
ALGORITHMS
SPRING
INSTRUCTIONS
THE
TEST
IS
CLOSED
BOOK
CLOSED
NOTES
IFYOUARETAKING
THE
FNALFORPRELIMINARY
EXAMCREDIT
THENWRITEYOURPRELIMINARY
NUMBER
GIVEN
TO
YOU
BY
KEENA
ON
THE
EXAM
ANSWER
SHEET
BUT
DO
NOT
WRITE
YOUR
NAME
IF
YOU
ARE
NOTTAKING
THE
FNALFORPRELIMINARY
EXAMCREDIT
WRITEYOURNAMEONTHEEXAMANSWERSHEET
IFYOUARETAKING
THECOURSEFOR
SOMEGRADING
OPTION
OTHERTHANTHESTANDARDLETTERGRADING
OPTION
PLEASE
SPECIFY
THAT
ON
YOUR
EXAM
ANSWER
SHEET
FORMOST
OF
THEPROBLEMS
I
AMINTERESTEDINTESTING
WHETHERYOUUNDERSTAND
THETECHNIQUES
AND
CONCEPTS
MORE
THAN
I
AM
INTERESTED
IN
THE
SOLUTION
TO
THE
PARTICULAR
PROBLEM
FOR
EXAMPLE
IFI
ASKYOUTOPROVETHAT
APROBLEMISNP
HARD
I
AM
MOREINTERESTEDINLEARNINGIF
YOUKNOWHOWTOPROVETHATAPROBLEMISNP
HARD
THANI
AMINTHE
SPECIFCS
OFTHEPROBLEM
IFI
ASKYOUPROBLEMTHAT
AGREEDY
ALGORITHMIS
CORRECT
USING
AN
EXCHANGE
ARGUMENT
I
AM
MORE
INTERESTED
IN
LEARNING
IF
YOU
KNOW
HOW
AN
EXCHANGE
ARGUMENT
WORKS
THAN
I
AM
IN
THE
SPECIFCS
OF
THE
PROBLEM
I
ASK
THESE
QUESTIONS
IN
THE
CONTEXT
OF
SPECIFC
PROBLEMS
TO
ALLOW
YOU
TO
DEMONSTRATE
YOUR
UNDERSTANDING
IN
A
CONCRETE
SETTING
OF
COURSE
YOU
HAVE
TO
TAKE
INTO
ACCOUNT
THE
SPECIFCS
OF
THE
PROBLEM
BUT
MAKE
SURE
TO
EXPLAIN
THE
GENERAL
METHOD
TECHNIQUE
CONCEPT
THAT
YOU
ARE
USING
AS
WELL
PARTIAL
CREDIT
IS
GIVEN
FOR
THE
ANSWER
I
DON
T
KNOW
A
BLANK
ANSWER
WILL
BE
INTER
PRETEDAS
IDON
TKNOW
FALSEORCOMPLETELYUNSUBSTANTIATED
ASSERTIONSWILL
RECEIVELESSER
CREDIT
SOLVE
UP
TO
OF
THE
PROBLEMS
CLEARLY
WRITE
THE
NUMBER
OF
THE
PROBLEM
THAT
YOU
ARE
SOLVING
IF
YOU
ANSWER
MORE
THAN
AN
ARBITRARY
ANSWERS
WILL
BE
GRADED
IF
YOU
ARE
UNCERTAIN
ABOUT
ANYTHING
ASK
A
QUESTION
TWO
OF
THE
THREE
FOLLOWING
DEFNITIONS
OF
BIG
OMEGA
AREA
LOGICALLY
EQUIVALENT
IDENTIFY
THE
TWO
THAT
ARE
LOGICALLY
EQUIVALENT
AND
PROVE
THAT
THEY
ARE
EQUIVALENT
TAKE
CARE
IN
YOUR
EXPOSITION
PROVE
THAT
THE
THIRDDEFNITIONIS
NOT
LOGICALLY
EQUIVALENTTO
THE
OTHER
TWO
YOU
MAY
ASSUME
THAT
WE
ARE
ONLY
CONSIDERINGFUNCTIONS
THAT
AREDEFNED
ON
THEPOSITIVEINTEGERS
AND
ARE
POSITIVE
AND
NON
DECREASING
A
F
N
G
N
I
N
F
N
CG
N
B
F
N

G
N
I
N
CG
N
C
F
N
O
G
N
I
N
F
N
CG
N
GIVE
AS
SIMPLE
ESTIMATES
AS
YOU
CAN
OF
THE
FOLLOWING
SUMS
THAT
ARE
ACCURATE
TO
WITHIN
A
MULTIPLICATIVE
CONSTANT
YOU
DO
NOT
NEED
TO
FULLY
PROVE
THE
CORRECTNESS
OF
EACH
OF
YOUR
ANSWERS
BUTGIVE
SOME
CONVINCINGJUSTIFCATIONFORYOUR
ANSWERS
A
P
X
I
LOGLOGI
I
B
X
LOG
N
I
LOGI
LOGLOGI
C
LOG
LOG
N
X
I
D
P
N
X
I
SHOW
THAT
THE
EXPECTED
CASE
RUNNING
TIME
OF
RANDOMIZED
QUICKSORT
IS
O
N
LOGN
USING
LINEARITY
OF
EXPECTATION
ASSUME
THAT
THE
SPLITTER
IS
PICKED
UNIFORMLY
AT
RANDOM
FROM
THE
SUBARRAY
IN
QUESTION
CONSIDER
THE
O
INE
PAGING
PROBLEM
WHERE
THERE
ARE
K
PAGES
OF
FAST
MEMORY
AND
K
PAGES
OF
SLOW
MEMORY
THE
INPUT
IS
AN
SEQUENCE
OF
REQUESTS
TO
PAGES
IN
SLOW
MEMORY
IF
THE
PAGE
REQUESTED
IS
TO
THE
UNIQUE
PAGE
THAT
IS
NOT
IN
FAST
MEMORY
THEN
A
PAGE
FAULT
OCCURS
IN
RESPONSE
TO
A
PAGE
FAULT
THE
O
INE
ALGORITHM
HAS
TO
EVICT
A
PAGE
OF
ITS
CHOICE
FROMFAST
MEMORY
AND
COPY
THEREQUESTEDPAGETOFAST
MEMORY
GIVETHE
O
INEALGORITHM
THAT
MINIMIZES
THE
NUMBER
OF
PAGE
FAULTS
PROVE
THAT
THIS
ALGORITHM
IS
CORRECT
OPTIMAL
USING
AN
EXCHANGE
ARGUMENT
CONSIDERTHEFOLLOWINGENERGY
MANAGEMENTPROBLEMFACEDBY
ACITY
THECITY
OWNSAHYDRO
ELECTRICDAMTHAT
CANGENERATE
UP
TO
M
MEGAWATT
HOURS
OF
ELECTRICYPERDAY
AT
A
COST
OF
L
DOLLARS
EVEN
IF
LESS
THAN
M
MEGAWATT
HOURS
IS
GENERATED
THE
COST
IS
STILL
L
ADDITIOALLY
ON
EACH
DAY
THE
CITY
CAN
BUY
ADDITIONAL
ELECTRICITY
FOR
C
DOLLARS
PER
MEGAWATT
HOUR
THE
CITY
CAN
STORE
UNUSED
ENERGY
IN
BATTERIES
THAT
HAVE
A
CAPACITY
OF
B
MEGAWATT
HOURS
BUT
THIS
COSTS
H
DOLLARS
PER
MEGAWATT
HOUR
PER
DAY
THE
CITY
KNOWS
ITS
ENERGY
NEEDS
FOR
N
CONSECUTIVE
DAYS
ARE
DN
MEGAWATT
HOURS
GIVE
AN
ALGORITHM
THAT
COMPUTES
THE
OPTIMAL
LEAST
COST
ENERGY
GENERATION
SCHEDULE
THAT
MEETS
THE
CITY
ENERGY
NEEDS
ON
EACH
DAY
THIS
SCHEDULE
NEEDS
TO
SPECIFY
ON
EACH
DAY
HOW
MUCH
ENERGY
TO
GENERATE
FROM
THE
DAM
HOW
MUCH
ENERGY
TO
BUY
HOW
MUCH
ENERGY
TO
TAKE
OUT
OF
THE
BATTERIES
AND
HOW
MUCH
ENERGY
TO
STORE
IN
THE
BATTERY
THE
ALGORITHM
RUNNING
TIME
SHOULD
BE
POLYNOMIAL
IN
N
AND
B
ASSUME
ALLPARAMETERS
AREPOSITIVEINTEGERS
NOTE
THATFOR
SIMPLICITYTHAT
EACHDAYISBEING
REPRESENTED
AS
A
POINT
IN
TIME
OBVIOUSLY
IN
REAL
LIFE
BATTERIES
COULD
BE
FLLED
EMPTIED
CONTINUOUSLY
INSTEAD
OF
DISCRETELY
CONSIDER
THE
SITUATION
WHERE
YOU
HAVE
A
WEB
SERVER
RUNNING
OVER
N
DAYS
ON
SOME
DAYS
THE
SERVER
IS
UP
AND
RUNNING
AND
ON
OTHER
DAYS
THE
SERVER
IS
DOWN
THERE
EVENTS
ARE
NOT
BERNOULLI
TRIALS
THERE
MAY
BE
DEPENDENCE
BETWEEN
THE
SERVER
STATES
ON
VARIOUS
DAYS
LET
XI
BE
THE
RANDOM
VARIABLE
DENOTING
THE
NUMBER
OF
CONSECUTIVE
DAYS
THAT
THE
SERVER
IS
UP
STARTING
FROM
DAY
I
I
N
ALL
YOU
KNOW
IS
THAT
FOR
ALL
I
THE
PROBABILITY
THAT
XI
IS
MORE
THAN
K
IS
AT
CALCULATE
AS
TIGHT
OF
AN
UPPER
BOUND
AS
YOU
CAN
ON
THE
EXPECTED
VALUE
OF
MAX
XN
EXPLAIN
HOW
TO
MODIFY
DIJKSTRA
ALGORITHM
TO
COMPUTE
LONGEST
PATH
IN
GRAPHS
WITH
POSITIVE
EDGES
WEIGHTS
WHERE
NOW
THE
LENGTH
OF
A
PATH
IS
THE
MINIMUM
EDGE
WEIGHT
ON
THEPATH
SOYOUWANTTO
FNDPATH
WHERETHEMINIMUMEDGEWEIGHTISMAXIMIZED
SHOWTHATTHEPROBLEM
OF
SOLVING
ANINTEGERLINEARPROGRAMISNP
HARD
USING
THEFACTTHAT
CNF
SAT
ISNP
COMPLETE
RECALL
THAT
THE
INPUTFOR
CNF
SAT
IS
A
BOOLEANFORMULAIN
CONJUNCTIVENORMALFORM
WITH
EXACTLY
THREEDISTINCTLITERALSPER
CLAUSE
AND
THEPROBLEMIS
TO
DETERMINE
IF
THE
FORMULA
IS
SATISFABLE
SHOWTHATIFTHEREISAPOLYNOMIAL
APPROXIMATIONALGORITHMFORTHECLIQUEPROBLEM
THEN
THERE
IS
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THE
CLIQUE
PROBLEM
THE
INPUTFORTHE
CLIQUEPROBLEMISAN
UNDIRECTEDGRAPH
G
AND
THE
OUTPUT
IS
THE
LARGEST
CLIQUE
A
COLLECTION
OFMUTUALLY
ADJACENT
VERTICES
CONSIDERTHEONLINEPAGINGPROBLEMWHERETHEREARE
K
PAGES
OFFASTMEMORY
AND
K
OF
SLOW
MEMORY
SO
AN
ONLINE
ALGORITHM
SEES
OVER
TIME
A
SEQUENCE
OF
REQUESTS
TO
PAGES
IN
SLOW
MEMORY
IF
THEPAGE
REQUESTEDISTOTHE
UNIQUEPAGETHATIS
NOTINFAST
MEMORY
THEN
A
PAGE
FAULT
OCCURS
IN
RESPONSE
TO
A
PAGE
FAULT
THE
ONLINE
ALGORITHM
HAS
TO
EVICT
A
PAGE
OFITS
CHOICEFROMFAST
MEMORY
AND
COPY
THE
REQUESTEDPAGETOFAST
MEMORY
ASSUMETHAT
EACH
OF
THE
PAGES
OF
SLOW
MEMORY
IS
EQUALLY
LIKELY
TO
BE
REQUESTED
INDEPENDENT
OF
OTHER
REQUESTS
A
SHOW
THAT
FOR
EVERY
DETERMINISTIC
ONLINE
ALGORITHM
THE
EXPECTED
NUMBER
OF
REQUESTS
BETWEEN
PAGE
FAULTS
IS
K
WHAT
SORT
OF
DISTRIBUTION
DOES
THE
NUMBER
OF
REQUESTS
BETWEEN
PAGE
FAULTS
HAVE
B
SHOWTHATTHEEXPECTEDNUMBEROF
REQUESTSBETWEENPAGEFAULTSFORTHEOPTIMAL
O
INE
ALGORITHMS
IS
O
K
LOGK
C
CONCLUDETHATTHEEXPECTED
NUMBEROFPAGEFAULTSFOR
EVERYDETERMINISTICONLINEALGO
RITHM
IS
LOGK
TIMES
THE
OPTIMAL
NUMBER
OF
PAGE
FAULTS
CONSIDER
THE
PAGING
PROBLEM
WHERE
THERE
ARE
K
PAGES
OF
FAST
MEMORY
AND
K
PAGES
OF
SLOW
MEMORY
SO
AN
ONLINE
ALGORITHM
SEES
OVER
TIME
A
SEQUENCE
OF
REQUESTS
TO
PAGES
IN
SLOW
MEMORY
IF
THE
PAGE
REQUESTED
IS
TO
THE
UNIQUE
PAGE
THAT
IS
NOT
IN
FAST
MEMORY
THEN
A
PAGE
FAULT
OCCURS
IN
RESPONSE
TO
A
PAGE
FAULT
THE
ONLINE
ALGORITHM
HAS
TO
EVICT
A
PAGE
OFITSCHOICEFROMFAST
MEMORY
AND
COPY
THE
REQUESTEDPAGETOFAST
MEMORY
ASSUME
THAT
YOU
ARE
GIVEN
THAT
THERE
IS
AN
INPUT
DISTRIBUTION
SUCH
THAT
THE
EXPECTED
NUMBER
OF
PAGEFAULTSFOREVERYDETERMINISTICONLINEALGORITHMIS
LOGK
TIMESTHE
OPTIMAL
NUMBER
OF
PAGE
FAULTS
SHOW
THAT
FOR
EVERY
RANDOMIZED
ONLINE
ALGORITHM
THERE
IN
AN
INPUT
SEQUENCE
SUCH
THATTHEEXPECTED
NUMBEROFPAGEFAULTSFORTHEONLINEALGORITHMIS
LOGK
TIMES
THE
OPTIMAL
NUMBEROFPAGEFAULTS
SOBASICALLY
YOUARE
ASKED
TOREPROVETHATYAO
STECHNIQUE
WORKSINTHE
CASE
OF
APPROXIMATION
COMPETITIVE
RATIOFOR
A
MINIMIZATIONPROBLEM
CONSIDER
THE
PROBLEM
WHERE
THE
INPUT
IS
N
NUMBERS
AND
THE
OUTPUT
IS
THE
LARGEST
AND
SMALLEST
NUMBER
PROVE
USING
AN
ADVERSARIAL
ARGUMENTTHAT
EVERYDETERMINISTICCOMPARISON
BASEDALGORITHM
O
COMPARISONS
SOTHE
ONLYWAYTHE
ALGORITHM
CAN
ACCESS
THE
INPUT
IS
BY
COMPARING
TWO
NUMBERS
IN
THE
INPUT
CONSIDER
THE
PROBLEM
COMPUTING
THE
SHORTEST
TOUR
CONNECTED
N
POINTS
IN
THE
EUCLIDEAN
PLANE
GIVE
A
POLYNOMIAL
TIME
APPROXIMATION
ALGORITHM
FOR
THIS
PROBLEM
YOU
MUST
PROVE
THAT
YOUR
ALGORITHM
IS
A
APPROXIMATION
ALGORITHM
PROVETHEFACTTHAT
MAX
FOWEQUALSMIN
CUTISACONSEQUENCEOF
STRONGLINEARPROGRAMMING
DUALITY
THATTHE
OBJECTIVESFORPRIMAL
ANDDUAL
OPTIMAL
SOLUTIONS
ARETHE
SAME
CONSIDERTHEFOLLOWINGPROBLEM
THEINPUTISA
DIRECTED
GRAPH
WITHPOSITIVEWEIGHTSONTHE
EDGES
AND
A
DESIGNATED
VERTEX
THE
GOAL
IS
TO
FND
THE
LEAST
COST
SPANNING
TREE
T
ROOTED
AT
WITH
ALL
EDGES
IN
T
DIRECTED
AWAY
FROM
SO
IN
T
THERE
IS
A
UNIQUE
PATH
IN
T
FROM
TO
EACH
VERTEX
IN
THE
GRAPH
THE
COST
OF
A
TREE
T
ISJUST
THE
SUM
OF
THE
WEIGHTS
OFTHE
EDGES
EXPLAINHOWTHISPROBLEM
CANBE
SOLVEDINPOLYNOMIAL
TIME
ASSUMETHAT
WE
WANTTOPROVETHAT
AN
ONLINE
SCHEDULING
ALGORITHM
A
GUARANTEES
THAT
THE
AVERAGE
WAITING
TIMEFORFOR
AJOBIS
AT
TIMESTHE
AVERAGE
WAITING
TIMEFORSHORTEST
REMAINING
PROCESSING
TIME
SCHEDULING
ALGORITM
WHICH
IS
OPTIMAL
FOR
THE
OBJECTIVE
OF
AVERAGE
WAITING
TIME
USING
APOTENTIALFUNCTION
INTHE
MANNERTHAT
WE
USEDTO
ANALYZE
ROUND
ROBIN
STATE
WHAT
STATEMENTS
NEED
TO
BE
PROVED
IN
ORDER
TO
COMPLETE
THIS
PROOF
THEPURPOSE
OF
THISQUESTIONISTODETERMINEIFYOUKNOWHOW
APOTENTIALFUNCTION
ARGUMENT
WORKS
AFEW
REMINDERS
ABOUT
SCHEDULING
EACHJOB
I
HAS
A
RELEASE
TIME
RI
WHICH
IS
THE
EARLIEST
TIME
THAT
IT
CAN
BE
RUN
AND
A
SIZE
PI
IFJOB
I
RUNS
ON
A
SPEED
PROCESSOR
IT
WILL
COMPLETE
AFTER
RUNNING
PI
TIMEUNITS
THEWAITING
TIMEFOR
AJOB
I
IS
THE
DI
ERENECEIN
TIME
CI
RI
BETWEEN
RI
AND
WHEN
IT
IS
COMPLETED
AT
TIME
CI
THE
AVERAGE
WAITING
TIME
FOR
N
JOBS
IS
P
THEN
IN
CI
RI
N
COURSE
DESCRIPTION
THIS
WILL
BE
AN
INTERMEDIATE
LEVEL
GRADUATE
COURSE
ON
APPROXIMATION
ALGORITHMS
IN
GENERAL
THE
AREA
OF
APPROXIMATION
ALGORITHMS
DEALS
WITH
FINDING
EFFICIENT
ALGORITHMS
FOR
NP
HARD
PROBLEMS
THAT
HAVE
KNOWN
WORST
CASE
PERFORMANCE
GUARANTEES
FOR
EXAMPLE
THE
TRAVELING
SALESMAN
PROBLEM
FINDING
THE
SHORTEST
TOUR
VISITING
ALL
POINTS
IN
SOME
SPACE
IS
KNOWN
TO
BE
NP
HARD
AND
THUS
CAN
NOT
BE
SOLVED
EFFICIENTLY
FOR
ALL
INPUTS
UNLESS
P
NP
BUT
IF
THE
POINTS
ARE
IN
THE
EUCLIDEAN
PLANE
THEN
THERE
IS
AN
EFFICIENT
ALGORITHM
TO
COMPUTE
A
TOUR
THAT
IS
AT
MOST
MORE
THAN
OPTIMAL
FOR
ALL
INPUTS
WE
WILL
CONCENTRATE
ON
UNDERSTANDING
THE
MAIN
IDEAS
TECHNIQUES
AND
CONCEPTS
AT
THE
EXPENSE
OF
COVERING
ALL
DETAILS
WE
WILL
CONCENTRATE
ON
LP
BASED
ALGORITHMS
AND
IN
PARTICULAR
ON
PRIMAL
DUAL
ALGORITHMS
COURSE
TEXT
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
WE
WILL
RATHER
CLOSELY
FOLLOW
SELECTED
PORTIONS
OF
THE
EXCELLENT
TEXT
AUTHORED
BY
VIJAY
VAZIRANI
THE
TABLE
OF
CONTENTS
CAN
BE
FOUND
ON
THE
AMAZON
PAGE
FOR
THE
TEXT
THE
PREFACE
TABLE
OF
CONTENTS
AND
FIRST
CHAPTER
OF
THE
TEXT
CAN
BE
FOUND
HERE
FOR
BACKGROUND
ON
LINEAR
PROGRAMMING
I
RECOMMEND
LINEAR
PROGRAMMING
BY
VASEK
CHVATAL
IF
YOU
CAN
AFFORD
COMBINATORIAL
OPTIMATION
ALGORITHMS
AND
COMPLEXITY
BY
CHRISTOS
PAPADIMITRIOU
AND
KENNETH
STEIGLITZ
ONLY
ON
AMAZON
INCLUDING
SHIPPING
FOR
BACKGROUND
ON
BASIC
ALGORITHMICS
I
SUGGEST
INTRODUCTION
TO
ALGORITHMS
BY
THOMAS
CORMEN
RONALD
RIVEST
CHARLES
LEISERSON
AND
CLIFFORD
STEIN
COURSE
FORMAT
I
WILL
PRESENT
THE
OVERWHELMING
MAJORITY
OF
THE
LECTURES
EACH
STUDENT
WILL
GIVE
ONE
LECTURE
AT
THE
END
OF
THE
TERM
ON
SOME
PAPER
FROM
THE
AREA
OF
APPROXIMATION
ALGORITHMS
MOST
LECTURES
WILL
DEVOTED
TO
UNDERSTANDING
A
PARTICULAR
PROBLEM
AND
A
PARTICULAR
ALGORITHM
I
USE
THE
SOCRATIC
METHOD
THAT
IS
I
TRY
TO
DEVELOP
THE
IDEAS
BY
ASKING
THE
STUDENTS
LEADING
QUESTIONS
THE
GRADING
WILL
BE
BASED
ON
DAILY
HOMEWORK
AND
THE
FINAL
PRESENTATION
PREREQUISITES
THE
IDEAL
BACKGROUND
WOULD
INCLUDE
AN
INTRODUCTORY
ALGORITHMS
COURSE
SUCH
AS
CS
AND
AN
INTRODUCTORY
COURSE
ON
MATHEMATICAL
LINEAR
PROGRAMMING
MANY
OF
ALGORITHMS
COVERED
IN
THE
TEXT
USE
TECHNIQUES
NORMALLY
COVERED
IN
AN
INTRODUCTORY
LINEAR
PROGRAMMING
COURSE
HOWEVER
THE
OFFICIAL
PREREQUISITE
IS
EITHER
AN
INTRODUCTORY
ALGORITHMS
COURSE
OR
AN
INTRODUCTORY
COURSE
ON
LINEAR
PROGRAMMING
CLASS
TIME
AND
LOCATION
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
TUESDAYS
AND
THURSDAYS
FROM
TO
WE
WILL
MEET
ROOM
OF
THE
SENNOTT
SQUARE
BUILDING
NOT
ROOM
AS
LISTED
IN
THE
SCHEDULE
OF
CLASSES
TENTATIVE
SCHEDULE
INTRODUCTION
CLASSES
APPROXIMATION
ALGORITHMS
WITH
EXPLICIT
LOWER
BOUND
EXAMPLES
APPROXIMATE
MST
ALGORITHM
FOR
TSP
APPROXIMATE
MATCHING
ALGORITHM
FOR
VERTEX
COVER
AND
APPROXIMATE
LP
ALGORITHM
FOR
VERTEX
COVER
READING
CHAPTERS
AND
HOMEWORK
PROBLEM
AND
FROM
VAZIRANI
ASSUME
YOU
HAVE
A
POLYNOMIAL
TIME
ALGORITHM
FOR
FINDING
MINIMUM
WEIGHT
MATCHINGS
AND
MINIMUM
WEIGHT
MATCHINGS
DUE
TUESDAY
SEPT
APPROXIMATION
ALGORITHMS
WITHOUT
EXPLICIT
LOWER
BOUNDS
EXAMPLES
O
LOG
N
APPROXIMATE
GREEDY
SET
COVER
ALGORITHM
AND
APPROXIMATE
MULTIWAY
CUT
ALGORITHM
READING
CHAPTERS
AND
HOMEWORK
PROBLEMS
AND
DUE
THURSDAY
SEPTEMBER
K
CENTER
CLASS
READING
CHAPTER
HOMEWORK
PROBLEM
DUE
TUESDAY
SEPTEMBER
SHORTEST
SUPERSTRING
CLASS
READING
CHAPTER
HOMEWORK
PROBLEMS
AND
DUE
THURSDAY
SEPTEMBER
REVIEW
OF
ALGEBRAIC
GEOMETRIC
AND
ECONOMIC
VIEWS
OF
DUALITY
CLASSES
READING
CHAPTER
HOMEWORK
PROBLEMS
DUE
TUESDAY
SEPTEMBER
HOMEWORK
PROBLEM
DUE
THURSDAY
SEPTEMBER
SET
COVER
VIA
DUAL
FITTING
DAY
READING
CHAPTER
HOMEWORK
PROBLEM
DUE
TUESDAY
SEPTEMBER
SET
COVER
VIA
ROUNDING
DAY
READING
CHAPTER
HOMEWORK
PROBLEMS
AND
DUE
THURSDAY
SEPTEMBER
MAX
SAT
DAY
READ
CHAPTER
HOMEWORK
PROBLEMS
AND
IN
AND
CAN
YOU
DEVELOP
A
DERANDOMIZED
ALGORITHM
THAT
ONLY
NEEDS
TO
SOLVE
LP
INSTANCE
DUE
THURSDAY
OCTOBER
SCHEDULING
ON
UNRELATED
MACHINES
DAY
READING
CHAPTER
CS
FALL
HTTP
PEOPLE
CS
PITT
EDU
KIRK
HOMEWORK
PROBLEM
DUE
TUESDAY
OCTOBER
SET
COVER
VIA
PRIMAL
DUAL
DAY
READING
CHAPTER
HOMEWORK
NONE
MULTICUT
IN
TREES
DAY
READING
CHAPTER
HOMEWORK
DUE
TUESDAY
OCTOBER
EDGE
MULTIWAY
CUT
DAY
READING
CHAPTER
HOMEWORK
PROBLEMS
AND
DUE
THURSDAY
OCTOBER
NODE
MULTIWAY
CUT
DAY
READING
CHAPTER
HOMEWORK
PROBLEM
DUE
TUESDAY
OCTOBER
MULTICUT
IN
GENERAL
GRAPHS
DAY
READING
CHAPTER
HOMEWORK
PROBLEMS
AND
SPARSEST
CUT
DAY
READING
CHAPTER
NO
HOMEWORK
STEINER
FOREST
DAY
READING
CHAPTER
HOMEWORK
PROBLEM
DUE
THURSDAY
OCTOBER
STEINER
NETWORK
DAY
READING
CHAPTER
HOMEWORK
PROBLEM
DUE
TUESDAY
NOVEMBER
FACILTY
LOCATION
DAY
READING
CHAPTER
K
MEDIAN
DAY
READING
CHAPTER
HARDNESS
OF
APPROXIMATION
DAY
READING
CHAPTER
MARTIN
P
AL
AND
EVA
TARDOS
KEY
POINTS
TO
DISCUSS
THE
COST
SHARING
PROBLEM
METRIC
FACILITY
LOCATION
SINGLE
SOURCE
RENT
OR
BUY
DEFNITION
OF
KEY
PROPERTIES
DEVELOPING
GROUP
STRATEGYPROOF
MECHANISMS
FOR
BOTH
PROBLEMS
USING
SIMILAR
PRIMAL
DUAL
ALGORITHMS
APPROXIMATION
FACTORS
FOR
BOTH
ALGORITHMS
THE
COST
SHARING
PROBLEM
INPUTS
A
SET
U
OF
POTENTIAL
USERS
EACH
USER
HAS
A
PRIVATE
UTILITY
UI
OF
BEING
SERVICED
BY
A
FACILITY
OR
CONNECTED
TO
A
NETWORK
IDEA
WE
WANT
TO
INSTALL
OR
MAINTAIN
A
FACILITY
OR
NETWORK
SUCH
THAT
THE
USERS
OF
THE
FACIL
ITY
NETWORK
SHARE
THE
COST
OF
ITS
INSTALLATION
MAINTENANCE
OUTPUTS
A
SET
J
U
OF
USERS
THAT
WILL
BE
USERS
OF
THE
FACILITY
OR
PART
OF
THE
NETWORK
WE
ALSO
WANT
THE
COST
OF
INSTALLATION
OR
MAINTE
NANCE
TO
BE
SHARED
AMONG
THE
USERS
SO
THAT
EV
ERYONE
IS
CONTENT
WITH
THE
DECISION
KNOWN
AS
COST
SHARES
MEANING
OF
CONTENT
PROPERTIES
OF
GROUP
STRATEGYPROOFNESS
A
USER
SHOULD
NOT
HAVE
INCENTIVES
TO
CHANGE
HIS
MIND
ABOUT
CONTRIBUTING
OR
NOT
CONTRIBUTING
TO
A
FACILITY
OR
ABOUT
BEING
IN
OR
NOT
BEING
IN
THE
NETWORK
LATER
A
USER
SHOULD
NOT
HAVE
INCENTIVES
TO
LIE
ABOUT
HIS
UTILITY
A
GROUP
OF
USERS
SHOULD
NOT
BE
TEMPTED
TO
BUY
A
SEPARATE
FACILITY
OR
TO
BUILD
A
SEPARATE
NETWORK
OF
COST
SMALLER
THAN
THE
SUM
OF
THEIR
CURRENT
CONTRIBUTIONS
CROSS
MONOTONICITY
THE
COST
SHARE
OF
EACH
USER
NEVER
GOES
UP
AS
THE
SET
OF
PARTICIPATING
USERS
INCREASES
MOULIN
AND
SHENKER
SHOW
THAT
CROSS
MONOTONIC
COST
SHARING
LEADS
TO
GROUP
STRATE
GYPROOF
MECHANISMS
FOR
DETERMINING
THE
SET
OF
USERS
J
COMPETITIVENESS
THE
SUM
OF
THE
COST
SHARES
CANNOT
BE
MORE
THAN
THE
TRUE
COST
COST
RECOVERY
THE
SUM
OF
THE
COST
SHARES
MUST
PAY
FOR
THE
TRUE
COST
A
APPROXIMATE
COST
RECOVERY
USERS
ARE
ONLY
REQUIRED
TO
RECOVER
PAY
FOR
A
FRACTION
OF
THE
TRUE
COST
DEVELOPING
A
GROUP
STRATEGYPROOF
MECHANISM
FOR
THE
COST
SHARING
PROBLEM
WE
NEED
TO
DETERMINE
THE
SET
J
OF
PARTICIPATING
USERS
DETERMINE
COST
SHARES
WITH
THE
PROPERTIES
CROSS
MONOTONICITY
COMPETITIVENESS
AND
A
APPROXIMATE
COST
RECOVERY
FOCUS
ON
TWO
PROBLEMS
METRIC
FACILITY
LOCATION
EASY
AND
SINGLE
SOURCE
RENT
OR
BUY
MORE
DICULT
METRIC
FACILITY
LOCATION
REVIEW
FROM
CLASS
INPUTS
A
SET
OF
POTENTIAL
FACILITIES
F
AND
A
SET
J
U
OF
USERS
IDEA
OPEN
A
SUBSET
OF
THE
FACILITIES
PAYING
AMOUNT
FP
FOR
EACH
OPEN
FACILITY
P
AND
BUILD
A
LINK
FROM
EACH
USER
J
J
TO
SOME
OPEN
FACILITY
GIVEN
THE
COST
OF
CONNECTING
USER
J
TO
FACILITY
P
DEFNED
AS
CJP
OUTPUTS
WHICH
FACILITIES
TO
OPEN
WHICH
USERS
ARE
CONNECTED
TO
WHICH
FACILITIES
PRIMAL
MIN
X
FPYP
XX
CJPXJP
PP
J
T
X
XJP
J
P
YP
XJP
J
P
XJP
YJ
DUAL
MAX
X
AJ
J
T
AJ
SSJP
CJP
J
P
X
SSJP
FP
P
J
AJ
SSJP
KEY
CONCEPTS
GROW
A
BALL
GHOST
AROUND
EACH
USER
UNTIL
EITHER
THE
GHOST
TOUCHES
A
FULL
FACILITY
OR
A
FACILITY
THAT
THE
GHOST
IS
ALREADY
TOUCHING
BECOMES
FULL
WHEN
FACILITY
P
BECOMES
FULL
WE
OPEN
IT
I
THERE
IS
NO
ALREADY
OPEN
FACILITY
Q
SUCH
THAT
C
P
Q
P
WHERE
T
P
IS
THE
TIME
WHEN
P
BECOMES
FULL
THIS
IS
SLIGHTLY
DI
ERENT
THAN
THE
METHOD
WE
DISCUSSED
IN
CLASS
BUT
ACHIEVES
THE
SAME
APPROXIMATION
THE
COST
OF
THE
SOLUTION
CONSTRUCTED
IS
AT
MOST
TIMES
THE
SUM
OF
THE
COST
SHARES
THUS
THE
SUM
OF
THE
COSTS
THAT
A
GROUP
OF
USERS
PAYS
TO
OPEN
A
FACILITY
COST
SHARES
IS
AT
LEAST
OF
THE
COST
OF
OPENING
THE
FACILITIES
PLUS
CONNEC
TION
COSTS
KEY
CONCEPTS
CON
T
CROSS
MONOTONICITY
THE
COST
SHARE
OF
EACH
USER
NEVER
GOES
UP
AS
THE
SET
OF
PARTICIPATING
USERS
INCREASES
BY
ADDING
MORE
USERS
EACH
FACILITY
CAN
ONLY
GET
FLLED
MORE
QUICKLY
AND
HENCE
EACH
INDIVIDUAL
USER
CAN
ONLY
BECOME
SATISFED
EARLIER
COMPETITIVENESS
THE
METHOD
CANNOT
CHARGE
USERS
MORE
THAN
THE
TRUE
COST
THE
ALGORITHM
PROVIDES
A
LOWER
BOUND
TO
OPTIMUM
A
APPROXIMATE
COST
RECOVERY
AS
STATED
PRE
VIOUSLY
THIS
ALGORITHM
RECOVERS
OF
THE
COST
OF
THE
SOLUTION
CONSTRUCTED
MAIN
RESULT
THIS
PRIMAL
DUAL
ALGORITHM
IS
A
APPROXIMATE
CROSS
MONOTONIC
COST
SHARING
I
E
GROUP
STRATEGYPROOF
METHOD
FOR
METRIC
FACILITY
LOCATION
SINGLE
SOURCE
RENT
OR
BUY
INPUTS
A
SET
OF
J
U
OF
USERS
AND
A
SOURCE
RESIDING
IN
A
GRAPH
G
V
E
A
PARAMETER
M
IDEA
BUILD
A
TREE
SUCH
THAT
THERE
EXISTS
A
PATH
BETWEEN
EACH
USER
AND
THE
SOURCE
USING
EDGES
IN
E
EACH
EDGE
CAN
EITHER
BE
BOUGHT
AT
A
COST
MCE
OR
RENTED
AT
A
COST
OF
CE
BOUGHT
EDGES
CAN
SUPPORT
ANY
NUMBER
OF
PATHS
THE
RENTAL
COST
CE
MUST
BE
PAID
FOR
EVERY
PATH
THAT
USES
EDGE
E
OUTPUTS
A
LIST
OF
BOUGHT
EDGES
AND
RENTED
EDGES
STRUCTURE
OF
THE
OPTIMAL
SOLUTION
IT
IS
NOT
HARD
TO
SEE
THAT
THE
BOUGHT
EDGES
IN
THE
OPTIMUM
RENT
OR
BUY
NETWORK
MUST
FORM
A
STEINER
TREE
WITH
AT
ITS
ROOT
THE
RENTAL
EDGES
FORM
A
SHORTEST
PATH
CON
NECTION
FROM
EACH
USER
J
TO
THE
CLOSEST
POINT
IN
THE
TREE
PRIMAL
AND
DUAL
FORMULATIONS
MIN
XX
CIJXIJ
M
X
CEZE
JI
E
E
T
X
XIJ
J
I
V
X
ZE
X
XIS
X
XITFORALLS
V
EOUTOFS
I
SI
X
ZE
X
XIS
X
XITFORALLS
V
EOUTOFS
I
SI
GROW
A
GHOST
AROUND
EVERY
USER
UNTIL
THE
USER
GHOST
TOUCHES
A
FULL
CENTER
OR
A
CEN
TER
THE
GHOST
IS
TOUCHING
BECOMES
FULL
AS
IN
FL
A
LOCATION
IS
FULL
IF
IT
IS
TOUCHED
BY
M
OR
MORE
USERS
GHOSTS
SINCE
THERE
ARE
NO
OPENING
COSTS
WE
OPEN
A
CENTER
AT
ANY
FULL
LOCATION
P
USE
THE
PRIMAL
DUAL
STEINER
TREE
ALGORITHM
TO
CONNECT
THE
OPENED
CENTERS
COST
SHARES
EACH
USER
PAYS
FOR
ITS
RENTAL
EDGES
TO
CONNECT
TO
A
CENTER
SHARE
THE
COSTS
OF
BUYING
EDGES
TO
A
CENTER
AMONG
THE
USERS
OF
THAT
CENTER
START
WITH
EACH
CENTER
IN
A
SEPARATE
COM
PONENT
GROW
A
GHOST
AROUND
EACH
CENTER
WHEN
TWO
GHOSTS
TOUCH
CHECK
IF
THE
TWO
CENTERS
ARE
IN
THE
SAME
COM
PONENT
IF
NOT
BUY
A
SHORTEST
PATH
BETWEEN
THE
GHOST
CENTERS
MERGING
THE
TWO
COMPONENTS
INTO
ONE
THE
CENTER
P
OF
THE
FRST
GHOST
TO
REACH
THE
SOURCE
IS
ALLOWED
TO
BUY
A
SHORTEST
PATH
BE
TWEEN
P
AND
THE
ALGORITHM
INCURS
A
COST
M
PER
TIME
UNIT
FOR
GROWING
EACH
COMPONENT
THAT
DOESN
T
CONTAIN
THE
ROOT
VERTEX
PROBLEMS
IF
WE
OPEN
ALL
FULL
CENTERS
MANY
MORE
CEN
TERS
ARE
OPENED
THAN
NECESSARY
THE
COST
OF
BUILDING
A
STEINER
TREE
ON
ALL
CENTERS
MAY
BE
VERY
LARGE
EACH
USER
MAY
BE
CONNECTED
TO
MULTIPLE
CENTERS
MAKING
DECISIONS
ON
HOW
TO
ALLOCATE
USERS
TO
CENTERS
IS
NECESSARILY
INFUENCED
BY
THE
ADDITION
OF
NEW
USERS
IT
IS
HARD
TO
GUAR
ANTEE
CROSS
MONOTONICITY
A
BETTER
IDEA
SIMULTANEOUSLY
GROW
GHOSTS
AROUND
USERS
TO
DETERMINE
RENTAL
EDGES
AND
BUILD
A
STEINER
TREE
TO
DETERMINE
WHICH
EDGES
TO
BUY
SIMPLIFYING
ASSUMPTION
IT
IS
CONVENIENT
TO
THINK
OF
AN
EDGE
E
AS
A
LINE
SEGMENT
OF
LENGTH
CE
CONTAINING
A
CONTINUUM
OF
POINTS
THE
TERM
LOCATION
REFERS
TO
BOTH
ORIGINAL
VERTICES
AND
IN
TERMEDIATE
POINTS
IT
HAS
BEEN
SHOWN
THAT
A
SOLUTION
THAT
IS
AL
LOWED
TO
RENT
AND
BUY
EDGE
SEGMENTS
ARBITRARILY
CAN
BE
TRANSFORMED
INTO
A
SOLUTION
THAT
DOES
NOT
USE
INTERMEDIATE
POINTS
OF
NO
GREATER
COST
B
J
T
THE
GHOST
AROUND
J
WITH
RADIUS
T
C
THE
TIME
VARYING
SET
OF
ALL
LOCATIONS
THAT
HAVE
BEEN
REACHED
BY
M
OR
MORE
USER
GHOSTS
AT
ANY
TIME
C
CAN
BE
REPRESENTED
AS
A
COLLEC
TION
OF
VERTICES
EDGES
AND
SEGMENTS
OF
EDGES
LET
C
C
CONNECTED
COMPONENT
OF
C
ANY
INCLUSION
MAXIMAL
C
C
SUCH
THAT
ANY
TWO
LOCATION
C
ARE
JOINED
BY
A
PATH
LYING
COMPLETELY
WITHIN
C
WE
SAY
THAT
A
USER
J
AT
TIME
T
IS
CONNECTED
TO
A
COMPONENT
C
OF
C
IF
B
J
T
C

A
USER
J
IS
SATISFED
IF
IT
IS
CONNECTED
TO
A
COMPONENT
CONTAINING
THE
SOURCE
VERTEX
T
J
THE
TIME
WHEN
USER
J
FRST
BECOMES
CON
NECTED
TO
A
COMPONENT
J
THE
TIME
WHEN
USER
J
BECOMES
SATISFED
THE
ALGORITHM
MAINTAINS
A
LIST
OF
COMPONENTS
C
INITIALIZE
C

BEGIN
GROWING
A
GHOST
AROUND
EACH
USER
AS
TIME
PROGRESSES
A
USER
GHOST
MAY
REACH
AN
OTHER
USER
LOCATION
LET
BE
THIS
SET
OF
USERS
THAT
HAVE
REACHED
A
LOCATION
P
WHEN
M
WE
ADD
THE
SET
NJ
SB
J
T
OF
LOCATIONS
AS
A
NEW
COMPONENT
OF
C
AT
THIS
TIME
LOCATION
P
IS
CONSIDER
TO
BE
FULL
WE
DECLARE
A
FULL
P
OPEN
IF
AT
TIME
T
P
THERE
IS
NO
OPEN
CENTER
WITHIN
A
RADIUS
P
OF
P
AS
TIME
PROGRESSES
TWO
COMPONENTS
MAY
TOUCH
WHEN
THIS
OCCURS
WE
JOIN
THE
COMPONENTS
BY
CONSTRUCTING
A
SHORTEST
PATH
BETWEEN
THEIR
CEN
TERS
WE
CONTINUE
UNTIL
ALL
USERS
ARE
SATISFED
AND
C
CONTAINS
A
SINGLE
COMPONENT
WE
SHOULD
MAKE
EVERY
USER
PAY
FOR
THE
RENTAL
COSTS
ASSOCIATED
WITH
HIM
IF
A
USER
IS
CON
NECTED
TO
MULTIPLE
COMPONENTS
WE
ONLY
LET
HIM
CONTRIBUTE
TO
THE
COMPONENT
WHERE
HIS
SHARE
IS
THE
SMALLEST
LET
J
C
DENOTE
THE
SET
OF
USERS
CONNECTED
TO
C
FOR
A
CONNECTED
USER
J
LET
AJ
T
BE
THE
MAXI
MUM
SIZE
J
C
OVER
ALL
COMPONENTS
C
THAT
J
IS
CONNECTED
TO
AT
TIME
T
DEFNE
FJ
AS
FOLLOWS
FJ
T
FOR
T
T
J
FJ
T
M
AJ
T
FOR
T
J
T
J
AND
FJ
T
FOR
T
J
DEFNE
A
AND
FOR
EACH
USER
AS
FOLLOWS
Z
J
Z
T
J
AJ
FJ
T
DT
AND
AJ
FJ
T
DT
T
J
MAINTAINING
KEY
PROPERTIES
THEOREM
CROSS
MONOTONICITY
THE
COST
SHARES
A
AND
ARE
CROSS
MONOTONIC
FUNCTIONS
OF
THE
SET
J
PROOF
SKETCH
BY
ADDING
MORE
USERS
WE
CAN
ONLY
MAKE
THE
SET
C
LARGER
AND
HENCE
MAKE
EACH
USER
CONNECT
EARLIER
MOREOVER
EACH
COM
PONENT
OF
C
CAN
ONLY
INCREASE
BY
ADDING
MORE
USERS
HENCE
AS
THE
NUMBER
OF
USERS
CON
NECTED
TO
THAT
COMPONENT
INCREASES
THE
COST
SHARES
CAN
ONLY
GROW
SLOWER
THEOREM
COMPETITIVENESS
EVERY
FEASIBLE
SOLUTION
TO
THE
SINGLE
SOURCE
RENT
OR
BUY
IN
STANCE
HAS
A
COST
OF
AT
LEAST
MAX
PJ
J
AJ
PJ
J
A
APPROXIMATE
COST
RECOVERY
LEMMA
LET
P
BE
AN
OPEN
CENTER
AND
LET
J
SP
THEN
J
T
P
FOR
A
J
THAT
DOES
NOT
BELONG
TO
ANY
SP
THERE
IS
AN
OPEN
GHOST
CENTER
P
SUCH
THAT
C
J
P
J
THIS
LEMMA
SHOWS
THAT
THE
COST
SHARES
CAN
PAY
FOR
OF
THE
RENTAL
COST
OF
THE
NETWORK
SIMILAR
TO
THE
FACILITY
LOCATION
CASE
LEMMA
THE
COST
OF
THE
TREE
WE
BUY
IS
AT
MOST
PJ
AJ
BOUNDING
THE
TREE
COST
NEXT
SLIDE
BOUNDING
THE
TREE
COST
WE
CAN
THINK
OF
THE
ALGORITHM
AS
INCURRING
A
COST
M
PER
TIME
UNIT
FOR
GROWING
EACH
COMPO
NENT
THAT
DOES
NOT
CONTAIN
THE
ROOT
VERTEX
IF
A
T
DENOTES
THE
NUMBER
OF
NON
ROOT
COMPO
NENTS
AT
TIME
T
THE
TOTAL
COST
OF
GROWING
THE
COMPONENTS
IS
Z
MA
T
DT
WHERE
THE
INTEGRAL
IS
OVER
THE
ENTIRE
EXECUTION
OF
THE
ALGORITHM
BY
STANDARD
ARGUMENTS
THE
COST
OF
THE
TREE
CONSTRUCTED
IS
AT
MOST
TWO
TIMES
THE
GROWING
COST
FOR
EACH
STEINER
COMPONENT
WE
DEFNE
A
TIME
VARYING
SET
CONTRIB
OF
USERS
THAT
WILL
BE
RESPONSIBLE
FOR
MAINTAINING
A
STEADY
FOW
OF
FUNDING
OF
AT
LEAST
M
PER
TIME
UNIT
FROM
THE
TIME
INCREMENTS
FJ
T
OF
THEIR
COST
SHARES
THUS
WE
HAVE
THAT
AT
ANY
TIME
T
THE
USERS
ARE
ABLE
TO
COLLECT
MA
T
REVENUE
FROM
THEIR
CONTRIBUTIONS
AT
TIME
T
HENCE
Z
Z
MA
T
DT
X
FJ
T
DT
J
Z
X
FJ
T
DT
X
JJ
SINCE
M
A
T
DT
CAN
PAY
FOR
HALF
OF
THE
TREE
THE
BUYING
COSTS
OF
OUR
SOLUTION
DOES
NOT
EX
CEED
PJ
AJ
MAIN
RESULT
LEMMA
THE
COST
OF
THE
SOLUTION
CONSTRUCTED
IS
AT
MOST
PJ
J
FOLLOWS
FROM
PREVIOUS
SLIDES
THEOREM
THE
COST
SHARES
ARE
CROSS
MONOTONIC
COMPETITIVE
AND
RECOVER
FRACTION
OF
THE
COST
OF
THE
SOLUTION
CONSTRUCTED
THE
APPROXIMATION
FACTOR
FOLLOWS
FROM
THE
FACT
THAT
A
FEASIBLE
SOLUTION
HAS
A
COST
OF
AT
LEAST
MAX
PJ
J
AJ
PJ
AND
THE
J
BOUND
STATED
ABOVE
LP
BASED
APPROXIMATION
ALGORITHMS
FOR
BROADCAST
SCHEDULING
MAHMOUD
ELHADDAD
CLASS
PRESENTATION
APPROXIMATION
ALGORITHMS
U
PITTSBURGH
FALL
B
KALYANASUNDARAM
K
PRUHS
AND
M
VELAUTHAPILLAI
SCHEDULING
BROADCASTS
IN
WIRELESS
NETWORKS
PROC
ESA
R
GHANDI
KHULLER
Y
A
KIM
AND
Y
C
WAN
ALGORITHMS
FOR
MIN
RESPONSE
TIME
IN
BROADCAST
SCHEDULING
PROC
IPCO
R
GHANDI
KHULLER
PARTHASARATHY
AND
A
SRINIVASAN
DEPENDENT
ROUNDING
IN
BIPARTITE
GRAPHS
PROC
FOCS
BROADCAST
SERVER
WITH
SLOTTED
BROADCAST
CHANNEL
N
ONE
SLOT
PAGES
PN
REQUESTS
RI
T
I
N
ARE
RECEIVED
AT
THE
END
OF
SLOT
T
OBJECTIVE
IS
TO
MINIMIZE
AVG
TOTAL
RESPONSE
TIME
CI
T
PI
T
T
T
T
T
T
RI
T
OFFLINE
PROBLEM
SHOWN
NP
HARD
ULTIMATE
GOAL
O
APPROXIMATION
ALGORITHM
RESOURCE
AUGMENTATION
CAN
WE
GET
AN
O
APPROXIMATION
ALG
BY
THROWING
O
MORE
BANDWIDTH
AT
THE
PROBLEM
A
K
SPEED
SERVER
IS
ONE
THAT
BROADCASTS
UP
TO
K
PAGES
EVERY
TIME
SLOT
SPEED
APPROX
ALG
SPEED
APPROX
AND
SPEED
APPROX
SPEED
APPROX
AND
SPEED
APPROX
REDUCTION
TO
INTEGER
MIN
COST
FLOW
REDUCTION
PROBABILISTIC
INTERPRETATION
OF
THE
LP
SOLUTION
IMPOSE
A
STRUCTURE
ON
THE
LP
SOLUTION
TO
FACILITATE
THE
DEFINITION
OF
A
SPEED
ALG
AND
IS
AN
INTEGER
PROVE
THAT
THE
ALGORITHM
GUARANTEES
A
FACTOR
APPROXIMATE
SOLUTION
D
D
MIN
T
N
T
N
N
WI
T
TT
FI
T
TT
N
T
TT
T
I
FI
N
I
TT
T
FI
TT
T
TT
T
N
FI
T
TT
I
N
T
T
N
FI
TT
T
T
T
N
TT
T
I
FI
T
TT
I
N
T
TT
T
N
FI
T
N
T
I
N
T
T
T
N
LEMMA
THE
OPTIMAL
VALUE
OF
IP
IS
THE
MINIMUM
TOTAL
RESPONSE
TIME
FOR
THE
BROADCAST
PROBLEM
LOPT
IS
N
FEASIBLE
FRACTION
OF
EACH
PAGE
CAN
BE
TRANSMITTED
IN
A
SLOT
WITHOUT
VIOLATING
THE
FOURTH
CONSTRAINT
LEMMA
ALL
REQUESTS
ARE
EVENTUALLY
SATISFIED
IN
THE
LP
SOLUTION
EQUIV
RI
T
J
T
K
T
N
PROBABILISTIC
INTERPRETATION
OF
LP
SOLUTION
TT
T
FI
TT
T
MIN
TT
T
PI
TT
NI
T
PI
T
FI
J
K
NI
T
THE
RI
T
REQUESTS
ARE
SATISFIED
AT
T
N
WITH
PROB
PI
THEY
ARE
SATISFIED
AT
NI
T
WITH
PROB
FI
T
THE
PROB
SOLUTION
N
T
NI
T
LEMMA
VL
LOPT
LET
IS
AN
INTEGER
THEY
SEEK
A
FEASIBLE
SOLUTION
BI
J
MIN
T
K
PI
K
J
THE
JTH
BREAKPOINT
FOR
PI
I
II
J
BI
J
BI
J
I
N
J
H
I
INTERVAL
II
J
IS
SATISFIED
AT
TIME
T
IF
PI
IS
BROADCAST
AT
T
II
J
ASSUME
ALL
REQUESTS
UP
TO
TIME
T
HAVE
BEEN
SCHEDULED
TO
SCHEDULE
THE
REQUESTS
AT
T
LET
U
BE
THE
SET
OF
CURRENTLY
UNSATISFIED
INTERVALS
AND
PICK
FROM
U
UP
TO
INTERVALS
WITH
SMALLEST
RIGHT
ENDPOINTS
BROADCAST
THEM
AT
TIME
T
LEMMA
EVERY
INTERVAL
IS
SATISFIED
IN
LEDF
LEDF
IS
A
APPROXIMATION
ALG
LEMMA
THE
TOTAL
RESPONSE
TIME
OF
THE
FEASIBLE
SCHEDULE
LEDF
IS
AT
MOST
LOPT
THEOREM
THERE
IS
A
POLYNOMIAL
TIME
SPEED
APPROX
ALG
FOR
THE
BROADCAST
PROBLEM
WHERE
THE
OBJECTIVE
IS
TO
MIN
THE
AVERAGE
RESPONSE
TIME
ILP
FORMULATION
RELAXED
LP
SOLUTION
USING
LOPT
DEFINE
A
SIMPLIFIED
PROBLEM
INSTANCE
THAT
ALLOWS
A
SPEED
ALG
AND
IS
AN
INTEGER
THE
SIMPLIFIED
INSTANCE
CAN
BE
REDUCED
TO
MIN
COST
FLOW
ON
BIPARTITE
GRAPH
EXACT
SOLUTION
TO
RELAXED
SIMPLIFIED
INSTANCE
BY
THE
INTEGRALITY
THEOREM
PROVE
THE
SOLUTION
FOR
SIMPLIFIED
INSTANCE
IS
AT
MOST
SOLUTION
THE
OPTIMAL
YIT
IFF
PI
IS
BROADCAST
AT
TT
XI
T
IFF
REQUESTS
I
T
ARE
SATISFIED
AT
TT
T
T
MIN
T
N
N
TT
T
RI
T
XTTT
T
TT
T
I
YIT
XI
T
I
N
TT
T
T
T
N
TT
T
TT
XTTT
I
N
T
YIT
TT
I
I
T
I
N
T
TT
YIT
I
N
TT
LET
X
Y
BE
THE
OPTIMAL
FRACTIONAL
SOLUTION
FOR
R
T
DEFINE
F
T
I
T
MIN
TTT
TTT
I
T
TRANSFORM
I
TO
IT
BY
CONSOLIDATING
THE
REQUESTS
SO
THAT
THE
FOLLOWING
PROPERTY
HOLDS
FOR
IT
PROPERTY
LET
NIT
BE
THE
SET
TIMES
OF
REQUESTS
FOR
PI
IN
IT
AND
TUT
TVT
THEN
T
TT
NIT
F
T
I
TUT
TVT
REQUESTS
I
T
GROUPED
WITH
I
G
I
T
G
I
T
T
F
T
I
T
G
I
T
RECALL
X
Y
IS
THE
OPTIMAL
N
FEASIBLE
FRACTIONAL
SOLUTION
FOR
I
CONSIDER
THE
SOLUTION
X
Y
TT
T
IF
TT
F
T
I
T
I
TT
TT
TTT
T
I
TT
IF
TT
F
T
I
T
OTHERWISE
THE
SOLUTION
X
Y
IS
FEASIBLE
IN
THE
WEAK
SENSE
THAT
CONSTRAINT
BECOMES
I
YIT
TT
HOWEVER
WITHOUT
INTEGER
SOLUTION
X
Y
UP
TO
N
PAGES
MAY
NEED
TO
BE
BROADCAST
EACH
TIME
SLOT
CONSTRUCT
THE
FOLLOWING
MIN
COST
FLOW
NETWORK
N
TTJ
TTJ
RT
TX
T
J
TX
TK
TKT
D
TML
X
TY
TY
TML
ANALYSIS
LEMMA
THE
COST
OF
SPEED
FRAC
SOL
IN
IT
AND
THAT
OF
AN
OPTIMAL
FRAC
SOL
FOR
I
ARE
RELATED
AS
FOLLOWS
RI
T
T
N
TT
G
I
T
X
T
RI
T
G
I
T
T
LEMMA
FOR
ANY
FEASIBLE
FLOW
IN
N
THERE
IS
A
SPEED
FEASIBLE
FRACTIONAL
SOL
FOR
IT
OF
THE
SAME
COST
AND
VICE
VERSA
LEMMA
THERE
EXISTS
A
SPEED
INTEGRAL
SOLUTION
FOR
IT
OF
THE
SAME
COST
AS
THE
SPEED
FRACTIONAL
SOL
X
Y
THEOREM
THERE
IS
A
SPEED
BROADCAST
PROBLEM
APPROX
SOLUTION
FOR
THE
STRATEGY
OVERVIEW
SAME
ILP
FORMULATION
AS
SAME
RELAXED
LP
SOLUTION
USING
LOPT
DEFINE
A
SIMPLIFIED
PROBLEM
INSTANCE
THAT
ALLOWS
A
SPEED
ALG
DIFFERENCE
DON
T
COMBINE
REQUESTS
JUST
DROP
THOSE
IN
THE
MIDDLE
THE
SIMPLIFIED
INSTANCE
CAN
BE
REDUCED
TO
MIN
COST
FLOW
ON
BIPARTITE
GRAPH
DIFFERENT
FROM
APPLY
DEPENDENT
ROUNDING
ON
THE
BIPARTITE
GRAPH
TO
GET
A
SPEED
APPROX
INTEGRAL
SOL
A
SPEED
APPROX
ALGORITHM
DEPENDENT
ROUNDING
DR
CS
TOPICS
IN
ALGORITHMS
SPRING
TOPIC
IS
ALGORITHMIC
GAME
THEORY
INSTRUCTORS
CLASS
IS
CANCELED
FOR
WEDNESDAY
JANUARY
COURSE
DESCRIPTION
WE
WILL
COVER
MOST
OF
THE
VERY
RECENT
TEXT
FALL
ON
ALGORITHMIC
GAME
THEORY
BY
NISAN
ROUGHGARDEN
TARDOS
AND
VAZIRANI
AFTER
USING
THE
TEXT
HERE
IS
A
REVIEW
THAT
I
WROTE
AT
THE
REQUEST
OF
FRITS
SPIEKSMA
CS
SPRING
HTTP
PEOPLE
CS
PITT
EDU
KIRK
THE
AMAZON
PAGE
CONTAINS
A
TABLE
OF
CONTENTS
AND
AN
EXCEPT
A
RATHER
NICE
FORWARD
WAS
WRITTEN
BY
CHRISTOS
PAPADIMITRIOU
THIS
COURSE
IS
INTENDED
TO
BE
A
BROAD
INTRODUCTION
TO
ALGORITHMIC
GAME
THEORY
THAT
SHOULD
BE
ACCESSIBLE
TO
A
WIDE
RANGE
OF
STUDENTS
COURSE
FORMAT
THE
INSTRUCTORS
WILL
PRESENT
THE
INITIAL
LECTURES
EACH
STUDENT
WILL
BE
EXPECTED
TO
LEAD
SOME
LECTURES
DISCUSSIONS
LATER
IN
THE
SEMESTER
COVERING
SOME
PORTION
OF
THE
TEXT
ONE
OR
TWO
EXERCISES
MAY
BE
ASSIGNED
FROM
EACH
CHAPTER
TO
PROVIDE
SOME
PRACTICE
USING
THE
CONCEPTS
FROM
THE
CHAPTER
CLASS
TIME
AND
LOCATION
MONDAYS
AND
WEDNESDAYS
AND
MAYBE
A
RARE
FRIDAY
TO
MAKE
UP
FOR
CLASSES
MISSED
DUE
TO
INSTRUCTORS
TRAVELS
TO
ACADEMIC
CONFERENCES
FROM
TO
IN
ROOM
OF
THE
SENNOTT
SQUARE
BUILDING
TENTATIVE
SCHEDULE
DATE
TOPIC
REFERENCE
HOMEWORK
DUE
AT
THE
START
OF
NEXT
CLASS
OCCASIONALLY
I
WILL
ASK
SOMEONE
TO
PRESENT
THE
HOMEWORK
MONDAY
JAN
DEFINITION
STRATEGIC
GAME
DOMINANCE
PARETO
EFFICIENCY
OPTIMALITY
PURE
NASH
EQUILIBRIUM
MIXED
NASH
EQUILIBRIUM
CHAPTER
WEDNESDAY
JAN
LEMKE
HOWSON
ALGORITHM
FOR
GENERAL
PERSON
GAMES
CHAPTER
IS
TOUGH
SLEDDING
HOMEWORK
CONSIDER
THE
GAME
IN
LEWIKI
NOTES
FIND
A
MIXED
NASH
EQUILIBRIUM
FOR
THE
GAME
CS
SPRING
HTTP
PEOPLE
CS
PITT
EDU
KIRK
INSTEEAD
TRY
GOOD
SLIDES
FROM
CLASS
TAUGHT
BY
MICHAEL
LEWIKI
APPLY
THE
LEMKE
HOWSON
ALGORITHM
TO
THIS
NASH
EQUILIBRIUM
UNTIL
YOU
GET
TO
A
NEW
NASH
EQUILIBRIUM
YOUR
FIRST
STEP
WILL
BE
ARBITRARY
SHOW
THE
PATH
ON
THE
D
AND
D
SPACES
SHOWN
IN
THE
NOTES
MONDAY
JAN
COMPLEXITY
OF
NASH
EQUILBRIM
REDUCTION
TO
LINEAR
PROGRAMMING
FOR
ZERO
SUM
PERSON
GAMES
SPERNER
LEMMA
BROWER
FIXED
POINT
EXISTENCE
OF
NASH
CHAPTER
GOOD
NOTES
FROM
A
CLASS
TAUGHT
BY
CHRISTOS
PAPADIMITRIOU
WEDNESDAY
JAN
NP
HARDNESS
OF
DECIDING
IF
MIXED
NASH
EQUILIBRIUM
IN
A
PERSON
GAME
PAPER
BY
CONITZER
AND
SANDHOLM
SLIDES
FOR
THE
PAPER
SLIDES
REVISED
BY
THE
STUDENTS
GROUP
HOMEWORK
ELABORATE
IMPROVE
ON
THE
FIRST
PAGE
OF
THESE
SLIDES
TO
MAKE
THE
PROOF
MORE
COMPLETE
CONVINCING
ILLUMINATING
IN
PARTICULAR
EXPLAIN
WHY
A
PLAYER
WON
T
PLAY
BOTH
A
LITERAL
AN
ITS
NEGATION
WHY
A
PLAYER
WON
T
PLAY
ANY
LITERAL
WITH
PROBABILITY
GREATER
THAN
N
WHERE
N
IS
THE
NUMBER
OF
VARIABLES
WHY
A
PLAYER
WON
T
PLAY
A
VARIABLE
MOVE
STRATEGY
WHY
A
PLAYER
WON
T
PLAY
A
CLAUSE
MOVE
STRATEGY
IF
THE
FORMULA
IS
SATISFIABLE
WHY
YOU
NEED
THE
DEFAULT
MOVE
YOU
MAY
ALSO
CHANGE
THE
INSTANCE
CONSTRUCTED
GAME
SAY
BY
ADDING
INFINITY
PAYOFFS
IF
YOU
THINK
THAT
THAT
HELPS
EMAIL
ME
THE
SLIDES
AND
I
WILL
POST
YOUR
REVISION
DON
T
GET
CARRIED
AWAY
I
AM
THINKING
THAT
THIS
SHOULD
TAKE
OR
AT
MOST
HOURS
MONDAY
JAN
NO
CLASS
MLK
DAY
WEDNESDAY
JAN
CLASS
CANCELLED
L
MONDAY
JAN
LEARNING
REGRET
MINIMIZATION
AND
EQUILIBRIA
CHAPTER
CS
SPRING
HTTP
PEOPLE
CS
PITT
EDU
KIRK
GUEST
LECTURE
KATRINA
LIGETT
WEDNESDAY
JAN
KKT
CONDITIONS
RESOURCE
ALLOCATION
MARKETS
T
PATHS
TI
PATHS
SECTION
SLIDES
AND
SLIDES
BY
VIJAY
VAZIRANI
MONDAY
FEB
FISCHER
LINEAR
MARKET
SECTION
SLIDES
BY
AMIN
SABERI
GROUP
HOMEWORK
CONSIDER
A
MARKET
OF
GOODS
AND
BUYERS
WHERE
THE
UTILITY
ONLY
INCREASES
AS
THE
SQUARE
ROOT
OF
THE
QUANTITY
OF
GOOD
RECEIVED
THAT
IS
A
BUYER
I
GETS
UTILITY
I
J
I
J
FROM
I
J
UNITS
OF
GOOD
J
IT
IS
PROBABLY
MORE
REALISTIC
TO
ASSUME
THAT
UTILITY
IS
A
CONCAVE
FUNCTION
OF
QUANTITY
WRITE
EISENBERG
GALE
PROGRAM
FOR
THE
MARKET
CLEARING
PROBLEM
FOR
THIS
MARKET
APPLY
THE
KKT
CONDITIONS
DETERMINE
FROM
THE
KKT
CONDITIONS
WHICH
CONDITIONS
IN
THEOREM
HOLD
FOR
THIS
MARKET
WHAT
IF
ANYTHING
GOES
WRONG
IF
ONE
TRIES
TO
APPLY
THE
ALGORITHM
IN
SECTION
FOR
FISCHER
LINEAR
CASE
TO
THIS
MARKET
DON
T
WORRY
ABOUT
RUNNING
TIME
CONCENTRATE
ON
CORRECTNESS
OF
THE
ALGORITHM
IF
WHAT
GOES
WRONG
IS
MINOR
CAN
IT
BE
EASILY
FIXED
WEDNESDAY
FEB
SOCIAL
CHOICE
ARROW
IMPOSSIBILITY
LEMMA
AND
GIBBARD
SATTERTHWAITE
SECTION
NOTES
FROM
CLASS
BY
CHRISTOS
PAPADIMITRIOU
GROUP
HOMEWORK
IN
THE
PROOF
OF
ARROW
IMPOSSIBILITY
LEMMA
THAT
I
DID
IN
CLASS
BASICALLY
THE
SAME
PROOF
AS
IN
THE
BOOK
WE
CONSIDER
THE
SEQUENCE
F
F
RECALL
THAT
F
SATISFIED
THE
CONDITIONS
OF
UNANIMITY
AND
INDEPENDENCE
OF
IRRELEVANT
ALTERNATIVES
IT
IS
EASY
TO
SEE
THAT
THERE
MUST
EXIST
A
K
SUCH
THAT
B
A
IF
F
FOR
J
K
AND
A
B
IN
F
THAT
IS
THE
PREFERENCE
FLIPS
AT
K
IN
MY
ARGUMENT
I
CS
SPRING
HTTP
PEOPLE
CS
PITT
EDU
KIRK
ASSUMED
THAT
IT
WAS
THEN
ALSO
THE
CASE
THAT
A
B
IN
F
FOR
J
K
THAT
IS
ONCE
THE
PREFERENCE
FLIPS
IT
HAS
TO
STAY
FLIPPED
SHENODA
POINTED
OUT
THAT
IT
AT
LEAST
WASTED
OBVIOUS
THAT
THIS
IS
TRUE
THAT
IS
IT
IS
POSSIBLE
THAT
THE
PREFERENCE
BETWEEN
A
AND
B
COULD
FLIP
SEVERAL
TIMES
YOUR
GOAL
IS
TO
DETERMINE
WHICH
OF
THE
FOLLOWING
IS
TRUE
THE
PREFERENCE
CAN
ONLY
FLIP
ONCE
THE
PREFERENCE
CAN
FLIP
MORE
THAN
ONCE
BUT
THE
PROOF
CAN
STILL
GO
THROUGH
WITH
AT
MOST
MINOR
MODIFICATION
MONDAY
FEB
CHRISTINE
WILL
BE
SPEAKING
INTRO
TO
INEFFICIENCY
OF
EQUILIBRIA
SECTIONS
WEDNESDAY
FEB
CHRISTINE
WILL
BE
SPEAKING
ROUTING
GAMES
SECTIONS
MONDAY
FEB
CHRISTINE
WILL
BE
SPEAKING
NETWORK
FORMATION
GAMES
A
LOCAL
CONNECTION
GAME
SECTIONS
WEDNESDAY
FEB
CHRISTINE
WILL
BE
SPEAKING
NETWORK
FORMATION
GAMES
A
GLOBAL
CONNECTION
GAME
AND
THE
POTENTIAL
FUNCTION
METHOD
SECTION
GROUP
HOMEWORK
PROBLEM
MONDAY
FEB
MECHANISMS
WITH
MONEY
VCG
CLARK
PIVOT
RULE
SECTIONS
GROUP
HOMEWORK
CONSIDER
THE
AUCTION
PROBLEM
OF
SELLING
K
IDENTICAL
ITEMS
TO
K
DIFFERENT
BIDDERS
IS
HAVE
THE
I
TH
HIGHEST
BIDDER
PAY
THE
BID
OF
THE
I
ST
HIGHEST
BID
TRUTHFUL
WEDNESDAY
FEB
HOUSE
ALLOCATION
AND
STABLE
MARRIAGE
SECTIONS
MONDAY
MARCH
COMBINATORIAL
AUCTIONS
THE
GREEDY
ALGORITHM
FOR
SINGLE
MINDED
BIDDERS
SECTION
WEDNESDAY
MARCH
COMBINATORIAL
AUCTIONS
WALRASIAN
EQUILIBRIUM
AND
THE
LP
RELAXATION
COMMUNICATION
COMPLEXITY
SECTION
SECTION
GROUP
HOMEWORK
PROVE
LEMMA
USING
THE
KKT
CONDITIONS
OR
LP
DUALITY
GROUP
HOMEWORK
PROBLEM
FROM
THE
TEXT
SPRING
BREAK
MONDAY
MARCH
BGP
ROUTING
SECTION
GROUP
HOMEWORK
CAN
YOU
COME
UP
WITH
A
PRECISE
FORMULATION
OF
THEOREM
THAT
IS
BOTH
CS
SPRING
HTTP
PEOPLE
CS
PITT
EDU
KIRK
INTERESTING
AND
AT
LEAST
PLAUSIBLY
TRUE
THE
MAIN
ISSUE
IN
THE
PROOF
THAT
FOLLOWS
IS
WHAT
IS
THE
DOMAIN
OF
QUANTIFICATION
WHEN
IT
IS
CLAIMED
THAT
EACH
AS
GETS
THEIR
MOST
VALUED
ROUTE
WEDNESDAY
MARCH
COST
SHARING
CHAPTER
MONDAY
MARCH
COST
SHARING
CHAPTER
GROUP
HOMEWORK
PROBLEM
WEDNESDAY
MARCH
CASCADING
BEHAVIOUR
IN
NETWORKS
CHAPTER
MONDAY
MARCH
LORY
PRESENTATION
ON
SPONSORED
SEARCH
CHAPTER
TALK
SLIDES
WEDNESDAY
APRIL
SHENODA
PRESENTATION
ON
SELFISH
LOAD
BALANCING
CHAPTER
TALK
SLIDES
MONDAY
APRIL
NO
CLASS
WEDNESDAY
APRIL
NO
CLASS
MONDAY
APRIL
JOSH
PRESENTATION
ON
REPUTATION
SYSTEMS
CHAPTER
SLIDES
WEDNESDAY
APRIL
RICH
PRESENTATION
ON
BIOLOGICAL
APPLICATIONS
OF
GAMES
SLIDES
MONDAY
APRIL
TOMAS
PRESENTATION
ON
BAYESIAN
APPROACHES
PAPER
BY
JIM
RATLIFF
TALK
SLIDES
WEDNESDAY
APRIL
PANICKOS
PRESENTATION
ON
PEER
TO
PEER
APPLICATIONS
OF
GAMES
CHAPTER
BAYESIAN
GAMES
GAMES
AND
EQUILIBRIUM
CONCEPTS
UNDER
UNCERTAINTY
TOMAS
SINGLIAR
APRIL
EXAMPLES
BLACKJACK
ACTION
SPACE
DRAW
CARD
PASS
ADD
UP
CARD
VALUES
MAXIMUM
TOTAL
WINS
WHAT
THE
NEXT
CARD
JPMORGAN
BUYS
BEAR
STEARNS
ACTION
SPACE
SHARE
PRICE
OFFERED
PAYOFF
TRUE
VALUE
OF
BUSINESS
PAYMENT
WHAT
IS
THE
EXTENT
OF
THE
MESS
EBAY
HOW
MUCH
DID
THAT
OTHER
GUY
BID
OUTLINE
GOAL
TO
SHOW
HOW
TO
INCORPORATE
INCOMPLETE
INFORMATION
INTO
GAMES
DEFINE
EQUILIBRIUM
CONCEPTS
AND
SHOW
HOW
TRICKY
THEY
BECOME
SETUP
SEQUENTIAL
GAMES
OF
INCOMPLETE
INFORMATION
SENDER
RECEIVER
GAMES
DECISION
MAKING
UNDER
UNCERTAINTY
BAYESIAN
NASH
CONCEPTS
AND
DESIRABLE
PROPERTIES
SEQUENTIAL
GAMES
GAMES
WHERE
PLAYERS
TAKE
TURNS
OPTIMAL
ALGORITHM
DECISION
TREE
ZERO
SUM
MINIMAX
TREE
DETERMINISTIC
GAME
CHOOSES
MAX
UTILITY
ACTION
CHOOSES
MAX
UTILITY
ACTION
ACTIONS
CONDITIONED
ON
OUTCOMES
UTILITIES
OF
OUTCOME
BAYESIAN
GAME
SETUP
DYNAMIC
GAME
PLAYED
SEQUENTIALLY
EACH
PLAYER
I
HAS
A
SET
OF
TYPES
I
NATURE
SELECTS
PLAYER
TYPE
I
I
ACCORDING
TO
P
PRIOR
JOINT
DISTRIBUTION
OVER
TYPES
PUBLICLY
KNOWN
PLAYER
IS
PRIVATELY
INFORMED
OF
HIS
TYPE
UNCERTAINTY
PLAYERS
DON
T
KNOW
OTHER
PLAYERS
TYPES
PLAYERS
NOW
CHOOSE
THEIR
ACTIONS
A
IN
SOME
ORDER
PLAYERS
RECEIVE
PAYOFFS
ACCORDING
TO
OUTCOME
PAYOFF
FUNCTION
ON
THE
OUTCOME
UI
A
I
R
SENDER
RECEIVER
GAMES
SIMPLEST
CASE
TWO
PLAYERS
SENDER
RECEIVER
RUNNING
EXAMPLE
SENDER
APPLIES
FOR
JOB
AT
RECEIVER
HER
MESSAGE
IS
WHAT
SHE
DID
LAST
YEAR
I
E
WENT
TO
BEACH
OR
COLLEGE
RECEIVER
DECIDES
WHETHER
TO
HIRE
OR
REJECT
SENDER
TYPE
IS
FIXED
I
E
GOING
TO
COLLEGE
DOES
NOT
MAKE
YOU
SMART
SENDER
TYPES
PRIVATE


SMART
DULL
ACTION
SEND
A
MESSAGE
M
M
BEACH
COLLEGE
RECEIVER
ONLY
ONE
TYPE
DETERMINISTIC
ACTION
A
A
HIRE
OR
REJECT
HOLDS
A
PRIOR
BELIEF
P

OVER
THE
SENDER
TYPE
P

SMART

P

DULL

TYPE
SPACE
MESSAGE
SPACE
ACTION
SPACE
THIS
BELIEF
IS
ASSUMED
TO
BE
COMMON
KNOWLEDGE
R
PAYOFF
GRAPHICAL
REPRESENTATION
PLAYERS
NATURE
SENDER
RECEIVER
SENDER
TYPES
SMART
DULL
RECEIVER
TYPE
R
DOES
NOT
KNOW
WHICH
PART
OF
THE
TREE
HE
IS
IN
HIS
INFORMATION
SET
ALL
NODES
HE
COULD
BE
IN
GRAPHICAL
REPRESENTATION
EVERYTHING
ELSE
BEING
EQUAL
SENDER
PREFERS
TO
BE
HIRED
BY
GO
TO
THE
BEACH
BY
IT
DOESN
T
MATTER
IF
SHE
SMART
OR
DULL
RECEIVER
WANTS
AN
EDUCATED
APPLICANT
SO
HIRES
IFF
SENDER
WENT
TO
COLLEGE
MORE
NOTATION
PAYOFFS
U
FOR
SENDER
V
FOR
RECEIVER
PURE
STRATEGIES
U
V
M
A
R
SENDER
HAS
ONLY
HER
TYPE

RECEIVER
HAS
ONLY
THE
MESSAGE
MIXED
STRATEGIES
SENDER
PROB
DISTRIBUTION
OVER
M
RECEIVER
DISTRIBUTION
OVER
A
M
M
A
M
A
M
M
A
SENDER
BEST
RESPONSE
FIX
A
MESSAGE
M
WE
KNOW
PAYOFF
FOR
M
IS
EXPECTED
VALUE
OVER
R
REACTION
EA
U
A
M
U
M
A
A
A
SENDER
BEST
RESPONSES
THEN
ARE
THE
MAX
UTILITY
MESSAGES
M
DEF
ARG
MA
X
A
M
U
M
A
IS
A
BEST
RESPONSE
TO
M
M
A
A
IF
IT
IS
NONZERO
ONLY
IN
M
I
E
SUPP
M
RECEIVER
BEST
RESPONSE
RECEIVER
HAS
OBTAINED
M
M
A
KNOWS
BUT
DOES
NOT
KNOW
LET
A
BE
THE
PROB
THAT
RCVR
PLAYS
A
AFTER
M
WISHES
TO
MAXIMIZE
HIS
EXPECTED
UTILITY
R
UPDATES
ITS
BELIEF
ABOUT
TYPE
GIVEN
M
MESSAGE
CARRIES
A
SIGNAL
ABOUT
TYPE
OF
R
DECIDES
BASED
ON
THE
POSTERIOR
BELIEF
RECEIVER
BELIEF
UPDATE
BAYES
RULE
P
M
P
M
P
M
P
M
P
M
IF
DENOMINATOR
IS
NON
THE
MESSAGE
IS
ON
PATH
SOME
SENDER
TYPE
HAS
A
NON
ZERO
PROBABILITY
OF
SENDING
M
RECEIVER
DECISION
RECEIVER
MAXIMIZES
HIS
UTILITY
FOR
EACH
MESSAGE
SEPARATELY
A
P
M
ARG
MAX
A
A
P
M
V
M
A
STRATEGY
IS
A
BEST
RESPONSE
TO
IFF
SUPP
M
REMEMBER
P
DEPENDS
ON
A
P
M
BAYESIAN
EQUILIBRIUM
DEFINITION
A
BAYESIAN
EQUILIBRIUM
OF
THE
R
GAME
IS
A
TRIPLE
SUCH
THAT
P
M
A
M
M
FOR
ALL
SUPP
FOR
ALL
ON
THE
PATH
MESSAGES
M
M
SUPP
M
THE
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
IS
CONSISTENT
WITH
THE
BAYES
RULE
IN
OUR
EXAMPLE
X
Y
L
R
T
SENDER
ACTION
IF
SMART
SENDER
ACTION
IF
DULL
RECEIVER
ACTION
IF
BEACH
IF
COLLEGE
RECEIVER
BELIEF
OF
SMART
IF
BEACH
IF
COLLEGE
IN
OUR
EXAMPLE
EQ
C
C
R
H

SENDER
ACTION
IF
SMART
SENDER
ACTION
IF
DULL
RECEIVER
ACTION
IF
BEACH
IF
COLLEGE
RECEIVER
BELIEF
OF
SMART
IF
BEACH
IF
COLLEGE
THIS
IS
A
BAYESIAN
EQUILIBRIUM
POOLING
STRATEGY
PROFILE
IN
OUR
EXAMPLE
EQ
B
B
R
R

SENDER
ACTION
IF
SMART
SENDER
ACTION
IF
DULL
RECEIVER
ACTION
IF
BEACH
IF
COLLEGE
RECEIVER
BELIEF
OF
SMART
IF
BEACH
IF
COLLEGE
THIS
IS
A
BAYESIAN
EQUILIBRIUM
BUT
AN
UNSTABLE
ONE
PERFECT
BAYESIAN
EQUILIBRIUM
DEFINITION
A
BAYESIAN
EQUILIBRIUM
OF
THE
R
GAME
IS
A
TRIPLE
SUCH
THAT
P
M
A
M
M
FOR
ALL
SUPP
FOR
ALL
ON
THE
PATH
MESSAGES
M
M
SUPP
M
THE
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
CONSISTENT
WITH
THE
BAYES
RULE
P
IS
EXISTENCE
OF
BAYESIAN
EQUILIBRIA
NASH
THM
A
MIXED
NASH
ALWAYS
EXISTS
IF
THERE
ARE
FINITELY
MANY
PLAYERS
WITH
FINITE
ACTION
SETS
CREATE
A
REGULAR
GAME
WITH

N
PLAYERS
REPLICATE
PLAYER
FOR
EACH
TYPE
P
P
WITH
UTILITIES
V
J
EUI
I
I
I
AGENT
PLAYS
WHAT
THE
CORRESPONDING
TYPED
AGENT
WOULD
IN
THE
CORRESPONDING
NORMAL
GAME
NASH
THM
GIVES
AN
EQUILIBRIUM
MIXTURE
OVER
STRATEGIES

THEN
I
J
W
P
I
J
IS
A
BAYESIAN
EQUILIBRIUM
MORE
TROUBLE
WITH
BAYESIAN
EQUILIBRIA
ADDITIONAL
CONDITIONS
OF
EQUILIBRIUM
REASONABLENESS
COLLEGE
IS
TOUGH
FOR
DULLS
EDUCATION
IS
UNPRODUCTIVE
NO
GAIN
FOR
RCVR
FROM
COLL
BUT
SIGNALS
THE
TYPE
OF
APPLICANT
C
B
R
H
IS
A
SEPARATING
PBE
SMART
TO
COLLEGE
REJECT
BEACHGOERS
BEACHGOERS
ARE
SMART
WP
COLLEGE
IS
TOUGH
FOR
DULLS
EDUCATION
IS
UNPRODUCTIVE
NO
GAIN
FOR
RCVR
FROM
COLL
B
B
R
R
T
T
IS
A
PBE
EVERYBODY
TO
BEACH
REJECT
EVERYBODY
BEACHGOERS
ARE
SMART
WP
PROBLEM
RCVR
INTERPRETS
DEVIATION
C
AS
COMING
FROM
A
TYPE

D
WHO
HAS
NO
INCENTIVE
TO
DEVIATE
DOMINATED
MESSAGES
COLLEGE
IS
DOMINATED
FOR
DULLS
WHATEVER
THE
OUTCOME
R
OR
H
DULL
TYPE
IS
BETTER
OFF
WITH
BEACH
DEFINITION
A
MESSAGE
M
IS
DOMINATED
FOR
IF
THERE
EXISTS
M
SUCH
THAT
MIN
A
A
M
U
M
A
MAX
A
A
M
U
M
A
WHERE
A
M
ARE
ALL
THE
ACTIONS
THAT
CAN
BE
A
BEST
RESPONSE
FOR
SOME
TYPE
A
M
A
P
M
P
M
TEST
OF
DOMINATED
MESSAGES
A
PBE
FAILS
THE
TEST
OF
DOMINATED
MESSAGES
IF
FOR
ANY
ARBITRARY
MESSAGE
M
THE
RECEIVER
PUTS
A
POSITIVE
WEIGHT
ON
THE
SENDER
BEING
OF
THE
TYPE
FOR
WHICH
THE
MESSAGE
IS
DOMINATED
THE
RECEIVER
ASSUMES
THE
SENDER
IS
IRRATIONAL
BECAUSE
SHE
SHOULD
HAVE
SENT
THE
DOMINATING
MESSAGE
TECHNICAL
NOTE
THERE
MUST
BE
SOME
TYPE
FOR
WHICH
M
IS
NOT
DOMINATED
OTHERWISE
A
TECHNICAL
PROBLEM
B
WE
ARE
COMPUTING
A
RESPONSE
TO
SOMETHING
A
FULLY
RATIONAL
AGENT
COULD
NOT
DO
EQUILIBRIUM
DOMINATION
B
B
H
R
T
T
IS
A
BE
THAT
PASSES
TEST
OF
DOMINATED
MESSAGES
EVERYBODY
GETS
HIRED
FOR
PTS
BUT
SMARTS
WANT
TO
DEVIATE
EQUILIBRIUM
DOMINATION
M
IS
EQUILIBRIUM
DOMINATED
WRT
EQ
IF
EXPECTED
PAYOFF
U
FROM
THE
EQUILIBRIUM
EXCEEDS
WHAT
THE
PLAYER
CAN
GET
BY
PLAYING
M
U
MAX
A
A
M
U
M
A
THE
DULL
SENDER
SHOULD
NOT
DEVIATE
P
DULL
COLLEGE
THANKS
FURTHER
READINGS
BOOK
SECTION
BAYESIAN
MECHANISM
DESIGN
JUNK
SLIDES
COMPLEXITY
RESULTS
ABOUT
NASH
EQUILIBRIA
VINCENT
CONITZER
AND
TUOMAS
SANDHOLM
CARNEGIE
MELLON
UNIVERSITY
COMPUTER
SCIENCE
DEPARTMENT
FORBES
AVENUE
PITTSBURGH
PA
USA
CONITZER
SANDHOLM
CS
CMU
EDU
ABSTRACT
NONCOOPERATIVE
GAME
THEORY
PROVIDES
A
NORMA
TIVE
FRAMEWORK
FOR
ANALYZING
STRATEGIC
INTERACTIONS
HOWEVER
FOR
THE
TOOLBOX
TO
BE
OPERATIONAL
THE
SO
LUTIONS
IT
DEFINES
WILL
HAVE
TO
BE
COMPUTED
IN
THIS
PAPER
WE
PROVIDE
A
SINGLE
REDUCTION
THAT
DEMON
STRATES
HARDNESS
OF
DETERMINING
WHETHER
NASH
EQUILIBRIA
WITH
CERTAIN
NATURAL
PROPERTIES
EXIST
AND
DEMONSTRATES
THE
HARDNESS
OF
COUNTING
NASH
EQUILIBRIA
OR
CONNECTED
SETS
OF
NASH
EQUILIBRIA
WE
ALSO
SHOW
THAT
DETERMINING
WHETHER
A
PURE
STRATEGY
BAYES
NASH
EQUILIBRIUM
EXISTS
IS
HARD
AND
THAT
DETERMINING
WHETHER
A
PURE
STRATEGY
NASH
EQUILIBRIUM
EXISTS
IN
A
STOCHASTIC
MARKOV
GAME
IS
HARD
EVEN
IF
THE
GAME
IS
INVISIBLE
THIS
REMAINS
HARD
IF
THE
GAME
IS
FI
NITE
ALL
OF
OUR
HARDNESS
RESULTS
HOLD
EVEN
IF
THERE
ARE
ONLY
TWO
PLAYERS
AND
THE
GAME
IS
SYMMETRIC
INTRODUCTION
NONCOOPERATIVE
GAME
THEORY
PROVIDES
A
NORMATIVE
FRAME
WORK
FOR
ANALYZING
STRATEGIC
INTERACTIONS
OF
AGENTS
HOWEVER
FOR
THE
TOOLBOX
TO
BE
OPERATIONAL
THE
SOLUTIONS
IT
DEFINES
WILL
HAVE
TO
BE
COMPUTED
THERE
HAS
BEEN
GROWING
INTEREST
IN
THE
COMPUTATIONAL
COMPLEXITY
OF
NATURAL
QUESTIONS
IN
GAME
THEORY
STARTING
AT
LEAST
AS
EARLY
AS
THE
COMPLEXITY
THE
ORISTS
HAVE
FOCUSED
ON
THE
COMPLEXITY
OF
PLAYING
PARTICULAR
HIGHLY
STRUCTURED
GAMES
USUALLY
BOARD
GAMES
SUCH
AS
CHESS
OR
GO
BUT
ALSO
GAMES
SUCH
AS
GEOGRAPHY
OR
QSAT
THESE
GAMES
TEND
TO
BE
ALTERNATING
MOVE
ZERO
SUM
GAMES
WITH
ENORMOUS
STATE
SPACES
WHICH
CAN
NEVERTHELESS
BE
CON
CISELY
REPRESENTED
DUE
TO
THE
SIMPLE
RULES
GOVERNING
THE
TRAN
SITION
BETWEEN
STATES
AS
A
RESULT
EFFORT
ON
FINDING
RESULTS
FOR
GENERAL
CLASSES
OF
GAMES
HAS
OFTEN
FOCUSED
ON
COMPLEX
LANGUAGES
IN
WHICH
SUCH
STRUCTURED
GAMES
CAN
BE
CONCISELY
REPRESENTED
REAL
WORLD
STRATEGIC
SETTINGS
ARE
GENERALLY
NOT
NEARLY
AS
STRUCTURED
NOR
DO
THEY
GENERALLY
POSSESS
THE
OTHER
PROPER
TIES
MOST
NOTABLY
ZERO
SUMNESS
OF
BOARD
GAMES
AND
THE
THE
MATERIAL
IN
THIS
PAPER
IS
BASED
UPON
WORK
SUPPORTED
BY
THE
NATIONAL
SCIENCE
FOUNDATION
UNDER
CAREER
AWARD
IRI
GRANT
IIS
ITR
IIS
AND
ITR
IIS
LIKE
ALGORITHMS
FOR
ANALYZING
THIS
MORE
GENERAL
CLASS
OF
GAMES
STRATEGICALLY
ARE
A
NECESSARY
COMPONENT
OF
SOPHISTI
CATED
AGENTS
THAT
ARE
TO
PLAY
SUCH
GAMES
ADDITIONALLY
THEY
ARE
NEEDED
BY
MECHANISM
DESIGNERS
WHO
HAVE
SOME
CON
TROL
OVER
THE
RULES
OF
THE
GAME
AND
WOULD
LIKE
THE
OUTCOME
OF
THE
GAME
TO
HAVE
CERTAIN
PROPERTIES
SUCH
AS
MAXIMUM
SOCIAL
WELFARE
NONCOOPERATIVE
GAME
THEORY
PROVIDES
LANGUAGES
FOR
REP
RESENTING
LARGE
CLASSES
OF
STRATEGIC
SETTINGS
AS
WELL
AS
SO
PHISTICATED
NOTIONS
OF
WHAT
IT
MEANS
TO
SOLVE
SUCH
GAMES
THE
BEST
KNOWN
SOLUTION
CONCEPT
IS
THAT
OF
NASH
EQUILIB
RIUM
WHERE
THE
PLAYERS
STRATEGIES
ARE
SUCH
THAT
NO
IN
DIVIDUAL
PLAYER
CAN
DERIVE
ANY
BENEFIT
FROM
DEVIATING
FROM
ITS
STRATEGY
THE
QUESTION
OF
HOW
COMPLEX
IT
IS
TO
CONSTRUCT
SUCH
AN
EQUILIBRIUM
HAS
BEEN
DUBBED
A
MOST
FUNDAMENTAL
COM
PUTATIONAL
PROBLEM
WHOSE
COMPLEXITY
IS
WIDE
OPEN
AND
TO
GETHER
WITH
FACTORING
THE
MOST
IMPORTANT
CONCRETE
OPEN
QUESTION
ON
THE
BOUNDARY
OF
TODAY
WHILE
THIS
QUESTION
REMAINS
OPEN
IMPORTANT
CONCRETE
AD
VANCES
HAVE
BEEN
MADE
IN
DETERMINING
THE
COMPLEXITY
OF
RE
LATED
QUESTIONS
FOR
EXAMPLE
PERSON
ZERO
SUM
GAMES
CAN
BE
SOLVED
USING
LINEAR
PROGRAMMING
IN
POLYNOMIAL
TIME
AS
ANOTHER
EXAMPLE
DETERMINING
THE
EXISTENCE
OF
A
JOINT
STRATEGY
WHERE
EACH
PLAYER
GETS
EXPECTED
PAYOFF
AT
LEAST
K
IS
P
COMPLETE
IN
A
CONCISELY
REPRESENTABLE
EXTENSIVE
FORM
GAME
WHERE
BOTH
PLAYERS
RECEIVE
THE
SAME
UTILITY
AS
YET
ANOTHER
EXAMPLE
IN
PLAYER
GENERAL
SUM
NORMAL
FORM
GAMES
DETERMINING
THE
EXISTENCE
OF
NASH
EQUILIBRIA
WITH
CER
TAIN
PROPERTIES
IS
P
HARD
FINALLY
THE
COMPLEXITY
OF
BEST
RESPONDING
OF
GUARANTEEING
PAYOFFS
AND
OF
FINDING
AN
EQUILIBRIUM
IN
REPEATED
AND
SEQUENTIAL
GAMES
HAS
BEEN
STUD
IED
IN
IN
THIS
PAPER
WE
PROVIDE
NEW
COMPLEXITY
RESULTS
ON
QUES
TIONS
RELATED
TO
NASH
EQUILIBRIA
IN
SECTION
WE
PROVIDE
A
SINGLE
REDUCTION
WHICH
SIGNIFICANTLY
IMPROVES
ON
MANY
OF
GILBOA
AND
ZEMEL
RESULTS
ON
DETERMINING
THE
EXISTENCE
OF
NASH
EQUILIBRIA
WITH
CERTAIN
PROPERTIES
IN
SECTION
WE
USE
THE
SAME
REDUCTION
TO
SHOW
THAT
COUNTING
THE
NUMBER
OF
NASH
EQUILIBRIA
OR
CONNECTED
SETS
OF
NASH
EQUILIBRIA
IS
P
HARD
IN
SECTION
WE
SHOW
THAT
DETERMINING
WHETHER
A
GAME
CAN
BE
CONVERTED
TO
A
NORMAL
FORM
GAME
AS
WELL
BUT
IT
WILL
GROW
EXPONENTIALLY
IN
SIZE
AND
THE
HARDNESS
RESULT
DOES
NOT
GO
THROUGH
PURE
STRATEGY
BAYES
NASH
EQUILIBRIUM
EXISTS
IS
HARD
FI
NALLY
IN
SECTION
WE
SHOW
THAT
DETERMINING
WHETHER
A
PURE
STRATEGY
NASH
EQUILIBRIUM
EXISTS
IN
A
STOCHASTIC
MARKOV
GAME
IS
HARD
EVEN
IF
THE
GAME
IS
INVISIBLE
THIS
REMAINS
HARD
IF
THE
GAME
IS
FINITE
ALL
OF
OUR
HARDNESS
RESULTS
HOLD
EVEN
IF
THERE
ARE
ONLY
TWO
PLAYERS
AND
THE
GAME
IS
SYMMETRIC
EQUILIBRIA
WITH
CERTAIN
PROPERTIES
IN
NORMAL
FORM
GAMES
WHEN
ONE
ANALYZES
THE
STRATEGIC
STRUCTURE
OF
A
GAME
ESPE
CIALLY
FROM
THE
VIEWPOINT
OF
A
MECHANISM
DESIGNER
WHO
TRIES
TO
CONSTRUCT
GOOD
RULES
FOR
A
GAME
FINDING
A
SINGLE
EQUILIB
RIUM
IS
FAR
FROM
SATISFACTORY
MORE
DESIRABLE
EQUILIBRIA
MAY
EXIST
IN
THIS
CASE
THE
GAME
BECOMES
MORE
ATTRACTIVE
ESPE
CIALLY
IF
ONE
CAN
COAX
THE
PLAYERS
INTO
PLAYING
A
DESIRABLE
EQUILIBRIUM
ALSO
LESS
DESIRABLE
EQUILIBRIA
MAY
EXIST
IN
THIS
CASE
THE
GAME
BECOMES
LESS
ATTRACTIVE
BEFORE
WE
CAN
MAKE
A
DEFINITE
JUDGMENT
ABOUT
THE
QUALITY
OF
THE
GAME
WE
WOULD
LIKE
TO
KNOW
THE
ANSWERS
TO
QUESTIONS
SUCH
AS
WHAT
IS
THE
GAME
MOST
DESIRABLE
EQUILIBRIUM
IS
THERE
A
UNIQUE
EQUILIB
RIUM
IF
NOT
HOW
MANY
EQUILIBRIA
ARE
THERE
ALGORITHMS
THAT
TACKLE
THESE
QUESTIONS
WOULD
BE
USEFUL
BOTH
TO
PLAYERS
AND
TO
THE
MECHANISM
DESIGNER
FURTHERMORE
ALGORITHMS
THAT
ANSWER
CERTAIN
EXISTENCE
QUESTIONS
MAY
PAVE
THE
WAY
TO
DESIGNING
ALGORITHMS
THAT
CON
STRUCT
A
NASH
EQUILIBRIUM
FOR
EXAMPLE
IF
WE
HAD
AN
ALGO
RITHM
THAT
TOLD
US
WHETHER
THERE
EXISTS
ANY
EQUILIBRIUM
WHERE
A
CERTAIN
PLAYER
PLAYS
A
CERTAIN
STRATEGY
THIS
COULD
BE
USEFUL
IN
ELIMINATING
POSSIBILITIES
IN
THE
SEARCH
FOR
A
NASH
EQUILIBRIUM
HOWEVER
ALL
THE
EXISTENCE
QUESTIONS
THAT
WE
HAVE
INVESTI
GATED
TURN
OUT
TO
BE
HARD
THESE
ARE
NOT
THE
FIRST
RESULTS
OF
THIS
NATURE
MOST
NOTABLY
GILBOA
AND
ZEMEL
PROVIDE
SOME
HARDNESS
RESULTS
IN
THE
SAME
SPIRIT
WE
PROVIDE
A
SIN
GLE
REDUCTION
WHICH
IN
DEMONSTRATES
SOMETIMES
STRONGER
VER
SIONS
OF
MOST
OF
THEIR
HARDNESS
RESULTS
AND
INTERESTING
NEW
RESULTS
ADDITIONALLY
AS
WE
SHOW
IN
SECTION
THE
REDUCTION
SHOWS
P
HARDNESS
OF
COUNTING
THE
NUMBER
OF
EQUILIBRIA
DEFINITION
LET

BE
A
BOOLEAN
FORMULA
IN
CONJUNCTIVE
NOR
MAL
FORM
LET
V
BE
ITS
SET
OF
VARIABLES
WITH
V
N
L
THE
SET
OF
CORRESPONDING
LITERALS
A
POSITIVE
AND
A
NEGATIVE
ONE
FOR
EACH
VARIABLE
AND
C
ITS
SET
OF
CLAUSES
THE
FUNC
TION
V
L
V
GIVES
THE
VARIABLE
CORRESPONDING
TO
A
LIT
ERAL
E
G
V
V
WE
DEFINE
G

TO
BE
THE
FOLLOWING
SYMMETRIC
PLAYER
GAME
IN
NORMAL
FORM
LET

L
V
C
F
LET
THE
UTILITY
FUNCTIONS
FOR
ALL
L
WITH
L
L
L
L
FOR
ALL
L
L
L
X
X
L
FOR
ALL
L
L
X

L
V
L
L
V
FOR
ALL
V
V
L
L
WITH
V
L
V
V
L
L
V
N
FOR
ALL
V
V
L
L
WITH
V
L
V
V
X
X
V
FOR
ALL
V
V
X

L
C
L
L
C
FOR
ALL
C
C
L
L
WITH
L
C
C
L
L
C
N
FOR
ALL
C
C
L
L
WITH
L
C
C
X
X
C
FOR
ALL
C
C
X

L
F
F
F
F
F
X
X
F
FOR
ALL
X

F
THEOREM
IF
LN
WHERE
V
LI
XI
SATISFIES

THEN
THERE
IS
A
NASH
EQUILIBRIUM
OF
G

WHERE
BOTH
PLAYERS
PLAY
LI
WITH
PROBABILITY
WITH
EXPECTED
UTILITY
FOR
EACH
PLAYER
THE
ONLY
OTHER
NASH
EQUILIBRIUM
IS
THE
ONE
WHERE
BOTH
PLAYERS
PLAY
F
AND
RECEIVE
EXPECTED
UTILITY
EACH
PROOF
WE
FIRST
DEMONSTRATE
THAT
THESE
COMBINATIONS
OF
MIXED
STRATEGIES
INDEED
DO
CONSTITUTE
NASH
EQUILIBRIA
IF
LN
WHERE
V
LI
XI
SATISFIES

AND
THE
OTHER
PLAYER
PLAYS
LI
WITH
PROBABILITY
PLAYING
ONE
OF
THESE
LI
AS
WELL
GIVES
UTILITY
ON
THE
OTHER
HAND
PLAYING
THE
NEGATION
OF
ONE
OF
THESE
LI
GIVES
UTILITY
N
PLAY
ING
SOME
VARIABLE
V
GIVES
UTILITY
N
N
SINCE
ONE
OF
THE
L
WE
FIRST
NEED
SOME
STANDARD
DEFINITIONS
FROM
GAME
THEORY
DEFINITION
IN
A
NORMAL
FORM
GAME
WE
ARE
GIVEN
A
SET
OF
AGENTS
A
AND
FOR
EACH
AGENT
I
A
STRATEGY
SET
I
AND
A
UTILITY
FUNCTION
UI

A
R
DEFINITION
A
MIXED
STRATEGY
I
FOR
PLAYER
I
IS
A
PROBABILITY
DISTRIBUTION
OVER
I
A
SPECIAL
CASE
OF
A
MIXED
STRATEGY
IS
A
PURE
STRATEGY
WHERE
ALL
OF
THE
PROBABILITY
MASS
IS
ON
ONE
ELEMENT
OF
I
DEFINITION
NASH
GIVEN
A
NORMAL
FORM
GAME
A
NASH
EQUILIBRIUM
NE
IS
VECTOR
OF
MIXED
STRATEGIES
ONE
FOR
EACH
AGENT
I
SUCH
THAT
NO
AGENT
HAS
AN
INCENTIVE
TO
DEVIATE
FROM
ITS
MIXED
STRATEGY
GIVEN
THAT
THE
OTHERS
DO
NOT
DEVIATE
THAT
IS
FOR
ANY
I
AND
ANY
ALTERNATIVE
MIXED
STRATEGY
IL
WE
HAVE
E
UI
SI
A
E
UI
SLI
A
WHERE
EACH
SI
IS
DRAWN
FROM
I
THAT
THE
OTHER
PLAYER
SOMETIMES
PLAYS
HAS
V
LI
V
PLAYING
SOME
CLAUSE
C
GIVES
UTILITY
AT
MOST
N
N
SINCE
ONE
OF
THE
LI
THAT
THE
OTHER
PLAYER
SOMETIMES
PLAYS
OCCURS
IN
CLAUSE
C
SINCE
THE
LI
SATISFY

FINALLY
PLAYING
F
GIVES
UTILITY
IT
FOLLOWS
THAT
PLAYING
ANY
ONE
OF
THE
LI
THAT
THE
OTHER
PLAYER
SOMETIMES
PLAYS
IS
AN
OPTIMAL
RESPONSE
AND
HENCE
THAT
BOTH
PLAYERS
PLAYING
EACH
OF
THESE
LI
WITH
PROBABILITY
IS
A
NASH
EQUILIBRIUM
CLEARLY
BOTH
PLAYERS
PLAYING
F
IS
ALSO
A
NASH
EQUILIBRIUM
SINCE
PLAY
ING
ANYTHING
ELSE
WHEN
THE
OTHER
PLAYS
F
GIVES
UTILITY
NOW
WE
DEMONSTRATE
THAT
THERE
ARE
NO
OTHER
NASH
EQUILIB
RIA
IF
THE
OTHER
PLAYER
ALWAYS
PLAYS
F
THE
UNIQUE
BEST
RE
SPONSE
IS
TO
ALSO
PLAY
F
SINCE
PLAYING
ANYTHING
ELSE
WILL
GIVE
UTILITY
OTHERWISE
GIVEN
A
MIXED
STRATEGY
FOR
THE
OTHER
PLAYER
CONSIDER
A
PLAYER
EXPECTED
UTILITY
GIVEN
THAT
THE
OTHER
PLAYER
DOES
NOT
PLAY
F
THAT
IS
THE
PROBABILITY
DISTRIBUTION
OVER
THE
OTHER
PLAYER
STRATEGIES
IS
PROPORTIONAL
TO
THE
PROBA
BILITY
DISTRIBUTION
CONSTITUTED
BY
THAT
PLAYER
MIXED
STRATEGY
I
AND
SLI
FROM
IL
IF
IS
A
VARIABLE
AND
ARE
LITERALS
WE
MAKE
A
NOW
WE
ARE
READY
TO
PRESENT
OUR
REDUCTION
DISTINCTION
BETWEEN
THE
VARIABLE
AND
THE
LITERAL
EXCEPT
F
OCCURS
WITH
PROBABILITY
IF
THIS
EXPECTED
UTILITY
IS
LESS
THAN
THE
PLAYER
IS
STRICTLY
BETTER
OFF
PLAYING
F
WHICH
GIVES
UTILITY
WHEN
THE
OTHER
PLAYER
DOES
NOT
PLAY
F
AND
ALSO
PERFORMS
BETTER
THAN
THE
ORIGINAL
STRATEGY
WHEN
THE
OTHER
PLAYER
DOES
PLAY
F
SO
THIS
CANNOT
OCCUR
IN
EQUILIBRIUM
THERE
ARE
NO
NASH
EQUILIBRIA
WHERE
ONE
PLAYER
ALWAYS
PLAYS
F
BUT
THE
OTHER
DOES
NOT
SO
SUPPOSE
BOTH
PLAYERS
PLAY
F
WITH
PROBABILITY
LESS
THAN
ONE
CONSIDER
THE
EXPECTED
SOCIAL
WELFARE
E
GIVEN
THAT
NEITHER
PLAYER
PLAYS
F
IT
IS
EASILY
VERIFIED
THAT
THERE
IS
NO
OUTCOME
WITH
SOCIAL
WELFARE
GREATER
THAN
ALSO
ANY
OUTCOME
IN
WHICH
ONE
PLAYER
PLAYS
AN
ELEMENT
OF
V
OR
C
HAS
SOCIAL
WELFARE
STRICTLY
BELOW
IT
FOLLOWS
THAT
IF
EITHER
PLAYER
EVER
PLAYS
AN
ELEMENT
OF
V
OR
C
THE
EXPECTED
SOCIAL
WELFARE
GIVEN
THAT
NEITHER
PLAYER
PLAYS
F
IS
STRICTLY
BELOW
BY
LINEARITY
OF
EXPECTATION
IT
FOLLOWS
THAT
THE
EXPECTED
UTILITY
OF
AT
LEAST
ONE
PLAYER
IS
STRICTLY
BELOW
GIVEN
THAT
NEITHER
PLAYER
PLAYS
F
AND
BY
THE
ABOVE
REASONING
THIS
PLAYER
WOULD
BE
STRICTLY
BETTER
OFF
PLAYING
F
INSTEAD
OF
ITS
RANDOMIZATION
OVER
STRATEGIES
OTHER
THAN
F
IT
FOLLOWS
THAT
NO
ELEMENT
OF
V
OR
C
IS
EVER
PLAYED
IN
A
NASH
EQUILIBRIUM
SO
WE
CAN
ASSUME
BOTH
PLAYERS
ONLY
PUT
POSITIVE
PROBABIL
ITY
ON
STRATEGIES
IN
L
F
THEN
IF
THE
OTHER
PLAYER
PUTS
POS
ITIVE
PROBABILITY
ON
F
PLAYING
F
IS
A
STRICTLY
BETTER
RESPONSE
THAN
ANY
ELEMENT
OF
L
SINCE
BOTH
GIVE
UTILITY
IF
THE
OTHER
PLAYER
PLAYS
AN
ELEMENT
OF
L
BUT
F
DOES
BETTER
IF
THE
OTHER
PLAYER
PLAYS
F
IT
FOLLOWS
THAT
THE
ONLY
EQUILIBRIUM
WHERE
F
IS
EVER
PLAYED
IS
THE
ONE
WHERE
BOTH
PLAYERS
ALWAYS
PLAY
F
NOW
WE
CAN
ASSUME
THAT
BOTH
PLAYERS
ONLY
PUT
POSITIVE
PROBABILITY
ON
ELEMENTS
OF
L
SUPPOSE
THAT
FOR
SOME
L
L
THE
PROBABILITY
THAT
A
GIVEN
PLAYER
PLAYS
EITHER
L
OR
L
IS
LESS
THAN
THEN
THE
EXPECTED
UTILITY
FOR
THE
OTHER
PLAYER
OF
PLAY
HARD
FOR
ANY
SUCH
DEFINITION
ADDITIONALLY
THE
FIRST
KIND
OF
EQUILIBRIUM
IS
IN
VARIOUS
SENSES
AN
OPTIMAL
OUTCOME
FOR
THE
GAME
EVEN
IF
THE
PLAYERS
WERE
TO
COOPERATE
SO
EVEN
FINDING
OUT
WHETHER
SUCH
AN
OPTIMAL
EQUILIBRIUM
EXISTS
IS
HARD
THE
FOLLOWING
COROLLARIES
ILLUSTRATE
THESE
POINTS
EACH
COROLLARY
IS
IMMEDIATE
FROM
THEOREM
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
IT
IS
HARD
TO
DETERMINE
WHETHER
THERE
EXISTS
A
NE
WITH
EXPECTED
STANDARD
SOCIAL
WELFARE
E
UI
AT
LEAST
K
EVEN
I
A
WHEN
K
IS
THE
MAXIMUM
SOCIAL
WELFARE
THAT
COULD
BE
OBTAINED
IN
THE
GAME
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
IT
IS
HARD
TO
DETERMINE
WHETHER
THERE
EXISTS
A
NE
WHERE
ALL
PLAYERS
HAVE
EXPECTED
UTILITY
AT
LEAST
K
EVEN
WHEN
K
IS
THE
LARGEST
NUMBER
SUCH
THAT
THERE
EXISTS
A
DISTRIBUTION
OVER
OUTCOMES
OF
THE
GAME
SUCH
THAT
ALL
PLAYERS
HAVE
EXPECTED
UTILITY
AT
LEAST
K
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
IT
IS
HARD
TO
DETERMINE
WHETHER
THERE
EXISTS
A
PARETO
OPTIMAL
NE
A
DISTRIBUTION
OVER
OUTCOMES
IS
PARETO
OPTIMAL
IF
THERE
IS
NO
OTHER
DISTRIBUTION
OVER
OUTCOMES
SUCH
THAT
EVERY
PLAYER
HAS
AT
LEAST
EQUAL
EXPECTED
UTILITY
AND
AT
LEAST
ONE
PLAYER
HAS
STRICTLY
GREATER
EXPECTED
UTILITY
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
IT
IS
HARD
TO
DETERMINE
WHETHER
THERE
EXISTS
A
NE
WHERE
PLAYER
HAS
EXPECTED
UTILITY
AT
LEAST
K
SOME
ADDITIONAL
INTERESTING
COROLLARIES
ARE
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
IT
IS
NP
ING
N
IS
STRICTLY
GREATER
THAN
N
HARD
TO
DETERMINE
WHETHER
THERE
IS
MORE
THAN
ONE
NASH
EQUI
HENCE
THIS
CANNOT
BE
A
NASH
EQUILIBRIUM
SO
WE
CAN
ASSUME
THAT
FOR
ANY
L
L
THE
PROBABILITY
THAT
A
GIVEN
PLAYER
PLAYS
N
IF
THERE
IS
AN
ELEMENT
OF
L
SUCH
THAT
PLAYER
PUTS
POSI
TIVE
PROBABILITY
ON
IT
AND
PLAYER
ON
ITS
NEGATION
BOTH
PLAY
ERS
HAVE
EXPECTED
UTILITY
LESS
THAN
AND
WOULD
BE
BETTER
OFF
SWITCHING
TO
F
SO
IN
A
NASH
EQUILIBRIUM
IF
PLAYER
PLAYS
L
WITH
SOME
PROBABILITY
PLAYER
MUST
PLAY
L
WITH
PROBABILITY
AND
THUS
PLAYER
MUST
PLAY
L
WITH
PROBABILITY
THUS
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
IT
IS
HARD
TO
DETERMINE
WHETHER
THERE
IS
AN
EQUILIBRIUM
WHERE
PLAYER
SOMETIMES
PLAYS
X
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
IT
IS
HARD
TO
DETERMINE
WHETHER
THERE
IS
AN
EQUILIBRIUM
WHERE
PLAYER
NEVER
PLAYS
X
ALL
OF
THESE
RESULTS
INDICATE
THAT
IT
IS
HARD
TO
OBTAIN
SUM
N
N
MARY
INFORMATION
ABOUT
A
GAME
NASH
EQUILIBRIA
COROL
WE
CAN
ASSUME
THAT
FOR
EACH
VARIABLE
EXACTLY
ONE
OF
ITS
COR
RESPONDING
LITERALS
IS
PLAYED
WITH
PROBABILITY
BY
BOTH
PLAY
ERS
IT
FOLLOWS
THAT
IN
ANY
NASH
EQUILIBRIUM
BESIDES
THE
ONE
WHERE
BOTH
PLAYERS
PLAY
F
LITERALS
THAT
ARE
SOMETIMES
PLAYED
INDEED
CORRESPOND
TO
AN
ASSIGNMENT
TO
THE
VARIABLES
ALL
THAT
IS
LEFT
TO
SHOW
IS
THAT
IF
THIS
ASSIGNMENT
DOES
NOT
SATISFY

IT
DOES
NOT
CORRESPOND
TO
A
NASH
EQUILIBRIUM
LET
C
C
BE
A
CLAUSE
THAT
IS
NOT
SATISFIED
BY
THE
ASSIGNMENT
THAT
IS
NONE
OF
ITS
LITERALS
ARE
EVER
PLAYED
THEN
PLAYING
C
WOULD
GIVE
UTILITY
AND
BOTH
PLAYERS
WOULD
BE
BETTER
OFF
PLAYING
THIS
HENCE
THERE
EXISTS
A
NASH
EQUILIBRIUM
IN
G

WHERE
EACH
PLAYER
GETS
UTILITY
IF
AND
ONLY
IF

IS
SATISFIABLE
OTHERWISE
LARY
AND
VERSIONS
OF
COROLLARIES
AND
WERE
FIRST
PROVEN
BY
GILBOA
AND
ZEMEL
COUNTING
THE
NUMBER
OF
EQUILIBRIA
IN
NORMAL
FORM
GAMES
EXISTENCE
QUESTIONS
DO
NOT
TELL
THE
WHOLE
STORY
IN
GENERAL
WE
ARE
INTERESTED
IN
CHARACTERIZING
ALL
THE
EQUILIBRIA
OF
A
GAME
ONE
RATHER
WEAK
SUCH
CHARACTERIZATION
IS
THE
NUMBER
OF
EQUI
WE
CAN
USE
THEOREM
TO
SHOW
THAT
EVEN
DETERMINING
THIS
NUMBER
IN
A
GIVEN
NORMAL
FORM
GAME
IS
HARD
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
COUNTING
THE
NUMBER
OF
NASH
EQUILIBRIA
IS
P
HARD
EACH
OF
THEM
GETS
SINCE
ANY
SENSIBLE
DEFINITION
OF
WELFARE
OPTIMIZATION
WOULD
PREFER
THE
FIRST
KIND
OF
EQUILIBRIUM
IT
FOL
LOWS
THAT
DETERMINING
WHETHER
A
GOOD
EQUILIBRIUM
EXISTS
IS
RESULTS
PROVE
HARDNESS
IN
A
SLIGHTLY
MORE
RESTRICTED
SETTING
NUMBER
OF
EQUILIBRIA
IN
NORMAL
FORM
GAMES
HAS
BEEN
STUD
IED
BOTH
IN
THE
WORST
CASE
AND
IN
THE
AVERAGE
CASE
PROOF
THE
NUMBER
OF
NASH
EQUILIBRIA
IN
OUR
GAME
G

IS
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
TO
THE
VARIABLES
OF

E
I
I
E
UI
I
SLI
I
A

A
WHERE
EACH
SI

IS
DRAWN
FROM
I

AND
SL
FROM
L
PLUS
ONE
COUNTING
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
TO
A
I
I
I
I
I
I
CNF
FORMULA
IS
P
HARD
IT
IS
EASY
TO
CONSTRUCT
GAMES
WHERE
THERE
IS
A
CONTINUUM
OF
NASH
EQUILIBRIA
IN
SUCH
GAMES
IT
IS
MORE
MEANINGFUL
TO
ASK
HOW
MANY
DISTINCT
CONTINUUMS
OF
EQUILIBRIA
THERE
ARE
MORE
FORMALLY
ONE
CAN
ASK
HOW
MANY
MAXIMAL
CONNECTED
SETS
OF
EQUILIBRIA
A
GAME
HAS
A
MAXIMAL
CONNECTED
SET
IS
A
CONNECTED
SET
WHICH
IS
NOT
A
PROPER
SUBSET
OF
A
CONNECTED
SET
COROLLARY
EVEN
IN
SYMMETRIC
PLAYER
GAMES
COUNTING
THE
WE
CAN
NOW
DEFINE
THE
COMPUTATIONAL
PROBLEM
DEFINITION
PURE
STRATEGY
BNE
WE
ARE
GIVEN
A
BAYESIAN
GAME
WE
ARE
ASKED
WHETHER
THERE
EXISTS
A
BNE
WHERE
ALL
THE
STRATEGIES
I
I
ARE
PURE
TO
SHOW
OUR
HARDNESS
RESULT
WE
WILL
REDUCE
FROM
THE
SET
COVER
PROBLEM
DEFINITION
SET
COVER
WE
ARE
GIVEN
A
SET
SN
SUBSETS
SM
OF
WITH
PROOF
EVERY
NASH
EQUILIBRIUM
IN
G

CONSTITUTES
A
MAXI
MAL
CONNECTED
SET
BY
ITSELF
SO
THE
NUMBER
OF
MAXIMAL
CON
NECTED
SETS
IS
THE
NUMBER
OF
SATISFYING
ASSIGNMENTS
TO
THE
VARIABLES
OF

PLUS
ONE
THE
MOST
INTERESTING
HARDNESS
RESULTS
ARE
THE
ONES
WHERE
THE
CORRESPONDING
EXISTENCE
AND
SEARCH
QUESTIONS
ARE
EASY
SUCH
AS
COUNTING
THE
NUMBER
OF
PERFECT
BIPARTITE
MATCHINGS
IN
THE
CASE
OF
NASH
EQUILIBRIA
THE
EXISTENCE
QUESTION
IS
TRIVIAL
IT
HAS
BEEN
ANALYTICALLY
SHOWN
BY
KAKUTANI
FIXED
POINT
THE
OREM
THAT
A
NASH
EQUILIBRIUM
ALWAYS
EXISTS
THE
COM
PLEXITY
OF
THE
SEARCH
QUESTION
REMAINS
OPEN
PURE
STRATEGY
BAYES
NASH
EQUILIBRIA
EQUILIBRIA
IN
PURE
STRATEGIES
ARE
PARTICULARLY
DESIRABLE
BECAUSE
THEY
AVOID
THE
UNCOMFORTABLE
REQUIREMENT
THAT
PLAYERS
RAN
DOMIZE
OVER
STRATEGIES
AMONG
WHICH
THEY
ARE
INDIFFERENT
IN
NORMAL
FORM
GAMES
WITH
SMALL
NUMBERS
OF
PLAYERS
IT
IS
EASY
TO
DETERMINE
THE
EXISTENCE
OF
PURE
STRATEGY
EQUILIBRIA
ONE
CAN
SIMPLY
CHECK
FOR
EACH
COMBINATION
OF
PURE
STRATE
GIES
WHETHER
IT
CONSTITUTES
A
NASH
EQUILIBRIUM
HOWEVER
THIS
IS
NOT
FEASIBLE
IN
BAYESIAN
GAMES
WHERE
THE
PLAYERS
HAVE
PRIVATE
INFORMATION
ABOUT
THEIR
OWN
PREFERENCES
REPRESENTED
BY
TYPES
HERE
PLAYERS
MAY
CONDITION
THEIR
ACTIONS
ON
THEIR
TYPES
SO
THE
STRATEGY
SPACE
OF
EACH
PLAYER
IS
EXPONENTIAL
IN
THE
NUMBER
OF
TYPES
IN
THIS
SECTION
WE
SHOW
THAT
THE
QUESTION
OF
WHETHER
A
PURE
STRATEGY
BAYES
NASH
EQUILIBRIUM
EXISTS
IS
IN
FACT
HARD
EVEN
IN
SYMMETRIC
TWO
PLAYER
GAMES
FIRST
WE
NEED
THE
STANDARD
DEFINITION
OF
A
BAYESIAN
GAME
AND
BAYES
NASH
EQUI
LIBRIUM
FROM
GAME
THEORY
DEFINITION
IN
A
BAYESIAN
GAME
WE
ARE
GIVEN
A
SET
OF
AGENTS
A
FOR
EACH
AGENT
I
A
SET
OF
TYPES
I
A
COMMONLY
KNOWN
PRIOR
DISTRIBUTION

OVER

A
FOR
EACH
AGENT
I
A
SET
OF
STRATEGIES
I
AND
FOR
EACH
AGENT
I
A
UTILITY
FUNCTION
UI
I

A
R
THEOREM
PURE
STRATEGY
BNE
IS
HARD
EVEN
IN
SYMMETRIC
PLAYER
GAMES
WHERE

IS
UNIFORM
PROOF
WE
REDUCE
AN
ARBITRARY
SET
COVER
INSTANCE
TO
THE
FOLLOWING
PURE
STRATEGY
BNE
INSTANCE
LET
THERE
BE
TWO
PLAYERS
WITH

K

IS
UNIFORM
FURTHERMORE

SM
SN
THE
UTILITY
FUNCTIONS
WE
CHOOSE
IN
FACT
DO
NOT
DEPEND
ON
THE
TYPES
SO
WE
OMIT
THE
TYPE
ARGUMENT
IN
THEIR
DEFINITIONS
THEY
ARE
AS
FOLLOWS
SI
SJ
SJ
SI
FOR
ALL
SI
AND
SJ
SI
SJ
SJ
SI
FOR
ALL
SI
AND
SJ
SI
SI
SJ
SJ
SI
FOR
ALL
SI
AND
SJ
SI
SI
SJ
SJ
SI
FOR
ALL
SI
AND
SJ
SJ
SI
SI
SJ
FOR
ALL
SI
AND
SJ
SI
SJ
SI
SI
SJ
FOR
ALL
SI
AND
SJ
SI
WE
NOW
SHOW
THE
TWO
INSTANCES
ARE
EQUIVALENT
FIRST
SUP
POSE
THERE
EXIST
SCK
SUCH
THAT
I
K
SCI
SUPPOSE
BOTH
PLAYERS
PLAY
AS
FOLLOWS
WHEN
THEIR
TYPE
IS
I
THEY
PLAY
SCI
WE
CLAIM
THAT
THIS
IS
A
BNE
FOR
SUPPOSE
THE
OTHER
PLAYER
EMPLOYS
THIS
STRATEGY
THEN
BECAUSE
FOR
ANY
SJ
THERE
IS
AT
LEAST
ONE
SCI
SUCH
THAT
SJ
SCI
WE
HAVE
THAT
THE
EXPECTED
UTILITY
OF
PLAYING
SJ
IS
AT
MOST
K
IT
FOLLOWS
THAT
PLAYING
ANY
OF
THE
SJ
WHICH
GIVES
UTILITY
IS
OPTIMAL
SO
THERE
IS
A
PURE
STRATEGY
BNE
ON
THE
OTHER
HAND
SUPPOSE
THAT
THERE
IS
A
PURE
STRATEGY
BNE
WE
FIRST
OBSERVE
THAT
IN
NO
PURE
STRATEGY
BNE
BOTH
PLAYERS
PLAY
SOME
ELEMENT
OF
FOR
SOME
TYPE
FOR
IF
THE
OTHER
PLAYER
SOMETIMES
PLAYS
SOME
SJ
THE
UTILITY
OF
PLAYING
SOME
SI
IS
AT
MOST
K
WHEREAS
PLAYING
SOME
SI
INSTEAD
GUARANTEES
A
UTILITY
OF
AT
LEAST
SO
THERE
IS
AT
LEAST
ONE
PLAYER
WHO
NEVER
PLAYS
ANY
ELEMENT
OF
NOW
SUPPOSE
THE
OTHER
PLAYER
SOMETIMES
PLAYS
SOME
SJ
WE
KNOW
THERE
IS
SOME
SI
SUCH
THAT
SJ
SI
IF
THE
FORMER
PLAYER
PLAYS
THIS
SI
THIS
WILL
GIVE
IT
A
UTILITY
OF
AT
LEAST
K
DEFINITION
HARSANYI
GIVEN
A
BAYESIAN
GAME
A
BAYES
NASH
EQUILIBRIUM
BNE
IS
A
VECTOR
OF
MIXED
STRATE
GIES
ONE
FOR
EACH
PAIR
I
I
I
SUCH
THAT
NO
AGENT
HAS
AN
INCENTIVE
TO
DEVIATE
FOR
ANY
OF
ITS
TYPES
GIVEN
THAT
THE
OTHERS
DO
NOT
DEVIATE
THAT
IS
FOR
ANY
I
I
I
AND
ANY
ALTERNATIVE
L
SINCE
IT
MUST
DO
AT
LEAST
THIS
WELL
IN
THE
EQUILIBRIUM
AND
IT
NEVER
PLAYS
ELEMENTS
OF
IT
MUST
SOMETIMES
RECEIVE
UTILITY
IT
FOLLOWS
THAT
THERE
EXIST
SA
AND
SB
SA
SUCH
THAT
THE
FORMER
PLAYER
SOMETIMES
PLAYS
SA
AND
THE
LATTER
SOMETIMES
PLAYS
SB
BUT
THEN
PLAYING
SB
GIVES
THE
LATTER
PLAYER
A
UTILITY
OF
AT
MOST
K
AND
IT
WOULD
BE
BETTER
OFF
I
E
I
I
E
UI
I
SI
I
A

A
PLAYING
SOME
SI
INSTEAD
CONTRADICTION
IT
FOLLOWS
THAT
IN
NO
PURE
STRATEGY
BNE
ANY
ELEMENT
OF
IS
EVER
PLAYED
NOW
IN
OUR
GIVEN
PURE
STRATEGY
EQUILIBRIUM
CONSIDER
THE
SET
OF
ALL
THE
SI
THAT
ARE
PLAYED
BY
PLAYER
FOR
SOME
TYPE
CLEARLY
THERE
CAN
BE
AT
MOST
K
SUCH
SETS
WE
CLAIM
THEY
COVER
FOR
IF
THEY
DO
NOT
COVER
SOME
ELEMENT
THE
EXPECTED
OFF
TO
PLAYER
I
IN
STATE
WHERE
THE
PLAYERS
PLAY
ACTIONS
A
A
A
DISCOUNT
FACTOR

SUCH
THAT
THE
TOTAL
UTILITY
OF
AGENT
J
I
IS
KU
SK
AK
AK
WHERE
SK
IS
THE
STATE
NEVER
PLAYS
ANY
ELEMENT
OF
EITHER
IS
NOT
PLAYING
OPTIMALLY
CONTRADICTION
HENCE
THERE
EXISTS
A
SET
COVER
AK
AK
A
IN
STAGE
K
IF
ONE
ALLOWS
FOR
GENERAL
MIXED
STRATEGIES
A
BAYES
NASH
EQUILIBRIUM
ALWAYS
EXISTS
HOWEVER
THE
QUESTION
OF
HOW
EFFICIENTLY
ONE
CAN
BE
CONSTRUCTED
REMAINS
OPEN
PURE
STRATEGY
NASH
EQUILIBRIA
IN
STOCHASTIC
MARKOV
GAMES
WE
NOW
SHIFT
OUR
ATTENTION
FROM
SINGLE
SHOT
GAMES
TO
GAMES
WITH
MULTIPLE
STAGES
IN
EACH
STAGE
THE
PLAYERS
GET
TO
ACT
AND
OBTAIN
PAYOFFS
THERE
HAS
ALREADY
BEEN
SOME
RESEARCH
INTO
THE
COMPLEXITY
OF
PLAYING
REPEATED
AND
SEQUENTIAL
GAMES
FOR
EX
AMPLE
DETERMINING
WHETHER
A
PARTICULAR
AUTOMATON
IS
A
BEST
RESPONSE
IS
COMPLETE
IT
IS
COMPLETE
TO
COMPUTE
A
BEST
RESPONSE
AUTOMATON
WHEN
THE
AUTOMATA
UNDER
CONSID
ERATION
ARE
BOUNDED
THE
QUESTION
OF
WHETHER
A
GIVEN
PLAYER
WITH
IMPERFECT
RECALL
CAN
GUARANTEE
ITSELF
A
GIVEN
PAY
OFF
USING
PURE
STRATEGIES
IS
COMPLETE
AND
IN
GENERAL
BEST
RESPONDING
TO
AN
ARBITRARY
STRATEGY
CAN
EVEN
BE
NONCOM
PUTABLE
IN
THIS
SECTION
WE
PRESENT
TO
OUR
KNOWLEDGE
THE
FIRST
PSPACE
HARDNESS
RESULT
ON
THE
EXISTENCE
OF
A
PURE
IN
GENERAL
A
PLAYER
NEED
NOT
ALWAYS
BE
AWARE
OF
THE
CUR
RENT
STATE
OF
THE
GAME
THE
ACTIONS
THE
OTHERS
PLAYED
IN
PRE
VIOUS
STAGES
OR
THE
PAYOFFS
THAT
THE
PLAYER
HAS
ACCUMULATED
IN
THE
EXTREME
CASE
PLAYERS
NEVER
FIND
OUT
ANY
OF
THESE
AND
ARE
HENCE
PLAYING
BLINDLY
WE
CALL
SUCH
A
MARKOV
GAME
IN
VISIBLE
IT
IS
RELATIVELY
EASY
TO
SPECIFY
A
PURE
STRATEGY
IN
AN
INVISIBLE
MARKOV
GAME
BECAUSE
THERE
IS
NOTHING
TO
CONDITION
ON
HENCE
SUCH
A
STRATEGY
IS
SIMPLY
AN
INFINITE
SEQUENCE
OF
ACTIONS
FOR
PLAYER
I
A
SEQUENCE
AK
WHERE
IT
PLAYS
ACTION
AK
IN
STAGE
K
REGARDLESS
IN
SPITE
OF
THIS
APPARENT
SIMPLICITY
OF
THE
GAME
WE
SHOW
THAT
DETERMINING
WHETHER
PURE
STRATEGY
EQUILIBRIA
EXIST
IS
EXTREMELY
HARD
DEFINITION
PURE
STRATEGY
INVISIBLE
MARKOV
NE
WE
ARE
GIVEN
AN
INVISIBLE
MARKOV
GAME
WE
ARE
ASKED
WHETHER
THERE
EXISTS
A
NASH
EQUILIBRIUM
WHERE
ALL
THE
STRATEGIES
ARE
PURE
WE
SHOW
THAT
THIS
PROBLEM
IS
PSPACE
HARD
BY
REDUCING
FROM
PERIODIC
SAT
WHICH
IS
PSPACE
COMPLETE
DEFINITION
PERIODIC
SAT
WE
ARE
GIVEN
A
CNF
FOR
MULA

OVER
THE
VARIABLES
LET
A
MULTI
STAGE
GAME
IS
TYPICALLY
REPRESENTED
AS
A
STOCHASTIC
MARKOV
GAME
WHERE
THERE
IS
AN
UNDERLYING
SET
OF
STATES
AND

K
BE
THE
SAME
FORMULA
EXCEPT
THAT
ALL
THE
SUPERSCRIPTS
ARE
INCREMENTED
BY
K
WE
ARE
ASKED
WHETHER
THERE
EXISTS
A
BOOLEAN
ASSIGNMENT
TO
THE
VARIABLES
XK
XK
THE
PLAYERS
ACTIONS
BUT
ALSO
ON
THE
STATE
FURTHERMORE
THE
PROBABILITY
OF
TRANSITIONING
TO
A
GIVEN
STATE
IS
DETERMINED
BY
THE
CURRENT
STATE
AND
THE
PLAYERS
CURRENT
ACTIONS
HARDNESS
RESULTS
FOR
SUCH
GAMES
CANNOT
BE
OBTAINED
SIMPLY
BY
FORMU
LATING
A
KNOWN
HARD
GAME
SUCH
AS
GENERALIZED
GO
OR
QSAT
AS
A
MARKOV
GAME
BECAUSE
SUCH
A
FORMULATION
WOULD
HAVE
TO
SPECIFY
AN
EXPONENTIAL
NUMBER
OF
STATES
EVEN
IF
THE
NUMBER
OF
STATES
IS
POLYNOMIAL
ONE
MIGHT
SUSPECT
HARD
NESS
BECAUSE
THE
STRATEGY
SPACES
ARE
EXTREMELY
RICH
HOWEVER
IN
THIS
SECTION
WE
SHOW
HARDNESS
EVEN
IN
A
VARIANT
WHERE
THE
STRATEGY
SPACES
ARE
SIMPLE
IN
THE
SENSE
THAT
THE
PLAYERS
CANNOT
CONDITION
THEIR
ACTIONS
ON
EVENTS
IN
THE
GAME
DEFINITION
A
STOCHASTIC
MARKOV
GAME
CONSISTS
OF
THEOREM
PURE
STRATEGY
INVISIBLE
MARKOV
NE
IS
HARD
EVEN
WHEN
THE
GAME
IS
SYMMETRIC
PLAYER
AND
THE
TRANSITION
PROCESS
IS
DETERMINISTIC
PROOF
WE
REDUCE
AN
ARBITRARY
PERIODIC
SAT
INSTANCE
TO
THE
FOLLOWING
SYMMETRIC
PLAYER
PURE
STRATEGY
INVISIBLE
MARKOV
NE
INSTANCE
THE
STATE
SPACE
IS
SI
I
N
I
C
C
I
C
C
R
WHERE
C
IS
THE
SET
OF
CLAUSES
IN

FURTHERMORE

T
F
C
THE
TRANSITION
PROBABILITIES
ARE
P
SI
SI
MODN
FOR
I
N
AND
ALL

P
FOR
ALL
T
F
A
SET
OF
PLAYERS
A
A
SET
OF
STATES
AMONG
WHICH
THE
GAME
TRANSITS
P
C
B
P
B
C
FOR
ALL
B
T
F
AND
C
C
FOR
ALL
B
T
F
AND
C
C
FOR
EACH
PLAYER
I
A
SET
OF
ACTIONS
I
THAT
CAN
BE
PLAYED
P
R
FOR
ALL
C
IN
ANY
STATE
A
TRANSITION
PROBABILITY
FUNCTION
P
P
TI
C
T
FOR
ALL
I
J
C
C
AND


A
WHERE
P
A
A
GIVES
THE
PROBABILITY
OF
THE
GAME
BEING
IN
STATE
IN
THE
NEXT
P
C
R
FOR
ALL
J
C
C
AND
STAGE
GIVEN
THAT
THE
CURRENT
STATE
OF
THE
GAME
IS
AND
THE
PLAYERS
PLAY
ACTIONS
A
A
FOR
EACH
PLAYER
I
A
PAYOFF
FUNCTION
UI

A
R
WHERE
UI
A
A
GIVES
THE
PAY

DO
NOT
NEED
TO
WORRY
ABOUT
ISSUES
OF
CREDIBLE
THREATS
AND
SUBGAME
PERFECTION
IN
THIS
SETTING
SO
WE
CAN
SIMPLY
USE
NASH
EQUI
LIBRIUM
AS
OUR
SOLUTION
CONCEPT
P
R
R
FOR
ALL

L
K
N
I
C
AND
SETTING
XL
K
TO
B
SATISFIES
C
THE
DISCOUNT
SOME
OF
THE
UTILITIES
OBTAINED
IN
A
GIVEN
STAGE
ARE
AS
FOLLOWS
WE
DO
NOT
SPECIFY
UTILITIES
IRRELEVANT
TO
OUR
ANALYSIS
SI
SI
FOR
I
N
AND
ALL

U
U
FOR
ALL
ING
IS
INSIGNIFICANT
ENOUGH
THAT
THIS
MORE
THAN
CANCELS
OUT
THE
EARNED
IN
STAGE
KN
PLAYER
WILL
GET
AT
MOST
IN
THE
OTHER
STAGES
UP
TO
THE
FIRST
STAGE
IN
STATE
R
AND
GIVEN
THAT
WE
MADE
THE
PAYOFFS
IN
THE
GAME
IN
STATE
R
SUFFICIENTLY
SMALL
RELATIVE
TO

PLAYER
WILL
NOT
EARN
ENOUGH
IN
THE
REMAINING
T
F
C
B
B
C
FOR
ALL
B
T
F
AND
C
C
WHEN
SETTING
VARIABLE
TO
B
DOES
NOT
SATISFY
C
C
B
B
C
FOR
ALL
B
T
F
AND
C
C
WHEN
SETTING
VARIABLE
TO
B
DOES
SATISFY
C
FOR
ALL
C
TO
DEVIATE
THUS
A
PURE
STRATEGY
NE
EXISTS
ON
THE
OTHER
HAND
SUPPOSE
THAT
NO
ASSIGNMENT
SATISFYING
THE
PERIODIC
SAT
FORMULA
EXISTS
LET
US
INVESTIGATE
WHETHER
A
NASH
EQUILIBRIUM
COULD
EXIST
WE
KNOW
THAT
IN
SUCH
A
NASH
EQUILIBRIUM
WE
NEVER
LEAVE
THE
SI
SO
BOTH
PLAYERS
RECEIVE
UTILITY
AND
NO
C
IS
EVER
PLAYED
IN
A
STAGE
WITH
STATE
X
B
B
X
FOR
K
SINCE
PLAYING
A
C
IN
ONE
OF
THE
OTHER
STAGES
CAN
HAVE
NO
KN
I
C
I
N
ALL
KN
I
C
C
C
AND
B
T
F
SUCH
THAT
SETTING
DETERRENT
VALUE
WE
MAY
SUPPOSE
THAT
ONLY
ELEMENTS
OF
T
F
VARIABLE
XK
TO
B
DOES
NOT
SATISFY
C
AND
ALL
X

ARE
PLAYED
NOW
CONSIDER
THE
FOLLOWING
ASSIGNMENT
TO
THE
I
XK
IF
PLAYER
PLAYS
B
IN
STAGE
KN
I
XK
IS
SET
TO
B
SINCE
TKN
I
C
X
B
TKN
I
C
B
X
FOR
K
I
I
I
N
ALL
C
C
AND
B
T
F
SUCH
THAT
SETTING
VARIABLE
XK
TO
B
DOES
SATISFY
C
AND
ALL
X

NO
ASSIGNMENT
SATISFYING
THE
PERIODIC
SAT
FORMULA
EXISTS
WE
KNOW
THERE
IS
SOME
CLAUSE
C
AND
SOME
K
SUCH
THAT
NO
VARIABLE
XL
AMONG
XK
XK
XK
XK
IS
SET
TO
SOME
U
X
CL
U
CL
X
FOR
K
I
N
N
I
N
ALL
C
CL
C
AND
ALL
X

I
DEVIATES
TO
PLAY
THIS
C
IN
STAGE
KN
IT
WILL
RECEIVE
PAYOFF
ADDITIONALLY
THE
GAME
PLAYED
IN
STATE
R
IS
SOME
SYMMET
RIC
ZERO
SUM
GAME
WITHOUT
A
PURE
STRATEGY
EQUILIBRIUM
FOR
EXAMPLE
A
GENERALIZATION
OF
ROCK
PAPER
SCISSORS
WITH
VERY
IN
THIS
STAGE
AND
PAYOFF
IN
ALL
THE
REMAINING
STAGES
UP
TO
THE
FIRST
STAGE
IN
STATE
R
FURTHERMORE
PLAYER
CAN
GUARANTEE
ITSELF
AT
LEAST
PAYOFF
IN
EACH
STAGE
IN
STATE
R
AS
THIS
STATE
SMALL
PAYOFFS
FINALLY
THE
DISCOUNT
FACTOR
IS

SO
CORRESPONDS
TO
A
ZERO
SUM
SYMMETRIC
GAME
IT
FOLLOWS
THAT
THAT
THIS
DEVIATION
GIVES
PLAYER
POSITIVE
UTILITY
AND
IS
HENCE
BENEFICIAL
THUS
NO
PURE
STRATEGY
NE
EXISTS
WE
START
OUR
ANALYSIS
WITH
A
FEW
OBSERVATIONS
FIRST
THERE
CAN
BE
NO
PURE
STRATEGY
EQUILIBRIUM
IN
WHICH
STATE
R
IS
REACHED
AT
SOME
POINT
BECAUSE
SINCE
R
IS
AN
ABSORBING
STATE
THIS
WOULD
REQUIRE
THAT
SOME
PURE
STRATEGY
EQUILIBRIUM
OF
THE
GAME
IN
STATE
R
WERE
PLAYED
WHENEVER
STATE
R
OCCURRED
OTH
ERWISE
A
PLAYER
WHO
IS
NOT
BEST
RESPONDING
IN
ONE
OF
THESE
STAGES
COULD
SIMPLY
SWITCH
TO
A
BEST
RESPONSE
IN
THIS
STAGE
AND
BECAUSE
THE
GAME
IS
INVISIBLE
THE
REST
OF
THE
GAME
WOULD
REMAIN
UNAFFECTED
SO
THIS
WOULD
GIVE
HIGHER
UTILITY
BUT
SUCH
AN
EQUILIBRIUM
DOES
NOT
EXIST
SECOND
IF
WE
EVER
REACH
ONE
OF
THE
TJ
STATES
WE
WILL
INEVITABLY
REACH
STATE
R
AT
SOME
POINT
AFTER
THIS
IT
FOLLOWS
THAT
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
NEVER
LEAVE
THE
SI
STATES
NOW
SUPPOSE
AN
ASSIGNMENT
SATISFYING
THE
PERIODIC
SAT
FORMULA
EXISTS
LET
BOTH
PLAYERS
PLAY
AS
FOLLOWS
IN
STAGE
KN
I
WITH
I
N
B
T
F
IS
PLAYED
WHERE
B
IS
THE
VALUE
THAT
THE
VARIABLE
XK
IS
SET
TO
CLEARLY
BOTH
PLAYERS
RECEIVE
UTILITY
WITH
THESE
STRATEGIES
DOES
EITHER
PLAYER
HAVE
AN
INCENTIVE
TO
DEVIATE
THE
ONLY
DEVIATION
OF
ANY
SIGNIFI
CANCE
IS
TO
PLAY
SOME
C
C
WHEN
THE
CURRENT
STATE
IS
SO
WITHOUT
LOSS
OF
GENERALITY
BECAUSE
OF
THE
SYMMETRY
OF
THE
GAME
SAY
PLAYER
DEVIATES
TO
PLAYING
C
C
IN
STAGE
KN
WHEN
THE
STATE
IS
WE
KNOW
THAT
IN
THE
SATISFYING
ASSIGN
MENT
SOME
VARIABLE
XL
AMONG
XK
XK
XK
XK
IS
SET
TO
SOME
B
SUCH
THAT
SETTING
XL
K
TO
B
SATISFIES
C
IF
IT
IS
XK
A
SIMPLER
VERSION
OF
THE
SAME
ARGUMENT
SHOWS
A
WEAKER
FORM
OF
HARDNESS
FOR
THE
CASE
WHERE
THE
GAME
IS
RESTRICTED
TO
HAVE
ONLY
FINITELY
MANY
STAGES
WE
OMIT
THE
PROOF
DUE
TO
LIMITED
SPACE
THEOREM
PURE
STRATEGY
INVISIBLE
MARKOV
NE
IS
HARD
EVEN
WHEN
THE
GAME
IS
SYMMETRIC
PLAYER
THE
TRANSITION
PROCESS
IS
DETERMINISTIC
AND
THE
NUMBER
OF
STAGES
IN
THE
GAME
IS
FINITE
CONCLUSIONS
AND
FUTURE
RESEARCH
NONCOOPERATIVE
GAME
THEORY
PROVIDES
A
NORMATIVE
FRAME
WORK
FOR
ANALYZING
STRATEGIC
INTERACTIONS
HOWEVER
FOR
THE
TOOLBOX
TO
BE
OPERATIONAL
THE
SOLUTIONS
IT
DEFINES
WILL
HAVE
TO
BE
COMPUTED
IN
THIS
PAPER
WE
PROVIDED
A
SINGLE
REDUCTION
THAT
DEMONSTRATES
HARDNESS
OF
DETERMINING
WHETHER
NASH
EQUILIBRIA
WITH
CERTAIN
NATURAL
PROPERTIES
EXIST
AND
DEMONSTRATES
THE
HARDNESS
OF
COUNTING
NASH
EQUILIBRIA
OR
CONNECTED
SETS
OF
NASH
EQUILIBRIA
WE
ALSO
SHOWED
THAT
DETERMINING
WHETHER
A
PURE
STRATEGY
BAYES
NASH
EQUILIBRIUM
EXISTS
IS
HARD
AND
THAT
DETERMINING
WHETHER
A
PURE
STRATEGY
NASH
EQUILIBRIUM
EXISTS
IN
A
STOCHASTIC
MARKOV
GAME
IS
HARD
EVEN
IN
INVISIBLE
GAMES
AND
HARD
IF
THE
GAME
IS
FINITE
ALL
OF
OUR
HARDNESS
RESULTS
HOLD
I
WHICH
IS
SET
TO
B
THEN
IN
STAGE
KN
PLAYER
PLAYS
B
AND
PLAYER
GETS
PAYOFF
IN
THIS
STAGE
SINCE
WE
ARE
IN
STATE
AND
SETTING
TO
B
SATISFIES
C
OTHERWISE
IF
IT
IS
XL
WITH
EVEN
IF
THERE
ARE
ONLY
TWO
PLAYERS
AND
THE
GAME
IS
SYMMETRIC
THERE
ARE
NUMEROUS
OPEN
RESEARCH
QUESTIONS
IN
COMPUTING
SOLUTIONS
TO
NONCOOPERATIVE
GAMES
SOME
RECENT
WORK
HAS
FO
I
L
K
OR
I
WHICH
IS
SET
TO
B
THEN
PLAYER
WILL
GET
PAYOFF
IN
STAGE
KN
BUT
IN
STAGE
LN
I
PLAYER
PLAYS
B
AND
PLAYER
GETS
PAYOFF
IN
THIS
STAGE
SINCE
WE
ARE
IN
STATE
CUSED
ON
NOVEL
KNOWLEDGE
REPRESENTATIONS
WHICH
IN
CERTAIN
SETTINGS
CAN
DRASTICALLY
SPEED
UP
EQUILIBRIUM
FINDING
E
G
ONE
AVENUE
OF
FUTURE
WORK
INCLUDES
IDENTIFYING
RE
PERFECT
BAYESIAN
EQUILIBRIUM
IN
SENDER
RECEIVER
GAMES
INTRODUCTION
SENDER
RECEIVER
GAMES
STRATEGIES
IN
SENDER
RECEIVER
GAMES
SENDER
BEST
RESPONSE
STRATEGIES
RECEIVER
BEST
RESPONSE
STRATEGIES
UPDATING
THE
RECEIVER
BELIEFS
MESSAGE
WISE
OPTIMIZATION
BAYESIAN
EQUILIBRIUM
PERFECT
BAYESIAN
EQUILIBRIUM
THE
TEST
OF
DOMINATED
MESSAGES
INTRODUCTION
WE
PREVIOUSLY
STUDIED
STATIC
GAMES
OF
IMPERFECT
INFORMATION
EACH
PLAYER
I
I
HAS
PRIVATE
INFORMATION
WHICH
WAS
SUMMARIZED
BY
HER
TYPE
I
I
EACH
PLAYER
KNOWS
HER
OWN
TYPE
BUT
DOES
NOT
IN
GENERAL
KNOW
THE
TYPES
OF
HER
OPPONENTS
EACH
PLAYER
I
BELIEFS
ABOUT
THE
TYPES

I

I
OF
HER
OPPONENTS
ARE
DERIVED
FROM
HER
KNOWLEDGE
OF
HER
OWN
TYPE
I
AND
A
COMMON
PRIOR
BELIEF
P

OVER
THE
SPACE
OF
TYPE
PROFILES
NATURE
MOVES
FIRST
PICKING
A
TYPE
PROFILE


ACCORDING
TO
THE
PROBABILITY
DISTRIBUTION
P

NATURE
THEN
PRIVATELY
INFORMED
EACH
PLAYER
I
I
OF
HER
TYPE
PLAYER
IS
TYPE
PLAYER
IS
TYPE
PLAYER
N
IS
TYPE
N
THEN
EACH
PLAYER
I
I
OF
THE
N
PLAYERS
SIMULTANEOUSLY
CHOOSES
AN
ACTION
AI
AI
FROM
HER
ACTION
SPACE
A
PAYOFF
UIA

IS
THEN
AWARDED
TO
EACH
PLAYER
WHICH
DEPENDS
ON
THE
ACTION
PROFILE
A
A
THE
PLAYERS
CHOSE
AND
THE
TYPE
PROFILE

NATURE
CHOSE
IT
WAS
BECAUSE
THE
PLAYERS
SIMULTANEOUSLY
CHOSE
THEIR
ACTIONS
THAT
WE
CALLED
THESE
GAMES
STATIC
NOW
WE
WANT
TO
GENERALIZE
OUR
ANALYSIS
BY
CONSIDERING
DYNAMIC
GAMES
OF
INCOMPLETE
INFORMATION
I
E
WE
CONSIDER
GAMES
IN
WHICH
SOME
PLAYERS
TAKE
ACTIONS
BEFORE
OTHERS
AND
THESE
ACTIONS
ARE
OBSERVED
TO
SOME
EXTENT
BY
SOME
OTHER
PLAYERS
SENDER
RECEIVER
GAMES
WE
CONSIDER
HERE
THE
SIMPLEST
DYNAMIC
GAMES
OF
INCOMPLETE
INFORMATION
SENDER
RECEIVER
GAMES
THERE
BY
JIM
RATLIFF
SEE
THE
STATIC
GAMES
OF
INCOMPLETE
INFORMATION
HANDOUT
ARE
ONLY
TWO
PLAYERS
A
SENDER
AND
A
RECEIVER
R
THE
SENDER
ACTION
WILL
BE
TO
SEND
A
MESSAGE
M
M
CHOSEN
FROM
A
MESSAGE
SPACE
M
TO
THE
RECEIVER
THE
RECEIVER
WILL
OBSERVE
THIS
MESSAGE
M
AND
RESPOND
TO
IT
BY
CHOOSING
AN
ACTION
A
A
FROM
HIS
ACTION
SPACE
A
TO
MAKE
THIS
GAME
A
SIMPLE
BUT
NONTRIVIAL
GAME
OF
INCOMPLETE
INFORMATION
WE
ENDOW
THE
SENDER
WITH
SOME
PRIVATE
INFORMATION
WHICH
WE
DESCRIBE
BY
HER
TYPE


THE
RECEIVER
HAS
NO
PRIVATE
INFORMATION
SO
HE
HAS
BUT
A
SINGLE
TYPE
WHICH
WE
THEN
HAVE
NO
NEED
TO
MENTION
FURTHER
THE
RECEIVER
DOES
HAVE
PRIOR
BELIEFS
I
E
PRIOR
TO
OBSERVING
THE
SENDER
MESSAGE
ABOUT
THE
SENDER
TYPE
WHICH
ARE
DESCRIBED
BY
THE
PROBABILITY
DISTRIBUTION
P

OVER
THE
SENDER
TYPE
SPACE

IN
OTHER
WORDS
BEFORE
OBSERVING
THE
SENDER
MESSAGE
THE
RECEIVER
BELIEVES
THAT
THE
PROBABILITY
THAT
THE
SENDER
IS
SOME
PARTICULAR
TYPE


IS
P
WE
WILL
TYPICALLY
ASSUME
THAT
THE
TYPE
SPACE

THE
MESSAGE
SPACE
M
AND
THE
RECEIVER
ACTION
SPACE
A
ARE
FINITE
SETS
AFTER
THE
RECEIVER
TAKES
AN
ACTION
A
A
EACH
PLAYER
IS
AWARDED
A
PAYOFF
WHICH
CAN
IN
GENERAL
DEPEND
ON
THE
MESSAGE
M
THE
SENDER
SENT
THE
ACTION
A
THE
RECEIVER
TOOK
IN
RESPONSE
AND
THE
TYPE

WHICH
NATURE
CHOSE
FOR
THE
SENDER
THE
PAYOFFS
TO
THE
SENDER
AND
RECEIVER
TO
A
MESSAGE
ACTION
TYPE
TRIPLE
M
A

M
A

ARE
UM
A

AND
VM
A

RESPECTIVELY
I
E
U
V
M
A


WE
CAN
EXPRESS
THIS
GAME
OF
INCOMPLETE
INFORMATION
AS
AN
EXTENSIVE
FORM
GAME
OF
IMPERFECT
INFORMATION
BY
EXPLICITLY
REPRESENTING
NATURE
WHO
CHOOSES
A
TYPE


FOR
THE
SENDER
BECAUSE
THE
SENDER
OBSERVES
THIS
CHOICE
OF
NATURE
EVERY
SENDER
INFORMATION
SET
IS
A
SINGLETON
AND
THE
NUMBER
OF
SENDER
INFORMATION
SETS
IS
EQUAL
TO
THE
NUMBER
OF
POSSIBLE
SENDER
TYPES
VIZ

THE
RECEIVER
OBSERVES
ONLY
THE
MESSAGE
SENT
BY
THE
SENDER
THEREFORE
THE
NUMBER
OF
RECEIVER
INFORMATION
SETS
IS
EQUAL
TO
THE
NUMBER
OF
POSSIBLE
MESSAGES
THE
SENDER
CAN
TRANSMIT
VIZ
M
WITHIN
EACH
OF
HIS
INFORMATION
SETS
THE
RECEIVER
CANNOT
DISTINGUISH
BETWEEN
THE
SENDER
POSSIBLE
TYPES
SO
EACH
RECEIVER
INFORMATION
SET
HAS
A
NUMBER
OF
NODES
EQUAL
TO
THE
NUMBER
OF
POSSIBLE
SENDER
TYPES
VIZ

THEREFORE
THE
TOTAL
NUMBER
OF
RECEIVER
NODES
IS
THE
PRODUCT
OF
THE
CARDINALITIES
OF
THE
MESSAGE
AND
TYPE
SPACES
VIZ
M

OF
COURSE
IN
THIS
CASE
THE
MESSAGE
SEEMS
MORE
THAN
A
MERE
MESSAGE
THE
TERMS
MESSAGE
FOR
THE
SENDER
AND
ACTION
FOR
THE
RECEIVER
BOTH
REFER
TO
ACTIONS
TAKEN
BY
A
PLAYER
THE
DISTINCTION
BETWEEN
THE
TWO
IS
ONLY
INTERPRETATIONAL
WE
USE
MESSAGE
FOR
THE
SENDER
ACTION
TO
ACKNOWLEDGE
THAT
THE
SENDER
REALIZES
THAT
THE
RECEIVER
WILL
RESPOND
TO
THE
SENDER
ACTION
AND
THEREFORE
THE
SENDER
CAN
ATTEMPT
TO
INFLUENCE
THE
RECEIVER
RESPONSE
THROUGH
HER
CHOICE
OF
MESSAGE
DULL
THEREFORE
HER
TYPE
SPACE
WOULD
BE

BRIGHT
DULL
THE
RECEIVER
PRIOR
BELIEFS
CONCERNING
THE
PROBABILITY
THAT
THE
SENDER
IS
BRIGHT
OR
DULL
CAN
BE
DESCRIBED
BY
A
SINGLE
NUMBER
WITH
PROBABILITY
THE
SENDER
IS
BRIGHT
WITH
PROBABILITY
SHE
IS
DULL
I
E
THE
RECEIVER
PRIOR
BELIEFS
P

ARE
DEFINED
BY
PBRIGHT
AND
PDULL
CONSIDER
THE
SIMPLE
SENDER
RECEIVER
GAME
SHOWN
IN
FIGURE
NOTE
THAT
THE
SENDER
HAS
TWO
INFORMATION
SETS
CORRESPONDING
TO
HER
TWO
TYPES
VIZ
BRIGHT
AND
DULL
THE
RECEIVER
ALSO
HAS
TWO
INFORMATION
SETS
BUT
THESE
CORRESPOND
TO
THE
SENDER
TWO
POSSIBLE
MESSAGES
VIZ
BEACH
AND
COLLEGE
RATHER
THAN
TO
THE
SENDER
POSSIBLE
TYPES
THE
RECEIVER
LEFT
HAND
INFORMATION
SET
IS
HIS
BEACH
INFORMATION
SET
AND
HIS
RIGHT
HAND
INFORMATION
SET
IS
HIS
COLLEGE
INFORMATION
SET
BRIGHT
B
N
C
R
H
R
H
B
C
R
R
DULL
FIGURE
A
SIMPLE
SENDER
RECEIVER
GAME
LET
INTERPRET
THE
PAYOFFS
SHOWN
IN
FIGURE
THE
FIRST
AND
SECOND
PAYOFFS
OF
EACH
ORDERED
PAIR
ARE
THE
SENDER
AND
RECEIVER
PAYOFFS
RESPECTIVELY
FOR
A
PARTICULAR
TYPE
MESSAGE
ACTION
TRIPLE
FOR
A
FIXED
TYPE
AND
RECEIVER
ACTION
THE
SENDER
PAYOFF
TO
GOING
TO
THE
BEACH
IS
ALWAYS
TWO
GREATER
THAN
HER
PAYOFF
TO
GOING
TO
COLLEGE
FOR
FIXED
EDUCATIONAL
AND
EMPLOYMENT
DECISIONS
THE
SENDER
PAYOFF
IS
INDEPENDENT
OF
HER
TYPE
FOR
A
FIXED
TYPE
AND
EDUCATIONAL
DECISION
THE
SENDER
RECEIVES
A
PAYOFF
FROM
BEING
HIRED
WHICH
IS
GREATER
THAN
HER
PAYOFF
IF
SHE
IS
REJECTED
TO
SUMMARIZE
THE
SENDER
PAYOFFS
WITH
THE
APPROPRIATE
CETERIS
PARIBUS
QUALIFICATIONS
THE
SENDER
PREFERS
THE
BEACH
OVER
GOING
TO
COLLEGE
PREFERS
BEING
HIRED
OVER
BEING
REJECTED
AND
IS
NOT
DISCRIMINATED
AGAINST
DUE
TO
APTITUDE
WHENEVER
THE
RECEIVER
REJECTS
AN
APPLICANT
THE
RECEIVER
GETS
A
PAYOFF
OF
ZERO
ALTHOUGH
THE
SENDER
APTITUDE
DID
NOT
DIRECTLY
INFLUENCE
THE
SENDER
PAYOFFS
APTITUDE
IS
PAYOFF
RELEVANT
TO
THE
RECEIVER
WHEN
HE
HIRES
FOR
A
FIXED
EDUCATIONAL
DECISION
THE
RECEIVER
PAYOFF
TO
HIRING
IS
GREATER
FOR
EXAMPLE
IF
THE
BRIGHT
APPLICANT
IS
HIRED
SHE
RECEIVES
A
PAYOFF
OF
FROM
THE
BEACH
BUT
ONLY
FROM
COLLEGE
IF
THE
DULL
APPLICANT
IS
REJECTED
SHE
RECEIVES
A
PAYOFF
OF
FROM
THE
BEACH
BUT
ONLY
FROM
COLLEGE
FOR
EXAMPLE
IF
THE
APPLICANT
GOES
TO
THE
BEACH
AND
IS
HIRED
SHE
RECEIVES
A
PAYOFF
OF
REGARDLESS
OF
WHETHER
SHE
IS
BRIGHT
OR
DULL
FOR
EXAMPLE
IF
THE
BRIGHT
APPLICANT
GOES
TO
COLLEGE
SHE
RECEIVES
IF
SHE
IS
HIRED
AND
ONLY
IF
SHE
IS
REJECTED
IF
THE
DULL
APPLICANT
GOES
TO
THE
BEACH
SHE
RECEIVES
IF
SHE
IS
HIRED
AND
ONLY
IF
SHE
IS
REJECTED
STRATEGIES
IN
SENDER
RECEIVER
GAMES
A
PURE
STRATEGY
FOR
A
PLAYER
IN
ANY
EXTENSIVE
FORM
GAME
IS
A
MAPPING
FROM
HER
INFORMATION
SETS
TO
HER
AVAILABLE
ACTIONS
AT
THE
RELEVANT
INFORMATION
SET
THERE
IS
A
ONE
TO
ONE
CORRESPONDENCE
BETWEEN
THE
SENDER
INFORMATION
SETS
AND
HER
TYPE
SPACE

THEREFORE
A
PURE
STRATEGY
FOR
THE
SENDER
IS
A
MAP
M

M
FROM
HER
TYPE
SPACE

TO
HER
MESSAGE
SPACE
M
THERE
IS
A
ONE
TO
ONE
CORRESPONDENCE
BETWEEN
THE
RECEIVER
INFORMATION
SETS
AND
THE
SENDER
MESSAGE
SPACE
THEREFORE
A
PURE
STRATEGY
FOR
THE
RECEIVER
IS
A
MAPPING
A
M
A
FROM
THE
SENDER
MESSAGE
SPACE
M
TO
THE
RECEIVER
ACTION
SPACE
A
WE
CAN
ALSO
DEFINE
BEHAVIOR
STRATEGIES
FOR
THE
PLAYERS
THE
SENDER
CAN
SEND
MIXED
MESSAGES
LET
MFIM
BE
THE
SET
OF
PROBABILITY
DISTRIBUTIONS
OVER
THE
SENDER
MESSAGE
SPACE
M
A
BEHAVIOR
STRATEGY
FOR
THE
SENDER
IS
A
MAP
SS

M
FROM
HER
TYPE
SPACE

TO
MIXTURES
OVER
HER
MESSAGE
SPACE
THEREFORE
FOR
ALL
TYPES


SS
M
IS
A
MIXTURE
OVER
MESSAGES
IN
PARTICULAR
FOR
ANY
MESSAGE
M
M
WE
DENOTE
BY
SSM

THE
PROBABILITY
ACCORDING
TO
THE
SENDER
BEHAVIOR
STRATEGY
SS
THAT
A
TYPE

SENDER
WILL
SEND
THE
MESSAGE
M
FOR
A
GIVEN
SENDER
STRATEGY
SS
A
MESSAGE
M
IS
ON
THE
PATH
IF
ACCORDING
TO
SS
THERE
EXISTS
A
TYPE

WHO
SENDS
M
WITH
POSITIVE
PROBABILITY
THE
SET
OF
ON
THE
PATH
MESSAGES
FOR
SENDER
STRATEGY
SS
IS
THE
RECEIVER
CAN
ALSO
RANDOMIZE
HIS
ACTIONS
IN
RESPONSE
TO
HIS
MESSAGE
OBSERVATION
LET
AFIA
BE
THE
SET
OF
PROBABILITY
DISTRIBUTIONS
OVER
THE
RECEIVER
ACTION
SPACE
THEN
A
BEHAVIOR
STRATEGY
FOR
THE
RECEIVER
IS
A
MAP
M
A
FROM
THE
SENDER
MESSAGE
SPACE
M
TO
THE
MIXED
ACTION
SPACE
A
THEREFORE
FOR
ALL
MESSAGES
M
M
M
A
IS
A
MIXTURE
OVER
RECEIVER
ACTIONS
IN
PARTICULAR
FOR
ANY
ACTION
A
A
WE
DENOTE
BY
A
M
THE
PROBABILITY
ACCORDING
TO
THE
RECEIVER
BEHAVIOR
STRATEGY
THAT
THE
RECEIVER
WILL
CHOOSE
THE
ACTION
A
CONDITIONAL
ON
HAVING
OBSERVED
THE
MESSAGE
M
M
IF
THE
SENDER
GOES
TO
COLLEGE
THE
RECEIVER
PAYOFF
TO
HIRE
IS
WHEN
THE
SENDER
IS
BRIGHT
BUT
ONLY
WHEN
THE
SENDER
IS
DULL
IF
THE
SENDER
GOES
TO
THE
BEACH
THE
RECEIVER
PAYOFF
TO
HIRE
IS
WHEN
THE
SENDER
IS
BRIGHT
AND
WHEN
SHE
IS
DULL
FOR
EXAMPLE
IF
THE
RECEIVER
HIRES
THE
DULL
SENDER
THE
RECEIVER
GAINS
A
PAYOFF
OF
IF
THE
SENDER
WENT
TO
COLLEGE
COMPARED
TO
A
PAYOFF
OF
IF
THE
SENDER
HAD
GONE
TO
THE
BEACH
INSTEAD
NOTE
THAT
THE
SUPPORT
OF
SS
IS
THE
SET
OF
MESSAGES
WHICH
A
TYPE

SENDER
SENDS
WITH
POSITIVE
PROBABILITY
WHEN
SHE
IS
PLAYING
ACCORDING
TO
THE
BEHAVIOR
STRATEGY
SS
THE
SYMBOLS
SS
AND
WERE
SELECTED
FOR
THESE
BEHAVIOR
STRATEGIES
TO
BE
MNEMONICALLY
FRIENDLY
I
E
IN
THE
HOPE
THAT
SIGMA
AND
RHO
WOULD
SUGGEST
SENDER
AND
RECEIVER
RESPECTIVELY
SENDER
BEST
RESPONSE
STRATEGIES
WE
FIRST
ASK
WHEN
IS
A
SENDER
STRATEGY
M
M
A
BEST
RESPONSE
TO
SOME
RECEIVER
BEHAVIOR
STRATEGY
AM
CONSIDER
THE
CASE
WHERE
A
TYPE

SENDER
CHOOSES
TO
SEND
A
MESSAGE
M
M
KNOWING
THAT
THE
RECEIVER
WILL
RESPOND
ACCORDING
TO
HIS
BEHAVIOR
STRATEGY
AM
THIS
SENDER
EXPECTED
UTILITY
WILL
BE
A
CONVEX
COMBINATION
OF
HER
PAYOFFS
TO
PARTICULAR
PURE
ACTIONS
BY
THE
RECEIVER
VIZ
A
A
A
MUM
A

A
PURE
STRATEGY
M
M
WILL
BE
A
BEST
RESPONSE
FOR
THE
SENDER
TO
A
RECEIVER
BEHAVIOR
STRATEGY
AM
IF
FOR
EVERY
TYPE


OF
SENDER
THE
MESSAGE
SPECIFIED
BY
M
MAXIMIZES
THE
EXPECTED
UTILITY
OF
A
TYPE

SENDER
GIVEN
THAT
THE
RECEIVER
WILL
RESPOND
TO
THE
MESSAGE
M
ACCORDING
TO
THE
STRATEGY
FOR
A
GIVEN
RECEIVER
MIXED
STRATEGY
AM
THE
SET
OF
OPTIMAL
MESSAGES
FOR
A
TYPE

SENDER
IS
M
FIARG
MAX
A
A
A
M
UM
A

THEREFORE
A
SENDER
STRATEGY
M
M
IS
A
BEST
RESPONSE
TO
THE
RECEIVER
STRATEGY
AM
IF
AND
ONLY
IF
FOR
ALL


M
M

A
SENDER
BEHAVIOR
STRATEGY
SS
M
IS
A
BEST
RESPONSE
TO
THE
RECEIVER
BEHAVIOR
STRATEGY
AM
IF
AND
ONLY
IF
FOR
ALL


SUPP
SSM

RECEIVER
BEST
RESPONSE
STRATEGIES
NOW
WE
ASK
WHEN
IS
A
RECEIVER
STRATEGY
A
AM
A
BEST
RESPONSE
TO
A
SENDER
BEHAVIOR
STRATEGY
SS
M
UPDATING
THE
RECEIVER
BELIEFS
THE
RECEIVER
CHOOSES
AN
ACTION
AFTER
HE
OBSERVES
THE
SENDER
MESSAGE
HE
WANTS
TO
CHOOSE
THE
ACTION
WHICH
IS
OPTIMAL
GIVEN
THE
BEST
BELIEFS
HE
CAN
HAVE
CONCERNING
THE
SENDER
TYPE
THE
RECEIVER
ENTERS
THE
GAME
WITH
PRIOR
BELIEFS
P

CONCERNING
THE
SENDER
TYPE

BECAUSE
THE
RECEIVER
KNOWS
THE
SENDER
TYPE
CONTINGENT
MESSAGE
SENDING
STRATEGY
SS
M
THE
RECEIVER
MIGHT
BE
ABLE
TO
INFER
SOMETHING
MORE
ABOUT
THE
SENDER
TYPE
AND
THEREBY
UPDATE
HIS
BELIEFS
AS
LONG
AS
THE
OBSERVED
MESSAGE
IS
NOT
TOTALLY
UNEXPECTED
GIVEN
THAT
THE
SENDER
IS
PLAYING
THE
BEHAVIOR
STRATEGY
SS
I
E
THERE
IS
SOME
TYPE
WHICH
ACCORDING
TO
SS
SENDS
THAT
MESSAGE
WITH
POSITIVE
PROBABILITY
WE
CAN
USE
BAYES
RULE
TO
UPDATE
THE
RECEIVER
PRIOR
BELIEFS
P

SPECIFICALLY
FOR
ANY
OBSERVED
ON
THE
PATH
MESSAGE
M
MSS
WE
DENOTE
THE
RECEIVER
POSTERIOR
BELIEF
THAT
THE
SENDER
IS
TYPE

BY
PB
M
WHICH
IS
GIVEN
FROM
BAYES
RULE
BY
PB
MFI
P
SSM



P

SSM


WE
SEE
THE
JUSTIFICATION
FOR
THE
RESTRICTION
TO
ON
THE
PATH
NOT
TOTALLY
UNEXPECTED
MESSAGES
IF
SOME
FOR
ANY
SETS
A
AND
B
AB
IS
THE
SET
OF
ALL
FUNCTIONS
FROM
B
A
THE
NUMERATOR
OF
THE
RIGHT
HAND
SIDE
IS
THE
PROBABILITY
OF
THE
EVENT
THE
SENDER
IS
TYPE

AND
SENDS
MESSAGE
M
THE
DENOMINATOR
IS
THE
PROBABILITY
THAT
MESSAGE
M
IS
SENT
MESSAGE
M
IS
NEVER
SENT
REGARDLESS
OF
WHICH
TYPE
THE
SENDER
IS
THEN
THE
DENOMINATOR
OF
THE
RIGHT
HAND
SIDE
WILL
VANISH
IN
GENERAL
WE
CAN
DEFINE
THE
RECEIVER
POSTERIOR
BELIEFS
EVEN
AFTER
OBSERVING
OFF
THE
PATH
AND
THEREFORE
TOTALLY
UNEXPECTED
MESSAGES
FOR
EVERY
MESSAGE
M
M
WE
LET
PM

BE
THE
RECEIVER
POSTERIOR
BELIEFS
AFTER
OBSERVING
THE
MESSAGE
M
ABOUT
THE
SENDER
TYPE
IN
OTHER
WORDS
THE
RECEIVER
ATTACHES
THE
PROBABILITY
P
M
TO
THE
EVENT
THAT
THE
SENDER
HAS
TYPE


CONDITIONAL
UPON
THE
RECEIVER
OBSERVING
THE
MESSAGE
M
M
SO
P
M

IS
A
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
WHERE
DOES
THE
RECEIVER
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
M

COME
FROM
IT
IS
DERIVED
FROM
THE
RECEIVER
PRIOR
BELIEFS
P

AND
UPDATED
IN
RESPONSE
TO
HIS
OBSERVATION
OF
THE
SENDER
MESSAGE
M
WE
REQUIRE
THAT
THIS
UPDATING
BE
DONE
ACCORDING
TO
BAYES
RULE
WHENEVER
POSSIBLE
THIS
MEANS
THAT
FOR
ALL
ON
THE
PATH
MESSAGES
M
MSS
AND
FOR
ALL
TYPES


PM

PBM

ALTERNATIVELY
BUT
EQUIVALENTLY
WE
CAN
SAY
THAT
THE
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
M

IS
CONSISTENT
WITH
BAYES
RULE
IF
THE
RESTRICTION
OF
P
TO
THE
ON
THE
PATH
MESSAGES
MSS
IS
PB
MESSAGE
WISE
OPTIMIZATION
CONSIDER
A
RECEIVER
PURE
STRATEGY
A
AM
IF
A
TYPE

SENDER
SENDS
THE
MESSAGE
M
M
AND
THE
RECEIVER
RESPONDS
ACCORDING
TO
HIS
PURE
STRATEGY
A
THE
RECEIVER
PAYOFF
WILL
BE
VM
AM

THE
PROBABILITY
WITH
WHICH
HE
RECEIVES
THIS
PARTICULAR
PAYOFF
IS
THE
PROBABILITY
OF
THE
EVENT
THE
SENDER
IS
TYPE

AND
SENDS
MESSAGE
M
THIS
PROBABILITY
IS
THE
PROBABILITY
THAT
THE
SENDER
IS
TYPE

VIZ
P
MULTIPLIED
BY
THE
PROBABILITY
THAT
THE
SENDER
SENDS
THE
MESSAGE
M
CONDITIONAL
ON
THE
SENDER
BEING
TYPE

VIZ
SSM

THEREFORE
THE
EXPECTED
UTILITY
VA
SS
TO
THE
RECEIVER
WHO
PLAYS
THE
STRATEGY
A
AM
AGAINST
THE
SENDER
BEHAVIOR
STRATEGY
SS
M
IS
THE
SUM
OF
THE
PROBABILITY
WEIGHTED
PAYOFFS
PSSM
VM
AM

OVER
ALL
POSSIBLE
COMBINATIONS
OF
MESSAGES
AND
TYPES
VA
SSFIM
M


PSSM
VM
AM

A
RECEIVER
STRATEGY
A
AM
WILL
BE
A
BEST
RESPONSE
TO
THE
SENDER
BEHAVIOR
STRATEGY
SS
M
IF
AND
ONLY
IF
IT
MAXIMIZES
THE
RECEIVER
EXPECTED
UTILITY
OVER
ALL
POSSIBLE
RECEIVER
PURE
STRATEGIES
I
E
A
ARG
MAX
VA
SS
A
AM
AT
FIRST
GLANCE
THE
OPTIMIZATION
PROBLEM
IN
MIGHT
APPEAR
PROBLEMATIC
BECAUSE
IT
REQUIRES
MAXIMIZATION
OVER
A
FUNCTION
SPACE
FORTUNATELY
THE
MAXIMAND
FROM
IS
ADDITIVELY
SEPARABLE
IN
THE
VARIOUS
MESSAGES
M
M
SO
WE
LL
BE
ABLE
TO
CONSTRUCT
A
BEST
RESPONSE
RECEIVER
STRATEGY
A
AM
VIA
A
MESSAGE
BY
MESSAGE
OPTIMIZATION
TO
FIND
INDIVIDUAL
BEST
RESPONSE
ACTIONS
AM
FOR
EACH
MESSAGE
M
M
THIS
SIMPLIFICATION
IS
JUSTIFIED
BY
THE
FOLLOWING
LEMMA
WHICH
YOU
ARE
INVITED
TO
PROVE
FOR
YOURSELF
LET
A
BE
A
SET
AND
M
BE
A
FINITE
SET
LET
F
BE
A
FUNCTION
F
M
A

THEN
A
ARG
MAX
FM
AM
A
AM
IF
AND
ONLY
IF
FOR
ALL
M
M
AM
ARG
MAX
FM
A
A
A
TO
APPLY
THIS
LEMMA
TO
THE
OPTIMIZATION
PROBLEM
WE
DEFINE
FM
AFI

PSSM
VM
A

NOW
WE
HAVE
FROM
VA
SSFIM
M
FM
AM
THEREFORE
FROM
AND
THE
LEMMA
WE
SEE
THAT
THE
RECEIVER
STRATEGY
A
AM
IS
A
BEST
RESPONSE
TO
THE
SENDER
BEHAVIOR
STRATEGY
SS
M
IF
AND
ONLY
IF
FOR
ALL
M
M
AM
ARG
MAX
FM
A
A
A
IF
A
MESSAGE
M
IS
OFF
THE
PATH
I
E
M
M
MSS
THEN
IT
IS
SENT
BY
NO
TYPE
FOR
EVERY
TYPE


SSM
THEREFORE
M
M
MSS
A
A
FM
THEREFORE
ALL
ACTIONS
A
A
ARE
MAXIMIZERS
OF
FM
A
WHEN
M
IS
AN
OFF
THE
PATH
MESSAGE
I
E
M
M
MSS
A
ARG
MAX
FM
A
A
A
WHEN
M
MSS
IS
AN
ON
THE
PATH
MESSAGE
IT
IS
USEFUL
TO
DIVIDE
THE
MAXIMAND
OF
BY
THE
GUARANTEED
NONZERO
PROBABILITY
THAT
M
IS
SENT
VIZ

P
SSM


THIS
DOES
NOT
CHANGE
THE
SET
OF
MAXIMIZERS
OF
THIS
DIVISION
ALLOWS
US
USING
AND
TO
EXPRESS
THE
CONDITION
IN
TERMS
OF
THE
RECEIVER
BAYES
UPDATED
BELIEFS
M
MSS
AM
ARG
MAX
PB
MVM
A

A
A


BUT
THIS
MAXIMAND
IS
SIMPLY
THE
RECEIVER
EXPECTED
UTILITY
GIVEN
HER
BAYES
UPDATED
BELIEFS
ABOUT
THE
SENDER
TYPE
WHEN
SHE
CHOOSES
THE
ACTION
A
A
AFTER
OBSERVING
THE
ON
THE
PATH
MESSAGE
M
MSS
THEREFORE
CONDITION
STATES
THAT
IT
IS
NECESSARY
AND
SUFFICIENT
IN
ORDER
THAT
THE
RECEIVER
STRATEGY
A
AM
TO
BE
A
BEST
RESPONSE
TO
THE
SENDER
BEHAVIOR
STRATEGY
SS
M
THAT
IT
SPECIFY
FOR
EACH
ON
THE
PATH
MESSAGE
AN
ACTION
WHICH
IS
A
BEST
RESPONSE
TO
THAT
MESSAGE
GIVEN
THE
RECEIVER
BAYES
UPDATED
BELIEFS
FOR
A
GIVEN
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
M

THE
RECEIVER
EXPECTED
UTILITY
TO
THE
ACTION
A
A
CONDITIONAL
UPON
HAVING
OBSERVED
THE
MESSAGE
M
M
IS

P
MVM
A

THEREFORE
FOR
A
GIVEN
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
THE
SET
OF
RECEIVER
BEST
RESPONSE
ACTIONS
TO
SOME
MESSAGE
M
IS
GIVEN
BY
AP
M
ARG
MAX


P
M
VM
A

A
RECEIVER
PURE
STRATEGY
A
AM
IS
A
BEST
RESPONSE
TO
THE
SENDER
BEHAVIOR
STRATEGY
SS
M
IF
AND
ONLY
IF
FOR
ALL
M
M
AM
APB
M
A
RECEIVER
BEHAVIOR
STRATEGY
AM
IS
A
BEST
RESPONSE
TO
THE
SENDER
BEHAVIOR
STRATEGY
SS
M
IF
AND
ONLY
IF
FOR
ALL
M
M
SUPP
MAPB
M
BAYESIAN
EQUILIBRIUM
A
BAYESIAN
EQUILIBRIUM
OF
THE
SENDER
RECEIVER
GAME
IS
A
TRIPLE
SS
P
M
AM

M
SATISFYING
THE
FOLLOWING
THREE
CONDITIONS
FOR
ALL
TYPES


SUPP
SSM

FOR
ALL
ON
THE
PATH
MESSAGES
M
MSS
SUPP
MAP
M
THE
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
IS
CONSISTENT
WITH
BAYES
RULE
WHENEVER
POSSIBLE
IN
THE
SENSE
THAT
THE
RESTRICTION
OF
P
TO
THE
ON
THE
PATH
MESSAGES
MSS
IS
PB
NOTE
THAT
OPTIMALITY
FROM
THE
RECEIVER
IS
REQUIRED
ONLY
AT
ON
THE
PATH
INFORMATION
SETS
THEREFORE
THE
ONLY
RECEIVER
INFORMATION
SETS
AT
WHICH
THE
SPECIFICATION
OF
THE
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
ENTERS
INTO
THE
DEFINITION
OF
BAYESIAN
EQUILIBRIUM
IS
AT
ON
THE
PATH
MESSAGE
INFORMATION
SETS
WHERE
THESE
BELIEFS
ARE
JUST
THE
ONES
DERIVED
FROM
BAYES
RULE
FROM
H
BRIGHT
B
N
T
H
C
R
R
H
R
B
C
R
R
R
DULL
FIGURE
LIFE
IS
A
BEACH
WITH
THE
RECEIVER
CONDITIONAL
POSTERIOR
BELIEFS
INDICATED
WE
CAN
REPRESENT
A
STRATEGY
PROFILE
BY
THE
ORDERED
SEXTUPLE
X
Y
L
R
T
WHERE
X
SENDER
ACTION
IF
BRIGHT
Y
SENDER
ACTION
IF
DULL
L
RECEIVER
ACTION
IF
BEACH
IS
OBSERVED
R
RECEIVER
ACTION
IF
COLLEGE
IS
OBSERVED
RECEIVER
BELIEF
PROBABILITY
GIVEN
THAT
BEACH
IS
OBSERVED
THAT
THE
SENDER
IS
BRIGHT
T
RECEIVER
BELIEF
PROBABILITY
GIVEN
THAT
COLLEGE
IS
OBSERVED
THAT
THE
SENDER
IS
BRIGHT
CONSIDER
THE
FOLLOWING
STRATEGY
PROFILE
C
C
R
H
THIS
STRATEGY
PROFILE
IS
DEPICTED
IN
FIGURE
BY
THE
THICK
LINE
SEGMENTS
WE
NOTE
THAT
ACCORDING
TO
THIS
STRATEGY
PROFILE
THE
BEACH
MESSAGE
IS
NEVER
SENT
BY
ANY
TYPE
OF
SENDER
AND
IS
THEREFORE
OFF
THE
PATH
THEREFORE
IN
ORDER
TO
EVALUATE
WHETHER
THIS
STRATEGY
PROFILE
IS
A
BAYESIAN
EQUILIBRIUM
WE
NEED
NOT
SPECIFY
CONDITIONAL
POSTERIOR
BELIEFS
FOR
THE
RECEIVER
AT
THIS
INFORMATION
SET
HENCE
THE
IN
THE
ABOVE
SPECIFICATION
LET
VERIFY
THAT
THIS
STRATEGY
PROFILE
IS
A
BAYESIAN
EQUILIBRIUM
OF
THIS
GAME
FIRST
WE
CHECK
WHETHER
ANY
TYPE
OF
SENDER
WISHES
TO
DEVIATE
AWAY
FROM
GOING
TO
COLLEGE
IN
FAVOR
OF
GOING
TO
THE
BEACH
INSTEAD
GIVEN
THE
HIRING
POLICIES
OF
THE
RECEIVER
EACH
TYPE
OF
SENDER
RECEIVES
A
PAYOFF
OF
FROM
CONFORMING
TO
COLLEGE
EACH
WOULD
RECEIVE
A
LOWER
PAYOFF
OF
INSTEAD
IF
SHE
WENT
TO
THE
BEACH
THEREFORE
NEITHER
TYPE
OF
SENDER
WOULD
DEVIATE
TO
CHECK
WHETHER
THE
RECEIVER
WOULD
PREFER
TO
CHANGE
HIS
HIRING
POLICY
GIVEN
THE
SENDER
TYPE
CONTINGENT
STRATEGY
WE
NEED
ONLY
CHECK
THE
ONLY
ON
THE
PATH
INFORMATION
SET
VIZ
THE
COLLEGE
INFORMATION
SET
THE
EASY
WAY
TO
SEE
THAT
HIRING
IS
OPTIMAL
AT
THE
COLLEGE
INFORMATION
SET
IS
TO
NOTICE
THAT
I
E
BOTH
TYPES
OF
SENDER
GO
TO
COLLEGE
THE
RECEIVER
REJECTS
ANY
BEACHGOERS
AND
HIRES
ANY
COLLEGE
GRADUATES
IF
THE
RECEIVER
OBSERVES
COLLEGE
HE
BELIEVES
THAT
THE
PROBABILITY
IS
THAT
THE
SENDER
IS
BRIGHT
HIRING
IS
BETTER
FOR
THE
RECEIVER
THAN
REJECTING
FOR
EACH
TYPE
OF
SENDER
SEPARATELY
THEREFORE
REGARDLESS
OF
THE
RECEIVER
BELIEF
T
THE
CORRESPONDING
CONVEX
COMBINATION
OF
HIRING
PAYOFFS
WILL
EXCEED
THE
ZERO
HE
WOULD
GET
IF
HE
REJECTS
MORE
FORMALLY
FOR
ANY
RECEIVER
BELIEFS
THAT
THE
SENDER
IS
BRIGHT
CONDITIONAL
ON
OBSERVING
COLLEGE
THE
RECEIVER
EXPECTED
PAYOFF
TO
HIRING
AT
THE
COLLEGE
INFORMATION
SET
IS
THEREFORE
FOR
ANY
THE
SPECIFIED
STRATEGY
PROFILE
IS
A
BAYESIAN
EQUILIBRIUM
THE
SPECIFICATION
OF
POSTERIOR
BELIEFS
AT
THE
COLLEGE
INFORMATION
SET
VIZ
T
IMPLIES
THAT
EVEN
AFTER
OBSERVING
THE
SENDER
MESSAGE
THE
RECEIVER
BELIEFS
ABOUT
THE
SENDER
TYPE
ARE
UNCHANGED
FROM
HER
PRIOR
BELIEFS
THIS
NO
UPDATING
RESULT
OCCURS
BECAUSE
THIS
IS
A
POOLING
STRATEGY
PROFILE
I
E
ALL
TYPES
OF
THE
SENDER
SEND
THE
SAME
MESSAGE
WE
CAN
ALSO
USE
TO
SEE
FORMALLY
THAT
THIS
SPECIFICATION
T
IS
CONSISTENT
WITH
BAYES
RULE
THIS
IS
THE
LAST
STEP
IN
VERIFYING
THAT
THE
STRATEGY
PROFILE
IS
A
BAYESIAN
EQUILIBRIUM
LETTING
M
COLLEGE
AND

BRIGHT
PBBRIGHT
COLLEGE
PBRIGHT
SSCOLLEGE
BRIGHT
PBRIGHT
SSCOLLEGE
BRIGHT
PDULL
SSCOLLEGE
DULL
I
E
PBRIGHT
COLLEGE
T
PBBRIGHT
COLLEGE
EXACTLY
AS
REQUIRED
BY
CONDITION
FOR
BAYESIAN
EQUILIBRIUM
NOW
LET
LOOK
AT
ANOTHER
STRATEGY
PROFILE
B
B
R
R
THIS
STRATEGY
PROFILE
IS
INDICATED
BELOW
IN
FIGURE
EACH
TYPE
OF
SENDER
IS
SENDING
THE
OPTIMAL
MESSAGE
GIVEN
THE
RECEIVER
HIRING
POLICY
BY
CHOOSING
BEACH
BECAUSE
EACH
TYPE
OF
SENDER
WILL
BE
REJECTED
WHATEVER
MESSAGE
SHE
SENDS
SHE
LL
CHOOSE
THE
MOST
PLEASANT
MESSAGE
VIZ
GO
TO
THE
BEACH
TO
CHECK
THE
OPTIMALITY
OF
THE
RECEIVER
HIRING
PLANS
WE
NEED
TO
CHECK
ONLY
THE
SINGLE
ON
THE
PATH
INFORMATION
SET
VIZ
BEACH
UNEDUCATED
SENDERS
AREN
T
WORTH
HIRING
SO
REJECTION
AT
THIS
INFORMATION
SET
IS
OPTIMAL
FOR
THE
RECEIVER
YOU
CAN
ALSO
VERIFY
SIMILARLY
TO
THE
DEMONSTRATION
FOR
THE
STRATEGY
PROFILE
OF
FIGURE
THAT
THE
SPECIFICATION
IS
CONSISTENT
WITH
BAYES
RULE
H
BRIGHT
B
N
T
H
C
R
R
H
R
B
C
R
R
R
DULL
FIGURE
A
LESS
CREDIBLE
BAYESIAN
EQUILIBRIUM
HOWEVER
NOTE
WHY
THE
ABOVE
STRATEGY
PROFILE
SPECIFICATION
FOR
THE
SENDER
IS
A
BEST
RESPONSE
TO
THE
PERFECT
BAYESIAN
EQUILIBRIUM
WE
SAW
IN
THE
ABOVE
EXAMPLE
THAT
THE
STRATEGY
PROFILE
DEPICTED
IN
FIGURE
WAS
A
BAYESIAN
EQUILIBRIUM
OF
THE
GAME
BUT
WAS
SUSPECT
BECAUSE
IT
RELIED
ON
A
NONOPTIMAL
ACTION
BY
THE
RECEIVER
AT
AN
OFF
THE
PATH
RECEIVER
INFORMATION
SET
WE
CAN
ELIMINATE
THIS
STRATEGY
PROFILE
BY
A
SIMPLE
STRENGTHENING
OF
OUR
SOLUTION
CONCEPT
A
PERFECT
BAYESIAN
EQUILIBRIUM
OF
THE
SENDER
RECEIVER
GAME
IS
A
TRIPLE
SS
P
M
AM

M
SATISFYING
THE
FOLLOWING
THREE
CONDITIONS
FOR
ALL
TYPES


SUPP
SSM

FOR
ALL
MESSAGES
M
M
SUPP
MAP
M
THE
CONDITIONAL
POSTERIOR
BELIEF
SYSTEM
P
IS
CONSISTENT
WITH
BAYES
RULE
WHENEVER
POSSIBLE
IN
THE
SENSE
THAT
THE
RESTRICTION
OF
P
TO
THE
ON
THE
PATH
MESSAGES
MSS
IS
PB
NOTE
THAT
THE
ONLY
DIFFERENCE
BETWEEN
THIS
DEFINITION
OF
PERFECT
BAYESIAN
AND
THE
EARLIER
DEFINITION
OF
BAYESIAN
EQUILIBRIUM
IS
IN
THE
STRENGTHENING
OF
THE
ORIGINAL
RECEIVER
OPTIMALITY
CONDITION
WHICH
IMPOSED
OPTIMALITY
ONLY
AT
ON
THE
PATH
MESSAGE
INFORMATION
SETS
RESULTING
IN
WHICH
REQUIRES
OPTIMALITY
OF
THE
RECEIVER
STRATEGY
AT
ALL
MESSAGE
INFORMATION
SETS
NOTE
FROM
THAT
THIS
ALSO
IMPLIES
THAT
NOW
THE
RECEIVER
POSTERIOR
BELIEFS
ARE
IMPORTANT
EVEN
AT
OFF
THE
PATH
MESSAGE
INFORMATION
SETS
HOWEVER
WE
AREN
T
CONSTRAINED
BY
BAYES
RULE
IN
THE
SPECIFICATION
OF
THESE
OFF
THE
PATH
BELIEFS
THE
STRATEGY
PROFILE
FROM
FIGURE
WOULD
FAIL
TO
BE
A
PERFECT
BAYESIAN
EQUILIBRIUM
REGARDLESS
OF
HOW
WE
SPECIFIED
T
BECAUSE
AS
WE
SAW
IN
THE
ANALYSIS
OF
THE
EXAMPLE
OF
FIGURE
FOR
ANY
BELIEFS
HIRING
IS
BETTER
FOR
THE
RECEIVER
AT
THE
COLLEGE
INFORMATION
SET
IS
BETTER
THAN
REJECTING
THERE
ALSO
NOTE
THAT
IF
ALL
MESSAGES
ARE
ON
THE
PATH
THEN
IF
THE
STRATEGY
PROFILE
IS
A
BAYESIAN
EQUILIBRIUM
IT
IS
ALSO
A
PERFECT
BAYESIAN
EQUILIBRIUM
EXAMPLE
PERFECT
BAYESIAN
EQUILIBRIA
CAN
STILL
BE
UNDESIRABLE
CONSIDER
THE
SAME
BASIC
GAME
WE
VE
BEEN
CONSIDERING
BUT
WITH
THE
DIFFERENT
PAYOFFS
SHOWN
IN
FIGURE
NOTE
THAT
FOR
A
FIXED
HIRING
DECISION
EACH
TYPE
OF
SENDER
PREFERS
GOING
TO
BEACH
OVER
GOING
TO
COLLEGE
BUT
THE
BRIGHT
SENDER
FINDS
COLLEGE
LESS
ONEROUS
THAN
THE
DULL
SENDER
DOES
IN
FACT
THIS
DIFFERENCE
IS
EXTREME
IN
THE
FOLLOWING
SENSE
A
BRIGHT
SENDER
IS
WILLING
TO
INCUR
THE
COST
OF
COLLEGE
IF
IT
MEANS
THAT
IT
MAKES
THE
DIFFERENCE
BETWEEN
BEING
HIRED
AND
BEING
REJECTED
HOWEVER
THE
DULL
SENDER
FINDS
COLLEGE
SUCH
A
DRAG
THAT
SHE
UNWILLING
TO
SKIP
THE
BEACH
REGARDLESS
OF
THE
EFFECT
HER
ACTION
HAS
ON
THE
HIRING
DECISION
OF
THE
RECEIVER
FOR
A
FIXED
EDUCATION
DECISION
THE
RECEIVER
PREFERS
TO
HIRE
THE
BRIGHT
SENDER
BUT
PREFERS
TO
REJECT
THE
DULL
SENDER
FOR
A
FIXED
TYPE
OF
SENDER
THE
RECEIVER
IS
INDIFFERENT
BETWEEN
HIRING
A
COLLEGE
EDUCATED
VS
A
BEACH
TANNED
SENDER
NOTE
THAT
WITH
THIS
PAYOFF
STRUCTURE
EDUCATION
IS
UNPRODUCTIVE
BUT
BECAUSE
GOING
TO
COLLEGE
HAS
A
HIGHER
COST
FOR
THE
LOWER
ABILITY
TYPE
OF
SENDER
EDUCATION
MIGHT
PROVIDE
A
COSTLY
SIGNAL
OF
THE
SENDER
TYPE
TO
THE
RECEIVER
FIGURE
EDUCATION
IS
UNPRODUCTIVE
BUT
AN
EFFECTIVE
SIGNAL
OF
ABILITY
CONSIDER
THE
STRATEGY
PROFILE
C
B
R
H
THIS
IS
NOT
ONLY
A
BAYESIAN
EQUILIBRIUM
BUT
ALSO
A
PERFECT
BAYESIAN
EQUILIBRIUM
BECAUSE
EVERY
MESSAGE
IS
ON
THE
PATH
THIS
IS
A
SEPARATING
EQUILIBRIUM
BECAUSE
EACH
TYPE
OF
SENDER
CHOOSES
A
DIFFERENT
ACTION
WHEN
EACH
TYPE
OF
SENDER
SENDS
A
DISTINCT
MESSAGE
THE
RECEIVER
CAN
DEDUCE
WITH
CERTAINTY
THE
IDENTITY
OF
THE
SENDER
FROM
HER
OBSERVED
MESSAGE
YOU
CAN
USE
TO
VERIFY
THAT
THE
POSTERIOR
BELIEF
ASSIGNMENTS
AND
T
ARE
THOSE
DETERMINED
BY
BAYES
RULE
LET
CONSIDER
THE
STRATEGY
PROFILE
B
B
R
R
T
WHERE
T
THIS
IS
A
POOLING
STRATEGY
PROFILE
THIS
IS
A
PERFECT
BAYESIAN
EQUILIBRIUM
THE
OFF
THE
PATH
POSTERIOR
BELIEFS
IMPLY
THAT
IF
A
DEFECTION
TO
COLLEGE
IS
OBSERVED
THE
DEFECTOR
IS
MORE
LIKELY
TO
BE
DULL
THAN
BRIGHT
HOWEVER
SUCH
OFF
THE
PATH
BELIEFS
ARE
OBJECTIONABLE
FOR
THE
FOLLOWING
REASON
NO
MATTER
WHAT
INFLUENCE
A
DEVIATION
TO
IF
GOING
TO
THE
BEACH
IMPLIES
THAT
THE
BRIGHT
SENDER
WILL
BE
REJECTED
THEN
GOING
TO
THE
BEACH
IMPLIES
A
PAYOFF
OF
ZERO
IF
GOING
TO
COLLEGE
IS
NECESSARY
TO
BE
HIRED
THEN
COLLEGE
IMPLIES
A
PAYOFF
OF
THEREFORE
THE
BRIGHT
SENDER
WILL
GO
TO
COLLEGE
IF
THAT
IS
NECESSARY
FOR
BEING
HIRED
THE
TEST
OF
DOMINATED
MESSAGES
WE
SAW
IN
THE
ABOVE
EXAMPLE
THAT
THE
POOLING
PERFECT
BAYESIAN
EQUILIBRIUM
PROFILE
WAS
UNDESIRABLE
BECAUSE
IT
RELIED
ON
THE
RECEIVER
INTERPRETING
A
DEVIATION
AS
COMING
FROM
A
TYPE
WHO
WOULD
NEVER
FIND
IT
OPTIMAL
TO
DEVIATE
THE
COLLEGE
MESSAGE
WAS
DOMINATED
FOR
THE
DULL
TYPE
IN
THE
FOLLOWING
SENSE
NO
MATTER
HOW
BADLY
FOR
THE
SENDER
THE
RECEIVER
MIGHT
RESPOND
TO
THE
PRESCRIBED
MESSAGE
BEACH
AND
NO
MATTER
HOW
FAVORABLY
FOR
THE
SENDER
THE
RECEIVER
MIGHT
RESPOND
TO
THE
DEVIATION
MESSAGE
COLLEGE
THE
DULL
SENDER
WOULD
STILL
PREFER
TO
SEND
THE
PRESCRIBED
MESSAGE
DENOTE
THE
SET
OF
RECEIVER
ACTIONS
WHICH
ARE
BEST
RESPONSES
CONDITIONAL
ON
THE
MESSAGE
M
FOR
SOME
CONDITIONAL
POSTERIOR
BELIEFS
BY
AM
P

AP
M
M
A
SENDER
WHO
SENDS
THE
MESSAGE
M
M
WOULD
NEVER
HAVE
TO
WORRY
ABOUT
A
RECEIVER
RESPONSE
WHICH
FELL
OUTSIDE
OF
THE
SET
AM
BECAUSE
SUCH
AN
ACTION
WOULD
NOT
BE
A
BEST
RESPONSE
BY
THE
RECEIVER
TO
ANY
POSTERIOR
BELIEF
SHE
COULD
POSSIBLY
HOLD
MESSAGE
M
M
IS
DOMINATED
FOR
TYPE


IF
THERE
EXISTS
A
MESSAGE
M
M
SUCH
THAT
MIN
A
AM

UM
A

MAX
UM
A

A
AM
LET
FI
SS
P
BE
A
PERFECT
BAYESIAN
EQUILIBRIUM
THE
EQUILIBRIUM
FAILS
THE
TEST
OF
DOMINATED
MESSAGES
IF
THERE
EXIST
TYPES



AND
AN
OFF
THE
EQUILIBRIUM
PATH
MESSAGE
M
M
MSS
SUCH
THE
RECEIVER
PUTS
POSITIVE
WEIGHT
CONDITIONAL
ON
M
BEING
OBSERVED
THAT
THE
MESSAGE
WAS
SENT
BY
TYPE

I
E
P
M
M
IS
DOMINATED
FOR
TYPE

AND
M
IS
NOT
DOMINATED
FOR
TYPE

BEFORE
WE
CAN
REJECT
AN
EQUILIBRIUM
BECAUSE
IT
PUTS
POSITIVE
WEIGHT
ON
A
DEVIANT
MESSAGE
ORIGINATING
IT
IS
MORE
COMMON
TO
ALLOW
M
TO
BE
ANY
MESSAGE
INM
THE
TEST
STATED
HERE
IS
EQUIVALENT
BECAUSE
NO
ON
THE
EQUILIBRIUM
PATH
MESSAGE
M
COULD
POSSIBLY
BE
DOMINATED
FOR
A
TYPE

FOR
WHOM
P
M
BECAUSE
ALONG
THE
EQUILIBRIUM
PATH
P
IS
DERIVED
BY
BAYES
RULE
I
E
THIS
WOULD
IMPLY
THAT
SSM


AND
THUS
THAT
IN
EQUILIBRIUM
TYPE

WERE
SENDING
A
DOMINATED
MESSAGE
THE
STATEMENT
GIVEN
HERE
SIMPLIFIES
THE
PROOF
OF
THE
THEOREM
TO
COME
FROM
A
TYPE
FOR
WHOM
THE
MESSAGE
IS
DOMINATED
WE
MUST
BE
ABLE
TO
IDENTIFY
A
TYPE
OF
SENDER
FOR
WHOM
THIS
MESSAGE
IS
NOT
DOMINATED
OTHERWISE
THIS
LOGIC
WOULD
FORCE
US
TO
PUT
ZERO
WEIGHT
ON
ALL
TYPES
AT
THIS
INFORMATION
SET
AND
THIS
WOULD
NOT
BE
A
LEGITIMATE
CONDITIONAL
PROBABILITY
DISTRIBUTION
WE
SEE
THAT
THE
POOLING
PERFECT
BAYESIAN
EQUILIBRIUM
FAIL
THE
TEST
OF
DOMINATED
MESSAGES
EXAMPLE
THE
SEPARATING
EQUILIBRIUM
DISAPPEARS
AND
THE
POOLING
BECOMES
REASONABLE
CONSIDER
THE
EXAMPLE
IN
FIGURE
NOW
COLLEGE
THOUGH
MORE
COSTLY
FOR
THE
DULL
THAN
FOR
THE
BRIGHT
SENDER
IS
NOT
AS
COSTLY
FOR
THE
DULL
SENDER
AS
IT
WAS
IN
THE
EXAMPLE
OF
FIGURE
GOING
TO
COLLEGE
IS
NO
LONGER
DOMINATED
FOR
THE
DULL
SENDER
SHE
WOULD
BE
WILLING
TO
GO
TO
COLLEGE
IF
THAT
MADE
THE
DIFFERENCE
BETWEEN
BEING
HIRED
AND
BEING
REJECTED
FIGURE
POOLING
IS
NOW
REASONABLE
AND
SEPARATION
IS
NOT
THE
SEPARATING
STRATEGY
PROFILE
C
B
R
H
WHICH
WAS
A
PERFECT
BAYESIAN
EQUILIBRIUM
IN
THE
GAME
OF
FIGURE
IS
NOT
AN
EQUILIBRIUM
OF
THE
PRESENT
GAME
BECAUSE
THE
DULL
SENDERS
WOULD
NOW
DEVIATE
TO
GOING
TO
COLLEGE
THE
POOLING
EQUILIBRIUM
B
B
R
R
T
WHERE
T
OF
FIGURE
IS
NOT
ONLY
STILL
A
PERFECT
BAYESIAN
EQUILIBRIUM
IN
THIS
GAME
IT
IS
NO
LONGER
REJECTED
BY
THE
TEST
OF
DOMINATED
MESSAGES
FIGURE
THE
TEST
OF
DOMINATED
MESSAGES
IS
NOT
STRONG
ENOUGH
CONSIDER
THE
FOLLOWING
EQUILIBRIUM
B
B
H
R
T
FOR
T
I
E
IF
A
DEVIATION
TO
COLLEGE
IS
OBSERVED
IT
IS
MORE
LIKELY
THAT
THE
DEVIATOR
IS
A
DULL
SENDER
THIS
EQUILIBRIUM
PASSES
THE
TEST
OF
DOMINATED
MESSAGES
BECAUSE
THE
DULL
SENDER
COULD
DO
WORSE
BY
GOING
TO
BEACH
GETTING
A
ZERO
THAN
BY
THE
MOST
OPTIMISTIC
HOPES
FOR
GOING
TO
COLLEGE
WHERE
SHE
COULD
GET
A
HOWEVER
THE
BRIGHT
SENDER
COULD
HOPE
TO
GAIN
BY
DEVIATION
RELATIVE
TO
HIS
EQUILIBRIUM
POTENTIAL
BUT
THE
DULL
TYPE
CANNOT
HOPE
THIS
THEREFORE
WE
SHOULDN
T
ATTRIBUTE
POSITIVE
PROBABILITY
TO
THE
DULL
SENDER
DEVIATING
LET
FI
SS
P
BE
A
PERFECT
BAYESIAN
EQUILIBRIUM
LET
U
BE
THE
TYPE

SENDER
EXPECTED
PAYOFF
IN
THIS
EQUILIBRIUM
MESSAGE
M
M
IS
EQUILIBRIUM
DOMINATED
WITH
RESPECT
TO
FOR
TYPE


IF
U
MAX
A
AM
UM
A

I
QUICKLY
VERIFY
THAT
DOMINATION
IMPLIES
EQUILIBRIUM
DOMINATION
IF
M
M
IS
DOMINATED
FOR
TYPE


THEN
FOR
EVERY
PERFECT
BAYESIAN
EQUILIBRIUM
M
IS
EQUILIBRIUM
DOMINATED
WITH
RESPECT
TO
FOR
TYPE

LET
M
M
BE
A
MESSAGE
WHICH
DOMINATES
M
FOR
TYPE

FOR
ANY
EQUILIBRIUM
RECEIVER
STRATEGY
THE
SENDER
EXPECTED
PAYOFF
TO
THE
MESSAGE
M
IS
A
M

UM
A

MIN
UM
A

A
AM

A
AM

WHICH
IS
DERIVED
FROM
AND
AP
M
AM

FOR
ANY
M
SUPP
SS
U
A
A
A
M

UM
A

ASSUME
THAT
M
IS
NOT
EQUILIBRIUM
DOMINATED
WITH
RESPECT
TO
THE
EQUILIBRIUM
THEN
FROM
THE
CONVERSE
OF
AND
A
A
M

A
M

UM
A

A
A
A
M

UM
A

THEREFORE
M
M

NOTE
IN
THAT
A
M

FOR
M
A
AM

WHICH
CONTRADICTS

LET
FI
SS
P
BE
A
PERFECT
BAYESIAN
EQUILIBRIUM
THE
EQUILIBRIUM
FAILS
THE
REFINEMENT
I
THE
INTUITIVE
CRITERION
IF
THERE
EXIST
TYPES



AND
AN
OFF
THE
EQUILIBRIUM
PATH
MESSAGE
M
M
MSS
SUCH
THE
RECEIVER
PUTS
POSITIVE
WEIGHT
CONDITIONAL
ON
M
BEING
OBSERVED
THAT
THE
MESSAGE
WAS
SENT
BY
TYPE

I
E
P
M
M
IS
EQUILIBRIUM
DOMINATED
WITH
RESPECT
TO
FOR
TYPE

AND
M
IS
NOT
EQUILIBRIUM
DOMINATED
WITH
RESPECT
TO
FOR
TYPE

IT
IS
OFTEN
ASSERTED
OR
AT
LEAST
STRONGLY
SUGGESTED
THAT
I
IS
AN
EQUILIBRIUM
REFINEMENT
OF
D
HOWEVER
A
PERFECT
BAYESIAN
EQUILIBRIUM
STRATEGY
PROFILE
CAN
PASS
THE
INTUITIVE
CRITERION
YET
FAIL
THE
TEST
OF
DOMINATED
MESSAGES
YET
IF
A
PERFECT
BAYESIAN
EQUILIBRIUM
SURVIVES
THE
INTUITIVE
CRITERION
THEN
THERE
EXISTS
A
PERFECT
BAYESIAN
EQUILIBRIUM
WHICH
YIELDS
THE
SAME
OUTCOME
I
E
PROBABILITY
DISTRIBUTION
OVER
TERMINAL
NODES
AND
WHICH
SURVIVES
BOTH
THE
TEST
OF
DOMINATED
MESSAGES
AND
THE
INTUITIVE
CRITERION
SEE
RATLIFF
REFERENCE
CHO
IN
KOO
AND
DAVID
M
KREPS
SIGNALING
GAMES
AND
STABLE
EQUILIBRIA
QUARTERLY
JOURNAL
OF
ECONOMICS
MAY
FUDENBERG
DREW
AND
JEAN
TIROLE
NONCOOPERATIVE
GAME
THEORY
FOR
INDUSTRIAL
ORGANIZATION
AN
INTRODUCTION
AND
OVERVIEW
IN
HANDBOOK
OF
INDUSTRIAL
ORGANIZATION
EDS
RICHARD
SCHMALENSEE
AND
ROBERT
D
WILLIG
VOL
NORTH
HOLLAND
PP
FUDENBERG
DREW
AND
JEAN
TIROLE
GAME
THEORY
MIT
PRESS
GIBBONS
ROBERT
GAME
THEORY
FOR
APPLIED
ECONOMISTS
PRINCETON
UNIVERSITY
PRESS
KREPS
DAVID
M
A
COURSE
IN
MICROECONOMIC
THEORY
PRINCETON
UNIVERSITY
PRESS
RATLIFF
JAMES
D
A
NOTE
ON
THE
TEST
OF
DOMINATED
MESSAGES
AND
THE
INTUITIVE
CRITERION
IN
AS
IN
THE
DEFINITION
OF
REFINEMENT
D
THE
RESTRICTION
OF
M
TO
OFF
THE
EQUILIBRIUM
PATH
MESSAGES
IS
WITHOUT
LOSS
OF
GENERALITY
FOR
MORE
ON
THESE
REFINEMENTS
SEE
CHO
AND
KREPS
AND
KREPS
FOR
EXAMPLE
FUDENBERG
AND
TIROLE
SAY
THE
IDEA
IS
ROUGHLY
TO
EXTEND
THE
ELIMINATION
OF
WEAKLY
DOMINATED
STRATEGIES
TO
STRATEGIES
WHICH
ARE
DOMINATED
RELATIVE
TO
EQUILIBRIUM
PAYOFFS
SO
DOING
ELIMINATES
MORE
STRATEGIES
AND
THUS
REFINES
THE
EQUILIBRIUM
CONCEPT
FURTHER
FUDENBERG
AND
TIROLE
SUGGEST
THAT
REPLACING
THE
EQUILIBRIUM
PATH
BY
ITS
PAYOFF
RESULTS
IN
AN
EQUILIBRIUM
REFINEMENT
WHOSE
REJECTION
REQUIREMENTS
ARE
WEAKER
AND
EASIER
TO
APPLY
KREPS
SAYS
THAT
THE
INTUITIVE
CRITERION
IS
A
STRONGER
TEST
THAN
THE
TEST
OF
DOMINATED
MESSAGES
GIBBONS
SAYS
THAT
BECAUSE
EQUILIBRIUM
DOMINANCE
IS
EASIER
TO
SATISFY
THAN
DOMINANCE
THE
INTUITIVE
CRITERION
MAKES
THE
TEST
OF
DOMINATED
MESSAGES
REDUNDANT
SENDER
RECEIVER
GAMES
MIMEO
CHAPTER
NETWORKS
IN
THEIR
SURROUNDING
CONTEXTS
IN
CHAPTER
WE
CONSIDERED
SOME
OF
THE
TYPICAL
STRUCTURES
THAT
CHARACTERIZE
SOCIAL
NET
WORKS
AND
SOME
OF
THE
TYPICAL
PROCESSES
THAT
AFFECT
THE
FORMATION
OF
LINKS
IN
THE
NETWORK
OUR
DISCUSSION
THERE
FOCUSED
PRIMARILY
ON
THE
NETWORK
AS
AN
OBJECT
OF
STUDY
IN
ITSELF
RELATIVELY
INDEPENDENT
OF
THE
BROADER
WORLD
IN
WHICH
IT
EXISTS
HOWEVER
THE
CONTEXTS
IN
WHICH
A
SOCIAL
NETWORK
IS
EMBEDDED
WILL
GENERALLY
HAVE
SIGNIF
ICANT
EFFECTS
ON
ITS
STRUCTURE
EACH
INDIVIDUAL
IN
A
SOCIAL
NETWORK
HAS
A
DISTINCTIVE
SET
OF
PERSONAL
CHARACTERISTICS
AND
SIMILARITIES
AND
COMPATIBILITIES
AMONG
TWO
PEOPLE
CHARACTERIS
TICS
CAN
STRONGLY
INFLUENCE
WHETHER
A
LINK
FORMS
BETWEEN
THEM
EACH
INDIVIDUAL
ALSO
ENGAGES
IN
A
SET
OF
BEHAVIORS
AND
ACTIVITIES
THAT
CAN
SHAPE
THE
FORMATION
OF
LINKS
WITHIN
THE
NETWORK
THESE
CONSIDERATIONS
SUGGEST
WHAT
WE
MEAN
BY
A
NETWORK
SURROUNDING
CONTEXTS
FACTORS
THAT
EXIST
OUTSIDE
THE
NODES
AND
EDGES
OF
A
NETWORK
BUT
WHICH
NONETHELESS
AFFECT
HOW
THE
NETWORK
STRUCTURE
EVOLVES
IN
THIS
CHAPTER
WE
CONSIDER
HOW
SUCH
EFFECTS
OPERATE
AND
WHAT
THEY
IMPLY
ABOUT
THE
STRUCTURE
OF
SOCIAL
NETWORKS
AMONG
OTHER
OBSERVATIONS
WE
WILL
FIND
THAT
THE
SURROUNDING
CONTEXTS
AFFECTING
A
NETWORK
FORMATION
CAN
TO
SOME
EXTENT
BE
VIEWED
IN
NETWORK
TERMS
AS
WELL
AND
BY
EXPANDING
THE
NETWORK
TO
REPRESENT
THE
CONTEXTS
TOGETHER
WITH
THE
INDIVIDUALS
WE
WILL
SEE
IN
FACT
THAT
SEVERAL
DIFFERENT
PROCESSES
OF
NETWORK
FORMATION
CAN
BE
DESCRIBED
IN
A
COMMON
FRAMEWORK
D
EASLEY
AND
J
KLEINBERG
NETWORKS
CROWDS
AND
MARKETS
REASONING
ABOUT
A
HIGHLY
CONNECTED
WORLD
CAMBRIDGE
UNIVERSITY
PRESS
DRAFT
VERSION
JUNE
HOMOPHILY
ONE
OF
THE
MOST
BASIC
NOTIONS
GOVERNING
THE
STRUCTURE
OF
SOCIAL
NETWORKS
IS
HOMOPHILY
THE
PRINCIPLE
THAT
WE
TEND
TO
BE
SIMILAR
TO
OUR
FRIENDS
TYPICALLY
YOUR
FRIENDS
DON
T
LOOK
LIKE
A
RANDOM
SAMPLE
OF
THE
UNDERLYING
POPULATION
VIEWED
COLLECTIVELY
YOUR
FRIENDS
ARE
GENERALLY
SIMILAR
TO
YOU
ALONG
RACIAL
AND
ETHNIC
DIMENSIONS
THEY
ARE
SIMILAR
IN
AGE
AND
THEY
ARE
ALSO
SIMILAR
IN
CHARACTERISTICS
THAT
ARE
MORE
OR
LESS
MUTABLE
INCLUDING
THE
PLACES
THEY
LIVE
THEIR
OCCUPATIONS
THEIR
LEVELS
OF
AFFLUENCE
AND
THEIR
INTERESTS
BELIEFS
AND
OPINIONS
CLEARLY
MOST
OF
US
HAVE
SPECIFIC
FRIENDSHIPS
THAT
CROSS
ALL
THESE
BOUNDARIES
BUT
IN
AGGREGATE
THE
PERVASIVE
FACT
IS
THAT
LINKS
IN
A
SOCIAL
NETWORK
TEND
TO
CONNECT
PEOPLE
WHO
ARE
SIMILAR
TO
ONE
ANOTHER
THIS
OBSERVATION
HAS
A
LONG
HISTORY
AS
MCPHERSON
SMITH
LOVIN
AND
COOK
NOTE
IN
THEIR
EXTENSIVE
REVIEW
OF
RESEARCH
ON
HOMOPHILY
THE
UNDERLYING
IDEA
CAN
BE
FOUND
IN
WRITINGS
OF
PLATO
SIMILARITY
BEGETS
FRIENDSHIP
AND
ARISTOTLE
PEOPLE
LOVE
THOSE
WHO
ARE
LIKE
THEMSELVES
AS
WELL
AS
IN
PROVERBS
SUCH
AS
BIRDS
OF
A
FEATHER
FLOCK
TOGETHER
ITS
ROLE
IN
MODERN
SOCIOLOGICAL
RESEARCH
WAS
CATALYZED
IN
LARGE
PART
BY
INFLUENTIAL
WORK
OF
LAZARSFELD
AND
MERTON
IN
THE
HOMOPHILY
PROVIDES
US
WITH
A
FIRST
FUNDAMENTAL
ILLUSTRATION
OF
HOW
A
NETWORK
SUR
ROUNDING
CONTEXTS
CAN
DRIVE
THE
FORMATION
OF
ITS
LINKS
CONSIDER
THE
BASIC
CONTRAST
BETWEEN
A
FRIENDSHIP
THAT
FORMS
BECAUSE
TWO
PEOPLE
ARE
INTRODUCED
THROUGH
A
COMMON
FRIEND
AND
A
FRIENDSHIP
THAT
FORMS
BECAUSE
TWO
PEOPLE
ATTEND
THE
SAME
SCHOOL
OR
WORK
FOR
THE
SAME
COMPANY
IN
THE
FIRST
CASE
A
NEW
LINK
IS
ADDED
FOR
REASONS
THAT
ARE
INTRINSIC
TO
THE
NETWORK
ITSELF
WE
NEED
NOT
LOOK
BEYOND
THE
NETWORK
TO
UNDERSTAND
WHERE
THE
LINK
CAME
FROM
IN
THE
SECOND
CASE
THE
NEW
LINK
ARISES
FOR
AN
EQUALLY
NATURAL
REASON
BUT
ONE
THAT
MAKES
SENSE
ONLY
WHEN
WE
LOOK
AT
THE
CONTEXTUAL
FACTORS
BEYOND
THE
NETWORK
AT
SOME
OF
THE
SOCIAL
ENVIRONMENTS
IN
THIS
CASE
SCHOOLS
AND
COMPANIES
TO
WHICH
THE
NODES
BELONG
OFTEN
WHEN
WE
LOOK
AT
A
NETWORK
SUCH
CONTEXTS
CAPTURE
SOME
OF
THE
DOMINANT
FEA
TURES
OF
ITS
OVERALL
STRUCTURE
FIGURE
FOR
EXAMPLE
DEPICTS
THE
SOCIAL
NETWORK
WITHIN
A
PARTICULAR
TOWN
MIDDLE
SCHOOL
AND
HIGH
SCHOOL
ENCOMPASSING
GRADES
IN
THIS
IMAGE
PRODUCED
BY
THE
STUDY
AUTHOR
JAMES
MOODY
STUDENTS
OF
DIFFERENT
RACES
ARE
DRAWN
AS
DIFFERENTLY
COLORED
CIRCLES
TWO
DOMINANT
DIVISIONS
WITHIN
THE
NETWORK
ARE
APPARENT
ONE
DIVISION
IS
BASED
ON
RACE
FROM
LEFT
TO
RIGHT
IN
THE
FIGURE
THE
OTHER
BASED
ON
AGE
AND
SCHOOL
ATTENDANCE
SEPARATES
STUDENTS
IN
THE
MIDDLE
SCHOOL
FROM
THOSE
IN
THE
HIGH
SCHOOL
FROM
TOP
TO
BOTTOM
IN
THE
FIGURE
THERE
ARE
MANY
OTHER
STRUCTURAL
DETAILS
IN
THIS
NETWORK
BUT
THE
EFFECTS
OF
THESE
TWO
CONTEXTS
STAND
OUT
WHEN
THE
NETWORK
IS
VIEWED
AT
A
GLOBAL
LEVEL
OF
COURSE
THERE
ARE
STRONG
INTERACTIONS
BETWEEN
INTRINSIC
AND
CONTEXTUAL
EFFECTS
ON
THE
FORMATION
OF
ANY
SINGLE
LINK
THEY
ARE
BOTH
OPERATING
CONCURRENTLY
IN
THE
SAME
NETWORK
FOR
EXAMPLE
THE
PRINCIPLE
OF
TRIADIC
CLOSURE
THAT
TRIANGLES
IN
THE
NETWORK
TEND
TO
CLOSE
AS
LINKS
FORM
BETWEEN
FRIENDS
OF
FRIENDS
IS
SUPPORTED
BY
A
RANGE
OF
MECHANISMS
THAT
RANGE
FROM
THE
INTRINSIC
TO
THE
CONTEXTUAL
IN
CHAPTER
WE
MOTIVATED
TRIADIC
CLOSURE
BY
FIGURE
HOMOPHILY
CAN
PRODUCE
A
DIVISION
OF
A
SOCIAL
NETWORK
INTO
DENSELY
CONNECTED
HOMOGENEOUS
PARTS
THAT
ARE
WEAKLY
CONNECTED
TO
EACH
OTHER
IN
THIS
SOCIAL
NETWORK
FROM
A
TOWN
MIDDLE
SCHOOL
AND
HIGH
SCHOOL
TWO
SUCH
DIVISIONS
IN
THE
NETWORK
ARE
APPARENT
ONE
BASED
ON
RACE
WITH
STUDENTS
OF
DIFFERENT
RACES
DRAWN
AS
DIFFERENTLY
COLORED
CIRCLES
AND
THE
OTHER
BASED
ON
FRIENDSHIPS
IN
THE
MIDDLE
AND
HIGH
SCHOOLS
RESPECTIVELY
HYPOTHESIZING
INTRINSIC
MECHANISMS
WHEN
INDIVIDUALS
B
AND
C
HAVE
A
COMMON
FRIEND
A
THEN
THERE
ARE
INCREASED
OPPORTUNITIES
AND
SOURCES
OF
TRUST
ON
WHICH
TO
BASE
THEIR
INTERACTIONS
AND
A
WILL
ALSO
HAVE
INCENTIVES
TO
FACILITATE
THEIR
FRIENDSHIP
HOWEVER
SOCIAL
CONTEXTS
ALSO
PROVIDE
NATURAL
BASES
FOR
TRIADIC
CLOSURE
SINCE
WE
KNOW
THAT
A
B
AND
A
C
FRIENDSHIPS
ALREADY
EXIST
THE
PRINCIPLE
OF
HOMOPHILY
SUGGESTS
THAT
B
AND
C
ARE
EACH
LIKELY
TO
BE
SIMILAR
TO
A
IN
A
NUMBER
OF
DIMENSIONS
AND
HENCE
QUITE
POSSIBLY
SIMILAR
TO
EACH
OTHER
AS
WELL
AS
A
RESULT
BASED
PURELY
ON
THIS
SIMILARITY
THERE
IS
AN
ELEVATED
CHANCE
THAT
A
B
C
FRIENDSHIP
WILL
FORM
AND
THIS
IS
TRUE
EVEN
IF
NEITHER
OF
THEM
IS
AWARE
THAT
THE
OTHER
ONE
KNOWS
A
THE
POINT
ISN
T
THAT
ANY
ONE
BASIS
FOR
TRIADIC
CLOSURE
IS
THE
CORRECT
ONE
RATHER
AS
WE
TAKE
INTO
ACCOUNT
MORE
AND
MORE
OF
THE
FACTORS
THAT
DRIVE
THE
FORMATION
OF
LINKS
IN
A
SOCIAL
FIGURE
USING
A
NUMERICAL
MEASURE
ONE
CAN
DETERMINE
WHETHER
SMALL
NETWORKS
SUCH
AS
THIS
ONE
WITH
NODES
DIVIDED
INTO
TWO
TYPES
EXHIBIT
HOMOPHILY
NETWORK
IT
INEVITABLY
BECOMES
DIFFICULT
TO
ATTRIBUTE
ANY
INDIVIDUAL
LINK
TO
A
SINGLE
FACTOR
AND
ULTIMATELY
ONE
EXPECTS
MOST
LINKS
TO
IN
FACT
ARISE
FROM
A
COMBINATION
OF
SEVERAL
FACTORS
PARTLY
DUE
TO
THE
EFFECT
OF
OTHER
NODES
IN
THE
NETWORK
AND
PARTLY
DUE
TO
THE
SURROUNDING
CONTEXTS
MEASURING
HOMOPHILY
WHEN
WE
SEE
STRIKING
DIVISIONS
WITHIN
A
NETWORK
LIKE
THE
ONE
IN
FIGURE
IT
IS
IMPORTANT
TO
ASK
WHETHER
THEY
ARE
GENUINELY
PRESENT
IN
THE
NETWORK
ITSELF
AND
NOT
SIMPLY
AN
ARTIFACT
OF
HOW
IT
IS
DRAWN
TO
MAKE
THIS
QUESTION
CONCRETE
WE
NEED
TO
FORMULATE
IT
MORE
PRECISELY
GIVEN
A
PARTICULAR
CHARACTERISTIC
OF
INTEREST
LIKE
RACE
OR
AGE
IS
THERE
A
SIMPLE
TEST
WE
CAN
APPLY
TO
A
NETWORK
IN
ORDER
TO
ESTIMATE
WHETHER
IT
EXHIBITS
HOMOPHILY
ACCORDING
TO
THIS
CHARACTERISTIC
SINCE
THE
EXAMPLE
IN
FIGURE
IS
TOO
LARGE
TO
INSPECT
BY
HAND
LET
CONSIDER
THIS
QUESTION
ON
A
SMALLER
EXAMPLE
WHERE
WE
CAN
DEVELOP
SOME
INTUITION
LET
SUPPOSE
IN
PARTICULAR
THAT
WE
HAVE
THE
FRIENDSHIP
NETWORK
OF
AN
ELEMENTARY
SCHOOL
CLASSROOM
AND
WE
SUSPECT
THAT
IT
EXHIBITS
HOMOPHILY
BY
GENDER
BOYS
TEND
TO
BE
FRIENDS
WITH
BOYS
AND
GIRLS
TEND
TO
BE
FRIENDS
WITH
GIRLS
FOR
EXAMPLE
THE
GRAPH
IN
FIGURE
SHOWS
THE
FRIENDSHIP
NETWORK
OF
A
SMALL
HYPOTHETICAL
CLASSROOM
IN
WHICH
THE
THREE
SHADED
NODES
ARE
GIRLS
AND
THE
SIX
UNSHADED
NODES
ARE
BOYS
IF
THERE
WERE
NO
CROSS
GENDER
EDGES
AT
ALL
THEN
THE
QUESTION
OF
HOMOPHILY
WOULD
BE
EASY
TO
RESOLVE
IT
WOULD
BE
PRESENT
IN
AN
EXTREME
SENSE
BUT
WE
EXPECT
THAT
HOMOPHILY
SHOULD
BE
A
MORE
SUBTLE
EFFECT
THAT
IS
VISIBLE
MAINLY
IN
AGGREGATE
AS
IT
IS
FOR
EXAMPLE
IN
THE
REAL
DATA
FROM
FIGURE
IS
THE
PICTURE
IN
FIGURE
CONSISTENT
WITH
HOMOPHILY
THERE
IS
A
NATURAL
NUMERICAL
MEASURE
OF
HOMOPHILY
THAT
WE
CAN
USE
TO
ADDRESS
QUESTIONS
LIKE
THIS
TO
MOTIVATE
THE
MEASURE
USING
THE
EXAMPLE
OF
GENDER
AS
IN
FIGURE
WE
FIRST
ASK
THE
FOLLOWING
QUESTION
WHAT
WOULD
IT
MEAN
FOR
A
NETWORK
NOT
TO
EXHIBIT
HO
MOPHILY
BY
GENDER
IT
WOULD
MEAN
THAT
THE
PROPORTION
OF
MALE
AND
FEMALE
FRIENDS
A
PERSON
HAS
LOOKS
LIKE
THE
BACKGROUND
MALE
FEMALE
DISTRIBUTION
IN
THE
FULL
POPULATION
HERE
A
CLOSELY
RELATED
FORMULATION
OF
THIS
NO
HOMOPHILY
DEFINITION
THAT
IS
A
BIT
EASIER
TO
ANALYZE
IF
WE
WERE
TO
RANDOMLY
ASSIGN
EACH
NODE
A
GENDER
ACCORDING
TO
THE
GENDER
BALANCE
IN
THE
REAL
NETWORK
THEN
THE
NUMBER
OF
CROSS
GENDER
EDGES
SHOULD
NOT
CHANGE
SIGNIFICANTLY
RELATIVE
TO
WHAT
WE
SEE
IN
THE
REAL
NETWORK
THAT
IS
IN
A
NETWORK
WITH
NO
HOMOPHILY
FRIENDSHIPS
ARE
BEING
FORMED
AS
THOUGH
THERE
WERE
RANDOM
MIXING
ACROSS
THE
GIVEN
CHARACTERISTIC
THUS
SUPPOSE
WE
HAVE
A
NETWORK
IN
WHICH
A
P
FRACTION
OF
ALL
INDIVIDUALS
ARE
MALE
AND
A
Q
FRACTION
OF
ALL
INDIVIDUALS
ARE
FEMALE
CONSIDER
A
GIVEN
EDGE
IN
THIS
NETWORK
IF
WE
INDEPENDENTLY
ASSIGN
EACH
NODE
THE
GENDER
MALE
WITH
PROBABILITY
P
AND
THE
GENDER
FEMALE
WITH
PROBABILITY
Q
THEN
BOTH
ENDS
OF
THE
EDGE
WILL
BE
MALE
WITH
PROBABILITY
AND
BOTH
ENDS
WILL
BE
FEMALE
WITH
PROBABILITY
ON
THE
OTHER
HAND
IF
THE
FIRST
END
OF
THE
EDGE
IS
MALE
AND
THE
SECOND
END
IS
FEMALE
OR
VICE
VERSA
THEN
WE
HAVE
A
CROSS
GENDER
EDGE
SO
THIS
HAPPENS
WITH
PROBABILITY
SO
WE
CAN
SUMMARIZE
THE
TEST
FOR
HOMOPHILY
ACCORDING
TO
GENDER
AS
FOLLOWS
HOMOPHILY
TEST
IF
THE
FRACTION
OF
CROSS
GENDER
EDGES
IS
SIGNIFICANTLY
LESS
THAN
THEN
THERE
IS
EVIDENCE
FOR
HOMOPHILY
IN
FIGURE
FOR
EXAMPLE
OF
THE
EDGES
IN
THE
GRAPH
ARE
CROSS
GENDER
SINCE
P
AND
Q
IN
THIS
EXAMPLE
WE
SHOULD
BE
COMPARING
THE
FRACTION
OF
CROSS
GENDER
EDGES
TO
THE
QUANTITY
IN
OTHER
WORDS
WITH
NO
HOMOPHILY
ONE
SHOULD
EXPECT
TO
SEE
CROSS
GENDER
EDGES
RATHER
THAN
THAN
AND
SO
THIS
EXAMPLE
SHOWS
SOME
EVIDENCE
OF
HOMOPHILY
THERE
ARE
A
FEW
POINTS
TO
NOTE
HERE
FIRST
THE
NUMBER
OF
CROSS
GENDER
EDGES
IN
A
RANDOM
ASSIGNMENT
OF
GENDERS
WILL
DEVIATE
SOME
AMOUNT
FROM
ITS
EXPECTED
VALUE
OF
AND
SO
TO
PERFORM
THE
TEST
IN
PRACTICE
ONE
NEEDS
A
WORKING
DEFINITION
OF
SIGNIFICANTLY
LESS
THAN
STANDARD
MEASURES
OF
STATISTICAL
SIGNIFICANCE
QUANTIFYING
THE
SIGNIFICANCE
OF
A
DEVIATION
BELOW
A
MEAN
CAN
BE
USED
FOR
THIS
PURPOSE
SECOND
IT
ALSO
EASILY
POSSIBLE
FOR
A
NETWORK
TO
HAVE
A
FRACTION
OF
CROSS
GENDER
EDGES
THAT
IS
SIGNIFICANTLY
MORE
THAN
IN
SUCH
A
CASE
WE
SAY
THAT
THE
NETWORK
EXHIBITS
INVERSE
HOMOPHILY
THE
NETWORK
OF
ROMANTIC
RELATIONSHIPS
IN
FIGURE
FROM
CHAPTER
IS
A
CLEAR
EXAMPLE
OF
THIS
ALMOST
ALL
THE
RELATIONSHIPS
REPORTED
BY
THE
HIGH
SCHOOL
STUDENTS
IN
THE
STUDY
INVOLVED
OPPOSITE
SEX
PARTNERS
RATHER
THAN
SAME
SEX
PARTNERS
SO
ALMOST
ALL
THE
EDGES
ARE
CROSS
GENDER
FINALLY
IT
EASY
TO
EXTEND
OUR
HOMOPHILY
TEST
TO
ANY
UNDERLYING
CHARACTERISTIC
RACE
ETHNICITY
AGE
NATIVE
LANGUAGE
POLITICAL
ORIENTATION
AND
SO
FORTH
WHEN
THE
CHARACTERISTIC
CAN
ONLY
TAKE
TWO
POSSIBLE
VALUES
SAY
ONE
VOTING
PREFERENCE
IN
A
TWO
CANDIDATE
ELECTION
THEN
WE
CAN
DRAW
A
DIRECT
ANALOGY
TO
THE
CASE
OF
TWO
GENDERS
AND
USE
THE
SAME
FORMULA
WHEN
THE
CHARACTERISTIC
CAN
TAKE
ON
MORE
THAN
TWO
POSSIBLE
VALUES
WE
STILL
PERFORM
A
GENERAL
VERSION
OF
THE
SAME
CALCULATION
FOR
THIS
WE
SAY
THAT
AN
EDGE
IS
HETEROGENEOUS
IF
IT
CONNECTS
TWO
NODES
THAT
ARE
DIFFERENT
ACCORDING
TO
THE
CHARACTERISTIC
IN
QUESTION
WE
THEN
ASK
HOW
THE
NUMBER
OF
HETEROGENEOUS
EDGES
COMPARES
TO
WHAT
WE
D
SEE
IF
WE
WERE
TO
RANDOMLY
ASSIGN
VALUES
FOR
THE
CHARACTERISTIC
TO
ALL
NODES
IN
THE
NETWORK
USING
THE
PROPORTIONS
FROM
THE
REAL
DATA
AS
PROBABILITIES
IN
THIS
WAY
EVEN
A
NETWORK
IN
WHICH
THE
NODES
ARE
CLASSIFIED
INTO
MANY
GROUPS
CAN
BE
TESTED
FOR
HOMOPHILY
USING
THE
SAME
UNDERLYING
COMPARISON
TO
A
BASELINE
OF
RANDOM
MIXING
MECHANISMS
UNDERLYING
HOMOPHILY
SELECTION
AND
SOCIAL
INFLUENCE
THE
FACT
THAT
PEOPLE
TEND
TO
HAVE
LINKS
TO
OTHERS
WHO
ARE
SIMILAR
TO
THEM
IS
A
STATEMENT
ABOUT
THE
STRUCTURE
OF
SOCIAL
NETWORKS
ON
ITS
OWN
IT
DOES
NOT
PROPOSE
AN
UNDERLYING
MECHANISM
BY
WHICH
TIES
AMONG
SIMILAR
PEOPLE
ARE
PREFERENTIALLY
FORMED
IN
THE
CASE
OF
IMMUTABLE
CHARACTERISTICS
SUCH
AS
RACE
OR
ETHNICITY
THE
TENDENCY
OF
PEOPLE
TO
FORM
FRIENDSHIPS
WITH
OTHERS
WHO
ARE
LIKE
THEM
IS
OFTEN
TERMED
SELECTION
IN
THAT
PEOPLE
ARE
SELECTING
FRIENDS
WITH
SIMILAR
CHARACTERISTICS
SELECTION
MAY
OPERATE
AT
SEVERAL
DIFFERENT
SCALES
AND
WITH
DIFFERENT
LEVELS
OF
INTENTIONALITY
IN
A
SMALL
GROUP
WHEN
PEOPLE
CHOOSE
FRIENDS
WHO
ARE
MOST
SIMILAR
FROM
AMONG
A
CLEARLY
DELINEATED
POOL
OF
POTENTIAL
CONTACTS
THERE
IS
CLEARLY
ACTIVE
CHOICE
GOING
ON
IN
OTHER
CASES
AND
AT
MORE
GLOBAL
LEVELS
SELECTION
CAN
BE
MORE
IMPLICIT
FOR
EXAMPLE
WHEN
PEOPLE
LIVE
IN
NEIGHBORHOODS
ATTEND
SCHOOLS
OR
WORK
FOR
COMPANIES
THAT
ARE
RELATIVELY
HOMOGENEOUS
COMPARED
TO
THE
POPULATION
AT
LARGE
THE
SOCIAL
ENVIRONMENT
IS
ALREADY
FAVORING
OPPORTUNITIES
TO
FORM
FRIENDSHIPS
WITH
OTHERS
LIKE
ONESELF
FOR
THIS
DISCUSSION
WE
WILL
REFER
TO
ALL
THESE
EFFECTS
CUMULATIVELY
AS
SELECTION
WHEN
WE
CONSIDER
HOW
IMMUTABLE
CHARACTERISTICS
INTERACT
WITH
NETWORK
FORMATION
THE
ORDER
OF
EVENTS
IS
CLEAR
A
PERSON
ATTRIBUTES
ARE
DETERMINED
AT
BIRTH
AND
THEY
PLAY
A
ROLE
IN
HOW
THIS
PERSON
CONNECTIONS
ARE
FORMED
OVER
THE
COURSE
OF
HIS
OR
HER
LIFE
WITH
CHARACTERISTICS
THAT
ARE
MORE
MUTABLE
ON
THE
OTHER
HAND
BEHAVIORS
ACTIVITIES
INTERESTS
BELIEFS
AND
OPINIONS
THE
FEEDBACK
EFFECTS
BETWEEN
PEOPLE
INDIVIDUAL
CHARACTERISTICS
AND
THEIR
LINKS
IN
THE
SOCIAL
NETWORK
BECOME
SIGNIFICANTLY
MORE
COMPLEX
THE
PROCESS
OF
SELECTION
STILL
OPERATES
WITH
INDIVIDUAL
CHARACTERISTICS
AFFECTING
THE
CONNECTIONS
THAT
ARE
FORMED
BUT
NOW
ANOTHER
PROCESS
COMES
INTO
PLAY
AS
WELL
PEOPLE
MAY
MODIFY
THEIR
BEHAVIORS
TO
BRING
THEM
MORE
CLOSELY
INTO
ALIGNMENT
WITH
THE
BEHAVIORS
OF
THEIR
FRIENDS
THIS
PROCESS
HAS
BEEN
VARIOUSLY
DESCRIBED
AS
SOCIALIZATION
AND
SOCIAL
INFLUENCE
SINCE
THE
EXISTING
SOCIAL
CONNECTIONS
IN
A
NETWORK
ARE
INFLUENCING
THE
INDIVIDUAL
CHARACTERISTICS
OF
THE
NODES
SOCIAL
INFLUENCE
CAN
BE
VIEWED
AS
THE
REVERSE
OF
SELECTION
WITH
SELECTION
THE
INDIVIDUAL
CHARACTERISTICS
DRIVE
THE
FORMATION
OF
LINKS
WHILE
WITH
SOCIAL
INFLUENCE
THE
EXISTING
LINKS
IN
MECHANISMS
UNDERLYING
HOMOPHILY
SELECTION
AND
SOCIAL
THE
NETWORK
SERVE
TO
SHAPE
PEOPLE
MUTABLE
CHARACTERISTICS
THE
INTERPLAY
OF
SELECTION
AND
SOCIAL
INFLUENCE
WHEN
WE
LOOK
AT
A
SINGLE
SNAPSHOT
OF
A
NETWORK
AND
SEE
THAT
PEOPLE
TEND
TO
SHARE
MUTABLE
CHARACTERISTICS
WITH
THEIR
FRIENDS
IT
CAN
BE
VERY
HARD
TO
SORT
OUT
THE
DISTINCT
EFFECTS
AND
RELATIVE
CONTRIBUTIONS
OF
SELECTION
AND
SOCIAL
INFLUENCE
HAVE
THE
PEOPLE
IN
THE
NETWORK
ADAPTED
THEIR
BEHAVIORS
TO
BECOME
MORE
LIKE
THEIR
FRIENDS
OR
HAVE
THEY
SOUGHT
OUT
PEOPLE
WHO
WERE
ALREADY
LIKE
THEM
SUCH
QUESTIONS
CAN
BE
ADDRESSED
USING
LONGITUDINAL
STUDIES
OF
A
SOCIAL
NETWORK
IN
WHICH
THE
SOCIAL
CONNECTIONS
AND
THE
BEHAVIORS
WITHIN
A
GROUP
ARE
BOTH
TRACKED
OVER
A
PERIOD
OF
TIME
FUNDAMENTALLY
THIS
MAKES
IT
POSSIBLE
TO
SEE
THE
BEHAVIORAL
CHANGES
THAT
OCCUR
AFTER
CHANGES
IN
AN
INDIVIDUAL
NETWORK
CONNECTIONS
AS
OPPOSED
TO
THE
CHANGES
TO
THE
NETWORK
THAT
OCCUR
AFTER
AN
INDIVIDUAL
CHANGES
HIS
OR
HER
BEHAVIOR
THIS
TYPE
OF
METHODOLOGY
HAS
BEEN
USED
FOR
EXAMPLE
TO
STUDY
THE
PROCESSES
THAT
LEAD
PAIRS
OF
ADOLESCENT
FRIENDS
TO
HAVE
SIMILAR
OUTCOMES
IN
TERMS
OF
SCHOLASTIC
ACHIEVEMENT
AND
DELINQUENT
BEHAVIOR
SUCH
AS
DRUG
USE
EMPIRICAL
EVIDENCE
CONFIRMS
THE
INTUITIVE
FACT
THAT
TEENAGE
FRIENDS
ARE
SIMILAR
TO
EACH
OTHER
IN
THEIR
BEHAVIORS
AND
BOTH
SELECTION
AND
SOCIAL
INFLUENCE
HAVE
A
NATURAL
RESONANCE
IN
THIS
SETTING
TEENAGERS
SEEK
OUT
SOCIAL
CIRCLES
COMPOSED
OF
PEOPLE
LIKE
THEM
AND
PEER
PRESSURE
CAUSES
THEM
TO
CONFORM
TO
BEHAVIORAL
PATTERNS
WITHIN
THEIR
SOCIAL
CIRCLES
WHAT
IS
MUCH
HARDER
TO
RESOLVE
IS
HOW
THESE
TWO
EFFECTS
INTERACT
AND
WHETHER
ONE
IS
MORE
STRONGLY
AT
WORK
THAN
THE
OTHER
AS
LONGITUDINAL
BEHAVIOR
RELEVANT
TO
THIS
QUESTION
BECAME
AVAILABLE
RESEARCHERS
BEGAN
QUANTIFYING
THE
RELATIVE
IMPACT
OF
THESE
DIFFERENT
FACTORS
A
LINE
OF
WORK
BEGINNING
WITH
COHEN
AND
KANDEL
HAS
SUGGESTED
THAT
WHILE
BOTH
EFFECTS
ARE
PRESENT
IN
THE
DATA
THE
OUTSIZED
ROLE
THAT
EARLIER
INFORMAL
ARGUMENTS
HAD
ACCORDED
TO
PEER
PRESSURE
I
E
SOCIAL
INFLUENCE
IS
ACTUALLY
MORE
MODERATE
THE
EFFECT
OF
SELECTION
HERE
IS
IN
FACT
COMPARABLE
TO
AND
SOMETIMES
GREATER
THAN
THE
EFFECT
OF
SOCIAL
INFLUENCE
UNDERSTANDING
THE
TENSION
BETWEEN
THESE
DIFFERENT
FORCES
CAN
BE
IMPORTANT
NOT
JUST
FOR
IDENTIFYING
UNDERLYING
CAUSES
BUT
ALSO
FOR
REASONING
ABOUT
THE
EFFECT
OF
POSSIBLE
INTERVENTIONS
ONE
MIGHT
ATTEMPT
IN
THE
SYSTEM
FOR
EXAMPLE
ONCE
WE
FIND
THAT
ILLICIT
DRUG
USE
DISPLAYS
HOMOPHILY
ACROSS
A
SOCIAL
NETWORK
WITH
STUDENTS
SHOWING
A
GREATER
LIKELIHOOD
TO
USE
DRUGS
WHEN
THEIR
FRIENDS
DO
WE
CAN
ASK
ABOUT
THE
EFFECTS
OF
A
PROGRAM
THAT
TARGETS
CERTAIN
HIGH
SCHOOL
STUDENTS
AND
INFLUENCES
THEM
TO
STOP
USING
DRUGS
TO
THE
EXTENT
THAT
THE
OBSERVED
HOMOPHILY
IS
BASED
ON
SOME
AMOUNT
OF
SOCIAL
INFLUENCE
SUCH
A
PROGRAM
COULD
HAVE
A
BROAD
IMPACT
ACROSS
THE
SOCIAL
NETWORK
BY
CAUSING
THE
FRIENDS
OF
THESE
TARGETED
STUDENTS
TO
STOP
USING
DRUGS
AS
WELL
BUT
ONE
MUST
BE
CAREFUL
IF
THE
OBSERVED
HOMOPHILY
IS
ARISING
INSTEAD
ALMOST
ENTIRELY
FROM
SELECTION
EFFECTS
THEN
THE
PROGRAM
MAY
NOT
REDUCE
DRUG
USE
ARE
OTHER
COGNITIVE
EFFECTS
AT
WORK
AS
WELL
FOR
EXAMPLE
PEOPLE
MAY
SYSTEMATICALLY
MISPERCEIVE
THE
CHARACTERISTICS
OF
THEIR
FRIENDS
AS
BEING
MORE
IN
ALIGNMENT
WITH
THEIR
OWN
THAN
THEY
REALLY
ARE
FOR
OUR
DISCUSSION
HERE
WE
WILL
NOT
FOCUS
EXPLICITLY
ON
SUCH
EFFECTS
BEYOND
THE
STUDENTS
IT
DIRECTLY
TARGETS
AS
THESE
STUDENTS
STOP
USING
DRUGS
THEY
CHANGE
THEIR
SOCIAL
CIRCLES
AND
FORM
NEW
FRIENDSHIPS
WITH
STUDENTS
WHO
DON
T
USE
DRUGS
BUT
THE
DRUG
USING
BEHAVIOR
OF
OTHER
STUDENTS
IS
NOT
STRONGLY
AFFECTED
ANOTHER
EXAMPLE
OF
RESEARCH
ADDRESSING
THIS
SUBTLE
INTERPLAY
OF
FACTORS
IS
THE
WORK
OF
CHRISTAKIS
AND
FOWLER
ON
THE
EFFECT
OF
SOCIAL
NETWORKS
ON
HEALTH
RELATED
OUTCOMES
IN
ONE
RECENT
STUDY
USING
LONGITUDINAL
DATA
COVERING
ROUGHLY
PEOPLE
THEY
TRACKED
OBESITY
STATUS
AND
SOCIAL
NETWORK
STRUCTURE
OVER
A
YEAR
PERIOD
THEY
FOUND
THAT
OBESE
AND
NON
OBESE
PEOPLE
CLUSTERED
IN
THE
NETWORK
IN
A
FASHION
CONSISTENT
WITH
HOMOPHILY
ACCORDING
TO
THE
NUMERICAL
MEASURE
DESCRIBED
IN
SECTION
PEOPLE
TEND
TO
BE
MORE
SIMILAR
IN
OBESITY
STATUS
TO
THEIR
NETWORK
NEIGHBORS
THAN
IN
A
VERSION
OF
THE
SAME
NETWORK
WHERE
OBESITY
STATUS
IS
ASSIGNED
RANDOMLY
THE
PROBLEM
IS
THEN
TO
DISTINGUISH
AMONG
SEVERAL
HYPOTHESES
FOR
WHY
THIS
CLUSTERING
IS
PRESENT
IS
IT
I
BECAUSE
OF
SELECTION
EFFECTS
IN
WHICH
PEOPLE
ARE
CHOOSING
TO
FORM
FRIENDSHIPS
WITH
OTHERS
OF
SIMILAR
OBESITY
STATUS
II
BECAUSE
OF
THE
CONFOUNDING
EFFECTS
OF
HOMOPHILY
ACCORDING
TO
OTHER
CHARACTERISTICS
IN
WHICH
THE
NETWORK
STRUCTURE
INDICATES
EXISTING
PATTERNS
OF
SIMILARITY
IN
OTHER
DIMENSIONS
THAT
CORRELATE
WITH
OBESITY
STATUS
OR
III
BECAUSE
CHANGES
IN
THE
OBESITY
STATUS
OF
A
PERSON
FRIENDS
WAS
EXERTING
A
PRESUMABLY
BEHAVIORAL
INFLUENCE
THAT
AFFECTED
HIS
OR
HER
FUTURE
OBESITY
STATUS
STATISTICAL
ANALYSIS
IN
CHRISTAKIS
AND
FOWLER
PAPER
ARGUES
THAT
EVEN
ACCOUNTING
FOR
EFFECTS
OF
TYPES
I
AND
II
THERE
IS
SIGNIFICANT
EVIDENCE
FOR
AN
EFFECT
OF
TYPE
III
AS
WELL
THAT
OBESITY
IS
A
HEALTH
CONDITION
DISPLAYING
A
FORM
OF
SOCIAL
INFLUENCE
WITH
CHANGES
IN
YOUR
FRIENDS
OBESITY
STATUS
IN
TURN
HAVING
A
SUBSEQUENT
EFFECT
ON
YOU
THIS
SUGGESTS
THE
INTRIGUING
PROSPECT
THAT
OBESITY
AND
PERHAPS
OTHER
HEALTH
CONDITIONS
WITH
A
STRONG
BEHAVIORAL
ASPECT
MAY
EXHIBIT
SOME
AMOUNT
OF
CONTAGION
IN
A
SOCIAL
SENSE
YOU
DON
T
NECESSARILY
CATCH
IT
FROM
YOUR
FRIENDS
THE
WAY
YOU
CATCH
THE
FLU
BUT
IT
NONETHELESS
CAN
SPREAD
THROUGH
THE
UNDERLYING
SOCIAL
NETWORK
VIA
THE
MECHANISM
OF
SOCIAL
INFLUENCE
THESE
EXAMPLES
AND
THIS
GENERAL
STYLE
OF
INVESTIGATION
SHOW
HOW
CAREFUL
ANALYSIS
IS
NEEDED
TO
DISTINGUISH
AMONG
DIFFERENT
FACTORS
CONTRIBUTING
TO
AN
AGGREGATE
CONCLUSION
EVEN
WHEN
PEOPLE
TEND
TO
BE
SIMILAR
TO
THEIR
NEIGHBORS
IN
A
SOCIAL
NETWORK
IT
MAY
NOT
BE
CLEAR
WHY
THE
POINT
IS
THAT
AN
OBSERVATION
OF
HOMOPHILY
IS
OFTEN
NOT
AN
ENDPOINT
IN
ITSELF
BUT
RATHER
THE
STARTING
POINT
FOR
DEEPER
QUESTIONS
QUESTIONS
THAT
ADDRESS
WHY
THE
HOMOPHILY
IS
PRESENT
HOW
ITS
UNDERLYING
MECHANISMS
WILL
AFFECT
THE
FURTHER
EVOLUTION
OF
THE
NETWORK
AND
HOW
THESE
MECHANISMS
INTERACT
WITH
POSSIBLE
OUTSIDE
ATTEMPTS
TO
INFLUENCE
THE
BEHAVIOR
OF
PEOPLE
IN
THE
NETWORK
FIGURE
AN
AFFILIATION
NETWORK
IS
A
BIPARTITE
GRAPH
THAT
SHOWS
WHICH
INDIVIDUALS
ARE
AFFILIATED
WITH
WHICH
GROUPS
OR
ACTIVITIES
HERE
ANNA
PARTICIPATES
IN
BOTH
OF
THE
SOCIAL
FOCI
ON
THE
RIGHT
WHILE
DANIEL
PARTICIPATES
IN
ONLY
ONE
AFFILIATION
THUS
FAR
WE
HAVE
BEEN
DISCUSSING
CONTEXTUAL
FACTORS
THAT
AFFECT
THE
FORMATION
OF
LINKS
IN
A
NETWORK
BASED
ON
SIMILARITIES
IN
CHARACTERISTICS
OF
THE
NODES
AND
BASED
ON
BEHAVIORS
AND
ACTIVITIES
THAT
THE
NODES
ENGAGE
IN
THESE
SURROUNDING
CONTEXTS
HAVE
BEEN
VIEWED
APPROPRIATELY
AS
EXISTING
OUTSIDE
THE
NETWORK
BUT
IN
FACT
IT
POSSIBLE
TO
PUT
THESE
CONTEXTS
INTO
THE
NETWORK
ITSELF
BY
WORKING
WITH
A
LARGER
NETWORK
THAT
CONTAINS
BOTH
PEOPLE
AND
CONTEXTS
AS
NODES
THROUGH
SUCH
A
NETWORK
FORMULATION
WE
WILL
GET
ADDITIONAL
INSIGHT
INTO
SOME
BROAD
ASPECTS
OF
HOMOPHILY
AND
SEE
HOW
THE
SIMULTANEOUS
EVOLUTION
OF
CONTEXTS
AND
FRIENDSHIPS
CAN
BE
PUT
ON
A
COMMON
NETWORK
FOOTING
WITH
THE
NOTION
OF
TRIADIC
CLOSURE
FROM
CHAPTER
IN
PRINCIPLE
WE
COULD
REPRESENT
ANY
CONTEXT
THIS
WAY
BUT
FOR
THE
SAKE
OF
CONCRETENESS
WE
LL
FOCUS
ON
HOW
TO
REPRESENT
THE
SET
OF
ACTIVITIES
A
PERSON
TAKES
PART
IN
AND
HOW
THESE
AFFECT
THE
FORMATION
OF
LINKS
WE
WILL
TAKE
A
VERY
GENERAL
VIEW
OF
THE
NOTION
OF
AN
ACTIVITY
HERE
BEING
PART
OF
A
PARTICULAR
COMPANY
ORGANIZATION
OR
NEIGBORHOOD
FREQUENTING
A
PARTICULAR
PLACE
PURSUING
A
PARTICULAR
HOBBY
OR
INTEREST
THESE
ARE
ALL
ACTIVITIES
THAT
WHEN
SHARED
BETWEEN
TWO
PEOPLE
TEND
TO
INCREASE
THE
LIKELIHOOD
THAT
THEY
WILL
INTERACT
AND
HENCE
FORM
A
LINK
IN
THE
SOCIAL
NETWORK
ADOPTING
TERMINOLOGY
DUE
TO
SCOTT
FELD
WE
LL
REFER
TO
SUCH
ACTIVITIES
AS
FOCI
THAT
IS
FOCAL
POINTS
OF
SOCIAL
INTERACTION
CONSTITUTING
SOCIAL
PSYCHOLOGICAL
LEGAL
OR
PHYSICAL
ENTIT
IES
AROUND
WHICH
JOINT
ACTIVITIES
ARE
ORGANIZED
E
G
WORKPLACES
VOLUNTARY
ORGANIZATIONS
HANGOUTS
ETC
AFFILIATION
NETWORKS
AS
A
FIRST
STEP
WE
CAN
REPRESENT
THE
PARTICIPATION
OF
A
SET
OF
PEOPLE
IN
A
SET
OF
FOCI
USING
A
GRAPH
AS
FOLLOWS
WE
WILL
HAVE
A
NODE
FOR
EACH
PERSON
AND
A
NODE
FOR
EACH
FOCUS
AND
WE
WILL
CONNECT
PERSON
A
TO
FOCUS
X
BY
AN
EDGE
IF
A
PARTICIPATES
IN
X
FIGURE
ONE
TYPE
OF
AFFILIATION
NETWORK
THAT
HAS
BEEN
WIDELY
STUDIED
IS
THE
MEMBERSHIPS
OF
PEOPLE
ON
CORPORATE
BOARDS
OF
DIRECTORS
A
VERY
SMALL
PORTION
OF
THIS
NETWORK
AS
OF
MID
IS
SHOWN
HERE
THE
STRUCTURAL
PATTERN
OF
MEMBERSHIPS
CAN
REVEAL
SUBTLETIES
IN
THE
INTERACTIONS
AMONG
BOTH
THE
BOARD
MEMBERS
AND
THE
COMPANIES
A
VERY
SIMPLE
EXAMPLE
OF
SUCH
A
GRAPH
IS
DEPICTED
IN
FIGURE
SHOWING
TWO
PEOPLE
ANNA
AND
DANIEL
AND
TWO
FOCI
WORKING
FOR
A
LITERACY
TUTORING
ORGANIZATION
AND
BELONGING
TO
A
KARATE
CLUB
THE
GRAPH
INDICATES
THAT
ANNA
PARTICIPATES
IN
BOTH
OF
THE
FOCI
WHILE
DANIEL
PARTICIPATES
IN
ONLY
ONE
WE
WILL
REFER
TO
SUCH
A
GRAPH
AS
AN
AFFILIATION
NETWORK
SINCE
IT
REPRESENTS
THE
AFFILIATION
OF
PEOPLE
DRAWN
ON
THE
LEFT
WITH
FOCI
DRAWN
ON
THE
RIGHT
MORE
GENERALLY
AFFILIATION
NETWORKS
ARE
EXAMPLES
OF
A
CLASS
OF
GRAPHS
CALLED
BIPARTITE
GRAPHS
WE
SAY
THAT
A
GRAPH
IS
BIPARTITE
IF
ITS
NODES
CAN
BE
DIVIDED
INTO
TWO
SETS
IN
SUCH
A
WAY
THAT
EVERY
EDGE
CONNECTS
A
NODE
IN
ONE
SET
TO
A
NODE
IN
THE
OTHER
SET
IN
OTHER
WORDS
THERE
ARE
NO
EDGES
JOINING
A
PAIR
OF
NODES
THAT
BELONG
TO
THE
SAME
SET
ALL
EDGES
GO
BETWEEN
THE
TWO
SETS
BIPARTITE
GRAPHS
ARE
VERY
USEFUL
FOR
REPRESENTING
DATA
IN
WHICH
THE
ITEMS
UNDER
STUDY
COME
IN
TWO
CATEGORIES
AND
WE
WANT
TO
UNDERSTAND
HOW
THE
ITEMS
IN
ONE
CATEGORY
ARE
ASSOCIATED
WITH
THE
ITEMS
IN
THE
OTHER
IN
THE
CASE
OF
AFFILIATION
NETWORKS
THE
TWO
CATEGORIES
ARE
THE
PEOPLE
AND
THE
FOCI
WITH
EACH
EDGE
CONNECTING
A
PERSON
TO
A
FOCUS
THAT
HE
OR
SHE
PARTICIPATES
IN
BIPARTITE
GRAPHS
ARE
OFTEN
DRAWN
AS
IN
FIGURE
WITH
THE
TWO
DIFFERENT
SETS
OF
NODES
DRAWN
AS
TWO
PARALLEL
VERTICAL
COLUMNS
AND
THE
EDGES
CROSSING
BETWEEN
THE
TWO
COLUMNS
AFFILIATION
NETWORKS
ARE
STUDIED
IN
A
RANGE
OF
SETTINGS
WHERE
RESEARCHERS
WANT
TO
UN
DERSTAND
THE
PATTERNS
OF
PARTICIPATION
IN
STRUCTURED
ACTIVITIES
AS
ONE
EXAMPLE
THEY
HAVE
RECEIVED
CONSIDERABLE
ATTENTION
IN
STUDYING
THE
COMPOSITION
OF
BOARDS
OF
DIRECTORS
OF
MAJOR
CORPORATIONS
BOARDS
OF
DIRECTORS
ARE
RELATIVELY
SMALL
ADVISORY
GROUPS
POPULATED
BY
HIGH
STATUS
INDIVIDUALS
AND
SINCE
MANY
PEOPLE
SERVE
ON
MULTIPLE
BOARDS
THE
OVERLAPS
IN
THEIR
PARTICIPATION
HAVE
A
COMPLEX
STRUCTURE
THESE
OVERLAPS
CAN
BE
NATURALLY
REPRESENTED
BY
AN
AFFILIATION
NETWORK
AS
THE
EXAMPLE
IN
FIGURE
SHOWS
THERE
IS
A
NODE
FOR
EACH
PERSON
AND
A
NODE
FOR
EACH
BOARD
AND
EACH
EDGE
CONNECTS
A
PERSON
TO
A
BOARD
THAT
THEY
BELONG
TO
AFFILIATION
NETWORKS
DEFINED
BY
BOARDS
OF
DIRECTORS
HAVE
THE
POTENTIAL
TO
REVEAL
INTERESTING
RELATIONSHIPS
ON
BOTH
SIDES
OF
THE
GRAPH
TWO
COMPANIES
ARE
IMPLICITLY
LINKED
BY
HAVING
THE
SAME
PERSON
SIT
ON
BOTH
THEIR
BOARDS
WE
CAN
THUS
LEARN
ABOUT
POSSIBLE
CONDUITS
FOR
INFORMATION
AND
INFLUENCE
TO
FLOW
BETWEEN
DIFFERENT
COMPANIES
TWO
PEOPLE
ON
THE
OTHER
HAND
ARE
IMPLICITLY
LINKED
BY
SERVING
TOGETHER
ON
A
BOARD
AND
SO
WE
LEARN
ABOUT
PARTICULAR
PATTERNS
OF
SOCIAL
INTERACTION
AMONG
SOME
OF
THE
MOST
POWERFUL
MEMBERS
OF
SOCIETY
OF
COURSE
EVEN
THE
COMPLETE
AFFILIATION
NETWORK
OF
PEOPLE
AND
BOARDS
OF
WHICH
FIGURE
IS
ONLY
A
SMALL
PIECE
STILL
MISSES
OTHER
IMPORTANT
CONTEXTS
THAT
THESE
PEOPLE
INHABIT
FOR
EXAMPLE
THE
SEVEN
PEOPLE
IN
FIGURE
INCLUDE
THE
PRESIDENTS
OF
TWO
MAJOR
UNIVERSITIES
AND
A
FORMER
VICE
PRESIDENT
OF
THE
UNITED
STATES
CO
EVOLUTION
OF
SOCIAL
AND
AFFILIATION
NETWORKS
IT
CLEAR
THAT
BOTH
SOCIAL
NETWORKS
AND
AFFILIATION
NETWORKS
CHANGE
OVER
TIME
NEW
FRIENDSHIP
LINKS
ARE
FORMED
AND
PEOPLE
BECOME
ASSOCIATED
WITH
NEW
FOCI
MOREOVER
THESE
CHANGES
REPRESENT
A
KIND
OF
CO
EVOLUTION
THAT
REFLECTS
THE
INTERPLAY
BETWEEN
SELECTION
AND
SOCIAL
INFLUENCE
IF
TWO
PEOPLE
PARTICIPATE
IN
A
SHARED
FOCUS
THIS
PROVIDES
THEM
WITH
AN
OPPORTUNITY
TO
BECOME
FRIENDS
AND
IF
TWO
PEOPLE
ARE
FRIENDS
THEY
CAN
INFLUENCE
EACH
OTHER
CHOICE
OF
FOCI
THERE
IS
A
NATURAL
NETWORK
PERSPECTIVE
ON
THESE
IDEAS
WHICH
BEGINS
FROM
A
NETWORK
REPRESENTATION
THAT
SLIGHTLY
EXTENDS
THE
NOTION
OF
AN
AFFILIATION
NETWORK
AS
BEFORE
WE
LL
HAVE
NODES
FOR
PEOPLE
AND
NODES
FOR
FOCI
BUT
WE
NOW
INTRODUCE
TWO
DISTINCT
KINDS
OF
EDGES
AS
WELL
THE
FIRST
KIND
OF
EDGE
FUNCTIONS
AS
AN
EDGE
IN
A
SOCIAL
NETWORK
IT
CONNECTS
TWO
STRUCTURE
OF
THIS
NETWORK
CHANGES
OVER
TIME
AS
WELL
AND
SOMETIMES
IN
WAYS
THAT
REINFORCE
THE
POINTS
IN
OUR
PRESENT
DISCUSSION
FOR
EXAMPLE
THE
BOARD
MEMBERSHIPS
SHOWN
IN
FIGURE
ARE
TAKEN
FROM
THE
MIDDLE
OF
BY
THE
END
OF
ARTHUR
LEVINSON
HAD
RESIGNED
FROM
THE
BOARD
OF
DIRECTORS
OF
GOOGLE
THUS
REMOVING
ONE
EDGE
FROM
THE
GRAPH
AS
PART
OF
THE
NEWS
COVERAGE
OF
THIS
RESIGNATION
THE
CHAIR
OF
THE
U
FEDERAL
TRADE
COMMISSION
JON
LEIBOWITZ
EXPLICITLY
INVOKED
THE
NOTION
OF
OVERLAPS
IN
BOARD
MEMBERSHIP
SAYING
GOOGLE
APPLE
AND
MR
LEVINSON
SHOULD
BE
COMMENDED
FOR
RECOGNIZING
THAT
OVERLAPPING
BOARD
MEMBERS
BETWEEN
COMPETING
COMPANIES
RAISE
SERIOUS
ANTITRUST
ISSUES
AND
FOR
THEIR
WILLINGNESS
TO
RESOLVE
OUR
CONCERNS
WITHOUT
THE
NEED
FOR
LITIGATION
BEYOND
THIS
MATTER
WE
WILL
CONTINUE
TO
MONITOR
COMPANIES
THAT
SHARE
BOARD
MEMBERS
AND
TAKE
ENFORCEMENT
ACTIONS
WHERE
APPROPRIATE
FIGURE
A
SOCIAL
AFFILIATION
NETWORK
SHOWS
BOTH
THE
FRIENDSHIPS
BETWEEN
PEOPLE
AND
THEIR
AFFILIATION
WITH
DIFFERENT
SOCIAL
FOCI
PEOPLE
AND
INDICATES
FRIENDSHIP
OR
ALTERNATIVELY
SOME
OTHER
SOCIAL
RELATION
LIKE
PROFESSIONAL
COLLABORATION
THE
SECOND
KIND
OF
EDGE
FUNCTIONS
AS
AN
EDGE
IN
AN
AFFILIATION
NETWORK
IT
CONNECTS
A
PERSON
TO
A
FOCUS
AND
INDICATES
THE
PARTICIPATION
OF
THE
PERSON
IN
THE
FOCUS
WE
WILL
CALL
SUCH
A
NETWORK
A
SOCIAL
AFFILIATION
NETWORK
REFLECTING
THE
FACT
THAT
IT
SIMULTANEOUSLY
CONTAINS
A
SOCIAL
NETWORK
ON
THE
PEOPLE
AND
AN
AFFILIATION
NETWORK
ON
THE
PEOPLE
AND
FOCI
FIGURE
DEPICTS
A
SIMPLE
SOCIAL
AFFILIATION
NETWORK
ONCE
WE
HAVE
SOCIAL
AFFILIATION
NETWORKS
AS
OUR
REPRESENTATION
WE
CAN
APPRECIATE
THAT
A
RANGE
OF
DIFFERENT
MECHANISMS
FOR
LINK
FORMATION
CAN
ALL
BE
VIEWED
AS
TYPES
OF
CLOSURE
PROCESSES
IN
THAT
THEY
INVOLVE
CLOSING
THE
THIRD
EDGE
OF
A
TRIANGLE
IN
THE
NETWORK
IN
PARTICULAR
SUPPOSE
WE
HAVE
TWO
NODES
B
AND
C
WITH
A
COMMON
NEIGHBOR
A
IN
THE
NETWORK
AND
SUPPOSE
THAT
AN
EDGE
FORMS
BETWEEN
B
AND
C
THERE
ARE
SEVERAL
INTERPRETATIONS
FOR
WHAT
THIS
CORRESPONDS
TO
DEPENDING
ON
WHETHER
A
B
AND
C
ARE
PEOPLE
OR
FOCI
I
IF
A
B
AND
C
EACH
REPRESENT
A
PERSON
THEN
THE
FORMATION
OF
THE
LINK
BETWEEN
B
AND
C
IS
TRIADIC
CLOSURE
JUST
AS
IN
CHAPTER
SEE
FIGURE
A
II
IF
B
AND
C
REPRESENT
PEOPLE
BUT
A
REPRESENTS
A
FOCUS
THEN
THIS
IS
SOMETHING
DIFFERENT
IT
IS
THE
TENDENCY
OF
TWO
PEOPLE
TO
FORM
A
LINK
WHEN
THEY
HAVE
A
FOCUS
IN
COMMON
SEE
FIGURE
B
THIS
IS
AN
ASPECT
OF
THE
MORE
GENERAL
PRINCIPLE
OF
SELECTION
FORMING
LINKS
TO
OTHERS
WHO
SHARE
CHARACTERISTICS
WITH
YOU
TO
EMPHASIZE
THE
ANALOGY
WITH
TRIADIC
CLOSURE
THIS
PROCESS
HAS
BEEN
CALLED
FOCAL
CLOSURE
III
IF
A
AND
B
ARE
PEOPLE
AND
C
IS
A
FOCUS
THEN
WE
HAVE
THE
FORMATION
OF
A
NEW
AFFILIATION
B
TAKES
PART
IN
A
FOCUS
THAT
HER
FRIEND
A
IS
ALREADY
INVOLVED
IN
SEE
FIGURE
C
THIS
IS
A
KIND
OF
SOCIAL
INFLUENCE
IN
WHICH
B
BEHAVIOR
COMES
INTO
CLOSER
ALIGNMENT
PERSON
A
TRIADIC
CLOSURE
FOCUS
B
FOCAL
CLOSURE
PERSON
C
MEMBERSHIP
CLOSURE
FIGURE
EACH
OF
TRIADIC
CLOSURE
FOCAL
CLOSURE
AND
MEMBERSHIP
CLOSURE
CORRESPONDS
TO
THE
CLOSING
OF
A
TRIANGLE
IN
A
SOCIAL
AFFILIATION
NETWORK
WITH
THAT
OF
HER
FRIEND
A
CONTINUING
THE
ANALOGY
WITH
TRIADIC
CLOSURE
WE
WILL
REFER
TO
THIS
KIND
OF
LINK
FORMATION
AS
MEMBERSHIP
CLOSURE
THUS
THREE
VERY
DIFFERENT
UNDERLYING
MECHANISMS
REFLECTING
TRIADIC
CLOSURE
AND
ASPECTS
OF
SELECTION
AND
SOCIAL
INFLUENCE
CAN
BE
UNIFIED
IN
THIS
TYPE
OF
NETWORK
AS
KINDS
OF
CLOSURE
THE
FORMATION
OF
A
LINK
IN
CASES
WHERE
THE
TWO
ENDPOINTS
ALREADY
HAVE
A
NEIGHBOR
IN
COMMON
FIGURE
SHOWS
ALL
THREE
KINDS
OF
CLOSURE
PROCESSES
AT
WORK
TRIADIC
CLOSURE
LEADS
TO
A
NEW
LINK
BETWEEN
ANNA
AND
CLAIRE
FOCAL
CLOSURE
LEADS
TO
A
NEW
LINK
BETWEEN
ANNA
AND
DANIEL
AND
MEMBERSHIP
CLOSURE
LEADS
TO
BOB
AFFILIATION
WITH
THE
KARATE
CLUB
OVERSIMPLIFYING
THE
MECHANISMS
AT
WORK
THEY
CAN
BE
SUMMARIZED
IN
THE
FOLLOWING
SUCCINCT
WAY
I
BOB
INTRODUCES
ANNA
TO
CLAIRE
II
KARATE
INTRODUCES
ANNA
TO
DANIEL
III
ANNA
INTRODUCES
BOB
TO
KARATE
TRACKING
LINK
FORMATION
IN
ON
LINE
DATA
IN
THIS
CHAPTER
AND
THE
PREVIOUS
ONE
WE
HAVE
IDENTIFIED
A
SET
OF
DIFFERENT
MECHANISMS
THAT
LEAD
TO
THE
FORMATION
OF
LINKS
IN
SOCIAL
NETWORKS
THESE
MECHANSISMS
ARE
GOOD
EXAMPLES
FIGURE
IN
A
SOCIAL
AFFILIATION
NETWORK
CONTAINING
BOTH
PEOPLE
AND
FOCI
EDGES
CAN
FORM
UNDER
THE
EFFECT
OF
SEVERAL
DIFFERENT
KINDS
OF
CLOSURE
PROCESSES
TWO
PEOPLE
WITH
A
FRIEND
IN
COMMON
TWO
PEOPLE
WITH
A
FOCUS
IN
COMMON
OR
A
PERSON
JOINING
A
FOCUS
THAT
A
FRIEND
IS
ALREADY
INVOLVED
IN
OF
SOCIAL
PHENOMENA
WHICH
ARE
CLEARLY
AT
WORK
IN
SMALL
GROUP
SETTINGS
BUT
WHICH
HAVE
TRADITIONALLY
BEEN
VERY
HARD
TO
MEASURE
QUANTITATIVELY
A
NATURAL
RESEARCH
STRATEGY
IS
TO
TRY
TRACKING
THESE
MECHANISMS
AS
THEY
OPERATE
IN
LARGE
POPULATIONS
WHERE
AN
ACCUMULATION
OF
MANY
SMALL
EFFECTS
CAN
PRODUCE
SOMETHING
OBSERVABLE
IN
THE
AGGREGATE
HOWEVER
GIVEN
THAT
MOST
OF
THE
FORCES
RESPONSIBLE
FOR
LINK
FORMATION
GO
LARGELY
UNRECORDED
IN
EVERYDAY
LIFE
IT
IS
A
CHALLENGE
TO
SELECT
A
LARGE
CLEARLY
DELINEATED
GROUP
OF
PEOPLE
AND
SOCIAL
FOCI
AND
ACCURATELY
QUANTIFY
THE
RELATIVE
CONTRIBUTIONS
THAT
THESE
DIFFERENT
MECHANISMS
MAKE
TO
THE
FORMATION
OF
REAL
NETWORK
LINKS
THE
AVAILABILITY
OF
DATA
FROM
LARGE
ON
LINE
SETTINGS
WITH
CLEAR
SOCIAL
STRUCTURE
HAS
MADE
IT
POSSIBLE
TO
ATTEMPT
SOME
PRELIMINARY
RESEARCH
ALONG
THESE
LINES
AS
WE
EMPHASIZED
IN
CHAPTER
ANY
ANALYSIS
OF
SOCIAL
PROCESSES
BASED
ON
SUCH
ON
LINE
DATASETS
MUST
COME
WITH
A
NUMBER
OF
CAVEATS
IN
PARTICULAR
IT
IS
NEVER
A
PRIORI
CLEAR
HOW
MUCH
ONE
CAN
EXTRAPOLATE
FROM
DIGITAL
INTERACTIONS
TO
INTERACTIONS
THAT
ARE
NOT
COMPUTER
MEDIATED
OR
EVEN
FROM
ONE
COMPUTER
MEDIATED
SETTING
TO
ANOTHER
OF
COURSE
THIS
PROBLEM
OF
EXTRAPOLATION
IS
PRESENT
WHENEVER
ONE
STUDIES
PHENOMENA
IN
A
MODEL
SYSTEM
ON
LINE
OR
NOT
AND
THE
KINDS
OF
MEA
SUREMENTS
THESE
LARGE
DATASETS
ENABLE
REPRESENT
INTERESTING
FIRST
STEPS
TOWARD
A
DEEPER
QUAN
TITATIVE
UNDERSTANDING
OF
HOW
MECHANISMS
OF
LINK
FORMATION
OPERATE
IN
REAL
LIFE
EXPLORING
THESE
QUESTIONS
IN
A
BROADER
RANGE
OF
LARGE
DATASETS
IS
AN
IMPORTANT
PROBLEM
AND
ONE
THAT
WILL
BECOME
EASIER
AS
LARGE
SCALE
DATA
BECOMES
INCREASINGLY
ABUNDANT
TRIADIC
CLOSURE
WITH
THIS
BACKGROUND
IN
MIND
LET
START
WITH
SOME
QUESTIONS
ABOUT
TRIADIC
CLOSURE
HERE
A
FIRST
BASIC
NUMERICAL
QUESTION
HOW
MUCH
MORE
LIKELY
IS
A
LINK
TO
FIGURE
A
LARGER
NETWORK
THAT
CONTAINS
THE
EXAMPLE
FROM
FIGURE
PAIRS
OF
PEOPLE
CAN
HAVE
MORE
THAN
ONE
FRIEND
OR
MORE
THAN
ONE
FOCUS
IN
COMMON
HOW
DOES
THIS
INCREASE
THE
LIKELIHOOD
THAT
AN
EDGE
WILL
FORM
BETWEEN
THEM
FORM
BETWEEN
TWO
PEOPLE
IN
A
SOCIAL
NETWORK
IF
THEY
ALREADY
HAVE
A
FRIEND
IN
COMMON
IN
OTHER
WORDS
HOW
MUCH
MORE
LIKELY
IS
A
LINK
TO
FORM
IF
IT
HAS
THE
EFFECT
OF
CLOSING
A
TRIANGLE
HERE
A
SECOND
QUESTION
ALONG
THE
SAME
LINES
AS
THE
FIRST
HOW
MUCH
MORE
LIKELY
IS
AN
EDGE
TO
FORM
BETWEEN
TWO
PEOPLE
IF
THEY
HAVE
MULTIPLE
FRIENDS
IN
COMMON
FOR
EXAMPLE
IN
FIGURE
ANNA
AND
ESTHER
HAVE
TWO
FRIENDS
IN
COMMON
WHILE
CLAIRE
AND
DANIEL
ONLY
HAVE
ONE
FRIEND
IN
COMMON
HOW
MUCH
MORE
LIKELY
IS
THE
FORMATION
OF
A
LINK
IN
THE
FIRST
OF
THESE
TWO
CASES
IF
WE
GO
BACK
TO
THE
ARGUMENTS
FOR
WHY
TRIADIC
CLOSURE
OPERATES
IN
SOCIAL
NETWORKS
WE
SEE
THAT
THEY
ALL
ARE
QUALITATIVELY
STRENGTHENED
AS
TWO
PEOPLE
HAVE
MORE
FRIENDS
IN
COMMON
THERE
ARE
MORE
SOURCES
OF
OPPORTUNITY
AND
TRUST
FOR
THE
INTERACTION
THERE
ARE
MORE
PEOPLE
WITH
AN
INCENTIVE
TO
BRING
THEM
TOGETHER
AND
THE
EVIDENCE
FOR
HOMOPHILY
IS
ARGUABLY
STRONGER
WE
CAN
ADDRESS
THESE
QUESTIONS
EMPIRICALLY
USING
NETWORK
DATA
AS
FOLLOWS
I
WE
TAKE
TWO
SNAPSHOTS
OF
THE
NETWORK
AT
DIFFERENT
TIMES
II
FOR
EACH
K
WE
IDENTIFY
ALL
PAIRS
OF
NODES
WHO
HAVE
EXACTLY
K
FRIENDS
IN
COMMON
IN
THE
FIRST
SNAPSHOT
BUT
WHO
ARE
NOT
DIRECTLY
CONNECTED
BY
AN
EDGE
III
WE
DEFINE
T
K
TO
BE
THE
FRACTION
OF
THESE
PAIRS
THAT
HAVE
FORMED
AN
EDGE
BY
THE
TIME
NUMBER
OF
COMMON
FRIENDS
FIGURE
QUANTIFYING
THE
EFFECTS
OF
TRIADIC
CLOSURE
IN
AN
E
MAIL
DATASET
THE
CURVE
DETERMINED
FROM
THE
DATA
IS
SHOWN
IN
THE
SOLID
BLACK
LINE
THE
DOTTED
CURVES
SHOW
A
COMPAR
ISON
TO
PROBABILITIES
COMPUTED
ACCORDING
TO
TWO
SIMPLE
BASELINE
MODELS
IN
WHICH
COMMON
FRIENDS
PROVIDE
INDEPENDENT
PROBABILITIES
OF
LINK
FORMATION
OF
THE
SECOND
SNAPSHOT
THIS
IS
OUR
EMPIRICAL
ESTIMATE
FOR
THE
PROBABILITY
THAT
A
LINK
WILL
FORM
BETWEEN
TWO
PEOPLE
WITH
K
FRIENDS
IN
COMMON
IV
WE
PLOT
T
K
AS
A
FUNCTION
OF
K
TO
ILLUSTRATE
THE
EFFECT
OF
COMMON
FRIENDS
ON
THE
FORMATION
OF
LINKS
NOTE
THAT
T
IS
THE
RATE
AT
WHICH
LINK
FORMATION
HAPPENS
WHEN
IT
DOES
NOT
CLOSE
A
TRIANGLE
WHILE
THE
VALUES
OF
T
K
FOR
LARGER
K
DETERMINE
THE
RATE
AT
WHICH
LINK
FORMATION
HAPPENS
WHEN
IT
DOES
CLOSE
A
TRIANGLE
THUS
THE
COMPARISON
BETWEEN
T
AND
THESE
OTHER
VALUES
ADDRESSES
THE
MOST
BASIC
QUESTION
ABOUT
THE
POWER
OF
TRIADIC
CLOSURE
KOSSINETS
AND
WATTS
COMPUTED
THIS
FUNCTION
T
K
USING
A
DATASET
ENCODING
THE
FULL
HISTORY
OF
E
MAIL
COMMUNICATION
AMONG
ROUGHLY
UNDERGRADUATE
AND
GRADUATE
STUDENTS
OVER
A
ONE
YEAR
PERIOD
AT
A
LARGE
U
UNIVERSITY
THIS
IS
A
WHO
TALKS
TO
WHOM
TYPE
OF
DATASET
AS
WE
DISCUSSED
IN
CHAPTER
FROM
THE
COMMUNICATION
TRACES
KOSSINETS
AND
WATTS
CONSTRUCTED
A
NETWORK
THAT
EVOLVED
OVER
TIME
JOINING
TWO
PEOPLE
BY
A
LINK
AT
A
GIVEN
INSTANT
IF
THEY
HAD
EXCHANGED
E
MAIL
IN
EACH
DIRECTION
AT
SOME
POINT
IN
THE
PAST
DAYS
THEY
THEN
DETERMINED
AN
AVERAGE
VERSION
OF
T
K
BY
TAKING
MULTIPLE
PAIRS
OF
SNAPSHOTS
THEY
BUILT
A
CURVE
FOR
T
K
ON
EACH
PAIR
OF
SNAPSHOTS
USING
THE
PROCEDURE
DESCRIBED
ABOVE
AND
THEN
AVERAGED
ALL
THE
CURVES
THEY
OBTAINED
IN
PARTICULAR
THE
OBSERVATIONS
IN
EACH
SNAPSHOT
WERE
ONE
DAY
APART
SO
THEIR
COMPUTATION
GIVES
THE
AVERAGE
PROBABILITY
THAT
TWO
PEOPLE
FORM
A
LINK
PER
DAY
AS
A
FUNCTION
OF
THE
NUMBER
OF
COMMON
FRIENDS
THEY
HAVE
FIGURE
SHOWS
A
PLOT
OF
THIS
CURVE
IN
THE
SOLID
BLACK
LINE
THE
FIRST
THING
ONE
NOTICES
IS
THE
CLEAR
EVIDENCE
FOR
TRIADIC
CLOSURE
T
IS
VERY
CLOSE
TO
AFTER
WHICH
THE
PROBABILITY
OF
LINK
FORMATION
INCREASES
STEADILY
AS
THE
NUMBER
OF
COMMON
FRIENDS
INCREASES
MOREOVER
FOR
MUCH
OF
THE
PLOT
THIS
PROBABILITY
INCREASES
IN
A
ROUGHLY
LINEAR
FASHION
AS
A
FUNCTION
OF
THE
NUMBER
OF
COMMON
FRIENDS
WITH
AN
UPWARD
BEND
AWAY
FROM
A
STRAIGHT
LINE
SHAPE
THE
CURVE
TURNS
UPWARD
IN
A
PARTICULARLY
PRONOUNCED
WAY
FROM
TO
TO
FRIENDS
HAVING
TWO
COMMON
FRIENDS
PRODUCES
SIGNIFICANTLY
MORE
THAN
TWICE
THE
EFFECT
ON
LINK
FORMATION
COMPARED
TO
HAVING
A
SINGLE
COMMON
FRIEND
THE
UPWARD
EFFECT
FROM
TO
TO
FRIENDS
IS
ALSO
SIGNIFICANT
BUT
IT
OCCURS
ON
A
MUCH
SMALLER
SUB
POPULATION
SINCE
MANY
FEWER
PEOPLE
IN
THE
DATA
HAVE
THIS
MANY
FRIENDS
IN
COMMON
WITHOUT
HAVING
ALREADY
FORMED
A
LINK
TO
INTERPRET
THIS
PLOT
MORE
DEEPLY
IT
HELPS
TO
COMPARE
IT
TO
AN
INTENTIONALLY
SIMPLIFIED
BASELINE
MODEL
DESCRIBING
WHAT
ONE
MIGHT
HAVE
EXPECTED
THE
DATA
TO
LOOK
LIKE
IN
THE
PRESENCE
OF
TRIADIC
CLOSURE
SUPPOSE
THAT
FOR
SOME
SMALL
PROBABILITY
P
EACH
COMMON
FRIEND
THAT
TWO
PEOPLE
HAVE
GIVES
THEM
AN
INDEPENDENT
PROBABILITY
P
OF
FORMING
A
LINK
EACH
DAY
SO
IF
TWO
PEOPLE
HAVE
K
FRIENDS
IN
COMMON
THE
PROBABILITY
THEY
FAIL
TO
FORM
A
LINK
ON
ANY
GIVEN
DAY
IS
P
K
THIS
IS
BECAUSE
EACH
COMMON
FRIEND
FAILS
TO
CAUSE
THE
LINK
TO
FORM
WITH
PROBABILITY
P
AND
THESE
K
TRIALS
ARE
INDEPENDENT
SINCE
P
K
IS
THE
PROBABILITY
THE
LINK
FAILS
TO
FORM
ON
A
GIVEN
DAY
THE
PROBABILITY
THAT
IT
DOES
FORM
ACCORDING
TO
OUR
SIMPLE
BASELINE
MODEL
IS
TBASELINE
K
P
K
WE
PLOT
THIS
CURVE
IN
FIGURE
AS
THE
UPPER
DOTTED
LINE
GIVEN
THE
SMALL
ABSOLUTE
EFFECT
OF
THE
FIRST
COMMON
FRIEND
IN
THE
DATA
WE
ALSO
SHOW
A
COMPARISON
TO
THE
CURVE
P
K
WHICH
JUST
SHIFTS
THE
SIMPLE
BASELINE
CURVE
ONE
UNIT
TO
THE
RIGHT
AGAIN
THE
POINT
IS
NOT
TO
PROPOSE
THIS
BASELINE
AS
AN
EXPLANATORY
MECHANISM
FOR
TRIADIC
CLOSURE
BUT
RATHER
TO
LOOK
AT
HOW
THE
REAL
DATA
COMPARES
TO
IT
BOTH
THE
REAL
CURVE
AND
THE
BASELINE
CURVE
ARE
CLOSE
TO
LINEAR
AND
HENCE
QUALITATIVELY
SIMILAR
BUT
THE
FACT
THAT
THE
REAL
DATA
TURNS
UPWARD
WHILE
THE
BASELINE
CURVE
TURNS
SLIGHTLY
DOWNWARD
INDICATES
THAT
THE
ASSUMPTION
OF
INDEPENDENT
EFFECTS
FROM
COMMON
FRIENDS
IS
TOO
SIMPLE
TO
BE
FULLY
SUPPORTED
BY
THE
DATA
A
STILL
LARGER
AND
MORE
DETAILED
STUDY
OF
THESE
EFFECTS
WAS
CONDUCTED
BY
LESKOVEC
ET
AL
WHO
ANALYZED
PROPERTIES
OF
TRIADIC
CLOSURE
IN
THE
ON
LINE
SOCIAL
NETWORKS
OF
LINKEDIN
FLICKR
DEL
ICIO
US
AND
YAHOO
ANSWERS
IT
REMAINS
AN
INTERESTING
QUESTION
TO
TRY
UNDER
STANDING
THE
SIMILARITIES
AND
VARIATIONS
IN
TRIADIC
CLOSURE
EFFECTS
ACROSS
SOCIAL
INTERACTION
IN
A
RANGE
OF
DIFFERENT
SETTINGS
NUMBER
OF
COMMON
FOCI
FIGURE
QUANTIFYING
THE
EFFECTS
OF
FOCAL
CLOSURE
IN
AN
E
MAIL
DATASET
AGAIN
THE
CURVE
DETERMINED
FROM
THE
DATA
IS
SHOWN
IN
THE
SOLID
BLACK
LINE
WHILE
THE
DOTTED
CURVE
PROVIDES
A
COMPARISON
TO
A
SIMPLE
BASELINE
FOCAL
AND
MEMBERSHIP
CLOSURE
USING
THE
SAME
APPROACH
WE
CAN
COMPUTE
PROBABIL
ITIES
FOR
THE
OTHER
KINDS
OF
CLOSURE
DISCUSSED
EARLIER
SPECIFICALLY
FOCAL
CLOSURE
WHAT
IS
THE
PROBABILITY
THAT
TWO
PEOPLE
FORM
A
LINK
AS
A
FUNCTION
OF
THE
NUMBER
OF
FOCI
THEY
ARE
JOINTLY
AFFILIATED
WITH
MEMBERSHIP
CLOSURE
WHAT
IS
THE
PROBABILITY
THAT
A
PERSON
BECOMES
INVOLVED
WITH
A
PARTICULAR
FOCUS
AS
A
FUNCTION
OF
THE
NUMBER
OF
FRIENDS
WHO
ARE
ALREADY
INVOLVED
IN
IT
AS
AN
EXAMPLE
OF
THE
FIRST
OF
THESE
KINDS
OF
CLOSURE
USING
FIGURE
ANNA
AND
GRACE
HAVE
ONE
ACTIVITY
IN
COMMON
WHILE
ANNA
AND
FRANK
HAVE
TWO
IN
COMMON
AS
AN
EXAMPLE
OF
THE
SECOND
ESTHER
HAS
ONE
FRIEND
WHO
BELONGS
TO
THE
KARATE
CLUB
WHILE
CLAIRE
HAS
TWO
HOW
DO
THESE
DISTINCTIONS
AFFECT
THE
FORMATION
OF
NEW
LINKS
FOR
FOCAL
CLOSURE
KOSSINETS
AND
WATTS
SUPPLEMENTED
THEIR
UNIVERSITY
E
MAIL
DATASET
WITH
INFORMATION
ABOUT
THE
CLASS
SCHEDULES
FOR
EACH
STUDENT
IN
THIS
WAY
EACH
CLASS
BECAME
A
FOCUS
AND
TWO
STUDENTS
SHARED
A
FOCUS
IF
THEY
HAD
TAKEN
A
CLASS
TOGETHER
THEY
COULD
THEN
COMPUTE
THE
PROBABILITY
OF
FOCAL
CLOSURE
BY
DIRECT
ANALOGY
WITH
THEIR
COMPUTATION
FOR
TRIADIC
CLOSURE
DETERMINING
THE
PROBABILITY
OF
LINK
FORMATION
PER
DAY
AS
A
FUNCTION
OF
THE
NUMBER
OF
SHARED
FOCI
FIGURE
SHOWS
A
PLOT
OF
THIS
FUNCTION
A
SINGLE
SHARED
CLASS
TURNS
OUT
TO
HAVE
ROUGHLY
THE
SAME
ABSOLUTE
EFFECT
ON
LINK
FORMATION
AS
A
SINGLE
SHARED
FRIEND
BUT
AFTER
THIS
THE
PROBABILITY
OF
JOINING
A
COMMUNITY
WHEN
K
FRIENDS
ARE
ALREADY
MEMBERS
K
FIGURE
QUANTIFYING
THE
EFFECTS
OF
MEMBERSHIP
CLOSURE
IN
A
LARGE
ONLINE
DATASET
THE
PLOT
SHOWS
THE
PROBABILITY
OF
JOINING
A
LIVEJOURNAL
COMMUNITY
AS
A
FUNCTION
OF
THE
NUMBER
OF
FRIENDS
WHO
ARE
ALREADY
MEMBERS
CURVE
FOR
FOCAL
CLOSURE
BEHAVES
QUITE
DIFFERENTLY
FROM
THE
CURVE
FOR
TRIADIC
CLOSURE
IT
TURNS
DOWNWARD
AND
APPEARS
TO
APPROXIMATELY
LEVEL
OFF
RATHER
THAN
TURNING
SLIGHTLY
UPWARD
THUS
SUBSEQUENT
SHARED
CLASSES
AFTER
THE
FIRST
PRODUCE
A
DIMINISHING
RETURNS
EFFECT
COMPARING
TO
THE
SAME
KIND
OF
BASELINE
IN
WHICH
THE
PROBABILITY
OF
LINK
FORMATION
WITH
K
SHARED
CLASSES
IS
P
K
SHOWN
AS
THE
DOTTED
CURVE
IN
FIGURE
WE
SEE
THAT
THE
REAL
DATA
TURNS
DOWNWARD
MORE
SIGNIFICANTLY
THAN
THIS
INDEPENDENT
MODEL
AGAIN
IT
IS
AN
INTERESTING
OPEN
QUESTION
TO
UNDERSTAND
HOW
THIS
EFFECT
GENERALIZES
TO
OTHER
TYPES
OF
SHARED
FOCI
AND
TO
OTHER
DOMAINS
FOR
MEMBERSHIP
CLOSURE
THE
ANALOGOUS
QUANTITIES
HAVE
BEEN
MEASURED
IN
OTHER
ON
LINE
DOMAINS
THAT
POSSESS
BOTH
PERSON
TO
PERSON
INTERACTIONS
AND
PERSON
TO
FOCUS
AFFILIATIONS
FIGURE
IS
BASED
ON
THE
BLOGGING
SITE
LIVEJOURNAL
WHERE
FRIENDSHIPS
ARE
DESIGNATED
BY
USERS
IN
THEIR
PROFILES
AND
WHERE
FOCI
CORRESPOND
TO
MEMBERSHIP
IN
USER
DEFINED
COMMUNITIES
THUS
THE
PLOT
SHOWS
THE
PROBABILITY
OF
JOINING
A
COMMUNITY
AS
A
FUNCTION
OF
THE
NUMBER
OF
FRIENDS
WHO
HAVE
ALREADY
DONE
SO
FIGURE
SHOWS
A
SIMILAR
ANALYSIS
FOR
WIKIPEDIA
HERE
THE
SOCIAL
AFFILIATION
NETWORK
CONTAINS
A
NODE
FOR
EACH
WIKIPEDIA
EDITOR
WHO
MAINTAINS
A
USER
ACCOUNT
AND
USER
TALK
PAGE
ON
THE
SYSTEM
AND
THERE
IS
AN
EDGE
JOINING
TWO
SUCH
EDITORS
IF
THEY
HAVE
COMMUNICATED
WITH
ONE
EDITOR
WRITING
ON
THE
USER
TALK
PAGE
OF
THE
OTHER
EACH
FIGURE
QUANTIFYING
THE
EFFECTS
OF
MEMBERSHIP
CLOSURE
IN
A
LARGE
ONLINE
DATASET
THE
PLOT
SHOWS
THE
PROBABILITY
OF
EDITING
A
WIKIPEDIA
ARTICLES
AS
A
FUNCTION
OF
THE
NUMBER
OF
FRIENDS
WHO
HAVE
ALREADY
DONE
SO
WIKIPEDIA
ARTICLE
DEFINES
A
FOCUS
AN
EDITOR
IS
ASSOCIATED
WITH
A
FOCUS
CORRESPONDING
TO
A
PARTICULAR
ARTICLE
IF
HE
OR
SHE
HAS
EDITED
THE
ARTICLE
THUS
THE
PLOT
IN
FIGURE
SHOWS
THE
PROBABILITY
A
PERSON
EDITS
A
WIKIPEDIA
ARTICLE
AS
A
FUNCTION
OF
THE
NUMBER
OF
PRIOR
EDITORS
WITH
WHOM
HE
OR
SHE
HAS
COMMUNICATED
AS
WITH
TRIADIC
AND
FOCAL
CLOSURE
THE
PROBABILITIES
IN
BOTH
FIGURE
AND
INCREASE
WITH
THE
NUMBER
K
OF
COMMON
NEIGHBORS
REPRESENTING
FRIENDS
ASSOCIATED
WITH
THE
FOCI
THE
MARGINAL
EFFECT
DIMINISHES
AS
THE
NUMBER
OF
FRIENDS
INCREASES
BUT
THE
EFFECT
OF
SUBSEQUENT
FRIENDS
REMAINS
SIGNIFICANT
MOREOVER
IN
BOTH
SOURCES
OF
DATA
THERE
IS
AN
INITIAL
INCREASING
EFFECT
SIMILAR
TO
WHAT
WE
SAW
WITH
TRIADIC
CLOSURE
IN
THIS
CASE
THE
PROBABILITY
OF
JOINING
A
LIVEJOURNAL
COMMUNITY
OR
EDITING
A
WIKIPEDIA
ARTICLE
IS
MORE
THAN
TWICE
AS
GREAT
WHEN
YOU
HAVE
TWO
CONNECTIONS
INTO
THE
FOCUS
RATHER
THAN
ONE
IN
OTHER
WORDS
THE
CONNECTION
TO
A
SECOND
PERSON
IN
THE
FOCUS
HAS
A
PARTICULARLY
PRONOUNCED
EFFECT
AND
AFTER
THIS
THE
DIMINISHING
MARGINAL
EFFECT
OF
CONNECTIONS
TO
FURTHER
PEOPLE
TAKES
OVER
OF
COURSE
MULTIPLE
EFFECTS
CAN
OPERATE
SIMULTANEOUSLY
ON
THE
FORMATION
OF
A
SINGLE
LINK
FOR
EXAMPLE
IF
WE
CONSIDER
THE
EXAMPLE
IN
FIGURE
TRIADIC
CLOSURE
MAKES
A
LINK
BETWEEN
BOB
AND
DANIEL
MORE
LIKELY
DUE
TO
THEIR
SHARED
FRIENDSHIP
WITH
ANNA
AND
FOCAL
CLOSURE
ALSO
MAKES
THIS
LINK
MORE
LIKELY
DUE
TO
THE
SHARED
MEMBERSHIP
OF
BOB
AND
DANIEL
IN
THE
KARATE
CLUB
IF
A
LINK
DOES
FORM
BETWEEN
THEM
IT
WILL
NOT
NECESSARILY
BE
A
PRIORI
CLEAR
HOW
TO
ATTRIBUTE
IT
TO
THESE
TWO
DISTINCT
EFFECTS
THIS
IS
ALSO
A
REFLECTION
OF
AN
ISSUE
WE
DISCUSSED
IN
SECTION
WHEN
DESCRIBING
SOME
OF
THE
MECHANISMS
BEHIND
TRIADIC
CLOSURE
SINCE
THE
PRINCIPLE
OF
HOMOPHILY
SUGGESTS
THAT
FRIENDS
TEND
TO
HAVE
MANY
CHARACTERISTICS
IN
COMMON
THE
EXISTENCE
OF
A
SHARED
FRIEND
BETWEEN
TWO
PEOPLE
IS
OFTEN
INDICATIVE
OF
OTHER
POSSIBLY
UNOBSERVED
SOURCES
OF
SIMILARITY
SUCH
AS
SHARED
FOCI
IN
THIS
CASE
THAT
BY
THEMSELVES
MAY
ALSO
MAKE
LINK
FORMATION
MORE
LIKELY
QUANTIFYING
THE
INTERPLAY
BETWEEN
SELECTION
AND
SOCIAL
INFLUENCE
AS
A
FINAL
ILLUSTRATION
OF
HOW
WE
CAN
USE
LARGE
SCALE
ON
LINE
DATA
TO
TRACK
PROCESSES
OF
LINK
FORMATION
LET
RETURN
TO
THE
QUESTION
OF
HOW
SELECTION
AND
SOCIAL
INFLUENCE
WORK
TOGETHER
TO
PRODUCE
HOMOPHILY
CONSIDERED
IN
SECTION
WE
LL
MAKE
USE
OF
THE
WIKIPEDIA
DATA
DISCUSSED
EARLIER
IN
THIS
SECTION
ASKING
HOW
DO
SIMILARITIES
IN
BEHAVIOR
BETWEEN
TWO
WIKIPEDIA
EDITORS
RELATE
TO
THEIR
PATTERN
OF
SOCIAL
INTERACTION
OVER
TIME
TO
MAKE
THIS
QUESTION
PRECISE
WE
NEED
TO
DEFINE
BOTH
THE
SOCIAL
NETWORK
AND
AN
UNDERLYING
MEASURE
OF
BEHAVIORAL
SIMILARITY
AS
BEFORE
THE
SOCIAL
NETWORK
WILL
CONSIST
OF
ALL
WIKIPEDIA
EDITORS
WHO
MAINTAIN
TALK
PAGES
AND
THERE
IS
AN
EDGE
CONNECTING
TWO
EDITORS
IF
THEY
HAVE
COMMUNICATED
WITH
ONE
WRITING
ON
THE
TALK
PAGE
OF
THE
OTHER
AN
EDITOR
BEHAVIOR
WILL
CORRESPOND
TO
THE
SET
OF
ARTICLES
SHE
HAS
EDITED
THERE
ARE
A
NUMBER
OF
NATURAL
WAYS
TO
DEFINE
NUMERICAL
MEASURES
OF
SIMILARITY
BETWEEN
TWO
EDITORS
BASED
ON
THEIR
ACTIONS
A
SIMPLE
ONE
IS
TO
DECLARE
THEIR
SIMILARITY
TO
BE
THE
VALUE
OF
THE
RATIO
NUMBER
OF
ARTICLES
EDITED
BY
BOTH
A
AND
B
NUMBER
OF
ARTICLES
EDITED
BY
AT
LEAST
ONE
OF
A
OR
B
FOR
EXAMPLE
IF
EDITOR
A
HAS
EDITED
THE
WIKIPEDIA
ARTICLES
ON
ITHACA
NY
AND
CORNELL
UNI
VERSITY
AND
EDITOR
B
HAS
EDITED
THE
ARTICLES
ON
CORNELL
UNIVERSITY
AND
STANFORD
UNIVERSITY
THEN
THEIR
SIMILARITY
UNDER
THIS
MEASURE
IS
SINCE
THEY
HAVE
JOINTLY
EDITED
ONE
ARTICLE
CORNELL
OUT
OF
THREE
THAT
THEY
HAVE
EDITED
IN
TOTAL
CORNELL
ITHACA
AND
STANFORD
NOTE
THE
CLOSE
SIMILARITY
TO
THE
DEFINITION
OF
NEIGHBORHOOD
OVERLAP
USED
IN
SECTION
INDEED
THE
MEASURE
IN
EQUATION
IS
PRECISELY
THE
NEIGHBORHOOD
OVERLAP
OF
TWO
EDITORS
IN
THE
BIPARTITE
AFFILIATION
NETWORK
OF
EDITORS
AND
ARTICLES
CONSISTING
ONLY
OF
EDGES
FROM
EDITORS
TO
THE
ARTICLES
THEY
VE
EDITED
PAIRS
OF
WIKIPEDIA
EDITORS
WHO
HAVE
COMMUNICATED
ARE
SIGNIFICANTLY
MORE
SIMILAR
IN
THEIR
BEHAVIOR
THAN
PAIRS
OF
WIKIPEDIA
EDITORS
WHO
HAVE
NOT
COMMUNICATED
SO
WE
HAVE
A
CASE
WHERE
HOMOPHILY
IS
CLEARLY
PRESENT
THEREFORE
WE
ARE
SET
UP
TO
ADDRESS
THE
QUESTION
OF
SELEC
TION
AND
SOCIAL
INFLUENCE
IS
THE
HOMOPHILY
ARISING
BECAUSE
EDITORS
ARE
FORMING
CONNECTIONS
WITH
THOSE
WHO
HAVE
EDITED
THE
SAME
ARTICLES
THEY
HAVE
SELECTION
OR
IS
IT
BECAUSE
EDITORS
ARE
LED
TO
THE
ARTICLES
OF
THOSE
THEY
TALK
TO
SOCIAL
INFLUENCE
TECHNICAL
REASONS
A
MINOR
VARIATION
ON
THIS
SIMPLE
SIMILARITY
MEASURE
IS
USED
FOR
THE
RESULTS
THAT
FOLLOW
HOWEVER
SINCE
THIS
VARIATION
IS
MORE
COMPLICATED
TO
DESCRIBE
AND
THE
DIFFERENCES
ARE
NOT
SIGNIFICANT
FOR
OUR
PURPOSES
WE
CAN
THINK
OF
SIMILARITY
AS
CONSISTING
OF
THE
NUMERICAL
MEASURE
JUST
DEFINED
FIGURE
THE
AVERAGE
SIMILARITY
OF
TWO
EDITORS
ON
WIKIPEDIA
RELATIVE
TO
THE
TIME
AT
WHICH
THEY
FIRST
COMMUNICATED
TIME
ON
THE
X
AXIS
IS
MEASURED
IN
DISCRETE
UNITS
WHERE
EACH
UNIT
CORRESPONDS
TO
A
SINGLE
WIKIPEDIA
ACTION
TAKEN
BY
EITHER
OF
THE
TWO
EDITORS
THE
CURVE
INCREASES
BOTH
BEFORE
AND
AFTER
THE
FIRST
CONTACT
AT
TIME
INDICATING
THAT
BOTH
SELECTION
AND
SOCIAL
INFLUENCE
PLAY
A
ROLE
THE
INCREASE
IN
SIMILARITY
IS
STEEPEST
JUST
BEFORE
TIME
BECAUSE
EVERY
ACTION
ON
WIKIPEDIA
IS
RECORDED
AND
TIME
STAMPED
IT
IS
NOT
HARD
TO
GET
AN
INITIAL
PICTURE
OF
THIS
INTERPLAY
USING
THE
FOLLOWING
METHOD
FOR
EACH
PAIR
OF
EDITORS
A
AND
B
WHO
HAVE
EVER
COMMUNICATED
RECORD
THEIR
SIMILARITY
OVER
TIME
WHERE
TIME
HERE
MOVES
IN
DISCRETE
UNITS
ADVANCING
BY
ONE
TICK
WHENEVER
EITHER
A
OR
B
PERFORMS
AN
ACTION
ON
WIKIPEDIA
EDITING
AN
ARTICLE
OR
COMMUNICATING
WITH
ANOTHER
EDITOR
NEXT
DECLARE
TIME
FOR
THE
PAIR
A
B
TO
BE
THE
POINT
AT
WHICH
THEY
FIRST
COMMUNICATED
THIS
RESULTS
IN
MANY
CURVES
SHOWING
SIMILARITY
AS
A
FUNCTION
OF
TIME
ONE
FOR
EACH
PAIR
OF
EDITORS
WHO
EVER
COMMUNICATED
AND
EACH
CURVE
SHIFTED
SO
THAT
TIME
IS
MEASURED
FOR
EACH
ONE
RELATIVE
TO
THE
MOMENT
OF
FIRST
COMMUNICATION
AVERAGING
ALL
THESE
CURVES
YIELDS
THE
SINGLE
PLOT
IN
FIGURE
IT
SHOWS
THE
AVERAGE
LEVEL
OF
SIMILARITY
RELATIVE
TO
THE
TIME
OF
FIRST
INTERACTION
OVER
ALL
PAIRS
OF
EDITORS
WHO
HAVE
EVER
INTERACTED
ON
WIKIPEDIA
THERE
ARE
A
NUMBER
OF
THINGS
TO
NOTICE
ABOUT
THIS
PLOT
FIRST
SIMILARITY
IS
CLEARLY
INCREAS
ING
BOTH
BEFORE
AND
AFTER
THE
MOMENT
OF
FIRST
INTERACTION
INDICATING
THAT
BOTH
SELECTION
AND
SOCIAL
INFLUENCE
ARE
AT
WORK
HOWEVER
THE
THE
CURVE
IS
NOT
SYMMETRIC
AROUND
TIME
THE
PERIOD
OF
FASTEST
INCREASE
IN
SIMILARITY
IS
CLEARLY
OCCURRING
BEFORE
INDICATING
A
PARTICULAR
ROLE
FOR
SELECTION
THERE
IS
AN
ESPECIALLY
RAPID
RISE
IN
SIMILARITY
ON
AVERAGE
JUST
BEFORE
TWO
EDITORS
MEET
ALSO
NOTE
THAT
THE
LEVELS
OF
SIMILARITY
DEPICTED
IN
THE
PLOT
ARE
MUCH
HIGHER
THAN
FOR
PAIRS
OF
EDITORS
WHO
HAVE
NOT
INTERACTED
THE
DASHED
BLUE
LINE
AT
THE
BOTTOM
OF
THE
PLOT
SHOWS
SIMILARITY
OVER
TIME
FOR
A
RANDOM
SAMPLE
OF
NON
INTERACTING
PAIRS
IT
IS
BOTH
FAR
LOWER
AND
ALSO
ESSENTIALLY
CONSTANT
AS
TIME
MOVES
FORWARD
AT
A
HIGHER
LEVEL
THE
PLOT
IN
FIGURE
ONCE
AGAIN
ILLUSTRATES
THE
TRADE
OFFS
INVOLVED
IN
WORKING
WITH
LARGE
SCALE
ON
LINE
DATA
ON
THE
ONE
HAND
THE
CURVE
IS
REMARKABLY
SMOOTH
BECAUSE
SO
MANY
PAIRS
ARE
BEING
AVERAGED
AND
SO
DIFFERENCES
BETWEEN
SELECTION
AND
SOCIAL
INFLUENCE
SHOW
UP
THAT
ARE
GENUINE
BUT
TOO
SUBTLE
TO
BE
NOTICEABLE
AT
SMALLER
SCALES
ON
THE
OTHER
HAND
THE
EFFECT
BEING
OBSERVED
IS
AN
AGGREGATE
ONE
IT
IS
THE
AVERAGE
OF
THE
INTERACTION
HISTORIES
OF
MANY
DIFFERENT
PAIRS
OF
INDIVIDUALS
AND
IT
DOES
NOT
PROVIDE
MORE
DETAILED
INSIGHT
INTO
THE
EXPERIENCE
OF
ANY
ONE
PARTICULAR
PAIR
A
GOAL
FOR
FURTHER
RESEARCH
IS
CLEARLY
TO
FIND
WAYS
OF
FORMULATING
MORE
COMPLEX
NUANCED
QUESTIONS
THAT
CAN
STILL
BE
MEANINGFULLY
ADDRESSED
ON
LARGE
DATASETS
OVERALL
THEN
THESE
ANALYSES
REPRESENT
EARLY
ATTEMPTS
TO
QUANTIFY
SOME
OF
THE
BASIC
MECHANISMS
OF
LINK
FORMATION
AT
A
VERY
LARGE
SCALE
USING
ON
LINE
DATA
WHILE
THEY
ARE
PROMISING
IN
REVEALING
THAT
THE
BASIC
PATTERNS
INDEED
SHOW
UP
STRONGLY
IN
THE
DATA
THEY
RAISE
MANY
FURTHER
QUESTIONS
IN
PARTICULAR
IT
NATURAL
TO
ASK
WHETHER
THE
GENERAL
SHAPES
OF
THE
CURVES
IN
FIGURES
ARE
SIMILAR
ACROSS
DIFFERENT
DOMAINS
INCLUDING
DOMAINS
THAT
ARE
LESS
TECHNOLOGICALLY
MEDIATED
AND
WHETHER
THESE
CURVE
SHAPES
CAN
BE
EXPLAINED
AT
A
SIMPLER
LEVEL
BY
MORE
BASIC
UNDERLYING
SOCIAL
MECHANISMS
A
SPATIAL
MODEL
OF
SEGREGATION
ONE
OF
THE
MOST
READILY
PERCEIVED
EFFECTS
OF
HOMOPHILY
IS
IN
THE
FORMATION
OF
ETHNICALLY
AND
RACIALLY
HOMOGENEOUS
NEIGHBORHOODS
IN
CITIES
TRAVELING
THROUGH
A
METROPOLITAN
AREA
ONE
FINDS
THAT
HOMOPHILY
PRODUCES
A
NATURAL
SPATIAL
SIGNATURE
PEOPLE
LIVE
NEAR
OTHERS
LIKE
THEM
AND
AS
A
CONSEQUENCE
THEY
OPEN
SHOPS
RESTAURANTS
AND
OTHER
BUSINESSES
ORIENTED
TOWARD
THE
POPULATIONS
OF
THEIR
RESPECTIVE
NEIGHBORHOODS
THE
EFFECT
IS
ALSO
STRIKING
WHEN
SUPERIMPOSED
ON
A
MAP
AS
FIGURE
BY
M
OBIUS
AND
ROSENBLAT
ILLUSTRATES
THEIR
IMAGES
DEPICT
THE
MAKE
SURE
THAT
THESE
ARE
EDITORS
WITH
SIGNIFICANT
HISTORIES
ON
WIKIPEDIA
THIS
PLOT
IS
CONSTRUCTED
USING
ONLY
PAIRS
OF
EDITORS
WHO
EACH
HAD
AT
LEAST
ACTIONS
BOTH
BEFORE
AND
AFTER
THEIR
FIRST
INTERACTION
WITH
EACH
OTHER
THE
INDIVIDUAL
HISTORIES
BEING
AVERAGED
TOOK
PLACE
AT
MANY
DISTINCT
POINTS
IN
WIKIPEDIA
HISTORY
IT
IS
ALSO
NATURAL
TO
ASK
WHETHER
THE
AGGREGATE
EFFECTS
OPERATED
DIFFERENTLY
IN
DIFFERENT
PHASES
OF
THIS
HISTORY
THIS
IS
A
NATURAL
QUESTION
FOR
FURTHER
INVESTIGATION
BUT
INITIAL
TESTS
BASED
ON
STUDYING
THESE
TYPES
OF
PROPERTIES
ON
WIKIPEDIA
DATASETS
BUILT
FROM
DIFFERENT
PERIODS
SHOW
THAT
THE
MAIN
EFFECTS
HAVE
REMAINED
RELATIVELY
STABLE
OVER
TIME
A
CHICAGO
B
CHICAGO
FIGURE
THE
TENDENCY
OF
PEOPLE
TO
LIVE
IN
RACIALLY
HOMOGENEOUS
NEIGHBORHOODS
PRODUCES
SPATIAL
PATTERNS
OF
SEGREGATION
THAT
ARE
APPARENT
BOTH
IN
EVERYDAY
LIFE
AND
WHEN
SUPERIM
POSED
ON
A
MAP
AS
HERE
IN
THESE
MAPS
OF
CHICAGO
FROM
AND
IN
BLOCKS
COLORED
YELLOW
AND
ORANGE
THE
PERCENTAGE
OF
AFRICAN
AMERICANS
IS
BELOW
WHILE
IN
BLOCKS
COLORED
BROWN
AND
BLACK
THE
PERCENTAGE
IS
ABOVE
PERCENTAGE
OF
AFRICAN
AMERICANS
PER
CITY
BLOCK
IN
CHICAGO
FOR
THE
YEARS
AND
IN
BLOCKS
COLORED
YELLOW
AND
ORANGE
THE
PERCENTAGE
IS
BELOW
WHILE
IN
BLOCKS
COLORED
BROWN
AND
BLACK
THE
PERCENTAGE
IS
ABOVE
THIS
PAIR
OF
FIGURES
ALSO
SHOWS
HOW
CONCENTRATIONS
OF
DIFFERENT
GROUPS
CAN
INTENSIFY
OVER
TIME
EMPHASIZING
THAT
THIS
IS
A
PROCESS
WITH
A
DYNAMIC
ASPECT
USING
THE
PRINCIPLES
WE
VE
BEEN
CONSIDERING
WE
NOW
DISCUSS
HOW
SIMPLE
MECHANSISMS
BASED
ON
SIMILARITY
AND
SELECTION
CAN
PROVIDE
INSIGHT
INTO
THE
OBSERVED
PATTERNS
AND
THEIR
DYNAMICS
THE
SCHELLING
MODEL
A
FAMOUS
MODEL
DUE
TO
THOMAS
SCHELLING
SHOWS
HOW
GLOBAL
PATTERNS
OF
SPATIAL
SEGREGATION
CAN
ARISE
FROM
THE
EFFECT
OF
HOMOPHILY
OPERATING
AT
A
LOCAL
LEVEL
THERE
ARE
MANY
FACTORS
THAT
CONTRIBUTE
TO
SEGREGATION
IN
REAL
LIFE
BUT
SCHELLING
MODEL
FOCUSES
ON
AN
INTENTIONALLY
SIMPLIFIED
MECHANISM
TO
ILLUSTRATE
HOW
THE
FORCES
LEADING
TO
SEGREGATION
ARE
REMARKABLY
ROBUST
THEY
CAN
OPERATE
EVEN
WHEN
NO
ONE
INDIVIDUAL
EXPLICITLY
WANTS
A
SEGREGATED
OUTCOME
A
AGENTS
OCCUPYING
CELLS
ON
A
GRID
B
NEIGHBOR
RELATIONS
AS
A
GRAPH
FIGURE
IN
SCHELLING
SEGREGATION
MODEL
AGENTS
OF
TWO
DIFFERENT
TYPES
X
AND
O
OCCUPY
CELLS
ON
A
GRID
THE
NEIGHBOR
RELATIONSHIPS
AMONG
THE
CELLS
CAN
BE
REPRESENTED
VERY
SIMPLY
AS
A
GRAPH
AGENTS
CARE
ABOUT
WHETHER
THEY
HAVE
AT
LEAST
SOME
NEIGHBORS
OF
THE
SAME
TYPE
THE
GENERAL
FORMULATION
OF
THE
MODEL
IS
AS
FOLLOWS
WE
ASSUME
THAT
THERE
IS
A
POPULATION
OF
INDIVIDUALS
WHOM
WE
LL
CALL
AGENTS
EACH
AGENT
IS
OF
TYPE
X
OR
TYPE
O
WE
THINK
OF
THE
TWO
TYPES
AS
REPRESENTING
SOME
IMMUTABLE
CHARACTERISTIC
THAT
CAN
SERVE
AS
THE
BASIS
FOR
HOMOPHILY
FOR
EXAMPLE
RACE
ETHNICITY
COUNTRY
OF
ORIGIN
OR
NATIVE
LANGUAGE
THE
AGENTS
RESIDE
IN
THE
CELLS
OF
A
GRID
INTENDED
AS
A
STYLIZED
MODEL
OF
THE
TWO
DIMENSIONAL
GEOGRAPHY
OF
A
CITY
AS
ILLUSTRATED
IN
FIGURE
A
WE
WILL
ASSUME
THAT
SOME
CELLS
OF
THE
GRID
CONTAIN
AGENTS
WHILE
OTHERS
ARE
UNPOPULATED
A
CELL
NEIGHBORS
ARE
THE
CELLS
THAT
TOUCH
IT
INCLUDING
DIAGONAL
CONTACT
THUS
A
CELL
THAT
IS
NOT
ON
THE
BOUNDARY
OF
THE
GRID
HAS
EIGHT
NEIGHBORS
WE
CAN
EQUIVALENTLY
THINK
OF
THE
NEIGHBOR
RELATIONSHIPS
AS
DEFINING
A
GRAPH
THE
CELLS
ARE
THE
NODES
AND
WE
PUT
AN
EDGE
BETWEEN
TWO
CELLS
THAT
ARE
NEIGHBORS
ON
THE
GRID
IN
THIS
VIEW
THE
AGENTS
THUS
OCCUPY
THE
NODES
OF
A
GRAPH
THAT
ARE
ARRANGED
IN
THIS
GRID
LIKE
PATTERN
AS
SHOWN
IN
FIGURE
B
FOR
EASE
OF
VISUALIZATION
HOWEVER
WE
WILL
CONTINUE
TO
DRAW
THINGS
USING
A
GEOMETRIC
GRID
RATHER
THAN
A
GRAPH
THE
FUNDAMENTAL
CONSTRAINT
DRIVING
THE
MODEL
IS
THAT
EACH
AGENT
WANTS
TO
HAVE
AT
LEAST
SOME
OTHER
AGENTS
OF
ITS
OWN
TYPE
AS
NEIGHBORS
WE
WILL
ASSUME
THAT
THERE
IS
A
THRESHOLD
T
COMMON
TO
ALL
AGENTS
IF
AN
AGENT
DISCOVERS
THAT
FEWER
THAN
T
OF
ITS
NEIGHBORS
ARE
OF
THE
SAME
TYPE
AS
ITSELF
THEN
IT
HAS
AN
INTEREST
IN
MOVING
TO
A
NEW
CELL
WE
WILL
CALL
SUCH
AN
AGENT
UNSATISFIED
WITH
ITS
CURRENT
LOCATION
FOR
EXAMPLE
IN
FIGURE
A
WE
INDICATE
WITH
AN
ASTERISK
ALL
THE
AGENTS
THAT
ARE
UNSATISFIED
IN
THE
ARRANGEMENT
FROM
FIGURE
A
WHEN
THE
THRESHOLD
T
IS
EQUAL
TO
IN
FIGURE
A
WE
HAVE
ALSO
ADDED
A
NUMBER
AFTER
EACH
AGENT
THIS
IS
SIMPLY
TO
PROVIDE
EACH
WITH
A
UNIQUE
NAME
THE
KEY
DISTINCTION
IS
STILL
WHETHER
EACH
AGENT
IS
OF
TYPE
X
OR
TYPE
O
A
AN
INITIAL
CONFIGURATION
O6
O5
B
AFTER
ONE
ROUND
OF
MOVEMENT
FIGURE
AFTER
ARRANGING
AGENTS
IN
CELLS
OF
THE
GRID
WE
FIRST
DETERMINE
WHICH
AGENTS
ARE
UNSATISFIED
WITH
FEWER
THAN
T
OTHER
AGENTS
OF
THE
SAME
TYPE
AS
NEIGHBORS
IN
ONE
ROUND
EACH
OF
THESE
AGENTS
MOVES
TO
A
CELL
WHERE
THEY
WILL
BE
SATISFIED
THIS
MAY
CAUSE
OTHER
AGENTS
TO
BECOME
UNSATISFIED
IN
WHICH
CASE
A
NEW
ROUND
OF
MOVEMENT
BEGINS
THE
DYNAMICS
OF
MOVEMENT
THUS
FAR
WE
HAVE
SIMPLY
SPECIFIED
A
SET
OF
AGENTS
THAT
WANT
TO
MOVE
GIVEN
AN
UNDERLYING
THRESHOLD
WE
NOW
DISCUSS
HOW
THIS
GIVES
THE
MODEL
ITS
DYNAMIC
ASPECT
AGENTS
MOVE
IN
A
SEQUENCE
OF
ROUNDS
IN
EACH
ROUND
WE
CONSIDER
THE
UNSATISFIED
AGENTS
IN
SOME
ORDER
AND
FOR
EACH
ONE
IN
TURN
WE
HAVE
IT
MOVE
TO
AN
UNOCCUPIED
CELL
WHERE
IT
WILL
BE
SATISFIED
AFTER
THIS
THE
ROUND
OF
MOVEMENT
HAS
COME
TO
AN
END
REPRESENTING
A
FIXED
TIME
PERIOD
DURING
WHICH
UNSATISFIED
AGENTS
HAVE
CHANGED
WHERE
THEY
LIVE
THESE
NEW
LOCATIONS
MAY
CAUSE
DIFFERENT
AGENTS
TO
BE
UNSATISFIED
AND
THIS
LEADS
TO
A
NEW
ROUND
OF
MOVEMENT
IN
THE
LITERATURE
ON
THIS
MODEL
THERE
ARE
NUMEROUS
VARIATIONS
IN
THE
SPECIFIC
DETAILS
OF
HOW
THE
MOVEMENT
OF
AGENTS
WITHIN
A
ROUND
IS
HANDLED
FOR
EXAMPLE
THE
AGENTS
CAN
BE
SCHEDULED
TO
MOVE
IN
A
RANDOM
ORDER
OR
IN
AN
ORDER
THAT
SWEEPS
DOWNWARD
ALONG
ROWS
OF
THE
GRID
THEY
CAN
MOVE
TO
THE
NEAREST
LOCATION
THAT
WILL
MAKE
THEM
SATISFIED
OR
TO
A
RANDOM
ONE
THERE
ALSO
NEEDS
TO
BE
A
WAY
OF
HANDLING
SITUATIONS
IN
WHICH
AN
AGENT
IS
SCHEDULED
TO
MOVE
AND
THERE
IS
NO
CELL
THAT
WILL
MAKE
IT
SATISIFIED
IN
SUCH
A
CASE
THE
AGENT
CAN
BE
LEFT
WHERE
IT
IS
OR
MOVED
TO
A
COMPLETELY
RANDOM
CELL
RESEARCH
HAS
FOUND
THAT
THE
QUALITATIVE
RESULTS
OF
THE
MODEL
TEND
TO
BE
QUITE
SIMILAR
HOWEVER
THESE
ISSUES
ARE
RESOLVED
AND
DIFFERENT
INVESTIGATIONS
OF
THE
MODEL
HAVE
TENDED
TO
RESOLVE
THEM
DIFFERENTLY
FOR
EXAMPLE
FIGURE
B
SHOWS
THE
RESULTS
OF
ONE
ROUND
OF
MOVEMENT
STARTING
FROM
THE
ARRANGEMENT
IN
FIGURE
A
WHEN
THE
THRESHOLD
T
IS
UNSATISFIED
AGENTS
ARE
SCHEDULED
TO
MOVE
BY
CONSIDERING
THEM
ONE
ROW
AT
A
TIME
WORKING
DOWNWARD
THROUGH
THE
GRID
AND
EACH
AGENT
MOVES
TO
THE
NEAREST
CELL
THAT
WILL
MAKE
IT
SATISFIED
THE
UNIQUE
NAME
OF
EACH
AGENT
IN
THE
FIGURE
ALLOWS
US
TO
SEE
WHERE
IT
HAS
MOVED
IN
FIGURE
B
RELATIVE
TO
THE
INITIAL
STATE
IN
FIGURE
A
NOTICE
THAT
IN
SOME
CONCRETE
RESPECTS
THE
PATTERN
OF
AGENTS
HAS
BECOME
MORE
SEGREGATED
AFTER
THIS
ROUND
OF
MOVEMENT
FOR
EXAMPLE
IN
FIGURE
A
THERE
IS
ONLY
A
SINGLE
AGENT
WITH
NO
NEIGHBORS
OF
THE
OPPOSITE
TYPE
AFTER
THIS
FIRST
ROUND
OF
MOVEMENT
HOWEVER
THERE
ARE
SIX
AGENTS
IN
FIGURE
B
WITH
NO
NEIGHBORS
OF
THE
OPPOSITE
TYPE
AS
WE
WILL
SEE
THIS
INCREASING
LEVEL
OF
SEGREGATION
IS
THE
KEY
BEHAVIOR
TO
EMERGE
FROM
THE
MODEL
LARGER
EXAMPLES
SMALL
EXAMPLES
OF
THE
TYPE
IN
FIGURES
AND
ARE
HELPFUL
IN
WORKING
THROUGH
THE
DETAILS
OF
THE
MODEL
BY
HAND
BUT
AT
SUCH
SMALL
SCALES
IT
IS
DIFFICULT
TO
SEE
THE
KINDS
OF
TYPICAL
PATTERNS
THAT
ARISE
FOR
THIS
COMPUTER
SIMULATION
IS
VERY
USEFUL
THERE
ARE
MANY
ON
LINE
COMPUTER
PROGRAMS
THAT
MAKE
IT
POSSIBLE
TO
SIMULATE
THE
SCHELLING
MODEL
AS
WITH
THE
PUBLISHED
LITERATURE
ON
THE
MODEL
THEY
ALL
TEND
TO
DIFFER
SLIGHTLY
FROM
EACH
OTHER
IN
THEIR
SPECIFICS
HERE
WE
DISCUSS
SOME
EXAMPLES
FROM
A
SIMULATION
WRITTEN
BY
SEAN
LUKE
WHICH
IS
LIKE
THE
VERSION
OF
THE
MODEL
WE
HAVE
DISCUSSED
THUS
FAR
EXCEPT
THAT
UNSATISFIED
AGENTS
MOVE
TO
A
RANDOM
LOCATION
IN
FIGURE
WE
SHOW
THE
RESULTS
OF
SIMULATING
THE
MODEL
ON
A
GRID
WITH
ROWS
AND
A
A
SIMULATION
WITH
THRESHOLD
B
ANOTHER
SIMULATION
WITH
THRESHOLD
FIGURE
TWO
RUNS
OF
A
SIMULATION
OF
THE
SCHELLING
MODEL
WITH
A
THRESHOLD
T
OF
ON
A
BY
GRID
WITH
AGENTS
OF
EACH
TYPE
EACH
CELL
OF
THE
GRID
IS
COLORED
RED
IF
IT
IS
OCCUPIED
BY
AN
AGENT
OF
THE
FIRST
TYPE
BLUE
IF
IT
IS
OCCUPIED
BY
AN
AGENT
OF
THE
SECOND
TYPE
AND
BLACK
IF
IT
IS
EMPTY
NOT
OCCUPIED
BY
ANY
AGENT
COLUMNS
AGENTS
OF
EACH
TYPE
AND
EMPTY
CELLS
THE
THRESHOLD
T
IS
EQUAL
TO
AS
IN
OUR
EARLIER
EXAMPLES
THE
TWO
IMAGES
DEPICT
THE
RESULTS
OF
TWO
DIFFERENT
RUNS
OF
THE
SIMULATION
WITH
DIFFERENT
RANDOM
STARTING
PATTERNS
OF
AGENTS
IN
EACH
CASE
THE
SIMULATION
REACHED
A
POINT
SHOWN
IN
THE
FIGURES
AT
WHICH
ALL
AGENTS
WERE
SATISFIED
AFTER
ROUGHLY
ROUNDS
OF
MOVEMENT
BECAUSE
OF
THE
DIFFERENT
RANDOM
STARTS
THE
FINAL
ARRANGEMENT
OF
AGENTS
IS
DIFFERENT
IN
THE
TWO
CASES
BUT
THE
QUALITATIVE
SIMILARITIES
REFLECT
THE
FUNDAMENTAL
CONSEQUENCES
OF
THE
MODEL
BY
SEEKING
OUT
LOCATIONS
NEAR
OTHER
AGENTS
OF
THE
SAME
TYPE
THE
MODEL
PRODUCES
LARGE
HOMOGENEOUS
REGIONS
INTERLOCKING
WITH
EACH
OTHER
AS
THEY
STRETCH
ACROSS
THE
GRID
IN
THE
MIDST
OF
THESE
REGIONS
ARE
LARGE
NUMBERS
OF
AGENTS
WHO
ARE
SURROUNDED
ON
ALL
SIDES
BY
OTHER
AGENTS
OF
THE
SAME
TYPE
AND
IN
FACT
AT
SOME
DISTANCE
FROM
THE
NEAREST
AGENT
OF
THE
OPPOSITE
TYPE
THE
GEOMETRIC
PATTERN
HAS
BECOME
SEGREGATED
MUCH
AS
IN
THE
MAPS
OF
CHICAGO
FROM
FIGURE
WITH
WHICH
WE
BEGAN
THE
SECTION
INTERPRETATIONS
OF
THE
MODEL
WE
VE
NOW
SEEN
HOW
THE
MODEL
WORKS
WHAT
IT
LOOKS
LIKE
AT
RELATIVELY
LARGE
SCALES
AND
HOW
IT
PRODUCES
SPATIALLY
SEGREGATED
OUTCOMES
BUT
WHAT
BROADER
INSIGHTS
INTO
HOMOPHILY
AND
SEGREGATION
DOES
IT
SUGGEST
THE
FIRST
AND
MOST
BASIC
ONE
IS
THAT
SPATIAL
SEGREGATION
IS
TAKING
PLACE
EVEN
THOUGH
NO
X
X
O
O
X
X
X
X
O
O
X
X
O
O
X
X
O
O
O
O
X
X
O
O
X
X
O
O
X
X
X
X
O
O
X
X
FIGURE
WITH
A
THRESHOLD
OF
IT
IS
POSSIBLE
TO
ARRANGE
AGENTS
IN
AN
INTEGRATED
PATTERN
ALL
AGENTS
ARE
SATISFIED
AND
EVERYONE
WHO
IS
NOT
ON
THE
BOUNDARY
ON
THE
GRID
HAS
AN
EQUAL
NUMBER
OF
NEIGHBORS
OF
EACH
TYPE
INDIVIDUAL
AGENT
IS
ACTIVELY
SEEKING
IT
STICKING
TO
OUR
FOCUS
ON
A
THRESHOLD
T
OF
WE
SEE
THAT
ALTHOUGH
AGENTS
WANT
TO
BE
NEAR
OTHERS
LIKE
THEM
THEIR
REQUIREMENTS
ARE
NOT
PARTICULARLY
DRACONIAN
FOR
EXAMPLE
AN
AGENT
WOULD
BE
PERFECTLY
HAPPY
TO
BE
IN
THE
MINORITY
AMONG
ITS
NEIGHBORS
WITH
FIVE
NEIGHBORS
OF
THE
OPPOSITE
TYPE
AND
THREE
OF
ITS
OWN
TYPE
NOR
ARE
THE
REQUIREMENTS
GLOBALLY
INCOMPATIBLE
WITH
COMPLETE
INTEGRATION
OF
THE
POPULATION
BY
ARRANGING
AGENTS
IN
A
CHECKERBOARD
PATTERN
AS
SHOWN
IN
FIGURE
WE
CAN
MAKE
EACH
AGENT
SATISFIED
AND
ALL
AGENTS
NOT
ON
THE
BOUNDARY
OF
THE
GRID
HAVE
EXACTLY
FOUR
NEIGHBORS
OF
EACH
TYPE
THIS
IS
A
PATTERN
THAT
WE
CAN
CONTINUE
ON
AS
LARGE
A
GRID
AS
WE
WANT
THUS
SEGREGATION
IS
NOT
HAPPENING
BECAUSE
WE
HAVE
SUBTLY
BUILT
IT
INTO
THE
MODEL
AGENTS
ARE
WILLING
TO
BE
IN
THE
MINORITY
AND
THEY
COULD
ALL
BE
SATISFIED
IF
WE
WERE
ONLY
ABLE
TO
CAREFULLY
ARRANGE
THEM
IN
AN
INTEGRATED
PATTERN
THE
PROBLEM
IS
THAT
FROM
A
RANDOM
START
IT
IS
VERY
HARD
FOR
THE
COLLECTION
OF
AGENTS
TO
FIND
SUCH
INTEGRATED
PATTERNS
MUCH
MORE
TYPICALLY
AGENTS
WILL
ATTACH
THEMSELVES
TO
CLUSTERS
OF
OTHERS
LIKE
THEMSELVES
AND
THESE
CLUSTERS
WILL
GROW
AS
OTHER
AGENTS
FOLLOW
SUIT
MOREOVER
THERE
IS
A
COMPOUNDING
EFFECT
AS
THE
ROUNDS
OF
MOVEMENT
UNFOLD
IN
WHICH
AGENTS
WHO
FALL
BELOW
THEIR
THRESHOLD
DEPART
FOR
MORE
HOMOGENEOUS
PARTS
OF
THE
GRID
CAUSING
PREVIOUSLY
SATISFIED
AGENTS
TO
FALL
BELOW
THEIR
THRESHOLDS
AND
MOVE
AS
WELL
AN
EFFECT
THAT
SCHELLING
DESCRIBES
AS
THE
PROGRESSIVE
UNRAVELING
OF
MORE
INTEGRATED
REGIONS
IN
THE
LONG
RUN
THIS
PROCESS
WILL
TEND
TO
CAUSE
SEGREGATED
REGIONS
TO
GROW
AT
THE
EXPENSE
OF
MORE
INTEGRATED
ONES
THE
OVERALL
EFFECT
IS
ONE
IN
WHICH
THE
LOCAL
PREFERENCES
OF
INDIVIDUAL
AGENTS
HAVE
PRODUCED
A
GLOBAL
PATTERN
THAT
NONE
OF
THEM
NECESSARILY
INTENDED
A
AFTER
STEPS
B
AFTER
STEPS
C
AFTER
STEPS
D
AFTER
STEPS
FIGURE
FOUR
INTERMEDIATE
POINTS
IN
A
SIMULATION
OF
THE
SCHELLING
MODEL
WITH
A
THRESHOLD
T
OF
ON
A
BY
GRID
WITH
AGENTS
OF
EACH
TYPE
AS
THE
ROUNDS
OF
MOVEMENT
PROGRESS
LARGE
HOMOGENEOUS
REGIONS
ON
THE
GRID
GROW
AT
THE
EXPENSE
OF
SMALLER
NARROWER
REGIONS
THIS
POINT
IS
ULTIMATELY
AT
THE
HEART
OF
THE
MODEL
ALTHOUGH
SEGREGATION
IN
REAL
LIFE
IS
AMPLIFIED
BY
A
GENUINE
DESIRE
WITHIN
SOME
FRACTION
OF
THE
POPULATION
TO
BELONG
TO
LARGE
CLUSTERS
OF
SIMILAR
PEOPLE
EITHER
TO
AVOID
PEOPLE
WHO
BELONG
TO
OTHER
GROUPS
OR
TO
ACQUIRE
A
CRITICAL
MASS
OF
MEMBERS
FROM
ONE
OWN
GROUP
WE
SEE
HERE
THAT
SUCH
FACTORS
ARE
NOT
NECESSARY
FOR
SEGREGATION
TO
OCCUR
THE
UNDERPINNINGS
OF
SEGREGATION
ARE
ALREADY
PRESENT
IN
A
SYSTEM
WHERE
INDIVIDUALS
SIMPLY
WANT
TO
AVOID
BEING
IN
TOO
EXTREME
A
MINORITY
IN
THEIR
OWN
LOCAL
AREA
THE
PROCESS
OPERATES
EVEN
MORE
POWERFULLY
WHEN
WE
RAISE
THE
THRESHOLD
T
IN
OUR
EXAMPLES
FROM
TO
EVEN
WITH
A
THRESHOLD
OF
NODES
ARE
WILLING
TO
HAVE
AN
EQUAL
NUMBER
OF
NEIGHBORS
OF
EACH
TYPE
AND
A
SLIGHTLY
MORE
ELABORATE
CHECKERBOARD
EXAMPLE
IN
THE
SPIRIT
OF
FIGURE
SHOWS
THAT
WITH
CAREFUL
PLACEMENT
THE
AGENTS
CAN
BE
ARRANGED
SO
THAT
ALL
ARE
SATISFIED
AND
MOST
STILL
HAVE
A
SIGNIFICANT
NUMBER
OF
NEIGHBORS
OF
THE
OPPOSITE
TYPE
BUT
NOW
NOT
ONLY
IS
AN
INTEGRATED
PATTERN
VERY
HARD
TO
REACH
FROM
A
RANDOM
STARTING
ARRANGEMENT
ANY
VESTIGES
OF
INTEGRATION
AMONG
THE
TWO
TYPES
TENDS
TO
COLLAPSE
COMPLETELY
OVER
TIME
AS
ONE
EXAMPLE
OF
THIS
FIGURE
SHOWS
FOUR
INTERMEDIATE
POINTS
IN
ONE
RUN
OF
A
SIMULATION
WITH
THRESHOLD
AND
OTHER
PROPERTIES
THE
SAME
AS
BEFORE
A
BY
GRID
WITH
AGENTS
OF
EACH
TYPE
AND
RANDOM
MOVEMENT
BY
UNSATISFIED
AGENTS
FIGURE
A
SHOWS
THAT
AFTER
ROUNDS
OF
MOVEMENT
WE
HAVE
AN
ARRANGEMENT
OF
AGENTS
THAT
ROUGHLY
RESEMBLES
WHAT
WE
SAW
WITH
A
LOWER
THRESHOLD
OF
HOWEVER
THIS
DOES
NOT
LAST
LONG
CRUCIALLY
THE
LONG
TENDRILS
WHERE
ONE
TYPE
INTERLOCKS
WITH
THE
OTHER
QUICKLY
WITHER
AND
RETRACT
LEAVING
THE
MORE
HOMOGENEOUS
REGIONS
SHOWN
AFTER
ROUNDS
IN
FIGURE
B
THIS
PULLING
BACK
CONTINUES
PASSING
THROUGH
A
PHASE
WITH
A
LARGE
AND
SMALL
REGION
OF
EACH
TYPE
AFTER
ROUNDS
FIGURE
C
EVENTUALLY
TO
A
POINT
WHERE
THERE
IS
ONLY
A
SINGLE
SIGNIFICANT
REGION
OF
EACH
TYPE
AFTER
ROUGHLY
ROUNDS
FIGURE
D
NOTE
THAT
THIS
IS
NOT
THE
END
OF
THE
PROCESS
SINCE
THERE
REMAIN
AGENTS
AROUND
THE
EDGES
STILL
LOOKING
FOR
PLACES
TO
MOVE
BUT
BY
THIS
POINT
THE
OVERALL
TWO
REGION
LAYOUT
HAS
BECOME
VERY
STABLE
FINALLY
WE
STRESS
THAT
THIS
FIGURE
CORRESPONDS
TO
JUST
A
SINGLE
RUN
OF
THE
SIMULATION
BUT
COMPUTATIONAL
EXPERIMENTS
SHOW
THAT
THE
SEQUENCE
OF
EVENTS
IT
DEPICTS
LEADING
TO
ALMOST
COMPLETE
SEPARATION
OF
THE
TWO
TYPES
IS
VERY
ROBUST
WHEN
THE
THRESHOLD
IS
THIS
HIGH
VIEWED
AT
A
STILL
MORE
GENERAL
LEVEL
THE
SCHELLING
MODEL
IS
AN
EXAMPLE
OF
HOW
CHARACTER
ISTICS
THAT
ARE
FIXED
AND
UNCHANGING
SUCH
AS
RACE
OR
ETHNICITY
CAN
BECOME
HIGHLY
CORRELATED
WITH
OTHER
CHARACTERISTICS
THAT
ARE
MUTABLE
IN
THIS
CASE
THE
MUTABLE
CHARACTERISTIC
IS
THE
DECISION
ABOUT
WHERE
TO
LIVE
WHICH
OVER
TIME
CONFORMS
TO
SIMILARITIES
IN
THE
AGENTS
IM
MUTABLE
TYPES
PRODUCING
SEGREGATION
BUT
THERE
ARE
OTHER
NON
SPATIAL
MANIFESTATION
OF
THE
SAME
EFFECT
IN
WHICH
BELIEFS
AND
OPINIONS
BECOME
CORRELATED
ACROSS
RACIAL
OR
ETHNIC
LINES
AND
FOR
SIMILAR
UNDERLYING
REASONS
AS
HOMOPHILY
DRAWS
PEOPLE
TOGETHER
ALONG
IMMUTABLE
CHARACTERISTICS
THERE
IS
A
NATURAL
TENDENCY
FOR
MUTABLE
CHARACTERISTICS
TO
CHANGE
IN
ACCOR
DANCE
WITH
THE
NETWORK
STRUCTURE
AS
A
FINAL
POINT
WE
NOTE
THAT
WHILE
THE
MODEL
IS
MATHEMATICALLY
PRECISE
AND
SELF
CONTAINED
THE
DISCUSSION
HAS
BEEN
CARRIED
OUT
IN
TERMS
OF
SIMULATIONS
AND
QUALITATIVE
OBSER
VATIONS
THIS
IS
BECAUSE
RIGOROUS
MATHEMATICAL
ANALYSIS
OF
THE
SCHELLING
MODEL
APPEARS
TO
BE
QUITE
DIFFICULT
AND
IS
LARGELY
AN
OPEN
RESEARCH
QUESTION
FOR
PARTIAL
PROGRESS
ON
ANALYZING
PROPERTIES
OF
THE
SCHELLING
MODEL
SEE
THE
WORK
OF
YOUNG
WHO
COMPARES
PROPERTIES
OF
DIFFERENT
ARRANGEMENTS
IN
WHICH
ALL
AGENTS
ARE
SATISFIED
M
OBIUS
AND
ROSENBLAT
WHO
PERFORM
A
PROBABILISTIC
ANALYSIS
AND
VINKOVI
C
AND
KIRMAN
WHO
DEVELOP
ANALOGIES
TO
MODELS
FOR
THE
MIXING
OF
TWO
LIQUIDS
AND
OTHER
PHYSICAL
PHENOMENA
EXERCISES
FIGURE
A
SOCIAL
NETWORK
WHERE
TRIADIC
CLOSURE
MAY
OCCUR
CONSIDER
THE
SOCIAL
NETWORK
REPRESENTED
IN
FIGURE
SUPPOSE
THAT
THIS
SOCIAL
NET
WORK
WAS
OBTAINED
BY
OBSERVING
A
GROUP
OF
PEOPLE
AT
A
PARTICULAR
POINT
IN
TIME
AND
RECORDING
ALL
THEIR
FRIENDSHIP
RELATIONS
NOW
SUPPOSE
THAT
WE
COME
BACK
AT
SOME
POINT
IN
THE
FUTURE
AND
OBSERVE
IT
AGAIN
ACCORDING
TO
THE
THEORIES
BASED
ON
EMPIRICAL
STUDIES
OF
TRIADIC
CLOSURE
IN
NETWORKS
WHICH
NEW
EDGE
IS
MOST
LIKELY
TO
BE
PRESENT
I
E
WHICH
PAIR
OF
NODES
WHO
DO
NOT
CURRENTLY
HAVE
AN
EDGE
CONNECTING
THEM
ARE
MOST
LIKELY
TO
BE
LINKED
BY
AN
EDGE
WHEN
WE
RETURN
TO
TAKE
THE
SECOND
OBSERVATION
ALSO
GIVE
A
BRIEF
EXPLANATION
FOR
YOUR
ANSWER
GIVEN
A
BIPARTITE
AFFILIATION
GRAPH
SHOWING
THE
MEMBERSHIP
OF
PEOPLE
IN
DIFFERENT
SOCIAL
FOCI
RESEARCHERS
SOMETIMES
CREATE
A
PROJECTED
GRAPH
ON
JUST
THE
PEOPLE
IN
WHICH
WE
JOIN
TWO
PEOPLE
WHEN
THEY
HAVE
A
FOCUS
IN
COMMON
A
DRAW
WHAT
SUCH
A
PROJECTED
GRAPH
WOULD
LOOK
LIKE
FOR
THE
EXAMPLE
OF
MEMBERSHIPS
ON
CORPORATE
BOARDS
OF
DIRECTORS
FROM
FIGURE
HERE
THE
NODES
WOULD
BE
THE
EXERCISES
SEVEN
PEOPLE
IN
THE
FIGURE
AND
THERE
WOULD
BE
AN
EDGE
JOINING
ANY
TWO
WHO
SERVE
ON
A
BOARD
OF
DIRECTORS
TOGETHER
B
GIVE
AN
EXAMPLE
OF
TWO
DIFFERENT
AFFILIATION
NETWORKS
ON
THE
SAME
SET
OF
PEOPLE
BUT
WITH
DIFFERENT
FOCI
SO
THAT
THE
PROJECTED
GRAPHS
FROM
THESE
TWO
DIFFERENT
AFFILIATION
NETWORKS
ARE
THE
SAME
THIS
SHOWS
HOW
INFORMATION
CAN
BE
LOST
WHEN
MOVING
FROM
THE
FULL
AFFILIATION
NETWORK
TO
JUST
THE
PROJECTED
GRAPH
ON
THE
SET
OF
PEOPLE
FIGURE
AN
AFFILIATION
NETWORK
ON
SIX
PEOPLE
LABELED
A
F
AND
THREE
FOCI
LABELED
X
Y
AND
Z
CONSIDER
THE
AFFILIATION
NETWORK
IN
FIGURE
WITH
SIX
PEOPLE
LABELED
A
F
AND
THREE
FOCI
LABELED
X
Y
AND
Z
A
DRAW
THE
DERIVED
NETWORK
ON
JUST
THE
SIX
PEOPLE
AS
IN
EXERCISE
JOINING
TWO
PEOPLE
WHEN
THEY
SHARE
A
FOCUS
B
IN
THE
RESULTING
NETWORK
ON
PEOPLE
CAN
YOU
IDENTIFY
A
SENSE
IN
WHICH
THE
TRIANGLE
ON
THE
NODES
A
C
AND
E
HAS
A
QUALITATIVELY
DIFFERENT
MEANING
THAN
THE
OTHER
TRIANGLES
THAT
APPEAR
IN
THE
NETWORK
EXPLAIN
FIGURE
A
GRAPH
ON
PEOPLE
ARISING
FROM
AN
UNOBSERVED
AFFILIATION
NETWORK
GIVEN
A
NETWORK
SHOWING
PAIRS
OF
PEOPLE
WHO
SHARE
ACTIVITIES
WE
CAN
TRY
TO
RECONSTRUCT
AN
AFFILIATION
NETWORK
CONSISTENT
WITH
THIS
DATA
FOR
EXAMPLE
SUPPOSE
THAT
YOU
ARE
TRYING
TO
INFER
THE
STRUCTURE
OF
A
BIPARTITE
AFFILIATION
NETWORK
AND
BY
INDIRECT
OBSERVATION
YOU
VE
OBTAINED
THE
PROJECTED
NETWORK
ON
JUST
THE
SET
OF
PEOPLE
CONSTRUCTED
AS
IN
EXERCISE
THERE
IS
AN
EDGE
JOINING
EACH
PAIR
OF
PEOPLE
WHO
SHARE
A
FOCUS
THIS
PROJECTED
NETWORK
IS
SHOWN
IN
FIGURE
A
DRAW
AN
AFFILIATION
NETWORK
INVOLVING
THESE
SIX
PEOPLE
TOGETHER
WITH
FOUR
FOCI
THAT
YOU
SHOULD
DEFINE
WHOSE
PROJECTED
NETWORK
IS
THE
GRAPH
SHOWN
IN
FIGURE
B
EXPLAIN
WHY
ANY
AFFILIATION
NETWORK
CAPABLE
OF
PRODUCING
THE
PROJECTED
NETWORK
IN
FIGURE
MUST
HAVE
AT
LEAST
FOUR
FOCI
CHAPTER
POSITIVE
AND
NEGATIVE
RELATIONSHIPS
IN
OUR
DISCUSSION
OF
NETWORKS
THUS
FAR
WE
HAVE
GENERALLY
VIEWED
THE
RELATIONSHIPS
CON
TAINED
IN
THESE
NETWORKS
AS
HAVING
POSITIVE
CONNOTATIONS
LINKS
HAVE
TYPICALLY
INDICATED
SUCH
THINGS
AS
FRIENDSHIP
COLLABORATION
SHARING
OF
INFORMATION
OR
MEMBERSHIP
IN
A
GROUP
THE
TERMINOLOGY
OF
ON
LINE
SOCIAL
NETWORKS
REFLECTS
A
LARGELY
SIMILAR
VIEW
THROUGH
ITS
EM
PHASIS
ON
THE
CONNECTIONS
ONE
FORMS
WITH
FRIENDS
FANS
FOLLOWERS
AND
SO
FORTH
BUT
IN
MOST
NETWORK
SETTINGS
THERE
ARE
ALSO
NEGATIVE
EFFECTS
AT
WORK
SOME
RELATIONS
ARE
FRIENDLY
BUT
OTHERS
ARE
ANTAGONISTIC
OR
HOSTILE
INTERACTIONS
BETWEEN
PEOPLE
OR
GROUPS
ARE
REGULARLY
BESET
BY
CONTROVERSY
DISAGREEMENT
AND
SOMETIMES
OUTRIGHT
CONFLICT
HOW
SHOULD
WE
REASON
ABOUT
THE
MIX
OF
POSITIVE
AND
NEGATIVE
RELATIONSHIPS
THAT
TAKE
PLACE
WITHIN
A
NETWORK
HERE
WE
DESCRIBE
A
RICH
PART
OF
SOCIAL
NETWORK
THEORY
THAT
INVOLVES
TAKING
A
NETWORK
AND
ANNOTATING
ITS
LINKS
I
E
ITS
EDGES
WITH
POSITIVE
AND
NEGATIVE
SIGNS
POSITIVE
LINKS
REPRESENT
FRIENDSHIP
WHILE
NEGATIVE
LINKS
REPRESENT
ANTAGONISM
AND
AN
IMPORTANT
PROBLEM
IN
THE
STUDY
OF
SOCIAL
NETWORKS
IS
TO
UNDERSTAND
THE
TENSION
BETWEEN
THESE
TWO
FORCES
THE
NOTION
OF
STRUCTURAL
BALANCE
THAT
WE
DISCUSS
IN
THIS
CHAPTER
IS
ONE
OF
THE
BASIC
FRAMEWORKS
FOR
DOING
THIS
IN
ADDITION
TO
INTRODUCING
SOME
OF
THE
BASICS
OF
STRUCTURAL
BALANCE
OUR
DISCUSSION
HERE
SERVES
A
SECOND
METHODOLOGICAL
PURPOSE
IT
ILLUSTRATES
A
NICE
CONNECTION
BETWEEN
LOCAL
AND
GLOBAL
NETWORK
PROPERTIES
A
RECURRING
ISSUE
IN
THE
ANALYSIS
OF
NETWORKED
SYSTEMS
IS
THE
WAY
IN
WHICH
LOCAL
EFFECTS
PHENOMENA
INVOLVING
ONLY
A
FEW
NODES
AT
A
TIME
CAN
HAVE
GLOBAL
CONSEQUENCES
THAT
ARE
OBSERVABLE
AT
THE
LEVEL
OF
THE
NETWORK
AS
A
WHOLE
STRUCTURAL
BALANCE
OFFERS
A
WAY
TO
CAPTURE
ONE
SUCH
RELATIONSHIP
IN
A
VERY
CLEAN
WAY
AND
BY
PURELY
MATHEMATICAL
ANALYSIS
WE
WILL
CONSIDER
A
SIMPLE
DEFINITION
ABSTRACTLY
AND
FIND
THAT
IT
INEVITABLY
LEADS
TO
CERTAIN
MACROSCOPIC
PROPERTIES
OF
THE
NETWORK
D
EASLEY
AND
J
KLEINBERG
NETWORKS
CROWDS
AND
MARKETS
REASONING
ABOUT
A
HIGHLY
CONNECTED
WORLD
CAMBRIDGE
UNIVERSITY
PRESS
DRAFT
VERSION
JUNE
STRUCTURAL
BALANCE
WE
FOCUS
HERE
ON
PERHAPS
THE
MOST
BASIC
MODEL
OF
POSITIVE
AND
NEGATIVE
RELATIONSHIPS
SINCE
IT
CAPTURES
THE
ESSENTIAL
IDEA
SUPPOSE
WE
HAVE
A
SOCIAL
NETWORK
ON
A
SET
OF
PEOPLE
IN
WHICH
EVERYONE
KNOWS
EVERYONE
ELSE
SO
WE
HAVE
AN
EDGE
JOINING
EACH
PAIR
OF
NODES
SUCH
A
NETWORK
IS
CALLED
A
CLIQUE
OR
A
COMPLETE
GRAPH
WE
THEN
LABEL
EACH
EDGE
WITH
EITHER
OR
A
LABEL
INDICATES
THAT
ITS
TWO
ENDPOINTS
ARE
FRIENDS
WHILE
A
LABEL
INDICATES
THAT
ITS
TWO
ENDPOINTS
ARE
ENEMIES
NOTE
THAT
SINCE
THERE
AN
EDGE
CONNECTING
EACH
PAIR
WE
ARE
ASSUMING
THAT
EACH
PAIR
OF
PEOPLE
ARE
EITHER
FRIENDS
OR
ENEMIES
NO
TWO
PEOPLE
ARE
INDIFFERENT
TO
ONE
ANOTHER
OR
UNAWARE
OF
EACH
OTHER
THUS
THE
MODEL
WE
RE
CONSIDERING
MAKES
THE
MOST
SENSE
FOR
A
GROUP
OF
PEOPLE
SMALL
ENOUGH
TO
HAVE
THIS
LEVEL
OF
MUTUAL
AWARENESS
E
G
A
CLASSROOM
A
SMALL
COMPANY
A
SPORTS
TEAM
A
FRATERNITY
OR
SORORITY
OR
FOR
A
SETTING
SUCH
AS
INTERNATIONAL
RELATIONS
IN
WHICH
THE
NODES
ARE
COUNTRIES
AND
EVERY
COUNTRY
HAS
AN
OFFICIAL
DIPLOMATIC
POSITION
TOWARD
EVERY
OTHER
THE
PRINCIPLES
UNDERLYING
STRUCTURAL
BALANCE
ARE
BASED
ON
THEORIES
IN
SOCIAL
PSYCHOLOGY
DATING
BACK
TO
THE
WORK
OF
HEIDER
IN
THE
AND
GENERALIZED
AND
EXTENDED
TO
THE
LANGUAGE
OF
GRAPHS
BEGINNING
WITH
THE
WORK
OF
CARTWRIGHT
AND
HARARY
IN
THE
THE
CRUCIAL
IDEA
IS
THE
FOLLOWING
IF
WE
LOOK
AT
ANY
TWO
PEOPLE
IN
THE
GROUP
IN
ISOLATION
THE
EDGE
BETWEEN
THEM
CAN
BE
LABELED
OR
THAT
IS
THEY
ARE
EITHER
FRIENDS
OR
ENEMIES
BUT
WHEN
WE
LOOK
AT
SETS
OF
THREE
PEOPLE
AT
A
TIME
CERTAIN
CONFIGURATIONS
OF
AND
ARE
SOCIALLY
AND
PSYCHOLOGICALLY
MORE
PLAUSIBLE
THAN
OTHERS
IN
PARTICULAR
THERE
ARE
FOUR
DISTINCT
WAYS
UP
TO
SYMMETRY
TO
LABEL
THE
THREE
EDGES
AMONG
THREE
PEOPLE
WITH
AND
SEE
FIGURE
WE
CAN
DISTINGUISH
AMONG
THESE
FOUR
POSSIBILITIES
AS
FOLLOWS
GIVEN
A
SET
OF
PEOPLE
A
B
AND
C
HAVING
THREE
PLUSES
AMONG
THEM
AS
IN
FIGURE
A
IS
A
VERY
NATURAL
SITUATION
IT
CORRESPONDS
TO
THREE
PEOPLE
WHO
ARE
MUTUAL
FRIENDS
HAVING
A
SINGLE
PLUS
AND
TWO
MINUSES
IN
THE
RELATIONS
AMONG
THE
THERE
PEOPLE
IS
ALSO
VERY
NATURAL
IT
MEANS
THAT
TWO
OF
THE
THREE
ARE
FRIENDS
AND
THEY
HAVE
A
MUTUAL
ENEMY
IN
THE
THIRD
SEE
FIGURE
C
THE
OTHER
TWO
POSSIBLE
LABELINGS
OF
THE
TRIANGLE
ON
A
B
AND
C
INTRODUCE
SOME
AMOUNT
OF
PSYCHOLOGICAL
STRESS
OR
INSTABILITY
INTO
THE
RELATIONSHIPS
A
TRIANGLE
WITH
TWO
PLUSES
AND
ONE
MINUS
CORRESPONDS
AS
IN
FIGURE
B
TO
A
PERSON
A
WHO
IS
FRIENDS
WITH
EACH
OF
B
AND
C
BUT
B
AND
C
DON
T
GET
ALONG
WITH
EACH
OTHER
IN
THIS
TYPE
OF
SITUATION
THERE
WOULD
BE
IMPLICIT
FORCES
PUSHING
A
TO
TRY
TO
GET
B
AND
C
TO
BECOME
IN
SECTION
WE
WILL
CONSIDER
THE
MORE
GENERAL
SETTING
IN
WHICH
NOT
EVERY
PAIR
OF
NODES
IS
NECESSARILY
CONNECTED
BY
AN
EDGE
A
A
B
AND
C
ARE
MUTUAL
FRIENDS
BALANCED
B
A
IS
FRIENDS
WITH
B
AND
C
BUT
THEY
DON
T
GET
ALONG
WITH
EACH
OTHER
NOT
BALANCED
C
A
AND
B
ARE
FRIENDS
WITH
C
AS
A
MUTUAL
EN
EMY
BALANCED
D
A
B
AND
C
ARE
MUTUAL
ENEMIES
NOT
BAL
ANCED
FIGURE
STRUCTURAL
BALANCE
EACH
LABELED
TRIANGLE
MUST
HAVE
OR
POSITIVE
EDGES
FRIENDS
THUS
TURNING
THE
B
C
EDGE
LABEL
TO
OR
ELSE
FOR
A
TO
SIDE
WITH
ONE
OF
B
OR
C
AGAINST
THE
OTHER
TURNING
ONE
OF
THE
EDGE
LABELS
OUT
OF
A
TO
A
SIMILARLY
THERE
ARE
SOURCES
OF
INSTABILITY
IN
A
CONFIGURATION
WHERE
EACH
OF
A
B
AND
C
ARE
MUTUAL
ENEMIES
AS
IN
FIGURE
D
IN
THIS
CASE
THERE
WOULD
BE
FORCES
MOTIVATING
TWO
OF
THE
THREE
PEOPLE
TO
TEAM
UP
AGAINST
THE
THIRD
TURNING
ONE
OF
THE
THREE
EDGE
LABELS
TO
A
BASED
ON
THIS
REASONING
WE
WILL
REFER
TO
TRIANGLES
WITH
ONE
OR
THREE
AS
BALANCED
SINCE
THEY
ARE
FREE
OF
THESE
SOURCES
OF
INSTABILITY
AND
WE
WILL
REFER
TO
TRIANGLES
WITH
ZERO
OR
TWO
AS
UNBALANCED
THE
ARGUMENT
OF
STRUCTURAL
BALANCE
THEORISTS
IS
THAT
BECAUSE
UNBALANCED
TRIANGLES
ARE
SOURCES
OF
STRESS
OR
PSYCHOLOGICAL
DISSONANCE
PEOPLE
STRIVE
TO
MINIMIZE
THEM
IN
THEIR
PERSONAL
RELATIONSHIPS
AND
HENCE
THEY
WILL
BE
LESS
ABUNDANT
IN
REAL
SOCIAL
SETTINGS
THAN
BALANCED
NOT
BALANCED
FIGURE
THE
LABELED
FOUR
NODE
COMPLETE
GRAPH
ON
THE
LEFT
IS
BALANCED
THE
ONE
ON
THE
RIGHT
IS
NOT
BALANCED
TRIANGLES
DEFINING
STRUCTURAL
BALANCE
FOR
NETWORKS
SO
FAR
WE
HAVE
BEEN
TALKING
ABOUT
STRUC
TURAL
BALANCE
FOR
GROUPS
OF
THREE
NODES
BUT
IT
IS
EASY
TO
CREATE
A
DEFINITION
THAT
NATURALLY
GENERALIZES
THIS
TO
COMPLETE
GRAPHS
ON
AN
ARBITRARY
NUMBER
OF
NODES
WITH
EDGES
LABELED
BY
AND
SPECIFICALLY
WE
SAY
THAT
A
LABELED
COMPLETE
GRAPH
IS
BALANCED
IF
EVERY
ONE
OF
ITS
TRIANGLES
IS
BALANCED
THAT
IS
IF
IT
OBEYS
THE
FOLLOWING
STRUCTURAL
BALANCE
PROPERTY
FOR
EVERY
SET
OF
THREE
NODES
IF
WE
CONSIDER
THE
THREE
EDGES
CONNECTING
THEM
EITHER
ALL
THREE
OF
THESE
EDGES
ARE
LABELED
OR
ELSE
EXACTLY
ONE
OF
THEM
IS
LABELED
FOR
EXAMPLE
CONSIDER
THE
TWO
LABELED
FOUR
NODE
NETWORKS
IN
FIGURE
THE
ONE
ON
THE
LEFT
IS
BALANCED
SINCE
WE
CAN
CHECK
THAT
EACH
SET
OF
THREE
NODES
SATISFIES
THE
STRUCTURAL
BALANCE
PROPERTY
ABOVE
ON
THE
OTHER
HAND
THE
ONE
ON
THE
RIGHT
IS
NOT
BALANCED
SINCE
AMONG
THE
THREE
NODES
A
B
C
THERE
ARE
EXACTLY
TWO
EDGES
LABELED
IN
VIOLATION
OF
STRUCTURAL
BALANCE
THE
TRIANGLE
ON
B
C
D
ALSO
VIOLATES
THE
CONDITION
OUR
DEFINITION
OF
BALANCED
NETWORKS
HERE
REPRESENTS
THE
LIMIT
OF
A
SOCIAL
SYSTEM
THAT
HAS
ELIMINATED
ALL
UNBALANCED
TRIANGLES
AS
SUCH
IT
IS
A
FAIRLY
EXTREME
DEFINITION
FOR
EXAMPLE
ONE
COULD
INSTEAD
PROPOSE
A
DEFINITION
WHICH
ONLY
REQUIRED
THAT
AT
LEAST
SOME
LARGE
PERCENTAGE
OF
ALL
TRIANGLES
WERE
BALANCED
ALLOWING
A
FEW
TRIANGLES
TO
BE
UNBALANCED
BUT
THE
VERSION
WITH
ALL
TRIANGLES
BALANCED
IS
A
FUNDAMENTAL
FIRST
STEP
IN
THINKING
ABOUT
THIS
CONCEPT
AND
MUTUAL
ANTAGONISM
BETWEEN
SETS
SET
X
SET
Y
FIGURE
IF
A
COMPLETE
GRAPH
CAN
BE
DIVIDED
INTO
TWO
SETS
OF
MUTUAL
FRIENDS
WITH
COMPLETE
MUTUAL
ANTAGONISM
BETWEEN
THE
TWO
SETS
THEN
IT
IS
BALANCED
FURTHERMORE
THIS
IS
THE
ONLY
WAY
FOR
A
COMPLETE
GRAPH
TO
BE
BALANCED
AS
WE
WILL
SEE
NEXT
IT
TURNS
OUT
TO
HAVE
VERY
INTERESTING
MATHEMATICAL
STRUCTURE
THAT
IN
FACT
HELPS
TO
INFORM
THE
CONCLUSIONS
OF
MORE
COMPLICATED
MODELS
AS
WELL
CHARACTERIZING
THE
STRUCTURE
OF
BALANCED
NETWORKS
AT
A
GENERAL
LEVEL
WHAT
DOES
A
BALANCED
NETWORK
I
E
A
BALANCED
LABELED
COMPLETE
GRAPH
LOOK
LIKE
GIVEN
ANY
SPECIFIC
EXAMPLE
WE
CAN
CHECK
ALL
TRIANGLES
TO
MAKE
SURE
THAT
THEY
EACH
OBEY
THE
BALANCE
CONDITIONS
BUT
IT
WOULD
BE
MUCH
BETTER
TO
HAVE
A
SIMPLE
CONCEPTUAL
DESCRIPTION
OF
WHAT
A
BALANCED
NETWORK
LOOKS
LIKE
IN
GENERAL
ONE
WAY
FOR
A
NETWORK
TO
BE
BALANCED
IS
IF
EVERYONE
LIKES
EACH
OTHER
IN
THIS
CASE
ALL
TRIANGLES
HAVE
THREE
LABELS
ON
THE
OTHER
HAND
THE
LEFT
HAND
SIDE
OF
FIGURE
SUGGESTS
A
SLIGHTLY
MORE
COMPLICATED
WAY
FOR
A
NETWORK
TO
BE
BALANCED
IT
CONSISTS
OF
TWO
GROUPS
OF
FRIENDS
A
B
AND
C
D
WITH
NEGATIVE
RELATIONS
BETWEEN
PEOPLE
IN
DIFFERENT
GROUPS
THIS
IS
ACTUALLY
TRUE
IN
GENERAL
SUPPOSE
WE
HAVE
A
LABELED
COMPLETE
GRAPH
IN
WHICH
THE
NODES
CAN
BE
DIVIDED
INTO
TWO
GROUPS
X
AND
Y
SUCH
THAT
EVERY
PAIR
OF
NODES
IN
X
LIKE
EACH
OTHER
EVERY
PAIR
OF
NODES
IN
Y
LIKE
EACH
OTHER
AND
EVERYONE
IN
X
IS
THE
ENEMY
OF
EVERYONE
IN
Y
SEE
THE
SCHEMATIC
ILLUSTRATION
IN
FIGURE
YOU
CAN
CHECK
THAT
SUCH
A
NETWORK
IS
BALANCED
A
TRIANGLE
CONTAINED
ENTIRELY
IN
ONE
GROUP
OR
THE
OTHER
HAS
THREE
LABELS
AND
A
TRIANGLE
WITH
TWO
PEOPLE
IN
ONE
GROUP
AND
ONE
IN
THE
OTHER
HAS
EXACTLY
ONE
LABEL
SO
THIS
DESCRIBES
TWO
BASIC
WAYS
TO
ACHIEVE
STRUCTURAL
BALANCE
EITHER
EVERYONE
LIKES
EACH
OTHER
OR
THE
WORLD
CONSISTS
OF
TWO
GROUPS
OF
MUTUAL
FRIENDS
WITH
COMPLETE
ANTAGONISM
BETWEEN
THE
GROUPS
THE
SURPRISING
FACT
IS
THE
FOLLOWING
THESE
ARE
THE
ONLY
WAYS
TO
HAVE
A
BALANCED
NETWORK
WE
FORMULATE
THIS
FACT
PRECISELY
AS
THE
FOLLOWING
BALANCE
THEOREM
PROVED
BY
FRANK
HARARY
IN
BALANCE
THEOREM
IF
A
LABELED
COMPLETE
GRAPH
IS
BALANCED
THEN
EITHER
ALL
PAIRS
OF
NODES
ARE
FRIENDS
OR
ELSE
THE
NODES
CAN
BE
DIVIDED
INTO
TWO
GROUPS
X
AND
Y
SUCH
THAT
EVERY
PAIR
OF
NODES
IN
X
LIKE
EACH
OTHER
EVERY
PAIR
OF
NODES
IN
Y
LIKE
EACH
OTHER
AND
EVERYONE
IN
X
IS
THE
ENEMY
OF
EVERYONE
IN
Y
THE
BALANCE
THEOREM
IS
NOT
AT
ALL
AN
OBVIOUS
FACT
NOR
SHOULD
IT
BE
INITIALLY
CLEAR
WHY
IT
IS
TRUE
ESSENTIALLY
WE
RE
TAKING
A
PURELY
LOCAL
PROPERTY
NAMELY
THE
STRUCTURAL
BALANCE
PROPERTY
WHICH
APPLIES
TO
ONLY
THREE
NODES
AT
A
TIME
AND
SHOWING
THAT
IT
IMPLIES
A
STRONG
GLOBAL
PROPERTY
EITHER
EVERYONE
GETS
ALONG
OR
THE
WORLD
IS
DIVIDED
INTO
TWO
BATTLING
FACTIONS
WE
RE
NOW
GOING
TO
SHOW
WHY
THIS
CLAIM
IN
FACT
IS
TRUE
PROVING
THE
BALANCE
THEOREM
ESTABLISHING
THE
CLAIM
REQUIRES
A
PROOF
WE
RE
GOING
TO
SUPPOSE
WE
HAVE
AN
ARBITRARY
LABELED
COMPLETE
GRAPH
ASSUME
ONLY
THAT
IT
IS
BALANCED
AND
CONCLUDE
THAT
EITHER
EVERYONE
IS
FRIENDS
OR
THAT
THERE
ARE
SETS
X
AND
Y
AS
DESCRIBED
IN
THE
CLAIM
RECALL
THAT
WE
WORKED
THROUGH
A
PROOF
IN
CHAPTER
AS
WELL
WHEN
WE
USED
SIMPLE
ASSUMPTIONS
ABOUT
TRIADIC
CLOSURE
IN
A
SOCIAL
NETWORK
TO
CONCLUDE
ALL
LOCAL
BRIDGES
IN
THE
NETWORK
MUST
BE
WEAK
TIES
OUR
PROOF
HERE
WILL
BE
SOMEWHAT
LONGER
BUT
STILL
VERY
NATURAL
AND
STRAIGHTFORWARD
WE
USE
THE
DEFINITION
OF
BALANCE
TO
DIRECTLY
DERIVE
THE
CONCLUSION
OF
THE
CLAIM
TO
START
SUPPOSE
WE
HAVE
A
LABELED
COMPLETE
GRAPH
AND
ALL
WE
KNOW
IS
THAT
IT
BALANCED
WE
HAVE
TO
SHOW
THAT
IT
HAS
THE
STRUCTURE
IN
THE
CLAIM
IF
IT
HAS
NO
NEGATIVE
EDGES
AT
ALL
THEN
EVERYONE
IS
FRIENDS
AND
WE
RE
ALL
SET
OTHERWISE
THERE
IS
AT
LEAST
ONE
NEGATIVE
EDGE
AND
WE
NEED
TO
SOMEHOW
COME
UP
WITH
A
DIVISION
OF
THE
NODES
INTO
SETS
OF
MUTUAL
FRIENDS
X
AND
Y
WITH
COMPLETE
ANTAGONISM
BETWEEN
THEM
THE
DIFFICULTY
IS
THAT
KNOWING
SO
LITTLE
ABOUT
THE
GRAPH
ITSELF
OTHER
THAN
THAT
IT
IS
BALANCED
IT
NOT
CLEAR
HOW
WE
RE
SUPPOSED
TO
IDENTIFY
X
AND
Y
LET
PICK
ANY
NODE
IN
THE
NETWORK
WE
LL
CALL
IT
A
AND
CONSIDER
THINGS
FROM
A
PERSPECTIVE
EVERY
OTHER
NODE
IS
EITHER
A
FRIEND
OF
A
OR
AN
ENEMY
OF
A
THUS
NATURAL
CANDIDATES
TO
TRY
FOR
THE
SETS
X
AND
Y
WOULD
BE
TO
DEFINE
X
TO
BE
A
AND
ALL
ITS
FRIENDS
AND
DEFINE
Y
TO
BE
ALL
THE
ENEMIES
OF
A
THIS
IS
INDEED
A
DIVISION
OF
ALL
THE
NODES
SINCE
EVERY
NODE
IS
EITHER
A
FRIEND
OR
AN
ENEMY
OF
A
RECALL
WHAT
WE
NEED
TO
SHOW
IN
ORDER
FOR
THESE
TWO
SETS
X
AND
Y
TO
SATISFY
THE
CONDITIONS
OF
THE
CLAIM
I
EVERY
TWO
NODES
IN
X
ARE
FRIENDS
II
EVERY
TWO
NODES
IN
Y
ARE
FRIENDS
FRIENDS
OF
A
ENEMIES
OF
A
FIGURE
A
SCHEMATIC
ILLUSTRATION
OF
OUR
ANALYSIS
OF
BALANCED
NETWORKS
THERE
MAY
BE
OTHER
NODES
NOT
ILLUSTRATED
HERE
III
EVERY
NODE
IN
X
IS
AN
ENEMY
OF
EVERY
NODE
IN
Y
LET
ARGUE
THAT
EACH
OF
THESE
CONDITIONS
IS
IN
FACT
TRUE
FOR
OUR
CHOICE
OF
X
AND
Y
THIS
WILL
MEAN
THAT
X
AND
Y
DO
SATISFY
THE
CONDITIONS
OF
THE
CLAIM
AND
WILL
COMPLETE
THE
PROOF
THE
REST
OF
THE
ARGUMENT
ESTABLISHING
I
II
AND
III
IS
ILLUSTRATED
SCHEMATICALLY
IN
FIGURE
FOR
I
WE
KNOW
THAT
A
IS
FRIENDS
WITH
EVERY
OTHER
NODE
IN
X
HOW
ABOUT
TWO
OTHER
NODES
IN
X
LET
CALL
THEM
B
AND
C
MUST
THEY
BE
FRIENDS
WE
KNOW
THAT
A
IS
FRIENDS
WITH
BOTH
B
AND
C
SO
IF
B
AND
C
WERE
ENEMIES
OF
EACH
OTHER
THEN
A
B
AND
C
WOULD
FORM
A
TRIANGLE
WITH
TWO
LABELS
A
VIOLATION
OF
THE
BALANCE
CONDITION
SINCE
WE
KNOW
THE
NETWORK
IS
BALANCED
THIS
CAN
T
HAPPEN
SO
IT
MUST
BE
THAT
B
AND
C
IN
FACT
ARE
FRIENDS
SINCE
B
AND
C
WERE
THE
NAMES
OF
ANY
TWO
NODES
IN
X
WE
HAVE
CONCLUDED
THAT
EVERY
TWO
NODES
IN
X
ARE
FRIENDS
LET
TRY
THE
SAME
KIND
OF
ARGUMENT
FOR
II
CONSIDER
ANY
TWO
NODES
IN
Y
LET
CALL
THEM
D
AND
E
MUST
THEY
BE
FRIENDS
WE
KNOW
THAT
A
IS
ENEMIES
WITH
BOTH
D
AND
E
SO
IF
D
AND
E
WERE
ENEMIES
OF
EACH
OTHER
THEN
A
D
AND
E
WOULD
FORM
A
TRIANGLE
WITH
NO
LABELS
A
VIOLATION
OF
THE
BALANCE
CONDITION
SINCE
WE
KNOW
THE
NETWORK
IS
BALANCED
THIS
CAN
T
HAPPEN
SO
IT
MUST
BE
THAT
D
AND
E
IN
FACT
ARE
FRIENDS
SINCE
D
AND
E
WERE
THE
NAMES
OF
ANY
TWO
NODES
IN
Y
WE
HAVE
CONCLUDED
THAT
EVERY
TWO
NODES
IN
Y
ARE
FRIENDS
FINALLY
LET
TRY
CONDITION
III
FOLLOWING
THE
STYLE
OF
OUR
ARGUMENTS
FOR
I
AND
II
CONSIDER
A
NODE
IN
X
CALL
IF
B
AND
A
NODE
IN
Y
CALL
IT
D
MUST
THEY
BE
ENEMIES
WE
KNOW
A
IS
FRIENDS
WITH
B
AND
ENEMIES
WITH
D
SO
IF
B
AND
D
WERE
FRIENDS
THEN
A
B
AND
D
WOULD
FORM
A
TRIANGLE
WITH
TWO
LABELS
A
VIOLATION
OF
THE
BALANCE
CONDITION
SINCE
WE
KNOW
THE
NETWORK
IS
BALANCED
THIS
CAN
T
HAPPEN
SO
IT
MUST
BE
THAT
B
AND
D
IN
FACT
ARE
ENEMIES
SINCE
B
AND
D
WERE
THE
NAMES
OF
ANY
NODE
IN
X
AND
ANY
NODE
IN
Y
WE
HAVE
CONCLUDED
THAT
EVERY
SUCH
PAIR
CONSTITUTES
A
PAIR
OF
ENEMIES
SO
IN
CONCLUSION
ASSUMING
ONLY
THAT
THE
NETWORK
IS
BALANCED
WE
HAVE
DESCRIBED
A
DIVISION
OF
THE
NODES
INTO
TWO
SETS
X
AND
Y
AND
WE
HAVE
CHECKED
CONDITIONS
I
II
AND
III
REQUIRED
BY
THE
CLAIM
THIS
COMPLETES
THE
PROOF
OF
THE
BALANCE
THEOREM
APPLICATIONS
OF
STRUCTURAL
BALANCE
STRUCTURAL
BALANCE
HAS
GROWN
INTO
A
LARGE
AREA
OF
STUDY
AND
WE
VE
ONLY
DESCRIBED
A
SIMPLE
BUT
CENTRAL
EXAMPLE
OF
THE
THEORY
IN
SECTION
WE
DISCUSS
TWO
EXTENSIONS
TO
THE
BASIC
THEORY
ONE
TO
HANDLE
GRAPHS
THAT
ARE
NOT
NECESSARILY
COMPLETE
AND
ONE
TO
DESCRIBE
THE
STRUCTURE
OF
COMPLETE
GRAPHS
THAT
ARE
APPROXIMATELY
BALANCED
IN
THE
SENSE
THAT
MOST
BUT
NOT
ALL
THEIR
TRIANGLES
ARE
BALANCED
THERE
HAS
ALSO
BEEN
RECENT
RESEARCH
LOOKING
AT
DYNAMIC
ASPECTS
OF
STRUCTURAL
BALANCE
THEORY
MODELING
HOW
THE
SET
OF
FRIENDSHIPS
AND
ANTAGONISMS
IN
A
COMPLETE
GRAPH
IN
OTHER
WORDS
THE
LABELING
OF
THE
EDGES
MIGHT
EVOLVE
OVER
TIME
AS
THE
SOCIAL
NETWORK
IMPLICITLY
SEEKS
OUT
STRUCTURAL
BALANCE
ANTAL
KRAPIVSKY
AND
REDNER
STUDY
A
MODEL
IN
WHICH
WE
START
WITH
A
RANDOM
LABELING
CHOOSING
OR
RANDOMLY
FOR
EACH
EDGE
WE
THEN
REPEATEDLY
LOOK
FOR
A
TRIANGLE
THAT
IS
NOT
BALANCED
AND
FLIP
ONE
OF
ITS
LABELS
TO
MAKE
IT
BALANCED
THIS
CAPTURES
A
SITUATION
IN
WHICH
PEOPLE
CONTINUALLY
REASSESS
THEIR
LIKES
AND
DISLIKES
OF
OTHERS
AS
THEY
STRIVE
FOR
STRUCTURAL
BALANCE
THE
MATHEMATICS
HERE
BECOMES
QUITE
COMPLICATED
AND
TURNS
OUT
TO
RESEMBLE
THE
MATHEMATICAL
MODELS
ONE
USES
FOR
CERTAIN
PHYSICAL
SYSTEMS
AS
THEY
RECONFIGURE
TO
MINIMIZE
THEIR
ENERGY
IN
THE
REMAINDER
OF
THIS
SECTION
WE
CONSIDER
TWO
FURTHER
AREAS
IN
WHICH
THE
IDEAS
OF
STRUC
TURAL
BALANCE
ARE
RELEVANT
INTERNATIONAL
RELATIONS
WHERE
THE
NODES
ARE
DIFFERENT
COUNTRIES
AND
ON
LINE
SOCIAL
MEDIA
SITES
WHERE
USERS
CAN
EXPRESS
POSITIVE
OR
NEGATIVE
OPINIONS
ABOUT
EACH
OTHER
INTERNATIONAL
RELATIONS
INTERNATIONAL
POLITICS
REPRESENTS
A
SETTING
IN
WHICH
IT
IS
NATURAL
TO
ASSUME
THAT
A
COLLECTION
OF
NODES
ALL
HAVE
OPINIONS
POSITIVE
OR
NEGATIVE
ABOUT
ONE
ANOTHER
HERE
THE
NODES
ARE
NATIONS
AND
AND
LABELS
INDICATE
ALLIANCES
OR
ANIMOSITY
RESEARCH
IN
POLITICAL
SCIENCE
HAS
SHOWN
THAT
STRUCTURAL
BALANCE
CAN
SOMETIMES
PROVIDE
AN
EFFECTIVE
EXPLANATION
FOR
THE
BEHAVIOR
OF
NATIONS
DURING
VARIOUS
INTERNATIONAL
CRISES
FOR
EXAMPLE
MOORE
DESCRIBING
THE
CONFLICT
OVER
BANGLADESH
SEPARATION
FROM
PAKISTAN
IN
EXPLICITLY
INVOKES
STRUCTURAL
BALANCE
THEORY
WHEN
HE
WRITES
T
HE
UNITED
STATES
SOMEWHAT
SURPRISING
SUPPORT
OF
PAKISTAN
BECOMES
LESS
SURPRISING
WHEN
ONE
CONSIDERS
THAT
THE
USSR
A
THREE
EMPERORS
LEAGUE
B
TRIPLE
ALLIANCE
C
GERMAN
RUSSIAN
LAPSE
D
FRENCH
RUSSIAN
ALLIANCE
E
ENTENTE
CORDIALE
F
BRITISH
RUSSIAN
ALLIANCE
FIGURE
THE
EVOLUTION
OF
ALLIANCES
IN
EUROPE
THE
NATIONS
GB
FR
RU
IT
GE
AND
AH
ARE
GREAT
BRITAIN
FRANCE
RUSSIA
ITALY
GERMANY
AND
AUSTRIA
HUNGARY
RESPEC
TIVELY
SOLID
DARK
EDGES
INDICATE
FRIENDSHIP
WHILE
DOTTED
RED
EDGES
INDICATE
ENMITY
NOTE
HOW
THE
NETWORK
SLIDES
INTO
A
BALANCED
LABELING
AND
INTO
WORLD
WAR
I
THIS
FIGURE
AND
EXAMPLE
ARE
FROM
ANTAL
KRAPIVSKY
AND
REDNER
WAS
CHINA
ENEMY
CHINA
WAS
INDIA
FOE
AND
INDIA
HAD
TRADITIONALLY
BAD
RELATIONS
WITH
PAKISTAN
SINCE
THE
U
WAS
AT
THAT
TIME
IMPROVING
ITS
RELATIONS
WITH
CHINA
IT
SUPPORTED
THE
ENEMIES
OF
CHINA
ENEMIES
FURTHER
REVERBERATIONS
OF
THIS
STRANGE
POLITICAL
CONSTELLATION
BECAME
INEVITABLE
NORTH
VIETNAM
MADE
FRIENDLY
GESTURES
TOWARD
INDIA
PAKISTAN
SEVERED
DIPLOMATIC
RELATIONS
WITH
THOSE
COUNTRIES
OF
THE
EASTERN
BLOC
WHICH
RECOGNIZED
BANGLADESH
AND
CHINA
VETOED
THE
ACCEPTANCE
OF
BANGLADESH
INTO
THE
U
N
ANTAL
KRAPIVSKY
AND
REDNER
USE
THE
SHIFTING
ALLIANCES
PRECEDING
WORLD
WAR
I
AS
ANOTHER
EXAMPLE
OF
STRUCTURAL
BALANCE
IN
INTERNATIONAL
RELATIONS
SEE
FIGURE
THIS
ALSO
REINFORCES
THE
FACT
THAT
STRUCTURAL
BALANCE
IS
NOT
NECESSARILY
A
GOOD
THING
SINCE
ITS
GLOBAL
OUTCOME
IS
OFTEN
TWO
IMPLACABLY
OPPOSED
ALLIANCES
THE
SEARCH
FOR
BALANCE
IN
A
SYSTEM
CAN
SOMETIMES
BE
SEEN
AS
A
SLIDE
INTO
A
HARD
TO
RESOLVE
OPPOSITION
BETWEEN
TWO
SIDES
TRUST
DISTRUST
AND
ON
LINE
RATINGS
A
GROWING
SOURCE
FOR
NETWORK
DATA
WITH
BOTH
POSITIVE
AND
NEGATIVE
EDGES
COMES
FROM
USER
COMMUNITIES
ON
THE
WEB
WHERE
PEOPLE
CAN
EXPRESS
POSITIVE
OR
NEGATIVE
SENTIMENTS
ABOUT
EACH
OTHER
EXAMPLES
INCLUDE
THE
TECHNOLOGY
NEWS
SITE
SLASHDOT
WHERE
USERS
CAN
DESIGNATE
EACH
OTHER
AS
A
FRIEND
OR
A
FOE
AND
ON
LINE
PRODUCT
RATING
SITES
SUCH
AS
EPINIONS
WHERE
A
USER
CAN
EXPRESS
EVALUATIONS
OF
DIFFERENT
PRODUCTS
AND
ALSO
EXPRESS
TRUST
OR
DISTRUST
OF
OTHER
USERS
GUHA
KUMAR
RAGHAVAN
AND
TOMKINS
PERFORMED
AN
ANALYSIS
OF
THE
NETWORK
OF
USER
EVALUATIONS
ON
EPINIONS
THEIR
WORK
IDENTIFIED
AN
INTERESTING
SET
OF
ISSUES
THAT
SHOW
HOW
THE
TRUST
DISTRUST
DICHOTOMY
IN
ON
LINE
RATINGS
HAS
BOTH
SIMILARITIES
AND
DIFFERENCES
WITH
THE
FRIEND
ENEMY
DICHOTOMY
IN
STRUCTURAL
BALANCE
THEORY
ONE
DIFFERENCE
IS
BASED
ON
A
SIMPLE
STRUCTURAL
DISTINCTION
WE
HAVE
BEEN
CONSIDERING
STRUCTURAL
BALANCE
IN
THE
CONTEXT
OF
UNDIRECTED
GRAPHS
WHEREAS
USER
EVALUATIONS
ON
A
SITE
LIKE
EPINIONS
FORM
A
DIRECTED
GRAPH
THAT
IS
WHEN
A
USER
A
EXPRESSES
TRUST
OR
DISTRUST
OF
A
USER
B
WE
DON
T
NECESSARILY
KNOW
WHAT
B
THINKS
OF
A
OR
WHETHER
B
IS
EVEN
AWARE
OF
A
A
MORE
SUBTLE
DIFFERENCE
BETWEEN
TRUST
DISTRUST
AND
FRIEND
ENEMY
RELATIONS
BECOMES
AP
PARENT
WHEN
THINKING
ABOUT
HOW
WE
SHOULD
EXPECT
TRIANGLES
ON
THREE
EPINIONS
USERS
TO
BEHAVE
CERTAIN
PATTERNS
ARE
EASY
TO
REASON
ABOUT
FOR
EXAMPLE
IF
USER
A
TRUSTS
USER
B
AND
USER
B
TRUSTS
USER
C
THEN
IT
IS
NATURAL
TO
EXPECT
THAT
A
WILL
TRUST
C
SUCH
TRIANGLES
WITH
THREE
FORWARD
POINTING
POSITIVE
EDGES
MAKE
SENSE
HERE
BY
ANALOGY
WITH
THE
ALL
POSITIVE
UNDIRECTED
TRIANGLES
OF
STRUCTURAL
BALANCE
THEORY
BUT
WHAT
IF
A
DISTRUSTS
B
AND
B
DIS
TRUSTS
C
SHOULD
WE
EXPECT
A
TO
TRUST
OR
TO
DISTRUST
C
THERE
ARE
APPEALING
ARGUMENTS
IN
BOTH
DIRECTIONS
IF
WE
THINK
OF
DISTRUST
AS
FUNDAMENTALLY
A
KIND
OF
ENEMY
RELATIONSHIP
THEN
THE
ARGUMENTS
FROM
STRUCTURAL
BALANCE
THEORY
WOULD
SUGGEST
THAT
A
SHOULD
TRUST
C
OTHERWISE
WE
D
HAVE
A
TRIANGLE
WITH
THREE
NEGATIVE
EDGES
ON
THE
OTHER
HAND
IF
A
DISTRUST
OF
B
EXPRESSES
A
BELIEF
THAT
SHE
IS
MORE
KNOWLEDGEABLE
AND
COMPETENT
THAN
B
AND
IF
B
DISTRUST
OF
C
REFLECTS
A
CORRESPONDING
BELIEF
BY
B
THEN
WE
MIGHT
WELL
EXPECT
THAT
A
WILL
DISTRUST
C
AND
PERHAPS
EVEN
MORE
STRONGLY
THAN
SHE
DISTRUSTS
B
IT
IS
REASONABLE
TO
EXPECT
THAT
THESE
TWO
DIFFERENT
INTERPRETATIONS
OF
DISTRUST
MAY
EACH
APPLY
SIMPLY
IN
DIFFERENT
SETTINGS
AND
BOTH
MIGHT
APPLY
IN
THE
CONTEXT
OF
A
SINGLE
PRODUCT
RATING
SITE
LIKE
EPINIONS
FOR
EXAMPLE
AMONG
USERS
WHO
ARE
PRIMARILY
RATING
BEST
SELLING
BOOKS
BY
POLITICAL
COMMENTATORS
TRUST
DISTRUST
EVALUATIONS
BETWEEN
USERS
MAY
BECOME
STRONGLY
ALIGNED
WITH
AGREEMENT
OR
DISAGREEMENT
IN
THESE
USERS
OWN
POLITICAL
ORIENTATIONS
IN
SUCH
A
CASE
IF
A
DISTRUSTS
B
AND
B
DISTRUSTS
C
THIS
MAY
SUGGEST
THAT
A
AND
C
ARE
CLOSE
TO
EACH
OTHER
ON
THE
UNDERLYING
POLITICAL
SPECTRUM
AND
SO
THE
PREDICTION
OF
STRUCTURAL
BALANCE
THEORY
THAT
A
SHOULD
TRUST
C
MAY
APPLY
ON
THE
OTHER
HAND
AMONG
USERS
WHO
ARE
PRIMARILY
RATING
CONSUMER
ELECTRONICS
PRODUCTS
TRUST
DISTRUST
EVALUATIONS
MAY
LARGELY
REFLECT
THE
RELATIVE
EXPERTISE
OF
USERS
ABOUT
THE
PRODUCTS
THEIR
RESPECTIVE
FEATURES
RELIABILITY
AND
SO
FORTH
IN
SUCH
A
CASE
IF
A
DISTRUSTS
B
AND
B
DISTRUSTS
C
WE
MIGHT
CONCLUDE
THAT
A
IS
SET
W
MUTUAL
FRIENDS
INSIDE
V
SET
V
SET
X
MUTUAL
FRIENDS
INSIDE
X
MUTUAL
ANTAGONISM
BETWEEN
ALL
SETS
SET
Y
MUTUAL
FRIENDS
INSIDE
Y
SET
Z
FIGURE
A
COMPLETE
GRAPH
IS
WEAKLY
BALANCED
PRECISELY
WHEN
IT
CAN
BE
DIVIDED
INTO
MULTIPLE
SETS
OF
MUTUAL
FRIENDS
WITH
COMPLETE
MUTUAL
ANTAGONISM
BETWEEN
EACH
PAIR
OF
SETS
FAR
MORE
EXPERT
THAN
C
AND
SO
SHOULD
DISTRUST
C
AS
WELL
ULTIMATELY
UNDERSTANDING
HOW
THESE
POSITIVE
AND
NEGATIVE
RELATIONSHIPS
WORK
IS
IMPOR
TANT
FOR
UNDERSTANDING
THE
ROLE
THEY
PLAY
ON
SOCIAL
WEB
SITES
WHERE
USERS
REGISTER
SUBJECTIVE
EVALUATIONS
OF
EACH
OTHER
RESEARCH
IS
ONLY
BEGINNING
TO
EXPLORE
THESE
FUNDAMENTAL
QUESTIONS
INCLUDING
THE
WAYS
IN
WHICH
THEORIES
OF
BALANCE
AS
WELL
AS
RELATED
THEORIES
CAN
BE
USED
TO
SHED
LIGHT
ON
THESE
ISSUES
IN
LARGE
SCALE
DATASETS
A
WEAKER
FORM
OF
STRUCTURAL
BALANCE
IN
STUDYING
MODELS
OF
POSITIVE
AND
NEGATIVE
RELATIONSHIPS
ON
NETWORKS
RESEARCHERS
HAVE
ALSO
FORMULATED
ALTERNATE
NOTIONS
OF
STRUCTURAL
BALANCE
BY
REVISITING
THE
ORIGINAL
ASSUMPTIONS
WE
USED
TO
MOTIVATE
THE
FRAMEWORK
IN
PARTICULAR
OUR
ANALYSIS
BEGAN
FROM
THE
CLAIM
THAT
THERE
ARE
TWO
KINDS
OF
STRUCTURES
ON
A
GROUP
OF
THREE
PEOPLE
THAT
ARE
INHERENTLY
UNBALANCED
A
TRIANGLE
WITH
TWO
POSITIVE
EDGES
AND
ONE
NEGATIVE
EDGE
AS
IN
FIGURE
B
AND
A
TRIANGLE
WITH
THREE
NEGATIVE
EDGES
AS
IN
FIGURE
D
IN
EACH
OF
THESE
CASES
WE
ARGUED
THAT
THE
RELATIONSHIPS
WITHIN
THE
TRIANGLE
CONTAINED
A
LATENT
SOURCE
OF
STRESS
THAT
THE
NETWORK
MIGHT
TRY
TO
RESOLVE
THE
UNDERLYING
ARGUMENTS
IN
THE
TWO
CASES
HOWEVER
WERE
FUNDAMENTALLY
DIFFERENT
IN
A
TRIANGLE
WITH
TWO
POSITIVE
EDGES
WE
HAVE
THE
PROBLEM
OF
A
PERSON
WHOSE
TWO
FRIENDS
DON
T
GET
ALONG
IN
A
TRIANGLE
WITH
THREE
NEGATIVE
EDGES
THERE
IS
THE
POSSIBILITY
THAT
TWO
OF
THE
NODES
WILL
ALLY
THEMSELVES
AGAINST
THE
THIRD
JAMES
DAVIS
AND
OTHERS
HAVE
ARGUED
THAT
IN
MANY
SETTINGS
THE
FIRST
OF
THESE
FACTORS
MAY
BE
SIGNIFICANTLY
STRONGER
THAN
THE
SECOND
WE
MAY
SEE
FRIENDS
OF
FRIENDS
TRYING
TO
RECON
CILE
THEIR
DIFFERENCES
RESOLVING
THE
LACK
OF
BALANCE
IN
FIGURE
B
WHILE
AT
THE
SAME
TIME
THERE
COULD
BE
LESS
OF
A
FORCE
LEADING
ANY
TWO
OF
THREE
MUTUAL
ENEMIES
AS
IN
FIGURE
D
TO
BECOME
FRIENDLY
IT
THEREFORE
BECOMES
NATURAL
TO
ASK
WHAT
STRUCTURAL
PROPERTIES
ARISE
WHEN
WE
RULE
OUT
ONLY
TRIANGLES
WITH
EXACTLY
TWO
POSITIVE
EDGES
WHILE
ALLOWING
TRIANGLES
WITH
THREE
NEGATIVE
EDGES
TO
BE
PRESENT
IN
THE
NETWORK
CHARACTERIZING
WEAKLY
BALANCED
NETWORKS
MORE
PRECISELY
WE
WILL
SAY
THAT
A
COM
PLETE
GRAPH
WITH
EACH
EDGE
LABELED
BY
OR
IS
WEAKLY
BALANCED
IF
THE
FOLLOWING
PROPERTY
HOLDS
WEAK
STRUCTURAL
BALANCE
PROPERTY
THERE
IS
NO
SET
OF
THREE
NODES
SUCH
THAT
THE
EDGES
AMONG
THEM
CONSIST
OF
EXACTLY
TWO
POSITIVE
EDGES
AND
ONE
NEGATIVE
EDGE
SINCE
WEAK
BALANCE
IMPOSES
LESS
OF
A
RESTRICTION
ON
WHAT
THE
NETWORK
CAN
LOOK
LIKE
WE
SHOULD
EXPECT
TO
SEE
A
BROADER
RANGE
OF
POSSIBLE
STRUCTURES
FOR
WEAKLY
BALANCED
NETWORKS
BEYOND
WHAT
THE
BALANCE
THEOREM
REQUIRED
FOR
NETWORKS
THAT
WERE
BALANCED
UNDER
OUR
ORIGINAL
DEFINITION
AND
INDEED
FIGURE
INDICATES
A
NEW
KIND
OF
STRUCTURE
THAT
CAN
ARISE
SUPPOSE
THAT
THE
NODES
CAN
BE
DIVIDED
INTO
AN
ARBITRARY
NUMBER
OF
GROUPS
POSSIBLY
MORE
THAN
TWO
SO
THAT
TWO
NODES
ARE
FRIENDS
WHEN
THEY
BELONG
TO
THE
SAME
GROUP
AND
ENEMIES
WHEN
THEY
BELONG
TO
DIFFERENT
GROUPS
THEN
WE
CAN
CHECK
THAT
SUCH
A
NETWORK
IS
WEAKLY
BALANCED
IN
ANY
TRIANGLE
THAT
CONTAINS
AT
LEAST
TWO
POSITIVE
EDGES
ALL
THREE
NODES
MUST
BELONG
TO
THE
SAME
GROUP
THEREFORE
THE
THIRD
EDGE
OF
THIS
TRIANGLE
MUST
BE
POSITIVE
AS
WELL
IN
OTHER
WORDS
THE
NETWORK
CONTAINS
NO
TRIANGLES
WITH
EXACTLY
TWO
EDGES
JUST
AS
THE
BALANCE
THEOREM
ESTABLISHED
THAT
ALL
BALANCED
NETWORKS
MUST
HAVE
A
SIMPLE
STRUCTURE
AN
ANALOGOUS
RESULT
HOLDS
FOR
WEAKLY
BALANCED
NETWORKS
THEY
MUST
HAVE
THE
STRUCTURE
DEPICTED
IN
FIGURE
WITH
ANY
NUMBER
OF
GROUPS
CHARACTERIZATION
OF
WEAKLY
BALANCED
NETWORKS
IF
A
LABELED
COMPLETE
GRAPH
IS
WEAKLY
BALANCED
THEN
ITS
NODES
CAN
BE
DIVIDED
INTO
GROUPS
IN
SUCH
A
WAY
THAT
FRIENDS
OF
A
ENEMIES
OF
A
FIGURE
A
SCHEMATIC
ILLUSTRATION
OF
OUR
ANALYSIS
OF
WEAKLY
BALANCED
NETWORKS
THERE
MAY
BE
OTHER
NODES
NOT
ILLUSTRATED
HERE
EVERY
TWO
NODES
BELONGING
TO
THE
SAME
GROUP
ARE
FRIENDS
AND
EVERY
TWO
NODES
BELONGING
TO
DIFFERENT
GROUPS
ARE
ENEMIES
THE
FACT
THAT
THIS
CHARACTERIZATION
IS
TRUE
IN
FACT
PROVIDED
ANOTHER
EARLY
MOTIVATION
FOR
STUDYING
WEAK
STRUCTURAL
BALANCE
THE
CARTWRIGHT
HARARY
NOTION
OF
BALANCE
PREDICTED
ONLY
DICHOTOMIES
OR
MUTUAL
CONSENSUS
AS
ITS
BASIC
SOCIAL
STRUCTURE
AND
THUS
DID
NOT
PROVIDE
A
MODEL
FOR
REASONING
ABOUT
SITUATIONS
IN
WHICH
A
NETWORK
IS
DIVIDED
INTO
MORE
THAN
TWO
FACTIONS
WEAK
STRUCTURAL
BALANCE
MAKES
THIS
POSSIBLE
SINCE
WEAKLY
BALANCED
COMPLETE
GRAPHS
CAN
CONTAIN
ANY
NUMBER
OF
OPPOSED
GROUPS
OF
MUTUAL
FRIENDS
PROVING
THE
CHARACTERIZATION
IT
IS
NOT
HARD
TO
GIVE
A
PROOF
FOR
THIS
CHARACTERIZA
TION
FOLLOWING
THE
STRUCTURE
OF
OUR
PROOF
FOR
THE
BALANCE
THEOREM
AND
MAKING
APPROPRIATE
CHANGES
WHERE
NECESSARY
STARTING
WITH
A
WEAKLY
BALANCED
COMPLETE
GRAPH
THE
CHARACTERIZA
TION
REQUIRES
THAT
WE
PRODUCE
A
DIVISION
OF
ITS
NODES
INTO
GROUPS
OF
MUTUAL
FRIENDS
SUCH
THAT
ALL
RELATIONS
BETWEEN
NODES
IN
DIFFERENT
GROUPS
ARE
NEGATIVE
HERE
IS
HOW
WE
WILL
CONSTRUCT
THIS
DIVISION
FIRST
WE
PICK
ANY
NODE
A
AND
WE
CONSIDER
THE
SET
CONSISTING
OF
A
AND
ALL
ITS
FRIENDS
LET
CALL
THIS
SET
OF
NODES
X
WE
D
LIKE
TO
MAKE
X
OUR
FIRST
GROUP
AND
FOR
THIS
TO
WORK
WE
NEED
TO
ESTABLISH
TWO
THINGS
I
ALL
OF
A
FRIENDS
ARE
FRIENDS
WITH
EACH
OTHER
THIS
WAY
WE
HAVE
INDEED
PRODUCED
A
GROUP
OF
MUTUAL
FRIENDS
II
A
AND
ALL
HIS
FRIENDS
ARE
ENEMIES
WITH
EVERYONE
ELSE
IN
THE
GRAPH
THIS
WAY
THE
PEOPLE
IN
THIS
GROUP
WILL
BE
ENEMIES
WITH
EVERYONE
IN
OTHER
GROUPS
HOWEVER
WE
DIVIDE
UP
THE
REST
OF
THE
GRAPH
FORTUNATELY
IDEAS
THAT
WE
ALREADY
USED
INSIDE
THE
PROOF
OF
THE
BALANCE
THEOREM
CAN
BE
ADAPTED
TO
OUR
NEW
SETTING
HERE
TO
ESTABLISH
I
AND
II
THE
IDEA
IS
SHOWN
IN
FIGURE
FIRST
FOR
I
LET
CONSIDER
TWO
NODES
B
AND
C
WHO
ARE
BOTH
FRIENDS
WITH
A
IF
B
AND
C
WERE
ENEMIES
OF
EACH
OTHER
THEN
THE
TRIANGLE
ON
NODES
A
B
AND
C
WOULD
HAVE
EXACTLY
TWO
LABELS
WHICH
WOULD
VIOLATE
WEAK
STRUCTURAL
BALANCE
SO
B
AND
C
MUST
INDEED
BE
FRIENDS
WITH
EACH
OTHER
FOR
II
WE
KNOW
THAT
A
IS
ENEMIES
WITH
ALL
NODES
IN
THE
GRAPH
OUTSIDE
X
SINCE
THE
GROUP
X
IS
DEFINED
TO
INCLUDE
ALL
OF
A
FRIENDS
HOW
ABOUT
AN
EDGE
BETWEEN
A
NODE
B
IN
X
AND
A
NODE
D
OUTSIDE
X
IF
B
AND
D
WERE
FRIENDS
THEN
THE
TRIANGLE
ON
NODES
A
B
AND
D
WOULD
HAVE
EXACTLY
TWO
LABELS
AGAIN
A
VIOLATION
OF
WEAK
STRUCTURAL
BALANCE
SO
B
AND
D
MUST
BE
ENEMIES
SINCE
PROPERTIES
I
AND
II
HOLD
WE
CAN
REMOVE
THE
SET
X
CONSISTING
OF
A
AND
ALL
HIS
FRIENDS
FROM
THE
GRAPH
AND
DECLARE
IT
TO
BE
THE
FIRST
GROUP
WE
NOW
HAVE
A
SMALLER
COMPLETE
GRAPH
THAT
IS
STILL
WEAKLY
BALANCED
WE
FIND
A
SECOND
GROUP
IN
THIS
GRAPH
AND
PROCEED
TO
REMOVE
GROUPS
IN
THIS
WAY
UNTIL
ALL
THE
NODES
HAVE
BEEN
ASSIGNED
TO
A
GROUP
SINCE
EACH
GROUP
CONSISTS
OF
MUTUAL
FRIENDS
BY
PROPERTY
I
AND
EACH
GROUP
HAS
ONLY
NEGATIVE
RELATIONS
WITH
EVERYONE
OUTSIDE
THE
GROUP
BY
PROPERTY
II
THIS
PROVES
THE
CHARACTERIZATION
IT
IS
INTERESTING
TO
REFLECT
ON
THIS
PROOF
IN
RELATION
TO
THE
PROOF
OF
THE
BALANCE
THEOREM
IN
PARTICULAR
THE
CONTRAST
REFLECTED
BY
THE
SMALL
DIFFERENCES
BETWEEN
FIGURES
AND
IN
PROVING
THE
BALANCE
THEOREM
WE
HAD
TO
REASON
ABOUT
THE
SIGN
OF
THE
EDGE
BETWEEN
D
AND
E
TO
SHOW
THAT
THE
ENEMIES
OF
THE
SET
X
THEMSELVES
FORMED
A
SET
Y
OF
MUTUAL
FRIENDS
IN
CHARACTERIZING
WEAKLY
BALANCED
COMPLETE
GRAPHS
ON
THE
OTHER
HAND
WE
MADE
NO
ATTEMPT
TO
REASON
ABOUT
THE
D
E
EDGE
BECAUSE
WEAK
BALANCE
IMPOSES
NO
CONDITION
ON
IT
TWO
ENEMIES
OF
A
CAN
BE
EITHER
FRIENDS
OR
ENEMIES
AS
A
RESULT
THE
SET
OF
ENEMIES
IN
FIGURE
MIGHT
NOT
BE
A
SET
OF
MUTUAL
FRIENDS
WHEN
ONLY
WEAK
BALANCE
HOLDS
IT
MIGHT
CONSIST
OF
MULTIPLE
GROUPS
OF
MUTUAL
FRIENDS
AND
AS
WE
EXTRACT
THESE
GROUPS
ONE
BY
ONE
OVER
THE
COURSE
OF
THE
PROOF
WE
RECOVER
THE
MULTI
FACTION
STRUCTURE
ILLUSTRATED
SCHEMATICALLY
IN
FIGURE
ADVANCED
MATERIAL
GENERALIZING
THE
DEFINITION
OF
STRUCTURAL
BALANCE
IN
THIS
SECTION
WE
CONSIDER
MORE
GENERAL
WAYS
OF
FORMULATING
THE
IDEA
OF
STRUCTURAL
BALANCE
IN
A
NETWORK
IN
PARTICULAR
OUR
DEFINITION
OF
STRUCTURAL
BALANCE
THUS
FAR
IS
FAIRLY
DEMANDING
IN
TWO
RESPECTS
FIGURE
IN
GRAPHS
THAT
ARE
NOT
COMPLETE
WE
CAN
STILL
DEFINE
NOTIONS
OF
STRUCTURAL
BALANCE
WHEN
THE
EDGES
THAT
ARE
PRESENT
HAVE
POSITIVE
OR
NEGATIVE
SIGNS
INDICATING
FRIEND
OR
ENEMY
RELATIONS
IT
APPLIES
ONLY
TO
COMPLETE
GRAPHS
WE
REQUIRE
THAT
EACH
PERSON
KNOW
AND
HAVE
AN
OPINION
POSITIVE
OR
NEGATIVE
ON
EVERYONE
ELSE
WHAT
IF
ONLY
SOME
PAIRS
OF
PEOPLE
KNOW
EACH
OTHER
THE
BALANCE
THEOREM
SHOWING
THAT
STRUCTURAL
BALANCE
IMPLIES
A
GLOBAL
DIVISION
OF
THE
WORLD
INTO
TWO
FACTIONS
ONLY
APPLIES
TO
THE
CASE
IN
WHICH
EVERY
TRIANGLE
IS
BALANCED
CAN
WE
RELAX
THIS
TO
SAY
THAT
IF
MOST
TRIANGLES
ARE
BALANCED
THEN
THE
WORLD
CAN
BE
APPROXIMATELY
DIVIDED
INTO
TWO
FACTIONS
IN
THE
TWO
PARTS
OF
THIS
SECTION
WE
DISCUSS
A
PAIR
OF
RESULTS
THAT
ADDRESS
THESE
QUESTIONS
THE
FIRST
IS
BASED
ON
A
GRAPH
THEORETIC
ANALYSIS
INVOLVING
THE
NOTION
OF
BREADTH
FIRST
SEARCH
FROM
CHAPTER
WHILE
THE
SECOND
IS
TYPICAL
OF
A
STYLE
OF
PROOF
KNOWN
AS
A
COUNTING
ARGUMENT
THROUGHOUT
THIS
SECTION
WE
WILL
FOCUS
ON
THE
ORIGINAL
DEFINITION
OF
STRUCTURAL
BALANCE
FROM
SECTIONS
AND
RATHER
THAN
THE
WEAKER
VERSION
FROM
SECTION
A
A
GRAPH
WITH
SIGNED
EDGES
B
FILLING
IN
THE
MISSING
EDGES
TO
ACHIEVE
BALANCE
Y
C
DIVIDING
THE
GRAPH
INTO
TWO
SETS
FIGURE
THERE
ARE
TWO
EQUIVALENT
WAYS
TO
DEFINE
STRUCTURAL
BALANCE
FOR
GENERAL
NON
COMPLETE
GRAPHS
ONE
DEFINITION
ASKS
WHETHER
IT
IS
POSSIBLE
TO
FILL
IN
THE
REMAINING
EDGES
SO
AS
TO
PRODUCE
A
SIGNED
COMPLETE
GRAPH
THAT
IS
BALANCED
THE
OTHER
DEFINITION
ASKS
WHETHER
IT
IS
POSSIBLE
TO
DIVIDE
THE
NODES
INTO
TWO
SETS
X
AND
Y
SO
THAT
ALL
EDGES
INSIDE
X
AND
INSIDE
Y
ARE
POSITIVE
AND
ALL
EDGES
BETWEEN
X
AND
Y
ARE
NEGATIVE
A
STRUCTURAL
BALANCE
IN
ARBITRARY
NON
COMPLETE
NETWORKS
FIRST
LET
CONSIDER
THE
CASE
OF
A
SOCIAL
NETWORK
THAT
IS
NOT
NECESSARILY
COMPLETE
THAT
IS
THERE
ARE
ONLY
EDGES
BETWEEN
CERTAIN
PAIRS
OF
NODES
BUT
EACH
OF
THESE
EDGES
IS
STILL
LABELED
WITH
OR
SO
NOW
THERE
ARE
THREE
POSSIBLE
RELATIONS
BETWEEN
EACH
PAIR
OF
NODES
A
POSITIVE
EDGE
INDICATING
FRIENDSHIP
A
NEGATIVE
EDGE
INDICATING
ENMITY
OR
THE
ABSENCE
OF
AN
EDGE
INDICATING
THAT
THE
TWO
ENDPOINTS
DO
NOT
KNOW
EACH
OTHER
FIGURE
DEPICTS
AN
EXAMPLE
OF
SUCH
A
SIGNED
NETWORK
DEFINING
BALANCE
FOR
GENERAL
NETWORKS
DRAWING
ON
WHAT
WE
VE
LEARNED
FROM
THE
SPECIAL
CASE
OF
COMPLETE
GRAPHS
WHAT
WOULD
BE
A
GOOD
DEFINITION
OF
BALANCE
FOR
THIS
MORE
GENERAL
KIND
OF
STRUCTURE
THE
BALANCE
THEOREM
SUGGESTS
THAT
WE
CAN
VIEW
STRUCTURAL
BALANCE
IN
EITHER
OF
TWO
EQUIVALENT
WAYS
A
LOCAL
VIEW
AS
A
CONDITION
ON
EACH
TRIANGLE
OF
THE
NETWORK
OR
A
GLOBAL
VIEW
AS
A
REQUIREMENT
THAT
THE
WORLD
BE
DIVIDED
INTO
TWO
MUTUALLY
OPPOSED
SETS
OF
FRIENDS
EACH
OF
THESE
SUGGESTS
A
WAY
OF
DEFINING
STRUCTURE
BALANCE
FOR
GENERAL
SIGNED
GRAPHS
ONE
OPTION
WOULD
BE
TO
TREAT
BALANCE
FOR
NON
COMPLETE
NETWORKS
AS
A
PROBLEM
OF
FILLING
IN
MISSING
VALUES
SUPPOSE
WE
IMAGINE
AS
A
THOUGHT
EXPERIMENT
THAT
ALL
PEOPLE
IN
THE
GROUP
IN
FACT
DO
KNOW
AND
HAVE
AN
OPINION
ON
EACH
OTHER
THE
GRAPH
UNDER
CONSIDERATION
IS
NOT
COMPLETE
ONLY
BECAUSE
WE
HAVE
FAILED
TO
OBSERVE
THE
RELATIONS
BETWEEN
SOME
OF
THE
PAIRS
WE
COULD
THEN
SAY
THAT
THE
GRAPH
IS
BALANCED
IF
IT
POSSIBLE
TO
FILL
IN
ALL
THE
MISSING
LABELED
EDGES
IN
SUCH
A
WAY
THAT
THE
RESULTING
SIGNED
COMPLETE
GRAPH
IS
BALANCED
IN
OTHER
WORDS
A
NON
COMPLETE
GRAPH
IS
BALANCED
IF
IT
CAN
BE
COMPLETED
BY
ADDING
EDGES
TO
FORM
A
SIGNED
COMPLETE
GRAPH
THAT
IS
BALANCED
FOR
EXAMPLE
FIGURE
A
SHOWS
A
GRAPH
WITH
SIGNED
EDGES
AND
FIGURE
B
SHOWS
HOW
THE
REMAINING
EDGES
CAN
BE
FILLED
IN
TO
PRODUCE
A
BALANCED
COMPLETE
GRAPH
WE
DECLARE
THE
MISSING
EDGE
BETWEEN
NODES
AND
TO
BE
POSITIVE
AND
THE
REMAINING
MISSING
EDGES
TO
BE
NEGATIVE
AND
ONE
CAN
CHECK
THAT
THIS
CAUSES
ALL
TRIANGLES
TO
BE
BALANCED
ALTERNATELY
WE
COULD
TAKE
A
MORE
GLOBAL
VIEW
VIEWING
STRUCTURAL
BALANCE
AS
IMPLYING
A
DIVISION
OF
THE
NETWORK
INTO
TWO
MUTUALLY
OPPOSED
SETS
OF
FRIENDS
WITH
THIS
IN
MIND
WE
COULD
DEFINE
A
SIGNED
GRAPH
TO
BE
BALANCED
IF
IT
IS
POSSIBLE
TO
DIVIDE
THE
NODES
INTO
TWO
SETS
X
AND
Y
SUCH
THAT
ANY
EDGE
WITH
BOTH
ENDS
INSIDE
X
OR
BOTH
ENDS
INSIDE
Y
IS
POSITIVE
AND
ANY
EDGE
WITH
ONE
END
IN
X
AND
THE
OTHER
IN
Y
IS
NEGATIVE
THAT
IS
PEOPLE
IN
X
ARE
ALL
MUTUAL
FRIENDS
TO
THE
EXTENT
THAT
THEY
KNOW
EACH
OTHER
THE
SAME
IS
TRUE
FOR
PEOPLE
IN
Y
AND
PEOPLE
IN
X
ARE
ALL
ENEMIES
OF
PEOPLE
IN
Y
TO
THE
EXTENT
THAT
THEY
KNOW
EACH
OTHER
CONTINUING
THE
EXAMPLE
FROM
FIGURE
A
IN
FIGURE
C
WE
SHOW
HOW
TO
DIVIDE
THIS
GRAPH
INTO
TWO
SETS
WITH
THE
DESIRED
PROPERTIES
THIS
EXAMPLE
HINTS
AT
A
PRINCIPLE
THAT
IS
TRUE
IN
GENERAL
THESE
TWO
WAYS
OF
DEFINING
BALANCE
ARE
EQUIVALENT
AN
ARBITRARY
SIGNED
GRAPH
IS
BALANCED
UNDER
THE
FIRST
DEFINITION
IF
AND
ONLY
IF
IT
IS
BALANCED
UNDER
THE
SECOND
DEFINITION
THIS
IS
ACTUALLY
NOT
HARD
TO
SEE
IF
A
SIGNED
GRAPH
IS
BALANCED
UNDER
THE
FIRST
DEFINITION
THEN
AFTER
FILLING
IN
ALL
THE
MISSING
EDGES
APPROPRIATELY
WE
HAVE
A
SIGNED
COMPLETE
GRAPH
TO
WHICH
WE
CAN
APPLY
THE
BALANCE
THEOREM
THIS
GIVES
US
A
DIVISION
OF
THE
NETWORK
INTO
TWO
SETS
X
AND
Y
THAT
SATISFIES
THE
PROPERTIES
OF
THE
SECOND
DEFINITION
ON
THE
OTHER
HAND
IF
A
SIGNED
GRAPH
IS
BALANCED
UNDER
THE
SECOND
DEFINITION
THEN
AFTER
FINDING
A
DIVISION
OF
THE
NODES
INTO
SETS
X
AND
Y
WE
CAN
FILL
IN
POSITIVE
EDGES
INSIDE
X
AND
INSIDE
Y
AND
FILL
IN
FIGURE
IF
A
SIGNED
GRAPH
CONTAINS
A
CYCLE
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
THEN
IT
IS
NOT
BALANCED
INDEED
IF
WE
PICK
ONE
OF
THE
NODES
AND
TRY
TO
PLACE
IT
IN
X
THEN
FOLLOWING
THE
SET
OF
FRIEND
ENEMY
RELATIONS
AROUND
THE
CYCLE
WILL
PRODUCE
A
CONFLICT
BY
THE
TIME
WE
GET
TO
THE
STARTING
NODE
NEGATIVE
EDGES
BETWEEN
X
AND
Y
AND
THEN
WE
CAN
CHECK
THAT
ALL
TRIANGLES
WILL
BE
BALANCED
SO
THIS
GIVES
A
FILLING
IN
THAT
SATISFIES
THE
FIRST
DEFINITION
THE
FACT
THAT
THE
TWO
DEFINITIONS
ARE
EQUIVALENT
SUGGESTS
A
CERTAIN
NATURALNESS
TO
THE
DEFINITION
SINCE
THERE
ARE
FUNDAMENTALLY
DIFFERENT
WAYS
TO
ARRIVE
AT
IT
IT
ALSO
LETS
US
USE
EITHER
DEFINITION
DEPENDING
ON
WHICH
IS
MORE
CONVENIENT
IN
A
GIVEN
SITUATION
AS
THE
EXAMPLE
IN
FIGURE
SUGGESTS
THE
SECOND
DEFINITION
IS
GENERALLY
MORE
USEFUL
TO
WORK
WITH
IT
TENDS
TO
BE
MUCH
EASIER
TO
THINK
ABOUT
DIVIDING
THE
NODES
INTO
TWO
SETS
THAN
TO
REASON
ABOUT
FILLING
IN
EDGES
AND
CHECKING
TRIANGLES
CHARACTERIZING
BALANCE
FOR
GENERAL
NETWORKS
CONCEPTUALLY
HOWEVER
THERE
IS
SOME
THING
NOT
FULLY
SATISFYING
ABOUT
EITHER
DEFINITION
THE
DEFINITIONS
THEMSELVES
DO
NOT
PROVIDE
MUCH
INSIGHT
INTO
HOW
TO
EASILY
CHECK
THAT
A
GRAPH
IS
BALANCED
THERE
ARE
AFTER
ALL
LOTS
OF
WAYS
TO
CHOOSE
SIGNS
FOR
THE
MISSING
EDGES
OR
TO
CHOOSE
WAYS
OF
SPLITTING
THE
NODES
INTO
SETS
X
AND
Y
AND
IF
A
GRAPH
IS
NOT
BALANCED
SO
THAT
THERE
IS
NO
WAY
TO
DO
THESE
THINGS
SUC
CESSFULLY
WHAT
COULD
YOU
SHOW
SOMEONE
TO
CONVINCE
THEM
OF
THIS
FACT
TO
TAKE
JUST
A
SMALL
EXAMPLE
TO
SUGGEST
SOME
OF
THE
DIFFICULTIES
IT
MAY
NOT
BE
OBVIOUS
FROM
A
QUICK
INSPECTION
OF
FIGURE
THAT
THIS
IS
NOT
A
BALANCED
GRAPH
OR
THAT
IF
WE
CHANGE
THE
EDGE
CONNECTING
NODES
AND
TO
BE
POSITIVE
INSTEAD
OF
NEGATIVE
IT
BECOMES
A
BALANCED
GRAPH
IN
FACT
HOWEVER
ALL
THESE
PROBLEMS
CAN
BE
REMEDIED
IF
WE
EXPLORE
THE
CONSEQUENCES
OF
THE
DEFINITIONS
A
LITTLE
FURTHER
WHAT
WE
WILL
SHOW
IS
A
SIMPLE
CHARACTERIZATION
OF
BALANCE
IN
GENERAL
SIGNED
GRAPHS
ALSO
DUE
TO
HARARY
AND
THE
PROOF
OF
THIS
CHARACTERIZATION
ALSO
PROVIDES
AN
EASY
METHOD
FOR
CHECKING
WHETHER
A
GRAPH
IS
BALANCED
THE
CHARACTERIZATION
IS
BASED
ON
CONSIDERING
THE
FOLLOWING
QUESTION
WHAT
PREVENTS
A
GRAPH
FROM
BEING
BALANCED
FIGURE
SHOWS
A
GRAPH
THAT
IS
NOT
BALANCED
OBTAINED
FROM
FIGURE
A
AND
CHANGING
THE
SIGN
OF
THE
EDGE
FROM
NODE
TO
NODE
IT
ALSO
ILLUSTRATES
A
REASON
WHY
IT
NOT
BALANCED
AS
FOLLOWS
IF
WE
START
AT
NODE
AND
TRY
TO
DIVIDE
THE
NODES
INTO
SETS
X
AND
Y
THEN
OUR
CHOICES
ARE
FORCED
AT
EVERY
STEP
SUPPOSE
WE
INITIALLY
DECIDE
THAT
NODE
SHOULD
BELONG
TO
X
FOR
THE
FIRST
NODE
IT
DOESN
T
MATTER
BY
SYMMETRY
THEN
SINCE
NODE
IS
FRIENDS
WITH
NODE
IT
TOO
MUST
BELONG
TO
X
NODE
AN
ENEMY
OF
MUST
THEREFORE
BELONG
TO
Y
HENCE
NODE
A
FRIEND
OF
MUST
BELONG
TO
Y
AS
WELL
AND
NODE
AN
ENEMY
OF
MUST
BELONG
TO
X
THE
PROBLEM
IS
THAT
IF
WE
CONTINUE
THIS
REASONING
ONE
STEP
FURTHER
THEN
NODE
AN
ENEMY
OF
SHOULD
BELONG
TO
Y
BUT
WE
HAD
ALREADY
DECIDED
AT
THE
OUTSET
TO
PUT
IT
INTO
X
WE
HAD
NO
FREEDOM
OF
CHOICE
DURING
THIS
PROCESS
SO
THIS
SHOWS
THAT
THERE
IS
NO
WAY
TO
DIVIDE
THE
NODES
IN
SETS
X
AND
Y
SO
AS
TO
SATISFY
THE
MUTUAL
FRIEND
MUTUAL
ENEMY
CONDITIONS
OF
STRUCTURAL
BALANCE
AND
HENCE
THE
SIGNED
GRAPH
IN
FIGURE
IS
NOT
BALANCED
THE
REASONING
IN
THE
PREVIOUS
PARAGRAPH
SOUNDS
ELABORATE
BUT
IN
FACT
IT
FOLLOWED
A
SIMPLE
PRINCIPLE
WE
WERE
WALKING
AROUND
A
CYCLE
AND
EVERY
TIME
WE
CROSSED
A
NEGATIVE
EDGE
WE
HAD
TO
CHANGE
THE
SET
INTO
WHICH
WE
WERE
PUTTING
NODES
THE
DIFFICULTY
WAS
THAT
GETTING
BACK
AROUND
TO
NODE
REQUIRED
CROSSING
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
AND
SO
OUR
ORIGINAL
DECISION
TO
PUT
NODE
INTO
X
CLASHED
WITH
THE
EVENTUAL
CONCLUSION
THAT
NODE
OUGHT
TO
BE
IN
Y
THIS
PRINCIPLE
APPLIES
IN
GENERAL
IF
THE
GRAPH
CONTAINS
A
CYCLE
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
THEN
THIS
IMPLIES
THE
GRAPH
IS
NOT
BALANCED
INDEED
IF
WE
START
AT
ANY
NODE
A
IN
THE
CYCLE
AND
PLACE
IT
IN
ONE
OF
THE
TWO
SETS
AND
THEN
WE
WALK
AROUND
THE
CYCLE
PLACING
THE
OTHER
NODES
WHERE
THEY
MUST
GO
THE
IDENTITY
OF
THE
SET
WHERE
WE
RE
PLACING
NODES
SWITCHES
AN
ODD
NUMBER
OF
TIMES
AS
WE
GO
AROUND
THE
CYCLE
THUS
WE
END
UP
WITH
THE
WRONG
SET
BY
THE
TIME
WE
MAKE
IT
BACK
TO
A
A
CYCLE
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
IS
THUS
A
VERY
SIMPLE
TO
UNDERSTAND
REASON
WHY
A
GRAPH
IS
NOT
BALANCED
YOU
CAN
SHOW
SOMEONE
SUCH
A
CYCLE
AND
IMMEDIATELY
CONVINCE
THEM
THAT
THE
GRAPH
IS
NOT
BALANCED
FOR
EXAMPLE
THE
CYCLE
BACK
IN
FIGURE
CONSISTING
OF
NODES
CONTAINS
FIVE
NEGATIVE
EDGES
THUS
SUPPLYING
A
SUCCINCT
REASON
WHY
THIS
GRAPH
IS
NOT
BALANCED
BUT
ARE
THERE
OTHER
MORE
COMPLEX
REASONS
WHY
A
GRAPH
IS
NOT
BALANCED
IN
FACT
THOUGH
IT
MAY
SEEM
INITIALLY
SURPRISING
CYCLES
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
ARE
THE
ONLY
OBSTACLES
TO
BALANCE
THIS
IS
THE
CRUX
OF
THE
FOLLOWING
CLAIM
CLAIM
A
SIGNED
GRAPH
IS
BALANCED
IF
AND
ONLY
IF
IT
CONTAINS
NO
CYCLE
WITH
AN
ODD
FIGURE
TO
DETERMINE
IF
A
SIGNED
GRAPH
IS
BALANCED
THE
FIRST
STEP
IS
TO
CONSIDER
ONLY
THE
POSITIVE
EDGES
FIND
THE
CONNECTED
COMPONENTS
USING
JUST
THESE
EDGES
AND
DECLARE
EACH
OF
THESE
COMPONENTS
TO
BE
A
SUPERNODE
IN
ANY
BALANCED
DIVISION
OF
THE
GRAPH
INTO
X
AND
Y
ALL
NODES
IN
THE
SAME
SUPERNODE
WILL
HAVE
TO
GO
INTO
THE
SAME
SET
NUMBER
OF
NEGATIVE
EDGES
WE
NOW
SHOW
HOW
TO
PROVE
THIS
CLAIM
THIS
IS
DONE
BY
DESIGNING
A
METHOD
THAT
ANALYZES
THE
GRAPH
AND
EITHER
FINDS
A
DIVISION
INTO
THE
DESIRED
SETS
X
AND
Y
OR
ELSE
FINDS
A
CYCLE
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
PROVING
THE
CHARACTERIZATION
IDENTIFYING
SUPERNODES
LET
RECALL
WHAT
WE
RE
TRY
ING
TO
DO
FIND
A
DIVISION
OF
THE
NODES
INTO
SETS
X
AND
Y
SO
THAT
ALL
EDGES
INSIDE
X
AND
Y
ARE
POSITIVE
AND
ALL
EDGES
CROSSING
BETWEEN
X
AND
Y
ARE
NEGATIVE
WE
WILL
CALL
A
PARTITIONING
INTO
SETS
X
AND
Y
WITH
THESE
PROPERTIES
A
BALANCED
DIVISION
WE
NOW
DESCRIBE
A
PROCEDURE
THAT
SEARCHES
FOR
A
BALANCED
DIVISION
OF
THE
NODES
INTO
SETS
X
AND
Y
EITHER
IT
SUCCEEDS
OR
IT
STOPS
WITH
A
CYCLE
CONTAINING
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
SINCE
THESE
ARE
THE
ONLY
TWO
POSSIBLE
OUTCOMES
FOR
THE
PROCEDURE
THIS
WILL
GIVE
A
PROOF
OF
THE
CLAIM
THE
PROCEDURE
WORKS
IN
TWO
MAIN
STEPS
THE
FIRST
STEP
IS
TO
CONVERT
THE
GRAPH
TO
A
REDUCED
ONE
IN
WHICH
THERE
ARE
ONLY
NEGATIVE
EDGES
AND
THE
SECOND
STEP
IS
TO
SOLVE
THE
PROBLEM
ON
THIS
REDUCED
GRAPH
THE
FIRST
STEP
WORKS
AS
FOLLOWS
NOTICE
THAT
WHENEVER
TWO
NODES
ARE
FIGURE
SUPPOSE
A
NEGATIVE
EDGE
CONNECTS
TWO
NODES
A
AND
B
THAT
BELONG
TO
THE
SAME
SUPERNODE
SINCE
THERE
IS
ALSO
A
PATH
CONSISTING
ENTIRELY
OF
POSITIVE
EDGES
THAT
CONNECTS
A
AND
B
THROUGH
THE
INSIDE
OF
THE
SUPERNODE
PUTTING
THIS
NEGATIVE
EDGE
TOGETHER
WITH
THE
ALL
POSITIVE
PATH
PRODUCES
A
CYCLE
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
CONNECTED
BY
A
POSITIVE
EDGE
THEY
MUST
BELONG
TO
THE
SAME
ONE
OF
THE
SETS
X
OR
Y
IN
A
BALANCED
DIVISION
SO
WE
BEGIN
BY
CONSIDERING
WHAT
THE
CONNECTED
COMPONENTS
OF
THE
GRAPH
WOULD
BE
IF
WE
WERE
TO
ONLY
CONSIDER
POSITIVE
EDGES
THESE
COMPONENTS
CAN
BE
VIEWED
AS
A
SET
OF
CONTIGUOUS
BLOBS
IN
THE
OVERALL
GRAPH
AS
SHOWN
IN
FIGURE
WE
WILL
REFER
TO
EACH
OF
THESE
BLOBS
AS
A
SUPERNODE
EACH
SUPERNODE
IS
CONNECTED
INTERNALLY
VIA
POSITIVE
EDGES
AND
THE
ONLY
EDGES
GOING
BETWEEN
TWO
DIFFERENT
SUPERNODES
ARE
NEGATIVE
IF
THERE
WERE
A
POSITIVE
EDGE
LINKING
TWO
DIFFERENT
SUPERNODES
WE
SHOULD
HAVE
COMBINED
THEM
TOGETHER
INTO
A
SINGLE
SUPERNODE
NOW
IF
ANY
SUPERNODE
CONTAINS
A
NEGATIVE
EDGE
BETWEEN
SOME
PAIR
OF
NODES
A
AND
B
THEN
WE
ALREADY
HAVE
A
CYCLE
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
AS
ILLUSTRATED
IN
THE
EXAMPLE
OF
FIGURE
CONSIDER
THE
PATH
OF
POSITIVE
EDGES
THAT
CONNECTS
A
AND
B
INSIDE
THE
SUPERNODE
AND
THEN
CLOSE
OFF
A
CYCLE
BY
INCLUDING
THE
NEGATIVE
EDGE
JOINING
A
AND
B
THIS
CYCLE
HAS
ONLY
A
SINGLE
NEGATIVE
EDGE
LINKING
A
AND
B
AND
SO
IT
SHOWS
THAT
THE
GRAPH
IS
NOT
BALANCED
IF
THERE
ARE
NO
NEGATIVE
EDGES
INSIDE
ANY
OF
THE
SUPERNODES
THEN
THERE
IS
NO
INTERNAL
PROBLEM
WITH
DECLARING
EACH
SUPERNODE
TO
BELONG
ENTIRELY
TO
ONE
OF
X
OR
Y
SO
THE
PROBLEM
IS
NOW
HOW
TO
ASSIGN
A
SINGLE
LABEL
X
OR
Y
TO
EACH
SUPERNODE
IN
SUCH
A
WAY
THAT
THESE
CHOICES
ARE
ALL
CONSISTENT
WITH
EACH
OTHER
SINCE
THE
DECISION
MAKING
IS
NOW
AT
THE
LEVEL
OF
SUPERNODES
WE
CREATE
A
NEW
VERSION
OF
THE
PROBLEM
IN
WHICH
THERE
IS
A
NODE
FOR
EACH
FIGURE
THE
SECOND
STEP
IN
DETERMINING
WHETHER
A
SIGNED
GRAPH
IS
BALANCED
IS
TO
LOOK
FOR
A
LABELING
OF
THE
SUPERNODES
SO
THAT
ADJACENT
SUPERNODES
WHICH
NECESSARILY
CONTAIN
MUTUAL
ENEMIES
GET
OPPOSITE
LABELS
FOR
THIS
PURPOSE
WE
CAN
IGNORE
THE
ORIGINAL
NODES
OF
THE
GRAPH
AND
CONSIDER
A
REDUCED
GRAPH
WHOSE
NODES
ARE
THE
SUPERNODES
OF
THE
ORIGINAL
GRAPH
SUPERNODE
AND
AN
EDGE
JOINING
TWO
SUPERNODES
IF
THERE
IS
AN
EDGE
IN
THE
ORIGINAL
THAT
CONNECTS
THE
TWO
SUPERNODES
FIGURE
SHOWS
HOW
THIS
WORKS
FOR
THE
EXAMPLE
OF
FIGURE
WE
ESSENTIALLY
FORGET
ABOUT
THE
INDIVIDUAL
NODES
INSIDE
THE
SUPERNODES
AND
BUILD
A
NEW
GRAPH
AT
THE
LEVEL
OF
THE
LARGE
BLOBS
OF
COURSE
HAVING
DONE
SO
WE
CAN
DRAW
THE
GRAPH
IN
A
LESS
BLOB
LIKE
WAY
AS
IN
FIGURE
WE
NOW
ENTER
THE
SECOND
STEP
OF
THE
PROCEDURE
USING
THIS
REDUCED
GRAPH
WHOSE
NODES
ARE
THE
SUPERNODES
OF
THE
ORIGINAL
GRAPH
PROVING
THE
CHARACTERIZATION
BREADTH
FIRST
SEARCH
OF
THE
REDUCED
GRAPH
RE
CALL
THAT
ONLY
NEGATIVE
EDGES
GO
BETWEEN
SUPERNODES
SINCE
A
POSITIVE
EDGE
BETWEEN
TWO
SU
PERNODES
WOULD
HAVE
MERGED
THEM
TOGETHER
INTO
A
SINGLE
ONE
AS
A
RESULT
OUR
REDUCED
GRAPH
HAS
ONLY
NEGATIVE
EDGES
THE
REMAINDER
OF
THE
PROCEDURE
WILL
PRODUCE
ONE
OF
TWO
POSSIBLE
OUTCOMES
THE
FIRST
POSSIBLE
OUTCOME
IS
TO
LABEL
EACH
NODE
IN
THE
REDUCED
GRAPH
AS
EITHER
X
OR
Y
IN
SUCH
A
WAY
THAT
EVERY
EDGE
HAS
ENDPOINTS
WITH
OPPOSITE
LABELS
FROM
THIS
WE
FIGURE
A
MORE
STANDARD
DRAWING
OF
THE
REDUCED
GRAPH
FROM
THE
PREVIOUS
FIGURE
A
NEGATIVE
CYCLE
IS
VISUALLY
APPARENT
IN
THIS
DRAWING
CAN
CREATE
A
BALANCED
DIVISION
OF
THE
ORIGINAL
GRAPH
BY
LABELING
EACH
NODE
THE
WAY
ITS
SUPERNODE
IS
LABELED
IN
THE
REDUCED
GRAPH
THE
SECOND
POSSIBLE
OUTCOME
WILL
BE
TO
FIND
A
CYCLE
IN
THE
REDUCED
GRAPH
THAT
HAS
AN
ODD
NUMBER
OF
EDGES
WE
CAN
THEN
CONVERT
THIS
TO
A
POTENTIALLY
LONGER
CYCLE
IN
THE
ORIGINAL
GRAPH
WITH
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
THE
CYCLE
IN
THE
REDUCED
GRAPH
CONNECTS
SUPERNODES
AND
CORRESPONDS
TO
A
SET
OF
NEGATIVE
EDGES
IN
THE
ORIGINAL
GRAPH
WE
CAN
SIMPLY
STITCH
TOGETHER
THESE
NEGATIVE
EDGES
USING
PATHS
CONSISTING
ENTIRELY
OF
POSITIVE
EDGES
THAT
GO
THROUGH
THE
INSIDES
OF
THE
SUPERNODES
THIS
WILL
BE
A
PATH
CONTAINING
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
IN
THE
ORIGINAL
GRAPH
FOR
EXAMPLE
THE
ODD
LENGTH
CYCLE
IN
FIGURE
THROUGH
NODES
A
THROUGH
E
CAN
BE
REALIZED
IN
THE
ORIGINAL
GRAPH
AS
THE
DARKENED
NEGATIVE
EDGES
SHOWN
IN
FIGURE
THIS
CAN
THEN
BE
TURNED
INTO
A
CYCLE
IN
THE
ORIGINAL
GRAPH
BY
INCLUDING
PATHS
THROUGH
THE
SUPERNODES
IN
THIS
EXAMPLE
USING
THE
ADDITIONAL
NODS
AND
IN
FACT
THIS
VERSION
OF
THE
PROBLEM
WHEN
THERE
ARE
ONLY
NEGATIVE
EDGES
IS
KNOWN
IN
GRAPH
THEORY
AS
THE
PROBLEM
OF
DETERMINING
WHETHER
A
GRAPH
IS
BIPARTITE
WHETHER
ITS
NODES
CAN
BE
DIVIDED
INTO
TWO
GROUPS
IN
THIS
CASE
X
AND
Y
SO
THAT
EACH
EDGE
GOES
FROM
ONE
GROUP
TO
THE
OTHER
WE
SAW
BIPARTITE
GRAPHS
WHEN
WE
CONSIDERED
AFFILIATION
NETWORKS
IN
CHAPTER
BUT
THERE
THE
FACT
THAT
THE
GRAPHS
WERE
BIPARTITE
WAS
APPARENT
FROM
THE
READY
MADE
DIVISION
OF
THE
NODES
INTO
PEOPLE
AND
SOCIAL
FOCI
HERE
ON
THE
OTHER
HAND
WE
ARE
HANDED
A
GRAPH
IN
FIGURE
HAVING
FOUND
A
NEGATIVE
CYCLE
THROUGH
THE
SUPERNODES
WE
CAN
THEN
TURN
THIS
INTO
A
CYCLE
IN
THE
ORIGINAL
GRAPH
BY
FILLING
IN
PATHS
OF
POSITIVE
EDGES
THROUGH
THE
INSIDE
OF
THE
SUPERNODES
THE
RESULTING
CYCLE
HAS
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
THE
WILD
WITH
NO
PRE
SPECIFIED
DIVISION
INTO
TWO
SETS
AND
WE
WANT
TO
KNOW
IF
IT
IS
POSSIBLE
TO
IDENTIFY
SUCH
A
DIVISION
WE
NOW
SHOW
A
WAY
TO
DO
THIS
USING
THE
IDEA
OF
BREADTH
FIRST
SEARCH
FROM
CHAPTER
RESULTING
EITHER
IN
THE
DIVISION
WE
SEEK
OR
IN
A
CYCLE
OF
ODD
LENGTH
WE
SIMPLY
PERFORM
BREADTH
FIRST
SEARCH
STARTING
FROM
ANY
ROOT
NODE
IN
THE
GRAPH
PRODUCING
A
SET
OF
LAYERS
AT
INCREASING
DISTANCES
FROM
THIS
ROOT
FIGURE
SHOWS
HOW
THIS
IS
DONE
FOR
THE
REDUCED
GRAPH
IN
FIGURE
WITH
NODE
G
AS
THE
STARTING
ROOT
NODE
NOW
BECAUSE
EDGES
CANNOT
JUMP
OVER
SUCCESSIVE
LAYERS
IN
BREADTH
FIRST
SEARCH
EACH
EDGE
EITHER
CONNECTS
TWO
NODES
IN
ADJACENT
LAYERS
OR
IT
CONNECTS
TWO
NODES
IN
THE
SAME
LAYER
IF
ALL
EDGES
ARE
OF
THE
FIRST
TYPE
THEN
WE
CAN
FIND
THE
DESIRED
DIVISION
OF
NODES
INTO
SETS
X
AND
Y
WE
SIMPLY
DECLARE
ALL
NODES
IN
EVEN
NUMBERED
LAYERS
TO
BELONG
TO
X
AND
ALL
NODES
IN
ODD
NUMBERED
LAYERS
TO
BELONG
TO
Y
SINCE
EDGES
ONLY
GO
BETWEEN
ADJACENT
LAYERS
ALL
EDGES
HAVE
ONE
END
IN
X
AND
THE
OTHER
END
IN
Y
AS
DESIRED
OTHERWISE
THERE
IS
AN
EDGE
CONNECTING
TWO
NODES
THAT
BELONG
TO
THE
SAME
LAYER
LET
CALL
THEM
A
AND
B
AS
THEY
ARE
IN
FIGURE
FOR
EACH
OF
THESE
TWO
NODES
THERE
IS
A
PATH
THAT
DESCENDS
LAYER
BY
LAYER
FROM
THE
ROOT
TO
IT
CONSIDER
THE
LAST
NODE
THAT
IS
COMMON
TO
THESE
TWO
PATHS
LET
CALL
THIS
NODE
D
AS
IT
IS
IN
FIGURE
THE
D
A
PATH
AND
THE
FIGURE
WHEN
WE
PERFORM
A
BREADTH
FIRST
SEARCH
OF
THE
REDUCED
GRAPH
THERE
IS
EITHER
AN
EDGE
CONNECTING
TWO
NODES
IN
THE
SAME
LAYER
OR
THERE
ISN
T
IF
THERE
ISN
T
THEN
WE
CAN
PRODUCE
THE
DESIRED
DIVISION
INTO
X
AND
Y
BY
PUTTING
ALTERNATE
LAYERS
IN
DIFFERENT
SETS
IF
THERE
IS
SUCH
AN
EDGE
SUCH
AS
THE
EDGE
JOINING
A
AND
B
IN
THE
FIGURE
THEN
WE
CAN
TAKE
TWO
PATHS
OF
THE
SAME
LENGTH
LEADING
TO
THE
TWO
ENDS
OF
THE
EDGE
WHICH
TOGETHER
WITH
THE
EDGE
ITSELF
FORMS
AN
ODD
CYCLE
D
B
PATH
HAVE
THE
SAME
LENGTH
K
SO
A
CYCLE
CREATED
FROM
THE
TWO
OF
THESE
PLUS
THE
A
B
EDGE
MUST
HAVE
LENGTH
AN
ODD
NUMBER
THIS
IS
THE
ODD
CYCLE
WE
SEEK
AND
THIS
COMPLETES
THE
PROOF
TO
RECAP
IF
ALL
EDGES
IN
THE
REDUCED
GRAPH
CONNECT
NODES
IN
ADJACENT
LAYERS
OF
THE
BREADTH
FIRST
SEARCH
THEN
WE
HAVE
A
WAY
TO
LABEL
THE
NODES
IN
THE
REDUCED
GRAPH
AS
INTO
X
AND
Y
WHICH
IN
TURN
PROVIDES
A
BALANCED
DIVISION
OF
THE
NODES
IN
THE
ORIGINAL
GRAPH
INTO
X
AND
Y
IN
THIS
CASE
WE
VE
ESTABLISHED
THAT
THE
GRAPH
IS
BALANCED
OTHERWISE
THERE
IS
AN
EDGE
CONNECTING
TWO
NODES
IN
THE
SAME
LAYER
OF
THE
BREADTH
FIRST
SEARCH
IN
WHICH
CASE
WE
PRODUCE
AN
ODD
CYCLE
IN
THE
REDUCED
GRAPH
AS
IN
FIGURE
IN
THIS
CASE
WE
CAN
CONVERT
INTO
THIS
TO
A
CYCLE
IN
THE
ORIGINAL
GRAPH
CONTAINING
AN
ODD
NUMBER
OF
NEGATIVE
EDGES
AS
IN
FIGURE
SINCE
THESE
ARE
THE
ONLY
TWO
POSSIBILITIES
THIS
PROVES
THE
CLAIM
B
APPROXIMATELY
BALANCED
NETWORKS
WE
NOW
RETURN
TO
THE
CASE
IN
WHICH
THE
GRAPH
IS
COMPLETE
SO
THAT
EVERY
NODE
HAS
A
POSITIVE
OR
NEGATIVE
RELATION
WITH
EVERY
OTHER
NODE
AND
WE
THINK
ABOUT
A
DIFFERENT
WAY
OF
GENERALIZING
THE
CHARACTERIZATION
OF
STRUCTURAL
BALANCE
FIRST
LET
WRITE
DOWN
THE
ORIGINAL
BALANCE
THEOREM
AGAIN
WITH
SOME
ADDITIONAL
FORMAT
TING
TO
MAKE
ITS
LOGICAL
STRUCTURE
CLEAR
CLAIM
IF
ALL
TRIANGLES
IN
A
LABELED
COMPLETE
GRAPH
ARE
BALANCED
THEN
EITHER
A
ALL
PAIRS
OF
NODES
ARE
FRIENDS
OR
ELSE
B
THE
NODES
CAN
BE
DIVIDED
INTO
TWO
GROUPS
X
AND
Y
SUCH
THAT
I
EVERY
PAIR
OF
NODES
IN
X
LIKE
EACH
OTHER
II
EVERY
PAIR
OF
NODES
IN
Y
LIKE
EACH
OTHER
AND
III
EVERYONE
IN
X
IS
THE
ENEMY
OF
EVERYONE
IN
Y
THE
CONDITIONS
OF
THIS
THEOREM
ARE
FAIRLY
EXTREME
IN
THAT
WE
REQUIRE
EVERY
SINGLE
TRIANGLE
TO
BE
BALANCED
WHAT
IF
WE
ONLY
KNOW
THAT
MOST
TRIANGLES
ARE
BALANCED
IT
TURNS
OUT
THAT
THE
CONDITIONS
OF
THE
THEOREM
CAN
BE
RELAXED
IN
A
VERY
NATURAL
WAY
ALLOWING
US
TO
PROVE
STATEMENTS
LIKE
THE
FOLLOWING
ONE
WE
PHRASE
IT
SO
THAT
THE
WORDING
REMAINS
COMPLETELY
PARALLEL
TO
THAT
OF
THE
BALANCE
THEOREM
CLAIM
IF
AT
LEAST
OF
ALL
TRIANGLES
IN
A
LABELED
COMPLETE
GRAPH
ARE
BALANCED
THEN
EITHER
A
THERE
IS
A
SET
CONSISTING
OF
AT
LEAST
OF
THE
NODES
IN
WHICH
AT
LEAST
OF
ALL
PAIRS
ARE
FRIENDS
OR
ELSE
B
THE
NODES
CAN
BE
DIVIDED
INTO
TWO
GROUPS
X
AND
Y
SUCH
THAT
I
AT
LEAST
OF
THE
PAIRS
IN
X
LIKE
EACH
OTHER
II
AT
LEAST
OF
THE
PAIRS
IN
Y
LIKE
EACH
OTHER
AND
III
AT
LEAST
OF
THE
PAIRS
WITH
ONE
END
IN
X
AND
THE
OTHER
END
IN
Y
ARE
ENEMIES
THIS
IS
A
TRUE
STATEMENT
THOUGH
THE
CHOICE
OF
NUMBERS
IS
VERY
SPECIFIC
HERE
IS
A
MORE
GENERAL
STATEMENT
THAT
INCLUDES
BOTH
THE
BALANCE
THEOREM
AND
THE
PRECEDING
CLAIM
AS
SPECIAL
CASES
CLAIM
LET

BE
ANY
NUMBER
SUCH
THAT

AND
DEFINE


IF
AT
LEAST

OF
ALL
TRIANGLES
IN
A
LABELED
COMPLETE
GRAPH
ARE
BALANCED
THEN
EITHER
A
THERE
IS
A
SET
CONSISTING
OF
AT
LEAST

OF
THE
NODES
IN
WHICH
AT
LEAST

OF
ALL
PAIRS
ARE
FRIENDS
OR
ELSE
B
THE
NODES
CAN
BE
DIVIDED
INTO
TWO
GROUPS
X
AND
Y
SUCH
THAT
I
AT
LEAST

OF
THE
PAIRS
IN
X
LIKE
EACH
OTHER
II
AT
LEAST

OF
THE
PAIRS
IN
Y
LIKE
EACH
OTHER
AND
III
AT
LEAST

OF
THE
PAIRS
WITH
ONE
END
IN
X
AND
THE
OTHER
END
IN
Y
ARE
ENEMIES
NOTICE
THAT
THE
BALANCE
THEOREM
IS
THE
CASE
IN
WHICH

AND
THE
OTHER
CLAIM
ABOVE
IS
THE
CASE
IN
WHICH

SINCE
IN
THIS
LATTER
CASE


WE
NOW
PROVE
THIS
LAST
CLAIM
THE
PROOF
IS
SELF
CONTAINED
BUT
IT
IS
MOST
EASILY
READ
WITH
SOME
PRIOR
EXPERIENCE
IN
WHAT
IS
SOMETIMES
CALLED
THE
ANALYSIS
OF
PERMUTATIONS
AND
COMBINATIONS
COUNTING
THE
NUMBER
OF
WAYS
TO
CHOOSE
PARTICULAR
SUBSETS
OF
LARGER
SETS
THE
PROOF
LOOSELY
FOLLOWS
THE
STYLE
OF
THE
PROOF
WE
USED
FOR
THE
BALANCE
THEOREM
WE
WILL
DEFINE
THE
TWO
SETS
X
AND
Y
TO
BE
THE
FRIENDS
AND
ENEMIES
RESPECTIVELY
OF
A
DESIGNATED
NODE
A
THINGS
ARE
TRICKIER
HERE
HOWEVER
BECAUSE
NOT
ALL
CHOICES
OF
A
WILL
GIVE
US
THE
STRUCTURE
WE
NEED
IN
PARTICULAR
IF
A
NODE
IS
PERSONALLY
INVOLVED
IN
TOO
MANY
UNBALANCED
TRIANGLES
THEN
SPLITTING
THE
GRAPH
INTO
ITS
FRIENDS
AND
ENEMIES
MAY
GIVE
A
VERY
DISORDERED
STRUCTURE
CONSEQUENTLY
THE
PROOF
CONSISTS
OF
TWO
STEPS
WE
FIRST
FIND
A
GOOD
NODE
THAT
IS
NOT
INVOLVED
IN
TOO
MANY
UNBALANCED
TRIANGLES
WE
THEN
SHOW
THAT
IF
WE
DIVIDE
THE
GRAPH
INTO
THE
FRIENDS
AND
ENEMIES
OF
THIS
GOOD
NODE
WE
HAVE
THE
DESIRED
PROPERTIES
WARM
UP
COUNTING
EDGES
AND
TRIANGLES
BEFORE
LAUNCHING
INTO
THE
PROOF
ITSELF
LET
CONSIDER
SOME
BASIC
COUNTING
QUESTIONS
THAT
WILL
SHOW
UP
AS
INGREDIENTS
IN
THE
PROOF
RECALL
THAT
WE
HAVE
A
COMPLETE
GRAPH
WITH
AN
UNDIRECTED
EDGE
JOINING
EACH
PAIR
OF
NODES
IF
N
IS
THE
NUMBER
OF
NODES
IN
THE
GRAPH
HOW
MANY
EDGES
ARE
THERE
WE
CAN
COUNT
THIS
QUANTITY
AS
FOLLOWS
THERE
ARE
N
POSSIBLE
WAYS
TO
CHOOSE
ONE
OF
THE
TWO
ENDPOINTS
AND
THEN
N
POSSIBLE
WAYS
TO
CHOOSE
A
DIFFERENT
NODE
AS
THE
OTHER
ENDPOINT
FOR
A
TOTAL
OF
N
N
POSSIBLE
WAYS
TO
CHOOSE
THE
TWO
ENDPOINTS
IN
SUCCESSION
IF
WE
WRITE
DOWN
A
LIST
OF
ALL
THESE
POSSIBLE
PAIRS
OF
ENDPOINTS
THEN
AN
EDGE
WITH
ENDPOINTS
A
AND
B
WILL
APPEAR
TWICE
ON
THE
LIST
ONCE
AS
AB
AND
ONCE
AS
BA
IN
GENERAL
EACH
EDGE
WILL
APPEAR
TWICE
ON
THE
LIST
AND
SO
THE
TOTAL
NUMBER
OF
EDGES
IS
N
N
A
VERY
SIMILAR
ARGUMENT
LETS
US
COUNT
THE
TOTAL
NUMBER
OF
TRIANGLES
IN
THE
GRAPH
SPECIF
ICALLY
THERE
ARE
N
WAYS
TO
PICK
THE
FIRST
CORNER
THEN
N
WAYS
TO
PICK
A
DIFFERENT
NODE
AS
THE
SECOND
CORNER
AND
THEN
N
WAYS
TO
PICK
A
THIRD
CORNER
DIFFERENT
FROM
THE
FIRST
TWO
THIS
YIELDS
A
TOTAL
OF
N
N
N
SEQUENCES
OF
THREE
CORNERS
IF
WE
WRITE
DOWN
THIS
LIST
OF
N
N
N
SEQUENCES
THEN
A
TRIANGLE
WITH
CORNERS
A
B
AND
C
WILL
APPEAR
SIX
TIMES
AS
ABC
ACB
BAC
BCA
CAB
AND
CBA
IN
GENERAL
EACH
TRIANGLE
WILL
APPEAR
SIX
TIMES
IN
THIS
LIST
AND
SO
THE
TOTAL
NUMBER
OF
TRIANGLES
IS
N
N
N
THE
FIRST
STEP
FINDING
A
GOOD
NODE
NOW
LET
MOVE
ON
TO
THE
FIRST
STEP
OF
THE
PROOF
WHICH
IS
TO
FIND
A
NODE
THAT
ISN
T
INVOLVED
IN
TOO
MANY
UNBALANCED
TRIANGLES
SINCE
WE
ARE
ASSUMING
THAT
AT
MOST
AN

FRACTION
OF
TRIANGLES
ARE
UNBALANCED
AND
THE
TOTAL
NUMBER
OF
TRIANGLES
IN
THE
GRAPH
IS
N
N
N
IT
FOLLOWS
THAT
THE
TOTAL
NUMBER
OF
UNBALANCED
TRIANGLES
IS
AT
MOST
N
N
N
SUPPOSE
WE
DEFINE
THE
WEIGHT
OF
A
NODE
TO
BE
THE
NUMBER
OF
UNBALANCED
TRIANGLES
THAT
IT
IS
A
PART
OF
THUS
A
NODE
OF
LOW
WEIGHT
WILL
BE
PRECISELY
WHAT
WE
RE
SEEKING
A
NODE
THAT
IS
IN
RELATIVELY
FEW
UNBALANCED
TRIANGLES
ONE
WAY
TO
COUNT
THE
TOTAL
WEIGHT
OF
ALL
NODES
WOULD
BE
TO
LIST
FOR
EACH
NODE
THE
UNBALANCED
TRIANGLES
THAT
IT
BELONGS
TO
AND
THEN
LOOK
AT
THE
LENGTH
OF
ALL
THESE
LISTS
COMBINED
IN
THESE
COMBINED
LISTS
EACH
TRIANGLE
WILL
APPEAR
THREE
TIMES
ONCE
IN
THE
LIST
FOR
EACH
OF
ITS
CORNERS
AND
SO
THE
TOTAL
WEIGHT
OF
ALL
NODES
IS
EXACTLY
THREE
TIMES
THE
NUMBER
OF
UNBALANCED
TRIANGLES
AS
A
RESULT
THE
TOTAL
WEIGHT
OF
ALL
NODES
IS
AT
MOST
N
N
N
N
N
THERE
ARE
N
NODES
SO
THE
AVERAGE
WEIGHT
OF
A
NODE
IS
AT
MOST

N
N
IT
NOT
POSSIBLE
FOR
ALL
NODES
TO
HAVE
WEIGHTS
THAT
ARE
STRICTLY
ABOVE
THE
AVERAGE
SO
THERE
IS
AT
LEAST
ONE
NODE
WHOSE
WEIGHT
IS
EQUAL
TO
THE
AVERAGE
OR
BELOW
IT
LET
PICK
ONE
SUCH
NODE
AND
CALL
IT
A
THIS
WILL
BE
OUR
GOOD
NODE
A
NODE
WHOSE
WEIGHT
IS
AT
MOST

N
N
SINCE
N
N
N
THIS
GOOD
NODE
IS
IN
AT
MOST
N
TRIANGLES
AND
BECAUSE
THE
ALGEBRA
IS
A
BIT
SIMPLER
WITH
THIS
SLIGHTLY
LARGER
QUANTITY
WE
WILL
USE
IT
IN
THE
REST
OF
THE
ANALYSIS
THE
SECOND
STEP
SPLITTING
THE
GRAPH
ACCORDING
TO
THE
GOOD
NODE
BY
ANALOGY
WITH
THE
PROOF
OF
THE
BALANCE
THEOREM
WE
DIVIDE
THE
GRAPH
INTO
TWO
SETS
A
SET
X
CONSISTING
OF
A
AND
ALL
ITS
FRIENDS
AND
A
SET
Y
CONSISTING
OF
ALL
THE
ENEMIES
OF
A
AS
ILLUSTRATED
IN
FIGURE
NOW
USING
THE
DEFINITION
OF
UNBALANCED
TRIANGLES
AND
THE
FACT
THAT
NODE
A
IS
NOT
INVOLVED
IN
TOO
MANY
OF
THEM
WE
CAN
ARGUE
THAT
THERE
ARE
RELATIVELY
FEW
NEGATIVE
EDGES
INSIDE
EACH
OF
X
AND
Y
AND
RELATIVELY
FEW
POSITIVE
EDGES
BETWEEN
THEM
SPECIFICALLY
THIS
WORKS
AS
FOLLOWS
EACH
NEGATIVE
EDGE
CONNECTING
TWO
NODES
IN
X
CREATES
A
DISTINCT
UNBALANCED
TRIANGLE
INVOLVING
NODE
A
SINCE
THERE
ARE
AT
MOST
N
UNBALANCED
TRIANGLES
INVOLVING
A
THERE
ARE
AT
MOST
N
NEGATIVE
EDGES
INSIDE
X
A
CLOSELY
ANALOGOUS
ARGUMENT
APPLIES
TO
Y
EACH
NEGATIVE
EDGE
CONNECTING
TWO
NODES
IN
Y
CREATES
A
DISTINCT
UNBALANCED
TRIANGLE
INVOLVING
NODE
A
AND
SO
THERE
ARE
AT
MOST
N
NEGATIVE
EDGES
INSIDE
Y
IS
A
VERY
COMMON
TRICK
IN
COUNTING
ARGUMENTS
REFERRED
TO
AS
THE
PIGEONHOLE
PRINCIPLE
TO
COMPUTE
THE
AVERAGE
VALUE
OF
A
SET
OF
OBJECTS
AND
THEN
ARGUE
THAT
THERE
MUST
BE
AT
LEAST
ONE
NODE
THAT
IS
EQUAL
TO
THE
AVERAGE
OR
BELOW
ALSO
OF
COURSE
THERE
MUST
BE
AT
LEAST
AT
LEAST
ONE
OBJECT
THAT
IS
EQUAL
TO
THE
AVERAGE
OR
ABOVE
ALTHOUGH
THIS
OBSERVATION
ISN
T
USEFUL
FOR
OUR
PURPOSES
HERE
FRIENDS
OF
A
A
GOOD
NODE
A
ENEMIES
OF
A
FIGURE
THE
CHARACTERIZATION
OF
APPROXIMATELY
BALANCED
COMPLETE
GRAPHS
FOLLOWS
FROM
AN
ANALYSIS
SIMILAR
TO
THE
PROOF
OF
THE
ORIGINAL
BALANCE
THEOREM
HOWEVER
WE
HAVE
TO
BE
MORE
CAREFUL
IN
DIVIDING
THE
GRAPH
BY
FIRST
FINDING
A
GOOD
NODE
THAT
ISN
T
INVOLVED
IN
TOO
MANY
UNBALANCED
TRIANGLES
AND
FINALLY
AN
ANALOGOUS
ARGUMENT
APPLIES
TO
EDGES
WITH
ONE
END
IN
X
AND
THE
OTHER
END
IN
Y
EACH
SUCH
EDGE
THAT
IS
POSITIVE
CREATES
A
DISTINCT
UNBALANCED
TRIANGLE
IN
VOLVING
A
AND
SO
THERE
ARE
AT
MOST
N
POSITIVE
EDGES
WITH
ONE
END
IN
X
AND
THE
OTHER
END
IN
Y
WE
NOW
CONSIDER
SEVERAL
POSSIBLE
CASES
DEPENDING
ON
THE
SIZES
OF
THE
SETS
X
AND
Y
ESSEN
TIALLY
IF
EITHER
OF
X
OR
Y
CONSISTS
OF
ALMOST
THE
ENTIRE
GRAPH
THEN
WE
SHOW
THAT
ALTERNATIVE
A
IN
THE
CLAIM
HOLDS
OTHERWISE
IF
EACH
OF
X
AND
Y
CONTAIN
A
NON
NEGLIGIBLE
NUMBER
OF
NODES
THEN
WE
SHOW
THAT
ALTERNATIVE
B
IN
THE
CLAIM
HOLDS
WE
RE
ALSO
GOING
TO
ASSUME
TO
MAKE
THE
CALCULATIONS
SIMPLER
THAT
N
IS
EVEN
AND
THAT
THE
QUANTITY
N
IS
A
WHOLE
NUMBER
ALTHOUGH
THIS
IS
NOT
IN
FACT
NECESSARY
FOR
THE
PROOF
TO
START
LET
X
BE
THE
NUMBER
OF
NODES
IN
X
AND
Y
BE
THE
NUMBER
OF
NODES
IN
Y
SUPPOSE
FIRST
THAT
X

N
SINCE

AND


IT
FOLLOWS
THAT

AND
SO
X
N
NOW
RECALL
OUR
EARLIER
COUNTING
ARGUMENT
THAT
GAVE
A
FORMULA
FOR
THE
NUMBER
OF
EDGES
IN
A
COMPLETE
GRAPH
IN
TERMS
OF
ITS
NUMBER
OF
NODES
IN
THIS
CASE
X
HAS
X
NODES
SO
IT
HAS
X
X
EDGES
SINCE
X
N
THIS
NUMBER
OF
EDGES
IS
AT
LEAST
N
N
N
N
THERE
ARE
AT
MOST
N
NEGATIVE
EDGES
INSIDE
X
AND
SO
THE
FRACTION
OF
NEGATIVE
EDGES
INSIDE
X
IS
AT
MOST
N
N

WHERE
WE
USE
THE
FACTS
THAT

AND

WE
THUS
CONCLUDE
THAT
IF
X
CONTAINS
AT
LEAST

N
NODES
THEN
IT
IS
A
SET
CONTAINING
AT
LEAST
A

FRACTION
OF
THE
NODES
IN
WHICH
AT
LEAST

OF
ALL
PAIRS
ARE
FRIENDS
SATISFYING
PART
A
IN
THE
CONCLUSION
OF
THE
CLAIM
THE
SAME
ARGUMENT
CAN
BE
APPLIED
IF
Y
CONTAINS
AT
LEAST

N
NODES
THUS
WE
ARE
LEFT
WITH
THE
CASE
IN
WHICH
BOTH
X
AND
Y
CONTAIN
STRICTLY
FEWER
THAN

N
AND
IN
THIS
CASE
WE
WILL
SHOW
THAT
PART
B
IN
THE
CONCLUSION
OF
THE
CLAIM
HOLDS
FIRST
OF
ALL
THE
EDGES
WITH
ONE
END
IN
X
AND
THE
OTHER
IN
Y
WHAT
FRACTION
ARE
POSITIVE
THE
TOTAL
NUMBER
OF
EDGES
WITH
ONE
END
IN
X
AND
THE
OTHER
END
IN
Y
CAN
BE
COUNTED
AS
FOLLOWS
THERE
ARE
X
WAYS
TO
CHOOSE
THE
END
IN
X
AND
THEN
Y
WAYS
TO
CHOOSE
THE
END
IN
Y
FOR
A
TOTAL
OF
XY
SUCH
EDGES
NOW
SINCE
EACH
OF
X
AND
Y
ARE
LESS
THAN

N
AND
THEY
ADD
UP
TO
N
THIS
PRODUCT
XY
IS
AT
LEAST
N

N


N
N
WHERE
THE
LAST
INEQUALITY
FOLLOWS
FROM
THE
FACT
THAT

THERE
ARE
AT
MOST
N
POSITIVE
EDGES
WITH
ONE
END
IN
X
AND
THE
OTHER
IN
Y
SO
AS
A
FRACTION
OF
THE
TOTAL
THIS
IS
AT
MOST
N

N



FINALLY
WHAT
FRACTION
OF
EDGES
INSIDE
EACH
OF
X
AND
Y
ARE
NEGATIVE
LET
CALCULATE
THIS
FOR
X
THE
ARGUMENT
FOR
Y
IS
EXACTLY
THE
SAME
THERE
ARE
X
X
EDGES
INSIDE
X
IN
TOTAL
AND
SINCE
WE
RE
IN
THE
CASE
WHERE
X
N
THIS
TOTAL
NUMBER
OF
EDGES
IS
AT
LEAST
N
N
N
THERE
ARE
AT
MOST
N
NEGATIVE
EDGES
INSIDE
X
SO
AS
A
FRACTION
OF
THE
TOTAL
THIS
IS
AT
MOST
N


THUS
THE
DIVISION
OF
NODES
INTO
SETS
X
AND
Y
SATISFIES
ALL
THE
REQUIREMENTS
IN
CONCLUSION
B
OF
THE
CLAIM
AND
SO
THE
PROOF
IS
COMPLETE
AS
A
FINAL
COMMENT
ON
THE
CLAIM
AND
ITS
PROOF
ONE
MIGHT
FEEL
THAT
THE
DIFFERENCE
BETWEEN

IN
THE
ASSUMPTION
OF
THE
CLAIM
AND

IS
A
BIT
EXCESSIVE
AS
WE
SAW
ABOVE
WHEN

THIS
MEANS
WE
NEED
TO
ASSUME
THAT
OF
ALL
TRIANGLES
ARE
BALANCED
IN
ORDER
TO
GET
SETS
WITH
A
DENSITY
OF
EDGES
HAVING
THE
CORRECT
SIGN
BUT
IN
FACT
IT
IS
POSSIBLE
TO
CONSTRUCT
EXAMPLES
SHOWING
THAT
THIS
RELATIONSHIP
BETWEEN

AND

IS
IN
FACT
ESSENTIALLY
THE
BEST
ONE
CAN
DO
IN
SHORT
THE
CLAIM
PROVIDES
THE
KIND
OF
APPROXIMATE
VERSION
OF
THE
BALANCE
THEOREM
THAT
WE
WANTED
AT
A
QUALITATIVE
LEVEL
BUT
WE
NEED
TO
ASSUME
A
FAIRLY
SMALL
FRACTION
OF
UNBALANCED
TRIANGLES
IN
ORDER
TO
BE
ABLE
TO
START
DRAWING
STRONG
CONCLUSIONS
EXERCISES
SUPPOSE
THAT
A
TEAM
OF
ANTHROPOLOGISTS
IS
STUDYING
A
SET
OF
THREE
SMALL
VILLAGES
THAT
NEIGHBOR
ONE
ANOTHER
EACH
VILLAGE
HAS
PEOPLE
CONSISTING
OF
EXTENDED
FAMILIES
EVERYONE
IN
EACH
VILLAGE
KNOWS
ALL
THE
PEOPLE
IN
THEIR
OWN
VILLAGE
AS
WELL
AS
THE
PEOPLE
IN
THE
OTHER
VILLAGES
WHEN
THE
ANTHROPOLOGISTS
BUILD
THE
SOCIAL
NETWORK
ON
THE
PEOPLE
IN
ALL
THREE
VILLAGES
TAKEN
TOGETHER
THEY
FIND
THAT
EACH
PERSON
IS
FRIENDS
WITH
ALL
THE
OTHER
PEOPLE
IN
THEIR
OWN
VILLAGE
AND
ENEMIES
WITH
EVERYONE
IN
THE
TWO
OTHER
VILLAGES
THIS
GIVES
THEM
A
NETWORK
ON
PEOPLE
I
E
IN
EACH
VILLAGE
WITH
POSITIVE
AND
NEGATIVE
SIGNS
ON
ITS
EDGES
ACCORDING
TO
THE
DEFINITIONS
IN
THIS
CHAPTER
IS
THIS
NETWORK
ON
PEOPLE
BALANCED
GIVE
A
BRIEF
EXPLANATION
FOR
YOUR
ANSWER
CONSIDER
THE
NETWORK
SHOWN
IN
FIGURE
THERE
IS
AN
EDGE
BETWEEN
EACH
PAIR
OF
NODES
WITH
FIVE
OF
THE
EDGES
CORRESPONDING
TO
POSITIVE
RELATIONSHIPS
AND
THE
OTHER
FIVE
OF
THE
EDGES
CORRESPONDING
TO
NEGATIVE
RELATIONSHIPS
FIGURE
A
NETWORK
WITH
FIVE
POSITIVE
EDGES
AND
FIVE
NEGATIVE
EDGES
EACH
EDGE
IN
THIS
NETWORK
PARTICIPATES
IN
THREE
TRIANGLES
ONE
FORMED
BY
EACH
OF
THE
ADDITIONAL
NODES
WHO
IS
NOT
ALREADY
AN
ENDPOINT
OF
THE
EDGE
FOR
EXAMPLE
THE
A
B
EDGE
PARTICIPATES
IN
A
TRIANGLE
ON
A
B
AND
C
A
TRIANGLE
ON
A
B
AND
D
AND
A
TRIANGLE
ON
A
B
AND
E
WE
CAN
LIST
TRIANGLES
FOR
THE
OTHER
EDGES
IN
A
SIMILAR
WAY
FOR
EACH
EDGE
HOW
MANY
OF
THE
TRIANGLES
IT
PARTICIPATES
IN
ARE
BALANCED
AND
HOW
MANY
ARE
UNBALANCED
NOTICE
THAT
BECAUSE
OF
THE
SYMMETRY
OF
THE
NETWORK
THE
ANSWER
WILL
BE
THE
SAME
FOR
EACH
POSITIVE
EDGE
AND
ALSO
FOR
EACH
NEGATIVE
EDGE
SO
IT
IS
ENOUGH
TO
CONSIDER
THIS
FOR
ONE
OF
THE
POSITIVE
EDGES
AND
ONE
OF
THE
NEGATIVE
EDGES
WHEN
WE
THINK
ABOUT
STRUCTURAL
BALANCE
WE
CAN
ASK
WHAT
HAPPENS
WHEN
A
NEW
NODE
TRIES
TO
JOIN
A
NETWORK
IN
WHICH
THERE
IS
EXISTING
FRIENDSHIP
AND
HOSTILITY
IN
FIG
URES
EACH
PAIR
OF
NODES
IS
EITHER
FRIENDLY
OR
HOSTILE
AS
INDICATED
BY
THE
OR
LABEL
ON
EACH
EDGE
FIGURE
A
NODE
SOCIAL
NETWORK
IN
WHICH
ALL
PAIRS
OF
NODES
KNOW
EACH
OTHER
AND
ALL
PAIRS
OF
NODES
ARE
FRIENDLY
TOWARD
EACH
OTHER
A
D
JOINS
THE
NETWORK
BY
BECOM
ING
FRIENDS
WITH
ALL
NODES
B
D
JOINS
THE
NETWORK
BY
BECOM
ING
ENEMIES
WITH
ALL
NODES
FIGURE
THERE
ARE
TWO
DISTINCT
WAYS
IN
WHICH
NODE
D
CAN
JOIN
THE
SOCIAL
NETWORK
FROM
FIGURE
WITHOUT
BECOMING
INVOLVED
IN
ANY
UNBALANCED
TRIANGLES
FIRST
CONSIDER
THE
NODE
SOCIAL
NETWORK
IN
FIGURE
IN
WHICH
ALL
PAIRS
OF
NODES
KNOW
EACH
OTHER
AND
ALL
PAIRS
OF
NODES
ARE
FRIENDLY
TOWARD
EACH
OTHER
NOW
A
FOURTH
NODE
D
WANTS
TO
JOIN
THIS
NETWORK
AND
ESTABLISH
EITHER
POSITIVE
OR
NEGATIVE
RELATIONS
WITH
EACH
EXISTING
NODE
A
B
AND
C
IT
WANTS
TO
DO
THIS
IN
SUCH
A
WAY
THAT
IT
DOESN
T
BECOME
INVOLVED
IN
ANY
UNBALANCED
TRIANGLES
I
E
SO
THAT
AFTER
ADDING
D
AND
THE
LABELED
EDGES
FROM
D
THERE
ARE
NO
UNBALANCED
TRIANGLES
THAT
CONTAIN
D
IS
THIS
POSSIBLE
IN
FACT
IN
THIS
EXAMPLE
THERE
ARE
TWO
WAYS
FOR
D
TO
ACCOMPLISH
THIS
AS
INDICATED
IN
FIGURE
FIRST
D
CAN
BECOME
FRIENDS
WITH
ALL
EXISTING
NODES
IN
THIS
WAY
ALL
THE
TRIANGLES
CONTAINING
IT
HAVE
THREE
POSITIVE
EDGES
AND
SO
ARE
BALANCED
ALTERNATELY
IT
CAN
BECOME
ENEMIES
WITH
ALL
EXISTING
NODES
IN
THIS
WAY
EACH
TRIANGLE
CONTAINING
IT
HAS
EXACTLY
ONE
POSITIVE
EDGE
AND
AGAIN
THESE
TRIANGLES
WOULD
BE
BALANCED
SO
FOR
THIS
NETWORK
IT
WAS
POSSIBLE
FOR
D
TO
JOIN
WITHOUT
BECOMING
INVOLVED
IN
ANY
UNBALANCED
TRIANGLES
HOWEVER
THE
SAME
IS
NOT
NECESSARILY
POSSIBLE
FOR
OTHER
NETWORKS
WE
NOW
CONSIDER
THIS
KIND
OF
QUESTION
FOR
SOME
OTHER
NETWORKS
FIGURE
ALL
THREE
NODES
ARE
MUTUAL
ENEMIES
A
CONSIDER
THE
NODE
SOCIAL
NETWORK
IN
FIGURE
IN
WHICH
ALL
PAIRS
OF
NODES
KNOW
EACH
OTHER
AND
EACH
PAIR
IS
EITHER
FRIENDLY
OR
HOSTILE
AS
INDICATED
BY
THE
OR
LABEL
ON
EACH
EDGE
A
FOURTH
NODE
D
WANTS
TO
JOIN
THIS
NETWORK
AND
ESTABLISH
EITHER
POSITIVE
OR
NEGATIVE
RELATIONS
WITH
EACH
EXISTING
NODE
A
B
AND
C
CAN
NODE
D
DO
THIS
IN
SUCH
A
WAY
THAT
IT
DOESN
T
BECOME
INVOLVED
IN
ANY
UNBALANCED
TRIANGLES
IF
THERE
IS
A
WAY
FOR
D
TO
DO
THIS
SAY
HOW
MANY
DIFFERENT
SUCH
WAYS
THERE
ARE
AND
GIVE
AN
EXPLANATION
THAT
IS
HOW
MANY
DIFFERENT
POSSIBLE
LABELINGS
OF
THE
EDGES
OUT
OF
D
HAVE
THE
PROPERTY
THAT
ALL
TRIANGLES
CONTAINING
D
ARE
BALANCED
IF
THERE
IS
NO
SUCH
WAY
FOR
D
TO
DO
THIS
GIVE
AN
EXPLANATION
WHY
NOT
IN
THIS
AND
THE
SUBSEQUENT
QUESTIONS
IT
POSSIBLE
TO
WORK
OUT
AN
ANSWER
BY
REA
SONING
ABOUT
THE
NEW
NODE
OPTIONS
WITHOUT
HAVING
TO
CHECK
ALL
POSSIBILITIES
B
SAME
QUESTION
BUT
FOR
A
DIFFERENT
NETWORK
CONSIDER
THE
NODE
SOCIAL
NETWORK
IN
FIGURE
IN
WHICH
ALL
PAIRS
OF
NODES
KNOW
EACH
OTHER
AND
EACH
PAIR
IS
EITHER
FRIENDLY
OR
HOSTILE
AS
INDICATED
BY
THE
OR
LABEL
ON
EACH
EDGE
A
FOURTH
NODE
D
WANTS
TO
JOIN
THIS
NETWORK
AND
ESTABLISH
EITHER
POSITIVE
OR
NEGATIVE
RELATIONS
WITH
EACH
EXISTING
NODE
A
B
AND
C
CAN
NODE
D
DO
THIS
IN
SUCH
A
WAY
THAT
IT
DOESN
T
BECOME
INVOLVED
IN
ANY
UNBALANCED
TRIANGLES
IF
THERE
IS
A
WAY
FOR
D
TO
DO
THIS
SAY
HOW
MANY
DIFFERENT
SUCH
WAYS
THERE
ARE
AND
GIVE
AN
EXPLANATION
THAT
IS
HOW
MANY
DIFFERENT
POSSIBLE
LABELINGS
FIGURE
NODE
A
IS
FRIENDS
WITH
NODES
B
AND
C
WHO
ARE
ENEMIES
WITH
EACH
OTHER
OF
THE
EDGES
OUT
OF
D
HAVE
THE
PROPERTY
THAT
ALL
TRIANGLES
CONTAINING
D
ARE
BALANCED
IF
THERE
IS
NO
SUCH
WAY
FOR
D
TO
DO
THIS
GIVE
AN
EXPLANATION
WHY
NOT
C
USING
WHAT
YOU
VE
WORKED
OUT
IN
QUESTIONS
AND
CONSIDER
THE
FOLLOWING
QUES
TION
TAKE
ANY
LABELED
COMPLETE
GRAPH
ON
ANY
NUMBER
OF
NODES
THAT
IS
NOT
BALANCED
I
E
IT
CONTAINS
AT
LEAST
ONE
UNBALANCED
TRIANGLE
RECALL
THAT
A
LABELED
COMPLETE
GRAPH
IS
A
GRAPH
IN
WHICH
THERE
IS
AN
EDGE
BETWEEN
EACH
PAIR
OF
NODES
AND
EACH
EDGE
IS
LABELED
WITH
EITHER
OR
A
NEW
NODE
X
WANTS
TO
JOIN
THIS
NETWORK
BY
ATTACHING
TO
EACH
NODE
USING
A
POSITIVE
OR
NEGATIVE
EDGE
WHEN
IF
EVER
IS
IT
POSSIBLE
FOR
X
TO
DO
THIS
IN
SUCH
A
WAY
THAT
IT
DOES
NOT
BECOME
INVOLVED
IN
ANY
UNBALANCED
TRIANGLES
GIVE
AN
EXPLANATION
FOR
YOUR
ANSWER
HINT
THINK
ABOUT
ANY
UNBALANCED
TRIANGLE
IN
THE
NETWORK
AND
HOW
X
MUST
ATTACH
TO
THE
NODES
IN
IT
TOGETHER
WITH
SOME
ANTHROPOLOGISTS
YOU
RE
STUDYING
A
SPARSELY
POPULATED
REGION
OF
A
RAIN
FOREST
WHERE
FARMERS
LIVE
ALONG
A
MILE
LONG
STRETCH
OF
RIVER
EACH
FARMER
LIVES
ON
A
TRACT
OF
LAND
THAT
OCCUPIES
A
MILE
STRETCH
OF
THE
RIVER
BANK
SO
THEIR
TRACTS
EXACTLY
DIVIDE
UP
THE
MILES
OF
RIVER
BANK
THAT
THEY
COLLECTIVELY
COVER
THE
NUMBERS
ARE
CHOSEN
TO
BE
SIMPLE
AND
TO
MAKE
THE
STORY
EASY
TO
DESCRIBE
THE
FARMERS
ALL
KNOW
EACH
OTHER
AND
AFTER
INTERVIEWING
THEM
YOU
VE
DISCOVERED
THAT
EACH
FARMER
IS
FRIENDS
WITH
ALL
THE
OTHER
FARMERS
THAT
LIVE
AT
MOST
MILES
FROM
HIM
OR
HER
AND
IS
ENEMIES
WITH
ALL
THE
FARMERS
THAT
LIVE
MORE
THAN
MILES
FROM
HIM
OR
HER
YOU
BUILD
THE
SIGNED
COMPLETE
GRAPH
CORRESPONDING
TO
THIS
SOCIAL
NETWORK
AND
YOU
WONDER
WHETHER
IT
SATISFIES
THE
STRUCTURAL
BALANCE
PROPERTY
THIS
IS
THE
QUESTION
IS
THE
NETWORK
STRUCTURALLY
BALANCED
OR
NOT
PROVIDE
AN
EXPLANATION
FOR
YOUR
ANSWER
PART
II
GAME
THEORY
CHAPTER
GAMES
IN
THE
OPENING
CHAPTER
OF
THE
BOOK
WE
EMPHASIZED
THAT
THE
CONNECTEDNESS
OF
A
COMPLEX
SOCIAL
NATURAL
OR
TECHNOLOGICAL
SYSTEM
REALLY
MEANS
TWO
THINGS
FIRST
AN
UNDERLYING
STRUCTURE
OF
INTERCONNECTING
LINKS
AND
SECOND
AN
INTERDEPENDENCE
IN
THE
BEHAVIORS
OF
THE
INDIVIDUALS
WHO
INHABIT
THE
SYSTEM
SO
THAT
THE
OUTCOME
FOR
ANY
ONE
DEPENDS
AT
LEAST
IMPLICITLY
ON
THE
COMBINED
BEHAVIORS
OF
ALL
THE
FIRST
ISSUE
NETWORK
STRUCTURE
WAS
ADDRESSED
IN
THE
FIRST
PART
OF
THE
BOOK
USING
GRAPH
THEORY
IN
THIS
SECOND
PART
OF
THE
BOOK
WE
STUDY
INTERCONNECTEDNESS
AT
THE
LEVEL
OF
BEHAVIOR
DEVELOPING
BASIC
MODELS
FOR
THIS
IN
THE
LANGUAGE
OF
GAME
THEORY
GAME
THEORY
IS
DESIGNED
TO
ADDRESS
SITUATIONS
IN
WHICH
THE
OUTCOME
OF
A
PERSON
DECISION
DEPENDS
NOT
JUST
ON
HOW
THEY
CHOOSE
AMONG
SEVERAL
OPTIONS
BUT
ALSO
ON
THE
CHOICES
MADE
BY
THE
PEOPLE
THEY
ARE
INTERACTING
WITH
GAME
THEORETIC
IDEAS
ARISE
IN
MANY
CONTEXTS
SOME
CONTEXTS
ARE
LITERALLY
GAMES
FOR
EXAMPLE
CHOOSING
HOW
TO
TARGET
A
SOCCER
PENALTY
KICK
AND
CHOOSING
HOW
TO
DEFEND
AGAINST
IT
CAN
BE
MODELED
USING
GAME
THEORY
OTHER
SETTINGS
ARE
NOT
USUALLY
CALLED
GAMES
BUT
CAN
BE
ANALYZED
WITH
THE
SAME
TOOLS
EXAMPLES
INCLUDE
THE
PRICING
OF
A
NEW
PRODUCT
WHEN
OTHER
FIRMS
HAVE
SIMILAR
NEW
PRODUCTS
DECIDING
HOW
TO
BID
IN
AN
AUCTION
CHOOSING
A
ROUTE
ON
THE
INTERNET
OR
THROUGH
A
TRANSPORTATION
NETWORK
DECIDING
WHETHER
TO
ADOPT
AN
AGGRESSIVE
OR
A
PASSIVE
STANCE
IN
INTERNATIONAL
RELATIONS
OR
CHOOSING
WHETHER
TO
USE
PERFORMANCE
ENHANCING
DRUGS
IN
A
PROFESSIONAL
SPORT
IN
THESE
EXAMPLES
EACH
DECISION
MAKER
OUTCOME
DEPENDS
ON
THE
DECISIONS
MADE
BY
OTHERS
THIS
INTRODUCES
A
STRATEGIC
ELEMENT
THAT
GAME
THEORY
IS
DESIGNED
TO
ANALYZE
AS
WE
WILL
SEE
LATER
IN
CHAPTER
GAME
THEORETIC
IDEAS
ARE
ALSO
RELEVANT
TO
SETTINGS
WHERE
NO
ONE
IS
OVERTLY
MAKING
DECISIONS
EVOLUTIONARY
BIOLOGY
PROVIDES
PERHAPS
THE
MOST
STRIKING
EXAMPLE
A
BASIC
PRINCIPLE
IS
THAT
MUTATIONS
ARE
MORE
LIKELY
TO
SUCCEED
IN
A
POPULATION
WHEN
THEY
IMPROVE
THE
FITNESS
OF
THE
ORGANISMS
THAT
CARRY
THE
MUTATION
BUT
OFTEN
THIS
FITNESS
CANNOT
BE
ASSESSED
IN
ISOLATION
RATHER
IT
DEPENDS
ON
WHAT
ALL
THE
OTHER
NON
MUTANT
D
EASLEY
AND
J
KLEINBERG
NETWORKS
CROWDS
AND
MARKETS
REASONING
ABOUT
A
HIGHLY
CONNECTED
WORLD
CAMBRIDGE
UNIVERSITY
PRESS
DRAFT
VERSION
JUNE
ORGANISMS
ARE
DOING
AND
HOW
THE
MUTANT
BEHAVIOR
INTERACTS
WITH
THE
NON
MUTANTS
BE
HAVIORS
IN
SUCH
SITUATIONS
REASONING
ABOUT
THE
SUCCESS
OR
FAILURE
OF
THE
MUTATION
INVOLVES
GAME
THEORETIC
DEFINITIONS
AND
IN
FACT
VERY
CLOSELY
RESEMBLES
THE
PROCESS
OF
REASONING
ABOUT
DECISIONS
THAT
INTELLIGENT
ACTORS
MAKE
SIMILAR
KINDS
OF
REASONING
HAVE
BEEN
APPLIED
TO
THE
SUCCESS
OR
FAILURE
OF
NEW
CULTURAL
PRACTICES
AND
CONVENTIONS
IT
DEPENDS
ON
THE
EXISTING
PATTERNS
OF
BEHAVIOR
INTO
WHICH
THEY
ARE
INTRODUCED
THIS
INDICATES
THAT
THE
IDEAS
OF
GAME
THEORY
ARE
BROADER
THAN
JUST
A
MODEL
OF
HOW
PEOPLE
REASON
ABOUT
THEIR
INTERACTIONS
WITH
OTH
ERS
GAME
THEORY
MORE
GENERALLY
ADDRESSES
THE
QUESTION
OF
WHICH
BEHAVIORS
TEND
TO
SUSTAIN
THEMSELVES
WHEN
CARRIED
OUT
IN
A
LARGER
POPULATION
GAME
THEORETIC
IDEAS
WILL
APPEAR
IN
MANY
PLACES
THROUGHOUT
THE
BOOK
CHAPTERS
AND
DESCRIBE
TWO
INITIAL
AND
FUNDAMENTAL
APPLICATIONS
TO
NETWORK
TRAFFIC
WHERE
TRAVEL
TIME
DEPENDS
ON
THE
ROUTING
DECISIONS
OF
OTHERS
AND
TO
AUCTIONS
WHERE
THE
SUCCESS
OF
A
BIDDER
DEPENDS
ON
HOW
THE
OTHER
BIDDERS
BEHAVE
THERE
WILL
BE
MANY
FURTHER
EXAMPLES
LATER
IN
THE
BOOK
INCLUDING
THE
WAYS
IN
WHICH
PRICES
ARE
SET
IN
MARKETS
AND
THE
WAYS
IN
WHICH
PEOPLE
CHOOSE
TO
ADOPT
NEW
IDEAS
IN
SITUATIONS
WHERE
ADOPTION
DECISIONS
ARE
AFFECTED
BY
WHAT
OTHERS
ARE
DOING
AS
A
FIRST
STEP
THEN
WE
BEGIN
WITH
A
DISCUSSION
OF
THE
BASIC
IDEAS
BEHIND
GAME
THEORY
FOR
NOW
THIS
WILL
INVOLVE
DESCRIPTIONS
OF
SITUATIONS
IN
WHICH
PEOPLE
INTERACT
WITH
ONE
AN
OTHER
INITIALLY
WITHOUT
AN
ACCOMPANYING
GRAPH
STRUCTURE
ONCE
THESE
IDEAS
ARE
IN
PLACE
WE
WILL
BRING
GRAPHS
BACK
INTO
THE
PICTURE
IN
SUBSEQUENT
CHAPTERS
AND
BEGIN
TO
CONSIDER
HOW
STRUCTURE
AND
BEHAVIOR
CAN
BE
STUDIED
SIMULTANEOUSLY
WHAT
IS
A
GAME
GAME
THEORY
IS
CONCERNED
WITH
SITUATIONS
IN
WHICH
DECISION
MAKERS
INTERACT
WITH
ONE
ANOTHER
AND
IN
WHICH
THE
HAPPINESS
OF
EACH
PARTICIPANT
WITH
THE
OUTCOME
DEPENDS
NOT
JUST
ON
HIS
OR
HER
OWN
DECISIONS
BUT
ON
THE
DECISIONS
MADE
BY
EVERYONE
TO
HELP
MAKE
THE
DEFINITIONS
CONCRETE
IT
USEFUL
TO
START
WITH
AN
EXAMPLE
A
FIRST
EXAMPLE
SUPPOSE
THAT
YOU
RE
A
COLLEGE
STUDENT
AND
YOU
HAVE
TWO
LARGE
PIECES
OF
WORK
DUE
THE
NEXT
DAY
AN
EXAM
AND
A
PRESENTATION
YOU
NEED
TO
DECIDE
WHETHER
TO
STUDY
FOR
THE
EXAM
OR
TO
PREPARE
FOR
THE
PRESENTATION
FOR
SIMPLICITY
AND
TO
MAKE
THE
EXAMPLE
AS
CLEAN
AS
POSSIBLE
WE
LL
IMPOSE
A
FEW
ASSUMPTIONS
FIRST
WE
LL
ASSUME
YOU
CAN
EITHER
STUDY
FOR
THE
EXAM
OR
PREPARE
FOR
THE
PRESENTATION
BUT
NOT
BOTH
SECOND
WE
LL
ASSUME
YOU
HAVE
AN
ACCURATE
ESTIMATE
OF
THE
EXPECTED
GRADE
YOU
LL
GET
UNDER
THE
OUTCOMES
OF
DIFFERENT
DECISIONS
THE
OUTCOME
OF
THE
EXAM
IS
EASY
TO
PREDICT
IF
YOU
STUDY
THEN
YOUR
EXPECTED
GRADE
IS
A
WHILE
IF
YOU
DON
T
STUDY
THEN
YOUR
EXPECTED
GRADE
IS
AN
THE
PRESENTATION
IS
A
BIT
MORE
COMPLICATED
TO
THINK
ABOUT
FOR
THE
PRESENTATION
YOU
RE
WHAT
IS
A
GAME
DOING
IT
JOINTLY
WITH
A
PARTNER
IF
BOTH
YOU
AND
YOUR
PARTNER
PREPARE
FOR
THE
PRESENTATION
THEN
THE
PRESENTATION
WILL
GO
EXTREMELY
WELL
AND
YOUR
EXPECTED
JOINT
GRADE
IS
A
IF
JUST
ONE
OF
YOU
PREPARES
AND
THE
OTHER
DOESN
T
YOU
LL
GET
AN
EXPECTED
JOINT
GRADE
OF
AND
IF
NEITHER
OF
YOU
PREPARES
YOUR
EXPECTED
JOINT
GRADE
IS
THE
CHALLENGE
IN
REASONING
ABOUT
THIS
IS
THAT
YOUR
PARTNER
ALSO
HAS
THE
SAME
EXAM
THE
NEXT
DAY
AND
WE
LL
ASSUME
THAT
HE
HAS
THE
SAME
EXPECTED
OUTCOME
FOR
IT
IF
HE
STUDIES
AND
IF
HE
DOESN
T
HE
ALSO
HAS
TO
CHOOSE
BETWEEN
STUDYING
FOR
THE
EXAM
AND
PREPARING
FOR
THE
PRESENTATION
WE
LL
ASSUME
THAT
NEITHER
OF
YOU
IS
ABLE
TO
CONTACT
THE
OTHER
SO
YOU
CAN
T
JOINTLY
DISCUSS
WHAT
TO
DO
EACH
OF
YOU
NEEDS
TO
MAKE
A
DECISION
INDEPENDENTLY
KNOWING
THAT
THE
OTHER
WILL
ALSO
BE
MAKING
A
DECISION
BOTH
OF
YOU
ARE
INTERESTED
IN
MAXIMIZING
THE
AVERAGE
GRADE
YOU
GET
AND
WE
CAN
USE
THE
DISCUSSION
ABOVE
TO
WORK
OUT
HOW
THIS
AVERAGE
GRADE
IS
DETERMINED
BY
THE
WAY
THE
TWO
OF
YOU
INVEST
YOUR
EFFORTS
IF
BOTH
OF
YOU
PREPARE
FOR
THE
PRESENTATION
YOU
LL
BOTH
GET
ON
THE
PRESENTATION
AND
ON
THE
EXAM
FOR
AN
AVERAGE
OF
IF
BOTH
OF
YOU
STUDY
FOR
THE
EXAM
YOU
LL
BOTH
GET
ON
THE
EXAM
AND
ON
THE
PRESENTATION
FOR
AN
AVERAGE
OF
IF
ONE
OF
YOU
STUDIES
FOR
THE
EXAM
WHILE
THE
OTHER
PREPARES
FOR
THE
PRESENTATION
THE
RESULT
IS
AS
FOLLOWS
THE
ONE
WHO
PREPARES
FOR
THE
PRESENTATION
GETS
A
ON
THE
PRESENTATION
BUT
ONLY
AN
ON
THE
EXAM
FOR
AN
AVERAGE
OF
ON
THE
OTHER
HAND
THE
ONE
WHO
STUDIES
FOR
THE
EXAM
STILL
GETS
A
ON
THE
PRESENTATION
SINCE
IT
A
JOINT
GRADE
THIS
PERSON
BENEFITS
FROM
THE
FACT
THAT
ONE
OF
THE
TWO
OF
YOU
PREPARED
FOR
IT
THIS
PERSON
ALSO
GET
A
ON
THE
EXAM
THROUGH
STUDYING
AND
SO
GETS
AN
AVERAGE
OF
THERE
A
SIMPLE
TABULAR
WAY
TO
SUMMARIZE
ALL
THESE
OUTCOMES
AS
FOLLOWS
WE
REPRESENT
YOUR
TWO
CHOICES
TO
PREPARE
FOR
THE
PRESENTATION
OR
TO
STUDY
FOR
THE
EXAM
AS
THE
ROWS
OF
A
TABLE
WE
REPRESENT
YOUR
PARTNER
TWO
CHOICES
AS
THE
COLUMNS
SO
EACH
BOX
IN
THIS
TABLE
REPRESENTS
A
DECISION
BY
EACH
OF
YOU
IN
EACH
BOX
WE
RECORD
THE
AVERAGE
GRADE
YOU
EACH
RECEIVE
FIRST
YOURS
THEN
YOUR
PARTNER
WRITING
ALL
THIS
DOWN
WE
HAVE
THE
TABLE
SHOWN
IN
FIGURE
THIS
DESCRIBES
THE
SET
UP
OF
THE
SITUATION
NOW
YOU
NEED
TO
FIGURE
OUT
WHAT
TO
DO
PREPARE
FOR
THE
PRESENTATION
OR
STUDY
FOR
THE
EXAM
CLEARLY
YOUR
AVERAGE
GRADE
DEPENDS
NOT
JUST
ON
WHICH
OF
THESE
TWO
OPTIONS
YOU
CHOOSE
BUT
ALSO
ON
WHAT
YOUR
PARTNER
DECIDES
THEREFORE
AS
PART
OF
YOUR
DECISION
YOU
HAVE
TO
REASON
ABOUT
WHAT
YOUR
PARTNER
IS
LIKELY
TO
DO
THINKING
YOU
PRESENTATION
EXAM
YOUR
PARTNER
PRESENTATION
EXAM
FIGURE
EXAM
OR
PRESENTATION
ABOUT
THE
STRATEGIC
CONSEQUENCES
OF
YOUR
OWN
ACTIONS
WHERE
YOU
NEED
TO
CONSIDER
THE
EFFECT
OF
DECISIONS
BY
OTHERS
IS
PRECISELY
THE
KIND
OF
REASONING
THAT
GAME
THEORY
IS
DESIGNED
TO
FACILITATE
SO
BEFORE
MOVING
ON
TO
THE
ACTUAL
OUTCOME
OF
THIS
EXAM
OR
PRESENTATION
SCENARIO
IT
IS
USEFUL
TO
INTRODUCE
SOME
OF
THE
BASIC
DEFINITIONS
OF
GAME
THEORY
AND
THEN
CONTINUE
THE
DISCUSSION
IN
THIS
LANGUAGE
BASIC
INGREDIENTS
OF
A
GAME
THE
SITUATION
WE
VE
JUST
DESCRIBED
IS
AN
EXAMPLE
OF
A
GAME
FOR
OUR
PURPOSES
A
GAME
IS
ANY
SITUATION
WITH
THE
FOLLOWING
THREE
ASPECTS
I
THERE
IS
A
SET
OF
PARTICIPANTS
WHOM
WE
CALL
THE
PLAYERS
IN
OUR
EXAMPLE
YOU
AND
YOUR
PARTNER
ARE
THE
TWO
PLAYERS
II
EACH
PLAYER
HAS
A
SET
OF
OPTIONS
FOR
HOW
TO
BEHAVE
WE
WILL
REFER
TO
THESE
AS
THE
PLAYER
POSSIBLE
STRATEGIES
IN
THE
EXAMPLE
YOU
AND
YOUR
PARTNER
EACH
HAVE
TWO
POSSIBLE
STRATEGIES
TO
PREPARE
FOR
THE
PRESENTATION
OR
TO
STUDY
FOR
THE
EXAM
III
FOR
EACH
CHOICE
OF
STRATEGIES
EACH
PLAYER
RECEIVES
A
PAYOFF
THAT
CAN
DEPEND
ON
THE
STRATEGIES
SELECTED
BY
EVERYONE
THE
PAYOFFS
WILL
GENERALLY
BE
NUMBERS
WITH
EACH
PLAYER
PREFERRING
LARGER
PAYOFFS
TO
SMALLER
PAYOFFS
IN
OUR
CURRENT
EXAMPLE
THE
PAYOFF
TO
EACH
PLAYER
IS
THE
AVERAGE
GRADE
HE
OR
SHE
GETS
ON
THE
EXAM
AND
THE
PRESENTATION
WE
WILL
GENERALLY
WRITE
THE
PAYOFFS
IN
A
PAYOFF
MATRIX
AS
IN
FIGURE
OUR
INTEREST
IS
IN
REASONING
ABOUT
HOW
PLAYERS
WILL
BEHAVE
IN
A
GIVEN
GAME
FOR
NOW
WE
FOCUS
ON
GAMES
WITH
ONLY
TWO
PLAYERS
BUT
THE
IDEAS
APPLY
EQUALLY
WELL
TO
GAMES
WITH
ANY
NUMBER
OF
PLAYERS
ALSO
WE
WILL
FOCUS
ON
SIMPLE
ONE
SHOT
GAMES
GAMES
IN
WHICH
THE
PLAYERS
SIMULTANEOUSLY
AND
INDEPENDENTLY
CHOOSE
THEIR
ACTIONS
AND
THEY
DO
SO
ONLY
ONCE
IN
SECTION
AT
THE
END
OF
THIS
CHAPTER
WE
DISCUSS
HOW
TO
REINTERPRET
THE
THEORY
TO
DEAL
WITH
DYNAMIC
GAMES
IN
WHICH
ACTIONS
CAN
BE
PLAYED
SEQUENTIALLY
OVER
TIME
REASONING
ABOUT
BEHAVIOR
IN
A
GAME
ONCE
WE
WRITE
DOWN
THE
DESCRIPTION
OF
A
GAME
CONSISTING
OF
THE
PLAYERS
THE
STRATEGIES
AND
THE
PAYOFFS
WE
CAN
ASK
HOW
THE
PLAYERS
ARE
LIKELY
TO
BEHAVE
THAT
IS
HOW
THEY
WILL
GO
ABOUT
SELECTING
STRATEGIES
UNDERLYING
ASSUMPTIONS
IN
ORDER
TO
MAKE
THIS
QUESTION
TRACTABLE
WE
WILL
MAKE
A
FEW
ASSUMPTIONS
FIRST
WE
ASSUME
EVERYTHING
THAT
A
PLAYER
CARES
ABOUT
IS
SUMMARIZED
IN
THE
PLAYER
PAYOFFS
IN
THE
EXAM
OR
PRESENTATION
GAME
DESCRIBED
IN
SECTION
THIS
MEANS
THAT
THE
TWO
PLAYERS
ARE
SOLELY
CONCERNED
WITH
MAXIMIZING
THEIR
OWN
AVERAGE
GRADE
HOWEVER
NOTHING
IN
THE
FRAMEWORK
OF
GAME
THEORY
REQUIRES
THAT
PLAYERS
CARE
ONLY
ABOUT
PERSONAL
REWARDS
FOR
EXAMPLE
A
PLAYER
WHO
IS
ALTRUISTIC
MAY
CARE
ABOUT
BOTH
HIS
OR
HER
OWN
BENEFITS
AND
THE
OTHER
PLAYER
BENEFIT
IF
SO
THEN
THE
PAYOFFS
SHOULD
REFLECT
THIS
ONCE
THE
PAYOFFS
HAVE
BEEN
DEFINED
THEY
SHOULD
CONSTITUTE
A
COMPLETE
DESCRIPTION
OF
EACH
PLAYER
HAPPINESS
WITH
EACH
OF
THE
POSSIBLE
OUTCOMES
OF
THE
GAME
WE
ALSO
ASSUME
THAT
EACH
PLAYER
KNOWS
EVERYTHING
ABOUT
THE
STRUCTURE
OF
THE
GAME
TO
BEGIN
WITH
THIS
MEANS
THAT
EACH
PLAYER
KNOWS
HIS
OR
HER
OWN
LIST
OF
POSSIBLE
STRATEGIES
IT
SEEMS
REASONABLE
IN
MANY
SETTINGS
TO
ASSUME
THAT
EACH
PLAYER
ALSO
KNOWS
WHO
THE
OTHER
PLAYER
IS
IN
A
TWO
PLAYER
GAME
THE
STRATEGIES
AVAILABLE
TO
THIS
OTHER
PLAYER
AND
WHAT
HIS
OR
HER
PAYOFF
WILL
BE
FOR
ANY
CHOICE
OF
STRATEGIES
IN
THE
EXAM
OR
PRESENTATION
GAME
THIS
CORRESPONDS
TO
THE
ASSUMPTION
THAT
YOU
REALIZE
YOU
AND
YOUR
PARTNER
ARE
EACH
FACED
WITH
THE
CHOICE
OF
STUDYING
FOR
THE
EXAM
OR
PREPARING
FOR
THE
PRESENTATION
AND
YOU
HAVE
AN
ACCURATE
ESTIMATE
OF
THE
EXPECTED
OUTCOME
UNDER
DIFFERENT
COURSES
OF
ACTION
THERE
IS
CONSIDERABLE
RESEARCH
ON
HOW
TO
ANALYZE
GAMES
IN
WHICH
THE
PLAYERS
HAVE
MUCH
LESS
KNOWLEDGE
ABOUT
THE
UNDERLYING
STRUCTURE
AND
IN
FACT
JOHN
HARSANYI
SHARED
THE
NOBEL
PRIZE
IN
ECONOMICS
FOR
HIS
WORK
ON
GAMES
WITH
INCOMPLETE
INFORMATION
FINALLY
WE
SUPPOSE
THAT
EACH
INDIVIDUAL
CHOOSES
A
STRATEGY
TO
MAXIMIZE
HER
OWN
PAYOFF
GIVEN
HER
BELIEFS
ABOUT
THE
STRATEGY
USED
BY
THE
OTHER
PLAYER
THIS
MODEL
OF
INDIVIDUAL
BEHAVIOR
WHICH
IS
USUALLY
CALLED
RATIONALITY
ACTUALLY
COMBINES
TWO
IDEAS
THE
FIRST
IDEA
IS
THAT
EACH
PLAYER
WANTS
TO
MAXIMIZE
HER
OWN
PAYOFF
SINCE
THE
INDIVIDUAL
PAYOFF
IS
DEFINED
TO
BE
WHATEVER
THE
INDIVIDUAL
CARES
ABOUT
THIS
HYPOTHESIS
SEEMS
REASONABLE
THE
SECOND
IDEA
IS
THAT
EACH
PLAYER
ACTUALLY
SUCCEEDS
IN
SELECTING
THE
OPTIMAL
STRATEGY
IN
SIMPLE
SETTINGS
AND
FOR
GAMES
PLAYED
BY
EXPERIENCED
PLAYERS
THIS
TOO
SEEMS
REASONABLE
IN
COMPLEX
GAMES
OR
FOR
GAMES
PLAYED
BY
INEXPERIENCED
PLAYERS
IT
IS
SURELY
LESS
REASONABLE
IT
IS
INTERESTING
TO
CONSIDER
PLAYERS
WHO
MAKE
MISTAKES
AND
LEARN
FROM
THE
PLAY
OF
THE
GAME
THERE
IS
AN
EXTENSIVE
LITERATURE
WHICH
ANALYZES
PROBLEMS
OF
THIS
SORT
BUT
WE
WILL
NOT
CONSIDER
THESE
ISSUES
HERE
REASONING
ABOUT
BEHAVIOR
IN
THE
EXAM
OR
PRESENTATION
GAME
LET
GO
BACK
TO
THE
EXAM
OR
PRESENTATION
GAME
AND
ASK
HOW
WE
SHOULD
EXPECT
YOU
AND
YOUR
PARTNER
THE
TWO
PLAYERS
IN
THE
GAME
TO
BEHAVE
WE
FIRST
FOCUS
ON
THIS
FROM
YOUR
POINT
OF
VIEW
THE
REASONING
FOR
YOUR
PARTNER
WILL
BE
SYMMETRIC
SINCE
THE
GAME
LOOKS
THE
SAME
FROM
HIS
POINT
OF
VIEW
IT
WOULD
BE
EASIER
TO
DECIDE
WHAT
TO
DO
IF
YOU
COULD
PREDICT
WHAT
YOUR
PARTNER
WOULD
DO
BUT
TO
BEGIN
WITH
LET
CONSIDER
WHAT
YOU
SHOULD
DO
FOR
EACH
POSSIBLE
CHOICE
OF
STRATEGY
BY
YOUR
PARTNER
FIRST
IF
YOU
KNEW
YOUR
PARTNER
WAS
GOING
TO
STUDY
FOR
THE
EXAM
THEN
YOU
WOULD
GET
A
PAYOFF
OF
BY
ALSO
STUDYING
AND
A
PAYOFF
OF
ONLY
BY
PREPARING
FOR
THE
PRESENTATION
SO
IN
THIS
CASE
YOU
SHOULD
STUDY
FOR
THE
EXAM
ON
THE
OTHER
HAND
IF
YOU
KNEW
THAT
YOUR
PARTNER
WAS
GOING
TO
PREPARE
FOR
THE
PRE
SENTATION
THEN
YOU
D
GET
A
PAYOFF
OF
BY
ALSO
PREPARING
FOR
THE
PRESENTATION
BUT
A
PAYOFF
OF
BY
STUDYING
FOR
THE
EXAM
SO
IN
THIS
CASE
TOO
YOU
SHOULD
STUDY
FOR
THE
EXAM
THIS
APPROACH
OF
CONSIDERING
EACH
OF
YOUR
PARTNER
OPTIONS
SEPARATELY
TURNS
OUT
TO
BE
A
VERY
USEFUL
WAY
OF
ANALYZING
THE
PRESENT
SITUATION
IT
REVEALS
THAT
NO
MATTER
WHAT
YOUR
PARTNER
DOES
YOU
SHOULD
STUDY
FOR
THE
EXAM
WHEN
A
PLAYER
HAS
A
STRATEGY
THAT
IS
STRICTLY
BETTER
THAN
ALL
OTHER
OPTIONS
REGARDLESS
OF
WHAT
THE
OTHER
PLAYER
DOES
WE
WILL
REFER
TO
IT
AS
A
STRICTLY
DOMINANT
STRATEGY
WHEN
A
PLAYER
HAS
A
STRICTLY
DOMINANT
STRATEGY
WE
SHOULD
EXPECT
THAT
THEY
WILL
DEFINITELY
PLAY
IT
IN
THE
EXAM
OR
PRESENTATION
GAME
STUDYING
FOR
THE
EXAM
IS
ALSO
A
STRICTLY
DOMINANT
STRATEGY
FOR
YOUR
PARTNER
BY
THE
SAME
REASONING
AND
SO
WE
SHOULD
EXPECT
THAT
THE
OUTCOME
WILL
BE
FOR
BOTH
OF
YOU
TO
STUDY
EACH
GETTING
AN
AVERAGE
GRADE
OF
SO
THIS
GAME
HAS
A
VERY
CLEAN
ANALYSIS
AND
IT
EASY
TO
SEE
HOW
TO
END
UP
WITH
A
PREDICTION
FOR
THE
OUTCOME
DESPITE
THIS
THERE
SOMETHING
STRIKING
ABOUT
THE
CONCLUSION
IF
YOU
AND
YOUR
PARTNER
COULD
SOMEHOW
AGREE
THAT
YOU
WOULD
BOTH
PREPARE
FOR
THE
PRESENTATION
YOU
WOULD
EACH
GET
AN
AVERAGE
GRADE
OF
IN
OTHER
WORDS
YOU
WOULD
EACH
BE
BETTER
OFF
BUT
DESPITE
THE
FACT
THAT
YOU
BOTH
UNDERSTAND
THIS
THIS
PAYOFF
OF
CANNOT
BE
ACHIEVED
BY
RATIONAL
PLAY
THE
REASONING
ABOVE
MAKES
IT
CLEAR
WHY
NOT
EVEN
IF
YOU
WERE
TO
PERSONALLY
COMMIT
TO
PREPARING
FOR
THE
PRESENTATION
HOPING
TO
ACHIEVE
THE
OUTCOME
WHERE
YOU
BOTH
GET
AND
EVEN
IF
YOUR
PARTNER
KNEW
YOU
WERE
DOING
THIS
YOUR
PARTNER
WOULD
STILL
HAVE
AN
INCENTIVE
TO
STUDY
FOR
THE
EXAM
SO
AS
TO
ACHIEVE
A
STILL
HIGHER
PAYOFF
OF
FOR
HIMSELF
THIS
RESULT
DEPENDS
ON
OUR
ASSUMPTION
THAT
THE
PAYOFFS
TRULY
REFLECT
EVERYTHING
EACH
PLAYER
VALUES
IN
THE
OUTCOME
IN
THIS
CASE
THAT
YOU
AND
YOUR
PARTNER
ONLY
CARE
ABOUT
MAXIMIZING
YOUR
OWN
AVERAGE
GRADE
IF
FOR
EXAMPLE
YOU
CARED
ABOUT
THE
GRADE
THAT
YOUR
PARTNER
RECEIVED
AS
WELL
THEN
THE
PAYOFFS
IN
THIS
GAME
WOULD
LOOK
DIFFERENT
AND
THE
OUTCOME
COULD
BE
DIFFERENT
SIMILARLY
IF
YOU
CARED
ABOUT
THE
FACT
THAT
YOUR
PARTNER
WILL
BE
ANGRY
AT
YOU
FOR
NOT
PREPARING
FOR
THE
JOINT
PRESENTATION
THEN
THIS
TOO
SHOULD
BE
INCORPORATED
INTO
THE
PAYOFFS
AGAIN
POTENTIALLY
AFFECTING
THE
RESULTS
BUT
WITH
THE
PAYOFFS
AS
THEY
ARE
WE
ARE
LEFT
WITH
THE
INTERESTING
SITUATION
WHERE
THERE
IS
AN
OUTCOME
THAT
IS
BETTER
FOR
BOTH
OF
YOU
AN
AVERAGE
GRADE
OF
EACH
AND
YET
IT
CANNOT
BE
ACHIEVED
BY
RATIONAL
PLAY
OF
THE
GAME
A
RELATED
STORY
THE
PRISONER
DILEMMA
THE
OUTCOME
OF
THE
EXAM
OR
PRESENTATION
GAME
IS
CLOSELY
RELATED
TO
ONE
OF
THE
MOST
FAMOUS
EXAMPLES
IN
THE
DEVELOPMENT
OF
GAME
THE
ORY
THE
PRISONER
DILEMMA
HERE
IS
HOW
THIS
EXAMPLE
WORKS
SUPPOSE
THAT
TWO
SUSPECTS
HAVE
BEEN
APPREHENDED
BY
THE
POLICE
AND
ARE
BEING
INTERRO
GATED
IN
SEPARATE
ROOMS
THE
POLICE
STRONGLY
SUSPECT
THAT
THESE
TWO
INDIVIDUALS
ARE
RESPON
SIBLE
FOR
A
ROBBERY
BUT
THERE
IS
NOT
ENOUGH
EVIDENCE
TO
CONVICT
EITHER
OF
THEM
OF
THE
ROBBERY
HOWEVER
THEY
BOTH
RESISTED
ARREST
AND
CAN
BE
CHARGED
WITH
THAT
LESSER
CRIME
WHICH
WOULD
CARRY
A
ONE
YEAR
SENTENCE
EACH
OF
THE
SUSPECTS
IS
TOLD
THE
FOLLOWING
STORY
IF
YOU
CONFESS
AND
YOUR
PARTNER
DOESN
T
CONFESS
THEN
YOU
WILL
BE
RELEASED
AND
YOUR
PARTNER
WILL
BE
CHARGED
WITH
THE
CRIME
YOUR
CONFESSION
WILL
BE
SUFFICIENT
TO
CONVICT
HIM
OF
THE
ROBBERY
AND
HE
WILL
BE
SENT
TO
PRISON
FOR
YEARS
IF
YOU
BOTH
CONFESS
THEN
WE
DON
T
NEED
EITHER
OF
YOU
TO
TESTIFY
AGAINST
THE
OTHER
AND
YOU
WILL
BOTH
BE
CONVICTED
OF
THE
ROBBERY
ALTHOUGH
IN
THIS
CASE
YOUR
SENTENCE
WILL
BE
LESS
YEARS
ONLY
BECAUSE
OF
YOUR
GUILTY
PLEA
FINALLY
IF
NEITHER
OF
YOU
CONFESSES
THEN
WE
CAN
T
CONVICT
EITHER
OF
YOU
OF
THE
ROBBERY
SO
WE
WILL
CHARGE
EACH
OF
YOU
WITH
RESISTING
ARREST
YOUR
PARTNER
IS
BEING
OFFERED
THE
SAME
DEAL
DO
YOU
WANT
TO
CONFESS
TO
FORMALIZE
THIS
STORY
AS
A
GAME
WE
NEED
TO
IDENTIFY
THE
PLAYERS
THE
POSSIBLE
STRATEGIES
AND
THE
PAYOFFS
THE
TWO
SUSPECTS
ARE
THE
PLAYERS
AND
EACH
HAS
TO
CHOOSE
BETWEEN
TWO
POSSI
BLE
STRATEGIES
CONFESS
C
OR
NOT
CONFESS
N
C
FINALLY
THE
PAYOFFS
CAN
BE
SUMMARIZED
FROM
THE
STORY
ABOVE
AS
IN
FIGURE
NOTE
THAT
THE
PAYOFFS
ARE
ALL
OR
LESS
SINCE
THERE
ARE
NO
GOOD
OUTCOMES
FOR
THE
SUSPECTS
ONLY
DIFFERENT
GRADATIONS
OF
BAD
OUTCOMES
SUSPECT
N
C
C
SUSPECT
N
C
C
FIGURE
PRISONER
DILEMMA
AS
IN
THE
EXAM
OR
PRESENTATION
GAME
WE
CAN
CONSIDER
HOW
ONE
OF
THE
SUSPECTS
SAY
SUSPECT
SHOULD
REASON
ABOUT
HIS
OPTIONS
IF
SUSPECT
WERE
GOING
TO
CONFESS
THEN
SUSPECT
WOULD
RECEIVE
A
PAYOFF
OF
BY
CONFESSING
AND
A
PAYOFF
OF
BY
NOT
CONFESSING
SO
IN
THIS
CASE
SUSPECT
SHOULD
CONFESS
IF
SUSPECT
WERE
NOT
GOING
TO
CONFESS
THEN
SUSPECT
WOULD
RECEIVE
A
PAYOFF
OF
BY
CONFESSING
AND
A
PAYOFF
OF
BY
NOT
CONFESSING
SO
IN
THIS
CASE
TOO
SUSPECT
SHOULD
CONFESS
SO
CONFESSING
IS
A
STRICTLY
DOMINANT
STRATEGY
IT
IS
THE
BEST
CHOICE
REGARDLESS
OF
WHAT
THE
OTHER
PLAYER
CHOOSES
AS
A
RESULT
WE
SHOULD
EXPECT
BOTH
SUSPECTS
TO
CONFESS
EACH
GETTING
A
PAYOFF
OF
WE
THEREFORE
HAVE
THE
SAME
STRIKING
PHENOMENON
AS
IN
THE
EXAM
OR
PRESENTATION
GAME
THERE
IS
AN
OUTCOME
THAT
THE
SUSPECTS
KNOW
TO
BE
BETTER
FOR
BOTH
OF
THEM
IN
WHICH
THEY
BOTH
CHOOSE
NOT
TO
CONFESS
BUT
UNDER
RATIONAL
PLAY
OF
THE
GAME
THERE
IS
NO
WAY
FOR
THEM
TO
ACHIEVE
THIS
OUTCOME
INSTEAD
THEY
END
UP
WITH
AN
OUTCOME
THAT
IS
WORSE
FOR
BOTH
OF
THEM
AND
HERE
TOO
IT
IS
IMPORTANT
THAT
THE
PAYOFFS
REFLECT
EVERYTHING
ABOUT
THE
OUTCOME
OF
THE
GAME
IF
FOR
EXAMPLE
THE
SUSPECTS
COULD
CREDIBLY
THREATEN
EACH
OTHER
WITH
RETRIBUTION
FOR
CONFESSING
THEREBY
MAKING
CONFESSING
A
LESS
DESIRABLE
OPTION
THEN
THIS
WOULD
AFFECT
THE
PAYOFFS
AND
POTENTIALLY
THE
OUTCOME
INTERPRETATIONS
OF
THE
PRISONER
DILEMMA
THE
PRISONER
DILEMMA
HAS
BEEN
THE
SUBJECT
OF
A
HUGE
AMOUNT
OF
LITERATURE
SINCE
ITS
INTRODUCTION
IN
THE
EARLY
SINCE
IT
SERVES
AS
A
HIGHLY
STREAMLINED
DEPICTION
OF
THE
DIFFICULTY
IN
ESTABLISHING
COOPERATION
IN
THE
FACE
OF
INDIVIDUAL
SELF
INTEREST
WHILE
NO
MODEL
THIS
SIMPLE
CAN
PRECISELY
CAPTURE
COMPLEX
SCENARIOS
IN
THE
REAL
WORLD
THE
PRISONER
DILEMMA
HAS
BEEN
USED
AS
AN
INTERPRETIVE
FRAMEWORK
FOR
MANY
DIFFERENT
REAL
WORLD
SITUATIONS
FOR
EXAMPLE
THE
USE
OF
PERFORMANCE
ENHANCING
DRUGS
IN
PROFESSIONAL
SPORTS
HAS
BEEN
MODELED
AS
A
CASE
OF
THE
PRISONER
DILEMMA
GAME
HERE
THE
ATHLETES
ARE
THE
PLAYERS
AND
THE
TWO
POSSIBLE
STRATEGIES
ARE
TO
USE
PERFORMANCE
ENHANCING
DRUGS
OR
NOT
IF
YOU
USE
DRUGS
WHILE
YOUR
OPPONENT
DOESN
T
YOU
LL
GET
AN
ADVANTAGE
IN
THE
COMPETITION
BUT
YOU
LL
SUFFER
LONG
TERM
HARM
AND
MAY
GET
CAUGHT
IF
WE
CONSIDER
A
SPORT
WHERE
IT
IS
DIFFICULT
TO
DETECT
THE
USE
OF
SUCH
DRUGS
AND
WE
ASSUME
ATHLETES
IN
SUCH
A
SPORT
VIEW
THE
DOWNSIDE
AS
A
SMALLER
FACTOR
THAN
THE
BENEFITS
IN
COMPETITION
WE
CAN
CAPTURE
THE
SITUATION
WITH
NUMERICAL
PAYOFFS
THAT
MIGHT
LOOK
AS
FOLLOWS
THE
NUMBERS
ARE
ARBITRARY
HERE
WE
ARE
ONLY
INTERESTED
IN
THEIR
RELATIVE
SIZES
ATHLETE
DON
T
USE
DRUGS
USE
DRUGS
ATHLETE
DON
T
USE
DRUGS
USE
DRUGS
FIGURE
PERFORMANCE
ENHANCING
DRUGS
HERE
THE
BEST
OUTCOME
WITH
A
PAYOFF
OF
IS
TO
USE
DRUGS
WHEN
YOUR
OPPONENT
DOESN
T
SINCE
THEN
YOU
MAXIMIZE
YOUR
CHANCES
OF
WINNING
HOWEVER
THE
PAYOFF
TO
BOTH
USING
DRUGS
IS
WORSE
THAN
THE
PAYOFF
TO
BOTH
NOT
USING
DRUGS
SINCE
IN
BOTH
CASES
YOU
RE
EVENLY
MATCHED
BUT
IN
THE
FORMER
CASE
YOU
RE
ALSO
CAUSING
HARM
TO
YOURSELF
WE
CAN
NOW
SEE
THAT
USING
DRUGS
IS
A
STRICTLY
DOMINANT
STRATEGY
AND
SO
WE
HAVE
A
SITUATION
WHERE
THE
PLAYERS
USE
DRUGS
EVEN
THOUGH
THEY
UNDERSTAND
THAT
THERE
A
BETTER
OUTCOME
FOR
BOTH
OF
THEM
MORE
GENERALLY
SITUATIONS
OF
THIS
TYPE
ARE
OFTEN
REFERRED
TO
AS
ARMS
RACES
IN
WHICH
TWO
COMPETITORS
USE
AN
INCREASINGLY
DANGEROUS
ARSENAL
OF
WEAPONS
SIMPLY
TO
REMAIN
EVENLY
MATCHED
IN
THE
EXAMPLE
ABOVE
THE
PERFORMANCE
ENHANCING
DRUGS
PLAY
THE
ROLE
OF
THE
WEAPONS
BUT
THE
PRISONER
DILEMMA
HAS
ALSO
BEEN
USED
TO
INTERPRET
LITERAL
ARMS
RACES
BETWEEN
OPPOSING
NATIONS
WHERE
THE
WEAPONS
CORRESPOND
TO
THE
NATIONS
MILITARY
ARSENALS
TO
WRAP
UP
OUR
DISCUSSION
OF
THE
PRISONER
DILEMMA
WE
SHOULD
NOTE
THAT
IT
ONLY
ARISES
WHEN
THE
PAYOFFS
ARE
ALIGNED
IN
A
CERTAIN
WAY
AS
WE
WILL
SEE
IN
THE
REMAINDER
OF
THE
CHAPTER
THERE
ARE
MANY
SITUATIONS
WHERE
THE
STRUCTURE
OF
THE
GAME
AND
THE
RESULTING
BEHAVIOR
LOOKS
VERY
DIFFERENT
INDEED
EVEN
SIMPLE
CHANGES
TO
A
GAME
CAN
CHANGE
IT
FROM
AN
INSTANCE
OF
THE
PRISONER
DILEMMA
TO
SOMETHING
MORE
BENIGN
FOR
EXAMPLE
RETURNING
TO
THE
EXAM
OR
PRESENTATION
GAME
SUPPOSE
THAT
WE
KEEP
EVERYTHING
THE
SAME
AS
BEFORE
EXCEPT
THAT
WE
MAKE
THE
EXAM
MUCH
EASIER
SO
THAT
YOU
LL
GET
A
ON
IT
IF
YOU
STUDY
AND
A
IF
YOU
DON
T
THEN
WE
CAN
CHECK
THAT
THE
PAYOFF
MATRIX
NOW
BECOMES
YOU
PRESENTATION
EXAM
YOUR
PARTNER
PRESENTATION
EXAM
FIGURE
EXAM
OR
PRESENTATION
GAME
WITH
AN
EASIER
EXAM
FURTHERMORE
WE
CAN
CHECK
THAT
WITH
THESE
NEW
PAYOFFS
PREPARING
FOR
THE
PRESENTATION
NOW
BECOMES
A
STRICTLY
DOMINANT
STRATEGY
SO
WE
CAN
EXPECT
THAT
BOTH
PLAYERS
WILL
PLAY
THIS
STRATEGY
AND
BOTH
WILL
BENEFIT
FROM
THIS
DECISION
THE
DOWNSIDES
OF
THE
PREVIOUS
SCENARIO
NO
LONGER
APPEAR
LIKE
OTHER
DANGEROUS
PHENOMENA
THE
PRISONER
DILEMMA
ONLY
MANIFESTS
ITSELF
WHEN
THE
CONDITIONS
ARE
RIGHT
BEST
RESPONSES
AND
DOMINANT
STRATEGIES
IN
REASONING
ABOUT
THE
GAMES
IN
THE
PREVIOUS
SECTION
WE
USED
TWO
FUNDAMENTAL
CONCEPTS
THAT
WILL
BE
CENTRAL
TO
OUR
DISCUSSION
OF
GAME
THEORY
AS
SUCH
IT
IS
USEFUL
TO
DEFINE
THEM
CAREFULLY
HERE
AND
THEN
TO
LOOK
FURTHER
AT
SOME
OF
THEIR
IMPLICATIONS
THE
FIRST
CONCEPT
IS
THE
IDEA
OF
A
BEST
RESPONSE
IT
IS
THE
BEST
CHOICE
OF
ONE
PLAYER
GIVEN
A
BELIEF
ABOUT
WHAT
THE
OTHER
PLAYER
WILL
DO
FOR
INSTANCE
IN
THE
EXAM
OR
PRESENTATION
GAME
WE
DETERMINED
YOUR
BEST
CHOICE
IN
RESPONSE
TO
EACH
POSSIBLE
CHOICE
OF
YOUR
PARTNER
WE
CAN
MAKE
THIS
PRECISE
WITH
A
BIT
OF
NOTATION
AS
FOLLOWS
IF
IS
A
STRATEGY
CHOSEN
BY
PLAYER
AND
T
IS
A
STRATEGY
CHOSEN
BY
PLAYER
THEN
THERE
IS
AN
ENTRY
IN
THE
PAYOFF
MATRIX
CORRESPONDING
TO
THE
PAIR
OF
CHOSEN
STRATEGIES
T
WE
WILL
WRITE
T
TO
DENOTE
THE
PAYOFF
TO
PLAYER
AS
A
RESULT
OF
THIS
PAIR
OF
STRATEGIES
AND
T
TO
DENOTE
THE
PAYOFF
TO
PLAYER
AS
A
RESULT
OF
THIS
PAIR
OF
STRATEGIES
NOW
WE
SAY
THAT
A
STRATEGY
FOR
PLAYER
IS
A
BEST
RESPONSE
TO
A
STRATEGY
T
FOR
PLAYER
IF
PRODUCES
AT
LEAST
AS
GOOD
A
PAYOFF
AS
ANY
OTHER
STRATEGY
PAIRED
WITH
T
T
ST
T
FOR
ALL
OTHER
STRATEGIES
ST
OF
PLAYER
NATURALLY
THERE
IS
A
COMPLETELY
SYMMETRIC
DEFINITION
FOR
PLAYER
WHICH
WE
WON
T
WRITE
DOWN
HERE
IN
WHAT
FOLLOWS
WE
LL
PRESENT
THE
DEFINITIONS
FROM
PLAYER
POINT
OF
VIEW
BUT
THERE
ARE
DIRECT
ANALOGUES
FOR
PLAYER
IN
EACH
CASE
NOTICE
THAT
THIS
DEFINITION
ALLOWS
FOR
MULTIPLE
DIFFERENT
STRATEGIES
OF
PLAYER
TO
BE
TIED
AS
THE
BEST
RESPONSE
TO
STRATEGY
T
THIS
CAN
MAKE
IT
DIFFICULT
TO
PREDICT
WHICH
OF
THESE
MULTIPLE
DIFFERENT
STRATEGIES
PLAYER
WILL
USE
WE
CAN
EMPHASIZE
THAT
ONE
CHOICE
IS
UNIQUELY
THE
BEST
BY
SAYING
THAT
A
STRATEGY
OF
PLAYER
IS
A
STRICT
BEST
RESPONSE
TO
A
STRATEGY
T
FOR
PLAYER
IF
PRODUCES
A
STRICTLY
HIGHER
PAYOFF
THAN
ANY
OTHER
STRATEGY
PAIRED
WITH
T
T
ST
T
FOR
ALL
OTHER
STRATEGIES
ST
OF
PLAYER
WHEN
A
PLAYER
HAS
A
STRICT
BEST
RESPONSE
TO
T
THIS
IS
CLEARLY
THE
STRATEGY
SHE
SHOULD
PLAY
WHEN
FACED
WITH
T
THE
SECOND
CONCEPT
WHICH
WAS
CENTRAL
TO
OUR
ANALYSIS
IN
THE
PREVIOUS
SECTION
IS
THAT
OF
A
STRICTLY
DOMINANT
STRATEGY
WE
CAN
FORMULATE
ITS
DEFINITION
IN
TERMS
OF
BEST
RESPONSES
AS
FOLLOWS
WE
SAY
THAT
A
DOMINANT
STRATEGY
FOR
PLAYER
IS
A
STRATEGY
THAT
IS
A
BEST
RESPONSE
TO
EVERY
STRATEGY
OF
PLAYER
WE
SAY
THAT
A
STRICTLY
DOMINANT
STRATEGY
FOR
PLAYER
IS
A
STRATEGY
THAT
IS
A
STRICT
BEST
RESPONSE
TO
EVERY
STRATEGY
OF
PLAYER
IN
THE
PREVIOUS
SECTION
WE
MADE
THE
OBSERVATION
THAT
IF
A
PLAYER
HAS
A
STRICTLY
DOMINANT
STRATEGY
THEN
WE
CAN
EXPECT
HIM
OR
HER
TO
USE
IT
THE
NOTION
OF
A
DOMINANT
STRATEGY
IS
SLIGHTLY
WEAKER
SINCE
IT
CAN
BE
TIED
AS
THE
BEST
OPTION
AGAINST
SOME
OPPOSING
STRATEGIES
AS
A
RESULT
A
PLAYER
COULD
POTENTIALLY
HAVE
MULTIPLE
DOMINANT
STRATEGIES
IN
WHICH
CASE
IT
MAY
NOT
BE
OBVIOUS
WHICH
ONE
SHOULD
BE
PLAYED
THE
ANALYSIS
OF
THE
PRISONER
DILEMMA
WAS
FACILITATED
BY
THE
FACT
THAT
BOTH
PLAYERS
HAD
STRICTLY
DOMINANT
STRATEGIES
AND
SO
IT
WAS
EASY
TO
REASON
ABOUT
WHAT
WAS
LIKELY
TO
HAPPEN
BUT
MOST
SETTINGS
WON
T
BE
THIS
CLEAR
CUT
AND
WE
NOW
BEGIN
TO
LOOK
AT
GAMES
WHICH
LACK
STRICTLY
DOMINANT
STRATEGIES
A
GAME
IN
WHICH
ONLY
ONE
PLAYER
HAS
A
STRICTLY
DOMINANT
STRATEGY
AS
A
FIRST
STEP
LET
CONSIDER
A
SETTING
IN
WHICH
ONE
PLAYER
HAS
A
STRICTLY
DOMINANT
STRATEGY
AND
THE
OTHER
ONE
DOESN
T
AS
A
CONCRETE
EXAMPLE
WE
CONSIDER
THE
FOLLOWING
STORY
SUPPOSE
THERE
ARE
TWO
FIRMS
THAT
ARE
EACH
PLANNING
TO
PRODUCE
AND
MARKET
A
NEW
PRODUCT
THESE
TWO
PRODUCTS
WILL
DIRECTLY
COMPETE
WITH
EACH
OTHER
LET
IMAGINE
THAT
THE
POPULATION
OF
CONSUMERS
CAN
BE
CLEANLY
DIVIDED
INTO
TWO
MARKET
SEGMENTS
PEOPLE
WHO
WOULD
ONLY
BUY
A
LOW
PRICED
VERSION
OF
THE
PRODUCT
AND
PEOPLE
WHO
WOULD
ONLY
BUY
AN
UPSCALE
VERSION
LET
ALSO
ASSUME
THAT
THE
PROFIT
ANY
FIRM
MAKES
ON
A
SALE
OF
EITHER
A
LOW
PRICE
OR
AN
UPSCALE
PRODUCT
IS
THE
SAME
SO
TO
KEEP
TRACK
OF
PROFITS
IT
GOOD
ENOUGH
TO
KEEP
TRACK
OF
SALES
EACH
FIRM
WANTS
TO
MAXIMIZE
ITS
PROFIT
OR
EQUIVALENTLY
ITS
SALES
AND
IN
ORDER
TO
DO
THIS
IT
HAS
TO
DECIDE
WHETHER
ITS
NEW
PRODUCT
WILL
BE
LOW
PRICED
OR
UPSCALE
SO
THIS
GAME
HAS
TWO
PLAYERS
FIRM
AND
FIRM
AND
EACH
HAS
TWO
POSSIBLE
STRATEGIES
TO
PRODUCE
A
LOW
PRICED
PRODUCT
OR
AN
UPSCALE
ONE
TO
DETERMINE
THE
PAYOFFS
HERE
IS
HOW
THE
FIRMS
EXPECT
THE
SALES
TO
WORK
OUT
FIRST
PEOPLE
WHO
WOULD
PREFER
A
LOW
PRICED
VERSION
ACCOUNT
FOR
OF
THE
POPULATION
AND
PEOPLE
WHO
WOULD
PREFER
AN
UPSCALE
VERSION
ACCOUNT
FOR
OF
THE
POPULATION
FIRM
IS
THE
MUCH
MORE
POPULAR
BRAND
AND
SO
WHEN
THE
TWO
FIRMS
DIRECTLY
COMPETE
IN
A
MARKET
SEGMENT
FIRM
GETS
OF
THE
SALES
AND
FIRM
GETS
OF
THE
SALES
IF
A
FIRM
IS
THE
ONLY
ONE
TO
PRODUCE
A
PRODUCT
FOR
A
GIVEN
MARKET
SEGMENT
IT
GETS
ALL
THE
SALES
BASED
ON
THIS
WE
CAN
DETERMINE
PAYOFFS
FOR
DIFFERENT
CHOICES
OF
STRATEGIES
AS
FOLLOWS
IF
THE
TWO
FIRMS
MARKET
TO
DIFFERENT
MARKET
SEGMENTS
THEY
EACH
GET
ALL
THE
SALES
IN
THAT
SEGMENT
SO
THE
ONE
THAT
TARGETS
THE
LOW
PRICED
SEGMENT
GETS
A
PAYOFF
AND
THE
ONE
THAT
TARGETS
THE
UPSCALE
SEGMENT
GETS
IF
BOTH
FIRMS
TARGET
THE
LOW
PRICED
SEGMENT
THEN
FIRM
GETS
OF
IT
FOR
A
PAYOFF
OF
AND
FIRM
GETS
OF
IT
FOR
A
PAYOFF
OF
ANALOGOUSLY
IF
BOTH
FIRMS
TARGET
THE
UPSCALE
SEGMENT
THEN
FIRM
GETS
A
PAYOFF
OF
AND
FIRM
GETS
A
PAYOFF
OF
THIS
CAN
BE
SUMMARIZED
IN
THE
FOLLOWING
PAYOFF
MATRIX
FIRM
LOW
PRICED
UPSCALE
FIRM
LOW
PRICED
UPSCALE
FIGURE
MARKETING
STRATEGY
NOTICE
THAT
IN
THIS
GAME
FIRM
HAS
A
STRICTLY
DOMINANT
STRATEGY
FOR
FIRM
LOW
PRICED
IS
A
STRICT
BEST
RESPONSE
TO
EACH
STRATEGY
OF
FIRM
ON
THE
OTHER
HAND
FIRM
DOES
NOT
HAVE
A
DOMINANT
STRATEGY
LOW
PRICED
IS
ITS
BEST
RESPONSE
WHEN
FIRM
PLAYS
UPSCALE
AND
UPSCALE
IS
ITS
BEST
RESPONSE
WHEN
FIRM
PLAYS
LOW
PRICED
STILL
IT
IS
NOT
HARD
TO
MAKE
A
PREDICTION
ABOUT
THE
OUTCOME
OF
THIS
GAME
SINCE
FIRM
HAS
A
STRICTLY
DOMINANT
STRATEGY
IN
LOW
PRICED
WE
CAN
EXPECT
IT
WILL
PLAY
IT
NOW
WHAT
SHOULD
FIRM
DO
IF
FIRM
KNOWS
FIRM
PAYOFFS
AND
KNOWS
THAT
FIRM
WANTS
TO
MAXIMIZE
PROFITS
THEN
FIRM
CAN
CONFIDENTLY
PREDICT
THAT
FIRM
WILL
PLAY
LOW
PRICED
THEN
SINCE
UPSCALE
IS
THE
STRICT
BEST
RESPONSE
BY
FIRM
TO
LOW
PRICED
WE
CAN
PREDICT
THAT
FIRM
WILL
PLAY
UPSCALE
SO
OUR
OVERALL
PREDICTION
OF
PLAY
IN
THIS
MARKETING
GAME
IS
LOW
PRICED
BY
FIRM
AND
UPSCALE
BY
FIRM
RESULTING
IN
PAYOFFS
OF
AND
RESPECTIVELY
NOTE
THAT
ALTHOUGH
WE
RE
DESCRIBING
THE
REASONING
IN
TWO
STEPS
FIRST
THE
STRICTLY
DOM
INANT
STRATEGY
OF
FIRM
AND
THEN
THE
BEST
RESPONSE
OF
FIRM
THIS
IS
STILL
IN
THE
CONTEXT
OF
A
GAME
WHERE
THE
PLAYERS
MOVE
SIMULTANEOUSLY
BOTH
FIRMS
ARE
DEVELOPING
THEIR
MARKETING
STRATEGIES
CONCURRENTLY
AND
IN
SECRET
IT
IS
SIMPLY
THAT
THE
REASONING
ABOUT
STRATEGIES
NATU
RALLY
FOLLOWS
THIS
TWO
STEP
LOGIC
RESULTING
IN
A
PREDICTION
ABOUT
HOW
THE
SIMULTANEOUS
PLAY
WILL
OCCUR
IT
ALSO
INTERESTING
TO
NOTE
THE
INTUITIVE
MESSAGE
OF
THIS
PREDICTION
FIRM
IS
SO
STRONG
THAT
IT
CAN
PROCEED
WITHOUT
REGARD
TO
FIRM
DECISION
GIVEN
THIS
FIRM
BEST
STRATEGY
IS
TO
STAY
SAFELY
OUT
OF
THE
WAY
OF
FIRM
FINALLY
WE
SHOULD
ALSO
NOTE
HOW
THE
MARKETING
STRATEGY
GAME
MAKES
USE
OF
THE
KNOWL
EDGE
WE
ASSUME
PLAYERS
HAVE
ABOUT
THE
GAME
BEING
PLAYED
AND
ABOUT
EACH
OTHER
IN
PARTICU
LAR
WE
ASSUME
THAT
EACH
PLAYER
KNOWS
THE
ENTIRE
PAYOFF
MATRIX
AND
IN
REASONING
ABOUT
THIS
SPECIFIC
GAME
IT
IS
IMPORTANT
THAT
FIRM
KNOWS
THAT
FIRM
WANTS
TO
MAXIMIZE
PROFITS
AND
THAT
FIRM
KNOWS
THAT
FIRM
KNOWS
ITS
OWN
PROFITS
IN
GENERAL
WE
WILL
ASSUME
THAT
THE
PLAYERS
HAVE
COMMON
KNOWLEDGE
OF
THE
GAME
THEY
KNOW
THE
STRUCTURE
OF
THE
GAME
THEY
KNOW
THAT
EACH
OF
THEM
KNOW
THE
STRUCTURE
OF
THE
GAME
THEY
KNOW
THAT
EACH
OF
THEM
KNOW
THAT
EACH
OF
THEM
KNOW
AND
SO
ON
WHILE
WE
WILL
NOT
NEED
THE
FULL
TECHNICAL
CONTENT
OF
COMMON
KNOWLEDGE
IN
ANYTHING
WE
DO
HERE
IT
IS
AN
UNDERLYING
ASSUMPTION
AND
A
TOPIC
OF
RESEARCH
IN
THE
GAME
THEORY
LITERATURE
AS
MENTIONED
EARLIER
IT
IS
STILL
POSSIBLE
TO
ANALYZE
GAMES
IN
SITUATIONS
WHERE
COMMON
KNOWLEDGE
DOES
NOT
HOLD
BUT
THE
ANALYSIS
BECOMES
MORE
COMPLEX
IT
ALSO
WORTH
NOTING
THAT
THE
ASSUMPTION
OF
COMMON
KNOWLEDGE
IS
A
BIT
STRONGER
THAN
WE
NEED
FOR
REASONING
ABOUT
SIMPLE
GAMES
SUCH
AS
THE
PRISONER
DILEMMA
WHERE
STRICTLY
DOMINANT
STRATEGIES
FOR
EACH
PLAYER
IMPLY
A
PARTICULAR
COURSE
OF
ACTION
REGARDLESS
OF
WHAT
THE
OTHER
PLAYER
IS
DOING
NASH
EQUILIBRIUM
WHEN
NEITHER
PLAYER
IN
A
TWO
PLAYER
GAME
HAS
A
STRICTLY
DOMINANT
STRATEGY
WE
NEED
SOME
OTHER
WAY
OF
PREDICTING
WHAT
IS
LIKELY
TO
HAPPEN
IN
THIS
SECTION
WE
DEVELOP
METHODS
FOR
DOING
THIS
THE
RESULT
WILL
BE
A
USEFUL
FRAMEWORK
FOR
ANALYZING
GAMES
IN
GENERAL
NASH
EQUILIBRIUM
AN
EXAMPLE
A
THREE
CLIENT
GAME
TO
FRAME
THE
QUESTION
IT
HELPS
TO
THINK
ABOUT
A
SIMPLE
EXAMPLE
OF
A
GAME
THAT
LACKS
STRICTLY
DOMINANT
STRATEGIES
LIKE
OUR
PREVIOUS
EXAMPLE
IT
WILL
BE
A
MARKETING
GAME
PLAYED
BETWEEN
TWO
FIRMS
HOWEVER
IT
HAS
A
SLIGHTLY
MORE
INTRICATE
SET
UP
SUPPOSE
THERE
ARE
TWO
FIRMS
THAT
EACH
HOPE
TO
DO
BUSINESS
WITH
ONE
OF
THREE
LARGE
CLIENTS
A
B
AND
C
EACH
FIRM
HAS
THREE
POSSIBLE
STRATEGIES
WHETHER
TO
APPROACH
A
B
OR
C
THE
RESULTS
OF
THEIR
TWO
DECISIONS
WILL
WORK
OUT
AS
FOLLOWS
IF
THE
TWO
FIRMS
APPROACH
THE
SAME
CLIENT
THEN
THE
CLIENT
WILL
GIVE
HALF
ITS
BUSINESS
TO
EACH
FIRM
IS
TOO
SMALL
TO
ATTRACT
BUSINESS
ON
ITS
OWN
SO
IF
IT
APPROACHES
ONE
CLIENT
WHILE
FIRM
APPROACHES
A
DIFFERENT
ONE
THEN
FIRM
GETS
A
PAYOFF
OF
IF
FIRM
APPROACHES
CLIENT
B
OR
C
ON
ITS
OWN
IT
WILL
GET
THEIR
FULL
BUSINESS
HOWEVER
A
IS
A
LARGER
CLIENT
AND
WILL
ONLY
DO
BUSINESS
WITH
THE
FIRMS
IF
BOTH
APPROACH
A
BECAUSE
A
IS
A
LARGER
CLIENT
DOING
BUSINESS
WITH
IT
IS
WORTH
AND
HENCE
TO
EACH
FIRM
IF
IT
SPLIT
WHILE
DOING
BUSINESS
WITH
B
OR
C
IS
WORTH
AND
HENCE
TO
EACH
FIRM
IF
IT
SPLIT
FROM
THIS
DESCRIPTION
WE
CAN
WORK
OUT
THE
FOLLOWING
PAYOFF
MATRIX
A
FIRM
B
C
FIRM
A
B
C
FIGURE
THREE
CLIENT
GAME
IF
WE
STUDY
HOW
THE
PAYOFFS
IN
THIS
GAME
WORK
WE
SEE
THAT
NEITHER
FIRM
HAS
A
DOMINANT
STRATEGY
INDEED
EACH
STRATEGY
BY
EACH
FIRM
IS
A
STRICT
BEST
RESPONSE
TO
SOME
STRATEGY
BY
THE
OTHER
FIRM
FOR
FIRM
A
IS
A
STRICT
BEST
RESPONSE
TO
STRATEGY
A
BY
FIRM
B
IS
A
STRICT
BEST
RESPONSE
TO
B
AND
C
IS
A
STRICT
BEST
RESPONSE
TO
C
FOR
FIRM
A
IS
A
STRICT
BEST
RESPONSE
TO
STRATEGY
A
BY
FIRM
C
IS
A
STRICT
BEST
RESPONSE
TO
B
AND
B
IS
A
STRICT
BEST
RESPONSE
TO
C
SO
HOW
SHOULD
WE
REASON
ABOUT
THE
OUTCOME
OF
PLAY
IN
THIS
GAME
DEFINING
NASH
EQUILIBRIUM
IN
JOHN
NASH
PROPOSED
A
SIMPLE
BUT
POWERFUL
PRIN
CIPLE
FOR
REASONING
ABOUT
BEHAVIOR
IN
GENERAL
GAMES
AND
ITS
UNDERLYING
PREMISE
IS
THE
FOLLOWING
EVEN
WHEN
THERE
ARE
NO
DOMINANT
STRATEGIES
WE
SHOULD
EXPECT
PLAYERS
TO
USE
STRATEGIES
THAT
ARE
BEST
RESPONSES
TO
EACH
OTHER
MORE
PRECISELY
SUPPOSE
THAT
PLAYER
CHOOSES
A
STRATEGY
AND
PLAYER
CHOOSES
A
STRATEGY
T
WE
SAY
THAT
THIS
PAIR
OF
STRATEGIES
T
IS
A
NASH
EQUILIBRIUM
IF
IS
A
BEST
RESPONSE
TO
T
AND
T
IS
A
BEST
RESPONSE
TO
THIS
IS
NOT
A
CONCEPT
THAT
CAN
BE
DERIVED
PURELY
FROM
RATIONALITY
ON
THE
PART
OF
THE
PLAYERS
INSTEAD
IT
IS
AN
EQUILIBRIUM
CONCEPT
THE
IDEA
IS
THAT
IF
THE
PLAYERS
CHOOSE
STRATEGIES
THAT
ARE
BEST
RESPONSES
TO
EACH
OTHER
THEN
NO
PLAYER
HAS
AN
INCENTIVE
TO
DEVIATE
TO
AN
ALTERNATIVE
STRATEGY
SO
THE
SYSTEM
IS
IN
A
KIND
OF
EQUILIBRIUM
STATE
WITH
NO
FORCE
PUSHING
IT
TOWARD
A
DIFFERENT
OUTCOME
NASH
SHARED
THE
NOBEL
PRIZE
IN
ECONOMICS
FOR
HIS
DEVELOPMENT
AND
ANALYSIS
OF
THIS
IDEA
TO
UNDERSTAND
THE
IDEA
OF
NASH
EQUILIBRIUM
WE
SHOULD
FIRST
ASK
WHY
A
PAIR
OF
STRATEGIES
THAT
ARE
NOT
BEST
RESPONSES
TO
EACH
OTHER
WOULD
NOT
CONSTITUTE
AN
EQUILIBRIUM
THE
ANSWER
IS
THAT
THE
PLAYERS
CANNOT
BOTH
BELIEVE
THAT
THESE
STRATEGIES
WILL
BE
ACTUALLY
USED
IN
THE
GAME
AS
THEY
KNOW
THAT
AT
LEAST
ONE
PLAYER
WOULD
HAVE
AN
INCENTIVE
TO
DEVIATE
TO
ANOTHER
STRATEGY
SO
NASH
EQUILIBRIUM
CAN
BE
THOUGHT
OF
AS
AN
EQUILIBRIUM
IN
BELIEFS
IF
EACH
PLAYER
BELIEVES
THAT
THE
OTHER
PLAYER
WILL
ACTUALLY
PLAY
A
STRATEGY
THAT
IS
PART
OF
A
NASH
EQUILIBRIUM
THEN
SHE
IS
WILLING
TO
PLAY
HER
PART
OF
THE
NASH
EQUILIBRIUM
LET
CONSIDER
THE
THREE
CLIENT
GAME
FROM
THE
PERSPECTIVE
OF
NASH
EQUILIBRIUM
IF
FIRM
CHOOSES
A
AND
FIRM
CHOOSES
A
THEN
WE
CAN
CHECK
THAT
FIRM
IS
PLAYING
A
BEST
RESPONSE
TO
FIRM
STRATEGY
AND
FIRM
IS
PLAYING
A
BEST
RESPONSE
TO
FIRM
STRATEGY
HENCE
THE
PAIR
OF
STRATEGIES
A
A
FORMS
A
NASH
EQUILIBRIUM
MOREOVER
WE
CAN
CHECK
THAT
THIS
IS
THE
ONLY
NASH
EQUILIBRIUM
NO
OTHER
PAIR
OF
STRATEGIES
ARE
BEST
RESPONSES
TO
EACH
OTHER
THIS
DISCUSSION
ALSO
SUGGESTS
TWO
WAYS
TO
FIND
NASH
EQUILIBRIA
THE
FIRST
IS
TO
SIMPLY
CHECK
ALL
PAIRS
OF
STRATEGIES
AND
ASK
FOR
EACH
ONE
OF
THEM
WHETHER
THE
INDIVIDUAL
STRATEGIES
ARE
BEST
RESPONSES
TO
EACH
OTHER
THE
SECOND
IS
TO
COMPUTE
EACH
PLAYER
BEST
RESPONSE
TO
EACH
STRATEGY
OF
THE
OTHER
PLAYER
AND
THEN
FIND
STRATEGIES
THAT
ARE
MUTUAL
BEST
RESPONSES
MULTIPLE
EQUILIBRIA
COORDINATION
GAMES
FOR
A
GAME
WITH
A
SINGLE
NASH
EQUILIBRIUM
SUCH
AS
THE
THREE
CLIENT
GAME
IN
THE
PREVI
OUS
SECTION
IT
SEEMS
REASONABLE
TO
PREDICT
THAT
THE
PLAYERS
WILL
PLAY
THE
STRATEGIES
IN
THIS
EQUILIBRIUM
UNDER
ANY
OTHER
PLAY
OF
THE
GAME
AT
LEAST
ONE
PLAYER
WILL
NOT
BE
USING
A
BEST
RESPONSE
TO
WHAT
THE
OTHER
IS
DOING
SOME
NATURAL
GAMES
HOWEVER
CAN
HAVE
MORE
THAN
ONE
NASH
EQUILIBRIUM
AND
IN
THIS
CASE
IT
BECOMES
DIFFICULT
TO
PREDICT
HOW
RATIONAL
PLAYERS
WILL
ACTUALLY
BEHAVE
IN
THE
GAME
WE
CONSIDER
SOME
FUNDAMENTAL
EXAMPLES
OF
THIS
PROBLEM
HERE
A
COORDINATION
GAME
A
SIMPLE
BUT
CENTRAL
EXAMPLE
IS
THE
FOLLOWING
COORDINATION
GAME
WHICH
WE
CAN
MOTIVATE
THROUGH
THE
FOLLOWING
STORY
SUPPOSE
YOU
AND
A
PARTNER
ARE
THIS
DISCUSSION
EACH
PLAYER
ONLY
HAS
THREE
AVAILABLE
STRATEGIES
A
B
OR
C
LATER
IN
THIS
WE
WILL
INTRODUCE
THE
POSSIBILITY
OF
MORE
COMPLEX
STRATEGIES
IN
WHICH
PLAYERS
CAN
RANDOMIZE
OVER
THEIR
AVAILABLE
OPTIONS
WITH
THIS
MORE
COMPLEX
FORMULATION
OF
POSSIBLE
STRATEGIES
WE
WILL
FIND
ADDITIONAL
EQUILIBRIA
FOR
THE
THREE
CLIENT
GAME
EACH
PREPARING
SLIDES
FOR
A
JOINT
PROJECT
PRESENTATION
YOU
CAN
T
REACH
YOUR
PARTNER
BY
PHONE
AND
NEED
TO
START
WORKING
ON
THE
SLIDES
NOW
YOU
HAVE
TO
DECIDE
WHETHER
TO
PREPARE
YOUR
HALF
OF
THE
SLIDES
IN
POWERPOINT
OR
IN
APPLE
KEYNOTE
SOFTWARE
EITHER
WOULD
BE
FINE
BUT
IT
WILL
BE
MUCH
EASIER
TO
MERGE
YOUR
SLIDES
TOGETHER
WITH
YOUR
PARTNER
IF
YOU
USE
THE
SAME
SOFTWARE
SO
WE
HAVE
A
GAME
IN
WHICH
YOU
AND
YOUR
PARTNER
ARE
THE
TWO
PLAYERS
CHOOSING
POWER
POINT
OR
CHOOSING
KEYNOTE
FORM
THE
TWO
STRATEGIES
AND
THE
PAYOFFS
ARE
AS
SHOWN
IN
FIGURE
YOU
POWERPOINT
KEYNOTE
YOUR
PARTNER
POWERPOINT
KEYNOTE
FIGURE
COORDINATION
GAME
THIS
IS
CALLED
A
COORDINATION
GAME
BECAUSE
THE
TWO
PLAYERS
SHARED
GOAL
IS
REALLY
TO
COORDINATE
ON
THE
SAME
STRATEGY
THERE
ARE
MANY
SETTINGS
IN
WHICH
COORDINATION
GAMES
ARISE
FOR
EXAMPLE
TWO
MANUFACTURING
COMPANIES
THAT
WORK
TOGETHER
EXTENSIVELY
NEED
TO
DECIDE
WHETHER
TO
CONFIGURE
THEIR
MACHINERY
IN
METRIC
UNITS
OF
MEASUREMENT
OR
ENGLISH
UNITS
OF
MEASUREMENT
TWO
PLATOONS
IN
THE
SAME
ARMY
NEED
TO
DECIDE
WHETHER
TO
ATTACK
AN
ENEMY
LEFT
FLANK
OR
RIGHT
FLANK
TWO
PEOPLE
TRYING
TO
FIND
EACH
OTHER
IN
A
CROWDED
MALL
NEED
TO
DECIDE
WHETHER
TO
WAIT
AT
THE
NORTH
END
OF
THE
MALL
OR
AT
THE
SOUTH
END
IN
EACH
CASE
EITHER
CHOICE
CAN
BE
FINE
PROVIDED
THAT
BOTH
PARTICIPANTS
MAKE
THE
SAME
CHOICE
THE
UNDERLYING
DIFFICULTY
IS
THAT
THE
GAME
HAS
TWO
NASH
EQUILIBRIA
I
E
POWER
POINT
POWERPOINT
AND
KEYNOTE
KEYNOTE
IN
OUR
EXAMPLE
FROM
FIGURE
IF
THE
PLAYERS
FAIL
TO
COORDINATE
ON
ONE
OF
THE
NASH
EQUILIBRIA
PERHAPS
BECAUSE
ONE
PLAYER
EXPECTS
POWER
POINT
TO
BE
PLAYED
AND
THE
OTHER
EXPECTS
KEYNOTE
THEN
THEY
RECEIVE
LOW
PAYOFFS
SO
WHAT
DO
THE
PLAYERS
DO
THIS
REMAINS
A
SUBJECT
OF
CONSIDERABLE
DISCUSSION
AND
RESEARCH
BUT
SOME
PROPOSALS
HAVE
RECEIVED
ATTENTION
IN
THE
LITERATURE
THOMAS
SCHELLING
INTRODUCED
THE
IDEA
OF
A
FOCAL
POINT
AS
A
WAY
TO
RESOLVE
THIS
DIFFICULTY
HE
NOTED
THAT
IN
SOME
GAMES
THERE
ARE
NATURAL
REASONS
POSSIBLY
OUTSIDE
THE
PAYOFF
STRUCTURE
OF
THE
GAME
THAT
CAUSE
THE
PLAYERS
TO
FOCUS
ON
ONE
OF
THE
NASH
EQUILIBRIA
FOR
EXAMPLE
SUPPOSE
TWO
DRIVERS
ARE
APPROACHING
EACH
OTHER
AT
NIGHT
ON
AN
UNDIVIDED
COUNTRY
ROAD
EACH
DRIVER
HAS
TO
DECIDE
WHETHER
TO
MOVE
OVER
TO
THE
LEFT
OR
THE
RIGHT
IF
THE
DRIVERS
COORDINATE
MAKING
THE
SAME
CHOICE
OF
SIDE
THEN
THEY
PASS
EACH
OTHER
BUT
IF
THEY
FAIL
TO
COORDINATE
THEN
THEY
GET
A
SEVERELY
LOW
PAYOFF
DUE
TO
THE
RESULTING
COLLISION
FORTUNATELY
SOCIAL
CONVENTION
CAN
HELP
THE
DRIVERS
DECIDE
WHAT
TO
DO
IN
THIS
CASE
IF
THIS
GAME
IS
BEING
PLAYED
IN
THE
U
CONVENTION
STRONGLY
SUGGESTS
THAT
THEY
SHOULD
MOVE
TO
THE
RIGHT
WHILE
IF
THE
GAME
IS
BEING
PLAYED
IN
ENGLAND
CONVENTION
STRONGLY
SUGGESTS
THAT
THEY
SHOULD
MOVE
TO
THE
LEFT
IN
OTHER
WORDS
SOCIAL
CONVENTIONS
WHILE
OFTEN
ARBITRARY
CAN
SOMETIMES
BE
USEFUL
IN
HELPING
PEOPLE
COORDINATE
AMONG
MULTIPLE
EQUILIBRIA
VARIANTS
ON
THE
BASIC
COORDINATION
GAME
ONE
CAN
ENRICH
THE
STRUCTURE
OF
OUR
BASIC
COORDINATION
GAME
TO
CAPTURE
A
NUMBER
OF
RELATED
ISSUES
SURROUNDING
THE
PROBLEM
OF
MUL
TIPLE
EQUILIBRIA
TO
TAKE
A
SIMPLE
EXTENSION
OF
OUR
PREVIOUS
EXAMPLE
SUPPOSE
THAT
BOTH
YOU
AND
YOUR
PROJECT
PARTNER
EACH
PREFER
KEYNOTE
TO
POWERPOINT
YOU
STILL
WANT
TO
COORDINATE
BUT
YOU
NOW
VIEW
THE
TWO
ALTERNATIVES
AS
UNEQUAL
THIS
GIVES
US
THE
PAYOFF
MATRIX
FOR
AN
UNBALANCED
COORDINATION
GAME
SHOWN
IN
FIGURE
YOU
POWERPOINT
KEYNOTE
YOUR
PARTNER
POWERPOINT
KEYNOTE
FIGURE
UNBALANCED
COORDINATION
GAME
NOTICE
THAT
POWERPOINT
POWERPOINT
AND
KEYNOTE
KEYNOTE
ARE
STILL
BOTH
NASH
EQUI
LIBRIA
FOR
THIS
GAME
DESPITE
THE
FACT
THAT
ONE
OF
THEM
GIVES
HIGHER
PAYOFFS
TO
BOTH
PLAYERS
THE
POINT
IS
THAT
IF
YOU
BELIEVE
YOUR
PARTNER
WILL
CHOOSE
POWERPOINT
YOU
STILL
SHOULD
CHOOSE
POWERPOINT
AS
WELL
HERE
SCHELLING
THEORY
OF
FOCAL
POINTS
SUGGESTS
THAT
WE
CAN
USE
A
FEATURE
INTRINSIC
TO
THE
GAME
RATHER
THAN
AN
ARBITRARY
SOCIAL
CONVENTION
TO
MAKE
A
PREDICTION
ABOUT
WHICH
EQUILIBRIUM
WILL
BE
CHOSEN
BY
THE
PLAYERS
THAT
IS
WE
CAN
PREDICT
THAT
WHEN
THE
PLAYERS
HAVE
TO
CHOOSE
THEY
WILL
SELECT
STRATEGIES
SO
AS
TO
REACH
THE
EQUILIB
RIUM
THAT
GIVES
HIGHER
PAYOFFS
TO
BOTH
OF
THEM
TO
TAKE
ANOTHER
EXAMPLE
CONSIDER
THE
TWO
PEOPLE
TRYING
TO
MEET
AT
A
CROWDED
MALL
IF
THE
NORTH
END
OF
THE
MALL
HAS
A
BOOKSTORE
THEY
BOTH
LIKE
WHILE
THE
SOUTH
END
CONSISTS
OF
A
LOADING
DOCK
THE
NATURAL
FOCAL
POINT
WOULD
BE
THE
EQUILIBRIUM
IN
WHICH
THEY
BOTH
CHOOSE
THE
NORTH
END
THINGS
GET
MORE
COMPLICATED
IF
YOU
AND
YOUR
PARTNER
DON
T
AGREE
ON
WHICH
SOFTWARE
YOU
PREFER
AS
SHOWN
IN
THE
PAYOFF
MATRIX
OF
FIGURE
YOU
POWERPOINT
KEYNOTE
YOUR
PARTNER
POWERPOINT
KEYNOTE
FIGURE
BATTLE
OF
THE
SEXES
IN
THIS
CASE
THE
TWO
EQUILIBRIA
STILL
CORRESPOND
TO
THE
TWO
DIFFERENT
WAYS
OF
COORDINATING
BUT
YOUR
PAYOFF
IS
HIGHER
IN
THE
KEYNOTE
KEYNOTE
EQUILIBRIUM
WHILE
YOUR
PARTNER
PAYOFF
IS
HIGHER
IN
THE
POWERPOINT
POWERPOINT
EQUILIBRIUM
THIS
GAME
IS
TRADITIONALLY
CALLED
THE
BATTLE
OF
THE
SEXES
BECAUSE
OF
THE
FOLLOWING
MOTIVATING
STORY
A
HUSBAND
AND
WIFE
WANT
TO
SEE
A
MOVIE
TOGETHER
AND
THEY
NEED
TO
CHOOSE
BETWEEN
A
ROMANTIC
COMEDY
AND
AN
ACTION
MOVIE
THEY
WANT
TO
COORDINATE
ON
THEIR
CHOICE
BUT
THE
ROMANCE
ROMANCE
EQUILIBRIUM
GIVES
A
HIGHER
PAYOFF
TO
ONE
OF
THEM
WHILE
THE
ACTION
ACTION
EQUILIBRIUM
GIVES
A
HIGHER
PAYOFF
TO
THE
OTHER
IN
BATTLE
OF
THE
SEXES
IT
CAN
BE
HARD
TO
PREDICT
THE
EQUILIBRIUM
THAT
WILL
BE
PLAYED
USING
EITHER
THE
PAYOFF
STRUCTURE
OR
SOME
PURELY
EXTERNAL
SOCIAL
CONVENTION
RATHER
IT
HELPS
TO
KNOW
SOMETHING
ABOUT
CONVENTIONS
THAT
EXIST
BETWEEN
THE
TWO
PLAYERS
THEMSELVES
SUGGESTING
HOW
THEY
RESOLVE
DISAGREEMENTS
WHEN
THEY
PREFER
DIFFERENT
WAYS
OF
COORDINATING
IT
WORTH
MENTIONING
ONE
FINAL
VARIATION
ON
THE
BASIC
COORDINATION
GAME
WHICH
HAS
ATTRACTED
ATTENTION
IN
RECENT
YEARS
THIS
IS
THE
STAG
HUNT
GAME
THE
NAME
IS
MOTIVATED
BY
THE
FOLLOWING
STORY
FROM
WRITINGS
OF
ROUSSEAU
SUPPOSE
THAT
TWO
PEOPLE
ARE
OUT
HUNTING
IF
THEY
WORK
TOGETHER
THEY
CAN
CATCH
A
STAG
WHICH
WOULD
BE
THE
HIGHEST
PAYOFF
OUTCOME
BUT
ON
THEIR
OWN
EACH
CAN
CATCH
A
HARE
THE
TRICKY
PART
IS
THAT
IF
ONE
HUNTER
TRIES
TO
CATCH
A
STAG
ON
HIS
OWN
HE
WILL
GET
NOTHING
WHILE
THE
OTHER
ONE
CAN
STILL
CATCH
A
HARE
THUS
THE
HUNTERS
ARE
THE
TWO
PLAYERS
THEIR
STRATEGIES
ARE
HUNT
STAG
AND
HUNT
HARE
AND
THE
PAYOFFS
ARE
AS
SHOWN
IN
FIGURE
HUNTER
HUNT
STAG
HUNT
HARE
HUNTER
HUNT
STAG
HUNT
HARE
FIGURE
STAG
HUNT
THIS
IS
QUITE
SIMILAR
TO
THE
UNBALANCED
COORDINATION
GAME
EXCEPT
THAT
IF
THE
TWO
PLAYERS
MISCOORDINATE
THE
ONE
WHO
WAS
TRYING
FOR
THE
HIGHER
PAYOFF
OUTCOME
GETS
PENALIZED
MORE
THAN
THE
ONE
WHO
WAS
TRYING
FOR
THE
LOWER
PAYOFF
OUTCOME
IN
FACT
THE
ONE
TRYING
FOR
THE
LOWER
PAYOFF
OUTCOME
DOESN
T
GET
PENALIZED
AT
ALL
AS
A
RESULT
THE
CHALLENGE
IN
REASONING
ABOUT
WHICH
EQUILIBRIUM
WILL
BE
CHOSEN
IS
BASED
ON
THE
TRADE
OFF
BETWEEN
THE
HIGH
PAYOFF
OF
ONE
AND
THE
LOW
DOWNSIDE
OF
MISCOORDINATION
FROM
THE
OTHER
IT
HAS
BEEN
ARGUED
THAT
THE
STAG
HUNT
GAME
CAPTURES
SOME
OF
THE
INTUITIVE
CHALLENGES
THAT
ARE
ALSO
RAISED
BY
THE
PRISONER
DILEMMA
THE
STRUCTURES
ARE
CLEARLY
DIFFERENT
SINCE
THE
PRISONER
DILEMMA
HAS
STRICTLY
DOMINANT
STRATEGIES
BOTH
HOWEVER
HAVE
THE
PROPERTY
THAT
PLAYERS
CAN
BENEFIT
IF
THEY
COOPERATE
WITH
EACH
OTHER
BUT
RISK
SUFFERING
IF
THEY
TRY
COOPERATING
WHILE
THEIR
PARTNER
DOESN
T
ANOTHER
WAY
TO
SEE
SOME
OF
THE
SIMILARITIES
BETWEEN
THE
TWO
GAMES
IS
TO
NOTICE
THAT
IF
WE
GO
BACK
TO
THE
ORIGINAL
EXAM
OR
PRESENTATION
GAME
AND
MAKE
ONE
SMALL
CHANGE
THEN
WE
END
UP
CHANGING
IT
FROM
AN
INSTANCE
OF
PRISONER
DILEMMA
TO
SOMETHING
CLOSELY
RESEMBLING
STAG
HUNT
SPECIFICALLY
SUPPOSE
THAT
WE
KEEP
THE
GRADE
OUTCOMES
THE
SAME
AS
IN
SECTION
EXCEPT
THAT
WE
REQUIRE
BOTH
YOU
AND
YOUR
PARTNER
TO
PREPARE
FOR
THE
PRESENTATION
IN
ORDER
TO
HAVE
ANY
CHANCE
OF
A
BETTER
GRADE
THAT
IS
IF
YOU
BOTH
PREPARE
YOU
BOTH
GET
A
ON
THE
PRESENTATION
BUT
IF
AT
MOST
ONE
OF
YOU
PREPARES
YOU
BOTH
GET
THE
BASE
GRADE
OF
WITH
THIS
CHANGE
THE
PAYOFFS
FOR
THE
EXAM
OR
PRESENTATION
GAME
BECOME
WHAT
IS
SHOWN
IN
FIGURE
YOU
PRESENTATION
EXAM
YOUR
PARTNER
PRESENTATION
EXAM
FIGURE
EXAM
OR
PRESENTATION
GAME
STAG
HUNT
VERSION
WE
NOW
HAVE
A
STRUCTURE
THAT
CLOSELY
RESEMBLES
THE
STAG
HUNT
GAME
COORDINATING
ON
PRESENTATION
PRESENTATION
OR
EXAM
EXAM
ARE
BOTH
EQUILIBRIA
BUT
IF
YOU
ATTEMPT
TO
GO
FOR
THE
HIGHER
PAYOFF
EQUILIBRIUM
YOU
RISK
GETTING
A
LOW
GRADE
IF
YOUR
PARTNER
OPTS
TO
STUDY
FOR
THE
EXAM
MULTIPLE
EQUILIBRIA
THE
HAWK
DOVE
GAME
MULTIPLE
NASH
EQUILIBRIA
ALSO
ARISE
IN
A
DIFFERENT
BUT
EQUALLY
FUNDAMENTAL
KIND
OF
GAME
IN
WHICH
THE
PLAYERS
ENGAGE
IN
A
KIND
OF
ANTI
COORDINATION
ACTIVITY
PROBABLY
THE
MOST
BASIC
FORM
OF
SUCH
A
GAME
IS
THE
HAWK
DOVE
GAME
WHICH
IS
MOTIVATED
BY
THE
FOLLOWING
STORY
SUPPOSE
TWO
ANIMALS
ARE
ENGAGED
IN
A
CONTEST
TO
DECIDE
HOW
A
PIECE
OF
FOOD
WILL
BE
DIVIDED
BETWEEN
THEM
EACH
ANIMAL
CAN
CHOOSE
TO
BEHAVE
AGGRESSIVELY
THE
HAWK
STRATEGY
OR
PASSIVELY
THE
DOVE
STRATEGY
IF
THE
TWO
ANIMALS
BOTH
BEHAVE
PASSIVELY
THEY
DIVIDE
THE
FOOD
EVENLY
AND
EACH
GET
A
PAYOFF
OF
IF
ONE
BEHAVES
AGGRESSIVELY
WHILE
THE
OTHER
BEHAVES
PASSIVELY
THEN
THE
AGGRESSOR
GETS
MOST
OF
THE
FOOD
OBTAINING
A
PAYOFF
OF
WHILE
THE
PASSIVE
ONE
ONLY
GETS
A
PAYOFF
OF
BUT
IF
BOTH
ANIMALS
BEHAVE
AGGRESSIVELY
THEN
THEY
DESTROY
THE
FOOD
AND
POSSIBLY
INJURE
EACH
OTHER
EACH
GETTING
A
PAYOFF
OF
THUS
WE
HAVE
THE
PAYOFF
MATRIX
IN
FIGURE
ANIMAL
D
H
ANIMAL
D
H
FIGURE
HAWK
DOVE
GAME
THIS
GAME
HAS
TWO
NASH
EQUILIBRIA
D
H
AND
H
D
WITHOUT
KNOWING
MORE
ABOUT
THE
ANIMALS
WE
CANNOT
PREDICT
WHICH
OF
THESE
EQUILIBRIA
WILL
BE
PLAYED
SO
AS
IN
THE
COORDINATION
GAMES
WE
LOOKED
AT
EARLIER
THE
CONCEPT
OF
NASH
EQUILIBRIUM
HELPS
TO
NARROW
DOWN
THE
SET
OF
REASONABLE
PREDICTIONS
BUT
IT
DOES
NOT
PROVIDE
A
UNIQUE
PREDICTION
THE
HAWK
DOVE
GAME
HAS
BEEN
STUDIED
IN
MANY
CONTEXTS
FOR
EXAMPLE
SUPPOSE
WE
SUB
STITUTE
TWO
COUNTRIES
FOR
THE
TWO
ANIMALS
AND
SUPPOSE
THAT
THE
COUNTRIES
ARE
SIMULTANEOUSLY
CHOOSING
WHETHER
TO
BE
AGGRESSIVE
OR
PASSIVE
IN
THEIR
FOREIGN
POLICY
EACH
COUNTRY
HOPES
TO
GAIN
THROUGH
BEING
AGGRESSIVE
BUT
IF
BOTH
ACT
AGGRESSIVELY
THEY
RISK
ACTUALLY
GOING
TO
WAR
WHICH
WOULD
BE
DISASTROUS
FOR
BOTH
SO
IN
EQUILIBRIUM
WE
CAN
EXPECT
THAT
ONE
WILL
BE
AGGRESSIVE
AND
ONE
WILL
BE
PASSIVE
BUT
WE
CAN
T
PREDICT
WHO
WILL
FOLLOW
WHICH
STRATEGY
AGAIN
WE
WOULD
NEED
TO
KNOW
MORE
ABOUT
THE
COUNTRIES
TO
PREDICT
WHICH
EQUILIBRIUM
WILL
BE
PLAYED
HAWK
DOVE
IS
ANOTHER
EXAMPLE
OF
A
GAME
THAT
CAN
ARISE
FROM
A
SMALL
CHANGE
TO
THE
PAYOFFS
IN
THE
EXAM
OR
PRESENTATION
GAME
LET
AGAIN
RECALL
THE
SET
UP
FROM
THE
OPENING
SECTION
AND
NOW
VARY
THINGS
SO
THAT
IF
NEITHER
YOU
NOR
YOUR
PARTNER
PREPARES
FOR
THE
PRESENTATION
YOU
WILL
GET
A
VERY
LOW
JOINT
GRADE
OF
IF
ONE
OR
BOTH
OF
YOU
PREPARE
THE
GRADES
FOR
THE
PRESENTATION
ARE
THE
SAME
AS
BEFORE
IF
WE
COMPUTE
THE
AVERAGE
GRADES
YOU
GET
FOR
DIFFERENT
CHOICES
OF
STRATEGIES
IN
THIS
VERSION
OF
THE
GAME
WE
HAVE
THE
PAYOFFS
IN
FIGURE
YOU
PRESENTATION
EXAM
YOUR
PARTNER
PRESENTATION
EXAM
FIGURE
EXAM
OR
PRESENTATION
HAWK
DOVE
VERSION
IN
THIS
VERSION
OF
THE
GAME
THERE
ARE
TWO
EQUILIBRIA
PRESENTATION
EXAM
AND
EXAM
PRESENTATION
ESSENTIALLY
ONE
OF
YOU
MUST
BEHAVE
PASSIVELY
AND
PREPARE
FOR
THE
PRESENTATION
WHILE
THE
OTHER
ACHIEVES
THE
HIGHER
PAYOFF
BY
STUDYING
FOR
THE
EXAM
IF
YOU
BOTH
TRY
TO
AVOID
THE
ROLE
OF
THE
PASSIVE
PLAYER
YOU
END
UP
WITH
VERY
LOW
PAYOFFS
BUT
WE
CANNOT
PREDICT
FROM
THE
STRUCTURE
OF
THE
GAME
ALONE
WHO
WILL
PLAY
THIS
PASSIVE
ROLE
THE
HAWK
DOVE
GAME
IS
ALSO
KNOWN
BY
A
NUMBER
OF
OTHER
NAMES
IN
THE
GAME
THEORY
LITERATURE
FOR
EXAMPLE
IT
IS
FREQUENTLY
REFERRED
TO
AS
THE
GAME
OF
CHICKEN
TO
EVOKE
THE
IMAGE
OF
TWO
TEENAGERS
RACING
THEIR
CARS
TOWARD
EACH
OTHER
DARING
EACH
OTHER
TO
BE
THE
ONE
TO
SWERVE
OUT
OF
THE
WAY
THE
TWO
STRATEGIES
HERE
ARE
SWERVE
AND
DON
T
SWERVE
THE
ONE
WHO
SWERVES
FIRST
SUFFERS
HUMILIATION
FROM
HIS
FRIENDS
BUT
IF
NEITHER
SWERVES
THEN
BOTH
SUFFER
AN
ACTUAL
COLLISION
MIXED
STRATEGIES
IN
THE
PREVIOUS
TWO
SECTIONS
WE
HAVE
BEEN
DISCUSSING
GAMES
WHOSE
CONCEPTUAL
COMPLEXITY
COMES
FROM
THE
EXISTENCE
OF
MULTIPLE
EQUILIBRIA
HOWEVER
THERE
ARE
ALSO
GAMES
WHICH
HAVE
NO
NASH
EQUILIBRIA
AT
ALL
FOR
SUCH
GAMES
WE
WILL
MAKE
PREDICTIONS
ABOUT
PLAYERS
BEHAVIOR
BY
ENLARGING
THE
SET
OF
STRATEGIES
TO
INCLUDE
THE
POSSIBILITY
OF
RANDOMIZATION
ONCE
PLAYERS
ARE
ALLOWED
TO
BEHAVE
RANDOMLY
ONE
OF
JOHN
NASH
MAIN
RESULTS
ESTABLISHES
THAT
EQUILIBRIA
ALWAYS
EXIST
PROBABLY
THE
SIMPLEST
CLASS
OF
GAMES
TO
EXPOSE
THIS
PHENOMENON
ARE
WHAT
MIGHT
BE
CALLED
ATTACK
DEFENSE
GAMES
IN
SUCH
GAMES
ONE
PLAYER
BEHAVES
AS
THE
ATTACKER
WHILE
THE
OTHER
BEHAVES
AS
THE
DEFENDER
THE
ATTACKER
CAN
USE
ONE
OF
TWO
STRATEGIES
LET
CALL
THEM
A
AND
B
WHILE
THE
DEFENDER
TWO
STRATEGIES
ARE
DEFEND
AGAINST
A
OR
DEFEND
AGAINST
B
IF
THE
DEFENDER
DEFENDS
AGAINST
THE
ATTACK
THE
ATTACKER
IS
USING
THEN
THE
DEFENDER
GETS
THE
HIGHER
PAYOFF
BUT
IF
THE
DEFENDER
DEFENDS
AGAINST
THE
WRONG
ATTACK
THEN
THE
ATTACKER
GETS
THE
HIGHER
PAYOFF
MATCHING
PENNIES
A
SIMPLE
ATTACK
DEFENSE
GAME
IS
CALLED
MATCHING
PENNIES
AND
IS
BASED
ON
A
GAME
IN
WHICH
TWO
PEOPLE
EACH
HOLD
A
PENNY
AND
SIMULTANEOUSLY
CHOOSE
WHETHER
TO
SHOW
HEADS
H
OR
TAILS
T
ON
THEIR
PENNY
PLAYER
LOSES
HIS
PENNY
TO
PLAYER
IF
THEY
MATCH
AND
WINS
PLAYER
PENNY
IF
THEY
DON
T
MATCH
THIS
PRODUCES
A
PAYOFF
MATRIX
AS
SHOWN
IN
FIGURE
PLAYER
H
T
PLAYER
H
T
FIGURE
MATCHING
PENNIES
MATCHING
PENNIES
IS
A
SIMPLE
EXAMPLE
OF
A
LARGE
CLASS
OF
INTERESTING
GAMES
WITH
THE
PROPERTY
THAT
THE
PAYOFFS
OF
THE
PLAYERS
SUM
TO
ZERO
IN
EVERY
OUTCOME
SUCH
GAMES
ARE
CALLED
ZERO
SUM
GAMES
AND
MANY
ATTACK
DEFENSE
GAMES
AND
MORE
GENERALLY
GAMES
WHERE
THE
PLAYERS
INTERESTS
ARE
IN
DIRECT
CONFLICT
HAVE
THIS
STRUCTURE
GAMES
LIKE
MATCHING
PENNIES
HAVE
IN
FACT
BEEN
USED
AS
METAPHORICAL
DESCRIPTIONS
OF
DECISIONS
MADE
IN
COMBAT
FOR
EXAMPLE
THE
ALLIED
LANDING
IN
EUROPE
ON
JUNE
ONE
OF
THE
PIVOTAL
MOMENTS
IN
WORLD
WAR
II
INVOLVED
A
DECISION
BY
THE
ALLIES
WHETHER
TO
CROSS
THE
ENGLISH
CHANNEL
AT
NORMANDY
OR
AT
CALAIS
AND
A
CORRESPONDING
DECISION
BY
THE
GERMAN
ARMY
WHETHER
TO
MASS
ITS
DEFENSIVE
FORCES
AT
NORMANDY
OR
CALAIS
THIS
HAS
AN
ATTACK
DEFENSE
STRUCTURE
THAT
CLOSELY
RESEMBLES
THE
MATCHING
PENNIES
GAME
THE
FIRST
THING
TO
NOTICE
ABOUT
MATCHING
PENNIES
IS
THAT
THERE
IS
NO
PAIR
OF
STRATEGIES
THAT
ARE
BEST
RESPONSES
TO
EACH
OTHER
TO
SEE
THIS
OBSERVE
THAT
FOR
ANY
PAIR
OF
STRATEGIES
ONE
OF
THE
PLAYERS
GETS
A
PAYOFF
OF
AND
THIS
PLAYER
WOULD
IMPROVE
HIS
OR
HER
PAYOFF
TO
BY
SWITCHING
STRATEGIES
SO
FOR
ANY
PAIR
OF
STRATEGIES
ONE
OF
THE
PLAYERS
WANTS
TO
SWITCH
WHAT
THEY
RE
DOING
ALTHOUGH
IT
NOT
CRUCIAL
FOR
THE
DISCUSSION
HERE
IT
INTERESTING
TO
NOTE
THAT
THE
THREE
CLIENT
GAME
USED
AS
AN
EXAMPLE
IN
SECTION
CAN
BE
VIEWED
INTUITIVELY
AS
A
KIND
OF
HYBRID
OF
THE
MATCHING
PENNIES
GAME
AND
THE
STAG
HUNT
GAME
IF
WE
LOOK
JUST
AT
HOW
THE
TWO
PLAYERS
EVALUATE
THE
OPTIONS
OF
APPROACHING
CLIENTS
B
AND
C
WE
HAVE
MATCHING
PENNIES
FIRM
WANTS
TO
MATCH
WHILE
FIRM
WANTS
TO
NOT
MATCH
HOWEVER
IF
THEY
COORDINATE
ON
APPROACHING
CLIENT
A
THEN
THEY
BOTH
GET
EVEN
HIGHER
PAYOFFS
THIS
MEANS
THAT
IF
WE
TREAT
EACH
PLAYER
AS
SIMPLY
HAVING
THE
TWO
STRATEGIES
H
OR
T
THEN
THERE
IS
NO
NASH
EQUILIBRIUM
FOR
THIS
GAME
THIS
IS
NOT
SO
SURPRISING
IF
WE
CONSIDER
HOW
MATCHING
PENNIES
WORKS
A
PAIR
OF
STRATEGIES
ONE
FOR
EACH
PLAYER
FORMS
A
NASH
EQUILIBRIUM
IF
EVEN
GIVEN
KNOWLEDGE
OF
EACH
OTHER
STRATEGIES
NEITHER
PLAYER
WOULD
HAVE
AN
INCENTIVE
TO
SWITCH
TO
AN
ALTERNATE
STRATEGY
BUT
IN
MATCHING
PENNIES
IF
PLAYER
KNOWS
THAT
PLAYER
IS
GOING
TO
PLAY
A
PARTICULAR
CHOICE
OF
H
OR
T
THEN
PLAYER
CAN
EXPLOIT
THIS
BY
CHOOSING
THE
OPPOSITE
AND
RECEIVING
A
PAYOFF
OF
ANALOGOUS
REASONING
HOLDS
FOR
PLAYER
WHEN
WE
THINK
INTUITIVELY
ABOUT
HOW
GAMES
OF
THIS
TYPE
ARE
PLAYED
IN
REAL
LIFE
WE
SEE
THAT
PLAYERS
GENERALLY
TRY
TO
MAKE
IT
DIFFICULT
FOR
THEIR
OPPONENTS
TO
PREDICT
WHAT
THEY
WILL
PLAY
THIS
SUGGESTS
THAT
IN
OUR
MODELING
OF
A
GAME
LIKE
MATCHING
PENNIES
WE
SHOULDN
T
TREAT
THE
STRATEGIES
AS
SIMPLY
H
OR
T
BUT
AS
WAYS
OF
RANDOMIZING
ONE
BEHAVIOR
BETWEEN
H
AND
T
WE
NOW
SEE
HOW
TO
BUILD
THIS
INTO
A
MODEL
FOR
THE
PLAY
OF
THIS
KIND
OF
GAME
MIXED
STRATEGIES
THE
SIMPLEST
WAY
TO
INTRODUCE
RANDOMIZED
BEHAVIOR
IS
TO
SAY
THAT
EACH
PLAYER
IS
NOT
ACTUALLY
CHOOSING
H
OR
T
DIRECTLY
BUT
RATHER
IS
CHOOSING
A
PROBABILITY
WITH
WHICH
SHE
WILL
PLAY
H
SO
IN
THIS
MODEL
THE
POSSIBLE
STRATEGIES
FOR
PLAYER
ARE
NUMBERS
P
BETWEEN
AND
A
GIVEN
NUMBER
P
MEANS
THAT
PLAYER
IS
COMMITTING
TO
PLAY
H
WITH
PROBABILITY
P
AND
T
WITH
PROBABILITY
P
SIMILARLY
THE
POSSIBLE
STRATEGIES
FOR
PLAYER
ARE
NUMBERS
Q
BETWEEN
AND
REPRESENTING
THE
PROBABILITY
THAT
PLAYER
WILL
PLAY
H
SINCE
A
GAME
CONSISTS
OF
A
SET
OF
PLAYERS
STRATEGIES
AND
PAYOFFS
WE
SHOULD
NOTICE
THAT
BY
ALLOWING
RANDOMIZATION
WE
HAVE
ACTUALLY
CHANGED
THE
GAME
IT
NO
LONGER
CONSISTS
OF
TWO
STRATEGIES
BY
EACH
PLAYER
BUT
INSTEAD
A
SET
OF
STRATEGIES
CORRESPONDING
TO
THE
INTERVAL
OF
NUMBERS
BETWEEN
AND
WE
WILL
REFER
TO
THESE
AS
MIXED
STRATEGIES
SINCE
THEY
INVOLVE
MIXING
BETWEEN
THE
OPTIONS
H
AND
T
NOTICE
THAT
THE
SET
OF
MIXED
STRATEGIES
STILL
INCLUDES
THE
ORIGINAL
TWO
OPTIONS
OF
COMMITTING
TO
DEFINITELY
PLAY
H
OR
T
THESE
TWO
CHOICES
CORRESPOND
TO
SELECTING
PROBABILITIES
OF
OR
RESPECTIVELY
AND
WE
WILL
REFER
TO
THEM
AS
THE
TWO
PURE
STRATEGIES
IN
THE
GAME
TO
MAKE
THINGS
MORE
INFORMAL
NOTATIONALLY
WE
WILL
SOMETIMES
REFER
TO
THE
CHOICE
OF
P
BY
PLAYER
EQUIVALENTLY
AS
THE
PURE
STRATEGY
H
AND
SIMILARLY
FOR
P
AND
Q
OR
PAYOFFS
FROM
MIXED
STRATEGIES
WITH
THIS
NEW
SET
OF
STRATEGIES
WE
ALSO
NEED
TO
DETER
MINE
THE
NEW
SET
OF
PAYOFFS
THE
SUBTLETY
IN
DEFINING
PAYOFFS
IS
THAT
THEY
ARE
NOW
RANDOM
QUANTITIES
EACH
PLAYER
WILL
GET
WITH
SOME
PROBABILITY
AND
WILL
GET
WITH
THE
REMAIN
ING
PROBABILITY
WHEN
PAYOFFS
WERE
NUMBERS
IT
WAS
OBVIOUS
HOW
TO
RANK
THEM
BIGGER
WAS
BETTER
NOW
THAT
PAYOFFS
ARE
RANDOM
IT
IS
NOT
IMMEDIATELY
OBVIOUS
HOW
TO
RANK
THEM
WE
WANT
A
PRINCIPLED
WAY
TO
SAY
THAT
ONE
RANDOM
OUTCOME
IS
BETTER
THAN
ANOTHER
TO
THINK
ABOUT
THIS
ISSUE
LET
START
BY
CONSIDERING
MATCHING
PENNIES
FROM
PLAYER
ANALOGOUSLY
TO
THE
TWO
HUNTERS
COORDINATING
TO
HUNT
STAG
POINT
OF
VIEW
AND
FOCUS
FIRST
ON
HOW
SHE
EVALUATES
HER
TWO
PURE
STRATEGIES
OF
DEFINITELY
PLAYING
H
OR
DEFINITELY
PLAYING
T
SUPPOSE
THAT
PLAYER
CHOOSES
THE
STRATEGY
Q
THAT
IS
HE
COMMITS
TO
PLAYING
H
WITH
PROBABILITY
Q
AND
T
WITH
PROBABILITY
Q
THEN
IF
PLAYER
CHOOSES
PURE
STRATEGY
H
SHE
RECEIVES
A
PAYOFF
OF
WITH
PROBABILITY
Q
SINCE
THE
TWO
PENNIES
MATCH
WITH
PROBABILITY
Q
IN
WHICH
EVENT
SHE
LOSES
AND
SHE
RECEIVES
A
PAYOFF
OF
WITH
PROBABILITY
Q
SINCE
THE
TWO
PENNIES
DON
T
MATCH
WITH
PROBABILITY
Q
ALTERNATIVELY
IF
PLAYER
CHOOSES
PURE
STRATEGY
T
SHE
RECEIVES
WITH
PROBABILITY
Q
AND
WITH
PROBABILITY
Q
SO
EVEN
IF
PLAYER
USES
A
PURE
STRATEGY
HER
PAYOFFS
CAN
STILL
BE
RANDOM
DUE
TO
THE
RANDOMIZATION
EMPLOYED
BY
PLAYER
HOW
SHOULD
WE
DECIDE
WHICH
OF
H
OR
T
IS
MORE
APPEALING
TO
PLAYER
IN
THIS
CASE
IN
ORDER
TO
RANK
RANDOM
PAYOFFS
NUMERICALLY
WE
WILL
ATTACH
A
NUMBER
TO
EACH
DISTRIBUTION
THAT
REPRESENTS
HOW
ATTRACTIVE
THIS
DISTRIBUTION
IS
TO
THE
PLAYER
ONCE
WE
HAVE
DONE
THIS
WE
CAN
THEN
RANK
OUTCOMES
ACCORDING
TO
THEIR
ASSOCIATED
NUMBER
THE
NUMBER
WE
WILL
USE
FOR
THIS
PURPOSE
IS
THE
EXPECTED
VALUE
OF
THE
PAYOFF
SO
FOR
EXAMPLE
IF
PLAYER
CHOOSES
THE
PURE
STRATEGY
H
WHILE
PLAYER
CHOOSES
A
PROBABILITY
OF
Q
AS
ABOVE
THEN
THE
EXPECTED
PAYOFF
TO
PLAYER
IS
Q
Q
SIMILARLY
IF
PLAYER
CHOOSES
THE
PURE
STRATEGY
T
WHILE
PLAYER
CHOOSES
A
PROBABILITY
OF
Q
THEN
THE
EXPECTED
PAYOFF
TO
PLAYER
IS
Q
Q
WE
WILL
ASSUME
PLAYERS
ARE
SEEKING
TO
MAXIMIZE
THE
EXPECTED
PAYOFF
THEY
GET
FROM
A
CHOICE
OF
MIXED
STRATEGIES
ALTHOUGH
THE
EXPECTATION
IS
A
NATURAL
QUANTITY
IT
IS
A
SUBTLE
QUESTION
WHETHER
MAXIMIZING
EXPECTATION
IS
A
REASONABLE
MODELING
ASSUMPTION
ABOUT
THE
BEHAVIOR
OF
PLAYERS
BY
NOW
HOWEVER
THERE
IS
A
WELL
ESTABLISHED
FOUNDATION
FOR
THE
ASSUMPTION
THAT
PLAYERS
RANK
DISTRIBUTIONS
OVER
PAYOFFS
ACCORDING
TO
THEIR
EXPECTED
VALUES
AND
SO
WE
WILL
FOLLOW
IT
HERE
WE
HAVE
NOW
DEFINED
THE
MIXED
STRATEGY
VERSION
OF
THE
MATCHING
PENNIES
GAME
STRATEGIES
ARE
PROBABILITIES
OF
PLAYING
H
AND
PAYOFFS
ARE
THE
EXPECTATIONS
OF
THE
PAYOFFS
FROM
THE
FOUR
PURE
OUTCOMES
H
H
H
T
T
H
AND
T
T
WE
CAN
NOW
ASK
WHETHER
THERE
IS
A
NASH
EQUILIBRIUM
FOR
THIS
RICHER
VERSION
OF
THE
GAME
EQUILIBRIUM
WITH
MIXED
STRATEGIES
WE
DEFINE
A
NASH
EQUILIBRIUM
FOR
THE
MIXED
STRATEGY
VERSION
JUST
AS
WE
DID
FOR
THE
PURE
STRATEGY
VERSION
IT
IS
A
PAIR
OF
STRATEGIES
NOW
PROBABILITIES
SO
THAT
EACH
IS
A
BEST
RESPONSE
TO
THE
OTHER
FIRST
LET
OBSERVE
THAT
NO
PURE
STRATEGY
CAN
BE
PART
OF
A
NASH
EQUILIBRIUM
THIS
IS
EQUIVALENT
TO
THE
REASONING
WE
DID
AT
THE
OUTSET
OF
THIS
SECTION
SUPPOSE
FOR
EXAMPLE
THAT
THE
PURE
STRATEGY
H
I
E
PROBABILITY
P
BY
PLAYER
WERE
PART
OF
A
NASH
EQUILIBRIUM
THEN
PLAYER
UNIQUE
BEST
RESPONSE
WOULD
BE
THE
PURE
STRATEGY
H
AS
WELL
SINCE
PLAYER
GETS
WHENEVER
HE
MATCHES
BUT
H
BY
PLAYER
IS
NOT
A
BEST
RESPONSE
TO
H
BY
PLAYER
SO
IN
FACT
THIS
COULDN
T
BE
A
NASH
EQUILIBRIUM
ANALOGOUS
REASONING
APPLIES
TO
THE
OTHER
POSSIBLE
PURE
STRATEGIES
BY
THE
TWO
PLAYERS
SO
WE
REACH
THE
NATURAL
CONCLUSION
THAT
IN
ANY
NASH
EQUILIBRIUM
BOTH
PLAYERS
MUST
BE
USING
PROBABILITIES
THAT
ARE
STRICTLY
BETWEEN
AND
NEXT
LET
ASK
WHAT
PLAYER
BEST
RESPONSE
SHOULD
BE
TO
THE
STRATEGY
Q
USED
BY
PLAYER
ABOVE
WE
DETERMINED
THAT
THE
EXPECTED
PAYOFF
TO
PLAYER
FROM
THE
PURE
STRATEGY
H
IN
THIS
CASE
IS
WHILE
THE
EXPECTED
PAYOFF
TO
PLAYER
FROM
THE
PURE
STRATEGY
T
IS
NOW
HERE
THE
KEY
POINT
IF
THEN
ONE
OF
THE
PURE
STRATEGIES
H
OR
T
IS
IN
FACT
THE
UNIQUE
BEST
RESPONSE
BY
PLAYER
TO
A
PLAY
OF
Q
BY
PLAYER
THIS
IS
SIMPLY
BECAUSE
ONE
OF
OR
IS
LARGER
IN
THIS
CASE
AND
SO
THERE
IS
NO
POINT
FOR
PLAYER
TO
PUT
ANY
PROBABILITY
ON
HER
WEAKER
PURE
STRATEGY
BUT
WE
ALREADY
ESTABLISHED
THAT
PURE
STRATEGIES
CANNOT
BE
PART
OF
ANY
NASH
EQUILIBRIUM
FOR
MATCHING
PENNIES
AND
BECAUSE
PURE
STRATEGIES
ARE
THE
BEST
RESPONSES
WHENEVER
PROBABILITIES
THAT
MAKE
THESE
TWO
EXPECTATIONS
UNEQUAL
CANNOT
BE
PART
OF
A
NASH
EQUILIBRIUM
EITHER
SO
WE
VE
CONCLUDED
THAT
IN
ANY
NASH
EQUILIBRIUM
FOR
THE
MIXED
STRATEGY
VERSION
OF
MATCH
ING
PENNIES
WE
MUST
HAVE
OR
IN
OTHER
WORDS
Q
THE
SITUATION
IS
SYMMETRIC
WHEN
WE
CONSIDER
THINGS
FROM
PLAYER
POINT
OF
VIEW
AND
EVALUATE
THE
PAYOFFS
FROM
A
PLAY
OF
PROBABILITY
P
BY
PLAYER
WE
CONCLUDE
FROM
THIS
THAT
IN
ANY
NASH
EQUILIBRIUM
WE
MUST
ALSO
HAVE
P
THUS
THE
PAIR
OF
STRATEGIES
P
AND
Q
IS
THE
ONLY
POSSIBILITY
FOR
A
NASH
EQUILIBRIUM
WE
CAN
CHECK
THAT
THIS
PAIR
OF
STRATEGIES
IN
FACT
DO
FORM
BEST
RESPONSES
TO
EACH
OTHER
AS
A
RESULT
THIS
IS
THE
UNIQUE
NASH
EQUILIBRIUM
FOR
THE
MIXED
STRATEGY
VERSION
OF
MATCHING
PENNIES
INTERPRETING
THE
MIXED
STRATEGY
EQUILIBRIUM
FOR
MATCHING
PENNIES
HAVING
DE
RIVED
THE
NASH
EQUILIBRIUM
FOR
THIS
GAME
IT
USEFUL
TO
THINK
ABOUT
WHAT
IT
MEANS
AND
HOW
WE
CAN
APPLY
THIS
REASONING
TO
GAMES
IN
GENERAL
FIRST
LET
PICTURE
A
CONCRETE
SETTING
IN
WHICH
TWO
PEOPLE
ACTUALLY
SIT
DOWN
TO
PLAY
MATCHING
PENNIES
AND
EACH
OF
THEM
ACTUALLY
COMMITS
TO
BEHAVING
RANDOMLY
ACCORDING
TO
PROBABILITIES
P
AND
Q
RESPECTIVELY
IF
PLAYER
BELIEVES
THAT
PLAYER
WILL
PLAY
H
STRICTLY
MORE
THAN
HALF
THE
TIME
THEN
SHE
SHOULD
DEFINITELY
PLAY
T
IN
WHICH
CASE
PLAYER
SHOULD
NOT
BE
PLAYING
H
MORE
THAN
HALF
THE
TIME
THE
SYMMETRIC
REASONING
APPLIES
IF
PLAYER
BELIEVES
THAT
PLAYER
WILL
PLAY
T
STRICTLY
MORE
THAN
HALF
THE
TIME
IN
NEITHER
CASE
WOULD
WE
HAVE
A
NASH
EQUILIBRIUM
SO
THE
POINT
IS
THAT
THE
CHOICE
OF
Q
BY
PLAYER
MAKES
PLAYER
INDIFFERENT
BETWEEN
PLAYING
H
OR
T
THE
STRATEGY
Q
IS
EFFECTIVELY
NON
EXPLOITABLE
BY
PLAYER
THIS
WAS
IN
FACT
OUR
ORIGINAL
INTUITION
FOR
INTRODUCING
RANDOMIZATION
EACH
PLAYER
WANTS
THEIR
BEHAVIOR
TO
BE
UNPREDICTABLE
TO
THE
OTHER
SO
THAT
THEIR
BEHAVIOR
CAN
T
BE
TAKEN
ADVANTAGE
OF
WE
SHOULD
NOTE
THAT
THE
FACT
THAT
BOTH
PROBABILITIES
TURNED
OUT
TO
BE
IS
A
RESULT
OF
THE
HIGHLY
SYMMETRIC
STRUCTURE
OF
MATCHING
PENNIES
AS
WE
WILL
SEE
IN
SUBSEQUENT
EXAMPLES
IN
THE
NEXT
SECTION
WHEN
THE
PAYOFFS
ARE
LESS
SYMMETRIC
THE
NASH
EQUILIBRIUM
CAN
CONSIST
OF
UNEQUAL
PROBABILITIES
THIS
NOTION
OF
INDIFFERENCE
IS
A
GENERAL
PRINCIPLE
BEHIND
THE
COMPUTATION
OF
MIXED
STRATEGY
EQUILIBRIA
IN
TWO
PLAYER
TWO
STRATEGY
GAMES
WHEN
THERE
ARE
NO
EQUILIBRIA
INVOLVING
PURE
STRATEGIES
EACH
PLAYER
SHOULD
RANDOMIZE
SO
AS
TO
MAKE
THE
OTHER
PLAYER
INDIFFERENT
BETWEEN
THEIR
TWO
ALTERNATIVES
THIS
WAY
NEITHER
PLAYER
BEHAVIOR
CAN
BE
EXPLOITED
BY
A
PURE
STRATEGY
AND
THE
TWO
CHOICES
OF
PROBABILITIES
ARE
BEST
RESPONSES
TO
EACH
OTHER
AND
ALTHOUGH
WE
WON
T
PURSUE
THE
DETAILS
OF
IT
HERE
A
GENERALIZATION
OF
THIS
PRINCIPLE
APPLIES
TO
GAMES
WITH
ANY
FINITE
NUMBER
OF
PLAYERS
AND
ANY
FINITE
NUMBER
OF
STRATEGIES
NASH
MAIN
MATHEMATICAL
RESULT
ACCOMPANYING
HIS
DEFINITION
OF
EQUILIBRIUM
WAS
TO
PROVE
THAT
EVERY
SUCH
GAME
HAS
AT
LEAST
ONE
MIXED
STRATEGY
EQUILIBRIUM
IT
ALSO
WORTH
THINKING
ABOUT
HOW
TO
INTERPRET
MIXED
STRATEGY
EQUILIBRIA
IN
REAL
WORLD
SITUATIONS
THERE
ARE
IN
FACT
SEVERAL
POSSIBLE
INTERPRETATIONS
THAT
ARE
APPROPRIATE
IN
DIFFERENT
SITUATIONS
SOMETIMES
PARTICULARLY
WHEN
THE
PARTICIPANTS
ARE
GENUINELY
PLAYING
A
SPORT
OR
GAME
THE
PLAYERS
MAY
BE
ACTIVELY
RANDOMIZING
THEIR
ACTIONS
A
TENNIS
PLAYER
MAY
BE
RANDOMLY
DECIDING
WHETHER
TO
SERVE
THE
BALL
UP
THE
CENTER
OR
OUT
TO
THE
SIDE
OF
THE
COURT
A
CARD
PLAYER
MAY
BE
RANDOMLY
DECIDING
WHETHER
TO
BLUFF
OR
NOT
TWO
CHILDREN
MAY
BE
RANDOMIZING
AMONG
ROCK
PAPER
AND
SCISSORS
IN
THE
PERENNIAL
ELEMENTARY
SCHOOL
CONTEST
OF
THE
SAME
NAME
WE
WILL
LOOK
AT
EXAMPLES
OF
THIS
IN
THE
NEXT
SECTION
SOMETIMES
THE
MIXED
STRATEGIES
ARE
BETTER
VIEWED
AS
PROPORTIONS
WITHIN
A
POPULATION
SUPPOSE
FOR
EXAMPLE
THAT
TWO
SPECIES
OF
ANIMALS
IN
THE
PROCESS
OF
FORAGING
FOR
FOOD
REGULARLY
ENGAGE
IN
ONE
ON
ONE
ATTACK
DEFENSE
GAMES
WITH
THE
STRUCTURE
OF
MATCHING
PENNIES
HERE
A
SINGLE
MEMBER
OF
THE
FIRST
SPECIES
ALWAYS
PLAYS
THE
ROLE
OF
ATTACKER
AND
A
SINGLE
MEMBER
OF
THE
SECOND
SPECIES
ALWAYS
PLAYS
THE
ROLE
OF
DEFENDER
LET
SUPPOSE
THAT
EACH
INDIVIDUAL
ANIMAL
IS
GENETICALLY
HARD
WIRED
TO
ALWAYS
PLAY
H
OR
ALWAYS
PLAY
T
AND
SUPPOSE
FURTHER
THAT
THE
POPULATION
OF
EACH
SPECIES
CONSISTS
HALF
OF
ANIMALS
HARD
WIRED
TO
PLAY
H
AND
HALF
OF
ANIMALS
HARD
WIRED
TO
PLAY
T
THEN
WITH
THIS
POPULATION
MIXTURE
H
ANIMALS
IN
EACH
SPECIES
DO
EXACTLY
AS
WELL
ON
AVERAGE
OVER
MANY
RANDOM
INTERACTIONS
AS
T
ANIMALS
HENCE
THE
POPULATION
AS
A
WHOLE
IS
IN
A
KIND
OF
MIXED
EQUILIBRIUM
EVEN
THOUGH
EACH
INDIVIDUAL
IS
PLAYING
A
PURE
STRATEGY
THIS
STORY
SUGGESTS
AN
IMPORTANT
LINK
WITH
EVOLUTIONARY
BIOLOGY
WHICH
HAS
IN
FACT
BEEN
DEVELOPED
THROUGH
A
LONG
LINE
OF
RESEARCH
THIS
TOPIC
WILL
BE
OUR
FOCUS
IN
CHAPTER
MAYBE
THE
MOST
SUBTLE
INTERPRETATION
IS
BASED
ON
RECALLING
FROM
SECTION
THAT
NASH
EQUILIBRIUM
IS
OFTEN
BEST
THOUGHT
OF
AS
AN
EQUILIBRIUM
IN
BELIEFS
IF
EACH
PLAYER
BELIEVES
THAT
HER
PARTNER
WILL
PLAY
ACCORDING
TO
A
PARTICULAR
NASH
EQUILIBRIUM
THEN
SHE
TOO
WILL
WANT
TO
PLAY
ACCORDING
TO
IT
IN
THE
CASE
OF
MATCHING
PENNIES
WITH
ITS
UNIQUE
MIXED
EQUILIBRIUM
THIS
MEANS
THAT
IT
IS
ENOUGH
FOR
YOU
TO
EXPECT
THAT
WHEN
YOU
MEET
AN
ARBITRARY
PERSON
THEY
WILL
PLAY
THEIR
SIDE
OF
MATCHING
PENNIES
WITH
A
PROBABILITY
OF
IN
THIS
CASE
PLAYING
A
PROBABILITY
OF
MAKES
SENSE
FOR
YOU
TOO
AND
HENCE
THIS
CHOICE
OF
PROBABILITIES
IS
SELF
REINFORCING
IT
IS
IN
EQUILIBRIUM
ACROSS
THE
ENTIRE
POPULATION
MIXED
STRATEGIES
EXAMPLES
AND
EMPIRICAL
ANAL
YSIS
BECAUSE
MIXED
STRATEGY
EQUILIBRIUM
IS
A
SUBTLE
CONCEPT
IT
USEFUL
TO
THINK
ABOUT
IT
THROUGH
FURTHER
EXAMPLES
WE
WILL
FOCUS
ON
TWO
MAIN
EXAMPLES
BOTH
DRAWN
FROM
THE
REALM
OF
SPORTS
AND
BOTH
WITH
ATTACK
DEFENSE
STRUCTURES
THE
FIRST
IS
STYLIZED
AND
PARTLY
METAPHORICAL
WHILE
THE
SECOND
REPRESENTS
A
STRIKING
EMPIRICAL
TEST
OF
WHETHER
PEOPLE
IN
HIGH
STAKES
SITUATIONS
ACTUALLY
FOLLOW
THE
PREDICTIONS
OF
MIXED
STRATEGY
EQUILIBRIUM
WE
CONCLUDE
THE
SECTION
WITH
A
GENERAL
DISCUSSION
OF
HOW
TO
IDENTIFY
ALL
THE
EQUILIBRIA
OF
A
TWO
PLAYER
TWO
STRATEGY
GAME
THE
RUN
PASS
GAME
FIRST
LET
CONSIDER
A
STREAMLINED
VERSION
OF
THE
PROBLEM
FACED
BY
TWO
AMERICAN
FOOTBALL
TEAMS
AS
THEY
PLAN
THEIR
NEXT
PLAY
IN
A
FOOTBALL
GAME
THE
OFFENSE
CAN
CHOOSE
EITHER
TO
RUN
OR
TO
PASS
AND
THE
DEFENSE
CAN
CHOOSE
EITHER
TO
DEFEND
AGAINST
THE
RUN
OR
TO
DEFEND
AGAINST
THE
PASS
HERE
IS
HOW
THE
PAYOFFS
WORK
IF
THE
DEFENSE
CORRECTLY
MATCHES
THE
OFFENSE
PLAY
THEN
THE
OFFENSE
GAINS
YARDS
IF
THE
OFFENSE
RUNS
WHILE
THE
DEFENSE
DEFENDS
AGAINST
THE
PASS
THE
OFFENSE
GAINS
YARDS
IF
THE
OFFENSE
PASSES
WHILE
THE
DEFENSE
DEFENDS
AGAINST
THE
RUN
THE
OFFENSE
GAINS
YARDS
HENCE
WE
HAVE
THE
PAYOFF
MATRIX
SHOWN
IN
FIGURE
IF
YOU
DON
T
KNOW
THE
RULES
OF
AMERICAN
FOOTBALL
YOU
CAN
FOLLOW
THE
DISCUSSION
SIMPLY
BY
TAKING
THE
PAYOFF
MATRIX
AS
SELF
CONTAINED
INTUITIVELY
THE
POINT
IS
SIMPLY
THAT
WE
HAVE
OFFENSE
PASS
RUN
DEFENSE
DEFEND
PASS
DEFEND
RUN
FIGURE
RUN
PASS
GAME
AN
ATTACK
DEFENSE
GAME
WITH
TWO
PLAYERS
NAMED
OFFENSE
AND
DEFENSE
RESPECTIVELY
AND
WHERE
THE
ATTACKER
HAS
A
STRONGER
OPTION
PASS
AND
A
WEAKER
OPTION
RUN
JUST
AS
IN
MATCHING
PENNIES
IT
EASY
TO
CHECK
THAT
THERE
IS
NO
NASH
EQUILIBRIUM
WHERE
EITHER
PLAYER
USES
A
PURE
STRATEGY
BOTH
HAVE
TO
MAKE
THEIR
BEHAVIOR
UNPREDICTABLE
BY
RAN
DOMIZING
SO
LET
WORK
OUT
A
MIXED
STRATEGY
EQUILIBRIUM
FOR
THIS
GAME
LET
P
BE
THE
PROB
ABILITY
THAT
THE
OFFENSE
PASSES
AND
LET
Q
BE
THE
PROBABILITY
THAT
THE
DEFENSE
DEFENDS
AGAINST
THE
PASS
WE
KNOW
FROM
NASH
RESULT
THAT
AT
LEAST
ONE
MIXED
STRATEGY
EQUILIBRIUM
MUST
EXIST
BUT
NOT
WHAT
THE
ACTUAL
VALUES
OF
P
AND
Q
SHOULD
BE
WE
USE
THE
PRINCIPLE
THAT
A
MIXED
EQUILIBRIUM
ARISES
WHEN
THE
PROBABILITIES
USED
BY
EACH
PLAYER
MAKES
HIS
OPPONENT
INDIFFERENT
BETWEEN
HIS
TWO
OPTIONS
FIRST
SUPPOSE
THE
DEFENSE
CHOOSES
A
PROBABILITY
OF
Q
FOR
DEFENDING
AGAINST
THE
PASS
THEN
THE
EXPECTED
PAYOFF
TO
THE
OFFENSE
FROM
PASSING
IS
Q
Q
WHILE
THE
EXPECTED
PAYOFF
TO
THE
OFFENSE
FROM
RUNNING
IS
Q
Q
TO
MAKE
THE
OFFENSE
INDIFFERENT
BETWEEN
ITS
TWO
STRATEGIES
WE
NEED
TO
SET
AND
HENCE
Q
NEXT
SUPPOSE
THE
OFFENSE
CHOOSES
A
PROBABILITY
OF
P
FOR
PASSING
THEN
THE
EXPECTED
PAYOFF
TO
THE
DEFENSE
FROM
DEFENDING
AGAINST
THE
PASS
IS
P
P
WITH
THE
EXPECTED
PAYOFF
TO
THE
DEFENSE
FROM
DEFENDING
AGAINST
THE
RUN
IS
P
P
TO
MAKE
THE
DEFENSE
INDIFFERENT
BETWEEN
ITS
TWO
STRATEGIES
WE
NEED
TO
SET
AND
HENCE
P
THUS
THE
ONLY
POSSIBLE
PROBABILITY
VALUES
THAT
CAN
APPEAR
IN
A
MIXED
STRATEGY
EQUILIBRIUM
ARE
P
FOR
THE
OFFENSE
AND
Q
FOR
THE
DEFENSE
AND
THIS
IN
FACT
FORMS
AN
EQUILIBRIUM
NOTICE
ALSO
THAT
THE
EXPECTED
PAYOFF
TO
THE
OFFENSE
WITH
THESE
PROBABILITIES
IS
AND
THE
CORRESPONDING
EXPECTED
PAYOFF
TO
THE
DEFENSE
IS
ALSO
IN
CONTRAST
TO
MATCHING
PENNIES
NOTICE
THAT
BECAUSE
OF
THE
ASYMMETRIC
STRUCTURE
OF
THE
PAYOFFS
HERE
THE
PROBABILITIES
THAT
APPEAR
IN
THE
MIXED
STRATEGY
EQUILIBRIUM
ARE
UNBALANCED
AS
WELL
STRATEGIC
INTERPRETATION
OF
THE
RUN
PASS
GAME
THERE
ARE
SEVERAL
THINGS
TO
NOTICE
ABOUT
THIS
EQUILIBRIUM
FIRST
THE
STRATEGIC
IMPLICATIONS
OF
THE
EQUILIBRIUM
PROBABILITIES
ARE
INTRIGUING
AND
A
BIT
SUBTLE
SPECIFICALLY
ALTHOUGH
PASSING
IS
THE
OFFENSE
MORE
POWERFUL
WEAPON
IT
USES
IT
LESS
THAN
HALF
THE
TIME
IT
PLACES
ONLY
PROBABILITY
P
ON
PASSING
THIS
INITIALLY
SEEMS
COUNTER
INTUITIVE
WHY
NOT
SPEND
MORE
TIME
USING
YOUR
MORE
POWERFUL
OPTION
BUT
THE
CALCULATION
THAT
GAVE
US
THE
EQUILIBRIUM
PROBABILITIES
ALSO
SUPPLIES
THE
ANSWER
TO
THIS
QUESTION
IF
THE
OFFENSE
PLACED
ANY
HIGHER
PROBABILITY
ON
PASSING
THEN
THE
DEFENSE
BEST
RESPONSE
WOULD
BE
TO
ALWAYS
DEFEND
AGAINST
THE
PASS
AND
THE
OFFENSE
WOULD
ACTUALLY
DO
WORSE
IN
EXPECTATION
WE
CAN
SEE
HOW
THIS
WORKS
BY
TRYING
A
LARGER
VALUE
FOR
P
LIKE
P
IN
THIS
CASE
THE
DEFENSE
WILL
ALWAYS
DEFEND
AGAINST
THE
PASS
AND
SO
THE
OFFENSE
EXPECTED
PAYOFF
WILL
BE
SINCE
IT
GAINS
HALF
THE
TIME
AND
THE
OTHER
HALF
THE
TIME
ABOVE
WE
SAW
THAT
WITH
THE
EQUILIBRIUM
PROBABILITIES
THE
OFFENSE
HAS
AN
EXPECTED
PAYOFF
OF
MOREOVER
BECAUSE
P
MAKES
THE
DEFENSE
INDIFFERENT
BETWEEN
ITS
TWO
STRATEGIES
AN
OFFENSE
THAT
USES
P
IS
GUARANTEED
TO
GET
NO
MATTER
WHAT
THE
DEFENSE
DOES
ONE
WAY
TO
THINK
ABOUT
THE
REAL
POWER
OF
PASSING
AS
A
STRATEGY
IS
TO
NOTICE
THAT
IN
EQUILIBRIUM
THE
DEFENSE
IS
DEFENDING
AGAINST
THE
PASS
OF
THE
TIME
EVEN
THOUGH
THE
OFFENSE
IS
USING
IT
ONLY
OF
THE
TIME
SO
SOMEHOW
THE
THREAT
OF
PASSING
IS
HELPING
THE
OFFENSE
EVEN
THOUGH
IT
USES
IT
RELATIVELY
RARELY
THIS
EXAMPLE
CLEARLY
OVER
SIMPLIFIES
THE
STRATEGIC
ISSUES
AT
WORK
IN
AMERICAN
FOOTBALL
THERE
ARE
MANY
MORE
THAN
JUST
TWO
STRATEGIES
AND
TEAMS
ARE
CONCERNED
WITH
MORE
THAN
JUST
THEIR
YARDAGE
ON
THE
VERY
NEXT
PLAY
NEVERTHELESS
THIS
TYPE
OF
ANALYSIS
HAS
BEEN
APPLIED
QUANTITATIVELY
TO
STATISTICS
FROM
AMERICAN
FOOTBALL
VERIFYING
SOME
OF
THE
MAIN
QUALITATIVE
CONCLUSIONS
AT
A
BROAD
LEVEL
THAT
TEAMS
GENERALLY
RUN
MORE
THAN
THEY
PASS
AND
THAT
THE
EXPECTED
YARDAGE
GAINED
PER
PLAY
FROM
RUNNING
IS
CLOSE
TO
THE
EXPECTED
YARDAGE
GAINED
PER
PLAY
FROM
PASSING
FOR
MOST
TEAMS
THE
PENALTY
KICK
GAME
THE
COMPLEXITY
OF
AMERICAN
FOOTBALL
MAKES
IT
HARD
TO
CAST
IT
TRULY
ACCURATELY
AS
A
TWO
PERSON
TWO
STRATEGY
GAME
WE
NOW
FOCUS
ON
A
DIFFERENT
SETTING
ALSO
FROM
PROFESSIONAL
SPORTS
WHERE
SUCH
A
FORMALIZATION
CAN
BE
DONE
MUCH
MORE
EXACTLY
THE
MODELING
OF
PENALTY
KICKS
IN
SOCCER
AS
A
TWO
PLAYER
GAME
IN
IGNACIO
PALACIOS
HUERTA
UNDERTOOK
A
LARGE
STUDY
OF
PENALTY
KICKS
FROM
THE
PER
SPECTIVE
OF
GAME
THEORY
AND
WE
FOCUS
ON
HIS
ANALYSIS
HERE
AS
HE
OBSERVED
PENALTY
KICKS
CAPTURE
THE
INGREDIENTS
OF
TWO
PLAYER
TWO
STRATEGY
GAMES
REMARKABLY
FAITHFULLY
THE
KICKER
CAN
AIM
THE
BALL
TO
THE
LEFT
OR
THE
RIGHT
OF
THE
GOAL
AND
THE
GOALIE
CAN
DIVE
TO
EITHER
THE
LEFT
OR
RIGHT
AS
WELL
THE
BALL
MOVES
TO
THE
GOAL
FAST
ENOUGH
THAT
THE
DECISIONS
OF
THE
KICKER
AND
GOALIE
ARE
EFFECTIVELY
BEING
MADE
SIMULTANEOUSLY
AND
BASED
ON
THESE
DECISIONS
THE
KICKER
IS
LIKELY
TO
SCORE
OR
NOT
INDEED
THE
STRUCTURE
OF
THE
GAME
IS
VERY
MUCH
LIKE
MATCHING
PENNIES
IF
THE
GOALIE
DIVES
IN
THE
DIRECTION
WHERE
THE
BALL
IS
AIMED
HE
HAS
A
GOOD
CHANCE
OF
BLOCKING
IT
IF
THE
GOALIE
DIVES
IN
THE
WRONG
DIRECTION
IT
IS
VERY
LIKELY
TO
GO
IN
THE
GOAL
BASED
ON
AN
ANALYSIS
OF
ROUGHLY
PENALTY
KICKS
IN
PROFESSIONAL
SOCCER
PALACIOS
HUERTA
DETERMINED
THE
EMPIRICAL
PROBABILITY
OF
SCORING
FOR
EACH
OF
THE
FOUR
BASIC
OUTCOMES
WHETHER
THE
KICKER
AIMS
LEFT
OR
RIGHT
AND
WHETHER
THE
GOALIE
DIVES
LEFT
OR
RIGHT
THIS
LED
TO
A
PAYOFF
MATRIX
AS
SHOWN
IN
FIGURE
KICKER
L
R
GOALIE
L
R
FIGURE
THE
PENALTY
KICK
GAMES
FROM
EMPIRICAL
DATA
THERE
ARE
A
FEW
CONTRASTS
TO
NOTE
IN
RELATION
TO
THE
BASIC
MATCHING
PENNIES
GAME
FIRST
A
KICKER
HAS
A
REASONABLY
GOOD
CHANCE
OF
SCORING
EVEN
WHEN
THE
GOALIE
DIVES
IN
THE
CORRECT
DIRECTION
ALTHOUGH
A
CORRECT
CHOICE
BY
THE
GOALIE
STILL
GREATLY
REDUCES
THIS
PROBABILITY
SECOND
KICKERS
ARE
GENERALLY
RIGHT
FOOTED
AND
SO
THEIR
CHANCE
OF
SCORING
IS
NOT
COMPLETELY
SYMMETRIC
BETWEEN
AIMING
LEFT
AND
AIMING
RIGHT
DESPITE
THESE
CAVEATS
THE
BASIC
PREMISE
OF
MATCHING
PENNIES
IS
STILL
PRESENT
HERE
THERE
IS
NO
EQUILIBRIUM
IN
PURE
STRATEGIES
AND
SO
WE
NEED
TO
CONSIDER
HOW
PLAYERS
SHOULD
RANDOM
IZE
THEIR
BEHAVIOR
IN
PLAYING
THIS
GAME
USING
THE
PRINCIPLE
OF
INDIFFERENCE
AS
IN
PREVIOUS
EXAMPLES
WE
SEE
THAT
IF
Q
IS
THE
PROBABILITY
THAT
A
GOALIE
CHOOSES
L
WE
NEED
TO
SET
Q
SO
AS
TO
MAKE
THE
KICKER
INDIFFERENT
BETWEEN
HIS
TWO
OPTIONS
Q
Q
Q
Q
SOLVING
FOR
Q
WE
GET
Q
WE
CAN
DO
THE
ANALOGOUS
CALCULATION
TO
OBTAIN
THE
VALUE
OF
P
THAT
MAKES
THE
GOALIE
INDIFFERENT
OBTAINING
P
THE
STRIKING
PUNCHLINE
TO
THIS
STUDY
IS
THAT
IN
THE
DATASET
OF
REAL
PENALTY
KICKS
THE
GOALIES
DIVE
LEFT
A
FRACTION
OF
THE
TIME
MATCHING
THE
PREDICTION
TO
TWO
DECIMAL
PLACES
UP
THE
CENTER
AND
DECISIONS
BY
THE
GOALIE
TO
REMAIN
IN
THE
CENTER
ARE
VERY
RARE
AND
CAN
BE
IGNORED
IN
A
SIMPLE
VERSION
OF
THE
ANALYSIS
PURPOSES
OF
THE
ANALYSIS
WE
TAKE
ALL
THE
LEFT
FOOTED
KICKERS
IN
THE
DATA
AND
APPLY
A
LEFT
RIGHT
REFLECTION
TO
ALL
THEIR
ACTIONS
SO
THAT
R
ALWAYS
DENOTES
THE
NATURAL
SIDE
FOR
EACH
KICKER
AND
THE
KICKERS
AIM
LEFT
A
FRACTION
OF
THE
TIME
COMING
WITHIN
OF
THE
PREDICTION
IT
IS
PARTICULARLY
NICE
TO
FIND
THE
THEORY
PREDICTIONS
BORNE
OUT
IN
A
SETTING
SUCH
AS
PROFESSIONAL
SOCCER
SINCE
THE
TWO
PLAYER
GAME
UNDER
STUDY
IS
BEING
PLAYED
BY
EXPERTS
AND
THE
OUTCOME
IS
IMPORTANT
ENOUGH
TO
THE
PARTICIPANTS
THAT
THEY
ARE
INVESTING
SIGNIFICANT
ATTENTION
TO
THEIR
CHOICE
OF
STRATEGIES
FINDING
ALL
NASH
EQUILIBRIA
TO
CONCLUDE
OUR
DISCUSSION
OF
MIXED
STRATEGY
EQUILIBRIA
WE
CONSIDER
THE
GENERAL
QUESTION
OF
HOW
TO
FIND
ALL
NASH
EQUILIBRIA
OF
A
TWO
PLAYER
TWO
STRATEGY
GAME
FIRST
IT
IS
IMPORTANT
TO
NOTE
THAT
A
GAME
MAY
HAVE
BOTH
PURE
STRATEGY
AND
MIXED
STRATEGY
EQUILIBRIA
AS
A
RESULT
ONE
SHOULD
FIRST
CHECK
ALL
FOUR
PURE
OUTCOMES
GIVEN
BY
PAIRS
OF
PURE
STRATEGIES
TO
SEE
WHICH
IF
ANY
FORM
EQUILIBRIA
THEN
TO
CHECK
WHETHER
THERE
ARE
ANY
MIXED
STRATEGY
EQUILIBRIA
WE
NEED
TO
SEE
WHETHER
THERE
ARE
MIXING
PROBABILITIES
P
AND
Q
THAT
ARE
BEST
RESPONSES
TO
EACH
OTHER
IF
THERE
IS
A
MIXED
STRATEGY
EQUILIBRIUM
THEN
WE
CAN
DETERMINE
PLAYER
STRATEGY
Q
FROM
THE
REQUIREMENT
THAT
PLAYER
RANDOMIZES
PLAYER
WILL
ONLY
RANDOMIZE
IF
HIS
PURE
STRATEGIES
HAVE
EQUAL
EXPECTED
PAYOFF
THIS
EQUALITY
OF
EXPECTED
PAYOFFS
FOR
PLAYER
GIVES
US
ONE
EQUATION
WHICH
WE
CAN
SOLVE
TO
DETERMINE
Q
THE
SAME
PROCESS
GIVES
AN
EQUATION
TO
SOLVE
FOR
DETERMINING
PLAYER
STRATEGY
P
IF
BOTH
OF
THE
OBTAINED
VALUES
P
AND
Q
ARE
STRICTLY
BETWEEN
AND
AND
ARE
THUS
LEGITIMATE
MIXED
STRATEGIES
THEN
WE
HAVE
A
MIXED
STRATEGY
EQUILIBRIUM
THUS
FAR
OUR
EXAMPLES
OF
MIXED
STRATEGY
EQUILIBRIA
HAVE
BEEN
RESTRICTED
TO
GAMES
WITH
AN
ATTACK
DEFENSE
STRUCTURE
AND
SO
WE
HAVE
NOT
SEEN
AN
EXAMPLE
EXHIBITING
BOTH
PURE
AND
MIXED
EQUILIBRIA
HOWEVER
IT
IS
NOT
HARD
TO
FIND
SUCH
EXAMPLES
IN
PARTICULAR
COORDINATION
AND
HAWK
DOVE
GAMES
WITH
TWO
PURE
EQUILIBRIA
WILL
HAVE
A
THIRD
MIXED
EQUILIBRIUM
IN
WHICH
EACH
PLAYER
RANDOMIZES
AS
AN
EXAMPLE
LET
CONSIDER
THE
UNBALANCED
COORDINATION
GAME
FROM
SECTION
YOU
POWERPOINT
KEYNOTE
YOUR
PARTNER
POWERPOINT
KEYNOTE
FIGURE
UNBALANCED
COORDINATION
GAME
SUPPOSE
THAT
YOU
PLACE
A
PROBABILITY
OF
P
STRICTLY
BETWEEN
AND
ON
POWERPOINT
AND
YOUR
PARTNER
PLACES
A
PROBABILITY
OF
Q
STRICTLY
BETWEEN
AND
ON
POWERPOINT
THEN
YOU
LL
BE
INDIFFERENT
BETWEEN
POWERPOINT
AND
KEYNOTE
IF
Q
Q
Q
Q
OR
IN
OTHER
WORDS
IF
Q
SINCE
THE
SITUATION
IS
SYMMETRIC
FROM
YOUR
PARTNER
POINT
OF
VIEW
WE
ALSO
GET
P
THUS
IN
ADDITION
TO
THE
TWO
PURE
EQUILIBRIA
WE
ALSO
GET
AN
EQUILIBRIUM
IN
WHICH
EACH
OF
YOU
CHOOSES
POWERPOINT
WITH
PROBABILITY
NOTE
THAT
UNLIKE
THE
TWO
PURE
EQUILIBRIA
THIS
MIXED
EQUILIBRIUM
COMES
WITH
A
POSITIVE
PROBABILITY
THAT
THE
TWO
OF
YOU
WILL
MISCOORDINATE
BUT
THIS
IS
STILL
AN
EQUILIBRIUM
SINCE
IF
YOU
TRULY
BELIEVE
THAT
YOUR
PARTNER
IS
CHOOSING
POWERPOINT
WITH
PROBABILITY
AND
KEYNOTE
WITH
PROBABILITY
THEN
YOU
LL
BE
INDIFFERENT
BETWEEN
THE
TWO
OPTIONS
AND
WILL
GET
THE
SAME
EXPECTED
PAYOFF
HOWEVER
YOU
CHOOSE
PARETO
OPTIMALITY
AND
SOCIAL
OPTIMALITY
IN
A
NASH
EQUILIBRIUM
EACH
PLAYER
STRATEGY
IS
A
BEST
RESPONSE
TO
THE
OTHER
PLAYER
STRATEGIES
IN
OTHER
WORDS
THE
PLAYERS
ARE
OPTIMIZING
INDIVIDUALLY
BUT
THIS
DOESN
T
MEAN
THAT
AS
A
GROUP
THE
PLAYERS
WILL
NECESSARILY
REACH
AN
OUTCOME
THAT
IS
IN
ANY
SENSE
GOOD
THE
EXAM
OR
PRESENTATION
GAME
FROM
THE
OPENING
SECTION
AND
RELATED
GAMES
LIKE
THE
PRISONER
DILEMMA
SERVE
AS
EXAMPLES
OF
THIS
WE
REDRAW
THE
PAYOFF
MATRIX
FOR
THE
BASIC
EXAM
OR
PRESENTATION
GAME
IN
FIGURE
YOU
PRESENTATION
EXAM
YOUR
PARTNER
PRESENTATION
EXAM
86
FIGURE
EXAM
OR
PRESENTATION
IT
IS
INTERESTING
TO
CLASSIFY
OUTCOMES
IN
A
GAME
NOT
JUST
BY
THEIR
STRATEGIC
OR
EQUILIBRIUM
PROPERTIES
BUT
ALSO
BY
WHETHER
THEY
ARE
GOOD
FOR
SOCIETY
IN
ORDER
TO
REASON
ABOUT
THIS
LATTER
ISSUE
WE
FIRST
NEED
A
WAY
OF
MAKING
IT
PRECISE
THERE
ARE
TWO
USEFUL
CANDIDATES
FOR
SUCH
A
DEFINITION
AS
WE
NOW
DISCUSS
PARETO
OPTIMALITY
THE
FIRST
DEFINITION
IS
PARETO
OPTIMALITY
NAMED
AFTER
THE
ITALIAN
ECONOMIST
VILFREDO
PARETO
WHO
WORKED
IN
THE
LATE
AND
EARLY
A
CHOICE
OF
STRATEGIES
ONE
BY
EACH
PLAYER
IS
PARETO
OPTIMAL
IF
THERE
IS
NO
OTHER
CHOICE
OF
STRATEGIES
IN
WHICH
ALL
PLAYERS
RECEIVE
PAYOFFS
AT
LEAST
AS
HIGH
AND
AT
LEAST
ONE
PLAYER
RECEIVES
A
STRICTLY
HIGHER
PAYOFF
TO
SEE
THE
INTUITIVE
APPEAL
OF
PARETO
OPTIMALITY
LET
CONSIDER
A
CHOICE
OF
STRATEGIES
THAT
IS
NOT
PARETO
OPTIMAL
IN
THIS
CASE
THERE
AN
ALTERNATE
CHOICE
OF
STRATEGIES
THAT
MAKES
AT
LEAST
ONE
PLAYER
BETTER
OFF
WITHOUT
HARMING
ANY
PLAYER
IN
BASICALLY
ANY
REASONABLE
SENSE
THIS
ALTERNATE
CHOICE
IS
SUPERIOR
TO
WHAT
CURRENTLY
BEING
PLAYED
IF
THE
PLAYERS
COULD
JOINTLY
AGREE
ON
WHAT
TO
DO
AND
MAKE
THIS
AGREEMENT
BINDING
THEN
SURELY
THEY
WOULD
PREFER
TO
MOVE
TO
THIS
SUPERIOR
CHOICE
OF
STRATEGIES
PARETO
OPTIMALITY
AND
SOCIAL
OPTIMALITY
THE
MOTIVATION
HERE
RELIES
CRUCIALLY
ON
THE
IDEA
THAT
THE
PLAYERS
CAN
CONSTRUCT
A
BINDING
AGREEMENT
TO
ACTUALLY
PLAY
THE
SUPERIOR
CHOICE
OF
STRATEGIES
IF
THIS
ALTERNATE
CHOICE
IS
NOT
A
NASH
EQUILIBRIUM
THEN
ABSENT
A
BINDING
AGREEMENT
AT
LEAST
ONE
PLAYER
WOULD
WANT
TO
SWITCH
TO
A
DIFFERENT
STRATEGY
AS
AN
ILLUSTRATION
OF
WHY
THIS
IS
A
CRUCIAL
POINT
CONSIDER
THE
OUTCOMES
IN
THE
EXAM
OR
PRESENTATION
GAME
THE
OUTCOME
IN
WHICH
YOU
AND
YOUR
PARTNER
BOTH
STUDY
FOR
THE
EXAM
IS
NOT
PARETO
OPTIMAL
SINCE
THE
OUTCOME
IN
WHICH
YOU
BOTH
PREPARE
FOR
THE
PRESENTATION
IS
STRICTLY
BETTER
FOR
BOTH
OF
YOU
THIS
IS
THE
CENTRAL
DIFFICULTY
AT
THE
HEART
OF
THIS
EXAMPLE
NOW
PHRASED
IN
TERMS
OF
PARETO
OPTIMALITY
IT
SHOWS
THAT
EVEN
THOUGH
YOU
AND
YOUR
PARTNER
REALIZE
THERE
IS
A
SUPERIOR
SOLUTION
THERE
IS
NO
WAY
TO
MAINTAIN
IT
WITHOUT
A
BINDING
AGREEMENT
BETWEEN
THE
TWO
OF
YOU
IN
THIS
EXAMPLE
THE
TWO
OUTCOMES
IN
WHICH
EXACTLY
ONE
OF
YOU
PREPARES
FOR
THE
PRE
SENTATION
ARE
ALSO
PARETO
OPTIMAL
IN
THIS
CASE
ALTHOUGH
ONE
OF
YOU
IS
DOING
BADLY
THERE
IS
NO
ALTERNATE
CHOICE
OF
STRATEGIES
IN
WHICH
EVERYONE
IS
DOING
AT
LEAST
AS
WELL
SO
IN
FACT
THE
EXAM
OR
PRESENTATION
GAME
AND
THE
PRISONER
DILEMMA
ARE
EXAMPLES
OF
GAMES
IN
WHICH
THE
ONLY
OUTCOME
THAT
IS
NOT
PARETO
OPTIMAL
IS
THE
ONE
CORRESPONDING
TO
THE
UNIQUE
NASH
EQUILIBRIUM
SOCIAL
OPTIMALITY
A
STRONGER
CONDITION
THAT
IS
EVEN
SIMPLER
TO
STATE
IS
SOCIAL
OPTIMALITY
A
CHOICE
OF
STRATEGIES
ONE
BY
EACH
PLAYER
IS
A
SOCIAL
WELFARE
MAXIMIZER
OR
SOCIALLY
OPTIMAL
IF
IT
MAXIMIZES
THE
SUM
OF
THE
PLAYERS
PAYOFFS
IN
THE
EXAM
OR
PRESENTATION
GAME
THE
SOCIAL
OPTIMUM
IS
ACHIEVED
BY
THE
OUTCOME
IN
WHICH
BOTH
YOU
AND
YOUR
PARTNER
PREPARE
FOR
THE
PRESENTATION
WHICH
PRODUCES
A
COMBINED
PAYOFF
OF
OF
COURSE
THIS
DEFINITION
IS
ONLY
APPROPRIATE
TO
THE
EXTENT
THAT
IT
MAKES
SENSE
TO
ADD
THE
PAYOFFS
OF
DIFFERENT
PLAYERS
TOGETHER
IT
NOT
ALWAYS
CLEAR
THAT
WE
CAN
MEANINGFULLY
COMBINE
MY
SATISFACTION
WITH
AN
OUTCOME
AND
YOUR
SATISFACTION
BY
SIMPLY
ADDING
THEM
UP
OUTCOMES
THAT
ARE
SOCIALLY
OPTIMAL
MUST
ALSO
BE
PARETO
OPTIMAL
IF
SUCH
AN
OUTCOME
WEREN
T
PARETO
OPTIMAL
THERE
WOULD
BE
A
DIFFERENT
OUTCOME
IN
WHICH
ALL
PAYOFFS
WERE
AT
LEAST
AS
LARGE
AND
ONE
WAS
LARGER
AND
THIS
WOULD
BE
AN
OUTCOME
WITH
A
LARGER
SUM
OF
PAYOFFS
ON
THE
OTHER
HAND
A
PARETO
OPTIMAL
OUTCOME
NEED
NOT
BE
SOCIALLY
OPTIMAL
FOR
EXAMPLE
THE
EXAM
OR
PRESENTATION
GAME
HAS
THREE
OUTCOMES
THAT
ARE
PARETO
OPTIMAL
BUT
ONLY
ONE
OF
THESE
IS
THE
SOCIAL
OPTIMUM
FINALLY
OF
COURSE
IT
NOT
THE
CASE
THAT
NASH
EQUILIBRIA
ARE
AT
ODDS
WITH
THE
GOAL
OF
SOCIAL
OPTIMALITY
IN
EVERY
GAME
FOR
EXAMPLE
IN
THE
VERSION
OF
THE
EXAM
OR
PRESENTATION
GAME
WITH
AN
EASIER
EXAM
YIELDING
THE
PAYOFF
MATRIX
THAT
WE
SAW
EARLIER
IN
FIGURE
THE
UNIQUE
NASH
EQUILIBRIUM
IS
ALSO
THE
UNIQUE
SOCIAL
OPTIMUM
ADVANCED
MATERIAL
DOMINATED
STRATEGIES
AND
DYNAMIC
GAMES
IN
THIS
FINAL
SECTION
WE
CONSIDER
TWO
FURTHER
ISSUES
THAT
ARISE
IN
THE
ANALYSIS
OF
GAMES
FIRST
WE
STUDY
THE
ROLE
OF
DOMINATED
STRATEGIES
IN
REASONING
ABOUT
BEHAVIOR
IN
A
GAME
AND
FIND
THAT
THE
ANALYSIS
OF
DOMINATED
STRATEGIES
CAN
PROVIDE
A
WAY
TO
MAKE
PREDICTIONS
ABOUT
PLAY
BASED
ON
RATIONALITY
EVEN
WHEN
NO
PLAYER
HAS
A
DOMINANT
STRATEGY
SECOND
WE
DISCUSS
HOW
TO
REINTERPRET
THE
STRATEGIES
AND
PAYOFFS
IN
A
GAME
TO
DEAL
WITH
SITUATIONS
IN
WHICH
PLAY
ACTUALLY
OCCURS
SEQUENTIALLY
THROUGH
TIME
BEFORE
DOING
THIS
HOWEVER
WE
BEGIN
WITH
A
FORMAL
DEFINITION
FOR
GAMES
THAT
HAVE
MORE
THAN
TWO
PLAYERS
A
MULTI
PLAYER
GAMES
A
MULTI
PLAYER
GAME
CONSISTS
AS
IN
THE
TWO
PLAYER
CASE
OF
A
SET
OF
PLAYERS
A
SET
OF
STRATEGIES
FOR
EACH
PLAYER
AND
A
PAYOFF
TO
EACH
PLAYER
FOR
EACH
POSSIBLE
OUTCOME
SPECIFICALLY
SUPPOSE
THAT
A
GAME
HAS
N
PLAYERS
NAMED
N
EACH
PLAYER
HAS
A
SET
OF
POSSIBLE
STRATEGIES
AN
OUTCOME
OR
JOINT
STRATEGY
OF
THE
GAME
IS
A
CHOICE
OF
A
STRATEGY
FOR
EACH
PLAYER
FINALLY
EACH
PLAYER
I
HAS
A
PAYOFF
FUNCTION
PI
THAT
MAPS
OUTCOMES
OF
THE
GAME
TO
A
NUMERICAL
PAYOFF
FOR
I
THAT
IS
FOR
EACH
OUTCOME
CONSISTING
OF
STRATEGIES
SN
THERE
IS
A
PAYOFF
PI
SN
TO
PLAYER
I
NOW
WE
CAN
SAY
THAT
A
STRATEGY
SI
IS
A
BEST
RESPONSE
BY
PLAYER
I
TO
A
CHOICE
OF
STRATEGIES
SI
SI
SN
BY
ALL
THE
OTHER
PLAYERS
IF
PI
SI
SI
SI
SN
PI
SI
SIT
SI
SN
FOR
ALL
OTHER
POSSIBLE
STRATEGIES
SIT
AVAILABLE
TO
PLAYER
I
FINALLY
AN
OUTCOME
CONSISTING
OF
STRATEGIES
SN
IS
A
NASH
EQUILIBRIUM
IF
EACH
STRATEGY
IT
CONTAINS
IS
A
BEST
RESPONSE
TO
ALL
THE
OTHERS
B
DOMINATED
STRATEGIES
AND
THEIR
ROLE
IN
STRATEGIC
REASONING
IN
SECTIONS
AND
WE
DISCUSSED
STRICTLY
DOMINANT
STRATEGIES
STRATEGIES
THAT
ARE
A
STRICT
BEST
RESPONSE
TO
EVERY
POSSIBLE
CHOICE
OF
STRATEGIES
BY
THE
OTHER
PLAYERS
CLEARLY
IF
A
PLAYER
HAS
A
STRICTLY
DOMINANT
STRATEGY
THEN
THIS
IS
THE
STRATEGY
SHE
SHOULD
EMPLOY
BUT
WE
ALSO
SAW
THAT
EVEN
FOR
TWO
PLAYER
TWO
STRATEGY
GAMES
IT
IS
COMMON
TO
HAVE
NO
DOMINANT
STRATEGIES
THIS
HOLDS
EVEN
MORE
STRONGLY
FOR
LARGER
GAMES
ALTHOUGH
DOMINANT
AND
STRICTLY
DOMINANT
STRATEGIES
CAN
EXIST
IN
GAMES
WITH
MANY
PLAYERS
AND
MANY
STRATEGIES
THEY
ARE
RARE
FIGURE
IN
THE
FACILITY
LOCATION
GAME
EACH
PLAYER
HAS
STRICTLY
DOMINATED
STRATEGIES
BUT
NO
DOMINANT
STRATEGY
HOWEVER
EVEN
IF
A
PLAYER
DOES
NOT
HAVE
A
DOMINANT
STRATEGY
SHE
MAY
STILL
HAVE
STRATEGIES
THAT
ARE
DOMINATED
BY
OTHER
STRATEGIES
IN
THIS
SECTION
WE
CONSIDER
THE
ROLE
THAT
SUCH
DOMINATED
STRATEGIES
PLAY
IN
REASONING
ABOUT
BEHAVIOR
IN
GAMES
WE
BEGIN
WITH
A
FORMAL
DEFINITION
A
STRATEGY
IS
STRICTLY
DOMINATED
IF
THERE
IS
SOME
OTHER
STRATEGY
AVAILABLE
TO
THE
SAME
PLAYER
THAT
PRODUCES
A
STRICTLY
HIGHER
PAYOFF
IN
RESPONSE
TO
EVERY
CHOICE
OF
STRATEGIES
BY
THE
OTHER
PLAYERS
IN
THE
NOTATION
WE
VE
JUST
DEVELOPED
STRATEGY
SI
FOR
PLAYER
I
IS
STRICTLY
DOMINATED
IF
THERE
IS
ANOTHER
STRATEGY
SIT
FOR
PLAYER
I
SUCH
THAT
PI
SI
SIT
SI
SN
PI
SI
SI
SI
SN
FOR
ALL
CHOICES
OF
STRATEGIES
SI
SI
SN
BY
THE
OTHER
PLAYERS
NOW
IN
THE
TWO
PLAYER
TWO
STRATEGY
GAMES
WE
VE
BEEN
CONSIDERING
THUS
FAR
A
STRATEGY
IS
STRICTLY
DOMINATED
PRECISELY
WHEN
THE
OTHER
STRATEGY
AVAILABLE
TO
THE
SAME
PLAYER
IS
STRICTLY
DOMINANT
IN
THIS
CONTEXT
IT
WOULDN
T
MAKE
SENSE
TO
STUDY
STRICTLY
DOMINATED
STRATEGIES
AS
A
SEPARATE
CONCEPT
ON
THEIR
OWN
HOWEVER
IF
A
PLAYER
HAS
MANY
STRATEGIES
THEN
IT
POSSIBLE
FOR
A
STRATEGY
TO
BE
STRICTLY
DOMINATED
WITHOUT
ANY
STRATEGY
BEING
DOMINANT
IN
SUCH
CASES
WE
WILL
FIND
THAT
STRICTLY
DOMINATED
STRATEGIES
CAN
PLAY
A
VERY
USEFUL
ROLE
IN
REASONING
ABOUT
PLAY
IN
A
GAME
IN
PARTICULAR
WE
WILL
SEE
THAT
THERE
ARE
CASES
IN
WHICH
THERE
ARE
NO
DOMINANT
STRATEGIES
BUT
WHERE
THE
OUTCOME
OF
THE
GAME
CAN
STILL
BE
UNIQUELY
PREDICTED
USING
THE
STRUCTURE
OF
THE
DOMINATED
STRATEGIES
IN
THIS
WAY
REASONING
BASED
ON
DOMINATED
STRATEGIES
FORMS
AN
INTRIGUING
INTERMEDIATE
APPROACH
BETWEEN
DOMINANT
STRATEGIES
AND
NASH
EQUILIBRIUM
ON
THE
ONE
HAND
IT
CAN
BE
MORE
POWERFUL
THAN
REASONING
BASED
SOLELY
ON
DOMINANT
STRATEGIES
BUT
ON
THE
OTHER
HAND
IT
STILL
RELIES
ONLY
ON
THE
PREMISE
THAT
PLAYERS
SEEK
TO
MAXIMIZE
PAYOFFS
AND
DOESN
T
REQUIRE
THE
INTRODUCTION
OF
AN
EQUILIBRIUM
NOTION
TO
SEE
HOW
THIS
WORKS
IT
USEFUL
TO
INTRODUCE
THE
APPROACH
IN
THE
CONTEXT
OF
A
BASIC
EXAMPLE
EXAMPLE
THE
FACILITY
LOCATION
GAME
OUR
EXAMPLE
IS
A
GAME
IN
WHICH
TWO
FIRMS
COMPETE
THROUGH
THEIR
CHOICE
OF
LOCATIONS
SUPPOSE
THAT
TWO
FIRMS
ARE
EACH
PLANNING
TO
OPEN
A
STORE
IN
ONE
OF
SIX
TOWNS
LOCATED
ALONG
SIX
CONSECUTIVE
EXITS
ON
A
HIGHWAY
WE
CAN
REPRESENT
THE
ARRANGEMENT
OF
THESE
TOWNS
USING
A
SIX
NODE
GRAPH
AS
IN
FIGURE
NOW
BASED
ON
LEASING
AGREEMENTS
FIRM
HAS
THE
OPTION
OF
OPENING
ITS
STORE
IN
ANY
OF
TOWNS
A
C
OR
E
WHILE
FIRM
HAS
THE
OPTION
OF
OPENING
ITS
STORE
IN
ANY
OF
TOWNS
B
D
OR
F
THESE
DECISIONS
WILL
BE
EXECUTED
SIMULTANEOUSLY
ONCE
THE
TWO
STORES
ARE
OPENED
CUSTOMERS
FROM
THE
TOWNS
WILL
GO
TO
THE
STORE
THAT
IS
CLOSER
TO
THEM
SO
FOR
EXAMPLE
IF
FIRM
OPEN
ITS
STORE
IN
TOWN
C
AND
FIRM
OPENS
ITS
STORE
IN
TOWN
B
THEN
THE
STORE
IN
TOWN
B
WILL
ATTRACT
CUSTOMERS
FROM
A
AND
B
WHILE
THE
STORE
IN
TOWN
C
WILL
ATTRACT
CUSTOMERS
FROM
C
D
E
AND
F
IF
WE
ASSUME
THAT
THE
TOWNS
CONTAIN
AN
EQUAL
NUMBER
OF
CUSTOMERS
AND
THAT
PAYOFFS
ARE
DIRECTLY
PROPORTIONAL
TO
THE
NUMBER
OF
CUSTOMERS
THIS
WOULD
RESULT
IN
A
PAYOFF
OF
FOR
FIRM
AND
FOR
FIRM
SINCE
FIRM
CLAIMS
CUSTOMERS
FROM
TOWNS
WHILE
FIRM
CLAIMS
CUSTOMERS
FROM
THE
REMAINING
TOWNS
REASONING
IN
THIS
WAY
ABOUT
THE
NUMBER
OF
TOWNS
CLAIMED
BY
EACH
STORE
BASED
ON
PROXIMITY
TO
THEIR
LOCATIONS
WE
GET
THE
PAYOFF
MATRIX
SHOWN
IN
FIGURE
A
FIRM
C
E
FIRM
B
D
F
FIGURE
FACILITY
LOCATION
GAME
WE
REFER
TO
THIS
AS
A
FACILITY
LOCATION
GAME
THE
COMPETITIVE
LOCATION
OF
FACILITIES
IS
A
TOPIC
THAT
HAS
BEEN
THE
SUBJECT
OF
CONSIDERABLE
STUDY
IN
OPERATIONS
RESEARCH
AND
OTHER
AREAS
MOREOVER
CLOSELY
RELATED
MODELS
HAVE
BEEN
USED
WHEN
THE
ENTITIES
BEING
LOCATED
ARE
NOT
STORES
ALONG
A
ONE
DIMENSIONAL
HIGHWAY
BUT
THE
POSITIONS
OF
POLITICAL
CANDIDATES
ALONG
A
ONE
DIMENSIONAL
IDEOLOGICAL
SPECTRUM
HERE
TOO
CHOOSING
A
CERTAIN
POSITION
RELATIVE
TO
ONE
ELECTORAL
OPPONENT
CAN
ATTRACT
CERTAIN
VOTERS
WHILE
ALIENATING
OTHERS
WE
WILL
RETURN
TO
ISSUES
RELATED
TO
POLITICAL
COMPETITION
THOUGH
IN
A
SLIGHTLY
DIFFERENT
DIRECTION
IN
CHAPTER
WE
CAN
VERIFY
THAT
NEITHER
PLAYER
HAS
A
DOMINANT
STRATEGY
IN
THIS
GAME
FOR
EXAMPLE
IF
FIRM
LOCATES
AT
NODE
A
THEN
THE
STRICT
BEST
RESPONSE
OF
FIRM
IS
B
WHILE
IF
FIRM
LOCATES
AT
NODE
E
THEN
THE
STRICT
BEST
RESPONSE
OF
FIRM
IS
D
THE
SITUATION
IS
SYMMETRIC
IF
WE
INTERCHANGE
THE
ROLES
OF
THE
TWO
FIRMS
AND
READ
THE
GRAPH
FROM
THE
OTHER
DIRECTION
DOMINATED
STRATEGIES
IN
THE
FACILITY
LOCATION
GAME
WE
CAN
MAKE
PROGRESS
IN
REASONING
ABOUT
THE
BEHAVIOR
OF
THE
TWO
PLAYERS
IN
THE
FACILITY
LOCATION
GAME
BY
THINKING
ABOUT
THEIR
DOMINATED
STRATEGIES
FIRST
NOTICE
THAT
A
IS
A
STRICTLY
DOMINATED
STRATEGY
FOR
FIRM
IN
ANY
SITUATION
WHERE
FIRM
HAS
THE
OPTION
OF
CHOOSING
A
IT
WOULD
RECEIVE
A
STRICTLY
HIGHER
PAYOFF
BY
CHOOSING
C
SIMILARLY
F
IS
A
STRICTLY
DOMINATED
STRATEGY
FOR
FIRM
IN
ANY
SITUATION
WHERE
FIRM
HAS
THE
OPTION
OF
CHOOSING
F
IT
WOULD
RECEIVE
A
STRICTLY
HIGHER
PAYOFF
BY
CHOOSING
D
IT
IS
NEVER
IN
A
PLAYER
INTEREST
TO
USE
A
STRICTLY
DOMINATED
STRATEGY
SINCE
IT
SHOULD
ALWAYS
BE
REPLACED
BY
A
STRATEGY
THAT
DOES
BETTER
SO
FIRM
ISN
T
GOING
TO
USE
STRATEGY
A
MOREOVER
SINCE
FIRM
KNOWS
THE
STRUCTURE
OF
THE
GAME
INCLUDING
FIRM
PAYOFFS
FIRM
KNOWS
THAT
FIRM
WON
T
USE
STRATEGY
A
IT
CAN
BE
EFFECTIVELY
ELIMINATED
FROM
THE
GAME
THE
SAME
REASONING
SHOWS
THAT
F
CAN
BE
ELIMINATED
FROM
THE
GAME
WE
NOW
HAVE
A
SMALLER
INSTANCE
OF
THE
FACILITY
LOCATION
GAME
INVOLVING
ONLY
THE
FOUR
NODES
B
C
D
AND
E
AND
THE
PAYOFF
MATRIX
SHOWN
IN
FIGURE
FIRM
C
E
FIRM
B
D
FIGURE
SMALLER
FACILITY
LOCATION
GAME
NOW
SOMETHING
INTERESTING
HAPPENS
THE
STRATEGIES
B
AND
E
WEREN
T
PREVIOUSLY
STRICTLY
DOMINATED
THEY
WERE
USEFUL
IN
CASE
THE
OTHER
PLAYER
USED
A
OR
F
RESPECTIVELY
BUT
WITH
A
AND
F
ELIMINATED
THE
STRATEGIES
B
AND
E
NOW
ARE
STRICTLY
DOMINATED
SO
BY
THE
SAME
REASONING
BOTH
PLAYERS
KNOW
THEY
WON
T
BE
USED
AND
SO
WE
CAN
ELIMINATE
THEM
FROM
THE
GAME
THIS
GIVES
US
THE
EVEN
SMALLER
GAME
SHOWN
IN
FIGURE
FIRM
C
FIRM
D
FIGURE
EVEN
SMALLER
FACILITY
LOCATION
GAME
AT
THIS
POINT
THERE
IS
A
VERY
CLEAR
PREDICTION
FOR
THE
PLAY
OF
THE
GAME
FIRM
WILL
PLAY
C
AND
FIRM
WILL
PLAY
D
AND
THE
REASONING
THAT
LED
TO
THIS
IS
CLEAR
AFTER
REPEATEDLY
REMOVING
STRATEGIES
THAT
WERE
OR
BECAME
STRICTLY
DOMINATED
WE
WERE
LEFT
WITH
ONLY
A
SINGLE
PLAUSIBLE
OPTION
FOR
EACH
PLAYER
THE
PROCESS
THAT
LED
US
TO
THIS
REDUCED
GAME
IS
CALLED
THE
ITERATIVE
DELETION
OF
STRICTLY
DOMINATED
STRATEGIES
AND
WE
WILL
SHORTLY
DESCRIBE
IT
IN
ITS
FULL
GENERALITY
BEFORE
DOING
THIS
HOWEVER
IT
WORTH
MAKING
SOME
OBSERVATIONS
ABOUT
THE
EXAMPLE
OF
THE
FACILITY
LOCATION
GAME
FIRST
THE
PAIR
OF
STRATEGIES
C
D
IS
INDEED
THE
UNIQUE
NASH
EQUILIBRIUM
IN
THE
GAME
AND
WHEN
WE
DISCUSS
THE
ITERATED
DELETION
OF
STRICTLY
DOMINATED
STRATEGIES
IN
GENERAL
WE
WILL
SEE
THAT
IT
IS
AN
EFFECTIVE
WAY
TO
SEARCH
FOR
NASH
EQUILIBRIA
BUT
BEYOND
THIS
IT
IS
ALSO
AN
EFFECTIVE
WAY
TO
JUSTIFY
THE
NASH
EQUILIBRIA
THAT
ONE
FINDS
WHEN
WE
FIRST
INTRODUCED
NASH
EQUILIBRIUM
WE
OBSERVED
THAT
IT
COULDN
T
BE
DERIVED
PURELY
FROM
AN
ASSUMPTION
OF
RATIONALITY
ON
THE
PART
OF
THE
PLAYERS
RATHER
WE
HAD
TO
ASSUME
FURTHER
THAT
PLAY
OF
THE
GAME
WOULD
BE
FOUND
AT
AN
EQUILIBRIUM
FROM
WHICH
NEITHER
PLAYER
HAD
AN
INCENTIVE
TO
DEVIATE
ON
THE
OTHER
HAND
WHEN
A
UNIQUE
NASH
EQUILIBRIUM
EMERGES
FROM
THE
ITERATED
DELETION
OF
STRICTLY
DOMINATED
STRATEGIES
IT
IS
IN
FACT
A
PREDICTION
MADE
PURELY
BASED
ON
THE
ASSUMPTIONS
OF
THE
PLAYERS
RATIONALITY
AND
THEIR
KNOWLEDGE
OF
THE
GAME
SINCE
ALL
THE
STEPS
THAT
LED
TO
IT
WERE
BASED
SIMPLY
ON
REMOVING
STRATEGIES
THAT
WERE
STRICTLY
INFERIOR
TO
OTHERS
FROM
THE
PERSPECTIVE
OF
PAYOFF
MAXIMIZATION
A
FINAL
OBSERVATION
IS
THAT
ITERATED
DELETION
CAN
IN
PRINCIPLE
BE
CARRIED
OUT
FOR
A
VERY
LARGE
NUMBER
OF
STEPS
AND
THE
FACILITY
LOCATION
GAME
ILLUSTRATES
THIS
SUPPOSE
THAT
INSTEAD
OF
A
PATH
OF
LENGTH
SIX
WE
HAD
A
PATH
OF
LENGTH
WITH
THE
OPTIONS
FOR
THE
TWO
FIRMS
STILL
STRICTLY
ALTERNATING
ALONG
THIS
PATH
CONSTITUTING
POSSIBLE
STRATEGIES
FOR
EACH
PLAYER
THEN
IT
WOULD
BE
STILL
BE
THE
CASE
THAT
ONLY
THE
OUTER
TWO
NODES
WOULD
BE
STRICTLY
DOMINATED
AFTER
THEIR
REMOVAL
WE
D
HAVE
A
PATH
OF
LENGTH
IN
WHICH
THE
TWO
NEW
OUTER
NODES
HAD
NOW
BECOME
STRICTLY
DOMINATED
WE
CAN
CONTINUE
REMOVING
NODES
IN
THIS
WAY
AND
AFTER
STEPS
OF
SUCH
REASONING
WE
LL
HAVE
A
GAME
IN
WHICH
ONLY
THE
AND
NODES
HAVE
SURVIVED
AS
STRATEGIES
THIS
IS
THE
UNIQUE
NASH
EQUILIBRIUM
FOR
THE
GAME
AND
THIS
UNIQUE
PREDICTION
CAN
BE
JUSTIFIED
BY
A
VERY
LONG
SEQUENCE
OF
DELETIONS
OF
DOMINATED
STRATEGIES
IT
ALSO
INTERESTING
HOW
THIS
PREDICTION
IS
INTUITIVELY
NATURAL
AND
ONE
THAT
IS
OFTEN
SEEN
IN
REAL
LIFE
TWO
COMPETING
STORES
STAKING
OUT
POSITIONS
NEXT
TO
EACH
OTHER
NEAR
THE
CENTER
OF
THE
POPULATION
OR
TWO
POLITICAL
CANDIDATES
GRAVITATING
TOWARD
THE
IDEOLOGICAL
MIDDLE
GROUND
AS
THEY
COMPETE
FOR
VOTERS
IN
A
GENERAL
ELECTION
IN
EACH
CASE
THIS
MOVE
TOWARD
THE
CENTER
IS
THE
UNIQUE
WAY
TO
MAXIMIZE
THE
TERRITORY
THAT
YOU
CAN
CLAIM
AT
THE
EXPENSE
OF
YOUR
COMPETITOR
ITERATED
DELETION
OF
DOMINATED
STRATEGIES
THE
GENERAL
PRINCIPLE
IN
GENERAL
FOR
A
GAME
WITH
AN
ARBITRARY
NUMBER
OF
PLAYERS
THE
PROCESS
OF
ITERATED
DELETION
OF
STRICTLY
DOMINATED
STRATEGIES
PROCEEDS
AS
FOLLOWS
WE
START
WITH
ANY
N
PLAYER
GAME
FIND
ALL
THE
STRICTLY
DOMINATED
STRATEGIES
AND
DELETE
THEM
WE
THEN
CONSIDER
THE
REDUCED
GAME
IN
WHICH
THESE
STRATEGIES
HAVE
BEEN
REMOVED
IN
THIS
REDUCED
GAME
THERE
MAY
BE
STRATEGIES
THAT
ARE
NOW
STRICTLY
DOMINATED
DESPITE
NOT
HAVING
BEEN
STRICTLY
DOMINATED
IN
THE
FULL
GAME
WE
FIND
THESE
STRATEGIES
AND
DELETE
THEM
WE
CONTINUE
THIS
PROCESS
REPEATEDLY
FINDING
AND
REMOVING
STRICTLY
DOMINATED
STRATEGIES
UNTIL
NONE
CAN
BE
FOUND
AN
IMPORTANT
GENERAL
FACT
IS
THAT
THE
SET
OF
NASH
EQUILIBRIA
OF
THE
ORIGINAL
GAME
COINCIDES
WITH
THE
SET
OF
NASH
EQUILIBRIA
FOR
THE
FINAL
REDUCED
GAME
CONSISTING
ONLY
OF
STRATEGIES
THAT
SURVIVE
ITERATED
DELETION
TO
PROVE
THIS
FACT
IT
IS
ENOUGH
TO
SHOW
THAT
THE
SET
OF
NASH
EQUILIBRIA
DOES
NOT
CHANGE
WHEN
WE
PERFORM
ONE
ROUND
OF
DELETING
STRICTLY
DOMINATED
STRATEGIES
IF
THIS
IS
TRUE
THEN
WE
HAVE
ESTABLISHED
THAT
THE
NASH
EQUILIBRIA
CONTINUE
TO
REMAIN
UNCHANGED
THROUGH
AN
ARBITRARY
FINITE
SEQUENCE
OF
DELETIONS
TO
PROVE
THAT
THE
SET
OF
NASH
EQUILIBRIA
REMAINS
THE
SAME
THROUGH
ONE
ROUND
OF
DELETION
WE
NEED
TO
SHOW
TWO
THINGS
FIRST
ANY
NASH
EQUILIBRIUM
OF
THE
ORIGINAL
GAME
IS
A
NASH
EQUILIBRIUM
OF
THE
REDUCED
GAME
TO
SEE
THIS
NOTE
THAT
OTHERWISE
THERE
WOULD
BE
A
NASH
EQUILIBRIUM
OF
THE
ORIGINAL
GAME
INVOLVING
A
STRATEGY
THAT
WAS
DELETED
BUT
IN
THIS
CASE
IS
STRICTLY
DOMINATED
BY
SOME
OTHER
STRATEGY
ST
HENCE
CANNOT
BE
PART
OF
A
NASH
EQUILIBRIUM
OF
THE
ORIGINAL
GAME
IT
IS
NOT
A
BEST
RESPONSE
TO
THE
STRATEGIES
OF
THE
OTHER
PLAYERS
SINCE
THE
STRATEGY
ST
THAT
DOMINATES
IT
IS
A
BETTER
RESPONSE
THIS
ESTABLISHES
THAT
NO
NASH
EQUILIBRIUM
OF
THE
ORIGINAL
GAME
CAN
BE
REMOVED
BY
THE
DELETION
PROCESS
SECOND
WE
NEED
TO
SHOW
THAT
ANY
NASH
EQUILIBRIUM
OF
THE
REDUCED
GAME
IS
ALSO
A
NASH
EQUILIBRIUM
OF
THE
ORIGINAL
GAME
IN
ORDER
FOR
THIS
NOT
TO
BE
THE
CASE
THERE
WOULD
HAVE
TO
BE
A
NASH
EQUILIBRIUM
E
SN
OF
THE
REDUCED
GAME
AND
A
STRATEGY
SIT
THAT
WAS
DELETED
FROM
THE
ORIGINAL
GAME
SUCH
THAT
PLAYER
I
HAS
AN
INCENTIVE
TO
DEVIATE
FROM
ITS
STRATEGY
SI
IN
E
TO
THE
STRATEGY
SIT
BUT
STRATEGY
SIT
WAS
DELETED
BECAUSE
IT
WAS
STRICTLY
DOMINATED
BY
AT
LEAST
ONE
OTHER
STRATEGY
WE
CAN
THEREFORE
FIND
A
STRATEGY
SITT
THAT
STRICTLY
DOMINATED
IT
AND
WAS
NOT
DELETED
THEN
PLAYER
I
ALSO
HAS
AN
INCENTIVE
TO
DEVIATE
FROM
SI
TO
SITT
AND
SITT
IS
STILL
PRESENT
IN
THE
REDUCED
GAME
CONTRADICTING
OUR
ASSUMPTION
THAT
E
IS
A
NASH
EQUILIBRIUM
OF
THE
REDUCED
GAME
THIS
ESTABLISHES
THAT
THE
GAME
WE
END
UP
WITH
AFTER
ITERATED
DELETION
OF
STRICTLY
DOMI
NATED
STRATEGIES
STILL
HAS
ALL
THE
NASH
EQUILIBRIA
OF
THE
ORIGINAL
GAME
HENCE
THIS
PROCESS
CAN
BE
A
POWERFUL
WAY
TO
RESTRICT
THE
SEARCH
FOR
NASH
EQUILIBRIA
MOREOVER
ALTHOUGH
WE
DESCRIBED
THE
PROCESS
AS
OPERATING
IN
ROUNDS
WITH
ALL
CURRENTLY
STRICTLY
DOMINATED
STRATEGIES
BEING
REMOVED
IN
EACH
ROUND
THIS
IS
NOT
ESSENTIAL
ONE
CAN
SHOW
THAT
ELIMINATING
STRICTLY
DOMINATED
STRATEGIES
IN
ANY
ORDER
WILL
RESULT
IN
THE
SAME
SET
OF
SURVIVING
STRATEGIES
WEAKLY
DOMINATED
STRATEGIES
IT
IS
ALSO
NATURAL
TO
ASK
ABOUT
NOTIONS
THAT
ARE
SLIGHTLY
WEAKER
THAN
OUR
DEFINITION
OF
STRICTLY
DOMINATED
STRATEGIES
ONE
FUNDAMENTAL
DEFINITION
IN
THIS
SPIRIT
IS
THAT
OF
A
WEAKLY
DOMINATED
STRATEGY
WE
SAY
THAT
A
STRATEGY
IS
WEAKLY
DOMINATED
IF
THERE
IS
ANOTHER
STRATEGY
THAT
DOES
AT
LEAST
AS
WELL
NO
MATTER
WHAT
THE
OTHER
PLAYERS
DO
AND
DOES
STRICTLY
BETTER
AGAINST
SOME
JOINT
STRATEGY
OF
THE
OTHER
PLAYERS
IN
OUR
NOTATION
FROM
EARLIER
WE
SAY
THAT
A
STRATEGY
SI
FOR
PLAYER
I
IS
WEAKLY
DOMINATED
IF
THERE
IS
ANOTHER
STRATEGY
SIT
FOR
PLAYER
I
SUCH
THAT
PI
SI
SIT
SI
SN
PI
SI
SI
SI
SN
FOR
ALL
CHOICES
OF
STRATEGIES
SI
SI
SN
BY
THE
OTHER
PLAYERS
AND
PI
SI
SIT
SI
SN
PI
SI
SI
SI
SN
FOR
AT
LEAST
ONE
CHOICE
OF
STRATEGIES
SI
SI
SN
BY
THE
OTHER
PLAYERS
FOR
STRICTLY
DOMINATED
STRATEGIES
THE
ARGUMENT
FOR
DELETING
THEM
WAS
COMPELLING
THEY
ARE
NEVER
BEST
RESPONSES
FOR
WEAKLY
DOMINATED
STRATEGIES
THE
ISSUE
IS
MORE
SUBTLE
SUCH
STRATEGIES
COULD
BE
BEST
RESPONSES
TO
SOME
JOINT
STRATEGY
BY
THE
OTHER
PLAYERS
SO
A
RATIONAL
PLAYER
COULD
PLAY
A
WEAKLY
DOMINATED
STRATEGY
AND
IN
FACT
NASH
EQUILIBRIA
CAN
INVOLVE
WEAKLY
DOMINATED
STRATEGIES
THERE
ARE
SIMPLE
EXAMPLES
THAT
MAKE
THIS
CLEAR
EVEN
IN
TWO
PLAYER
TWO
STRATEGY
GAMES
CONSIDER
FOR
EXAMPLE
A
VERSION
OF
THE
STAG
HUNT
GAME
IN
WHICH
THE
PAYOFF
FROM
SUCCESSFULLY
CATCHING
A
STAG
IS
THE
SAME
AS
THE
PAYOFF
FROM
CATCHING
A
HARE
HUNTER
HUNT
STAG
HUNT
HARE
HUNTER
HUNT
STAG
HUNT
HARE
FIGURE
STAG
HUNT
A
VERSION
WITH
A
WEAKLY
DOMINATED
STRATEGY
IN
THIS
CASE
HUNT
STAG
IS
A
WEAKLY
DOMINATED
STRATEGY
SINCE
EACH
PLAYER
ALWAYS
DOES
AT
LEAST
AS
WELL
AND
SOMETIMES
STRICTLY
BETTER
BY
PLAYING
HUNT
HARE
NEVERTHELESS
THE
OUTCOME
IN
WHICH
BOTH
PLAYERS
CHOOSE
HUNT
STAG
IS
A
NASH
EQUILIBRIUM
SINCE
EACH
IS
PLAYING
A
BEST
RESPONSE
TO
THE
OTHER
STRATEGY
THUS
DELETING
WEAKLY
DOMINATED
STRATEGIES
IS
NOT
IN
GENERAL
A
SAFE
THING
TO
DO
IF
ONE
WANTS
TO
PRESERVE
THE
ESSENTIAL
STRUCTURE
OF
THE
GAME
SUCH
DELETION
OPERATIONS
CAN
DESTROY
NASH
EQUILIBRIA
OF
COURSE
IT
MIGHT
SEEM
REASONABLE
TO
SUPPOSE
THAT
A
PLAYER
SHOULD
NOT
PLAY
AN
EQUILIB
RIUM
INVOLVING
A
WEAKLY
DOMINATED
STRATEGY
SUCH
AS
HUNT
STAG
HUNT
STAG
IF
HE
HAD
ANY
UNCERTAINTY
ABOUT
WHAT
THE
OTHER
PLAYERS
WOULD
DO
AFTER
ALL
WHY
NOT
USE
AN
ALTERNATE
STRATEGY
THAT
IS
AT
LEAST
AS
GOOD
IN
EVERY
EVENTUALITY
BUT
NASH
EQUILIBRIUM
DOES
NOT
TAKE
INTO
ACCOUNT
THIS
IDEA
OF
UNCERTAINTY
ABOUT
THE
BEHAVIOR
OF
OTHERS
AND
HENCE
HAS
NO
WAY
TO
RULE
OUT
SUCH
OUTCOMES
IN
THE
NEXT
CHAPTER
WE
WILL
DISCUSS
AN
ALTERNATE
EQUILIBRIUM
CONCEPT
KNOWN
AS
EVOLUTIONARY
STABILITY
THAT
IN
FACT
DOES
ELIMINATE
WEAKLY
DOMINATED
STRATEGIES
IN
A
PRINCIPLED
WAY
THE
RELATIONSHIP
BETWEEN
NASH
EQUILIBRIUM
EVOLUTIONARY
STABILITY
AND
WEAKLY
DOMINATED
STRATEGIES
IS
CONSIDERED
IN
THE
EXERCISES
AT
THE
END
OF
CHAPTER
C
DYNAMIC
GAMES
OUR
FOCUS
IN
THIS
CHAPTER
HAS
BEEN
ON
GAMES
IN
WHICH
ALL
PLAYERS
CHOOSE
THEIR
STRATEGIES
SIMULTANEOUSLY
AND
THEN
RECEIVE
PAYOFFS
BASED
ON
THIS
JOINT
DECISION
OF
COURSE
ACTUAL
SIMULTANEITY
IS
NOT
CRUCIAL
FOR
THE
MODEL
BUT
IT
HAS
BEEN
CENTRAL
TO
OUR
DISCUSSIONS
SO
FAR
THAT
EACH
PLAYER
IS
CHOOSING
A
STRATEGY
WITHOUT
KNOWLEDGE
OF
THE
ACTUAL
CHOICES
MADE
BY
THE
OTHER
PLAYERS
MANY
GAMES
HOWEVER
ARE
PLAYED
OVER
TIME
SOME
PLAYER
OR
SET
OF
PLAYERS
MOVES
FIRST
OTHER
PLAYERS
OBSERVE
THE
CHOICE
MADE
AND
THEN
THEY
RESPOND
PERHAPS
ACCORDING
TO
A
PLAYER
A
B
PLAYER
A
B
A
B
FIGURE
A
SIMPLE
GAME
IN
EXTENSIVE
FORM
PREDETERMINED
ORDER
OF
GOVERNING
WHO
MOVES
WHEN
SUCH
GAMES
ARE
CALLED
DYNAMIC
GAMES
AND
THERE
ARE
MANY
BASIC
EXAMPLES
BOARD
GAMES
AND
CARD
GAMES
IN
WHICH
PLAYERS
ALTERNATE
TURNS
NEGOTIATIONS
WHICH
USUALLY
INVOLVE
A
SEQUENCE
OF
OFFERS
AND
COUNTER
OFFERS
AND
BIDDING
IN
AN
AUCTION
OR
PRICING
COMPETING
GOODS
WHERE
PARTICIPANTS
MUST
MAKE
DECISIONS
OVER
TIME
HERE
WE
LL
DISCUSS
AN
ADAPTATION
OF
THE
THEORY
OF
GAMES
THAT
INCORPORATES
THIS
DYNAMIC
ASPECT
NORMAL
AND
EXTENSIVE
FORMS
OF
A
GAME
TO
BEGIN
WITH
SPECIFYING
A
DYNAMIC
GAME
IS
GOING
TO
REQUIRE
A
NEW
KIND
OF
NOTATION
THUS
FAR
WE
VE
WORKED
WITH
SOMETHING
CALLED
THE
NORMAL
FORM
REPRESENTATION
OF
A
GAME
THIS
SPECIFIES
THE
LIST
OF
PLAYERS
THEIR
POSSIBLE
STRATEGIES
AND
THE
PAYOFFS
ARISING
FROM
EVERY
POSSIBLE
SIMULTANEOUS
CHOICE
OF
STRATEGIES
BY
THE
PLAYERS
FOR
TWO
PLAYER
GAMES
THE
PAYOFF
MATRICES
WE
VE
SEEN
IN
THIS
CHAPTER
ENCODE
THE
NORMAL
FORM
REPRESENTATION
OF
A
GAME
IN
A
COMPACT
WAY
TO
DESCRIBE
A
DYNAMIC
GAME
WE
RE
GOING
TO
NEED
A
RICHER
REPRESENTATION
WE
NEED
TO
BE
ABLE
TO
SPECIFY
WHO
MOVES
WHEN
WHAT
EACH
PLAYER
KNOWS
AT
ANY
OPPORTUNITY
THEY
HAVE
TO
MOVE
WHAT
THEY
CAN
DO
WHEN
IT
IS
THEIR
TURN
TO
MOVE
AND
WHAT
THE
PAYOFFS
ARE
AT
THE
END
OF
THE
GAME
WE
REFER
TO
THIS
SPECIFICATION
AS
THE
EXTENSIVE
FORM
REPRESENTATION
OF
THE
GAME
LET
START
WITH
A
VERY
SIMPLE
EXAMPLE
OF
A
DYNAMIC
GAME
SO
THAT
WE
CAN
DISCUSS
WHAT
ITS
EXTENSIVE
FORM
REPRESENTATION
LOOKS
LIKE
AS
WE
LL
SEE
THIS
GAME
IS
SIMPLE
ENOUGH
THAT
IT
AVOIDS
SOME
OF
THE
SUBTLETIES
THAT
ARISE
IN
THE
ANALYSIS
OF
DYNAMIC
GAMES
BUT
IT
IS
USEFUL
AS
A
FIRST
ILLUSTRATION
AND
WE
LL
PROCEED
TO
A
MORE
COMPLEX
SECOND
EXAMPLE
AFTERWARD
IN
OUR
FIRST
EXAMPLE
WE
IMAGINE
THAT
THERE
ARE
TWO
FIRMS
FIRM
AND
FIRM
EACH
OF
WHOM
IS
TRYING
TO
DECIDE
WHETHER
TO
FOCUS
ITS
ADVERTISING
AND
MARKETING
ON
TWO
POSSIBLE
REGIONS
NAMED
A
OR
B
FIRM
GETS
TO
CHOOSE
FIRST
IF
FIRM
FOLLOWS
FIRM
INTO
THE
SAME
REGION
THEN
FIRM
FIRST
MOVER
ADVANTAGE
GIVES
IT
OF
THE
PROFIT
OBTAINABLE
FROM
THE
MARKET
IN
THAT
REGION
WHILE
FIRM
WILL
ONLY
GET
IF
FIRM
MOVES
INTO
THE
OTHER
REGION
THEN
EACH
FIRM
GETS
ALL
THE
PROFIT
OBTAINABLE
IN
THEIR
RESPECTIVE
REGION
FINALLY
REGION
A
HAS
TWICE
AS
LARGE
A
MARKET
AS
REGION
B
THE
TOTAL
PROFIT
OBTAINABLE
IN
REGION
A
IS
EQUAL
TO
WHILE
IN
REGION
B
IT
WE
WRITE
THE
EXTENSIVE
FORM
REPRESENTATION
AS
A
GAME
TREE
DEPICTED
IN
FIGURE
THIS
TREE
IS
DESIGNED
TO
BE
READ
DOWNWARD
FROM
THE
TOP
THE
TOP
NODE
REPRESENTS
FIRM
INITIAL
MOVE
AND
THE
TWO
EDGES
DESCENDING
FROM
THIS
NODE
REPRESENT
ITS
TWO
OPTIONS
A
OR
B
BASED
ON
WHICH
BRANCH
IS
TAKEN
THIS
LEADS
TO
A
NODE
REPRESENTING
FIRM
SUBSEQUENT
MOVE
FIRM
CAN
THEN
ALSO
CHOOSE
OPTION
A
OR
B
AGAIN
REPRESENTED
BY
EDGES
DESCENDING
FROM
THE
NODE
THIS
LEADS
TO
A
TERMINAL
NODE
REPRESENTING
THE
END
OF
PLAY
IN
THE
GAME
EACH
TERMINAL
NODE
IS
LABELED
WITH
THE
PAYOFFS
TO
THE
TWO
PLAYERS
THUS
A
SPECIFIC
PLAY
DETERMINED
BY
A
SEQUENCE
OF
CHOICES
BY
FIRM
AND
FIRM
CORRESPONDS
TO
A
PATH
FROM
THE
TOP
NODE
IN
THE
TREE
DOWN
TO
SOME
TERMINAL
NODE
FIRST
FIRM
CHOOSES
A
OR
B
THEN
FIRM
CHOOSES
A
OR
B
AND
THEN
THE
TWO
PLAYERS
RECEIVE
THEIR
PAYOFFS
IN
A
MORE
GENERAL
MODEL
OF
DYNAMIC
GAMES
EACH
NODE
COULD
CONTAIN
AN
ANNOTATION
SAYING
WHAT
INFORMATION
ABOUT
THE
PREVIOUS
MOVES
IS
KNOWN
TO
THE
PLAYER
CURRENTLY
MAKING
A
MOVE
HOWEVER
FOR
OUR
PURPOSES
HERE
WE
WILL
FOCUS
ON
THE
CASE
IN
WHICH
EACH
PLAYER
KNOWS
THE
COMPLETE
HISTORY
OF
PAST
MOVES
WHEN
THEY
GO
TO
MAKE
THEIR
CURRENT
MOVE
REASONING
ABOUT
BEHAVIOR
IN
A
DYNAMIC
GAME
AS
WITH
SIMULTANEOUS
MOVE
GAMES
WE
D
LIKE
TO
MAKE
PREDICTIONS
FOR
WHAT
PLAYERS
WILL
DO
IN
DYNAMIC
GAMES
ONE
WAY
IS
TO
REASON
FROM
THE
GAME
TREE
IN
OUR
CURRENT
EXAMPLE
WE
CAN
START
BY
CONSIDERING
HOW
FIRM
WILL
BEHAVE
AFTER
EACH
OF
THE
TWO
POSSIBLE
OPENING
MOVES
BY
FIRM
IF
FIRM
CHOOSES
A
THEN
FIRM
MAXIMIZES
ITS
PAYOFF
BY
CHOOSING
B
WHILE
IF
FIRM
CHOOSES
B
THEN
FIRM
MAXIMIZES
ITS
PAYOFF
BY
CHOOSING
A
NOW
LET
CONSIDER
FIRM
OPENING
MOVE
GIVEN
WHAT
WE
VE
JUST
CONCLUDED
ABOUT
FIRM
SUBSEQUENT
BEHAVIOR
IF
FIRM
CHOOSES
A
THEN
IT
EXPECTS
FIRM
TO
CHOOSE
B
YIELDING
A
PAYOFF
OF
FOR
FIRM
IF
FIRM
CHOOSES
B
THEN
IT
EXPECTS
FIRM
TO
CHOOSE
A
YIELDING
A
PAYOFF
OF
FOR
FIRM
SINCE
WE
EXPECT
THE
FIRMS
TO
TRY
MAXIMIZING
THEIR
PAYOFFS
WE
PREDICT
THAT
FIRM
SHOULD
CHOOSE
A
AFTER
WHICH
FIRM
SHOULD
CHOOSE
B
THIS
IS
A
USEFUL
WAY
TO
ANALYZE
DYNAMIC
GAMES
WE
START
ONE
STEP
ABOVE
THE
TERMINAL
NODES
WHERE
THE
LAST
PLAYER
TO
MOVE
HAS
COMPLETE
CONTROL
OVER
THE
OUTCOME
OF
THE
PAYOFFS
THIS
LETS
US
PREDICT
WHAT
THE
LAST
PLAYER
WILL
DO
IN
ALL
CASES
HAVING
ESTABLISHED
THIS
WE
THEN
MOVE
ONE
MORE
LEVEL
UP
THE
GAME
TREE
USING
THESE
PREDICTIONS
TO
REASON
ABOUT
WHAT
THE
PLAYER
ONE
MOVE
EARLIER
WILL
DO
WE
CONTINUE
IN
THIS
WAY
UP
THE
TREE
EVENTUALLY
MAKING
PREDICTIONS
FOR
PLAY
ALL
THE
WAY
UP
TO
THE
TOP
NODE
A
DIFFERENT
STYLE
OF
ANALYSIS
EXPLOITS
AN
INTERESTING
CONNECTION
BETWEEN
NORMAL
AND
EXTEN
SIVE
FORMS
ALLOWING
US
TO
WRITE
A
NORMAL
FORM
REPRESENTATION
FOR
A
DYNAMIC
GAME
AS
FOLLOWS
SUPPOSE
THAT
BEFORE
THE
GAME
IS
PLAYED
EACH
PLAYER
MAKES
UP
A
PLAN
FOR
HOW
TO
PLAY
THE
ENTIRE
GAME
COVERING
EVERY
POSSIBLE
EVENTUALITY
THIS
PLAN
WILL
SERVE
AS
THE
PLAYER
STRATEGY
ONE
WAY
TO
THINK
ABOUT
SUCH
STRATEGIES
AND
A
USEFUL
WAY
TO
BE
SURE
THAT
THEY
INCLUDE
A
COMPLETE
DESCRIPTION
OF
EVERY
POSSIBILITY
IS
TO
IMAGINE
THAT
EACH
PLAYER
HAS
TO
PROVIDE
ALL
OF
THE
INFORMATION
NEEDED
TO
WRITE
A
COMPUTER
PROGRAM
WHICH
WILL
ACTUALLY
PLAY
THE
GAME
IN
THEIR
PLACE
FOR
THE
GAME
IN
FIGURE
FIRM
ONLY
HAS
TWO
POSSIBLE
STRATEGIES
A
OR
B
SINCE
FIRM
MOVES
AFTER
OBSERVING
WHAT
FIRM
DID
AND
FIRM
HAS
TWO
POSSIBLE
CHOICES
FOR
EACH
OF
THE
TWO
OPTIONS
BY
FIRM
FIRM
HAS
FOUR
POSSIBLE
PLANS
FOR
PLAYING
THE
GAME
THEY
CAN
BE
WRITTEN
AS
CONTINGENCIES
SPECIFYING
WHAT
FIRM
WILL
DO
IN
RESPONSE
TO
EACH
POSSIBLE
MOVE
BY
FIRM
A
IF
A
A
IF
B
A
IF
A
B
IF
B
B
IF
A
A
IF
B
AND
B
IF
A
B
IF
B
OR
IN
ABBREVIATED
FORM
AS
AA
AB
AA
BB
BA
AB
AND
BA
BB
IF
EACH
PLAYER
CHOOSES
A
COMPLETE
PLAN
FOR
PLAYING
THE
GAME
AS
ITS
STRATEGY
THEN
WE
CAN
DETERMINE
THE
PAYOFFS
DIRECTLY
FROM
THIS
PAIR
OF
CHOSEN
STRATEGIES
VIA
A
PAYOFF
MATRIX
FIRM
A
B
FIRM
AA
AB
AA
BB
BA
AB
BA
BB
FIGURE
CONVERSION
TO
NORMAL
FORM
BECAUSE
THE
PLANS
DESCRIBE
EVERYTHING
ABOUT
HOW
A
PLAYER
WILL
BEHAVE
WE
HAVE
MANAGED
TO
DESCRIBE
THIS
DYNAMIC
GAME
IN
NORMAL
FORM
EACH
PLAYER
CHOOSES
A
STRATEGY
CONSISTING
OF
A
COMPLETE
PLAN
IN
ADVANCE
AND
FROM
THIS
JOINT
CHOICE
OF
STRATEGIES
WE
CAN
DETERMINE
PAYOFFS
WE
WILL
SEE
LATER
THAT
THERE
ARE
SOME
IMPORTANT
SUBTLETIES
IN
USING
THIS
INTERPRETATION
OF
THE
UNDERLYING
DYNAMIC
GAME
AND
IN
PARTICULAR
THE
TRANSLATION
FROM
EXTENSIVE
TO
NORMAL
FORM
WILL
SOMETIMES
NOT
PRESERVE
THE
FULL
STRUCTURE
IMPLICIT
IN
THE
GAME
BUT
THE
TRANSLATION
IS
A
USEFUL
TOOL
FOR
ANALYSIS
AND
THE
SUBTLE
LACK
OF
FIDELITY
THAT
CAN
ARISE
IN
THE
TRANSLATION
IS
IN
ITSELF
A
REVEALING
NOTION
TO
DEVELOP
AND
EXPLORE
WITH
THIS
IN
MIND
WE
FIRST
FINISH
OUR
SIMPLE
EXAMPLE
WHERE
THE
TRANSLATION
WILL
WORK
PERFECTLY
AND
THEN
MOVE
ON
TO
A
SECOND
EXAMPLE
WHERE
THE
COMPLICATIONS
BEGIN
TO
ARISE
FOR
THE
NORMAL
FORM
PAYOFF
MATRIX
CORRESPONDING
TO
OUR
FIRST
EXAMPLE
THE
PAYOFF
MATRIX
HAS
EIGHT
CELLS
WHILE
THE
EXTENSIVE
FORM
REPRESENTATION
ONLY
HAS
FOUR
TERMINAL
NODES
WITH
PAYOFFS
THIS
OCCURS
BECAUSE
EACH
TERMINAL
NODE
CAN
BE
REACHED
WITH
TWO
DIFFERENT
PAIRS
OF
STRATEGIES
WITH
EACH
PAIR
FORMING
A
CELL
OF
THE
PAYOFF
MATRIX
BOTH
PAIRS
OF
STRATEGIES
DICTATE
THE
SAME
ACTIONS
IN
THE
PATH
OF
THE
GAME
TREE
WHICH
ACTUALLY
OCCURS
BUT
DESCRIBE
DIFFERENT
HYPOTHETICAL
ACTIONS
IN
OTHER
UNREALIZED
PATHS
FOR
EXAMPLE
THE
PAYOFFS
IN
THE
ENTRIES
FOR
A
AA
AB
AND
FOR
A
AA
BB
ARE
THE
SAME
BECAUSE
BOTH
STRATEGY
COMBINATIONS
LEAD
TO
THE
SAME
TERMINAL
NODE
IN
BOTH
CASES
FIRM
CHOOSES
A
IN
RESPONSE
TO
WHAT
FIRM
ACTUALLY
DOES
FIRM
PLAN
FOR
WHAT
TO
DO
IN
THE
EVENT
FIRM
CHOSE
B
IS
NOT
REALIZED
BY
THE
ACTUAL
PLAY
NOW
USING
THE
NORMAL
FORM
REPRESENTATION
WE
CAN
QUICKLY
SEE
THAT
FOR
FIRM
STRATEGY
A
IS
STRICTLY
DOMINANT
FIRM
DOES
NOT
HAVE
A
STRICTLY
DOMINANT
STRATEGY
BUT
IT
SHOULD
PLAY
A
BEST
RESPONSE
TO
FIRM
WHICH
WOULD
BE
EITHER
BA
AB
OR
BA
BB
NOTICE
THAT
THIS
PREDICTION
OF
PLAY
BY
FIRM
AND
FIRM
BASED
ON
THE
NORMAL
FORM
REPRESENTATION
IS
THE
SAME
AS
OUR
PREDICTION
BASED
ON
DIRECT
ANALYSIS
OF
THE
GAME
TREE
WHERE
WE
REASONED
UPWARD
FROM
THE
TERMINAL
NODES
FIRM
WILL
PLAY
A
AND
IN
RESPONSE
FIRM
WILL
PLAY
B
A
MORE
COMPLEX
EXAMPLE
THE
MARKET
ENTRY
GAME
IN
OUR
FIRST
DYNAMIC
GAME
REASONING
BASED
ON
THE
EXTENSIVE
AND
NORMAL
FORM
REPRESENTATIONS
LED
TO
ESSENTIALLY
IDENTICAL
CONCLUSIONS
AS
GAMES
GET
LARGER
EXTENSIVE
FORMS
ARE
REPRESENTATIONALLY
MORE
STREAMLINED
THAN
NORMAL
FORMS
FOR
DYNAMIC
GAMES
BUT
IF
THIS
WERE
THE
ONLY
DISTINCTION
IT
WOULD
BE
HARD
TO
ARGUE
THAT
DYNAMIC
GAMES
TRULY
ADD
MUCH
TO
THE
OVERALL
THEORY
OF
GAMES
IN
FACT
HOWEVER
THE
DYNAMIC
ASPECT
LEADS
TO
NEW
SUBTLETIES
AND
THIS
CAN
BE
EXPOSED
BY
CONSIDERING
A
CASE
IN
WHICH
THE
TRANSLATION
FROM
EXTENSIVE
FORM
TO
NORMAL
FORM
ENDS
UP
OBSCURING
SOME
OF
THE
STRUCTURE
THAT
IS
IMPLICIT
IN
THE
DYNAMIC
GAME
FOR
THIS
WE
CONSIDER
A
SECOND
EXAMPLE
OF
A
DYNAMIC
GAME
ALSO
PLAYED
BETWEEN
TWO
COMPETING
FIRMS
WE
CALL
THIS
THE
MARKET
ENTRY
GAME
AND
IT
MOTIVATED
BY
THE
FOLLOWING
SCENARIO
CONSIDER
A
REGION
WHERE
FIRM
IS
CURRENTLY
THE
ONLY
SERIOUS
PARTICIPANT
IN
A
GIVEN
LINE
OF
BUSINESS
AND
FIRM
IS
CONSIDERING
WHETHER
TO
ENTER
THE
MARKET
THE
FIRST
MOVE
IN
THIS
GAME
IS
MADE
BY
FIRM
WHO
MUST
DECIDE
WHETHER
TO
STAY
OUT
OF
THE
MARKET
OR
ENTER
IT
IF
FIRM
CHOOSES
TO
STAY
OUT
THEN
THE
GAME
ENDS
WITH
FIRM
GETTING
A
PAYOFF
OF
AND
FIRM
KEEPING
THE
PAYOFF
FROM
THE
ENTIRE
MARKET
PLAYER
FIGURE
EXTENSIVE
FORM
REPRESENTATION
OF
THE
MARKET
ENTRY
GAME
IF
FIRM
CHOOSES
TO
ENTER
THEN
THE
GAME
CONTINUES
TO
A
SECOND
MOVE
BY
FIRM
WHO
MUST
CHOOSE
WHETHER
TO
COOPERATE
AND
DIVIDE
THE
MARKET
EVENLY
WITH
FIRM
OR
RETALIATE
AND
ENGAGE
IN
A
PRICE
WAR
IF
FIRM
COOPERATES
THEN
EACH
FIRM
GETS
A
PAYOFF
CORRESPONDING
TO
HALF
THE
MARKET
IF
FIRM
RETALIATES
THEN
EACH
FIRM
GETS
A
NEGATIVE
PAYOFF
CHOOSING
NUMERICAL
PAYOFFS
TO
FILL
IN
THIS
STORY
WE
CAN
WRITE
THE
EXTENSIVE
FORM
REPRESENTATION
OF
THE
MARKET
ENTRY
GAME
AS
IN
FIGURE
SUBTLE
DISTINCTIONS
BETWEEN
EXTENSIVE
AND
NORMAL
FORM
REPRESENTATIONS
LET
TAKE
THE
TWO
WAYS
WE
DEVELOPED
TO
ANALYZE
OUR
PREVIOUS
DYNAMIC
GAME
AND
APPLY
THEM
HERE
FIRST
WE
CAN
WORK
OUR
WAY
UP
THE
GAME
TREE
STARTING
AT
THE
TERMINAL
NODES
AS
FOLLOWS
IF
FIRM
CHOOSES
TO
ENTER
THE
MARKET
THEN
FIRM
ACHIEVES
A
HIGHER
PAYOFF
BY
COOPERATING
THAN
BY
RETALIATING
SO
WE
SHOULD
PREDICT
COOPERATION
IN
THE
EVENT
THE
GAME
REACHES
THIS
POINT
GIVEN
THIS
WHEN
FIRM
GOES
TO
MAKE
ITS
FIRST
MOVE
IT
CAN
EXPECT
A
PAYOFF
OF
BY
STAYING
OUT
AND
A
PAYOFF
OF
BY
ENTERING
SO
IT
SHOULD
CHOOSE
TO
ENTER
THE
MARKET
WE
CAN
THEREFORE
PREDICT
THAT
FIRM
WILL
ENTER
THE
MARKET
AND
THEN
FIRM
WILL
COOPERATE
NOW
LET
CONSIDER
THE
NORMAL
FORM
REPRESENTATION
FIRM
POSSIBLE
PLANS
FOR
PLAYING
THE
GAME
ARE
JUST
TO
CHOOSE
STAY
OUT
OR
ENTER
E
FIRM
POSSIBLE
PLANS
ARE
TO
CHOOSE
RETALIATION
IN
THE
EVENT
OF
ENTRY
OR
COOPERATION
IN
THE
EVENT
OF
ENTRY
WE
LL
DENOTE
THESE
TWO
PLANS
BY
R
AND
C
RESPECTIVELY
THIS
GIVES
US
THE
PAYOFF
MATRIX
IN
FIGURE
FIRM
E
FIRM
R
C
FIGURE
NORMAL
FORM
OF
THE
MARKET
ENTRY
GAME
HERE
THE
SURPRISE
WHEN
WE
LOOK
AT
THIS
GAME
IN
NORMAL
FORM
WE
DISCOVER
TWO
DISTINCT
PURE
STRATEGY
NASH
EQUILIBRIA
E
C
AND
R
THE
FIRST
OF
THESE
CORRESPONDS
TO
THE
PREDICTION
FOR
PLAY
THAT
WE
OBTAINED
BY
ANALYZING
THE
EXTENSIVE
FORM
REPRESENTATION
WHAT
DOES
THE
SECOND
ONE
CORRESPOND
TO
TO
ANSWER
THIS
IT
HELPS
TO
RECALL
OUR
VIEW
OF
THE
NORMAL
FORM
REPRESENTATION
AS
CAPTURING
THE
IDEA
THAT
EACH
PLAYER
COMMITS
IN
ADVANCE
TO
A
COMPUTER
PROGRAM
THAT
WILL
PLAY
THE
GAME
IN
ITS
PLACE
VIEWED
THIS
WAY
THE
EQUILIBRIUM
R
CORRESPONDS
TO
AN
OUTCOME
IN
WHICH
FIRM
COMMITS
IN
ADVANCE
TO
A
COMPUTER
PROGRAM
THAT
WILL
AUTOMATICALLY
RETALIATE
IN
THE
EVENT
THAT
FIRM
ENTERS
THE
MARKET
FIRM
MEANWHILE
COMMITS
TO
A
PROGRAM
THAT
STAYS
OUT
OF
THE
MARKET
GIVEN
THIS
PAIR
OF
CHOICES
NEITHER
FIRM
HAS
AN
INCENTIVE
TO
CHANGE
THE
COMPUTER
PROGRAM
THEY
RE
USING
FOR
EXAMPLE
IF
FIRM
WERE
TO
SWITCH
TO
A
PROGRAM
THAT
ENTERED
THE
MARKET
IT
WOULD
TRIGGER
RETALIATION
BY
THE
PROGRAM
THAT
FIRM
IS
USING
THIS
CONTRAST
BETWEEN
THE
PREDICTION
FROM
THE
EXTENSIVE
AND
NORMAL
FORMS
HIGHLIGHTS
SOME
IMPORTANT
POINTS
FIRST
IT
SHOWS
THAT
THE
PREMISE
BEHIND
OUR
TRANSLATION
FROM
EXTENSIVE
TO
NORMAL
FORM
THAT
EACH
PLAYER
COMMITS
AHEAD
OF
TIME
TO
A
COMPLETE
PLAN
FOR
PLAYING
THE
GAME
IS
NOT
REALLY
EQUIVALENT
TO
OUR
INITIAL
PREMISE
IN
DEFINING
DYNAMIC
GAMES
NAMELY
THAT
EACH
PLAYER
MAKES
AN
OPTIMAL
DECISION
AT
EACH
INTERMEDIATE
POINT
IN
THE
GAME
BASED
ON
WHAT
HAS
ALREADY
HAPPENED
UP
TO
THAT
POINT
FIRM
DECISION
TO
RETALIATE
ON
ENTRY
HIGHLIGHTS
THIS
CLEARLY
IF
FIRM
CAN
TRULY
PRE
COMMIT
TO
THIS
PLAN
THEN
THE
EQUILIBRIUM
R
MAKES
SENSE
SINCE
FIRM
WILL
NOT
WANT
TO
PROVOKE
THE
RETALIATION
THAT
IS
ENCODED
IN
FIRM
PLAN
BUT
IF
WE
TAKE
THE
DYNAMIC
GAME
AS
ORIGINALLY
DEFINED
IN
EXTENSIVE
FORM
THEN
PRE
COMMITMENT
TO
A
PLAN
IS
NOT
PART
OF
THE
MODEL
RATHER
FIRM
ONLY
GETS
TO
EVALUATE
ITS
DECISION
TO
COOPERATE
OR
RETALIATE
ONCE
FIRM
HAS
ALREADY
ENTERED
THE
MARKET
AND
AT
THAT
POINT
ITS
PAYOFF
IS
BETTER
IF
IT
COOPERATES
GIVEN
THIS
FIRM
CAN
PREDICT
THAT
IT
IS
SAFE
TO
ENTER
IN
GAME
THEORY
THE
STANDARD
MODEL
FOR
DYNAMIC
GAMES
IN
EXTENSIVE
FORM
ASSUMES
THAT
PLAYERS
WILL
SEEK
TO
MAXIMIZE
THEIR
PAYOFF
AT
ANY
INTERMEDIATE
STAGE
OF
PLAY
THAT
CAN
BE
REACHED
IN
THE
GAME
IN
THIS
INTERPRETATION
THERE
IS
A
UNIQUE
PREDICTION
FOR
PLAY
IN
OUR
MARKET
ENTRY
GAME
CORRESPONDING
TO
THE
EQUILIBRIUM
E
C
IN
NORMAL
FORM
HOWEVER
THE
ISSUES
SURROUNDING
THE
OTHER
EQUILIBRIUM
R
ARE
NOT
SIMPLY
NOTATIONAL
OR
REPRESENTATIONAL
THEY
ARE
DEEPER
THAN
THIS
FOR
ANY
GIVEN
SCENARIO
IT
IS
REALLY
A
QUESTION
OF
WHAT
WE
BELIEVE
IS
BEING
MODELED
BY
THE
UNDERLYING
DYNAMIC
GAME
IN
EXTENSIVE
FORM
IT
IS
A
QUESTION
OF
WHETHER
WE
ARE
IN
A
SETTING
WHERE
A
PLAYER
CAN
IRREVOCABLY
PRE
COMMIT
TO
A
CERTAIN
PLAN
TO
THE
EXTENT
THAT
OTHER
PLAYERS
WILL
BELIEVE
THE
COMMITMENT
AS
A
CREDIBLE
THREAT
OR
NOT
FURTHER
THE
MARKET
ENTRY
GAME
SHOWS
HOW
THE
ABILITY
TO
COMMIT
TO
A
PARTICULAR
COURSE
OF
ACTION
WHEN
POSSIBLE
CAN
IN
FACT
BE
A
VALUABLE
THING
FOR
AN
INDIVIDUAL
PLAYER
EVEN
IF
THAT
COURSE
OF
ACTION
WOULD
BE
BAD
FOR
EVERYONE
IF
IT
WERE
ACTUALLY
CARRIED
OUT
IN
PARTICULAR
IF
FIRM
COULD
MAKE
FIRM
BELIEVE
THAT
IT
REALLY
WOULD
RETALIATE
IN
THE
EVENT
OF
ENTRY
THEN
FIRM
WOULD
CHOOSE
TO
STAY
OUT
RESULTING
IN
A
HIGHER
PAYOFF
FOR
FIRM
IN
PRACTICE
THIS
SUGGESTS
PARTICULAR
COURSES
OF
ACTION
THAT
FIRM
COULD
TAKE
BEFORE
THE
GAME
EVEN
STARTS
FOR
EXAMPLE
SUPPOSE
THAT
BEFORE
FIRM
HAD
DECIDED
WHETHER
TO
ENTER
THE
MARKET
FIRM
WERE
TO
PUBLICALLY
ADVERTISE
AN
OFFER
TO
BEAT
ANY
COMPETITOR
PRICE
BY
THIS
WOULD
BE
A
SAFE
THING
TO
DO
AS
LONG
AS
FIRM
IS
THE
ONLY
SERIOUS
PARTICIPANT
IN
THE
MARKET
BUT
IT
BECOMES
DANGEROUS
TO
BOTH
FIRMS
IF
FIRM
ACTUALLY
ENTERS
THE
FACT
THAT
THE
PLAN
HAS
BEEN
PUBLICALLY
ANNOUNCED
MEANS
THAT
IT
WOULD
BE
VERY
COSTLY
REPUTATIONALLY
AND
POSSIBLY
LEGALLY
FOR
FIRM
TO
BACK
AWAY
FROM
IT
IN
THIS
WAY
THE
ANNOUNCEMENT
CAN
SERVE
AS
A
WAY
OF
SWITCHING
THE
UNDERLYING
MODEL
FROM
ONE
IN
WHICH
FIRM
THREAT
TO
RETALIATE
IS
NOT
CREDIBLE
TO
ONE
IN
WHICH
FIRM
CAN
ACTUALLY
PRE
COMMIT
TO
A
PLAN
FOR
RETALIATION
RELATIONSHIP
TO
WEAKLY
DOMINATED
STRATEGIES
IN
DISCUSSING
THESE
DISTINCTIONS
IT
IS
ALSO
INTERESTING
TO
NOTE
THE
ROLE
THAT
WEAKLY
DOMINATED
STRATEGIES
PLAY
HERE
NOTICE
THAT
IN
THE
NORMAL
FORM
REPRESENTATION
IN
FIGURE
THE
STRATEGY
R
FOR
FIRM
IS
WEAKLY
DOMINATED
AND
FOR
A
SIMPLE
REASON
IT
YIELDS
THE
SAME
PAYOFF
IF
FIRM
CHOOSES
SINCE
THEN
FIRM
DOESN
T
ACTUALLY
GET
TO
MOVE
AND
IT
YIELDS
A
LOWER
PAYOFF
IF
FIRM
CHOOSES
E
SO
OUR
TRANSLATION
FROM
EXTENSIVE
FORM
TO
NORMAL
FORM
FOR
DYNAMIC
GAMES
PROVIDES
ANOTHER
REASON
TO
BE
CAREFUL
ABOUT
PREDICTIONS
OF
PLAY
IN
A
NORMAL
FORM
GAME
THAT
RELY
ON
WEAKLY
DOMINATED
STRATEGIES
IF
THE
STRUCTURE
IN
FACT
ARISES
FROM
A
DYNAMIC
GAME
IN
EXTENSIVE
FORM
THEN
INFORMATION
ABOUT
THE
DYNAMIC
GAME
THAT
IS
LOST
IN
THE
TRANSLATION
TO
NORMAL
FORM
COULD
POTENTIALLY
BE
SUFFICIENT
TO
ELIMINATE
SUCH
EQUILIBRIA
HOWEVER
WE
CAN
T
SIMPLY
FIX
UP
THE
TRANSLATION
BY
ELIMINATING
WEAKLY
DOMINATED
STRATE
GIES
WE
SAW
EARLIER
THAT
ITERATED
DELETION
OF
STRICTLY
DOMINATED
STRATEGIES
CAN
BE
DONE
IN
ANY
ORDER
ALL
ORDERS
YIELD
THE
SAME
FINAL
RESULT
BUT
THIS
IS
NOT
TRUE
FOR
THE
ITERATED
DELETION
OF
WEAKLY
DOMINATED
STRATEGIES
TO
SEE
THIS
SUPPOSE
WE
VARY
THE
MARKET
ENTRY
GAME
SLIGHTLY
SO
THAT
THE
PAYOFF
FROM
THE
JOINT
STRATEGY
E
C
IS
IN
THIS
VERSION
BOTH
FIRMS
KNOW
THEY
WILL
FAIL
TO
GAIN
A
POSITIVE
PAYOFF
EVEN
IF
FIRM
COOPERATES
ON
ENTRY
ALTHOUGH
THEY
STILL
DON
T
DO
AS
BADLY
AS
WHEN
FIRM
RETALIATES
R
IS
A
WEAKLY
DOMINATED
STRATEGY
AS
BEFORE
BUT
NOW
SO
IS
E
E
AND
PRODUCE
THE
SAME
PAYOFF
FOR
FIRM
WHEN
FIRM
CHOOSES
C
AND
PRODUCES
A
STRICTLY
HIGHER
PAYOFF
WHEN
FIRM
CHOOSES
R
IN
THIS
VERSION
OF
THE
GAME
THERE
ARE
NOW
THREE
PURE
STRATEGY
NASH
EQUILIBRIA
C
E
C
AND
R
IF
WE
FIRST
ELIMINATE
THE
WEAKLY
DOMINATED
STRATEGY
R
THEN
WE
ARE
LEFT
WITH
C
AND
E
C
AS
EQUILIBRIA
ALTERNATELY
IF
WE
FIRST
ELIMINATE
THE
WEAKLY
DOMINATED
STRATEGY
E
THEN
WE
ARE
LEFT
WITH
C
AND
R
AS
EQUILIBRIA
IN
BOTH
CASES
NO
FURTHER
ELIMINATION
OF
WEAKLY
DOMINATED
STRATEGIES
IS
POSSIBLE
SO
THE
ORDER
OF
DELETION
AFFECTS
THE
FINAL
SET
OF
EQUILIBRIA
WE
CAN
ASK
WHICH
OF
THESE
EQUILIBRIA
ACTUALLY
MAKE
SENSE
AS
PREDICTIONS
OF
PLAY
IN
THIS
GAME
IF
THIS
NORMAL
FORM
ACTUALLY
AROSE
FROM
THE
DYNAMIC
VERSION
OF
THE
MARKET
ENTRY
GAME
THEN
C
IS
STILL
THE
ONLY
REASONABLE
STRATEGY
FOR
FIRM
WHILE
FIRM
COULD
NOW
PLAY
EITHER
OR
E
FINAL
COMMENTS
THE
ANALYSIS
FRAMEWORK
WE
DEVELOPED
FOR
MOST
OF
THIS
CHAPTER
IS
BASED
ON
GAMES
IN
NORMAL
FORM
ONE
APPROACH
TO
ANALYZING
DYNAMIC
GAMES
IN
EXTENSIVE
FORM
IS
TO
FIRST
FIND
ALL
NASH
EQUILIBRIA
OF
THE
TRANSLATION
TO
NORMAL
FORM
TREATING
EACH
OF
THESE
AS
A
CANDIDATE
PREDICTION
OF
PLAY
IN
THE
DYNAMIC
GAME
AND
THEN
GO
BACK
TO
THE
EXTENSIVE
FORM
VERSION
TO
SEE
WHICH
OF
THESE
MAKE
SENSE
AS
ACTUAL
PREDICTIONS
THERE
IS
AN
ALTERNATE
THEORY
THAT
WORKS
DIRECTLY
WITH
THE
EXTENSIVE
FORM
REPRESENTATION
THE
SIMPLEST
TECHNIQUE
USED
IN
THIS
THEORY
IS
THE
STYLE
OF
ANALYSIS
WE
EMPLOYED
TO
ANALYZE
AN
EXTENSIVE
FORM
REPRESENTATION
FROM
THE
TERMINAL
NODES
UPWARD
BUT
THERE
ARE
MORE
COMPLEX
COMPONENTS
TO
THE
THEORY
AS
WELL
ALLOWING
FOR
RICHER
STRUCTURE
SUCH
AS
THE
POSSIBILITY
THAT
PLAYERS
AT
ANY
GIVEN
POINT
HAVE
ONLY
PARTIAL
INFORMATION
ABOUT
THE
HISTORY
OF
PLAY
UP
TO
THAT
POINT
WHILE
WE
WILL
NOT
GO
FURTHER
INTO
THIS
THEORY
HERE
IT
IS
DEVELOPED
IN
A
NUMBER
OF
BOOKS
ON
GAME
THEORY
AND
MICROECONOMIC
THEORY
EXERCISES
SAY
WHETHER
THE
FOLLOWING
CLAIM
IS
TRUE
OR
FALSE
AND
PROVIDE
A
BRIEF
SENTENCE
EXPLANATION
FOR
YOUR
ANSWER
CLAIM
IF
PLAYER
A
IN
A
TWO
PERSON
GAME
HAS
A
DOMINANT
STRATEGY
SA
THEN
THERE
IS
A
PURE
STRATEGY
NASH
EQUILIBRIUM
IN
WHICH
PLAYER
A
PLAYS
SA
AND
PLAYER
B
PLAYS
A
BEST
RESPONSE
TO
SA
CONSIDER
THE
FOLLOWING
STATEMENT
IN
A
NASH
EQUILIBRIUM
OF
A
TWO
PLAYER
GAME
EACH
PLAYER
IS
PLAYING
AN
OPTIMAL
STRATEGY
SO
THE
TWO
PLAYER
STRATEGIES
ARE
SOCIAL
WELFARE
MAXIMIZING
IS
THIS
STATEMENT
CORRECT
OR
INCORRECT
IF
YOU
THINK
IT
IS
CORRECT
GIVE
A
BRIEF
SENTENCE
EXPLANATION
FOR
WHY
IF
YOU
THINK
IT
IS
INCORRECT
GIVE
AN
EXAMPLE
OF
A
GAME
DISCUSSED
IN
CHAPTER
THAT
SHOWS
IT
TO
BE
INCORRECT
YOU
DO
NOT
NEED
TO
SPELL
OUT
ALL
THE
DETAILS
OF
THE
GAME
PROVIDED
YOU
MAKE
IT
CLEAR
WHAT
YOU
ARE
REFERRING
TO
TOGETHER
WITH
A
BRIEF
SENTENCE
EXPLANATION
FIND
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
IN
THE
GAME
BELOW
IN
THE
PAYOFF
MATRIX
BELOW
THE
ROWS
CORRESPOND
TO
PLAYER
A
STRATEGIES
AND
THE
COLUMNS
CORRESPOND
TO
PLAYER
B
STRATEGIES
THE
FIRST
ENTRY
IN
EACH
BOX
IS
PLAYER
A
PAYOFF
AND
THE
SECOND
ENTRY
IS
PLAYER
B
PAYOFF
PLAYER
A
U
D
PLAYER
B
L
R
CONSIDER
THE
TWO
PLAYER
GAME
WITH
PLAYERS
STRATEGIES
AND
PAYOFFS
DESCRIBED
IN
THE
FOLLOWING
GAME
MATRIX
T
PLAYER
A
M
B
PLAYER
B
L
M
R
FIGURE
PAYOFF
MATRIX
A
DOES
EITHER
PLAYER
HAVE
A
DOMINANT
STRATEGY
EXPLAIN
BRIEFLY
SENTENCES
B
FIND
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
FOR
THIS
GAME
CONSIDER
THE
FOLLOWING
TWO
PLAYER
GAME
IN
WHICH
EACH
PLAYER
HAS
THREE
STRATEGIES
U
PLAYER
A
M
D
PLAYER
B
L
M
R
FIND
ALL
THE
PURE
STRATEGY
NASH
EQUILIBRIA
FOR
THIS
GAME
IN
THIS
QUESTION
WE
WILL
CONSIDER
SEVERAL
TWO
PLAYER
GAMES
IN
EACH
PAYOFF
MATRIX
BELOW
THE
ROWS
CORRESPOND
TO
PLAYER
A
STRATEGIES
AND
THE
COLUMNS
CORRESPOND
TO
PLAYER
B
STRATEGIES
THE
FIRST
ENTRY
IN
EACH
BOX
IS
PLAYER
A
PAYOFF
AND
THE
SECOND
ENTRY
IS
PLAYER
B
PAYOFF
A
FIND
ALL
PURE
NON
RANDOMIZED
STRATEGY
NASH
EQUILIBRIA
FOR
THE
GAME
DESCRIBED
BY
THE
PAYOFF
MATRIX
BELOW
PLAYER
A
U
D
PLAYER
B
L
R
B
FIND
ALL
PURE
NON
RANDOMIZED
STRATEGY
NASH
EQUILIBRIA
FOR
THE
GAME
DESCRIBED
BY
THE
PAYOFF
MATRIX
BELOW
PLAYER
A
U
D
PLAYER
B
L
R
C
FIND
ALL
NASH
EQUILIBRIA
FOR
THE
GAME
DESCRIBED
BY
THE
PAYOFF
MATRIX
BELOW
PLAYER
A
U
D
PLAYER
B
L
R
HINT
THIS
GAME
HAS
A
BOTH
PURE
STRATEGY
EQUILIBRIA
AND
A
MIXED
STRATEGY
EQUILIBRIUM
TO
FIND
THE
MIXED
STRATEGY
EQUILIBRIUM
LET
THE
PROBABILITY
THAT
PLAYER
A
USES
STRATEGY
U
BE
P
AND
THE
PROBABILITY
THAT
PLAYER
B
USES
STRATEGY
L
BE
Q
AS
WE
LEARNED
IN
OUR
ANALYSIS
OF
MATCHING
PENNIES
IF
A
PLAYER
USES
A
MIXED
STRATEGY
ONE
THAT
IS
NOT
REALLY
JUST
SOME
PURE
STRATEGY
PLAYED
WITH
PROBABILITY
ONE
THEN
THE
PLAYER
MUST
BE
INDIFFERENT
BETWEEN
TWO
PURE
STRATEGIES
THAT
IS
THE
STRATEGIES
MUST
HAVE
EQUAL
EXPECTED
PAYOFFS
SO
FOR
EXAMPLE
IF
P
IS
NOT
OR
THEN
IT
MUST
BE
THE
CASE
THAT
Q
Q
Q
AS
THESE
ARE
THE
EXPECTED
PAYOFFS
TO
PLAYER
A
FROM
U
AND
D
WHEN
PLAYER
B
USES
PROBABILITY
Q
IN
THIS
QUESTION
WE
WILL
CONSIDER
SEVERAL
TWO
PLAYER
GAMES
IN
EACH
PAYOFF
MATRIX
BELOW
THE
ROWS
CORRESPOND
TO
PLAYER
A
STRATEGIES
AND
THE
COLUMNS
CORRESPOND
TO
PLAYER
B
STRATEGIES
THE
FIRST
ENTRY
IN
EACH
BOX
IS
PLAYER
A
PAYOFF
AND
THE
SECOND
ENTRY
IS
PLAYER
B
PAYOFF
A
FIND
ALL
NASH
EQUILIBRIA
FOR
THE
GAME
DESCRIBED
BY
THE
PAYOFF
MATRIX
BELOW
PLAYER
A
U
D
PLAYER
A
U
D
PLAYER
B
L
R
PLAYER
B
L
R
B
FIND
ALL
NASH
EQUILIBRIA
FOR
THE
GAME
DESCRIBED
BY
THE
PAYOFF
MATRIX
BELOW
INCLUDE
AN
EXPLANATION
FOR
YOUR
ANSWER
HINT
THIS
GAME
HAS
A
MIXED
STRATEGY
EQUILIBRIUM
TO
FIND
THE
EQUILIBRIUM
LET
THE
PROBABILITY
THAT
PLAYER
A
USES
STRATEGY
U
BE
P
AND
THE
PROBABILITY
THAT
PLAYER
B
USES
STRATEGY
L
BE
Q
AS
WE
LEARNED
IN
OUR
ANALYSIS
OF
MATCHING
PENNIES
IF
A
PLAYER
USES
A
MIXED
STRATEGY
ONE
THAT
IS
NOT
REALLY
JUST
SOME
PURE
STRATEGY
PLAYED
WITH
PROBABILITY
ONE
THEN
THE
PLAYER
MUST
BE
INDIFFERENT
BETWEEN
TWO
PURE
STRATEGIES
THAT
IS
THE
STRATEGIES
MUST
HAVE
EQUAL
EXPECTED
PAYOFFS
SO
FOR
EXAMPLE
IF
P
IS
NOT
OR
THEN
IT
MUST
BE
THE
CASE
THAT
Q
Q
AS
THESE
ARE
THE
EXPECTED
PAYOFFS
TO
PLAYER
A
FROM
U
AND
D
WHEN
PLAYER
B
USES
PROBABILITY
Q
CONSIDER
THE
TWO
PLAYER
GAME
DESCRIBED
BY
THE
PAYOFF
MATRIX
BELOW
PLAYER
A
U
D
PLAYER
B
L
R
A
FIND
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
FOR
THIS
GAME
B
THIS
GAME
ALSO
HAS
A
MIXED
STRATEGY
NASH
EQUILIBRIUM
FIND
THE
PROBABILITIES
THE
PLAYERS
USE
IN
THIS
EQUILIBRIUM
TOGETHER
WITH
AN
EXPLANATION
FOR
YOUR
ANSWER
C
KEEPING
IN
MIND
SCHELLING
FOCAL
POINT
IDEA
FROM
CHAPTER
WHAT
EQUILIBRIUM
DO
YOU
THINK
IS
THE
BEST
PREDICTION
OF
HOW
THE
GAME
WILL
BE
PLAYED
EXPLAIN
FOR
EACH
OF
THE
FOLLOWING
TWO
PLAYER
GAMES
FIND
ALL
NASH
EQUILIBRIA
IN
EACH
PAYOFF
MATRIX
BELOW
THE
ROWS
CORRESPOND
TO
PLAYER
A
STRATEGIES
AND
THE
COLUMNS
CORRESPOND
TO
PLAYER
B
STRATEGIES
THE
FIRST
ENTRY
IN
EACH
BOX
IS
PLAYER
A
PAYOFF
AND
THE
SECOND
ENTRY
IS
PLAYER
B
PAYOFF
A
B
PLAYER
A
U
D
PLAYER
B
L
R
PLAYER
B
L
R
PLAYER
A
U
D
IN
THE
PAYOFF
MATRIX
BELOW
THE
ROWS
CORRESPOND
TO
PLAYER
A
STRATEGIES
AND
THE
COLUMNS
CORRESPOND
TO
PLAYER
B
STRATEGIES
THE
FIRST
ENTRY
IN
EACH
BOX
IS
PLAYER
A
PAYOFF
AND
THE
SECOND
ENTRY
IS
PLAYER
B
PAYOFF
PLAYER
A
U
D
PLAYER
B
L
R
A
FIND
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
OF
THIS
GAME
B
NOTICE
FROM
THE
PAYOFF
MATRIX
ABOVE
THAT
PLAYER
A
PAYOFF
FROM
THE
PAIR
OF
STRATEGIES
U
L
IS
CAN
YOU
CHANGE
PLAYER
A
PAYOFF
FROM
THIS
PAIR
OF
STRATE
GIES
TO
SOME
NON
NEGATIVE
NUMBER
IN
SUCH
A
WAY
THAT
THE
RESULTING
GAME
HAS
NO
PURE
STRATEGY
NASH
EQUILIBRIUM
GIVE
A
BRIEF
SENTENCE
EXPLANATION
FOR
YOUR
ANSWER
NOTE
THAT
IN
ANSWERING
THIS
QUESTION
YOU
SHOULD
ONLY
CHANGE
PLAYER
A
PAYOFF
FOR
THIS
ONE
PAIR
OF
STRATEGIES
U
L
IN
PARTICULAR
LEAVE
THE
REST
OF
THE
STRUCTURE
OF
THE
GAME
UNCHANGED
THE
PLAYERS
THEIR
STRATEGIES
THE
PAYOFF
FROM
STRATEGIES
OTHER
THAN
U
L
AND
B
PAYOFF
FROM
U
L
C
NOW
LET
GO
BACK
TO
THE
ORIGINAL
PAYOFF
MATRIX
FROM
PART
A
AND
ASK
AN
ANALOGOUS
QUESTION
ABOUT
PLAYER
B
SO
WE
RE
BACK
TO
THE
PAYOFF
MATRIX
IN
WHICH
PLAYERS
A
AND
B
EACH
GET
A
PAYOFF
OF
FROM
THE
PAIR
OF
STRATEGIES
U
L
CAN
YOU
CHANGE
PLAYER
B
PAYOFF
FROM
THE
PAIR
OF
STRATEGIES
U
L
TO
SOME
NON
NEGATIVE
NUMBER
IN
SUCH
A
WAY
THAT
THE
RESULTING
GAME
HAS
NO
PURE
STRATEGY
NASH
EQUILIBRIUM
GIVE
A
BRIEF
SENTENCE
EXPLANATION
FOR
YOUR
ANSWER
AGAIN
IN
ANSWERING
THIS
QUESTION
YOU
SHOULD
ONLY
CHANGE
PLAYER
B
PAYOFF
FOR
THIS
ONE
PAIR
OF
STRATEGIES
U
L
IN
PARTICULAR
LEAVE
THE
REST
OF
THE
STRUCTURE
OF
THE
GAME
UNCHANGED
THE
PLAYERS
THEIR
STRATEGIES
THE
PAYOFF
FROM
STRATEGIES
OTHER
THAN
U
L
AND
A
PAYOFF
FROM
U
L
IN
THE
TEXT
WE
VE
DISCUSSED
DOMINANT
STRATEGIES
AND
NOTED
THAT
IF
A
PLAYER
HAS
A
DOMI
NANT
STRATEGY
WE
WOULD
EXPECT
IT
TO
BE
USED
THE
OPPOSITE
OF
A
DOMINANT
STRATEGY
IS
A
STRATEGY
THAT
IS
DOMINATED
THE
DEFINITION
OF
DOMINATED
IS
A
STRATEGY
I
IS
DOMINATED
IF
PLAYER
I
HAS
ANOTHER
STRATEGY
STI
WITH
THE
PROPERTY
THAT
PLAYER
I
PAYOFF
IS
GREATER
FROM
STI
THAN
FROM
I
NO
MATTER
WHAT
THE
OTHER
PLAYERS
IN
THE
GAME
DO
WE
DO
NOT
EXPECT
A
PLAYER
TO
USE
A
STRATEGY
THAT
IS
DOMINATED
AND
THIS
CAN
HELP
IN
FINDING
NASH
EQUILIBRIA
HERE
IS
AN
EXAMPLE
OF
THIS
IDEA
IN
THIS
GAME
M
IS
A
DOMINATED
STRATEGY
IT
IS
DOMINATED
BY
R
AND
PLAYER
B
WILL
NOT
USE
IT
PLAYER
A
U
D
PLAYER
B
L
M
R
SO
IN
ANALYZING
THE
GAME
WE
CAN
DELETE
M
AND
LOOK
AT
THE
REMAINING
GAME
PLAYER
A
U
D
PLAYER
B
L
R
NOW
PLAYER
A
HAS
A
DOMINANT
STRATEGY
U
AND
IT
IS
EASY
TO
SEE
THAT
THE
NASH
EQUILIB
RIUM
OF
THE
BY
GAME
IS
U
L
YOU
CAN
CHECK
THE
ORIGINAL
GAME
TO
SEE
THAT
U
L
IS
A
NASH
EQUILIBRIUM
OF
COURSE
USING
THIS
PROCEDURE
REQUIRES
THAT
WE
KNOW
THAT
A
DOMINATED
STRATEGY
CANNOT
BE
USED
IN
NASH
EQUILIBRIUM
CONSIDER
ANY
TWO
PLAYER
GAME
WHICH
HAS
AT
LEAST
ONE
PURE
STRATEGY
NASH
EQUILIBRIUM
EXPLAIN
WHY
THE
STRATEGIES
USED
IN
AN
EQUILIBRIUM
OF
THIS
GAME
WILL
NOT
BE
DOMINATED
STRATEGIES
IN
CHAPTER
WE
DISCUSSED
DOMINANT
STRATEGIES
AND
NOTED
THAT
IF
A
PLAYER
HAS
A
DOMINANT
STRATEGY
WE
WOULD
EXPECT
IT
TO
BE
USED
THE
OPPOSITE
OF
A
DOMINANT
STRATEGY
IS
A
STRATEGY
THAT
IS
DOMINATED
THERE
ARE
SEVERAL
POSSIBLE
NOTIONS
OF
WHAT
IT
MEANS
FOR
A
STRATEGY
TO
BE
DOMINATED
IN
THIS
PROBLEM
WE
WILL
FOCUS
ON
WEAK
DOMINATION
A
STRATEGY
I
IS
WEAKLY
DOMINATED
IF
PLAYER
I
HAS
ANOTHER
STRATEGY
STI
WITH
THE
PROPERTY
THAT
IS
ACTUALLY
TRUE
FOR
ANY
NUMBER
OF
PLAYERS
IT
WOULD
ALSO
HELP
TO
KNOW
THAT
IF
WE
ITERATIVELY
REMOVE
DOMINATED
STRATEGIES
IN
ANY
ORDER
AND
ANALYZE
THE
REDUCED
GAMES
WE
STILL
FIND
THE
NASH
EQUILIBRIA
OF
THE
ORIGINAL
GAME
THIS
IS
ALSO
TRUE
BUT
IT
IS
A
BIT
MORE
COMPLICATED
A
NO
MATTER
WHAT
THE
OTHER
PLAYER
DOES
PLAYER
I
PAYOFF
FROM
STI
IS
AT
LEAST
AS
LARGE
AS
THE
PAYOFF
FROM
I
AND
B
THERE
IS
SOME
STRATEGY
FOR
THE
OTHER
PLAYER
SO
THAT
PLAYER
I
PAYOFF
FROM
STI
IS
STRICTLY
GREATER
THAN
THE
PAYOFF
FROM
I
A
IT
SEEMS
UNLIKELY
THAT
A
PLAYER
WOULD
USE
A
WEAKLY
DOMINATED
STRATEGY
BUT
THESE
STRATEGIES
CAN
OCCUR
IN
A
NASH
EQUILIBRIUM
FIND
ALL
PURE
NON
RANDOMIZED
NASH
EQUILIBRIA
FOR
THE
GAME
BELOW
DO
ANY
OF
THEM
USE
WEAKLY
DOMINATED
STRATEGIES
PLAYER
A
U
D
PLAYER
B
L
R
B
ONE
WAY
TO
REASON
ABOUT
THE
WEAKLY
DOMINATED
STRATEGIES
THAT
YOU
SHOULD
HAVE
FOUND
IN
ANSWERING
THE
QUESTION
ABOVE
IS
TO
CONSIDER
THE
FOLLOWING
SEQUENTIAL
GAME
SUPPOSE
THAT
THE
PLAYERS
ACTUALLY
MOVE
SEQUENTIALLY
BUT
THE
PLAYER
TO
MOVE
SECOND
DOES
NOT
KNOW
WHAT
THE
PLAYER
MOVING
FIRST
CHOSE
PLAYER
A
MOVES
FIRST
AND
IF
HE
CHOOSES
U
THEN
PLAYER
B
CHOICE
DOES
NOT
MATTER
EFFECTIVELY
THE
GAME
IS
OVER
IF
A
CHOOSES
U
AS
NO
MATTER
WHAT
B
DOES
THE
PAYOFF
IS
IF
PLAYER
A
CHOOSES
D
THEN
PLAYER
B
MOVE
MATTERS
AND
THE
PAYOFF
IS
IF
B
CHOOSES
L
OR
IF
B
CHOOSES
R
NOTE
THAT
AS
B
DOES
NOT
OBSERVE
A
MOVE
THE
SIMULTANEOUS
MOVE
GAME
WITH
PAYOFF
MATRIX
ABOVE
IS
EQUIVALENT
TO
THIS
SEQUENTIAL
MOVE
GAME
IN
THIS
GAME
HOW
WOULD
YOU
EXPECT
THE
PLAYERS
TO
BEHAVE
EXPLAIN
YOUR
REASONING
THE
PLAYERS
ARE
NOT
ALLOWED
TO
CHANGE
THE
GAME
THEY
PLAY
IT
ONCE
JUST
AS
IT
IS
GIVEN
ABOVE
YOU
MAY
REASON
FROM
THE
PAYOFF
MATRIX
OR
THE
STORY
BEHIND
THE
GAME
BUT
IF
YOU
USE
THE
STORY
REMEMBER
THAT
B
DOES
NOT
OBSERVE
A
MOVE
UNTIL
AFTER
THE
GAME
IS
OVER
HERE
WE
CONSIDER
A
GAME
WITH
THREE
PLAYERS
NAMED
AND
TO
DEFINE
THE
GAME
WE
NEED
TO
SPECIFY
THE
SETS
OF
STRATEGIES
AVAILABLE
TO
EACH
PLAYER
ALSO
WHEN
EACH
OF
THE
THREE
PLAYERS
CHOOSES
A
STRATEGY
THIS
GIVES
A
TRIPLE
OF
STRATEGIES
AND
WE
NEED
TO
SPECIFY
THE
PAYOFF
EACH
PLAYER
RECEIVES
FROM
ANY
POSSIBLE
TRIPLE
OF
STRATEGIES
PLAYED
LET
SUPPOSE
THAT
PLAYER
STRATEGY
SET
IS
U
D
PLAYERS
STRATEGY
SET
IS
L
R
AND
PLAYER
STRATEGY
SET
IS
L
R
ONE
WAY
TO
SPECIFY
THE
PAYOFFS
WOULD
BE
TO
WRITE
DOWN
EVERY
POSSIBLE
TRIPLE
OF
STRATEGIES
AND
THE
PAYOFFS
FOR
EACH
A
DIFFERENT
BUT
EQUIVALENT
WAY
TO
INTERPRET
TRIPLES
OF
STRATEGIES
WHICH
MAKES
IT
EASIER
TO
SPECIFY
THE
PAYOFFS
IS
TO
IMAGINE
THAT
PLAYER
CHOOSES
WHICH
OF
TWO
DISTINCT
TWO
PLAYER
GAMES
PLAYERS
AND
WILL
PLAY
IF
CHOOSES
L
THEN
THE
PAYOFF
MATRIX
IS
PAYOFF
MATRIX
L
PLAYER
A
U
D
PLAYER
B
L
R
WHERE
THE
FIRST
ENTRY
IN
EACH
CELL
IS
THE
PAYOFF
TO
PLAYER
THE
SECOND
ENTRY
IS
THE
PAYOFF
TO
PLAYER
AND
THE
THIRD
ENTRY
IS
THE
PAYOFF
TO
PLAYER
IF
CHOOSES
R
THEN
THE
PAYOFF
MATRIX
IS
PAYOFF
MATRIX
R
PLAYER
A
U
D
PLAYER
B
L
R
SO
FOR
EXAMPLE
IF
PLAYER
CHOOSES
U
PLAYER
CHOOSES
R
AND
PLAYER
CHOOSES
R
THE
PAYOFFS
ARE
FOR
EACH
PLAYER
A
FIRST
SUPPOSE
THE
PLAYERS
ALL
MOVE
SIMULTANEOUSLY
THAT
IS
PLAYERS
AND
DO
NOT
OBSERVE
WHICH
GAME
PLAYER
HAS
SELECTED
UNTIL
AFTER
THEY
EACH
CHOSE
A
STRATEGY
FIND
ALL
OF
THE
PURE
STRATEGY
NASH
EQUILIBRIA
FOR
THIS
GAME
B
NOW
SUPPOSE
THAT
PLAYER
GETS
TO
MOVE
FIRST
AND
THAT
PLAYERS
AND
OBSERVE
PLAYER
MOVE
BEFORE
THEY
DECIDE
HOW
TO
PLAY
THAT
IS
IF
PLAYER
CHOOSES
THE
STRATEGY
R
THEN
PLAYERS
AND
PLAY
THE
GAME
DEFINED
BY
PAYOFF
MATRIX
R
AND
THEY
BOTH
KNOW
THAT
THEY
ARE
PLAYING
THIS
GAME
SIMILARLY
IF
PLAYER
CHOOSES
THE
STRATEGY
L
THEN
PLAYERS
AND
PLAY
THE
GAME
DEFINED
BY
PAYOFF
MATRIX
L
AND
THEY
BOTH
KNOW
THAT
THEY
ARE
PLAYING
THIS
GAME
LET
ALSO
SUPPOSE
THAT
IF
PLAYERS
AND
PLAY
THE
GAME
DEFINED
BY
PAYOFF
MATRIX
R
THEY
PLAY
A
PURE
STRATEGY
NASH
EQUILIBRIUM
FOR
THAT
GAME
AND
SIMILARLY
IF
PLAYERS
AND
PLAY
THE
GAME
DEFINED
BY
PAYOFF
MATRIX
L
THEY
PLAY
A
PURE
STRATEGY
NASH
EQUILIBRIUM
FOR
THAT
GAME
FINALLY
LET
SUPPOSE
THAT
PLAYER
UNDERSTANDS
THAT
THIS
IS
HOW
PLAYERS
AND
WILL
BEHAVE
WHAT
DO
YOU
EXPECT
PLAYER
TO
DO
AND
WHY
WHAT
TRIPLE
OF
STRATEGIES
WOULD
YOU
EXPECT
TO
SEE
PLAYED
IS
THIS
LIST
OF
STRATEGIES
A
NASH
EQUILIBRIUM
OF
THE
SIMULTANEOUS
MOVE
GAME
BETWEEN
THE
THREE
PLAYERS
CONSIDER
THE
TWO
PLAYER
GAME
WITH
PLAYERS
STRATEGIES
AND
PAYOFFS
DESCRIBED
IN
THE
FOLLOWING
GAME
MATRIX
PLAYER
U
D
PLAYER
L
R
A
FIND
ALL
OF
THE
NASH
EQUILIBRIA
OF
THIS
GAME
B
IN
THE
MIXED
STRATEGY
EQUILIBRIUM
YOU
FOUND
IN
PART
A
YOU
SHOULD
NOTICE
THAT
PLAYER
PLAYS
STRATEGY
U
MORE
OFTEN
THAN
STRATEGY
D
ONE
OF
YOUR
FRIENDS
REMARKS
THAT
YOUR
ANSWER
TO
PART
A
MUST
BE
WRONG
BECAUSE
CLEARLY
FOR
PLAYER
STRATEGY
D
IS
A
MORE
ATTRACTIVE
STRATEGY
THAN
STRATEGY
U
BOTH
U
AND
D
GIVE
PLAYER
A
PAYOFF
OF
ON
THE
OFF
DIAGONAL
ELEMENTS
OF
THE
PAYOFF
MATRIX
BUT
D
GIVES
PLAYER
A
PAYOFF
OF
ON
THE
DIAGONAL
WHILE
U
ONLY
GIVES
PLAYER
A
PAYOFF
OF
ON
THE
DIAGONAL
EXPLAIN
WHAT
IS
WRONG
WITH
THIS
REASONING
TWO
IDENTICAL
FIRMS
LET
CALL
THEM
FIRM
AND
FIRM
MUST
DECIDE
SIMULTANEOUSLY
AND
INDEPENDENTLY
WHETHER
TO
ENTER
A
NEW
MARKET
AND
WHAT
PRODUCT
TO
PRODUCE
IF
THEY
DO
ENTER
THE
MARKET
EACH
FIRM
IF
IT
ENTERS
CAN
DEVELOP
AND
PRODUCE
EITHER
PRODUCT
A
OR
PRODUCT
B
IF
BOTH
FIRMS
ENTER
AND
PRODUCE
PRODUCT
A
THEY
EACH
LOSE
TEN
MILLION
DOLLARS
IF
BOTH
FIRMS
ENTER
AND
BOTH
PRODUCE
PRODUCT
B
THEY
EACH
MAKE
A
PROFIT
OF
FIVE
MILLION
DOLLARS
IF
BOTH
ENTER
AND
ONE
PRODUCES
A
WHILE
THE
OTHER
PRODUCES
B
THEN
THEY
EACH
MAKE
A
PROFIT
OF
TEN
MILLION
DOLLARS
ANY
FIRM
THAT
DOES
NOT
ENTER
MAKES
A
PROFIT
OF
ZERO
FINALLY
IF
ONE
FIRM
DOES
NOT
ENTER
AND
THE
OTHER
FIRM
PRODUCES
A
IT
MAKES
A
PROFIT
OF
FIFTEEN
MILLION
DOLLARS
WHILE
IF
THE
SINGLE
ENTERING
FIRM
PRODUCES
B
IT
MAKES
A
PROFIT
OF
THIRTY
MILLION
DOLLARS
YOU
ARE
THE
MANAGER
OF
FIRM
AND
YOU
HAVE
TO
CHOOSE
A
STRATEGY
FOR
YOUR
FIRM
A
SET
THIS
SITUATION
UP
AS
A
GAME
WITH
TWO
PLAYERS
FIRMS
AND
AND
THREE
STRATEGIES
FOR
EACH
FIRM
PRODUCE
A
PRODUCE
B
OR
DO
NOT
ENTER
B
ONE
OF
YOUR
EMPLOYEES
ARGUES
THAT
YOU
SHOULD
ENTER
THE
MARKET
ALTHOUGH
HE
IS
NOT
SURE
WHAT
PRODUCT
YOU
SHOULD
PRODUCE
BECAUSE
NO
MATTER
WHAT
FIRM
DOES
ENTERING
AND
PRODUCING
PRODUCT
B
IS
BETTER
THAN
NOT
ENTERING
EVALUATE
THIS
ARGUMENT
C
ANOTHER
EMPLOYEE
AGREES
WITH
THE
PERSON
IN
PART
B
AND
ARGUES
THAT
AS
STRATEGY
A
COULD
RESULT
IN
A
LOSS
IF
THE
OTHER
FIRM
ALSO
PRODUCES
A
YOU
SHOULD
ENTER
AND
PRODUCE
B
IF
BOTH
FIRMS
REASON
THIS
WAY
AND
THUS
ENTER
AND
PRODUCE
PRODUCT
B
WILL
THEIR
PLAY
OF
THE
GAME
FORM
A
NASH
EQUILIBRIUM
EXPLAIN
D
FIND
ALL
THE
PURE
STRATEGY
NASH
EQUILIBRIA
OF
THIS
GAME
E
ANOTHER
EMPLOYEE
OF
YOUR
FIRM
SUGGESTS
MERGING
THE
TWO
FIRMS
AND
DECIDING
CO
OPERATIVELY
ON
STRATEGIES
SO
AS
TO
MAXIMIZE
THE
SUM
OF
PROFITS
IGNORING
WHETHER
THIS
MERGER
WOULD
BE
ALLOWED
BY
THE
REGULATORS
DO
YOU
THINK
ITS
A
GOOD
IDEA
EXPLAIN
CHAPTER
EVOLUTIONARY
GAME
THEORY
IN
CHAPTER
WE
DEVELOPED
THE
BASIC
IDEAS
OF
GAME
THEORY
IN
WHICH
INDIVIDUAL
PLAYERS
MAKE
DECISIONS
AND
THE
PAYOFF
TO
EACH
PLAYER
DEPENDS
ON
THE
DECISIONS
MADE
BY
ALL
AS
WE
SAW
THERE
A
KEY
QUESTION
IN
GAME
THEORY
IS
TO
REASON
ABOUT
THE
BEHAVIOR
WE
SHOULD
EXPECT
TO
SEE
WHEN
PLAYERS
TAKE
PART
IN
A
GIVEN
GAME
THE
DISCUSSION
IN
CHAPTER
WAS
BASED
ON
CONSIDERING
HOW
PLAYERS
SIMULTANEOUSLY
REASON
ABOUT
WHAT
THE
OTHER
PLAYERS
MAY
DO
IN
THIS
CHAPTER
ON
THE
OTHER
HAND
WE
EXPLORE
THE
NOTION
OF
EVOLUTIONARY
GAME
THEORY
WHICH
SHOWS
THAT
THE
BASIC
IDEAS
OF
GAME
THEORY
CAN
BE
APPLIED
EVEN
TO
SITUATIONS
IN
WHICH
NO
INDIVIDUAL
IS
OVERTLY
REASONING
OR
EVEN
MAKING
EXPLICIT
DECISIONS
RATHER
GAME
THEORETIC
ANALYSIS
WILL
BE
APPLIED
TO
SETTINGS
IN
WHICH
INDIVIDUALS
CAN
EXHIBIT
DIFFERENT
FORMS
OF
BEHAVIOR
INCLUDING
THOSE
THAT
MAY
NOT
BE
THE
RESULT
OF
CONSCIOUS
CHOICES
AND
WE
WILL
CONSIDER
WHICH
FORMS
OF
BEHAVIOR
HAVE
THE
ABILITY
TO
PERSIST
IN
THE
POPULATION
AND
WHICH
FORMS
OF
BEHAVIOR
HAVE
A
TENDENCY
TO
BE
DRIVEN
OUT
BY
OTHERS
AS
ITS
NAME
SUGGESTS
THIS
APPROACH
HAS
BEEN
APPLIED
MOST
WIDELY
IN
THE
AREA
OF
EVOLU
TIONARY
BIOLOGY
THE
DOMAIN
IN
WHICH
THE
IDEA
WAS
FIRST
ARTICULATED
BY
JOHN
MAYNARD
SMITH
AND
G
R
PRICE
EVOLUTIONARY
BIOLOGY
IS
BASED
ON
THE
IDEA
THAT
AN
ORGANISM
GENES
LARGELY
DETERMINE
ITS
OBSERVABLE
CHARACTERISTICS
AND
HENCE
ITS
FITNESS
IN
A
GIVEN
ENVI
RONMENT
ORGANISMS
THAT
ARE
MORE
FIT
WILL
TEND
TO
PRODUCE
MORE
OFFSPRING
CAUSING
GENES
THAT
PROVIDE
GREATER
FITNESS
TO
INCREASE
THEIR
REPRESENTATION
IN
THE
POPULATION
IN
THIS
WAY
FITTER
GENES
TEND
TO
WIN
OVER
TIME
BECAUSE
THEY
PROVIDE
HIGHER
RATES
OF
REPRODUCTION
THE
KEY
INSIGHT
OF
EVOLUTIONARY
GAME
THEORY
IS
THAT
MANY
BEHAVIORS
INVOLVE
THE
INTERACTION
OF
MULTIPLE
ORGANISMS
IN
A
POPULATION
AND
THE
SUCCESS
OF
ANY
ONE
OF
THESE
ORGANISMS
DEPENDS
ON
HOW
ITS
BEHAVIOR
INTERACTS
WITH
THAT
OF
OTHERS
SO
THE
FITNESS
OF
AN
INDIVIDUAL
ORGANISM
CAN
T
BE
MEASURED
IN
ISOLATION
RATHER
IT
HAS
TO
BE
EVALUATED
IN
THE
CONTEXT
OF
THE
FULL
POPULATION
IN
WHICH
IT
LIVES
THIS
OPENS
THE
DOOR
TO
A
NATURAL
GAME
THEORETIC
ANALOGY
D
EASLEY
AND
J
KLEINBERG
NETWORKS
CROWDS
AND
MARKETS
REASONING
ABOUT
A
HIGHLY
CONNECTED
WORLD
CAMBRIDGE
UNIVERSITY
PRESS
DRAFT
VERSION
JUNE
AN
ORGANISM
GENETICALLY
DETERMINED
CHARACTERISTICS
AND
BEHAVIORS
ARE
LIKE
ITS
STRATEGY
IN
A
GAME
ITS
FITNESS
IS
LIKE
ITS
PAYOFF
AND
THIS
PAYOFF
DEPENDS
ON
THE
STRATEGIES
CHARACTERISTICS
OF
THE
ORGANISMS
WITH
WHICH
IT
INTERACTS
WRITTEN
THIS
WAY
IT
IS
HARD
TO
TELL
IN
ADVANCE
WHETHER
THIS
WILL
TURN
OUT
TO
BE
A
SUPERFICIAL
ANALOGY
OR
A
DEEP
ONE
BUT
IN
FACT
THE
CONNECTIONS
TURN
OUT
TO
RUN
VERY
DEEPLY
GAME
THEORETIC
IDEAS
LIKE
EQUILIBRIUM
WILL
PROVE
TO
BE
A
USEFUL
WAY
TO
MAKE
PREDICTIONS
ABOUT
THE
RESULTS
OF
EVOLUTION
ON
A
POPULATION
FITNESS
AS
A
RESULT
OF
INTERACTION
TO
MAKE
THIS
CONCRETE
WE
NOW
DESCRIBE
A
FIRST
SIMPLE
EXAMPLE
OF
HOW
GAME
THEORETIC
IDEAS
CAN
BE
APPLIED
IN
EVOLUTIONARY
SETTINGS
THIS
EXAMPLE
WILL
BE
DESIGNED
FOR
EASE
OF
EXPLANATION
RATHER
THAN
PERFECT
FIDELITY
TO
THE
UNDERLYING
BIOLOGY
BUT
AFTER
THIS
WE
WILL
DISCUSS
EXAMPLES
WHERE
THE
PHENOMENON
AT
THE
HEART
OF
THE
EXAMPLE
HAS
BEEN
EMPIRICALLY
OBSERVED
IN
A
VARIETY
OF
NATURAL
SETTINGS
FOR
THE
EXAMPLE
LET
CONSIDER
A
PARTICULAR
SPECIES
OF
BEETLE
AND
SUPPOSE
THAT
EACH
BEETLE
FITNESS
IN
A
GIVEN
ENVIRONMENT
IS
DETERMINED
LARGELY
BY
THE
EXTENT
TO
WHICH
IT
CAN
FIND
FOOD
AND
USE
THE
NUTRIENTS
FROM
THE
FOOD
EFFECTIVELY
NOW
SUPPOSE
A
PARTICULAR
MUTATION
IS
INTRODUCED
INTO
THE
POPULATION
CAUSING
BEETLES
WITH
THE
MUTATION
TO
GROW
A
SIGNIFICANTLY
LARGER
BODY
SIZE
THUS
WE
NOW
HAVE
TWO
DISTINCT
KINDS
OF
BEETLES
IN
THE
POPULATION
SMALL
ONES
AND
LARGE
ONES
IT
IS
ACTUALLY
DIFFICULT
FOR
THE
LARGE
BEETLES
TO
MAINTAIN
THE
METABOLIC
REQUIREMENTS
OF
THEIR
LARGER
BODY
SIZE
IT
REQUIRES
DIVERTING
MORE
NUTRIENTS
FROM
THE
FOOD
THEY
EAT
AND
SO
THIS
HAS
A
NEGATIVE
EFFECT
ON
FITNESS
IF
THIS
WERE
THE
FULL
STORY
WE
D
CONCLUDE
THAT
THE
LARGE
BODY
SIZE
MUTATION
IS
FITNESS
DECREASING
AND
SO
IT
WILL
LIKELY
BE
DRIVEN
OUT
OF
THE
POPULATION
OVER
TIME
THROUGH
MULTIPLE
GENERATIONS
BUT
IN
FACT
THERE
MORE
TO
THE
STORY
AS
WE
LL
NOW
SEE
INTERACTION
AMONG
ORGANISMS
THE
BEETLES
IN
THIS
POPULATION
COMPETE
WITH
EACH
OTHER
FOR
FOOD
WHEN
THEY
COME
UPON
A
FOOD
SOURCE
THERE
CROWDING
AMONG
THE
BEETLES
AS
THEY
EACH
TRY
TO
GET
AS
MUCH
OF
THE
FOOD
AS
THEY
CAN
AND
NOT
SURPRISINGLY
THE
BEETLES
WITH
LARGE
BODY
SIZES
ARE
MORE
EFFECTIVE
AT
CLAIMING
AN
ABOVE
AVERAGE
SHARE
OF
THE
FOOD
LET
ASSUME
FOR
SIMPLICITY
THAT
FOOD
COMPETITION
IN
THIS
POPULATION
INVOLVES
TWO
BEETLES
INTERACTING
WITH
EACH
OTHER
AT
ANY
GIVEN
POINT
IN
TIME
THIS
WILL
MAKE
THE
IDEAS
EASIER
TO
DESCRIBE
BUT
THE
PRINCIPLES
WE
DEVELOP
CAN
ALSO
BE
APPLIED
TO
INTERACTIONS
AMONG
MANY
INDIVIDUALS
SIMULTANEOUSLY
WHEN
TWO
BEETLES
COMPETE
FOR
SOME
FOOD
WE
HAVE
THE
FOLLOWING
POSSIBLE
OUTCOMES
WHEN
BEETLES
OF
THE
SAME
SIZE
COMPETE
THEY
GET
EQUAL
SHARES
OF
THE
FOOD
WHEN
A
LARGE
BEETLE
COMPETES
WITH
A
SMALL
BEETLE
THE
LARGE
BEETLE
GETS
THE
MAJORITY
OF
THE
FOOD
IN
ALL
CASES
LARGE
BEETLES
EXPERIENCE
LESS
OF
A
FITNESS
BENEFIT
FROM
A
GIVEN
QUANTITY
OF
FOOD
SINCE
SOME
OF
IT
IS
DIVERTED
INTO
MAINTAINING
THEIR
EXPENSIVE
METABOLISM
THUS
THE
FITNESS
THAT
EACH
BEETLE
GETS
FROM
A
GIVEN
FOOD
RELATED
INTERACTION
CAN
BE
THOUGHT
OF
AS
A
NUMERICAL
PAYOFF
IN
A
TWO
PLAYER
GAME
BETWEEN
A
FIRST
BEETLE
AND
A
SECOND
BEETLE
AS
FOLLOWS
THE
FIRST
BEETLE
PLAYS
ONE
OF
THE
TWO
STRATEGIES
SMALL
OR
LARGE
DEPENDING
ON
ITS
BODY
SIZE
AND
THE
SECOND
BEETLE
PLAYS
ONE
OF
THESE
TWO
STRATEGIES
AS
WELL
BASED
ON
THE
TWO
STRATEGIES
USED
THE
PAYOFFS
TO
THE
BEETLES
ARE
DESCRIBED
BY
FIGURE
BEETLE
SMALL
LARGE
BEETLE
SMALL
LARGE
FIGURE
THE
BODY
SIZE
GAME
NOTICE
HOW
THE
NUMERICAL
PAYOFFS
SATISFY
THE
PRINCIPLES
JUST
OUTLINED
WHEN
TWO
SMALL
BEETLES
MEET
THEY
SHARE
THE
FITNESS
FROM
THE
FOOD
SOURCE
EQUALLY
LARGE
BEETLES
DO
WELL
AT
THE
EXPENSE
OF
SMALL
BEETLES
BUT
LARGE
BEETLES
CANNOT
EXTRACT
THE
FULL
AMOUNT
OF
FITNESS
FROM
THE
FOOD
SOURCE
IN
THIS
PAYOFF
MATRIX
THE
REDUCED
FITNESS
WHEN
TWO
LARGE
BEETLES
MEET
IS
PARTICULARLY
PRONOUNCED
SINCE
A
LARGE
BEETLE
HAS
TO
EXPEND
EXTRA
ENERGY
IN
COMPETING
WITH
ANOTHER
LARGE
BEETLE
THIS
PAYOFF
MATRIX
IS
A
NICE
WAY
TO
SUMMARIZE
WHAT
HAPPENS
WHEN
TWO
BEETLES
MEET
BUT
COMPARED
WITH
THE
GAME
IN
CHAPTER
THERE
SOMETHING
FUNDAMENTALLY
DIFFERENT
IN
WHAT
BEING
DESCRIBED
HERE
THE
BEETLES
IN
THIS
GAME
AREN
T
ASKING
THEMSELVES
WHAT
DO
I
WANT
MY
BODY
SIZE
TO
BE
IN
THIS
INTERACTION
RATHER
EACH
IS
GENETICALLY
HARD
WIRED
TO
PLAY
ONE
OF
THESE
TWO
STRATEGIES
THROUGH
ITS
WHOLE
LIFETIME
GIVEN
THIS
IMPORTANT
DIFFERENCE
THE
IDEA
OF
CHOOSING
STRATEGIES
WHICH
WAS
CENTRAL
TO
OUR
FORMULATION
OF
GAME
THEORY
IS
MISSING
FROM
THE
BIOLOGICAL
SIDE
OF
THE
ANALOGY
AS
A
RESULT
IN
PLACE
OF
THE
IDEA
OF
NASH
EQUILIBRIUM
WHICH
WAS
BASED
FUNDAMENTALLY
ON
THE
RELATIVE
BENEFIT
OF
CHANGING
ONE
OWN
PERSONAL
STRATEGY
WE
WILL
NEED
TO
THINK
ABOUT
STRATEGY
CHANGES
THAT
OPERATE
OVER
LONGER
TIME
SCALES
TAKING
PLACE
AS
SHIFTS
IN
A
POPULATION
UNDER
EVOLUTIONARY
FORCES
WE
DEVELOP
THE
FUNDAMENTAL
DEFINITIONS
FOR
THIS
IN
THE
NEXT
SECTION
EVOLUTIONARILY
STABLE
STRATEGIES
IN
CHAPTER
THE
NOTION
OF
NASH
EQUILIBRIUM
WAS
CENTRAL
IN
REASONING
ABOUT
THE
OUTCOME
OF
A
GAME
IN
A
NASH
EQUILIBRIUM
FOR
A
TWO
PLAYER
GAME
NEITHER
PLAYER
HAS
AN
INCENTIVE
TO
DEVIATE
FROM
THE
STRATEGY
THEY
ARE
CURRENTLY
USING
THE
EQUILIBRIUM
IS
A
CHOICE
OF
STRATEGIES
THAT
TENDS
TO
PERSIST
ONCE
THE
PLAYERS
ARE
USING
IT
THE
ANALOGOUS
NOTION
FOR
EVOLUTIONARY
SETTINGS
WILL
BE
THAT
OF
AN
EVOLUTIONARILY
STABLE
STRATEGY
A
GENETICALLY
DETERMINED
STRATEGY
THAT
TENDS
TO
PERSIST
ONCE
IT
IS
PREVALENT
IN
A
POPULATION
WE
FORMULATE
THIS
AS
FOLLOWS
SUPPOSE
IN
OUR
EXAMPLE
THAT
EACH
BEETLES
IS
REPEATEDLY
PAIRED
OFF
WITH
OTHER
BEETLES
IN
FOOD
COMPETITIONS
OVER
THE
COURSE
OF
ITS
LIFETIME
WE
WILL
ASSUME
THE
POPULATION
IS
LARGE
ENOUGH
THAT
NO
TWO
PARTICULAR
BEETLES
HAVE
A
SIGNIFICANT
PROBABILITY
OF
INTERACTING
WITH
EACH
OTHER
REPEATEDLY
A
BEETLE
OVERALL
FITNESS
WILL
BE
EQUAL
TO
THE
AVERAGE
FITNESS
IT
EXPERIENCES
FROM
EACH
OF
ITS
MANY
PAIRWISE
INTERACTIONS
WITH
OTHERS
AND
THIS
OVERALL
FITNESS
DETERMINES
ITS
REPRODUCTIVE
SUCCESS
THE
NUMBER
OF
OFFSPRING
THAT
CARRY
ITS
GENES
AND
HENCE
ITS
STRATEGY
INTO
THE
NEXT
GENERATION
IN
THIS
SETTING
WE
SAY
THAT
A
GIVEN
STRATEGY
IS
EVOLUTIONARILY
STABLE
IF
WHEN
THE
WHOLE
POPULATION
IS
USING
THIS
STRATEGY
ANY
SMALL
GROUP
OF
INVADERS
USING
A
DIFFERENT
STRATEGY
WILL
EVENTUALLY
DIE
OFF
OVER
MULTIPLE
GENERATIONS
WE
CAN
THINK
OF
THESE
INVADERS
EITHER
AS
MIGRANTS
WHO
MOVE
TO
JOIN
THE
POPULATION
OR
AS
MUTANTS
WHO
WERE
BORN
WITH
THE
NEW
BEHAVIOR
DIRECTLY
INTO
THE
POPULATION
WE
CAPTURE
THIS
IDEA
IN
TERMS
OF
NUMERICAL
PAYOFFS
BY
SAYING
THAT
WHEN
THE
WHOLE
POPULATION
IS
USING
A
STRATEGY
THEN
A
SMALL
GROUP
OF
INVADERS
USING
ANY
ALTERNATE
STRATEGY
T
SHOULD
HAVE
STRICTLY
LOWER
FITNESS
THAN
THE
USERS
OF
THE
MAJORITY
STRATEGY
SINCE
FITNESS
TRANSLATES
INTO
REPRODUCTIVE
SUCCESS
EVOLUTIONARY
PRINCIPLES
POSIT
THAT
STRICTLY
LOWER
FITNESS
IS
THE
CONDITION
THAT
CAUSES
A
SUB
POPULATION
LIKE
THE
USERS
OF
STRATEGY
T
TO
SHRINK
OVER
TIME
THROUGH
MULTIPLE
GENERATIONS
AND
EVENTUALLY
DIE
OFF
WITH
HIGH
PROBABILITY
MORE
FORMALLY
WE
WILL
PHRASE
THE
BASIC
DEFINITIONS
AS
FOLLOWS
WE
SAY
THE
FITNESS
OF
AN
ORGANISM
IN
A
POPULATION
IS
THE
EXPECTED
PAYOFF
IT
RECEIVES
FROM
AN
INTERACTION
WITH
A
RANDOM
MEMBER
OF
THE
POPULATION
WE
SAY
THAT
A
STRATEGY
T
INVADES
A
STRATEGY
AT
LEVEL
X
FOR
SOME
SMALL
POSITIVE
NUMBER
X
IF
AN
X
FRACTION
OF
THE
UNDERLYING
POPULATION
USES
T
AND
A
X
FRACTION
OF
THE
UNDERLYING
POPULATION
USES
FINALLY
WE
SAY
THAT
A
STRATEGY
IS
EVOLUTIONARILY
STABLE
IF
THERE
IS
A
SMALL
POSITIVE
NUMBER
Y
SUCH
THAT
WHEN
ANY
OTHER
STRATEGY
T
INVADES
AT
ANY
LEVEL
X
Y
THE
FITNESS
OF
AN
ORGANISM
PLAYING
IS
STRICTLY
GREATER
THAN
THE
FITNESS
OF
AN
ORGANISM
PLAYING
T
EVOLUTIONARILY
STABLE
STRATEGIES
IN
OUR
FIRST
EXAMPLE
LET
SEE
WHAT
HAPPENS
WHEN
WE
APPLY
THIS
DEFINITION
TO
OUR
EXAMPLE
INVOLVING
BEETLES
COMPETING
FOR
FOOD
WE
WILL
FIRST
CHECK
WHETHER
THE
STRATEGY
SMALL
IS
EVOLUTIONARILY
STABLE
AND
THEN
WE
WILL
DO
THE
SAME
FOR
THE
STRATEGY
LARGE
FOLLOWING
THE
DEFINITION
LET
SUPPOSE
THAT
FOR
SOME
SMALL
POSITIVE
NUMBER
X
A
X
FRACTION
OF
THE
POPULATION
USES
SMALL
AND
AN
X
FRACTION
OF
THE
POPULATION
USES
LARGE
THIS
IS
WHAT
THE
PICTURE
WOULD
LOOK
LIKE
JUST
AFTER
A
SMALL
INVADER
POPULATION
OF
LARGE
BEETLES
ARRIVES
WHAT
IS
THE
EXPECTED
PAYOFF
TO
A
SMALL
BEETLE
IN
A
RANDOM
INTERACTION
IN
THIS
POPULA
TION
WITH
PROBABILITY
X
IT
MEETS
ANOTHER
SMALL
BEETLE
RECEIVING
A
PAYOFF
OF
WHILE
WITH
PROBABILITY
X
IT
MEETS
A
LARGE
BEETLE
RECEIVING
A
PAYOFF
OF
THEREFORE
ITS
EXPECTED
PAYOFF
IS
X
X
WHAT
IS
THE
EXPECTED
PAYOFF
TO
A
LARGE
BEETLE
IN
A
RANDOM
INTERACTION
IN
THIS
POPULATION
WITH
PROBABILITY
X
IT
MEETS
A
SMALL
BEETLE
RECEIVING
A
PAYOFF
OF
WHILE
WITH
PROBABILITY
X
IT
MEETS
ANOTHER
LARGE
BEETLE
RECEIVING
A
PAYOFF
OF
THEREFORE
ITS
EXPECTED
PAYOFF
IS
X
X
IT
EASY
TO
CHECK
THAT
FOR
SMALL
ENOUGH
VALUES
OF
X
AND
EVEN
FOR
REASONABLY
LARGE
ONES
IN
THIS
CASE
THE
EXPECTED
FITNESS
OF
LARGE
BEETLES
IN
THIS
POPULATION
EXCEEDS
THE
EXPECTED
FITNESS
OF
SMALL
BEETLES
THEREFORE
SMALL
IS
NOT
EVOLUTIONARILY
STABLE
NOW
LET
CHECK
WHETHER
LARGE
IS
EVOLUTIONARILY
STABLE
FOR
THIS
WE
SUPPOSE
THAT
FOR
SOME
VERY
SMALL
POSITIVE
NUMBER
X
A
X
FRACTION
OF
THE
POPULATION
USES
LARGE
AND
AN
X
FRACTION
OF
THE
POPULATION
USES
SMALL
WHAT
IS
THE
EXPECTED
PAYOFF
TO
A
LARGE
BEETLE
IN
A
RANDOM
INTERACTION
IN
THIS
POPULATION
WITH
PROBABILITY
X
IT
MEETS
ANOTHER
LARGE
BEETLE
RECEIVING
A
PAYOFF
OF
WHILE
WITH
PROBABILITY
X
IT
MEETS
A
SMALL
BEETLE
RECEIVING
A
PAYOFF
OF
THEREFORE
ITS
EXPECTED
PAYOFF
IS
X
X
WHAT
IS
THE
EXPECTED
PAYOFF
TO
A
SMALL
BEETLE
IN
A
RANDOM
INTERACTION
IN
THIS
POPU
LATION
WITH
PROBABILITY
X
IT
MEETS
A
LARGE
BEETLE
RECEIVING
A
PAYOFF
OF
WHILE
WITH
PROBABILITY
X
IT
MEETS
ANOTHER
SMALL
BEETLE
RECEIVING
A
PAYOFF
OF
THEREFORE
ITS
EXPECTED
PAYOFF
IS
X
X
IN
THIS
CASE
THE
EXPECTED
FITNESS
OF
LARGE
BEETLES
IN
THIS
POPULATION
EXCEEDS
THE
EXPECTED
FITNESS
OF
SMALL
BEETLES
AND
SO
LARGE
IS
EVOLUTIONARILY
STABLE
INTERPRETING
THE
EVOLUTIONARILY
STABLE
STRATEGY
IN
OUR
EXAMPLE
INTUITIVELY
THIS
ANALYSIS
CAN
BE
SUMMARIZED
BY
SAYING
THAT
IF
A
FEW
LARGE
BEETLES
ARE
INTRODUCED
INTO
A
POPULATION
CONSISTING
OF
SMALL
BEETLES
THEN
THE
LARGE
BEETLES
DO
EXTREMELY
WELL
SINCE
THEY
RARELY
MEET
EACH
OTHER
THEY
GET
MOST
OF
THE
FOOD
IN
ALMOST
EVERY
COMPETITION
THEY
EXPERIENCE
AS
A
RESULT
THE
POPULATION
OF
SMALL
BEETLES
CANNOT
DRIVE
OUT
THE
LARGE
ONES
AND
SO
SMALL
IS
NOT
EVOLUTIONARILY
STABLE
ON
THE
OTHER
HAND
IN
A
POPULATION
OF
LARGE
BEETLES
A
FEW
SMALL
BEETLES
WILL
DO
VERY
BADLY
LOSING
ALMOST
EVERY
COMPETITION
FOR
FOOD
AS
A
RESULT
THE
POPULATION
OF
LARGE
BEETLES
RESISTS
THE
INVASION
OF
SMALL
BEETLES
AND
SO
LARGE
IS
EVOLUTIONARILY
STABLE
THEREFORE
IF
WE
KNOW
THAT
THE
LARGE
BODY
SIZE
MUTATION
IS
POSSIBLE
WE
SHOULD
EXPECT
TO
SEE
POPULATIONS
OF
LARGE
BEETLES
IN
THE
WILD
RATHER
THAN
POPULATIONS
OF
SMALL
ONES
IN
THIS
WAY
OUR
NOTION
OF
EVOLUTIONARY
STABILITY
HAS
PREDICTED
A
STRATEGY
FOR
THE
POPULATION
AS
WE
PREDICTED
OUTCOMES
FOR
GAMES
AMONG
RATIONAL
PLAYERS
IN
CHAPTER
BUT
BY
DIFFERENT
MEANS
WHAT
STRIKING
ABOUT
THIS
PARTICULAR
PREDICTED
OUTCOME
THOUGH
IS
THE
FACT
THAT
THE
FITNESS
OF
EACH
ORGANISM
IN
A
POPULATION
OF
SMALL
BEETLES
IS
WHICH
IS
LARGER
THAN
THE
FITNESS
OF
EACH
ORGANISM
IN
A
POPULATION
OF
LARGE
BEETLES
IN
FACT
THE
GAME
BETWEEN
SMALL
AND
LARGE
BEETLES
HAS
PRECISELY
THE
STRUCTURE
OF
A
PRISONER
DILEMMA
GAME
THE
MOTIVATING
SCENARIO
BASED
ON
COMPETITION
FOR
FOOD
MAKES
IT
CLEAR
THAT
THE
BEETLES
ARE
ENGAGED
IN
AN
ARMS
RACE
LIKE
THE
GAME
FROM
CHAPTER
IN
WHICH
TWO
COMPETING
ATHLETES
NEED
TO
DECIDE
WHETHER
TO
USE
PERFORMANCE
ENHANCING
DRUGS
THERE
IT
WAS
A
DOMINANT
STRATEGY
TO
USE
DRUGS
EVEN
THOUGH
BOTH
ATHLETES
UNDERSTAND
THAT
THEY
ARE
BETTER
OFF
IN
AN
OUTCOME
WHERE
NEITHER
OF
THEM
USES
DRUGS
IT
SIMPLY
THAT
THIS
MUTUALLY
BETTER
JOINT
OUTCOME
IS
NOT
SUSTAINABLE
IN
THE
PRESENT
CASE
THE
BEETLES
INDIVIDUALLY
DON
T
UNDERSTAND
ANYTHING
NOR
COULD
THEY
CHANGE
THEIR
BODY
SIZES
EVEN
IF
THEY
WANTED
TO
NEVERTHELESS
EVOLUTIONARY
FORCES
OVER
MULTIPLE
GENERATIONS
ARE
ACHIEVING
A
COMPLETELY
ANALOGOUS
EFFECT
AS
THE
LARGE
BEETLES
BENEFIT
AT
THE
EXPENSE
OF
THE
SMALL
ONES
LATER
IN
THIS
CHAPTER
WE
WILL
SEE
THAT
THIS
SIMILARITY
IN
THE
CONCLUSIONS
OF
TWO
DIFFERENT
STYLES
OF
ANALYSIS
IS
IN
FACT
PART
OF
A
BROADER
PRINCIPLE
HERE
IS
A
DIFFERENT
WAY
TO
SUMMARIZE
THE
STRIKING
FEATURE
OF
OUR
EXAMPLE
STARTING
FROM
A
POPULATION
OF
SMALL
BEETLES
EVOLUTION
BY
NATURAL
SELECTION
IS
CAUSING
THE
FITNESS
OF
THE
ORGANISMS
TO
DECREASE
OVER
TIME
THIS
MIGHT
SEEM
TROUBLING
INITIALLY
SINCE
WE
THINK
OF
NATURAL
SELECTION
AS
BEING
FITNESS
INCREASING
BUT
IN
FACT
IT
NOT
HARD
TO
RECONCILE
WHAT
HAPPENING
WITH
THIS
GENERAL
PRINCIPLE
OF
NATURAL
SELECTION
NATURAL
SELECTION
INCREASES
THE
FITNESS
OF
INDIVIDUAL
ORGANISMS
IN
A
FIXED
ENVIRONMENT
IF
THE
ENVIRONMENT
CHANGES
TO
BECOME
MORE
HOSTILE
TO
THE
ORGANISMS
THEN
CLEARLY
THIS
COULD
CAUSE
THEIR
FITNESS
TO
GO
DOWN
THIS
IS
WHAT
IS
HAPPENING
TO
THE
POPULATION
OF
BEETLES
EACH
BEETLE
ENVIRONMENT
INCLUDES
ALL
THE
OTHER
BEETLES
SINCE
THESE
OTHER
BEETLES
DETERMINE
ITS
SUCCESS
IN
FOOD
COMPETITIONS
THEREFORE
THE
INCREASING
FRACTION
OF
LARGE
BEETLES
CAN
BE
VIEWED
IN
A
SENSE
AS
A
SHIFT
TO
AN
ENVIRONMENT
THAT
IS
MORE
HOSTILE
FOR
EVERYONE
EMPIRICAL
EVIDENCE
FOR
EVOLUTIONARY
ARMS
RACES
BIOLOGISTS
HAVE
OFFERED
RECENT
EVI
DENCE
FOR
THE
PRESENCE
OF
EVOLUTIONARY
GAMES
IN
NATURE
WITH
THE
PRISONER
DILEMMA
STRUCTURE
WE
VE
JUST
SEEN
IT
IS
VERY
DIFFICULT
TO
TRULY
DETERMINE
PAYOFFS
IN
ANY
REAL
WORLD
SETTING
AND
SO
ALL
OF
THESE
STUDIES
ARE
THE
SUBJECT
OF
ONGOING
INVESTIGATION
AND
DEBATE
FOR
OUR
PURPOSES
IN
THIS
DISCUSSION
THEY
ARE
PERHAPS
MOST
USEFULLY
PHRASED
AS
DELIBERATELY
STREAMLINED
EXAMPLES
ILLUSTRATING
HOW
GAME
THEORETIC
REASONING
CAN
HELP
PROVIDE
QUALITATIVE
INSIGHT
INTO
DIFFERENT
FORMS
OF
BIOLOGICAL
INTERACTION
IT
HAS
BEEN
ARGUED
THAT
THE
HEIGHTS
OF
TREES
CAN
OBEY
PRISONER
DILEMMA
PAYOFFS
IF
TWO
NEIGHBORING
TREES
BOTH
GROW
SHORT
THEN
THEY
SHARE
THE
SUNLIGHT
EQUALLY
THEY
ALSO
SHARE
THE
SUNLIGHT
EQUALLY
IF
THEY
BOTH
GROW
TALL
BUT
IN
THIS
CASE
THEIR
PAYOFFS
ARE
EACH
LOWER
BECAUSE
THEY
HAVE
TO
INVEST
A
LOT
OF
RESOURCES
IN
ACHIEVING
THE
ADDITIONAL
HEIGHT
THE
TROUBLE
IS
THAT
IF
ONE
TREE
IS
SHORT
WHILE
ITS
NEIGHBOR
IS
TALL
THEN
THE
TALL
TREE
GETS
MOST
OF
THE
SUNLIGHT
AS
A
RESULT
WE
CAN
EASILY
END
UP
WITH
PAYOFFS
JUST
LIKE
THE
BODY
SIZE
GAME
AMONG
BEETLES
WITH
THE
TREES
EVOLUTIONARY
STRATEGIES
SHORT
AND
TALL
SERVING
AS
ANALOGUES
TO
THE
BEETLES
STRATEGIES
SMALL
AND
LARGE
OF
COURSE
THE
REAL
SITUATION
IS
MORE
COMPLEX
THAN
THIS
SINCE
GENETIC
VARIATION
AMONG
TREES
CAN
LEAD
TO
A
WIDE
RANGE
OF
DIFFERENT
HEIGHTS
AND
HENCE
A
RANGE
OF
DIFFERENT
STRATEGIES
RATHER
THAN
JUST
TWO
STRATEGIES
LABELED
SHORT
AND
TALL
WITHIN
THIS
CONTINUUM
PRISONER
DILEMMA
PAYOFFS
CAN
ONLY
APPLY
TO
A
CERTAIN
RANGE
OF
TREE
HEIGHTS
THERE
IS
SOME
HEIGHT
BEYOND
WHICH
FURTHER
HEIGHT
INCREASING
MUTATIONS
NO
LONGER
PROVIDE
THE
SAME
PAYOFF
STRUCTURE
BECAUSE
THE
ADDITIONAL
SUNLIGHT
IS
MORE
THAN
OFFSET
BY
THE
FITNESS
DOWNSIDE
OF
SUSTAINING
AN
ENORMOUS
HEIGHT
SIMILAR
KINDS
OF
COMPETITION
TAKE
PLACE
IN
THE
ROOT
SYSTEMS
OF
PLANTS
SUPPOSE
YOU
GROW
TWO
SOYBEAN
PLANTS
AT
OPPOSITE
ENDS
OF
A
LARGE
POT
OF
SOIL
THEN
THEIR
ROOT
SYSTEMS
WILL
EACH
FILL
OUT
THE
AVAILABLE
SOIL
AND
INTERMINGLE
WITH
EACH
OTHER
AS
THEY
TRY
TO
CLAIM
AS
MANY
RESOURCES
AS
THEY
CAN
IN
DOING
SO
THEY
DIVIDE
THE
RESOURCES
IN
THE
SOIL
EQUALLY
NOW
SUPPOSE
THAT
INSTEAD
YOU
PARTITION
THE
SAME
QUANTITY
OF
SOIL
USING
A
WALL
DOWN
THE
MIDDLE
SO
THAT
THE
TWO
PLANTS
ARE
ON
OPPOSITE
SIDES
OF
THE
WALL
THEN
EACH
STILL
GETS
HALF
THE
RESOURCES
PRESENT
IN
THE
SOIL
BUT
EACH
INVESTS
LESS
OF
ITS
ENERGY
IN
PRODUCING
ROOTS
AND
CONSEQUENTLY
HAS
GREATER
REPRODUCTIVE
SUCCESS
THROUGH
SEED
PRODUCTION
THIS
OBSERVATION
HAS
IMPLICATIONS
FOR
THE
FOLLOWING
SIMPLIFIED
EVOLUTIONARY
GAME
INVOLVING
ROOT
SYSTEMS
IMAGINE
THAT
INSTEAD
OF
A
WALL
WE
HAD
TWO
KINDS
OF
ROOT
DEVELOPMENT
STRATEGIES
AVAILABLE
TO
SOYBEAN
PLANTS
CONSERVE
WHERE
A
PLANT
ROOTS
ONLY
GROW
INTO
ITS
OWN
SHARE
OF
THE
SOIL
AND
EXPLORE
WHERE
THE
ROOTS
GROW
EVERYWHERE
THEY
CAN
REACH
THEN
WE
AGAIN
HAVE
THE
SCENARIO
AND
PAYOFFS
FROM
THE
BODY
SIZE
GAME
WITH
THE
SAME
CONCLUSION
ALL
PLANTS
ARE
BETTER
OFF
IN
A
POPULATION
WHERE
EVERYONE
PLAYS
CONSERVE
BUT
ONLY
EXPLORE
IS
EVOLUTIONARILY
STABLE
AS
A
THIRD
EXAMPLE
THERE
WAS
RECENT
EXCITEMENT
OVER
THE
DISCOVERY
THAT
VIRUS
POPULATIONS
CAN
ALSO
PLAY
AN
EVOLUTIONARY
VERSION
OF
THE
PRISONER
DILEMMA
TURNER
AND
CHAO
STUDIED
A
VIRUS
CALLED
PHAGE
WHICH
INFECTS
BACTERIA
AND
MANUFACTURES
PRODUCTS
NEEDED
FOR
ITS
OWN
REPLICATION
A
MUTATIONAL
VARIANT
OF
THIS
VIRUS
CALLED
PHAGE
IS
ALSO
ABLE
TO
REPLICATE
IN
BACTERIAL
HOSTS
THOUGH
LESS
EFFECTIVELY
ON
ITS
OWN
HOWEVER
IS
ABLE
TO
TAKE
ADVANTAGE
OF
CHEMICAL
PRODUCTS
PRODUCED
BY
WHICH
GIVES
A
FITNESS
ADVANTAGE
WHEN
IT
IS
IN
THE
PRESENCE
OF
THIS
TURNS
OUT
TO
YIELD
THE
STRUCTURE
OF
THE
PRISONER
DILEMMA
VIRUSES
HAVE
THE
TWO
EVOLUTIONARY
STRATEGIES
AND
VIRUSES
IN
A
PURE
POPULATION
ALL
DO
BETTER
THAN
VIRUSES
IN
A
PURE
POPULATION
AND
REGARDLESS
OF
WHAT
THE
OTHER
VIRUSES
ARE
DOING
YOU
AS
A
VIRUS
ARE
BETTER
OFF
PLAYING
THUS
ONLY
IS
EVOLUTIONARILY
STABLE
THE
VIRUS
SYSTEM
UNDER
STUDY
WAS
SO
SIMPLE
THAT
TURNER
AND
CHAO
WERE
ABLE
TO
INFER
AN
ACTUAL
PAYOFF
MATRIX
BASED
ON
MEASURING
THE
RELATIVE
RATES
AT
WHICH
THE
TWO
VIRAL
VARIANTS
WERE
ABLE
TO
REPLICATE
UNDER
DIFFERENT
CONDITIONS
USING
AN
ESTIMATION
PROCEDURE
DERIVED
FROM
THESE
MEASUREMENTS
THEY
OBTAINED
THE
PAYOFFS
IN
FIGURE
THE
PAYOFFS
ARE
RE
SCALED
SO
THAT
THE
UPPER
LEFT
BOX
HAS
THE
VALUE
VIRUS
VIRUS
FIGURE
THE
VIRUS
GAME
WHEREAS
OUR
EARLIER
EXAMPLES
HAD
AN
UNDERLYING
STORY
VERY
MUCH
LIKE
THE
USE
OF
PERFORMANCE
ENHANCING
DRUGS
THIS
GAME
AMONG
PHAGES
IS
ACTUALLY
REMINISCENT
OF
A
DIFFERENT
STORY
THAT
ALSO
MOTIVATES
THE
PRISONER
DILEMMA
PAYOFF
STRUCTURE
THE
SCENARIO
BEHIND
THE
EXAM
OR
PRESENTATION
GAME
WITH
WHICH
WE
BEGAN
CHAPTER
THERE
TWO
COLLEGE
STUDENTS
WOULD
BOTH
BE
BETTER
OFF
IF
THEY
JOINTLY
PREPARED
FOR
A
PRESENTATION
BUT
THE
PAYOFFS
LED
THEM
TO
EACH
THINK
SELFISHLY
AND
STUDY
FOR
AN
EXAM
INSTEAD
WHAT
THE
VIRUS
GAME
HERE
SHOWS
IS
THAT
SHIRKING
A
SHARED
RESPONSIBILITY
ISN
T
JUST
SOMETHING
THAT
RATIONAL
DECISION
MAKERS
DO
EVOLUTIONARY
FORCES
CAN
INDUCE
VIRUSES
TO
PLAY
THIS
STRATEGY
AS
WELL
A
GENERAL
DESCRIPTION
OF
EVOLUTIONARILY
STABLE
STRATE
GIES
THE
CONNECTIONS
BETWEEN
EVOLUTIONARY
GAMES
AND
GAMES
PLAYED
BY
RATIONAL
PARTICIPANTS
ARE
SUGGESTIVE
ENOUGH
THAT
IT
MAKES
SENSE
TO
UNDERSTAND
HOW
THE
RELATIONSHIP
WORKS
IN
GENERAL
WE
WILL
FOCUS
HERE
AS
WE
HAVE
THUS
FAR
ON
TWO
PLAYER
TWO
STRATEGY
GAMES
WE
WILL
ALSO
SHOULD
BE
NOTED
THAT
EVEN
IN
A
SYSTEM
THIS
SIMPLE
THERE
ARE
MANY
OTHER
BIOLOGICAL
FACTORS
AT
WORK
AND
HENCE
THIS
PAYOFF
MATRIX
IS
STILL
JUST
AN
APPROXIMATION
TO
THE
PERFORMANCE
OF
AND
POPULATIONS
UNDER
REAL
EXPERIMENTAL
AND
NATURAL
CONDITIONS
OTHER
FACTORS
APPEAR
TO
AFFECT
THESE
POPULATIONS
INCLUDING
THE
DENSITY
OF
THE
POPULATION
AND
THE
POTENTIAL
PRESENCE
OF
ADDITIONAL
MUTANT
FORMS
OF
THE
VIRUS
A
GENERAL
DESCRIPTION
OF
EVOLUTIONARILY
STABLE
STRATEGIES
RESTRICT
OUR
ATTENTION
TO
SYMMETRIC
GAMES
AS
IN
THE
PREVIOUS
SECTIONS
OF
THIS
CHAPTER
WHERE
THE
ROLES
OF
THE
TWO
PLAYERS
ARE
INTERCHANGEABLE
THE
PAYOFF
MATRIX
FOR
A
COMPLETELY
GENERAL
TWO
PLAYER
TWO
STRATEGY
GAME
THAT
IS
SYM
METRIC
CAN
BE
WRITTEN
AS
IN
FIGURE
ORGANISM
T
ORGANISM
T
A
A
B
C
C
B
D
D
FIGURE
GENERAL
SYMMETRIC
GAME
LET
CHECK
HOW
TO
WRITE
THE
CONDITION
THAT
IS
EVOLUTIONARILY
STABLE
IN
TERMS
OF
THE
FOUR
VARIABLES
A
B
C
AND
D
AS
BEFORE
WE
START
BY
SUPPOSING
THAT
FOR
SOME
VERY
SMALL
POSITIVE
NUMBER
X
A
X
FRACTION
OF
THE
POPULATION
USES
AND
AN
X
FRACTION
OF
THE
POPULATION
USES
T
WHAT
IS
THE
EXPECTED
PAYOFF
TO
AN
ORGANISM
PLAYING
IN
A
RANDOM
INTERACTION
IN
THIS
POPULATION
WITH
PROBABILITY
X
IT
MEETS
ANOTHER
PLAYER
OF
RECEIVING
A
PAYOFF
OF
A
WHILE
WITH
PROBABILITY
X
IT
MEETS
A
PLAYER
OF
T
RECEIVING
A
PAYOFF
OF
B
THEREFORE
ITS
EXPECTED
PAYOFF
IS
A
X
BX
WHAT
IS
THE
EXPECTED
PAYOFF
TO
AN
ORGANISM
PLAYING
T
IN
A
RANDOM
INTERACTION
IN
THIS
POPULATION
WITH
PROBABILITY
X
IT
MEETS
A
PLAYER
OF
RECEIVING
A
PAYOFF
OF
C
WHILE
WITH
PROBABILITY
X
IT
MEETS
ANOTHER
PLAYER
OF
T
RECEIVING
A
PAYOFF
OF
D
THEREFORE
ITS
EXPECTED
PAYOFF
IS
C
X
DX
THEREFORE
IS
EVOLUTIONARILY
STABLE
IF
FOR
ALL
SUFFICIENTLY
SMALL
VALUES
OF
X
THE
INEQUALITY
A
X
BX
C
X
DX
HOLDS
AS
X
GOES
TO
THE
LEFT
HAND
SIDE
BECOMES
A
AND
THE
RIGHT
HAND
SIDE
BECOMES
C
HENCE
IF
A
C
THEN
THE
LEFT
HAND
SIDE
IS
LARGER
ONCE
X
IS
SUFFICIENTLY
SMALL
WHILE
IF
A
C
THEN
THE
LEFT
HAND
SIDE
IS
SMALLER
ONCE
X
IS
SUFFICIENTLY
SMALL
FINALLY
IF
A
C
THEN
THE
LEFT
HAND
SIDE
IS
LARGER
PRECISELY
WHEN
B
D
THEREFORE
WE
HAVE
A
SIMPLE
WAY
TO
EXPRESS
THE
CONDITION
THAT
IS
EVOLUTIONARILY
STABLE
IN
A
TWO
PLAYER
TWO
STRATEGY
SYMMETRIC
GAME
IS
EVOLUTIONARILY
STABLE
PRECISELY
WHEN
EITHER
I
A
C
OR
II
A
C
AND
B
D
IT
IS
EASY
TO
SEE
THE
INTUITION
BEHIND
OUR
CALCULATIONS
THAT
TRANSLATES
INTO
THIS
CONDITION
AS
FOLLOWS
FIRST
IN
ORDER
FOR
TO
BE
EVOLUTIONARILY
STABLE
THE
PAYOFF
TO
USING
STRATEGY
AGAINST
MUST
BE
AT
LEAST
AS
LARGE
AS
THE
PAYOFF
TO
USING
STRATEGY
T
AGAINST
OTHERWISE
AN
INVADER
WHO
USES
T
WOULD
HAVE
A
HIGHER
FITNESS
THAN
THE
REST
OF
POPULATION
AND
THE
FRACTION
OF
THE
POPULATION
WHO
ARE
INVADERS
WOULD
HAVE
A
GOOD
PROBABILITY
OF
GROWING
OVER
TIME
SECOND
IF
AND
T
ARE
EQUALLY
GOOD
RESPONSES
TO
THEN
IN
ORDER
FOR
TO
BE
EVOLU
TIONARILY
STABLE
PLAYERS
OF
MUST
DO
BETTER
IN
THEIR
INTERACTIONS
WITH
T
THAN
PLAYERS
OF
T
DO
WITH
EACH
OTHER
OTHERWISE
PLAYERS
OF
T
WOULD
DO
AS
WELL
AS
AGAINST
THE
PART
OF
THE
POPULATION
AS
PLAYERS
OF
AND
AT
LEAST
AS
WELL
AGAINST
THE
T
PART
OF
THE
POPULATION
SO
THEIR
OVERALL
FITNESS
WOULD
BE
AT
LEAST
AS
GOOD
AS
THE
FITNESS
OF
PLAYERS
OF
RELATIONSHIP
BETWEEN
EVOLUTIONARY
AND
NASH
EQUI
LIBRIA
USING
OUR
GENERAL
WAY
OF
CHARACTERIZING
EVOLUTIONARILY
STABLE
STRATEGIES
WE
CAN
NOW
UNDER
STAND
HOW
THEY
RELATE
TO
NASH
EQUILIBRIA
IF
WE
GO
BACK
TO
THE
GENERAL
SYMMETRIC
GAME
FROM
THE
PREVIOUS
SECTION
WE
CAN
WRITE
DOWN
THE
CONDITION
FOR
I
E
THE
CHOICE
OF
BY
BOTH
PLAYERS
TO
BE
A
NASH
EQUILIBRIUM
IS
A
NASH
EQUILIBRIUM
WHEN
IS
A
BEST
RESPONSE
TO
THE
CHOICE
OF
BY
THE
OTHER
PLAYER
THIS
TRANSLATES
INTO
THE
SIMPLE
CONDITION
A
C
IF
WE
COMPARE
THIS
TO
THE
CONDITION
FOR
TO
BE
EVOLUTIONARILY
STABLE
I
A
C
OR
II
A
C
AND
B
D
WE
IMMEDIATELY
GET
THE
CONCLUSION
THAT
IF
STRATEGY
IS
EVOLUTIONARILY
STABLE
THEN
IS
A
NASH
EQUILIBRIUM
WE
CAN
ALSO
SEE
THAT
THE
OTHER
DIRECTION
DOES
NOT
HOLD
IT
IS
POSSIBLE
TO
HAVE
A
GAME
WHERE
IS
A
NASH
EQUILIBRIUM
BUT
IS
NOT
EVOLUTIONARILY
STABLE
THE
DIFFERENCE
IN
THE
TWO
CONDITIONS
ABOVE
TELLS
US
HOW
TO
CONSTRUCT
SUCH
A
GAME
WE
SHOULD
HAVE
A
C
AND
B
D
TO
GET
A
SENSE
FOR
WHERE
SUCH
A
GAME
MIGHT
COME
FROM
LET
RECALL
THE
STAG
HUNT
GAME
FROM
CHAPTER
HERE
EACH
PLAYER
CAN
HUNT
STAG
OR
HUNT
HARE
HUNTING
HARE
SUCCESSFULLY
JUST
REQUIRES
YOUR
OWN
EFFORT
WHILE
HUNTING
THE
MORE
VALUABLE
STAG
REQUIRES
THAT
YOU
BOTH
DO
SO
THIS
PRODUCES
PAYOFFS
AS
SHOWN
IN
FIGURE
RELATIONSHIP
BETWEEN
EVOLUTIONARY
AND
NASH
EQUILIBRIA
HUNTER
HUNT
STAG
HUNT
HARE
HUNTER
HUNT
STAG
HUNT
HARE
FIGURE
STAG
HUNT
IN
THIS
GAME
AS
WRITTEN
HUNT
STAG
AND
HUNT
HARE
ARE
BOTH
EVOLUTIONARILY
STABLE
AS
WE
CAN
CHECK
FROM
THE
CONDITIONS
ON
A
B
C
AND
D
TO
CHECK
THE
CONDITION
FOR
HUNT
HARE
WE
SIMPLY
NEED
TO
INTERCHANGE
THE
ROWS
AND
COLUMNS
OF
THE
PAYOFF
MATRIX
TO
PUT
HUNT
HARE
IN
THE
FIRST
ROW
AND
FIRST
COLUMN
HOWEVER
SUPPOSE
WE
MAKE
UP
A
MODIFICATION
OF
THE
STAG
HUNT
GAME
BY
SHIFTING
THE
PAYOFFS
AS
FOLLOWS
IN
THIS
NEW
VERSION
WHEN
THE
PLAYERS
MIS
COORDINATE
SO
THAT
ONE
HUNTS
STAG
WHILE
THE
OTHER
HUNTS
HARE
THEN
THE
HARE
HUNTER
GETS
AN
EXTRA
BENEFIT
DUE
TO
THE
LACK
OF
COMPETITION
FOR
HARE
IN
THIS
WAY
WE
GET
A
PAYOFF
MATRIX
AS
IN
FIGURE
HUNTER
HUNT
STAG
HUNT
HARE
HUNTER
HUNT
STAG
HUNT
HARE
FIGURE
STAG
HUNT
A
VERSION
WITH
ADDED
BENEFIT
FROM
HUNTING
HARE
ALONE
IN
THIS
CASE
THE
CHOICE
OF
STRATEGIES
HUNT
STAG
HUNT
STAG
IS
STILL
A
NASH
EQUILIBRIUM
IF
EACH
PLAYER
EXPECTS
THE
OTHER
TO
HUNT
STAG
THEN
HUNTING
STAG
IS
A
BEST
RESPONSE
BUT
HUNT
STAG
IS
NOT
AN
EVOLUTIONARILY
STABLE
STRATEGY
FOR
THIS
VERSION
OF
THE
GAME
BECAUSE
IN
THE
NOTATION
FROM
OUR
GENERAL
SYMMETRIC
GAME
WE
HAVE
A
C
AND
B
D
INFORMALLY
THE
PROBLEM
IS
THAT
A
HARE
HUNTER
AND
A
STAG
HUNTER
DO
EQUALLY
WELL
WHEN
EACH
IS
PAIRED
WITH
A
STAG
HUNTER
BUT
HARE
HUNTERS
DO
BETTER
THAN
STAG
HUNTERS
WHEN
EACH
IS
PAIRED
WITH
A
HARE
HUNTER
THERE
IS
ALSO
A
RELATIONSHIP
BETWEEN
EVOLUTIONARILY
STABLE
STRATEGIES
AND
THE
CONCEPT
OF
A
STRICT
NASH
EQUILIBRIUM
WE
SAY
THAT
A
CHOICE
OF
STRATEGIES
IS
A
STRICT
NASH
EQUILIBRIUM
IF
EACH
PLAYER
IS
USING
THE
UNIQUE
BEST
RESPONSE
TO
WHAT
THE
OTHER
PLAYER
IS
DOING
WE
CAN
CHECK
THAT
FOR
SYMMETRIC
TWO
PLAYER
TWO
STRATEGY
GAMES
THE
CONDITION
FOR
TO
BE
A
STRICT
NASH
EQUILIBRIUM
IS
THAT
A
C
SO
WE
SEE
THAT
IN
FACT
THESE
DIFFERENT
NOTIONS
OF
EQUILIBRIUM
NATURALLY
REFINE
EACH
OTHER
THE
CONCEPT
OF
AN
EVOLUTIONARILY
STABLE
STRATEGY
CAN
BE
VIEWED
AS
A
REFINEMENT
OF
THE
CONCEPT
OF
A
NASH
EQUILIBRIUM
THE
SET
OF
EVOLUTIONARILY
STABLE
STRATEGIES
IS
A
SUBSET
OF
THE
SET
OF
STRATEGIES
FOR
WHICH
IS
A
NASH
EQUILIBRIUM
SIMILARLY
THE
CONCEPT
OF
A
STRICT
NASH
EQUILIBRIUM
WHEN
THE
PLAYERS
USE
THE
SAME
STRATEGY
IS
A
REFINEMENT
OF
EVOLUTIONARY
STABILITY
IF
IS
A
STRICT
NASH
EQUILIBRIUM
THEN
IS
EVOLUTIONARILY
STABLE
IT
IS
INTRIGUING
THAT
DESPITE
THE
EXTREMELY
CLOSE
SIMILARITIES
BETWEEN
THE
CONCLUSIONS
OF
EVOLUTIONARY
STABILITY
AND
NASH
EQUILIBRIUM
THEY
ARE
BUILT
ON
VERY
DIFFERENT
UNDERLYING
STORIES
IN
A
NASH
EQUILIBRIUM
WE
CONSIDER
PLAYERS
CHOOSING
MUTUAL
BEST
RESPONSES
TO
EACH
OTHER
STRATEGY
THIS
EQUILIBRIUM
CONCEPT
PLACES
GREAT
DEMANDS
ON
THE
ABILITY
OF
THE
PLAYERS
TO
CHOOSE
OPTIMALLY
AND
TO
COORDINATE
ON
STRATEGIES
THAT
ARE
BEST
RESPONSES
TO
EACH
OTHER
EVOLUTIONARY
STABILITY
ON
THE
OTHER
HAND
SUPPOSES
NO
INTELLIGENCE
OR
COORDINATION
ON
THE
PART
OF
THE
PLAYERS
INSTEAD
STRATEGIES
ARE
VIEWED
AS
BEING
HARD
WIRED
INTO
THE
PLAYERS
PERHAPS
BECAUSE
THEIR
BEHAVIOR
IS
ENCODED
IN
THEIR
GENES
ACCORDING
TO
THIS
CONCEPT
STRATEGIES
WHICH
ARE
MORE
SUCCESSFUL
IN
PRODUCING
OFFSPRING
ARE
SELECTED
FOR
ALTHOUGH
THIS
EVOLUTIONARY
APPROACH
TO
ANALYZING
GAMES
ORIGINATED
IN
BIOLOGY
IT
CAN
BE
APPLIED
IN
MANY
OTHER
CONTEXTS
FOR
EXAMPLE
SUPPOSE
A
LARGE
GROUP
OF
PEOPLE
ARE
BEING
MATCHED
REPEATEDLY
OVER
TIME
TO
PLAY
THE
GENERAL
SYMMETRIC
GAME
FROM
FIGURE
NOW
THE
PAYOFFS
SHOULD
BE
INTERPRETED
AS
REFLECTING
THE
WELFARE
OF
THE
PLAYERS
AND
NOT
THEIR
NUMBER
OF
OFFSPRING
IF
ANY
PLAYER
CAN
LOOK
BACK
AT
HOW
OTHERS
HAVE
PLAYED
AND
CAN
OBSERVE
THEIR
PAYOFFS
THEN
IMITATION
OF
THE
STRATEGIES
THAT
HAVE
BEEN
MOST
SUCCESSFUL
MAY
INDUCE
AN
EVOLUTIONARY
DYNAMIC
ALTERNATIVELY
IF
A
PLAYER
CAN
OBSERVE
HIS
OWN
PAST
SUCCESSES
AND
FAILURES
THEN
HIS
LEARNING
MAY
INDUCE
AN
EVOLUTIONARY
DYNAMIC
IN
EITHER
CASE
STRATEGIES
THAT
HAVE
DONE
RELATIVELY
WELL
IN
THE
PAST
WILL
TEND
TO
BE
USED
BY
MORE
PEOPLE
IN
THE
FUTURE
THIS
CAN
LEAD
TO
THE
SAME
BEHAVIOR
THAT
UNDERLIES
THE
CONCEPT
OF
EVOLUTIONARILY
STABLE
STRATEGIES
AND
HENCE
CAN
PROMOTE
THE
PLAY
OF
SUCH
STRATEGIES
EVOLUTIONARILY
STABLE
MIXED
STRATEGIES
AS
A
FURTHER
STEP
IN
DEVELOPING
AN
EVOLUTIONARY
THEORY
OF
GAMES
WE
NOW
CONSIDER
HOW
TO
HANDLE
CASES
IN
WHICH
NO
STRATEGY
IS
EVOLUTIONARILY
STABLE
IN
FACT
IT
IS
NOT
HARD
TO
SEE
HOW
THIS
CAN
HAPPEN
EVEN
IN
TWO
PLAYER
GAMES
THAT
HAVE
PURE
STRATEGY
NASH
EQUILIBRIA
PERHAPS
THE
MOST
NATURAL
EXAMPLE
IS
THE
HAWK
DOVE
GAME
FROM
CHAPTER
AND
WE
USE
THIS
TO
INTRODUCE
THE
BASIC
IDEAS
OF
THIS
SECTION
RECALL
THAT
IN
THE
HAWK
DOVE
GAME
TWO
ANIMALS
COMPETE
FOR
A
PIECE
OF
FOOD
AN
ANIMAL
THAT
PLAYS
THE
STRATEGY
HAWK
H
BEHAVES
AGGRESSIVELY
WHILE
AN
ANIMAL
THAT
PLAYS
THE
STRATEGY
DOVE
D
BEHAVES
PASSIVELY
IF
ONE
ANIMAL
IS
AGGRESSIVE
WHILE
THE
OTHER
IS
PASSIVE
THEN
THE
AGGRESSIVE
ANIMAL
BENEFITS
BY
GETTING
MOST
OF
THE
FOOD
BUT
IF
BOTH
ANIMALS
ARE
AGGRESSIVE
THEN
THEY
RISK
DESTROYING
THE
FOOD
AND
INJURING
EACH
OTHER
THIS
LEADS
TO
A
PAYOFF
MATRIX
AS
SHOWN
IN
FIGURE
IN
CHAPTER
WE
CONSIDERED
THIS
GAME
IN
CONTEXTS
WHERE
THE
TWO
PLAYERS
WERE
MAKING
CHOICES
ABOUT
HOW
TO
BEHAVE
NOW
LET
CONSIDER
THE
SAME
GAME
IN
A
SETTING
WHERE
EACH
THAT
A
PLAYER
IS
USING
A
PURE
STRATEGY
IF
SHE
ALWAYS
PLAYS
A
PARTICULAR
ONE
OF
THE
STRATEGIES
IN
THE
GAME
AS
OPPOSED
TO
A
MIXED
STRATEGY
IN
WHICH
SHE
CHOOSES
AT
RANDOM
FROM
AMONG
SEVERAL
POSSIBLE
STRATEGIES
ANIMAL
D
H
ANIMAL
D
H
FIGURE
HAWK
DOVE
GAME
ANIMAL
IS
GENETICALLY
HARD
WIRED
TO
PLAY
A
PARTICULAR
STRATEGY
HOW
DOES
IT
LOOK
FROM
THIS
PERSPECTIVE
WHEN
WE
CONSIDER
EVOLUTIONARY
STABILITY
NEITHER
D
NOR
H
IS
A
BEST
RESPONSE
TO
ITSELF
AND
SO
USING
THE
GENERAL
PRINCIPLES
FROM
THE
LAST
TWO
SECTIONS
WE
SEE
THAT
NEITHER
IS
EVOLUTIONARILY
STABLE
INTUITIVELY
A
HAWK
WILL
DO
VERY
WELL
IN
A
POPULATION
CONSISTING
OF
DOVES
BUT
IN
A
POPULATION
OF
ALL
HAWKS
A
DOVE
WILL
ACTUALLY
DO
BETTER
BY
STAYING
OUT
OF
THE
WAY
WHILE
THE
HAWKS
FIGHT
WITH
EACH
OTHER
AS
A
TWO
PLAYER
GAME
IN
WHICH
PLAYERS
ARE
ACTUALLY
CHOOSING
STRATEGIES
THE
HAWK
DOVE
GAME
HAS
TWO
PURE
NASH
EQUILIBRIA
D
H
AND
H
D
BUT
THIS
DOESN
T
DIRECTLY
HELP
US
IDENTIFY
AN
EVOLUTIONARILY
STABLE
STRATEGY
SINCE
THUS
FAR
OUR
DEFINITION
OF
EVOLUTIONARY
STABILITY
HAS
BEEN
RESTRICTED
TO
POPULATIONS
IN
WHICH
ALMOST
ALL
MEMBERS
PLAY
THE
SAME
PURE
STRATEGY
TO
REASON
ABOUT
WHAT
WILL
HAPPEN
IN
THE
HAWK
DOVE
GAME
UNDER
EVOLUTIONARY
FORCES
WE
NEED
TO
GENERALIZE
THE
NOTION
OF
EVOLUTIONARY
STABILITY
BY
ALLOWING
SOME
NOTION
OF
MIXING
BETWEEN
STRATEGIES
DEFINING
MIXED
STRATEGIES
IN
EVOLUTIONARY
GAME
THEORY
THERE
ARE
AT
LEAST
TWO
NATURAL
WAYS
TO
INTRODUCE
THE
IDEA
OF
MIXING
INTO
THE
EVOLUTIONARY
FRAMEWORK
FIRST
IT
COULD
BE
THAT
EACH
INDIVIDUAL
IS
HARD
WIRED
TO
PLAY
A
PURE
STRATEGY
BUT
SOME
PORTION
OF
THE
POPULATION
PLAYS
ONE
STRATEGY
WHILE
THE
REST
OF
THE
POPULATION
PLAYS
ANOTHER
IF
THE
FITNESS
OF
INDIVIDUALS
IN
EACH
PART
OF
THE
POPULATION
IS
THE
SAME
AND
IF
INVADERS
EVENTUALLY
DIE
OFF
THEN
THIS
COULD
BE
CONSIDERED
TO
EXHIBIT
A
KIND
OF
EVOLUTIONARY
STABILITY
SECOND
IT
COULD
BE
THAT
EACH
INDIVIDUAL
IS
HARD
WIRED
TO
PLAY
A
PARTICULAR
MIXED
STRATEGY
THAT
IS
THEY
ARE
GENETICALLY
CONFIGURED
TO
CHOOSE
RANDOMLY
FROM
AMONG
CERTAIN
OPTIONS
WITH
CERTAIN
PROBABILITIES
IF
INVADERS
USING
ANY
OTHER
MIXED
STRATEGY
EVENTUALLY
DIE
OFF
THEN
THIS
TOO
COULD
BE
CONSIDERED
A
KIND
OF
EVOLUTIONARY
STABILITY
WE
WILL
SEE
THAT
FOR
OUR
PURPOSES
HERE
THESE
TWO
CONCEPTS
ARE
ACTUALLY
EQUIVALENT
TO
EACH
OTHER
AND
WE
WILL
FOCUS
INITIALLY
ON
THE
SECOND
IDEA
IN
WHICH
INDIVIDUALS
USE
MIXED
STRATEGIES
ESSENTIALLY
WE
WILL
FIND
THAT
IN
SITUATIONS
LIKE
THE
HAWK
DOVE
GAME
THE
INDIVIDUALS
OR
THE
POPULATION
AS
A
WHOLE
MUST
DISPLAY
A
MIXTURE
OF
THE
TWO
BEHAVIORS
IN
ORDER
TO
HAVE
ANY
CHANCE
OF
BEING
STABLE
AGAINST
INVASION
BY
OTHER
FORMS
OF
BEHAVIOR
THE
DEFINITION
OF
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
IS
IN
FACT
COMPLETELY
PARALLEL
TO
THE
DEFINITION
OF
EVOLUTIONARY
STABILITY
WE
HAVE
SEEN
THUS
FAR
IT
IS
SIMPLY
THAT
WE
NOW
GREATLY
ENLARGE
THE
SET
OF
POSSIBLE
STRATEGIES
SO
THAT
EACH
STRATEGY
CORRESPONDS
TO
A
PARTICULAR
RANDOMIZED
CHOICE
OVER
PURE
STRATEGIES
SPECIFICALLY
LET
CONSIDER
THE
GENERAL
SYMMETRIC
GAME
FROM
FIGURE
A
MIXED
STRAT
EGY
HERE
CORRESPONDS
TO
A
PROBABILITY
P
BETWEEN
AND
INDICATING
THAT
THE
ORGANISM
PLAYS
WITH
PROBABILITY
P
AND
PLAYS
T
WITH
PROBABILITY
P
AS
IN
OUR
DISCUSSION
OF
MIXED
STRATEGIES
FROM
CHAPTER
THIS
INCLUDES
THE
POSSIBILITY
OF
PLAYING
THE
PURE
STRATEGIES
OR
T
BY
SIMPLY
SETTING
P
OR
P
WHEN
ORGANISM
USES
THE
MIXED
STRATEGY
P
AND
ORGANISM
USES
THE
MIXED
STRATEGY
Q
THE
EXPECTED
PAYOFF
TO
ORGANISM
CAN
BE
COMPUTED
AS
FOLLOWS
THERE
IS
A
PROBABILITY
PQ
OF
AN
X
X
PAIRING
YIELDING
A
FOR
THE
FIRST
PLAYER
THERE
IS
A
PROBABILITY
P
Q
OF
AN
X
Y
PAIRING
YIELDING
B
FOR
THE
FIRST
PLAYER
THERE
IS
A
PROBABILITY
P
Q
OF
A
Y
X
PAIRING
YIELDING
C
FOR
THE
FIRST
PLAYER
AND
THERE
IS
A
PROBABILITY
P
Q
OF
A
Y
Y
PAIRING
YIELDING
D
FOR
THE
FIRST
PLAYER
SO
THE
EXPECTED
PAYOFF
FOR
THIS
FIRST
PLAYER
IS
V
P
Q
PQA
P
Q
B
P
QC
P
Q
D
AS
BEFORE
THE
FITNESS
OF
AN
ORGANISM
IS
ITS
EXPECTED
PAYOFF
IN
AN
INTERACTION
WITH
A
RANDOM
MEMBER
OF
THE
POPULATION
WE
CAN
NOW
GIVE
THE
PRECISE
DEFINITION
OF
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
IN
THE
GENERAL
SYMMETRIC
GAME
P
IS
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
IF
THERE
IS
A
SMALL
POSITIVE
NUMBER
Y
SUCH
THAT
WHEN
ANY
OTHER
MIXED
STRATEGY
Q
INVADES
P
AT
ANY
LEVEL
X
Y
THE
FITNESS
OF
AN
ORGANISM
PLAYING
P
IS
STRICTLY
GREATER
THAN
THE
FITNESS
OF
AN
ORGANISM
PLAYING
Q
THIS
IS
JUST
LIKE
OUR
PREVIOUS
DEFINITION
OF
EVOLUTIONARILY
STABLE
PURE
STRATEGIES
EXCEPT
THAT
WE
ALLOW
THE
STRATEGY
TO
BE
MIXED
AND
WE
ALLOW
THE
INVADERS
TO
USE
A
MIXED
STRATEGY
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
WITH
P
OR
P
IS
EVOLUTIONARILY
STABLE
UNDER
OUR
ORIGINAL
DEFINITION
FOR
PURE
STRATEGIES
AS
WELL
HOWEVER
NOTE
THE
SUBTLE
POINT
THAT
EVEN
IF
WERE
AN
EVOLUTIONARILY
STABLE
STRATEGY
UNDER
OUR
PREVIOUS
DEFINITION
IT
IS
NOT
NECESSARILY
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
UNDER
THIS
NEW
DEFINITION
WITH
P
THE
PROBLEM
IS
THAT
IT
IS
POSSIBLE
TO
CONSTRUCT
GAMES
IN
WHICH
NO
PURE
STRATEGY
CAN
SUCCESSFULLY
INVADE
A
POPULATION
PLAYING
BUT
A
MIXED
STRATEGY
CAN
AS
A
RESULT
IT
WILL
BE
IMPORTANT
TO
BE
CLEAR
IN
ANY
DISCUSSION
OF
EVOLUTIONARY
STABILITY
ON
WHAT
KINDS
OF
BEHAVIOR
AN
INVADER
CAN
EMPLOY
DIRECTLY
FROM
THE
DEFINITION
WE
CAN
WRITE
THE
CONDITION
FOR
P
TO
BE
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
AS
FOLLOWS
FOR
SOME
Y
AND
ANY
X
Y
THE
FOLLOWING
INEQUALITY
HOLDS
FOR
ALL
MIXED
STRATEGIES
Q
P
X
V
P
P
XV
P
Q
X
V
Q
P
XV
Q
Q
THIS
INEQUALITY
ALSO
MAKES
IT
CLEAR
THAT
THERE
IS
A
RELATIONSHIP
BETWEEN
MIXED
NASH
EQUILIBRIA
AND
EVOLUTIONARILY
STABLE
MIXED
STRATEGIES
AND
THIS
RELATIONSHIP
PARALLELS
THE
ONE
WE
SAW
EARLIER
FOR
PURE
STRATEGIES
IN
PARTICULAR
IF
P
IS
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
THEN
WE
MUST
HAVE
V
P
P
V
Q
P
AND
SO
P
IS
A
BEST
RESPONSE
TO
P
AS
A
RESULT
THE
PAIR
OF
STRATEGIES
P
P
IS
A
MIXED
NASH
EQUILIBRIUM
HOWEVER
BECAUSE
OF
THE
STRICT
INEQUALITY
IN
EQUATION
IT
IS
POSSIBLE
FOR
P
P
TO
BE
A
MIXED
NASH
EQUILIBRIUM
WITHOUT
P
BEING
EVOLUTIONARILY
STABLE
SO
AGAIN
EVOLUTIONARY
STABILITY
SERVES
AS
A
REFINEMENT
OF
THE
CONCEPT
OF
MIXED
NASH
EQUILIBRIUM
EVOLUTIONARILY
STABLE
MIXED
STRATEGIES
IN
THE
HAWK
DOVE
GAME
NOW
LET
SEE
HOW
TO
APPLY
THESE
IDEAS
TO
THE
HAWK
DOVE
GAME
FIRST
SINCE
ANY
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
MUST
CORRESPOND
TO
A
MIXED
NASH
EQUILIBRIUM
OF
THE
GAME
THIS
GIVES
US
A
WAY
TO
SEARCH
FOR
POSSIBLE
EVOLUTIONARILY
STABLE
STRATEGIES
WE
FIRST
WORK
OUT
THE
MIXED
NASH
EQUILIBRIA
FOR
THE
HAWK
DOVE
AND
THEN
WE
CHECK
IF
THEY
ARE
EVOLUTIONARILY
STABLE
AS
WE
SAW
IN
CHAPTER
IN
ORDER
FOR
P
P
TO
BE
A
MIXED
NASH
EQUILIBRIUM
IT
MUST
MAKE
THE
TWO
PLAYERS
INDIFFERENT
BETWEEN
THEIR
TWO
PURE
STRATEGIES
WHEN
THE
OTHER
PLAYER
IS
USING
THE
STRATEGY
P
THE
EXPECTED
PAYOFF
FROM
PLAYING
D
IS
P
WHILE
THE
EXPECTED
PAYOFF
FROM
PLAYING
H
IS
SETTING
THESE
TWO
QUANTITIES
EQUAL
TO
CAPTURE
THE
INDIFFERENCE
BETWEEN
THE
TWO
STRATEGIES
WE
GET
P
SO
IS
A
MIXED
NASH
EQUILIBRIUM
IN
THIS
CASE
BOTH
PURE
STRATEGIES
AS
WELL
AS
ANY
MIXTURE
BETWEEN
THEM
PRODUCE
AN
EXPECTED
PAYOFF
OF
WHEN
PLAYED
AGAINST
THE
STRATEGY
P
NOW
TO
SEE
WHETHER
P
IS
EVOLUTIONARILY
STABLE
WE
MUST
CHECK
INEQUALITY
WHEN
SOME
OTHER
MIXED
STRATEGY
Q
INVADES
AT
A
SMALL
LEVEL
X
HERE
IS
A
FIRST
OBSERVATION
THAT
MAKES
EVALUATING
THIS
INEQUALITY
A
BIT
EASIER
SINCE
P
P
IS
A
MIXED
NASH
EQUILIBRIUM
THAT
USES
BOTH
PURE
STRATEGIES
WE
HAVE
JUST
ARGUED
THAT
ALL
MIXED
STRATEGIES
Q
HAVE
THE
SAME
PAYOFF
WHEN
PLAYED
AGAINST
P
AS
A
RESULT
WE
HAVE
V
P
P
V
Q
P
FOR
ALL
Q
SUBTRACTING
THESE
TERMS
FROM
THE
LEFT
AND
RIGHT
OF
INEQUALITY
AND
THEN
DIVIDING
BY
X
WE
GET
THE
FOLLOWING
INEQUALITY
TO
CHECK
V
P
Q
V
Q
Q
THE
POINT
IS
THAT
SINCE
P
P
IS
A
MIXED
EQUILIBRIUM
THE
STRATEGY
P
CAN
T
BE
A
STRICT
BEST
RESPONSE
TO
ITSELF
ALL
OTHER
MIXED
STRATEGIES
ARE
JUST
AS
GOOD
AGAINST
IT
THEREFORE
IN
ORDER
FOR
P
TO
BE
EVOLUTIONARILY
STABLE
IT
MUST
BE
A
STRICTLY
BETTER
RESPONSE
TO
EVERY
OTHER
MIXED
STRATEGY
Q
THAN
Q
IS
TO
ITSELF
THAT
IS
WHAT
WILL
CAUSE
IT
TO
HAVE
HIGHER
FITNESS
WHEN
Q
INVADES
IN
FACT
IT
IS
TRUE
THAT
V
P
Q
V
Q
Q
FOR
ALL
MIXED
STRATEGIES
Q
P
AND
WE
CAN
CHECK
THIS
AS
FOLLOWS
USING
THE
FACT
THAT
P
WE
HAVE
V
P
Q
Q
Q
Q
WHILE
NOW
WE
HAVE
V
Q
Q
Q
Q
Q
Q
V
P
Q
V
Q
Q
THIS
LAST
WAY
OF
WRITING
V
P
Q
V
Q
Q
SHOWS
THAT
IT
IS
A
PERFECT
SQUARE
AND
SO
IT
IS
POSITIVE
WHENEVER
Q
THIS
IS
JUST
WHAT
WE
WANT
FOR
SHOWING
THAT
V
P
Q
V
Q
Q
WHENEVER
Q
P
AND
SO
IT
FOLLOWS
THAT
P
IS
INDEED
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
INTERPRETATIONS
OF
EVOLUTIONARILY
STABLE
MIXED
STRATEGIES
THE
KIND
OF
MIXED
EQUI
LIBRIUM
THAT
WE
SEE
HERE
IN
THE
HAWK
DOVE
GAME
IS
TYPICAL
OF
BIOLOGICAL
SITUATIONS
IN
WHICH
ORGANISMS
MUST
BREAK
THE
SYMMETRY
BETWEEN
TWO
DISTINCT
BEHAVIORS
WHEN
CONSISTENTLY
ADOPTING
JUST
ONE
OF
THESE
BEHAVIORS
IS
EVOLUTIONARILY
UNSUSTAINABLE
WE
CAN
INTERPRET
THE
RESULT
OF
THIS
EXAMPLE
IN
TWO
POSSIBLE
WAYS
FIRST
ALL
PARTICIPANTS
IN
THE
POPULATION
MAY
ACTUALLY
BE
MIXING
OVER
THE
TWO
POSSIBLE
PURE
STRATEGIES
WITH
THE
GIVEN
PROBABILITY
IN
THIS
CASE
ALL
MEMBERS
OF
THE
POPULATION
ARE
GENETICALLY
THE
SAME
BUT
WHENEVER
TWO
OF
THEM
ARE
MATCHED
UP
TO
PLAY
ANY
COMBINATION
OF
D
AND
H
COULD
POTENTIALLY
BE
PLAYED
WE
KNOW
THE
EMPIRICAL
FREQUENCY
WITH
WHICH
ANY
PAIR
OF
STRATEGIES
WILL
BE
PLAYED
BUT
NOT
WHAT
ANY
TWO
ANIMALS
WILL
ACTUALLY
DO
A
SECOND
INTERPRETATION
IS
THAT
THE
MIXTURE
IS
TAKING
PLACE
AT
THE
POPULATION
LEVEL
IT
COULD
BE
THAT
OF
THE
ANIMALS
ARE
HARD
WIRED
TO
ALWAYS
PLAY
D
AND
ARE
HARD
WIRED
TO
ALWAYS
PLAY
H
IN
THIS
CASE
NO
INDIVIDUAL
IS
ACTUALLY
MIXING
BUT
AS
LONG
AS
IT
IS
NOT
POSSIBLE
TO
TELL
IN
ADVANCE
WHICH
ANIMAL
WILL
PLAY
D
AND
WHICH
WILL
PLAY
H
THE
INTERACTION
OF
TWO
RANDOMLY
SELECTED
ANIMALS
RESULTS
IN
THE
SAME
FREQUENCY
OF
OUTCOMES
THAT
WE
SEE
WHEN
EACH
ANIMAL
IS
ACTUALLY
MIXING
NOTICE
ALSO
THAT
IN
THIS
CASE
THE
FITNESSES
OF
BOTH
KINDS
OF
ANIMALS
ARE
THE
SAME
SINCE
BOTH
D
AND
H
ARE
BEST
RESPONSES
TO
THE
MIXED
STRATEGY
P
THUS
THESE
TWO
DIFFERENT
INTERPRETATION
OF
THE
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
LEAD
TO
THE
SAME
CALCULATIONS
AND
THE
SAME
OBSERVED
BEHAVIOR
IN
THE
POPULATION
THERE
ARE
A
NUMBER
OF
OTHER
SETTINGS
IN
WHICH
THIS
TYPE
OF
MIXING
BETWEEN
PURE
STRATEGIES
HAS
BEEN
DISCUSSED
IN
BIOLOGY
A
COMMON
SCENARIO
IS
THAT
THERE
IS
AN
UNDESIRABLE
FITNESS
LOWERING
ROLE
IN
A
POPULATION
OF
ORGANISMS
BUT
IF
SOME
ORGANISMS
DON
T
CHOOSE
TO
PLAY
THIS
ROLE
THEN
EVERYONE
SUFFERS
CONSIDERABLY
FOR
EXAMPLE
LET
THINK
BACK
TO
THE
VIRUS
GAME
IN
FIGURE
AND
SUPPOSE
PURELY
HYPOTHETICALLY
FOR
THE
SAKE
OF
THIS
EXAMPLE
THAT
THE
PAYOFF
WHEN
BOTH
VIRUSES
USE
THE
STRATEGY
WERE
AS
SHOWN
IN
FIGURE
VIRUS
VIRUS
50
FIGURE
THE
VIRUS
GAME
HYPOTHETICAL
PAYOFFS
WITH
STRONGER
FITNESS
PENALTIES
TO
IN
THIS
EVENT
RATHER
THAN
HAVING
A
PRISONER
DILEMMA
TYPE
OF
PAYOFF
STRUCTURE
WE
D
HAVE
A
HAWK
DOVE
PAYOFF
STRUCTURE
HAVING
BOTH
VIRUSES
PLAY
IS
SUFFICIENTLY
BAD
THAT
ONE
OF
THEM
NEEDS
TO
PLAY
THE
ROLE
OF
THE
TWO
PURE
EQUILIBRIA
OF
THE
RESULTING
TWO
PLAYER
GAME
VIEWED
AS
A
GAME
AMONG
RATIONAL
PLAYERS
RATHER
THAN
A
BIOLOGICAL
INTERACTION
WOULD
BE
AND
IN
A
VIRUS
POPULATION
WE
D
EXPECT
TO
FIND
AN
EVOLUTIONARILY
STABLE
MIXED
STRATEGY
IN
WHICH
BOTH
KINDS
OF
VIRUS
BEHAVIOR
WERE
OBSERVED
THIS
EXAMPLE
LIKE
THE
EXAMPLES
FROM
OUR
EARLIER
DISCUSSION
OF
THE
HAWK
DOVE
GAME
IN
SECTION
SUGGESTS
THE
DELICATE
BOUNDARY
THAT
EXISTS
BETWEEN
PRISONER
DILEMMA
AND
HAWK
DOVE
IN
BOTH
CASES
A
PLAYER
CAN
CHOOSE
TO
BE
HELPFUL
TO
THE
OTHER
PLAYER
OR
SELFISH
IN
PRISONER
DILEMMA
HOWEVER
THE
PAYOFF
PENALTIES
FROM
SELFISHNESS
ARE
MILD
ENOUGH
THAT
SELFISHNESS
BY
BOTH
PLAYERS
IS
THE
UNIQUE
EQUILIBRIUM
WHILE
IN
HAWK
DOVE
SELFISHNESS
IS
SUFFICIENTLY
HARMFUL
THAT
AT
LEAST
ONE
PLAYER
SHOULD
TRY
TO
AVOID
IT
THERE
HAS
BEEN
RESEARCH
INTO
HOW
THIS
BOUNDARY
BETWEEN
THE
TWO
GAMES
MANIFESTS
ITSELF
IN
OTHER
BIOLOGICAL
SETTINGS
AS
WELL
ONE
EXAMPLE
IS
THE
IMPLICIT
GAME
PLAYED
BY
FEMALE
LIONS
IN
DEFENDING
THEIR
TERRITORY
WHEN
TWO
FEMALE
LIONS
ENCOUNTER
AN
ATTACKER
ON
THE
EDGE
OF
THEIR
TERRITORY
EACH
CAN
CHOOSE
TO
PLAY
THE
STRATEGY
CONFRONT
IN
WHICH
SHE
CONFRONTS
THE
ATTACKER
OR
LAG
IN
WHICH
SHE
LAGS
BEHIND
AND
TRIES
TO
LET
THE
OTHER
LION
CONFRONT
THE
ATTACKER
FIRST
IF
YOU
RE
ONE
OF
THE
LIONS
AND
YOUR
FELLOW
DEFENDER
CHOOSES
THE
STRATEGY
CONFRONT
THEN
YOU
GET
A
HIGHER
PAYOFF
BY
CHOOSING
LAG
SINCE
YOU
RE
LESS
LIKELY
TO
GET
INJURED
WHAT
HARDER
TO
DETERMINE
IN
EMPIRICAL
STUDIES
IS
WHAT
A
LION
BEST
RESPONSE
SHOULD
BE
TO
A
PLAY
OF
LAG
BY
HER
PARTNER
CHOOSING
CONFRONT
RISKS
INJURY
BUT
JOINING
YOUR
PARTNER
IN
LAG
RISKS
A
SUCCESSFUL
ASSAULT
ON
THE
TERRITORY
BY
THE
ATTACKER
UNDERSTANDING
WHICH
IS
THE
BEST
RESPONSE
IS
IMPORTANT
FOR
UNDERSTANDING
WHETHER
THIS
GAME
IS
MORE
LIKE
PRISONER
DILEMMA
OR
HAWK
DOVE
AND
WHAT
THE
EVOLUTIONARY
CONSEQUENCES
MIGHT
BE
FOR
THE
OBSERVED
BEHAVIOR
WITHIN
A
LION
POPULATION
IN
THIS
AS
IN
MANY
EXAMPLES
FROM
EVOLUTIONARY
GAME
THEORY
IT
IS
BEYOND
THE
POWER
OF
CURRENT
EMPIRICAL
STUDIES
TO
WORK
OUT
DETAILED
FITNESS
VALUES
FOR
PARTICULAR
STRATEGIES
HOW
EVER
EVEN
IN
SITUATIONS
WHERE
EXACT
PAYOFFS
ARE
NOT
KNOWN
THE
EVOLUTIONARY
FRAMEWORK
CAN
PROVIDE
AN
ILLUMINATING
PERSPECTIVE
ON
THE
INTERACTIONS
BETWEEN
DIFFERENT
FORMS
OF
BEHAV
IOR
IN
AN
UNDERLYING
POPULATION
AND
HOW
THESE
INTERACTIONS
SHAPE
THE
COMPOSITION
OF
THE
POPULATION
EXERCISES
IN
THE
PAYOFF
MATRIX
BELOW
THE
ROWS
CORRESPOND
TO
PLAYER
A
STRATEGIES
AND
THE
COLUMNS
CORRESPOND
TO
PLAYER
B
STRATEGIES
THE
FIRST
ENTRY
IN
EACH
BOX
IS
PLAYER
A
PAYOFF
AND
THE
SECOND
ENTRY
IS
PLAYER
B
PAYOFF
PLAYER
A
X
Y
PLAYER
B
X
Y
A
FIND
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
B
FIND
ALL
EVOLUTIONARILY
STABLE
STRATEGIES
GIVE
A
BRIEF
EXPLANATION
FOR
YOUR
ANSWER
C
BRIEFLY
EXPLAIN
HOW
THE
SETS
OF
PREDICTED
OUTCOMES
RELATE
TO
EACH
OTHER
IN
THE
PAYOFF
MATRIX
BELOW
THE
ROWS
CORRESPOND
TO
PLAYER
A
STRATEGIES
AND
THE
COLUMNS
CORRESPOND
TO
PLAYER
B
STRATEGIES
THE
FIRST
ENTRY
IN
EACH
BOX
IS
PLAYER
A
PAYOFF
AND
THE
SECOND
ENTRY
IS
PLAYER
B
PAYOFF
PLAYER
A
X
Y
PLAYER
B
X
Y
A
FIND
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
B
FIND
ALL
EVOLUTIONARILY
STABLE
STRATEGIES
GIVE
A
BRIEF
EXPLANATION
FOR
YOUR
ANSWER
C
BRIEFLY
EXPLAIN
HOW
THE
ANSWERS
IN
PARTS
AND
RELATE
TO
EACH
OTHER
IN
THIS
PROBLEM
WE
WILL
CONSIDER
THE
RELATIONSHIP
BETWEEN
NASH
EQUILIBRIA
AND
EVOLU
TIONARILY
STABLE
STRATEGIES
FOR
GAMES
WITH
A
STRICTLY
DOMINANT
STRATEGY
FIRST
LET
DEFINE
WHAT
WE
MEAN
BY
STRICTLY
DOMINANT
IN
A
TWO
PLAYER
GAME
STRATEGY
X
IS
SAID
TO
BE
A
STRICTLY
DOMINANT
STRATEGY
FOR
A
PLAYER
I
IF
NO
MATTER
WHAT
STRATEGY
THE
OTHER
PLAYER
J
USES
PLAYER
I
PAYOFF
FROM
USING
STRATEGY
X
IS
STRICTLY
GREATER
THAN
HIS
PAYOFF
FROM
ANY
OTHER
STRATEGY
CONSIDER
THE
FOLLOWING
GAME
IN
WHICH
A
B
C
AND
D
ARE
NON
NEGATIVE
NUMBERS
PLAYER
A
X
Y
PLAYER
B
X
Y
A
A
B
C
C
B
D
D
SUPPOSE
THAT
STRATEGY
X
IS
A
STRICTLY
DOMINANT
STRATEGY
FOR
EACH
PLAYER
I
E
A
C
AND
B
D
A
FIND
ALL
OF
THE
PURE
STRATEGY
NASH
EQUILIBRIA
OF
THIS
GAME
B
FIND
ALL
OF
THE
EVOLUTIONARILY
STABLE
STRATEGIES
OF
THIS
GAME
C
HOW
WOULD
YOUR
ANSWERS
TO
PARTS
A
AND
B
CHANGE
IF
WE
CHANGE
THE
ASSUMPTION
ON
PAYOFFS
TO
A
C
AND
B
D
PLAYER
A
X
Y
PLAYER
B
X
Y
X
X
CONSIDER
FOLLOWING
THE
TWO
PLAYER
SYMMETRIC
GAME
WHERE
X
CAN
BE
OR
A
FOR
EACH
OF
THE
POSSIBLE
VALUES
OF
X
FIND
ALL
PURE
STRATEGY
NASH
EQUILIBRIA
AND
ALL
EVOLUTIONARILY
STABLE
STRATEGIES
B
YOUR
ANSWERS
TO
PART
A
SHOULD
SUGGEST
THAT
THE
DIFFERENCE
BETWEEN
THE
PREDICTIONS
OF
EVOLUTIONARY
STABILITY
AND
NASH
EQUILIBRIUM
ARISES
WHEN
A
NASH
EQUILIBRIUM
USES
A
WEAKLY
DOMINATED
STRATEGY
WE
SAY
THAT
A
STRATEGY
I
IS
WEAKLY
DOMINATED
IF
PLAYER
I
HAS
ANOTHER
STRATEGY
STI
WITH
THE
PROPERTY
THAT
A
NO
MATTER
WHAT
THE
OTHER
PLAYER
DOES
PLAYER
I
PAYOFF
FROM
STI
IS
AT
LEAST
AS
LARGE
AS
THE
PAYOFF
FROM
I
AND
B
THERE
IS
SOME
STRATEGY
FOR
THE
OTHER
PLAYER
SO
THAT
PLAYER
I
PAYOFF
FROM
STI
IS
STRICTLY
GREATER
THAN
THE
PAYOFF
FROM
I
NOW
CONSIDER
THE
FOLLOWING
CLAIM
THAT
MAKES
A
CONNECTION
BETWEEN
EVOLUTIONARILY
STABLE
STRATEGIES
AND
WEAKLY
DOMINATED
STRATEGIES
CLAIM
SUPPOSE
THAT
IN
THE
GAME
BELOW
X
X
IS
A
NASH
EQUILIBRIUM
AND
THAT
STRATEGY
X
IS
WEAKLY
DOMINATED
THEN
X
IS
NOT
AN
EVOLUTIONARILY
STABLE
STRATEGY
PLAYER
A
X
Y
PLAYER
B
X
Y
A
A
B
C
C
B
D
D
EXPLAIN
WHY
THIS
CLAIM
IS
TRUE
YOU
DO
NOT
NEED
TO
WRITE
A
FORMAL
PROOF
A
CAREFUL
EXPLANATION
IS
FINE
CHAPTER
MODELING
NETWORK
TRAFFIC
USING
GAME
THEORY
AMONG
THE
INITIAL
EXAMPLES
IN
OUR
DISCUSSION
OF
GAME
THEORY
IN
CHAPTER
WE
NOTED
THAT
TRAVELING
THROUGH
A
TRANSPORTATION
NETWORK
OR
SENDING
PACKETS
THROUGH
THE
INTERNET
INVOLVES
FUNDAMENTALLY
GAME
THEORETIC
REASONING
RATHER
THAN
SIMPLY
CHOOSING
A
ROUTE
IN
ISOLATION
INDIVIDUALS
NEED
TO
EVALUATE
ROUTES
IN
THE
PRESENCE
OF
THE
CONGESTION
RESULTING
FROM
THE
DECISIONS
MADE
BY
THEMSELVES
AND
EVERYONE
ELSE
IN
THIS
CHAPTER
WE
DEVELOP
MODELS
FOR
NETWORK
TRAFFIC
USING
THE
GAME
THEORETIC
IDEAS
WE
VE
DEVELOPED
THUS
FAR
IN
THE
PROCESS
OF
DOING
THIS
WE
WILL
DISCOVER
A
RATHER
UNEXPECTED
RESULT
KNOWN
AS
BRAESS
PARADOX
WHICH
SHOWS
THAT
ADDING
CAPACITY
TO
A
NETWORK
CAN
SOMETIMES
ACTUALLY
SLOW
DOWN
THE
TRAFFIC
TRAFFIC
AT
EQUILIBRIUM
LET
BEGIN
BY
DEVELOPING
A
MODEL
OF
A
TRANSPORTATION
NETWORK
AND
HOW
IT
RESPONDS
TO
TRAFFIC
CONGESTION
WITH
THIS
IN
PLACE
WE
CAN
THEN
INTRODUCE
THE
GAME
THEORETIC
ASPECTS
OF
THE
PROBLEM
WE
REPRESENT
A
TRANSPORTATION
NETWORK
BY
A
DIRECTED
GRAPH
WE
CONSIDER
THE
EDGES
TO
BE
HIGHWAYS
AND
THE
NODES
TO
BE
EXITS
WHERE
YOU
CAN
GET
ON
OR
OFF
A
PARTICULAR
HIGHWAY
THERE
ARE
TWO
PARTICULAR
NODES
WHICH
WE
LL
CALL
A
AND
B
AND
WE
LL
ASSUME
EVERYONE
WANTS
TO
DRIVE
FROM
A
TO
B
FOR
EXAMPLE
WE
CAN
IMAGINE
THAT
A
IS
AN
EXIT
IN
THE
SUBURBS
B
IS
AN
EXIT
DOWNTOWN
AND
WE
RE
LOOKING
AT
A
LARGE
COLLECTION
OF
MORNING
COMMUTERS
FINALLY
EACH
EDGE
HAS
A
DESIGNATED
TRAVEL
TIME
THAT
DEPENDS
ON
THE
AMOUNT
OF
TRAFFIC
IT
CONTAINS
TO
MAKE
THIS
CONCRETE
CONSIDER
THE
GRAPH
IN
FIGURE
THE
LABEL
ON
EACH
EDGE
GIVES
THE
D
EASLEY
AND
J
KLEINBERG
NETWORKS
CROWDS
AND
MARKETS
REASONING
ABOUT
A
HIGHLY
CONNECTED
WORLD
CAMBRIDGE
UNIVERSITY
PRESS
DRAFT
VERSION
JUNE
FIGURE
A
HIGHWAY
NETWORK
WITH
EACH
EDGE
LABELED
BY
ITS
TRAVEL
TIME
IN
MINUTES
WHEN
THERE
ARE
X
CARS
USING
IT
WHEN
CARS
NEED
TO
GET
FROM
A
TO
B
THEY
DIVIDE
EVENLY
OVER
THE
TWO
ROUTES
AT
EQUILIBRIUM
AND
THE
TRAVEL
TIME
IS
MINUTES
TRAVEL
TIME
IN
MINUTES
WHEN
THERE
ARE
X
CARS
USING
THE
EDGE
IN
THIS
SIMPLIFIED
EXAMPLE
THE
A
D
AND
C
B
EDGES
ARE
INSENSITIVE
TO
CONGESTION
EACH
TAKES
MINUTES
TO
TRAVERSE
REGARDLESS
OF
THE
NUMBER
OF
CARS
TRAVELING
ON
THEM
ON
THE
OTHER
HAND
THE
A
C
AND
D
B
EDGES
ARE
HIGHLY
SENSITIVE
TO
CONGESTION
FOR
EACH
ONE
IT
TAKES
X
MINUTES
TO
TRAVERSE
WHEN
THERE
ARE
X
CARS
USING
THE
EDGE
NOW
SUPPOSE
THAT
CARS
WANT
TO
GET
FROM
A
TO
B
AS
PART
OF
THE
MORNING
COMMUTE
THERE
ARE
TWO
POSSIBLE
ROUTES
THAT
EACH
CAR
CAN
CHOOSE
THE
UPPER
ROUTE
THROUGH
C
OR
THE
LOWER
ROUTE
THROUGH
D
FOR
EXAMPLE
IF
EACH
CAR
TAKES
THE
UPPER
ROUTE
THROUGH
C
THEN
THE
TOTAL
TRAVEL
TIME
FOR
EVERYONE
IS
MINUTES
SINCE
THE
SAME
IS
TRUE
IF
EVERYONE
TAKES
THE
LOWER
ROUTE
ON
THE
OTHER
HAND
IF
THE
CARS
DIVIDE
UP
EVENLY
BETWEEN
THE
TWO
ROUTES
SO
THAT
EACH
CARRIES
CARS
THEN
THE
TOTAL
TRAVEL
TIME
FOR
PEOPLE
ON
BOTH
ROUTES
IS
EQUILIBRIUM
TRAFFIC
SO
WHAT
DO
WE
EXPECT
WILL
HAPPEN
THE
TRAFFIC
MODEL
WE
VE
DESCRIBED
IS
REALLY
A
GAME
IN
WHICH
THE
PLAYERS
CORRESPOND
TO
THE
DRIVERS
AND
EACH
PLAYER
POSSIBLE
STRATEGIES
CONSIST
OF
THE
POSSIBLE
ROUTES
FROM
A
TO
B
IN
OUR
EXAMPLE
THIS
MEANS
THAT
EACH
PLAYER
ONLY
HAS
TWO
STRATEGIES
BUT
IN
LARGER
NETWORKS
THERE
COULD
BE
MANY
STRATEGIES
FOR
EACH
PLAYER
THE
PAYOFF
FOR
A
PLAYER
IS
THE
NEGATIVE
OF
HIS
OR
HER
TRAVEL
TIME
WE
USE
THE
NEGATIVE
SINCE
LARGE
TRAVEL
TIMES
ARE
BAD
TRAVEL
TIMES
HERE
ARE
SIMPLIFIED
TO
MAKE
THE
REASONING
CLEARER
IN
ANY
REAL
APPLICATION
EACH
ROAD
WOULD
HAVE
BOTH
SOME
MINIMUM
TRAVEL
TIME
AND
SOME
SENSITIVITY
TO
THE
NUMBER
OF
CARS
X
THAT
ARE
USING
IT
HOWEVER
THE
ANALYSIS
HERE
ADAPTS
DIRECTLY
TO
MORE
INTRICATE
FUNCTIONS
SPECIFYING
THE
TRAVEL
TIMES
ON
EDGES
BRAESS
PARADOX
THIS
ALL
FITS
VERY
NATURALLY
INTO
THE
FRAMEWORK
WE
VE
BEEN
USING
ONE
THING
TO
NOTICE
OF
COURSE
IS
THAT
UP
TO
NOW
WE
HAVE
FOCUSED
PRIMARILY
ON
GAMES
WITH
TWO
PLAYERS
WHEREAS
THE
CURRENT
GAME
WILL
GENERALLY
HAVE
AN
ENORMOUS
NUMBER
OF
PLAYERS
IN
OUR
EXAMPLE
BUT
THIS
POSES
NO
DIRECT
PROBLEM
FOR
APPLYING
ANY
OF
THE
IDEAS
WE
VE
DEVELOPED
A
GAME
CAN
HAVE
ANY
NUMBER
OF
PLAYERS
EACH
OF
WHOM
CAN
HAVE
ANY
NUMBER
OF
AVAILABLE
STRATEGIES
AND
THE
PAYOFF
TO
EACH
PLAYER
DEPENDS
ON
THE
STRATEGIES
CHOSEN
BY
ALL
A
NASH
EQUILIBRIUM
IS
STILL
A
LIST
OF
STRATEGIES
ONE
FOR
EACH
PLAYER
SO
THAT
EACH
PLAYER
STRATEGY
IS
A
BEST
RESPONSE
TO
ALL
THE
OTHERS
THE
NOTIONS
OF
DOMINANT
STRATEGIES
MIXED
STRATEGIES
AND
NASH
EQUILIBRIUM
WITH
MIXED
STRATEGIES
ALL
HAVE
DIRECT
PARALLELS
WITH
THEIR
DEFINITIONS
FOR
TWO
PLAYER
GAMES
IN
THIS
TRAFFIC
GAME
THERE
IS
GENERALLY
NOT
A
DOMINANT
STRATEGY
FOR
EXAMPLE
IN
FIGURE
EITHER
ROUTE
HAS
THE
POTENTIAL
TO
BE
THE
BEST
CHOICE
FOR
A
PLAYER
IF
ALL
THE
OTHER
PLAYERS
ARE
USING
THE
OTHER
ROUTE
THE
GAME
DOES
HAVE
NASH
EQUILIBRIA
HOWEVER
AS
WE
WILL
SEE
NEXT
ANY
LIST
OF
STRATEGIES
IN
WHICH
THE
DRIVERS
BALANCE
THEMSELVES
EVENLY
BETWEEN
THE
TWO
ROUTES
ON
EACH
IS
A
NASH
EQUILIBRIUM
AND
THESE
ARE
THE
ONLY
NASH
EQUILIBRIA
WHY
DOES
EQUAL
BALANCE
YIELD
A
NASH
EQUILIBRIUM
AND
WHY
DO
ALL
NASH
EQUILIBRIA
HAVE
EQUAL
BALANCE
TO
ANSWER
THE
FIRST
QUESTION
WE
JUST
OBSERVE
THAT
WITH
AN
EVEN
BALANCE
BETWEEN
THE
TWO
ROUTES
NO
DRIVER
HAS
AN
INCENTIVE
TO
SWITCH
OVER
TO
THE
OTHER
ROUTE
FOR
THE
SECOND
QUESTION
CONSIDER
A
LIST
OF
STRATEGIES
IN
WHICH
X
DRIVERS
USE
THE
UPPER
ROUTE
AND
THE
REMAINING
X
DRIVERS
USE
THE
LOWER
ROUTE
THEN
IF
X
IS
NOT
EQUAL
TO
THE
TWO
ROUTES
WILL
HAVE
UNEQUAL
TRAVEL
TIMES
AND
ANY
DRIVER
ON
THE
SLOWER
ROUTE
WOULD
HAVE
AN
INCENTIVE
TO
SWITCH
TO
THE
FASTER
ONE
HENCE
ANY
LIST
OF
STRATEGIES
IN
WHICH
X
IS
NOT
EQUAL
TO
CANNOT
BE
A
NASH
EQUILIBRIUM
AND
ANY
LIST
OF
STRATEGIES
IN
WHICH
X
IS
A
NASH
EQUILIBRIUM
BRAESS
PARADOX
IN
FIGURE
EVERYTHING
WORKS
OUT
VERY
CLEANLY
SELF
INTERESTED
BEHAVIOR
BY
ALL
DRIVERS
CAUSES
THEM
AT
EQUILIBRIUM
TO
BALANCE
PERFECTLY
BETWEEN
THE
AVAILABLE
ROUTES
BUT
WITH
ONLY
A
SMALL
CHANGE
TO
THE
NETWORK
WE
CAN
QUICKLY
FIND
OURSELVES
IN
TRULY
COUNTERINTUITIVE
TERRITORY
THE
CHANGE
IS
AS
FOLLOWS
SUPPOSE
THAT
THE
CITY
GOVERNMENT
DECIDES
TO
BUILD
A
NEW
VERY
FAST
HIGHWAY
FROM
C
TO
D
AS
INDICATED
IN
FIGURE
TO
KEEP
THINGS
SIMPLE
WE
LL
MODEL
ITS
TRAVEL
TIME
AS
REGARDLESS
OF
THE
NUMBER
OF
CARS
ON
IT
ALTHOUGH
THE
RESULTING
EFFECT
WOULD
HAPPEN
EVEN
WITH
MORE
REALISTIC
BUT
SMALL
TRAVEL
TIMES
IT
WOULD
STAND
TO
REASON
THAT
PEOPLE
TRAVEL
TIME
FROM
A
TO
B
OUGHT
TO
GET
BETTER
AFTER
THIS
EDGE
FROM
C
TO
D
IS
ADDED
DOES
IT
HERE
THE
SURPRISE
THERE
IS
A
UNIQUE
NASH
EQUILIBRIUM
IN
THIS
NEW
HIGHWAY
NETWORK
BUT
IT
LEADS
TO
A
WORSE
TRAVEL
TIME
FOR
EVERYONE
AT
EQUILIBRIUM
EVERY
DRIVER
USES
THE
ROUTE
THROUGH
BOTH
C
AND
D
AND
AS
A
RESULT
THE
TRAVEL
TIME
FOR
EVERY
DRIVER
IS
SINCE
TO
SEE
WHY
THIS
IS
AN
EQUILIBRIUM
NOTE
THAT
NO
DRIVER
CAN
FIGURE
THE
HIGHWAY
NETWORK
FROM
THE
PREVIOUS
FIGURE
AFTER
A
VERY
FAST
EDGE
HAS
BEEN
ADDED
FROM
C
TO
D
ALTHOUGH
THE
HIGHWAY
SYSTEM
HAS
BEEN
UPGRADED
THE
TRAVEL
TIME
AT
EQUILIBRIUM
IS
NOW
MINUTES
SINCE
ALL
CARS
USE
THE
ROUTE
THROUGH
C
AND
D
BENEFIT
BY
CHANGING
THEIR
ROUTE
WITH
TRAFFIC
SNAKING
THROUGH
C
AND
D
THE
WAY
IT
IS
ANY
OTHER
ROUTE
WOULD
NOW
TAKE
MINUTES
AND
TO
SEE
WHY
IT
THE
ONLY
EQUILIBRIUM
YOU
CAN
CHECK
THAT
THE
CREATION
OF
THE
EDGE
FROM
C
TO
D
HAS
IN
FACT
MADE
THE
ROUTE
THROUGH
C
AND
D
A
DOMINANT
STRATEGY
FOR
ALL
DRIVERS
REGARDLESS
OF
THE
CURRENT
TRAFFIC
PATTERN
YOU
GAIN
BY
SWITCHING
YOUR
ROUTE
TO
GO
THROUGH
C
AND
D
IN
OTHER
WORDS
ONCE
THE
FAST
HIGHWAY
FROM
C
TO
D
IS
BUILT
THE
ROUTE
THROUGH
C
AND
D
ACTS
LIKE
A
VORTEX
THAT
DRAWS
ALL
DRIVERS
INTO
IT
TO
THE
DETRIMENT
OF
ALL
IN
THE
NEW
NETWORK
THERE
IS
NO
WAY
GIVEN
INDIVIDUALLY
SELF
INTERESTED
BEHAVIOR
BY
THE
DRIVERS
TO
GET
BACK
TO
THE
EVEN
BALANCE
SOLUTION
THAT
WAS
BETTER
FOR
EVERYONE
THIS
PHENOMENON
THAT
ADDING
RESOURCES
TO
A
TRANSPORTATION
NETWORK
CAN
SOMETIMES
HURT
PERFORMANCE
AT
EQUILIBRIUM
WAS
FIRST
ARTICULATED
BY
DIETRICH
BRAESS
IN
AND
IT
HAS
BECOME
KNOWN
AS
BRAESS
PARADOX
LIKE
MANY
COUNTERINTUITIVE
ANOMALIES
IT
NEEDS
THE
RIGHT
COMBINATION
OF
CONDITIONS
TO
ACTUALLY
POP
UP
IN
REAL
LIFE
BUT
IT
HAS
BEEN
OBSERVED
EMPIRICALLY
IN
REAL
TRANSPORTATION
NETWORKS
INCLUDING
IN
SEOUL
KOREA
WHERE
THE
DESTRUCTION
OF
A
SIX
LANE
HIGHWAY
TO
BUILD
A
PUBLIC
PARK
ACTUALLY
IMPROVED
TRAVEL
TIME
INTO
AND
OUT
OF
THE
CITY
EVEN
THOUGH
TRAFFIC
VOLUME
STAYED
ROUGHLY
THE
SAME
BEFORE
AND
AFTER
THE
CHANGE
SOME
REFLECTIONS
ON
BRAESS
PARADOX
HAVING
NOW
SEEN
HOW
BRAESS
PARADOX
WORKS
WE
CAN
ALSO
APPRECIATE
THAT
THERE
IS
ACTUALLY
NOTHING
REALLY
PARADOXICAL
ABOUT
IT
THERE
ARE
MANY
SETTINGS
IN
WHICH
ADDING
A
NEW
STRATEGY
TO
A
GAME
MAKES
THINGS
WORSE
FOR
EVERYONE
FOR
EXAMPLE
THE
PRISONER
DILEMMA
FROM
CHAPTER
CAN
BE
USED
TO
ILLUSTRATE
THIS
POINT
IF
THE
ONLY
STRATEGY
FOR
EACH
PLAYER
WERE
NOT
CONFESS
AN
ADMITTEDLY
VERY
SIMPLE
GAME
THEN
BOTH
PLAYERS
WOULD
BE
BETTER
OFF
COMPARED
WITH
THE
GAME
WHERE
CONFESS
IS
ADDED
AS
AN
OPTION
INDEED
THAT
WHY
THE
POLICE
OFFER
CONFESS
AS
AN
OPTION
IN
THE
FIRST
PLACE
STILL
IT
REASONABLE
TO
VIEW
THE
ANALOGOUS
PHENOMENON
AT
THE
HEART
OF
THE
BRAESS
PARADOX
AS
MORE
PARADOXICAL
AT
AN
INTUITIVE
LEVEL
WE
ALL
HAVE
AN
INFORMAL
SENSE
THAT
UPGRADING
A
NETWORK
HAS
TO
BE
A
GOOD
THING
AND
SO
IT
IS
SURPRISING
WHEN
IT
TURNS
OUT
TO
MAKE
THINGS
WORSE
THE
EXAMPLE
IN
THIS
SECTION
IS
ACTUALLY
THE
STARTING
POINT
FOR
A
LARGE
BODY
OF
WORK
ON
GAME
THEORETIC
ANALYSIS
OF
NETWORK
TRAFFIC
FOR
EXAMPLE
WE
COULD
ASK
HOW
BAD
BRAESS
PARADOX
CAN
BE
FOR
NETWORKS
IN
GENERAL
HOW
MUCH
LARGER
CAN
THE
EQUILIBRIUM
TRAVEL
TIME
BE
AFTER
THE
ADDITION
OF
AN
EDGE
RELATIVE
TO
WHAT
IT
WAS
BEFORE
SUPPOSE
IN
PARTICULAR
THAT
WE
ALLOW
THE
GRAPH
TO
BE
ARBITRARY
AND
WE
ASSUME
THAT
THE
TRAVEL
TIME
ON
EACH
EDGE
DEPENDS
IN
A
LINEAR
WAY
ON
THE
NUMBER
OF
CARS
TRAVERSING
IT
THAT
IS
ALL
TRAVEL
TIMES
ACROSS
EDGES
HAVE
THE
FORM
AX
B
WHERE
EACH
OF
A
AND
B
IS
EITHER
OR
A
POSITIVE
NUMBER
IN
THIS
CASE
ELEGANT
RESULTS
OF
TIM
ROUGHGARDEN
AND
E
VA
TARDOS
CAN
BE
USED
TO
SHOW
THAT
IF
WE
ADD
EDGES
TO
A
NETWORK
WITH
AN
EQUILIBRIUM
PATTERN
OF
TRAFFIC
THERE
IS
ALWAYS
AN
EQUILIBRIUM
IN
THE
NEW
NETWORK
WHOSE
TRAVEL
TIME
IS
NO
MORE
THAN
TIMES
AS
LARGE
MOREOVER
IS
THE
FACTOR
INCREASE
THAT
WE
D
GET
IN
THE
EXAMPLE
FROM
FIGURES
AND
IF
WE
REPLACE
THE
TWO
TRAVEL
TIMES
OF
WITH
IN
THAT
CASE
THE
TRAVEL
TIME
AT
EQUILIBRIUM
WOULD
JUMP
FROM
TO
WHEN
WE
ADD
THE
EDGE
FROM
C
TO
D
SO
THE
ROUGHGARDEN
TARDOS
RESULT
SHOWS
THAT
THIS
SIMPLE
EXAMPLE
IS
AS
BAD
AS
THE
BRAESS
PARADOX
CAN
GET
IN
A
QUANTITATIVE
SENSE
WHEN
EDGES
RESPOND
LINEARLY
TO
TRAFFIC
WHEN
EDGES
CAN
RESPOND
NON
LINEARLY
THINGS
CAN
BE
MUCH
WORSE
THERE
ARE
MANY
OTHER
TYPES
OF
QUESTIONS
THAT
CAN
BE
PURSUED
AS
WELL
FOR
EXAMPLE
WE
COULD
THINK
ABOUT
WAYS
OF
DESIGNING
NETWORKS
TO
PREVENT
BAD
EQUILIBRIA
FROM
ARISING
OR
TO
AVOID
BAD
EQUILIBRIA
THROUGH
THE
JUDICIOUS
USE
OF
TOLLS
ON
CERTAIN
PARTS
OF
THE
NETWORK
MANY
OF
THESE
EXTENSIONS
AS
WELL
AS
OTHERS
ARE
DISCUSSED
BY
TIM
ROUGHGARDEN
IN
HIS
BOOK
ON
GAME
THEORETIC
MODELS
OF
NETWORK
TRAFFIC
ADVANCED
MATERIAL
THE
SOCIAL
COST
OF
TRAFFIC
AT
EQUILIBRIUM
THE
BRAESS
PARADOX
IS
ONE
ASPECT
OF
A
LARGER
PHENOMENON
WHICH
IS
THAT
NETWORK
TRAFFIC
AT
EQUILIBRIUM
MAY
NOT
BE
SOCIALLY
OPTIMAL
IN
THIS
SECTION
WE
TRY
TO
QUANTIFY
HOW
FAR
FROM
OPTIMAL
TRAFFIC
CAN
BE
AT
EQUILIBRIUM
WE
WOULD
LIKE
OUR
ANALYSIS
TO
APPLY
TO
ANY
NETWORK
AND
SO
WE
INTRODUCE
THE
FOLLOWING
GENERAL
DEFINITIONS
THE
NETWORK
CAN
BE
ANY
DIRECTED
GRAPH
THERE
IS
A
SET
OF
DRIVERS
AND
DIFFERENT
DRIVERS
MAY
HAVE
DIFFERENT
STARTING
POINTS
AND
DESTINATIONS
NOW
EACH
EDGE
E
HAS
A
TRAVEL
TIMES
WRITTEN
AS
EXPLICIT
FUNCTIONS
OF
X
B
TRAVEL
TIMES
WRITTEN
AS
ANNOTATIONS
ON
THE
EDGES
FIGURE
A
NETWORK
ANNOTATED
WITH
THE
TRAVEL
TIME
FUNCTION
ON
EACH
EDGE
A
TRAVEL
TIME
FUNCTION
TE
X
WHICH
GIVES
THE
TIME
IT
TAKES
ALL
DRIVERS
TO
CROSS
THE
EDGE
WHEN
THERE
ARE
X
DRIVERS
USING
IT
THESE
TRAVEL
TIMES
ARE
SIMPLY
THE
FUNCTIONS
THAT
WE
DREW
AS
LABELS
INSIDE
THE
EDGES
IN
THE
FIGURES
IN
SECTION
WE
WILL
ASSUME
THAT
ALL
TRAVEL
TIME
FUNCTIONS
ARE
LINEAR
IN
THE
AMOUNT
OF
TRAFFIC
SO
THAT
TE
X
AEX
BE
FOR
SOME
CHOICE
OF
NUMBERS
AE
AND
BE
THAT
ARE
EITHER
POSITIVE
OR
ZERO
FOR
EXAMPLE
IN
FIGURE
WE
DRAW
ANOTHER
NETWORK
ON
WHICH
BRAESS
PARADOX
ARISES
WITH
THE
TRAVEL
TIME
FUNCTIONS
SCALED
DOWN
TO
INVOLVE
SMALLER
NUMBERS
THE
VERSION
OF
THE
DRAWING
IN
FIGURE
A
HAS
THE
TRAVEL
TIME
FUNCTIONS
EXPLICITLY
WRITTEN
OUT
WHILE
THE
VERSION
OF
THE
DRAWING
IN
FIGURE
B
HAS
THE
TRAVEL
TIME
FUNCTIONS
WRITTEN
AS
LABELS
INSIDE
THE
EDGES
FINALLY
WE
SAY
THAT
A
TRAFFIC
PATTERN
IS
SIMPLY
A
CHOICE
OF
A
PATH
BY
EACH
DRIVER
AND
THE
SOCIAL
COST
OF
A
GIVEN
TRAFFIC
PATTERN
IS
THE
SUM
OF
THE
TRAVEL
TIMES
INCURRED
BY
ALL
DRIVERS
WHEN
THEY
USE
THIS
TRAFFIC
PATTERN
FOR
EXAMPLE
FIGURE
SHOWS
TWO
DIFFERENT
TRAFFIC
PATTERNS
ON
THE
NETWORK
FROM
FIGURE
WHEN
THERE
ARE
FOUR
DRIVERS
EACH
WITH
STARTING
NODE
A
AND
DESTINATION
NODE
B
THE
FIRST
OF
THESE
TRAFFIC
PATTERNS
IN
FIGURE
A
ACHIEVES
THE
MINIMUM
POSSIBLE
SOCIAL
COST
EACH
DRIVER
REQUIRES
UNITS
OF
TIME
TO
GET
TO
THEIR
DESTINATION
AND
SO
THE
SOCIAL
COST
IS
WE
WILL
REFER
TO
SUCH
A
TRAFFIC
PATTERN
WHICH
ACHIEVES
THE
MINIMUM
POSSIBLE
SOCIAL
COST
AS
SOCIALLY
OPTIMAL
THERE
ARE
OTHER
TRAFFIC
PATTERNS
ON
THIS
NETWORK
THAT
ALSO
ACHIEVE
A
SOCIAL
COST
OF
THAT
IS
THERE
ARE
MULTIPLE
TRAFFIC
PATTERNS
FOR
THIS
NETWORK
THAT
ARE
SOCIALLY
OPTIMAL
NOTE
THAT
SOCIALLY
OPTIMAL
TRAFFIC
PATTERNS
ARE
SIMPLY
THE
SOCIAL
WELFARE
MAXIMIZERS
OF
THIS
TRAFFIC
GAME
SINCE
THE
SUM
OF
THE
DRIVERS
PAYOFFS
IS
THE
NEGATIVE
OF
THE
SOCIAL
COST
THE
SECOND
TRAFFIC
PATTERN
FIGURE
B
IS
THE
UNIQUE
NASH
EQUILIBRIUM
AND
IT
HAS
A
LARGER
SOCIAL
COST
OF
THE
MAIN
TWO
QUESTIONS
WE
CONSIDER
IN
THE
REMAINDER
OF
THIS
CHAPTER
ARE
THE
FOLLOWING
FIRST
IN
ANY
NETWORK
WITH
LINEAR
TRAVEL
TIME
FUNCTIONS
IS
THERE
ALWAYS
AN
EQUILIBRIUM
TRAFFIC
A
THE
SOCIAL
OPTIMUM
B
THE
NASH
EQUILIBRIUM
FIGURE
A
VERSION
OF
BRAESS
PARADOX
IN
THE
SOCIALLY
OPTIMAL
TRAFFIC
PATTERN
ON
THE
LEFT
THE
SOCIAL
COST
IS
WHILE
IN
THE
UNIQUE
NASH
EQUILIBRIUM
ON
THE
RIGHT
THE
SOCIAL
COST
IS
PATTERN
WE
HAVE
SEEN
EXAMPLES
IN
CHAPTER
OF
GAMES
WHERE
EQUILIBRIA
DO
NOT
EXIST
USING
PURE
STRATEGIES
AND
IT
IS
NOT
A
PRIORI
CLEAR
THAT
THEY
SHOULD
ALWAYS
EXIST
FOR
THE
TRAFFIC
GAME
WE
VE
DEFINED
HERE
HOWEVER
WE
WILL
FIND
IN
FACT
THAT
EQUILIBRIA
ALWAYS
DO
EXIST
THE
SECOND
MAIN
QUESTION
IS
WHETHER
THERE
ALWAYS
EXISTS
AN
EQUILIBRIUM
TRAFFIC
PATTERN
WHOSE
SOCIAL
COST
IS
NOT
MUCH
MORE
THAN
THE
SOCIAL
OPTIMUM
WE
WILL
FIND
THAT
THIS
IS
IN
FACT
THE
CASE
WE
WILL
SHOW
A
RESULT
DUE
TO
ROUGHGARDEN
AND
TARDOS
THAT
THERE
IS
ALWAYS
AN
EQUILIBRIUM
WHOSE
SOCIAL
COST
IS
AT
MOST
TWICE
THAT
OF
THE
OPTIMUM
A
HOW
TO
FIND
A
TRAFFIC
PATTERN
AT
EQUILIBRIUM
WE
WILL
PROVE
THAT
AN
EQUILIBRIUM
EXISTS
BY
ANALYZING
THE
FOLLOWING
PROCEDURE
THAT
EXPLICITLY
SEARCHES
FOR
ONE
THE
PROCEDURE
STARTS
FROM
ANY
TRAFFIC
PATTERN
IF
IT
IS
AN
EQUILIBRIUM
WE
ARE
DONE
OTHERWISE
THERE
IS
AT
LEAST
ONE
DRIVER
WHOSE
BEST
RESPONSE
GIVEN
WHAT
EVERYONE
ELSE
IS
DOING
IS
SOME
ALTERNATE
PATH
PROVIDING
A
STRICTLY
LOWER
TRAVEL
TIME
WE
PICK
ONE
SUCH
DRIVER
AND
HAVE
HIM
SWITCH
TO
THIS
ALTERNATE
PATH
WE
NOW
HAVE
A
NEW
TRAFFIC
PATTERN
AND
WE
AGAIN
CHECK
WHETHER
IT
IS
AN
EQUILIBRIUM
IF
IT
ISN
T
THEN
WE
HAVE
SOME
DRIVER
SWITCH
TO
HIS
BEST
RESPONSE
AND
WE
CONTINUE
IN
THIS
FASHION
THIS
PROCEDURE
IS
CALLED
BEST
RESPONSE
DYNAMICS
SINCE
IT
DYNAMICALLY
RECONFIGURES
THE
FACT
STRONGER
RESULTS
OF
ROUGHGARDEN
AND
TARDOS
SUPPLEMENTED
BY
SUBSEQUENT
RESULTS
OF
ANSHELEVICH
ET
AL
ESTABLISH
THAT
IN
FACT
EVERY
EQUILIBRIUM
TRAFFIC
PATTERN
HAS
SOCIAL
COST
AT
MOST
TIMES
THE
OPTIMUM
ONE
CAN
SHOW
THAT
THIS
IMPLIES
THEIR
RESULT
ON
THE
BRAESS
PARADOX
CITED
IN
THE
PREVIOUS
SECTION
THAT
WITH
LINEAR
TRAVEL
TIMES
ADDING
EDGES
CAN
T
MAKE
THINGS
WORSE
BY
A
FACTOR
OF
MORE
THAN
HOWEVER
SINCE
IT
IS
HARDER
TO
PROVE
THE
BOUND
OF
WE
LIMIT
OURSELVES
HERE
TO
PROVING
THE
EASIER
BUT
WEAKER
FACTOR
OF
BETWEEN
THE
SOCIAL
OPTIMUM
AND
SOME
EQUILIBRIUM
TRAFFIC
PATTERN
PLAYERS
STRATEGIES
BY
CONSTANTLY
HAVING
SOME
PLAYER
PERFORM
HIS
OR
HER
BEST
RESPONSE
TO
THE
CURRENT
SITUATION
IF
THE
PROCEDURE
EVER
STOPS
IN
A
STATE
WHERE
EVERYONE
IS
IN
FACT
PLAYING
THEIR
BEST
RESPONSE
TO
THE
CURRENT
SITUATION
THEN
WE
HAVE
AN
EQUILIBRIUM
SO
THE
KEY
IS
TO
SHOW
THAT
IN
ANY
INSTANCE
OF
OUR
TRAFFIC
GAME
BEST
RESPONSE
DYNAMICS
MUST
EVENTUALLY
STOP
AT
AN
EQUILIBRIUM
BUT
WHY
SHOULD
IT
CERTAINLY
FOR
GAMES
THAT
LACK
AN
EQUILIBRIUM
BEST
RESPONSE
DYNAMICS
WILL
RUN
FOREVER
FOR
EXAMPLE
IN
THE
MATCHING
PENNIES
GAME
FROM
CHAPTER
WHEN
ONLY
PURE
STRATEGIES
ARE
ALLOWED
BEST
RESPONSE
DYNAMICS
WILL
SIMPLY
CONSIST
OF
THE
TWO
PLAYERS
ENDLESSLY
SWITCHING
THEIR
STRATEGIES
BETWEEN
H
AND
T
IT
SEEMS
PLAUSIBLE
THAT
FOR
SOME
NETWORK
THIS
COULD
HAPPEN
IN
THE
TRAFFIC
GAME
AS
WELL
ONE
AT
A
TIME
DRIVERS
SHIFT
THEIR
ROUTES
TO
ONES
THAT
ARE
BETTER
FOR
THEM
THUS
INCREASING
THE
DELAY
FOR
ANOTHER
DRIVER
WHO
THEN
SWITCHES
AND
CONTINUES
THE
CASCADE
IN
FACT
HOWEVER
THIS
CANNOT
HAPPEN
IN
THE
TRAFFIC
GAME
WE
NOW
SHOW
THAT
BEST
RESPONSE
DYNAMICS
MUST
ALWAYS
TERMINATE
IN
AN
EQUILIBRIUM
THUS
PROVING
NOT
ONLY
THAT
EQUILIBRIA
EXIST
BUT
ALSO
THAT
THEY
CAN
BE
REACHED
BY
A
SIMPLE
PROCESS
IN
WHICH
DRIVERS
CONSTANTLY
UPDATE
WHAT
THEY
RE
DOING
ACCORDING
TO
BEST
RESPONSES
ANALYZING
BEST
RESPONSE
DYNAMICS
VIA
POTENTIAL
ENERGY
HOW
SHOULD
WE
GO
ABOUT
PROVING
THAT
BEST
RESPONSE
DYNAMICS
MUST
COME
TO
A
HALT
WHEN
YOU
HAVE
A
PROCESS
THAT
RUNS
ACCORDING
TO
SOME
SET
OF
INSTRUCTIONS
LIKE
DO
THE
FOLLOWING
TEN
THINGS
AND
THEN
STOP
IT
GENERALLY
OBVIOUS
THAT
IT
WILL
EVENTUALLY
COME
TO
AN
END
THE
PROCESS
ESSENTIALLY
COMES
WITH
ITS
OWN
GUARANTEE
OF
TERMINATION
BUT
WE
HAVE
A
PROCESS
THAT
RUNS
ACCORDING
TO
A
DIFFERENT
KIND
OF
RULE
ONE
THAT
SAYS
KEEP
DOING
SOMETHING
UNTIL
A
PARTICULAR
CONDITION
HAPPENS
TO
HOLD
IN
THIS
CASE
THERE
IS
NO
A
PRIORI
REASON
TO
BELIEVE
IT
WILL
EVER
STOP
IN
SUCH
CASES
A
USEFUL
ANALYSIS
TECHNIQUE
IS
TO
DEFINE
SOME
KIND
OF
PROGRESS
MEASURE
THAT
TRACKS
THE
PROCESS
AS
IT
OPERATES
AND
TO
SHOW
THAT
EVENTUALLY
ENOUGH
PROGRESS
WILL
BE
MADE
THAT
THE
PROCESS
MUST
STOP
FOR
THE
TRAFFIC
GAME
IT
NATURAL
TO
THINK
OF
THE
SOCIAL
COST
OF
THE
CURRENT
TRAFFIC
PATTERN
AS
A
POSSIBLE
PROGRESS
MEASURE
BUT
IN
FACT
THE
SOCIAL
COST
IS
NOT
SO
USEFUL
FOR
THIS
PURPOSE
SOME
BEST
RESPONSE
UPDATES
BY
DRIVERS
CAN
MAKE
THE
SOCIAL
COST
BETTER
FOR
EXAMPLE
IF
A
DRIVER
LEAVES
A
CONGESTED
ROAD
FOR
A
RELATIVELY
EMPTY
ONE
BUT
OTHERS
CAN
MAKE
IT
WORSE
AS
IN
THE
SEQUENCE
OF
BEST
RESPONSE
UPDATES
THAT
SHIFTS
THE
TRAFFIC
PATTERN
FROM
THE
SOCIAL
OPTIMUM
TO
THE
INFERIOR
EQUILIBRIUM
IN
THE
BRAESS
PARADOX
SO
IN
GENERAL
AS
BEST
RESPONSE
DYNAMICS
RUNS
THE
SOCIAL
COST
OF
THE
CURRENT
TRAFFIC
PATTERN
CAN
OSCILLATE
BETWEEN
GOING
UP
AND
GOING
DOWN
AND
IT
NOT
CLEAR
HOW
THIS
IS
RELATED
TO
OUR
PROGRESS
TOWARD
AN
EQUILIBRIUM
INSTEAD
WE
RE
GOING
TO
DEFINE
AN
ALTERNATE
QUANTITY
THAT
INITIALLY
SEEMS
A
BIT
MYSTERIOUS
HOWEVER
WE
WILL
SEE
THAT
IT
HAS
THE
PROPERTY
THAT
IT
STRICTLY
DECREASES
WITH
EACH
BEST
RESPONSE
UPDATE
AND
SO
IT
CAN
BE
USED
TO
TRACK
THE
PROGRESS
OF
BEST
RESPONSE
DYNAMICS
WE
WILL
REFER
TO
THIS
QUANTITY
AS
THE
POTENTIAL
ENERGY
OF
A
TRAFFIC
PATTERN
THE
POTENTIAL
ENERGY
OF
A
TRAFFIC
PATTERN
IS
DEFINED
EDGE
BY
EDGE
AS
FOLLOWS
IF
AN
EDGE
E
CURRENTLY
HAS
X
DRIVERS
ON
IT
THEN
WE
DEFINE
THE
POTENTIAL
ENERGY
OF
THIS
EDGE
TO
BE
ENERGY
E
TE
TE
TE
X
IF
AN
EDGE
HAS
NO
DRIVERS
ON
IT
ITS
POTENTIAL
ENERGY
IS
DEFINED
TO
BE
THE
POTENTIAL
ENERGY
OF
A
TRAFFIC
PATTERN
IS
THEN
SIMPLY
THE
SUM
OF
THE
POTENTIAL
ENERGIES
OF
ALL
THE
EDGES
WITH
THEIR
CURRENT
NUMBER
OF
DRIVERS
IN
THIS
TRAFFIC
PATTERN
IN
FIGURE
WE
SHOW
THE
POTENTIAL
ENERGY
OF
EACH
EDGE
FOR
THE
FIVE
TRAFFIC
PATTERNS
THAT
BEST
RESPONSE
DYNAMICS
PRODUCES
AS
IT
MOVES
FROM
THE
SOCIAL
OPTIMUM
TO
THE
UNIQUE
EQUILIBRIUM
IN
THE
BRAESS
PARADOX
NETWORK
FROM
FIGURE
NOTICE
THAT
THE
POTENTIAL
ENERGY
OF
AN
EDGE
E
WITH
X
DRIVERS
IS
NOT
THE
TOTAL
TRAVEL
TIME
EXPERIENCED
BY
THE
DRIVERS
THAT
CROSS
IT
SINCE
THERE
ARE
X
DRIVERS
EACH
EXPERIENCING
A
TRAVEL
TIME
OF
TE
X
THEIR
TOTAL
TRAVEL
TIME
IS
XTE
X
WHICH
IS
A
DIFFERENT
NUMBER
THE
POTENTIAL
ENERGY
INSTEAD
IS
A
SORT
OF
CUMULATIVE
QUANTITY
IN
WHICH
WE
IMAGINE
DRIVERS
CROSSING
THE
EDGE
ONE
BY
ONE
AND
EACH
DRIVER
ONLY
FEELS
THE
DELAY
CAUSED
BY
HIMSELF
AND
THE
DRIVERS
CROSSING
THE
EDGE
IN
FRONT
OF
HIM
OF
COURSE
THE
POTENTIAL
ENERGY
IS
ONLY
USEFUL
FOR
OUR
PURPOSE
IF
IT
LETS
US
ANALYZE
THE
PROGRESS
OF
BEST
RESPONSE
DYNAMICS
WE
SHOW
HOW
TO
DO
THIS
NEXT
PROVING
THAT
BEST
RESPONSE
DYNAMICS
COMES
TO
AN
END
OUR
MAIN
CLAIM
IS
THE
FOLLOWING
EACH
STEP
OF
BEST
RESPONSE
DYNAMICS
CAUSES
THE
POTENTIAL
ENERGY
OF
THE
CURRENT
TRAFFIC
PATTERN
TO
STRICTLY
DECREASE
PROVING
THIS
WILL
BE
ENOUGH
TO
SHOW
THAT
BEST
RESPONSE
DYNAMICS
MUST
COME
TO
AN
END
FOR
THE
FOLLOWING
REASON
THE
POTENTIAL
ENERGY
CAN
ONLY
TAKE
A
FINITE
NUMBER
OF
POSSIBLE
VALUES
ONE
FOR
EACH
POSSIBLE
TRAFFIC
PATTERN
IF
IT
IS
STRICTLY
DECREASING
WITH
EACH
STEP
OF
BEST
RESPONSE
DYNAMICS
THIS
MEANS
THAT
IT
IS
CONSUMING
THIS
FINITE
SUPPLY
OF
POSSIBLE
VALUES
SINCE
IT
CAN
NEVER
REVISIT
A
VALUE
ONCE
IT
DROPS
BELOW
IT
SO
BEST
RESPONSE
DYNAMICS
MUST
COME
TO
A
STOP
BY
THE
TIME
THE
POTENTIAL
ENERGY
REACHES
ITS
MINIMUM
POSSIBLE
VALUE
IF
NOT
SOONER
AND
ONCE
BEST
RESPONSE
DYNAMICS
COMES
TO
A
STOP
WE
MUST
BE
AT
AN
EQUILIBRIUM
FOR
OTHERWISE
THE
DYNAMICS
WOULD
HAVE
A
WAY
TO
CONTINUE
THUS
SHOWING
THAT
THE
POTENTIAL
ENERGY
STRICTLY
DECREASES
IN
EVERY
STEP
OF
BEST
RESPONSE
DYNAMICS
IS
ENOUGH
TO
SHOW
THE
EXISTENCE
OF
AN
EQUILIBRIUM
TRAFFIC
PATTERN
AS
AN
EXAMPLE
LET
RETURN
TO
THE
SEQUENCE
OF
BEST
RESPONSE
STEPS
FROM
FIGURE
AL
THOUGH
THE
SOCIAL
COST
IS
RISING
THROUGH
THE
FIVE
TRAFFIC
PATTERNS
INCREASING
FROM
TO
THE
POTENTIAL
ENERGY
DECREASES
STRICTLY
IN
EACH
STEP
IN
THE
SEQUENCE
IN
FACT
IT
IS
EASY
TO
TRACK
THE
CHANGE
IN
POTENTIAL
ENERGY
THROUGH
THIS
SEQUENCE
AS
FOLLOWS
FROM
ONE
TRAFFIC
PATTERN
TO
THE
NEXT
THE
ONLY
CHANGE
IS
THAT
ONE
DRIVER
ABANDONS
HIS
CURRENT
PATH
AND
SWITCHES
TO
A
NEW
ONE
SUPPOSE
WE
REALLY
VIEW
THIS
SWITCH
AS
A
TWO
STEP
PROCESS
FIRST
THE
A
THE
INITIAL
TRAFFIC
PATTERN
POTENTIAL
ENERGY
IS
B
AFTER
ONE
STEP
OF
BEST
RESPONSE
DYNAMICS
PO
TENTIAL
ENERGY
IS
C
AFTER
TWO
STEPS
POTENTIAL
ENERGY
IS
D
AFTER
THREE
STEPS
POTENTIAL
ENERGY
IS
E
AFTER
FOUR
STEPS
EQUILIBRIUM
IS
REACHED
POTENTIAL
ENERGY
IS
FIGURE
WE
CAN
TRACK
THE
PROGRESS
OF
BEST
RESPONSE
DYNAMICS
IN
THE
TRAFFIC
GAME
BY
WATCHING
HOW
THE
POTENTIAL
ENERGY
CHANGES
A
THE
POTENTIAL
ENERGY
OF
A
TRAFFIC
PATTERN
NOT
IN
EQUILIBRIUM
B
POTENTIAL
ENERGY
IS
RELEASED
WHEN
A
DRIVER
ABAN
DONS
THEIR
CURRENT
PATH
C
POTENTIAL
ENERGY
IS
PUT
BACK
INTO
THE
SYSTEM
WHEN
THE
DRIVER
CHOOSES
A
NEW
PATH
FIGURE
WHEN
A
DRIVER
ABANDONS
ONE
PATH
IN
FAVOR
OF
ANOTHER
THE
CHANGE
IN
POTENTIAL
ENERGY
IS
EXACTLY
THE
IMPROVEMENT
IN
THE
DRIVER
TRAVEL
TIME
DRIVERS
ABANDONS
HIS
CURRENT
PATH
TEMPORARILY
LEAVING
THE
SYSTEM
THEN
THE
DRIVER
RETURNS
TO
THE
SYSTEM
BY
ADOPTING
A
NEW
PATH
THIS
FIRST
STEP
RELEASES
POTENTIAL
ENERGY
AS
THE
DRIVER
LEAVES
THE
SYSTEM
AND
THE
SECOND
STEP
ADDS
POTENTIAL
ENERGY
AS
HE
RE
JOINS
WHAT
THE
NET
CHANGE
FOR
EXAMPLE
THE
TRANSITION
FROM
FIGURE
A
TO
B
OCCURS
BECAUSE
ONE
DRIVER
ABAN
DONS
THE
UPPER
PATH
AND
ADOPTS
THE
ZIGZAG
PATH
AS
SHOWN
IN
FIGURE
ABANDONING
THE
UPPER
PATH
RELEASES
UNITS
OF
POTENTIAL
ENERGY
WHILE
ADOPTING
THE
ZIGZAG
PATH
PUTS
UNITS
OF
POTENTIAL
ENERGY
BACK
INTO
THE
SYSTEM
THE
RESULTING
CHANGE
IS
A
DECREASE
OF
NOTICE
THAT
THE
DECREASE
OF
IS
SIMPLY
THE
TRAVEL
TIME
THE
DRIVER
WAS
EXPERIENCING
ON
THE
PATH
HE
ABANDONED
AND
THE
SUBSEQUENT
INCREASE
OF
IS
THE
TRAVEL
TIME
THE
DRIVER
NOW
EXPERIENCES
ON
THE
PATH
HE
HAS
ADOPTED
THIS
RELATIONSHIP
IS
IN
FACT
TRUE
FOR
ANY
NETWORK
AND
ANY
BEST
RESPONSE
BY
A
DRIVER
AND
IT
HOLDS
FOR
A
SIMPLE
REASON
SPECIFICALLY
THE
POTENTIAL
ENERGY
OF
EDGE
E
WITH
X
DRIVERS
IS
TE
TE
TE
X
TE
X
AND
WHEN
ONE
OF
THESE
DRIVERS
LEAVES
IT
DROPS
TO
TE
TE
TE
X
HENCE
THE
CHANGE
IN
POTENTIAL
ENERGY
ON
EDGE
E
IS
TE
X
EXACTLY
THE
TRAVEL
TIME
THAT
THE
DRIVER
WAS
EXPERIENCING
ON
E
SUMMING
THIS
OVER
ALL
EDGES
USED
BY
THE
DRIVER
WE
SEE
THAT
THE
POTENTIAL
ENERGY
RELEASED
WHEN
A
DRIVER
ABANDONS
HIS
CURRENT
PATH
IS
EXACTLY
EQUAL
TO
THE
TRAVEL
TIME
THE
DRIVER
WAS
EXPERIENCING
BY
THE
SAME
REASONING
WHEN
A
DRIVER
ADOPTS
A
NEW
PATH
THE
POTENTIAL
ENERGY
ON
EACH
EDGE
E
HE
JOINS
INCREASES
FROM
TE
TE
TE
X
TO
TE
TE
TE
X
TE
X
AND
THE
INCREASE
OF
TE
X
IS
EXACTLY
THE
NEW
TRAVEL
TIME
THE
DRIVER
EXPERIENCES
ON
THIS
EDGE
HENCE
THE
POTENTIAL
ENERGY
ADDED
TO
THE
SYSTEM
WHEN
A
DRIVER
ADOPTS
A
NEW
PATH
IS
EXACTLY
EQUAL
TO
THE
TRAVEL
TIME
THE
DRIVER
NOW
EXPERIENCES
IT
FOLLOWS
WHEN
A
DRIVER
SWITCHES
PATHS
THE
NET
CHANGE
IN
POTENTIAL
ENERGY
IS
SIMPLY
HIS
NEW
TRAVEL
TIME
MINUS
HIS
OLD
TRAVEL
TIME
BUT
IN
BEST
RESPONSE
DYNAMICS
A
DRIVER
ONLY
CHANGES
PATHS
WHEN
IT
CAUSES
HIS
TRAVEL
TIME
TO
DECREASE
SO
THE
CHANGE
IN
POTENTIAL
ENERGY
IS
NEGATIVE
FOR
ANY
BEST
RESPONSE
MOVE
THIS
ESTABLISHES
WHAT
WE
WANTED
TO
SHOW
THAT
THE
POTENTIAL
ENERGY
IN
THE
SYSTEM
STRICTLY
DECREASES
THROUGHOUT
BEST
RESPONSE
DYNAMICS
AS
ARGUED
ABOVE
SINCE
THE
POTENTIAL
ENERGY
CANNOT
DECREASE
FOREVER
BEST
RESPONSE
DYNAMICS
MUST
THEREFORE
EVENTUALLY
COME
TO
AN
END
AT
A
TRAFFIC
PATTERN
IN
EQUILIBRIUM
B
COMPARING
EQUILIBRIUM
TRAFFIC
TO
THE
SOCIAL
OPTIMUM
HAVING
SHOWN
THAT
AN
EQUILIBRIUM
TRAFFIC
PATTERN
ALWAYS
EXISTS
WE
NOW
CONSIDER
HOW
ITS
TRAVEL
TIME
COMPARES
TO
THAT
OF
A
SOCIALLY
OPTIMAL
TRAFFIC
PATTERN
WE
WILL
SEE
THAT
THE
POTENTIAL
ENERGY
WE
VE
DEFINED
IS
VERY
USEFUL
FOR
MAKING
THIS
COMPARISON
THE
BASIC
IDEA
IS
TO
ESTABLISH
A
RELATIONSHIP
BETWEEN
THE
POTENTIAL
ENERGY
OF
AN
EDGE
AND
THE
TOTAL
TRAVEL
TIME
OF
ALL
DRIVERS
CROSSING
THE
EDGE
ONCE
WE
DO
THIS
WE
WILL
SUM
THESE
TWO
QUANTITIES
OVER
ALL
THE
EDGES
TO
COMPARE
TRAVEL
TIMES
AT
EQUIIBRIUM
AND
AT
SOCIAL
OPTIMALITY
FIGURE
THE
POTENTIAL
ENERGY
IS
THE
AREA
UNDER
THE
SHADED
RECTANGLES
IT
IS
ALWAYS
AT
LEAST
HALF
THE
TOTAL
TRAVEL
TIME
WHICH
IS
THE
AREA
INSIDE
THE
ENCLOSING
RECTANGLE
RELATING
POTENTIAL
ENERGY
TO
TRAVEL
TIME
FOR
A
SINGLE
EDGE
WE
DENOTE
THE
PO
TENTIAL
ENERGY
OF
AN
EDGE
BY
ENERGY
E
AND
WE
RECALL
THAT
WHEN
THERE
ARE
X
DRIVERS
THIS
POTENTIAL
ENERGY
IS
DEFINED
BY
ENERGY
E
TE
TE
TE
X
ON
THE
OTHER
HAND
EACH
OF
THE
X
DRIVERS
EXPERIENCES
A
TRAVEL
TIME
OF
TE
X
AND
SO
THE
TOTAL
TRAVEL
TIME
EXPERIENCED
BY
ALL
DRIVERS
ON
THE
EDGE
IS
TOTAL
TRAVEL
TIME
E
XTE
X
FOR
PURPOSES
OF
COMPARISON
WITH
THE
POTENTIAL
ENERGY
IT
IS
USEFUL
TO
WRITE
THIS
AS
FOLLOWS
TOTAL
TRAVEL
TIME
E
TE
X
TE
X
TE
X
X
T
E
RMS
SINCE
THE
POTENTIAL
ENERGY
AND
THE
TOTAL
TRAVEL
TIME
EACH
HAVE
X
TERMS
BUT
THE
TERMS
IN
THE
LATTER
EXPRESSION
ARE
AT
LEAST
AS
LARGE
AS
THE
TERMS
IN
THE
FORMER
WE
HAVE
ENERGY
E
TOTAL
TRAVEL
TIME
E
FIGURE
SHOWS
HOW
THE
POTENTIAL
ENERGY
AND
THE
TOTAL
TRAVEL
TIME
COMPARE
WHEN
TE
IS
A
LINEAR
FUNCTION
THE
TOTAL
TRAVEL
TIME
IS
THE
SHADED
AREA
UNDER
THE
HORIZONTAL
LINE
WITH
Y
VALUE
TE
X
WHILE
THE
POTENTIAL
ENERGY
IS
THE
TOTAL
AREA
UNDER
ALL
THE
UNIT
WIDTH
RECTANGLES
OF
HEIGHTS
TE
TE
TE
X
AS
THIS
FIGURE
MAKES
CLEAR
GEOMETRICALLY
SINCE
TE
IS
A
LINEAR
FUNCTION
WE
HAVE
TE
TE
TE
X
XTE
X
ALTERNATELY
WE
CAN
SEE
THIS
BY
A
BIT
OF
SIMPLE
ALGEBRA
RECALLING
THAT
TE
X
AEX
BE
TE
TE
TE
X
AE
X
BEX
AEX
X
B
X
E
X
AE
X
B
E
X
AEX
BE
XTE
X
IN
TERMS
OF
ENERGIES
AND
TOTAL
TRAVEL
TIMES
THIS
SAYS
ENERGY
E
TOTAL
TRAVEL
TIME
E
SO
THE
CONCLUSION
IS
THAT
THE
POTENTIAL
ENERGY
OF
AN
EDGE
IS
NEVER
FAR
FROM
THE
TOTAL
TRAVEL
TIME
IT
IS
SANDWICHED
BETWEEN
THE
TOTAL
TRAVEL
TIME
AND
HALF
THE
TOTAL
TRAVEL
TIME
RELATING
THE
TRAVEL
TIME
AT
EQUILIBRIUM
AND
SOCIAL
OPTIMALITY
WE
NOW
USE
THIS
RELATIONSHIP
BETWEEN
POTENTIAL
ENERGY
AND
TOTAL
TRAVEL
TO
RELATE
THE
EQUILIBRIUM
AND
SOCIALLY
OPTIMAL
TRAFFIC
PATTERNS
LET
Z
BE
A
TRAFFIC
PATTERN
WE
DEFINE
ENERGY
Z
TO
BE
THE
TOTAL
POTENTIAL
ENERGY
OF
ALL
EDGES
WHEN
DRIVERS
FOLLOW
THE
TRAFFIC
PATTERN
Z
WE
WRITE
SOCIAL
COST
Z
TO
DENOTE
THE
SOCIAL
COST
OF
THE
TRAFFIC
PATTERN
RECALL
THAT
THIS
IS
THE
SUM
OF
THE
TRAVEL
TIMES
EXPERIENCED
BY
ALL
DRIVERS
EQUIVALENTLY
SUMMING
THE
SOCIAL
COST
EDGE
BY
EDGE
SOCIAL
COST
Z
IS
THE
SUM
OF
THE
TOTAL
TRAVEL
TIMES
ON
ALL
THE
EDGES
SO
APPLYING
OUR
RELATIONSHIPS
BETWEEN
POTENTIAL
ENERGY
AND
TRAVEL
TIME
ON
AN
EDGE
BY
EDGE
BASIS
WE
SEE
THAT
THE
SAME
RELATIONSHIPS
GOVERN
THE
POTENTIAL
ENERGY
AND
SOCIAL
COST
OF
A
TRAFFIC
PATTERN
SOCIAL
COST
Z
ENERGY
Z
SOCIAL
COST
Z
NOW
SUPPOSE
THAT
WE
START
FROM
A
SOCIALLY
OPTIMAL
TRAFFIC
PATTERN
Z
AND
WE
THEN
ALLOW
BEST
RESPONSE
DYNAMICS
TO
RUN
UNTIL
THEY
STOP
AT
AN
EQUILIBRIUM
TRAFFIC
PATTERN
ZT
THE
SOCIAL
COST
MAY
START
INCREASING
AS
WE
RUN
BEST
RESPONSE
DYNAMICS
BUT
THE
POTENTIAL
ENERGY
CAN
ONLY
GO
DOWN
AND
SINCE
THE
SOCIAL
COST
CAN
NEVER
BE
MORE
THAN
TWICE
THE
POTENTIAL
ENERGY
THIS
SHRINKING
POTENTIAL
ENERGY
KEEPS
THE
SOCIAL
COST
FROM
EVER
GETTING
MORE
THAN
TWICE
AS
HIGH
AS
WHERE
IT
STARTED
THIS
SHOWS
THAT
THE
SOCIAL
COST
OF
THE
EQUILIBRIUM
WE
REACH
IS
AT
MOST
TWICE
THE
COST
OF
THE
SOCIAL
OPTIMUM
WE
STARTED
WITH
HENCE
THERE
IS
AN
EQUILIBRIUM
WITH
AT
MOST
TWICE
THE
SOCIALLY
OPTIMAL
COST
AS
WE
WANTED
TO
SHOW
LET
WRITE
THIS
ARGUMENT
OUT
IN
TERMS
OF
THE
INEQUALITIES
ON
ENERGIES
AND
SOCIAL
COSTS
FIRST
WE
SAW
IN
THE
PREVIOUS
SECTION
THAT
THE
POTENTIAL
ENERGY
DECREASES
AS
BEST
RESPONSE
DYNAMICS
MOVES
FROM
Z
TO
ZT
AND
SO
ENERGY
ZT
ENERGY
Z
SECOND
THE
QUANTITATIVE
RELATIONSHIPS
BETWEEN
ENERGIES
AND
SOCIAL
COST
SAY
THAT
SOCIAL
COST
ZT
ENERGY
ZT
AND
ENERGY
Z
SOCIAL
COST
Z
NOW
WE
JUST
CHAIN
THESE
INEQUALITIES
TOGETHER
CONCLUDING
THAT
SOCIAL
COST
ZT
ENERGY
ZT
ENERGY
Z
SOCIAL
COST
Z
NOTE
THAT
THIS
REALLY
IS
THE
SAME
ARGUMENT
THAT
WE
MADE
IN
WORDS
IN
THE
PREVIOUS
PARAGRAPH
THE
POTENTIAL
ENERGY
DECREASES
DURING
BEST
RESPONSE
DYNAMICS
AND
THIS
DECREASE
PREVENTS
THE
SOCIAL
COST
FROM
EVERY
INCREASING
BY
MORE
THAN
A
FACTOR
OF
TWO
THUS
TRACKING
POTENTIAL
ENERGY
IS
NOT
ONLY
USEFUL
FOR
SHOWING
THAT
BEST
RESPONSE
DYNAMICS
MUST
REACH
AN
EQUILIBRIUM
BY
RELATING
THIS
POTENTIAL
ENERGY
TO
THE
SOCIAL
COST
WE
CAN
USE
IT
TO
PUT
A
BOUND
ON
THE
SOCIAL
COST
OF
THE
EQUILIBRIUM
THAT
IS
REACHED
EXERCISES
THERE
ARE
CARS
WHICH
MUST
TRAVEL
FROM
TOWN
A
TO
TOWN
B
THERE
ARE
TWO
POSSIBLE
ROUTES
THAT
EACH
CAR
CAN
TAKE
THE
UPPER
ROUTE
THROUGH
TOWN
C
OR
THE
LOWER
ROUTE
THROUGH
TOWN
D
LET
X
BE
THE
NUMBER
OF
CARS
TRAVELING
ON
THE
EDGE
AC
AND
LET
Y
BE
THE
NUMBER
OF
CARS
TRAVELING
ON
THE
EDGE
DB
THE
DIRECTED
GRAPH
IN
FIGURE
INDICATES
THAT
TRAVEL
TIME
PER
CAR
ON
EDGE
AC
IS
X
IF
X
CARS
USE
EDGE
AC
AND
SIMILARLY
THE
TRAVEL
TIME
PER
CAR
ON
EDGE
DB
IS
Y
IF
Y
CARS
USE
EDGE
DB
THE
TRAVEL
TIME
PER
CAR
ON
EACH
OF
EDGES
CB
AND
AD
IS
REGARDLESS
OF
THE
NUMBER
OF
CARS
ON
THESE
EDGES
EACH
DRIVER
WANTS
TO
SELECT
A
ROUTE
TO
MINIMIZE
HIS
TRAVEL
TIME
THE
DRIVERS
MAKE
SIMULTANEOUS
CHOICES
A
FIND
NASH
EQUILIBRIUM
VALUES
OF
X
AND
Y
B
NOW
THE
GOVERNMENT
BUILDS
A
NEW
ONE
WAY
ROAD
FROM
TOWN
C
TO
TOWN
D
THE
NEW
ROAD
ADDS
THE
PATH
ACDB
TO
THE
NETWORK
THIS
NEW
ROAD
FROM
C
TO
D
HAS
A
TRAVEL
FIGURE
TRAFFIC
NETWORK
TIME
OF
PER
CAR
REGARDLESS
OF
THE
NUMBER
OF
CARS
THAT
USE
IT
FIND
A
NASH
EQUILIBRIUM
FOR
THE
GAME
PLAYED
ON
THE
NEW
NETWORK
WHAT
ARE
THE
EQUILIBRIUM
VALUES
OF
X
AND
Y
WHAT
HAPPENS
TO
TOTAL
COST
OF
TRAVEL
THE
SUM
OF
TOTAL
TRAVEL
TIMES
FOR
THE
CARS
AS
A
RESULT
OF
THE
AVAILABILITY
OF
THE
NEW
ROAD
C
SUPPOSE
NOW
THAT
CONDITIONS
ON
EDGES
CB
AND
AD
ARE
IMPROVED
SO
THAT
THE
TRAVEL
TIMES
ON
EACH
EDGE
ARE
REDUCED
TO
THE
ROAD
FROM
C
TO
D
THAT
WAS
CONSTRUCTED
IN
PART
B
IS
STILL
AVAILABLE
FIND
A
NASH
EQUILIBRIUM
FOR
THE
GAME
PLAYED
ON
THE
NETWORK
WITH
THE
SMALLER
TRAVEL
TIMES
FOR
CB
AND
AD
WHAT
ARE
THE
EQUILIBRIUM
VALUES
OF
X
AND
Y
WHAT
IS
THE
TOTAL
COST
OF
TRAVEL
WHAT
WOULD
HAPPEN
TO
THE
TOTAL
COST
OF
TRAVEL
IF
THE
GOVERNMENT
CLOSED
THE
ROAD
FROM
C
TO
D
THERE
ARE
TWO
CITIES
A
AND
B
JOINED
BY
TWO
ROUTES
THERE
ARE
TRAVELERS
WHO
BEGIN
IN
CITY
A
AND
MUST
TRAVEL
TO
CITY
B
THERE
ARE
TWO
ROUTES
BETWEEN
A
AND
B
ROUTE
I
BEGINS
WITH
A
HIGHWAY
LEAVING
CITY
A
THIS
HIGHWAY
TAKES
ONE
HOUR
OF
TRAVEL
TIME
REGARDLESS
OF
HOW
MANY
TRAVELERS
USE
IT
AND
ENDS
WITH
A
LOCAL
STREET
LEADING
INTO
CITY
B
THIS
LOCAL
STREET
NEAR
CITY
B
REQUIRES
A
TRAVEL
TIME
IN
MINUTES
EQUAL
TO
PLUS
THE
NUMBER
OF
TRAVELERS
WHO
USE
THE
STREET
ROUTE
II
BEGINS
WITH
A
LOCAL
STREET
LEAVING
CITY
A
WHICH
REQUIRES
A
TRAVEL
TIME
IN
MINUTES
EQUAL
TO
PLUS
THE
NUMBER
OF
TRAVELERS
WHO
USE
THIS
STREET
AND
ENDS
WITH
A
HIGHWAY
INTO
CITY
B
WHICH
REQUIRES
ONE
HOUR
OF
TRAVEL
TIME
REGARDLESS
OF
THE
NUMBER
OF
TRAVELERS
WHO
USE
THIS
HIGHWAY
A
DRAW
THE
NETWORK
DESCRIBED
ABOVE
AND
LABEL
THE
EDGES
WITH
THE
TRAVEL
TIME
NEEDED
TO
MOVE
ALONG
THE
EDGE
LET
X
BE
THE
NUMBER
OF
TRAVELERS
WHO
USE
ROUTE
I
THE
NETWORK
SHOULD
BE
A
DIRECTED
GRAPH
AS
ALL
ROADS
ARE
ONE
WAY
B
TRAVELERS
SIMULTANEOUSLY
CHOSE
WHICH
ROUTE
TO
USE
FIND
THE
NASH
EQUILIBRIUM
VALUE
OF
X
C
NOW
THE
GOVERNMENT
BUILDS
A
NEW
TWO
WAY
ROAD
CONNECTING
THE
NODES
WHERE
LOCAL
STREETS
AND
HIGHWAYS
MEET
THIS
ADDS
TWO
NEW
ROUTES
ONE
NEW
ROUTE
CONSISTS
OF
THE
FIGURE
TRAFFIC
NETWORK
LOCAL
STREET
LEAVING
CITY
A
ON
ROUTE
II
THE
NEW
ROAD
AND
THE
LOCAL
STREET
INTO
CITY
B
ON
ROUTE
I
THE
SECOND
NEW
ROUTE
CONSISTS
OF
THE
HIGHWAY
LEAVING
CITY
A
ON
ROUTE
I
THE
NEW
ROAD
AND
THE
HIGHWAY
LEADING
INTO
CITY
B
ON
ROUTE
II
THE
NEW
ROAD
IS
VERY
SHORT
AND
TAKES
NO
TRAVEL
TIME
FIND
THE
NEW
NASH
EQUILIBRIUM
HINT
THERE
IS
AN
EQUILIBRIUM
IN
WHICH
NO
ONE
CHOOSES
TO
USE
THE
SECOND
NEW
ROUTE
DESCRIBED
ABOVE
D
WHAT
HAPPENS
TO
TOTAL
TRAVEL
TIME
AS
A
RESULT
OF
THE
AVAILABILITY
OF
THE
NEW
ROAD
E
IF
YOU
CAN
ASSIGN
TRAVELERS
TO
ROUTES
THEN
IN
FACT
IT
POSSIBLE
TO
REDUCE
TOTAL
TRAVEL
TIME
RELATIVE
TO
WHAT
IT
WAS
BEFORE
THE
NEW
ROAD
WAS
BUILT
THAT
IS
THE
TOTAL
TRAVEL
TIME
OF
THE
POPULATION
CAN
BE
REDUCED
BELOW
THAT
IN
THE
ORIGINAL
NASH
EQUILIBRIUM
FROM
PART
B
BY
ASSIGNING
TRAVELERS
TO
ROUTES
THERE
ARE
MANY
ASSIGNMENTS
OF
ROUTES
THAT
WILL
ACCOMPLISH
THIS
FIND
ONE
EXPLAIN
WHY
YOUR
REASSIGNMENT
REDUCES
TOTAL
TRAVEL
TIME
HINT
REMEMBER
THAT
TRAVEL
ON
THE
NEW
ROAD
CAN
GO
IN
EITHER
DIRECTION
YOU
DO
NOT
NEED
FIND
THE
TOTAL
TRAVEL
TIME
MINIMIZING
ASSIGNMENT
OF
TRAVELERS
ONE
APPROACH
TO
THIS
QUESTION
IS
TO
START
WITH
THE
NASH
EQUILIBRIUM
FROM
PART
B
AND
LOOK
FOR
A
WAY
TO
ASSIGN
SOME
TRAVELERS
TO
DIFFERENT
ROUTES
SO
AS
TO
REDUCE
TOTAL
TRAVEL
TIME
THERE
ARE
CARS
WHICH
MUST
TRAVEL
FROM
CITY
A
TO
CITY
B
THERE
ARE
TWO
POSSIBLE
ROUTES
THAT
EACH
CAR
CAN
TAKE
THE
UPPER
ROUTE
THROUGH
CITY
C
OR
THE
LOWER
ROUTE
THROUGH
CITY
D
LET
X
BE
THE
NUMBER
OF
CARS
TRAVELING
ON
THE
EDGE
AC
AND
LET
Y
BE
THE
NUMBER
OF
CARS
TRAVELING
ON
THE
EDGE
DB
THE
DIRECTED
GRAPH
IN
FIGURE
INDICATES
THAT
TOTAL
TRAVEL
TIME
PER
CAR
ALONG
THE
UPPER
ROUTE
IS
X
IF
X
CARS
USE
THE
UPPER
ROUTE
AND
SIMILARLY
THE
TOTAL
TRAVEL
TIME
PER
CAR
ALONG
THE
LOWER
ROUTE
IS
Y
IF
Y
CARS
TAKE
THE
LOWER
ROUTE
EACH
DRIVER
WANTS
TO
SELECT
A
ROUTE
TO
MINIMIZE
HIS
TOTAL
TRAVEL
TIME
THE
DRIVERS
MAKE
SIMULTANEOUS
CHOICES
A
FIND
NASH
EQUILIBRIUM
VALUES
OF
X
AND
Y
B
NOW
THE
GOVERNMENT
BUILDS
A
NEW
ONE
WAY
ROAD
FROM
CITY
A
TO
CITY
B
THE
NEW
ROUTE
HAS
A
TRAVEL
TIME
OF
PER
CAR
REGARDLESS
OF
THE
NUMBER
OF
CARS
THAT
USE
IT
DRAW
THE
NEW
NETWORK
AND
LABEL
THE
EDGES
WITH
THE
COST
OF
TRAVEL
NEEDED
TO
MOVE
ALONG
THE
EDGE
THE
NETWORK
SHOULD
BE
A
DIRECTED
GRAPH
AS
ALL
ROADS
ARE
ONE
WAY
FIND
A
NASH
EQUILIBRIUM
FOR
THE
GAME
PLAYED
ON
THE
NEW
NETWORK
WHAT
HAPPENS
TO
TOTAL
COST
OF
TRAVEL
THE
SUM
OF
TOTAL
TRAVEL
TIMES
FOR
THE
CARS
AS
A
RESULT
OF
THE
AVAILABILITY
OF
THE
NEW
ROAD
C
NOW
THE
GOVERNMENT
CLOSES
THE
DIRECT
ROUTE
BETWEEN
CITY
A
AND
CITY
B
AND
BUILDS
A
NEW
ONE
WAY
ROAD
WHICH
LINKS
CITY
C
TO
CITY
D
THIS
NEW
ROAD
BETWEEN
C
AND
D
IS
VERY
SHORT
AND
HAS
A
TRAVEL
TIME
OF
REGARDLESS
OF
THE
NUMBER
OF
CARS
THAT
USE
IT
DRAW
THE
NEW
NETWORK
AND
LABEL
THE
EDGES
WITH
THE
COST
OF
TRAVEL
NEEDED
TO
MOVE
ALONG
THE
EDGE
THE
NETWORK
SHOULD
BE
A
DIRECTED
GRAPH
AS
ALL
ROADS
ARE
ONE
WAY
FIND
A
NASH
EQUILIBRIUM
FOR
THE
GAME
PLAYED
ON
THE
NEW
NETWORK
WHAT
HAPPENS
TO
TOTAL
COST
OF
TRAVEL
AS
A
RESULT
OF
THE
AVAILABILITY
OF
THE
NEW
ROAD
D
THE
GOVERNMENT
IS
UNHAPPY
WITH
THE
OUTCOME
IN
PART
C
AND
DECIDES
TO
REOPEN
THE
ROAD
DIRECTLY
LINKING
CITY
A
AND
CITY
B
THE
ROAD
THAT
WAS
BUILT
IN
PART
B
AND
CLOSED
IN
PART
C
THE
ROUTE
BETWEEN
C
AND
D
THAT
WAS
CONSTRUCTED
IN
PART
C
REMAINS
OPEN
THIS
ROAD
STILL
HAS
A
TRAVEL
TIME
OF
PER
CAR
REGARDLESS
OF
THE
NUMBER
OF
CARS
THAT
USE
IT
DRAW
THE
NEW
NETWORK
AND
LABEL
THE
EDGES
WITH
THE
COST
OF
TRAVEL
NEEDED
TO
MOVE
ALONG
THE
EDGE
THE
NETWORK
SHOULD
BE
A
DIRECTED
GRAPH
AS
ALL
ROADS
ARE
ONE
WAY
FIND
A
NASH
EQUILIBRIUM
FOR
THE
GAME
PLAYED
ON
THE
NEW
NETWORK
WHAT
HAPPENS
TO
TOTAL
COST
OF
TRAVEL
AS
A
RESULT
OF
RE
OPENING
THE
DIRECT
ROUTE
BETWEEN
A
AND
B
THERE
ARE
TWO
CITIES
A
AND
B
JOINED
BY
TWO
ROUTES
I
AND
II
ALL
ROADS
ARE
ONE
WAY
ROADS
THERE
ARE
TRAVELERS
WHO
BEGIN
IN
CITY
A
AND
MUST
TRAVEL
TO
CITY
B
ROUTE
I
LINKS
CITY
A
TO
CITY
B
THROUGH
CITY
C
THIS
ROUTE
BEGINS
WITH
A
ROAD
LINKING
CITY
A
TO
CITY
C
WHICH
HAS
A
COST
OF
TRAVEL
FOR
EACH
TRAVELER
EQUAL
TO
X
WHERE
X
IS
THE
NUMBER
OF
TRAVELERS
ON
THIS
ROAD
ROUTE
I
ENDS
WITH
A
HIGHWAY
FROM
CITY
C
TO
CITY
B
WHICH
HAS
A
COST
OF
TRAVEL
FOR
EACH
TRAVELER
OF
REGARDLESS
OF
THE
NUMBER
OF
TRAVELERS
WHO
USE
IT
ROUTE
II
LINKS
CITY
A
TO
CITY
B
THROUGH
CITY
D
THIS
ROUTE
BEGINS
WITH
A
HIGHWAY
LINKING
CITY
A
TO
CITY
D
WHICH
HAS
A
COST
OF
TRAVEL
FOR
EACH
TRAVELER
OF
REGARDLESS
OF
THE
NUMBER
OF
TRAVELERS
WHO
USE
IT
ROUTE
II
ENDS
WITH
A
ROAD
LINKING
CITY
D
TO
CITY
B
WHICH
HAS
A
COST
OF
TRAVEL
FOR
EACH
TRAVELER
EQUAL
TO
Y
WHERE
Y
IS
THE
NUMBER
OF
TRAVELERS
ON
THIS
ROAD
THESE
COSTS
OF
TRAVEL
ARE
THE
VALUE
THAT
TRAVELERS
PUT
ON
THE
TIME
LOST
DUE
TO
TRAVEL
PLUS
THE
COST
OF
GASOLINE
FOR
THE
TRIP
CURRENTLY
THERE
ARE
NO
TOLLS
ON
THESE
ROADS
SO
THE
GOVERNMENT
COLLECTS
NO
REVENUE
FROM
TRAVEL
ON
THEM
A
DRAW
THE
NETWORK
DESCRIBED
ABOVE
AND
LABEL
THE
EDGES
WITH
THE
COST
OF
TRAVEL
NEEDED
TO
MOVE
ALONG
THE
EDGE
THE
NETWORK
SHOULD
BE
A
DIRECTED
GRAPH
AS
ALL
ROADS
ARE
ONE
WAY
B
TRAVELERS
SIMULTANEOUSLY
CHOSE
WHICH
ROUTE
TO
USE
FIND
NASH
EQUILIBRIUM
VALUES
OF
X
AND
Y
C
NOW
THE
GOVERNMENT
BUILDS
A
NEW
ONE
WAY
ROAD
FROM
CITY
C
TO
CITY
D
THE
NEW
ROAD
IS
VERY
SHORT
AND
HAS
COST
OF
TRAVEL
FIND
A
NASH
EQUILIBRIUM
FOR
THE
GAME
PLAYED
ON
THE
NEW
NETWORK
D
WHAT
HAPPENS
TO
TOTAL
COST
OF
TRAVEL
AS
A
RESULT
OF
THE
AVAILABILITY
OF
THE
NEW
ROAD
E
THE
GOVERNMENT
IS
UNHAPPY
WITH
THE
OUTCOME
IN
PART
C
AND
DECIDES
TO
IMPOSE
A
TOLL
ON
USERS
OF
THE
ROAD
FROM
CITY
A
TO
CITY
C
AND
TO
SIMULTANEOUSLY
SUBSIDIZE
USERS
OF
THE
HIGHWAY
FROM
CITY
A
TO
CITY
D
THEY
CHARGE
A
TOLL
OF
TO
EACH
USER
AND
THUS
INCREASE
THE
COST
OF
TRAVEL
BY
THIS
AMOUNT
FOR
USERS
OF
THE
ROAD
FROM
CITY
A
TO
CITY
C
THEY
ALSO
SUBSIDIZE
TRAVEL
AND
THUS
REDUCE
THE
COST
OF
TRAVEL
BY
THIS
AMOUNT
FOR
EACH
USER
OF
THE
HIGHWAY
FROM
CITY
A
TO
CITY
D
BY
FIND
A
NEW
NASH
EQUILIBRIUM
IF
YOU
ARE
CURIOUS
ABOUT
HOW
A
SUBSIDY
COULD
WORK
YOU
CAN
THINK
OF
IT
AS
A
NEGATIVE
TOLL
IN
THIS
ECONOMY
ALL
TOLLS
ARE
COLLECTED
ELECTRONICALLY
MUCH
AS
NEW
YORK
STATE
ATTEMPTS
TO
DO
WITH
ITS
E
ZPASS
SYSTEM
SO
A
SUBSIDY
JUST
REDUCES
THE
TOTAL
AMOUNT
THAT
HIGHWAY
USERS
OWE
F
AS
YOU
WILL
OBSERVE
IN
SOLVING
PART
E
THE
TOLL
AND
SUBSIDY
IN
PART
E
WERE
DESIGNED
SO
THAT
THERE
IS
A
NASH
EQUILIBRIUM
IN
WHICH
THE
AMOUNT
THE
GOVERNMENT
COLLECTS
FROM
THE
TOLL
JUST
EQUALS
THE
AMOUNT
IT
LOSES
ON
THE
SUBSIDY
SO
THE
GOVERNMENT
IS
BREAKING
EVEN
ON
THIS
POLICY
WHAT
HAPPENS
TO
TOTAL
COST
OF
TRAVEL
BETWEEN
PARTS
C
AND
E
CAN
YOU
EXPLAIN
WHY
THIS
OCCURS
CAN
YOU
THINK
OF
ANY
BREAK
EVEN
TOLLS
AND
SUBSIDIES
THAT
COULD
BE
PLACED
ON
THE
ROADS
FROM
CITY
C
TO
CITY
B
AND
FROM
CITY
D
TO
CITY
B
THAT
WOULD
LOWER
THE
TOTAL
COST
OF
TRAVEL
EVEN
MORE
CHAPTER
AUCTIONS
IN
CHAPTER
WE
CONSIDERED
A
FIRST
EXTENDED
APPLICATION
OF
GAME
THEORETIC
IDEAS
IN
OUR
ANALYSIS
OF
TRAFFIC
FLOW
THROUGH
A
NETWORK
HERE
WE
CONSIDER
A
SECOND
MAJOR
APPLICATION
THE
BEHAVIOR
OF
BUYERS
AND
SELLERS
IN
AN
AUCTION
AN
AUCTION
IS
A
KIND
OF
ECONOMIC
ACTIVITY
THAT
HAS
BEEN
BROUGHT
INTO
MANY
PEOPLE
EVERYDAY
LIVES
BY
THE
INTERNET
THROUGH
SITES
SUCH
AS
EBAY
BUT
AUCTIONS
ALSO
HAVE
A
LONG
HISTORY
THAT
SPANS
MANY
DIFFERENT
DOMAINS
FOR
EXAMPLE
THE
U
GOVERNMENT
USES
AUCTIONS
TO
SELL
TREASURY
BILLS
AND
TIMBER
AND
OIL
LEASES
CHRISTIE
AND
SOTHEBY
USE
THEM
TO
SELL
ART
AND
MORRELL
CO
AND
THE
CHICAGO
WINE
COMPANY
USE
THEM
TO
SELL
WINE
AUCTIONS
WILL
ALSO
PLAY
AN
IMPORTANT
AND
RECURRING
ROLE
IN
THE
BOOK
SINCE
THE
SIMPLIFIED
FORM
OF
BUYER
SELLER
INTERACTION
THEY
EMBODY
IS
CLOSELY
RELATED
TO
MORE
COMPLEX
FORMS
OF
ECONOMIC
INTERACTION
AS
WELL
IN
PARTICULAR
WHEN
WE
THINK
IN
THE
NEXT
PART
OF
THE
BOOK
ABOUT
MARKETS
IN
WHICH
MULTIPLE
BUYERS
AND
SELLERS
ARE
CONNECTED
BY
AN
UNDERLYING
NETWORK
STRUCTURE
WE
LL
USE
IDEAS
INITIALLY
DEVELOPED
IN
THIS
CHAPTER
FOR
UNDERSTANDING
SIMPLER
AUCTION
FORMATS
SIMILARLY
IN
CHAPTER
WE
LL
STUDY
A
MORE
COMPLEX
KIND
OF
AUCTION
IN
THE
CONTEXT
OF
A
WEB
SEARCH
APPLICATION
ANALYZING
THE
WAYS
IN
WHICH
SEARCH
COMPANIES
LIKE
GOOGLE
YAHOO
AND
MICROSOFT
USE
AN
AUCTION
FORMAT
TO
SELL
ADVERTISING
RIGHTS
FOR
KEYWORDS
TYPES
OF
AUCTIONS
IN
THIS
CHAPTER
WE
FOCUS
ON
DIFFERENT
SIMPLE
TYPES
OF
AUCTIONS
AND
HOW
THEY
PROMOTE
DIFFERENT
KINDS
OF
BEHAVIOR
AMONG
BIDDERS
WE
LL
CONSIDER
THE
CASE
OF
A
SELLER
AUCTIONING
ONE
ITEM
TO
A
SET
OF
BUYERS
WE
COULD
SYMMETRICALLY
THINK
OF
A
SITUATION
IN
WHICH
A
BUYER
IS
TRYING
TO
PURCHASE
A
SINGLE
ITEM
AND
RUNS
AN
AUCTION
AMONG
A
SET
OF
MULTIPLE
SELLERS
EACH
OF
WHOM
IS
ABLE
TO
PROVIDE
THE
ITEM
SUCH
PROCUREMENT
AUCTIONS
ARE
FREQUENTLY
RUN
BY
GOVERNMENTS
TO
D
EASLEY
AND
J
KLEINBERG
NETWORKS
CROWDS
AND
MARKETS
REASONING
ABOUT
A
HIGHLY
CONNECTED
WORLD
CAMBRIDGE
UNIVERSITY
PRESS
DRAFT
VERSION
JUNE
PURCHASE
GOODS
BUT
HERE
WE
LL
FOCUS
ON
THE
CASE
IN
WHICH
THE
SELLER
RUNS
THE
AUCTION
THERE
ARE
MANY
DIFFERENT
WAYS
OF
DEFINING
AUCTIONS
THAT
ARE
MUCH
MORE
COMPLEX
THAN
WHAT
WE
CONSIDER
HERE
THE
SUBSEQUENT
CHAPTERS
WILL
GENERALIZE
OUR
ANALYSIS
TO
THE
CASE
IN
WHICH
THERE
ARE
MULTIPLE
GOODS
BEING
SOLD
AND
THE
BUYERS
ASSIGN
DIFFERENT
VALUES
TO
THESE
GOODS
OTHER
VARIATIONS
WHICH
FALL
OUTSIDE
THE
SCOPE
OF
THE
BOOK
INCLUDE
AUCTIONS
IN
WHICH
GOODS
ARE
SOLD
SEQUENTIALLY
OVER
TIME
THESE
MORE
COMPLEX
VARIATIONS
CAN
ALSO
BE
ANALYZED
USING
EXTENSIONS
OF
THE
IDEAS
WE
LL
TALK
ABOUT
HERE
AND
THERE
IS
A
LARGE
LITERATURE
IN
ECONOMICS
THAT
CONSIDERS
AUCTIONS
AT
THIS
BROAD
LEVEL
OF
GENERALITY
THE
UNDERLYING
ASSUMPTION
WE
MAKE
WHEN
MODELING
AUCTIONS
IS
THAT
EACH
BIDDER
HAS
AN
INTRINSIC
VALUE
FOR
THE
ITEM
BEING
AUCTIONED
SHE
IS
WILLING
TO
PURCHASE
THE
ITEM
FOR
A
PRICE
UP
TO
THIS
VALUE
BUT
NOT
FOR
ANY
HIGHER
PRICE
WE
WILL
ALSO
REFER
TO
THIS
INTRINSIC
VALUE
AS
THE
BIDDER
TRUE
VALUE
FOR
THE
ITEM
THERE
ARE
FOUR
MAIN
TYPES
OF
AUCTIONS
WHEN
A
SINGLE
ITEM
IS
BEING
SOLD
AND
MANY
VARIANTS
OF
THESE
TYPES
ASCENDING
BID
AUCTIONS
ALSO
CALLED
ENGLISH
AUCTIONS
THESE
AUCTIONS
ARE
CARRIED
OUT
INTERACTIVELY
IN
REAL
TIME
WITH
BIDDERS
PRESENT
EITHER
PHYSICALLY
OR
ELECTRONICALLY
THE
SELLER
GRADUALLY
RAISES
THE
PRICE
BIDDERS
DROP
OUT
UNTIL
FINALLY
ONLY
ONE
BIDDER
REMAINS
AND
THAT
BIDDER
WINS
THE
OBJECT
AT
THIS
FINAL
PRICE
ORAL
AUCTIONS
IN
WHICH
BIDDERS
SHOUT
OUT
PRICES
OR
SUBMIT
THEM
ELECTRONICALLY
ARE
FORMS
OF
ASCENDING
BID
AUCTIONS
DESCENDING
BID
AUCTIONS
ALSO
CALLED
DUTCH
AUCTIONS
THIS
IS
ALSO
AN
INTERACTIVE
AUCTION
FORMAT
IN
WHICH
THE
SELLER
GRADUALLY
LOWERS
THE
PRICE
FROM
SOME
HIGH
INITIAL
VALUE
UNTIL
THE
FIRST
MOMENT
WHEN
SOME
BIDDER
ACCEPTS
AND
PAYS
THE
CURRENT
PRICE
THESE
AUCTIONS
ARE
CALLED
DUTCH
AUCTIONS
BECAUSE
FLOWERS
HAVE
LONG
BEEN
SOLD
IN
THE
NETHERLANDS
USING
THIS
PROCEDURE
FIRST
PRICE
SEALED
BID
AUCTIONS
IN
THIS
KIND
OF
AUCTION
BIDDERS
SUBMIT
SIMULTANEOUS
SEALED
BIDS
TO
THE
SELLER
THE
TERMINOLOGY
COMES
FROM
THE
ORIGINAL
FORMAT
FOR
SUCH
AUCTIONS
IN
WHICH
BIDS
WERE
WRITTEN
DOWN
AND
PROVIDED
IN
SEALED
ENVELOPES
TO
THE
SELLER
WHO
WOULD
THEN
OPEN
THEM
ALL
TOGETHER
THE
HIGHEST
BIDDER
WINS
THE
OBJECT
AND
PAYS
THE
VALUE
OF
HER
BID
SECOND
PRICE
SEALED
BID
AUCTIONS
ALSO
CALLED
VICKREY
AUCTIONS
BIDDERS
SUBMIT
SIMUL
TANEOUS
SEALED
BIDS
TO
THE
SELLERS
THE
HIGHEST
BIDDER
WINS
THE
OBJECT
AND
PAYS
THE
VALUE
OF
THE
SECOND
HIGHEST
BID
THESE
AUCTIONS
ARE
CALLED
VICKREY
AUCTIONS
IN
HONOR
OF
WILLIAM
VICKREY
WHO
WROTE
THE
FIRST
GAME
THEORETIC
ANALYSIS
OF
AUCTIONS
INCLUDING
THE
SECOND
PRICE
AUCTION
VICKERY
WON
THE
NOBEL
MEMORIAL
PRIZE
IN
ECONOMICS
IN
FOR
THIS
BODY
OF
WORK
WHEN
ARE
AUCTIONS
APPROPRIATE
WHEN
ARE
AUCTIONS
APPROPRIATE
AUCTIONS
ARE
GENERALLY
USED
BY
SELLERS
IN
SITUATIONS
WHERE
THEY
DO
NOT
HAVE
A
GOOD
ESTIMATE
OF
THE
BUYERS
TRUE
VALUES
FOR
AN
ITEM
AND
WHERE
BUYERS
DO
NOT
KNOW
EACH
OTHER
VALUES
IN
THIS
CASE
AS
WE
WILL
SEE
SOME
OF
THE
MAIN
AUCTION
FORMATS
CAN
BE
USED
TO
ELICIT
BIDS
FROM
BUYERS
THAT
REVEAL
THESE
VALUES
KNOWN
VALUES
TO
MOTIVATE
THE
SETTING
IN
WHICH
BUYERS
TRUE
VALUES
ARE
UNKNOWN
LET
START
BY
CONSIDERING
THE
CASE
IN
WHICH
THE
SELLER
AND
BUYERS
KNOW
EACH
OTHER
VALUES
FOR
AN
ITEM
AND
ARGUE
THAT
AN
AUCTION
IS
UNNECESSARY
IN
THIS
SCENARIO
IN
PARTICULAR
SUPPOSE
THAT
A
SELLER
IS
TRYING
TO
SELL
AN
ITEM
THAT
HE
VALUES
AT
X
AND
SUPPOSE
THAT
THE
MAXIMUM
VALUE
HELD
BY
A
POTENTIAL
BUYER
OF
THE
ITEM
IS
SOME
LARGER
NUMBER
Y
IN
THIS
CASE
WE
SAY
THERE
IS
A
SURPLUS
OF
Y
X
THAT
CAN
BE
GENERATED
BY
THE
SALE
OF
THE
ITEM
IT
CAN
GO
FROM
SOMEONE
WHO
VALUES
IT
LESS
X
TO
SOMEONE
WHO
VALUES
IT
MORE
Y
IF
THE
SELLER
KNOWS
THE
TRUE
VALUES
THAT
THE
POTENTIAL
BUYERS
ASSIGN
TO
THE
ITEM
THEN
HE
CAN
SIMPLY
ANNOUNCE
THAT
THE
ITEM
IS
FOR
SALE
AT
A
FIXED
PRICE
JUST
BELOW
Y
AND
THAT
HE
WILL
NOT
ACCEPT
ANY
LOWER
PRICE
IN
THIS
CASE
THE
BUYER
WITH
VALUE
Y
WILL
BUY
THE
ITEM
AND
THE
FULL
VALUE
OF
THE
SURPLUS
WILL
GO
TO
THE
SELLER
IN
OTHER
WORDS
THE
SELLER
HAS
NO
NEED
FOR
AN
AUCTION
IN
THIS
CASE
HE
GETS
AS
MUCH
AS
HE
COULD
REASONABLY
EXPECT
JUST
BY
ANNOUNCING
THE
RIGHT
PRICE
NOTICE
THAT
THERE
IS
AN
ASYMMETRY
IN
THE
FORMULATION
OF
THIS
EXAMPLE
WE
GAVE
THE
SELLER
THE
ABILITY
TO
COMMIT
TO
THE
MECHANISM
THAT
WAS
USED
FOR
SELLING
THE
OBJECT
THIS
ABILITY
OF
THE
SELLER
TO
TIE
HIS
HANDS
BY
COMMITTING
TO
A
FIXED
PRICE
IS
IN
FACT
VERY
VALUABLE
TO
HIM
ASSUMING
THE
BUYERS
BELIEVE
THIS
COMMITMENT
THE
ITEM
IS
SOLD
FOR
A
PRICE
JUST
BELOW
Y
AND
THE
SELLER
MAKES
ALL
THE
SURPLUS
IN
CONTRAST
CONSIDER
WHAT
WOULD
HAPPEN
IF
WE
GAVE
THE
BUYER
WITH
MAXIMUM
VALUE
Y
THE
ABILITY
TO
COMMIT
TO
THE
MECHANISM
IN
THIS
CASE
THIS
BUYER
COULD
ANNOUNCE
THAT
SHE
IS
WILLING
TO
PURCHASE
THE
ITEM
FOR
A
PRICE
JUST
ABOVE
THE
LARGER
OF
X
AND
THE
VALUES
HELD
BY
ALL
OTHER
BUYERS
WITH
THIS
ANNOUNCEMENT
THE
SELLER
WOULD
STILL
BE
WILLING
TO
SELL
SINCE
THE
PRICE
WOULD
BE
ABOVE
X
BUT
NOW
AT
LEAST
SOME
OF
THE
SURPLUS
WOULD
GO
TO
THE
BUYER
AS
WITH
THE
SELLER
COMMITMENT
THIS
COMMITMENT
BY
THE
BUYER
ALSO
REQUIRES
KNOWLEDGE
OF
EVERYONE
ELSE
VALUES
THESE
EXAMPLES
SHOW
HOW
COMMITMENT
TO
A
MECHANISM
CAN
SHIFT
THE
POWER
IN
THE
TRANS
ACTION
IN
FAVOR
OF
THE
SELLER
OR
THE
BUYER
ONE
CAN
ALSO
IMAGINE
MORE
COMPLEX
SCENARIOS
IN
WHICH
THE
SELLER
AND
BUYERS
KNOW
EACH
OTHER
VALUES
BUT
NEITHER
HAS
THE
POWER
TO
UNILATER
ALLY
COMMIT
TO
A
MECHANISM
IN
THIS
CASE
ONE
MAY
SEE
SOME
KIND
OF
BARGAINING
TAKE
PLACE
OVER
THE
PRICE
WE
DISCUSS
THE
TOPIC
OF
BARGAINING
FURTHER
IN
CHAPTER
AS
WE
WILL
DISCOVER
IN
THE
CURRENT
CHAPTER
THE
ISSUE
OF
COMMITMENT
IS
ALSO
CRUCIAL
IN
THE
CONTEXT
OF
AUCTIONS
SPECIFICALLY
IT
IS
IMPORTANT
THAT
A
SELLER
BE
ABLE
TO
RELIABLY
COMMIT
IN
ADVANCE
TO
A
GIVEN
AUCTION
FORMAT
UNKNOWN
VALUES
THUS
FAR
WE
VE
BEEN
DISCUSSING
HOW
SELLERS
AND
BUYERS
MIGHT
INTERACT
WHEN
EVERYONE
KNOWS
EACH
OTHER
TRUE
VALUES
FOR
THE
ITEM
BEGINNING
IN
THE
NEXT
SECTION
WE
LL
SEE
HOW
AUCTIONS
COME
INTO
PLAY
WHEN
THE
PARTICIPANTS
DO
NOT
KNOW
EACH
OTHER
VALUES
FOR
MOST
OF
THIS
CHAPTER
WE
WILL
RESTRICT
OUR
ATTENTION
TO
THE
CASE
IN
WHICH
THE
BUYERS
HAVE
INDEPENDENT
PRIVATE
VALUES
FOR
THE
ITEM
THAT
IS
EACH
BUYER
KNOWS
HOW
MUCH
SHE
VALUES
THE
ITEM
SHE
DOES
NOT
KNOW
HOW
MUCH
OTHERS
VALUE
IT
AND
HER
VALUE
FOR
IT
DOES
NOT
DEPEND
ON
OTHERS
VALUES
FOR
EXAMPLE
THE
BUYERS
COULD
BE
INTERESTED
IN
CONSUMING
THE
ITEM
WITH
THEIR
VALUES
REFLECTING
HOW
MUCH
THEY
EACH
WOULD
ENJOY
IT
LATER
WE
WILL
ALSO
CONSIDER
THE
POLAR
OPPOSITE
OF
THIS
SETTING
THE
CASE
OF
COMMON
VALUES
SUPPOSE
THAT
AN
ITEM
IS
BEING
AUCTIONED
AND
INSTEAD
OF
CONSUMING
THE
ITEM
EACH
BUYER
PLANS
TO
RESELL
THE
ITEM
IF
SHE
GETS
IT
IN
THIS
CASE
ASSUMING
THE
BUYERS
WILL
DO
A
COMPARABLY
GOOD
JOB
OF
RESELLING
IT
THE
ITEM
HAS
AN
UNKNOWN
BUT
COMMON
VALUE
REGARDLESS
OF
WHO
ACQUIRES
IT
IT
IS
EQUAL
TO
HOW
MUCH
REVENUE
THIS
FUTURE
RESELLING
OF
THE
ITEM
WILL
GENERATE
BUYERS
ESTIMATES
OF
THIS
REVENUE
MAY
DIFFER
IF
THEY
HAVE
SOME
PRIVATE
INFORMATION
ABOUT
THE
COMMON
VALUE
AND
SO
THEIR
VALUATIONS
OF
THE
ITEM
MAY
DIFFER
IN
THIS
SETTING
THE
VALUE
EACH
BUYER
ASSIGNS
TO
THE
OBJECT
WOULD
BE
AFFECTED
BY
KNOWLEDGE
OF
THE
OTHER
BUYERS
VALUATIONS
SINCE
THE
BUYERS
COULD
USE
THIS
KNOWLEDGE
TO
FURTHER
REFINE
THEIR
ESTIMATES
OF
THE
COMMON
VALUE
RELATIONSHIPS
BETWEEN
DIFFERENT
AUCTION
FORMATS
OUR
MAIN
GOAL
WILL
BE
TO
CONSIDER
HOW
BIDDERS
BEHAVE
IN
DIFFERENT
TYPES
OF
AUCTIONS
WE
BEGIN
IN
THIS
SECTION
WITH
SOME
SIMPLE
INFORMAL
OBSERVATIONS
THAT
RELATE
BEHAVIOR
IN
INTERACTIVE
AUCTIONS
ASCENDING
BID
AND
DESCENDING
BID
AUCTIONS
WHICH
PLAY
OUT
IN
REAL
TIME
WITH
BEHAVIOR
IN
SEALED
BID
AUCTIONS
THESE
OBSERVATIONS
CAN
BE
MADE
MATHEMATICALLY
RIGOROUS
BUT
FOR
THE
DISCUSSION
HERE
WE
WILL
STICK
TO
AN
INFORMAL
DESCRIPTION
DESCENDING
BID
AND
FIRST
PRICE
AUCTIONS
FIRST
CONSIDER
A
DESCENDING
BID
AUCTION
HERE
AS
THE
SELLER
IS
LOWERING
THE
PRICE
FROM
ITS
HIGH
INITIAL
STARTING
POINT
NO
BIDDER
SAYS
ANYTHING
UNTIL
FINALLY
SOMEONE
ACTUALLY
ACCEPTS
THE
BID
AND
PAYS
THE
CURRENT
PRICE
BIDDERS
THEREFORE
LEARN
NOTHING
WHILE
THE
AUCTION
IS
RUNNING
OTHER
THAN
THE
FACT
THAT
NO
ONE
HAS
YET
ACCEPTED
THE
CURRENT
PRICE
FOR
EACH
BIDDER
I
THERE
A
FIRST
PRICE
BI
AT
WHICH
SHE
LL
BE
WILLING
TO
BREAK
THE
SILENCE
AND
ACCEPT
THE
ITEM
AT
PRICE
BI
SO
WITH
THIS
VIEW
THE
PROCESS
IS
EQUIVALENT
TO
A
SEALED
BID
FIRST
PRICE
AUCTION
THIS
PRICE
BI
PLAYS
THE
ROLE
OF
BIDDER
I
BID
THE
ITEM
GOES
TO
THE
BIDDER
WITH
THE
HIGHEST
BID
VALUE
AND
THIS
BIDDER
PAYS
THE
VALUE
OF
HER
BID
IN
EXCHANGE
FOR
THE
ITEM
RELATIONSHIPS
BETWEEN
DIFFERENT
AUCTION
FORMATS
ASCENDING
BID
AND
SECOND
PRICE
AUCTIONS
NOW
LET
THINK
ABOUT
AN
ASCENDING
BID
AUCTION
IN
WHICH
BIDDERS
GRADUALLY
DROP
OUT
AS
THE
SELLER
STEADILY
RAISES
THE
PRICE
THE
WINNER
OF
THE
AUCTION
IS
THE
LAST
BIDDER
REMAINING
AND
SHE
PAYS
THE
PRICE
AT
WHICH
THE
SECOND
TO
LAST
BIDDER
DROPS
OUT
SUPPOSE
THAT
YOU
RE
A
BIDDER
IN
SUCH
AN
AUCTION
LET
CONSIDER
HOW
LONG
YOU
SHOULD
STAY
IN
THE
AUCTION
BEFORE
DROPPING
OUT
FIRST
DOES
IT
EVER
MAKE
SENSE
TO
STAY
IN
THE
AUCTION
AFTER
THE
PRICE
REACHES
YOUR
TRUE
VALUE
NO
BY
STAYING
IN
YOU
EITHER
LOSE
AND
GET
NOTHING
OR
ELSE
YOU
WIN
AND
HAVE
TO
PAY
MORE
THAN
YOUR
VALUE
FOR
THE
ITEM
SECOND
DOES
IT
EVER
MAKE
SENSE
TO
DROP
OUT
BEFORE
THE
PRICE
REACHES
YOUR
TRUE
VALUE
FOR
THE
ITEM
AGAIN
NO
IF
YOU
DROP
OUT
EARLY
BEFORE
YOUR
TRUE
VALUE
IS
REACHED
THEN
YOU
GET
NOTHING
WHEN
BY
STAYING
IN
YOU
MIGHT
WIN
THE
ITEM
AT
A
PRICE
BELOW
YOUR
TRUE
VALUE
SO
THIS
INFORMAL
ARGUMENT
INDICATES
THAT
YOU
SHOULD
STAY
IN
AN
ASCENDING
BID
AUCTION
UP
TO
THE
EXACT
MOMENT
AT
WHICH
THE
PRICE
REACHES
YOUR
TRUE
VALUE
IF
WE
THINK
OF
EACH
BIDDER
I
DROP
OUT
PRICE
AS
HER
BID
BI
THIS
SAYS
THAT
PEOPLE
SHOULD
USE
THEIR
TRUE
VALUES
AS
THEIR
BIDS
MOREOVER
WITH
THIS
DEFINITION
OF
BIDS
THE
RULE
FOR
DETERMINING
THE
OUTCOME
OF
AN
ASCENDING
BID
AUCTION
CAN
BE
REFORMULATED
AS
FOLLOWS
THE
PERSON
WITH
THE
HIGHEST
BID
IS
THE
ONE
WHO
STAYS
IN
THE
LONGEST
THUS
WINNING
THE
ITEM
AND
SHE
PAYS
THE
PRICE
AT
WHICH
THE
SECOND
TO
LAST
PERSON
DROPPED
OUT
IN
OTHER
WORDS
SHE
PAYS
THE
BID
OF
THIS
SECOND
TO
LAST
PERSON
THUS
THE
ITEM
GOES
TO
THE
HIGHEST
BIDDER
AT
A
PRICE
EQUAL
TO
THE
SECOND
HIGHEST
BID
THIS
IS
PRECISELY
THE
RULE
USED
IN
THE
SEALED
BID
SECOND
PRICE
AUCTION
WITH
THE
DIFFERENCE
BEING
THAT
THE
ASCENDING
BID
AUCTION
INVOLVES
REAL
TIME
INTERACTION
BETWEEN
THE
BUYERS
AND
SELLER
WHILE
THE
SEALED
BID
VERSION
TAKES
PLACE
PURELY
THROUGH
SEALED
BIDS
THAT
THE
SELLER
OPENS
AND
EVALUATES
BUT
THE
CLOSE
SIMILARITY
IN
RULES
HELPS
TO
MOTIVATE
THE
INITIALLY
COUNTER
INTUITIVE
PRICING
RULE
FOR
THE
SECOND
PRICE
AUCTION
IT
CAN
BE
VIEWED
AS
A
SIMULATION
USING
SEALED
BIDS
OF
AN
ASCENDING
BID
AUCTION
MOREOVER
THE
FACT
THAT
BIDDERS
WANT
TO
REMAIN
IN
AN
ASCENDING
BID
AUCTION
UP
TO
EXACTLY
THE
POINT
AT
WHICH
THEIR
TRUE
VALUE
IS
REACHED
PROVIDES
THE
INTUITION
FOR
WHAT
WILL
BE
OUR
MAIN
RESULT
IN
THE
NEXT
SECTION
AFTER
FORMULATING
THE
SEALED
BID
SECOND
PRICE
AUCTION
IN
TERMS
OF
GAME
THEORY
WE
WILL
FIND
THAT
BIDDING
ONE
TRUE
VALUE
IS
A
DOMINANT
STRATEGY
CONCEPTUALLY
SIMPLEST
TO
THINK
OF
THREE
THINGS
HAPPENING
SIMULTANEOUSLY
AT
THE
END
OF
AN
ASCENDING
BID
AUCTION
I
THE
SECOND
TO
LAST
BIDDER
DROPS
OUT
II
THE
LAST
REMAINING
BIDDER
SEES
THAT
SHE
IS
ALONE
AND
STOPS
AGREEING
TO
ANY
HIGHER
PRICES
AND
III
THE
SELLER
AWARDS
THE
ITEM
TO
THIS
LAST
REMAINING
BIDDER
AT
THE
CURRENT
PRICE
OF
COURSE
IN
PRACTICE
WE
MIGHT
WELL
EXPECT
THAT
THERE
IS
SOME
VERY
SMALL
INCREMENT
BY
WHICH
THE
BID
IS
RAISED
IN
EACH
STEP
AND
THAT
THE
LAST
REMAINING
BIDDER
ACTUALLY
WINS
ONLY
AFTER
ONE
MORE
RAISING
OF
THE
BID
BY
THIS
TINY
INCREMENT
BUT
KEEPING
TRACK
OF
THIS
SMALL
INCREMENT
MAKES
FOR
A
MORE
CUMBERSOME
ANALYSIS
WITHOUT
CHANGING
THE
UNDERLYING
IDEAS
AND
SO
WE
WILL
ASSUME
THAT
THE
AUCTION
ENDS
AT
PRECISELY
THE
MOMENT
WHEN
THE
SECOND
HIGHEST
BIDDER
DROPS
OUT
COMPARING
AUCTION
FORMATS
IN
THE
NEXT
TWO
SECTIONS
WE
WILL
CONSIDER
THE
TWO
MAIN
FORMATS
FOR
SEALED
BID
AUCTIONS
IN
MORE
DETAIL
BEFORE
DOING
THIS
IT
WORTH
MAKING
TWO
POINTS
FIRST
THE
DISCUSSION
IN
THIS
SECTION
SHOWS
THAT
WHEN
WE
ANALYZE
BIDDER
BEHAV
IOR
IN
SEALED
BID
AUCTIONS
WE
RE
ALSO
LEARNING
ABOUT
THEIR
INTERACTIVE
ANALOGUES
WITH
THE
DESCENDING
BID
AUCTION
AS
THE
ANALOGUE
OF
THE
SEALED
BID
FIRST
PRICE
AUCTION
AND
THE
ASCENDING
BID
AUCTION
AS
THE
ANALOGUE
OF
THE
SEALED
BID
SECOND
PRICE
AUCTION
SECOND
A
PURELY
SUPERFICIAL
COMPARISON
OF
THE
FIRST
PRICE
AND
SECOND
PRICE
SEALED
BID
AUCTIONS
MIGHT
SUGGEST
THAT
THE
SELLER
WOULD
GET
MORE
MONEY
FOR
THE
ITEM
IF
HE
RAN
A
FIRST
PRICE
AUCTION
AFTER
ALL
HE
LL
GET
PAID
THE
HIGHEST
BID
RATHER
THAN
THE
SECOND
HIGHEST
BID
IT
MAY
SEEM
STRANGE
THAT
IN
A
SECOND
PRICE
AUCTION
THE
SELLER
IS
INTENTIONALLY
UNDERCHARGING
THE
BIDDERS
BUT
SUCH
REASONING
IGNORES
ONE
OF
THE
MAIN
MESSAGES
FROM
OUR
STUDY
OF
GAME
THEORY
THAT
WHEN
YOU
MAKE
UP
RULES
TO
GOVERN
PEOPLE
BEHAVIOR
YOU
HAVE
TO
ASSUME
THAT
THEY
LL
ADAPT
THEIR
BEHAVIOR
IN
LIGHT
OF
THE
RULES
HERE
THE
POINT
IS
THAT
BIDDERS
IN
A
FIRST
PRICE
AUCTION
WILL
TEND
TO
BID
LOWER
THAN
THEY
DO
IN
A
SECOND
PRICE
AUCTION
AND
IN
FACT
THIS
LOWERING
OF
BIDS
WILL
TEND
TO
OFFSET
WHAT
WOULD
OTHERWISE
LOOK
LIKE
A
DIFFERENCE
IN
THE
SIZE
OF
THE
WINNING
BID
THIS
CONSIDERATION
WILL
COME
UP
AS
A
CENTRAL
ISSUE
AT
VARIOUS
POINTS
LATER
IN
THE
CHAPTER
SECOND
PRICE
AUCTIONS
THE
SEALED
BID
SECOND
PRICE
AUCTION
IS
PARTICULARLY
INTERESTING
AND
THERE
ARE
A
NUMBER
OF
EXAMPLES
OF
IT
IN
WIDESPREAD
USE
THE
AUCTION
FORM
USED
ON
EBAY
IS
ESSENTIALLY
A
SECOND
PRICE
AUCTION
THE
PRICING
MECHANISM
THAT
SEARCH
ENGINES
USE
TO
SELL
KEYWORD
BASED
ADVERTISING
IS
A
GENERALIZATION
OF
THE
SECOND
PRICE
AUCTION
AS
WE
WILL
SEE
IN
CHAPTER
ONE
OF
THE
MOST
IMPORTANT
RESULTS
IN
AUCTION
THEORY
IS
THE
FACT
WE
MENTIONED
TOWARD
THE
END
OF
THE
PREVIOUS
SECTION
WITH
INDEPENDENT
PRIVATE
VALUES
BIDDING
YOUR
TRUE
VALUE
IS
A
DOMINANT
STRATEGY
IN
A
SECOND
PRICE
SEALED
BID
AUCTION
THAT
IS
THE
BEST
CHOICE
OF
BID
IS
EXACTLY
WHAT
THE
OBJECT
IS
WORTH
TO
YOU
FORMULATING
THE
SECOND
PRICE
AUCTION
AS
A
GAME
TO
SEE
WHY
THIS
IS
TRUE
WE
SET
THINGS
UP
USING
THE
LANGUAGE
OF
GAME
THEORY
DEFINING
THE
AUCTION
IN
TERMS
OF
PLAYERS
STRATEGIES
AND
PAYOFFS
THE
BIDDERS
WILL
CORRESPOND
TO
THE
PLAYERS
LET
VI
BE
BIDDER
I
TRUE
VALUE
FOR
THE
OBJECT
BIDDER
I
STRATEGY
IS
AN
AMOUNT
BI
TO
BID
AS
A
FUNCTION
OF
HER
TRUE
VALUE
VI
IN
A
SECOND
PRICE
SEALED
BID
AUCTION
THE
PAYOFF
TO
BIDDER
I
WITH
VALUE
VI
AND
BID
BI
IS
DEFINED
AS
FOLLOWS
IF
BI
IS
NOT
THE
WINNING
BID
THEN
THE
PAYOFF
TO
I
IS
IF
BI
IS
THE
WINNING
BID
AND
SOME
OTHER
BJ
IS
THE
SECOND
PLACE
BID
THEN
THE
PAYOFF
TO
I
IS
VI
BJ
SECOND
PRICE
AUCTIONS
FIGURE
IF
BIDDER
I
DEVIATES
FROM
A
TRUTHFUL
BID
IN
A
SECOND
PRICE
AUCTION
THE
PAYOFF
IS
ONLY
AFFECTED
IF
THE
CHANGE
IN
BID
CHANGES
THE
WIN
LOSS
OUTCOME
TO
MAKE
THIS
COMPLETELY
WELL
DEFINED
WE
NEED
TO
HANDLE
THE
POSSIBILITY
OF
TIES
WHAT
DO
WE
DO
IF
TWO
PEOPLE
SUBMIT
THE
SAME
BID
AND
IT
TIED
FOR
THE
LARGEST
ONE
WAY
TO
HANDLE
THIS
IS
TO
ASSUME
THAT
THERE
IS
A
FIXED
ORDERING
ON
THE
BIDDERS
THAT
IS
AGREED
ON
IN
ADVANCE
AND
IF
A
SET
OF
BIDDERS
TIES
FOR
THE
NUMERICALLY
LARGEST
BID
THEN
THE
WINNING
BID
IS
THE
ONE
SUBMITTED
BY
THE
BIDDER
IN
THIS
SET
THAT
COMES
FIRST
IN
THIS
ORDER
OUR
FORMULATION
OF
THE
PAYOFFS
WORKS
WITH
THIS
MORE
REFINED
DEFINITION
OF
WINNING
BID
AND
SECOND
PLACE
BID
AND
NOTE
THAT
IN
THE
CASE
OF
A
TIE
THE
WINNING
BIDDER
RECEIVES
THE
ITEM
BUT
PAYS
THE
FULL
VALUE
OF
HER
OWN
BID
FOR
A
PAYOFF
OF
ZERO
SINCE
IN
THE
EVENT
OF
A
TIE
THE
FIRST
PLACE
AND
SECOND
PLACE
BIDS
ARE
EQUAL
THERE
IS
ONE
FURTHER
POINT
WORTH
NOTING
ABOUT
OUR
FORMULATION
OF
AUCTIONS
IN
THE
LANGUAGE
OF
GAME
THEORY
WHEN
WE
DEFINED
GAMES
IN
CHAPTER
WE
ASSUMED
THAT
EACH
PLAYER
KNEW
THE
PAYOFFS
OF
ALL
PLAYERS
IN
THE
GAME
HERE
THIS
ISN
T
THE
CASE
SINCE
THE
BIDDERS
DON
T
KNOW
EACH
OTHER
VALUES
AND
SO
STRICTLY
SPEAKING
WE
NEED
TO
USE
A
SLIGHT
GENERALIZATION
OF
THE
NOTIONS
FROM
CHAPTER
TO
HANDLE
THIS
LACK
OF
KNOWLEDGE
FOR
OUR
ANALYSIS
HERE
HOWEVER
SINCE
WE
ARE
FOCUSING
ON
DOMINANT
STRATEGIES
IN
WHICH
A
PLAYER
HAS
AN
OPTIMAL
STRATEGY
REGARDLESS
OF
THE
OTHER
PLAYERS
BEHAVIOR
WE
WILL
BE
ABLE
TO
DISREGARD
THIS
SUBTLETY
TRUTHFUL
BIDDING
IN
SECOND
PRICE
AUCTIONS
THE
PRECISE
STATEMENT
OF
OUR
CLAIM
ABOUT
SECOND
PRICE
AUCTIONS
IS
AS
FOLLOWS
CLAIM
IN
A
SEALED
BID
SECOND
PRICE
AUCTION
IT
IS
A
DOMINANT
STRATEGY
FOR
EACH
BIDDER
I
TO
CHOOSE
A
BID
BI
VI
TO
PROVE
THIS
CLAIM
WE
NEED
TO
SHOW
THAT
IF
BIDDER
I
BIDS
BI
VI
THEN
NO
DEVIATION
FROM
THIS
BID
WOULD
IMPROVE
HER
PAYOFF
REGARDLESS
OF
WHAT
STRATEGY
EVERYONE
ELSE
IS
USING
THERE
ARE
TWO
CASES
TO
CONSIDER
DEVIATIONS
IN
WHICH
I
RAISES
HER
BID
AND
DEVIATIONS
IN
WHICH
I
LOWERS
HER
BID
THE
KEY
POINT
IN
BOTH
CASES
IS
THAT
THE
VALUE
OF
I
BID
ONLY
AFFECTS
WHETHER
I
WINS
OR
LOSES
BUT
NEVER
AFFECTS
HOW
MUCH
I
PAYS
IN
THE
EVENT
THAT
SHE
WINS
THE
AMOUNT
PAID
IS
DETERMINED
ENTIRELY
BY
THE
OTHER
BIDS
AND
IN
PARTICULAR
BY
THE
LARGEST
AMONG
THE
OTHER
BIDS
SINCE
ALL
OTHER
BIDS
REMAIN
THE
SAME
WHEN
I
CHANGES
HER
BID
A
CHANGE
TO
I
BID
ONLY
AFFECTS
HER
PAYOFF
IF
IT
CHANGES
HER
WIN
LOSS
OUTCOME
THIS
ARGUMENT
IS
SUMMARIZED
IN
FIGURE
WITH
THIS
IN
MIND
LET
CONSIDER
THE
TWO
CASES
FIRST
SUPPOSE
THAT
INSTEAD
OF
BIDDING
VI
BIDDER
I
CHOOSES
A
BID
BTI
VI
THIS
ONLY
AFFECTS
BIDDER
I
PAYOFF
IF
I
WOULD
LOSE
WITH
BID
VI
BUT
WOULD
WIN
WITH
BID
BTI
IN
ORDER
FOR
THIS
TO
HAPPEN
THE
HIGHEST
OTHER
BID
BJ
MUST
BE
BETWEEN
BI
AND
BTI
IN
THIS
CASE
THE
PAYOFF
TO
I
FROM
DEVIATING
WOULD
BE
AT
MOST
VI
BJ
AND
SO
THIS
DEVIATION
TO
BID
BTI
DOES
NOT
IMPROVE
I
PAYOFF
NEXT
SUPPOSE
THAT
INSTEAD
OF
BIDDING
VI
BIDDER
I
CHOOSES
A
BID
BTIT
VI
THIS
ONLY
AFFECTS
BIDDER
I
PAYOFF
IF
I
WOULD
WIN
WITH
BID
VI
BUT
WOULD
LOSE
WITH
BID
BTIT
SO
BEFORE
DEVIATING
VI
WAS
THE
WINNING
BID
AND
THE
SECOND
PLACE
BID
BK
WAS
BETWEEN
VI
AND
BTIT
IN
THIS
CASE
I
PAYOFF
BEFORE
DEVIATING
WAS
VI
BK
AND
AFTER
DEVIATING
IT
IS
SINCE
I
LOSES
SO
AGAIN
THIS
DEVIATION
DOES
NOT
IMPROVE
I
PAYOFF
THIS
COMPLETES
THE
ARGUMENT
THAT
TRUTHFUL
BIDDING
IS
A
DOMINANT
STRATEGY
IN
A
SEALED
BID
SECOND
PRICE
AUCTION
THE
HEART
OF
THE
ARGUMENT
IS
THE
FACT
NOTED
AT
THE
OUTSET
IN
A
SECOND
PRICE
AUCTION
YOUR
BID
DETERMINES
WHETHER
YOU
WIN
OR
LOSE
BUT
NOT
HOW
MUCH
YOU
PAY
IN
THE
EVENT
THAT
YOU
WIN
THEREFORE
YOU
NEED
TO
EVALUATE
CHANGES
TO
YOUR
BID
IN
LIGHT
OF
THIS
THIS
ALSO
FURTHER
HIGHLIGHTS
THE
PARALLELS
TO
THE
ASCENDING
BID
AUCTION
THERE
TOO
THE
ANALOGUE
OF
YOUR
BID
I
E
THE
POINT
UP
TO
WHICH
YOU
RE
WILLING
TO
STAY
IN
THE
AUCTION
DETERMINES
WHETHER
YOU
LL
STAY
IN
LONG
ENOUGH
TO
WIN
BUT
THE
AMOUNT
YOU
PAY
IN
THE
EVENT
THAT
YOU
WIN
IS
DETERMINED
BY
THE
POINT
AT
WHICH
THE
SECOND
PLACE
BIDDER
DROPS
OUT
THE
FACT
THAT
TRUTHFULNESS
IS
A
DOMINANT
STRATEGY
ALSO
MAKES
SECOND
PRICE
AUCTIONS
CON
CEPTUALLY
VERY
CLEAN
BECAUSE
TRUTHFUL
BIDDING
IS
A
DOMINANT
STRATEGY
IT
IS
THE
BEST
THING
TO
DO
REGARDLESS
OF
WHAT
THE
OTHER
BIDDERS
ARE
DOING
SO
IN
A
SECOND
PRICE
AUCTION
IT
MAKES
FIRST
PRICE
AUCTIONS
AND
OTHER
FORMATS
SENSE
TO
BID
YOUR
TRUE
VALUE
EVEN
IF
OTHER
BIDDERS
ARE
OVERBIDDING
UNDERBIDDING
COLLUDING
OR
BEHAVING
IN
OTHER
UNPREDICTABLE
WAYS
IN
OTHER
WORDS
TRUTHFUL
BIDDING
IS
A
GOOD
IDEA
EVEN
IF
THE
COMPETING
BIDDERS
IN
THE
AUCTION
DON
T
KNOW
THAT
THEY
OUGHT
TO
BE
BIDDING
TRUTHFULLY
AS
WELL
WE
NOW
TURN
TO
FIRST
PRICE
AUCTIONS
WHERE
WE
LL
FIND
THAT
THE
SITUATION
IS
MUCH
MORE
COMPLEX
IN
PARTICULAR
EACH
BIDDER
NOW
HAS
TO
REASON
ABOUT
THE
BEHAVIOR
OF
HER
COMPETITORS
IN
ORDER
TO
ARRIVE
AT
AN
OPTIMAL
CHOICE
FOR
HER
OWN
BID
FIRST
PRICE
AUCTIONS
AND
OTHER
FORMATS
IN
A
SEALED
BID
FIRST
PRICE
AUCTION
THE
VALUE
OF
YOUR
BID
NOT
ONLY
AFFECTS
WHETHER
YOU
WIN
BUT
ALSO
HOW
MUCH
YOU
PAY
AS
A
RESULT
MOST
OF
THE
REASONING
FROM
THE
PREVIOUS
SECTION
HAS
TO
BE
REDONE
AND
THE
CONCLUSIONS
ARE
NOW
DIFFERENT
TO
BEGIN
WITH
WE
CAN
SET
UP
THE
FIRST
PRICE
AUCTION
AS
A
GAME
IN
ESSENTIALLY
THE
SAME
WAY
THAT
WE
DID
FOR
SECOND
PRICE
AUCTIONS
AS
BEFORE
BIDDERS
ARE
PLAYERS
AND
EACH
BIDDER
STRATEGY
IS
AN
AMOUNT
TO
BID
AS
A
FUNCTION
OF
HER
TRUE
VALUE
THE
PAYOFF
TO
BIDDER
I
WITH
VALUE
VI
AND
BID
BI
IS
SIMPLY
THE
FOLLOWING
IF
BI
IS
NOT
THE
WINNING
BID
THEN
THE
PAYOFF
TO
I
IS
IF
BI
IS
THE
WINNING
BID
THEN
THE
PAYOFF
TO
I
IS
VI
BI
THE
FIRST
THING
WE
NOTICE
IS
THAT
BIDDING
YOUR
TRUE
VALUE
IS
NO
LONGER
A
DOMINANT
STRATEGY
BY
BIDDING
YOUR
TRUE
VALUE
YOU
WOULD
GET
A
PAYOFF
OF
IF
YOU
LOSE
AS
USUAL
AND
YOU
WOULD
ALSO
GET
A
PAYOFF
OF
IF
YOU
WIN
SINCE
YOU
D
PAY
EXACTLY
WHAT
IT
WAS
WORTH
TO
YOU
AS
A
RESULT
THE
OPTIMAL
WAY
TO
BID
IN
A
FIRST
PRICE
AUCTION
IS
TO
SHADE
YOUR
BID
SLIGHTLY
DOWNWARD
SO
THAT
IF
YOU
WIN
YOU
WILL
GET
A
POSITIVE
PAYOFF
DETERMINING
HOW
MUCH
TO
SHADE
YOUR
BID
INVOLVES
BALANCING
A
TRADE
OFF
BETWEEN
TWO
OPPOSING
FORCES
IF
YOU
BID
TOO
CLOSE
TO
YOUR
TRUE
VALUE
THEN
YOUR
PAYOFF
WON
T
BE
VERY
LARGE
IN
THE
EVENT
THAT
YOU
WIN
BUT
IF
YOU
BID
TOO
FAR
BELOW
YOUR
TRUE
VALUE
SO
AS
TO
INCREASE
YOUR
PAYOFF
IN
THE
EVENT
OF
WINNING
THEN
YOU
REDUCE
YOUR
CHANCE
OF
BEING
THE
HIGH
BID
AND
HENCE
YOUR
CHANCE
OF
WINNING
AT
ALL
FINDING
THE
OPTIMAL
TRADE
OFF
BETWEEN
THESE
TWO
FACTORS
IS
A
COMPLEX
PROBLEM
THAT
DE
PENDS
ON
KNOWLEDGE
OF
THE
OTHER
BIDDERS
AND
THEIR
DISTRIBUTION
OF
POSSIBLE
VALUES
FOR
EXAMPLE
IT
IS
INTUITIVELY
NATURAL
THAT
YOUR
BID
SHOULD
BE
HIGHER
I
E
SHADED
LESS
CLOSER
TO
YOUR
TRUE
VALUE
IN
A
FIRST
PRICE
AUCTION
WITH
MANY
COMPETING
BIDDERS
THAN
IN
A
FIRST
PRICE
AUCTION
WITH
ONLY
A
FEW
COMPETING
BIDDERS
KEEPING
OTHER
PROPERTIES
OF
THE
BIDDERS
THE
SAME
THIS
IS
SIMPLY
BECAUSE
WITH
A
LARGE
POOL
OF
OTHER
BIDDERS
THE
HIGHEST
COMPETING
BID
IS
LIKELY
TO
BE
LARGER
AND
HENCE
YOU
NEED
TO
BID
HIGHER
TO
GET
ABOVE
THIS
AND
BE
THE
HIGHEST
BID
WE
WILL
DISCUSS
HOW
TO
DETERMINE
THE
OPTIMAL
BID
FOR
A
FIRST
PRICE
AUCTION
IN
SECTION
ALL
PAY
AUCTIONS
THERE
ARE
OTHER
SEALED
BID
AUCTION
FORMATS
THAT
ARISE
IN
DIFFERENT
SET
TINGS
ONE
THAT
INITIALLY
SEEMS
COUNTER
INTUITIVE
IN
ITS
FORMULATION
IS
THE
ALL
PAY
AUCTION
EACH
BIDDER
SUBMITS
A
BID
THE
HIGHEST
BIDDER
RECEIVES
THE
ITEM
AND
ALL
BIDDERS
PAY
THEIR
BIDS
REGARDLESS
OF
WHETHER
THEY
WIN
OR
LOSE
THAT
IS
THE
PAYOFFS
ARE
NOW
AS
FOLLOWS
IF
BI
IS
NOT
THE
WINNING
BID
THEN
THE
PAYOFF
TO
I
IS
BI
IF
BI
IS
THE
WINNING
BID
THEN
THE
PAYOFF
TO
I
IS
VI
BI
GAMES
WITH
THIS
TYPE
OF
PAYOFF
ARISE
IN
A
NUMBER
OF
SITUATIONS
USUALLY
WHERE
THE
NOTION
OF
BIDDING
IS
IMPLICIT
POLITICAL
LOBBYING
CAN
BE
MODELED
IN
THIS
WAY
EACH
SIDE
MUST
SPEND
MONEY
ON
LOBBYING
BUT
ONLY
THE
SUCCESSFUL
SIDE
RECEIVES
ANYTHING
OF
VALUE
FOR
THIS
EXPENDITURE
WHILE
IT
IS
NOT
TRUE
THAT
THE
SIDE
SPENDING
MORE
ON
LOBBYING
ALWAYS
WINS
THERE
IS
A
CLEAR
ANALOGY
BETWEEN
THE
AMOUNT
SPENT
ON
LOBBYING
AND
A
BID
WITH
ALL
PARTIES
PAYING
THEIR
BID
REGARDLESS
OF
WHETHER
THEY
WIN
OR
LOSE
ONE
CAN
PICTURE
SIMILAR
CONSIDERATIONS
ARISING
IN
SETTINGS
SUCH
AS
DESIGN
COMPETITIONS
WHERE
COMPETING
ARCHITECTURAL
FIRMS
SPEND
MONEY
ON
PRELIMINARY
DESIGNS
TO
TRY
TO
WIN
A
CONTRACT
FROM
A
CLIENT
THIS
MONEY
MUST
BE
SPENT
BEFORE
THE
CLIENT
MAKES
A
DECISION
THE
DETERMINATION
OF
AN
OPTIMAL
BID
IN
AN
ALL
PAY
AUCTION
SHARES
A
NUMBER
OF
QUALITATIVE
FEATURES
WITH
THE
REASONING
IN
A
FIRST
PRICE
AUCTION
IN
GENERAL
YOU
WANT
TO
BID
BELOW
YOUR
TRUE
VALUE
AND
YOU
MUST
BALANCE
THE
TRADE
OFF
BETWEEN
BIDDING
HIGH
INCREASING
YOUR
PROBABILITY
OF
WINNING
AND
BIDDING
LOW
DECREASING
YOUR
EXPENDITURE
IF
YOU
LOSE
AND
INCREASING
YOUR
PAYOFF
IF
YOU
WIN
IN
GENERAL
THE
FACT
THAT
EVERYONE
MUST
PAY
IN
THIS
AUCTION
FORMAT
MEANS
THAT
BIDS
WILL
TYPICALLY
BE
SHADED
MUCH
LOWER
THAN
IN
A
FIRST
PRICE
AUCTION
THE
FRAMEWORK
WE
DEVELOP
FOR
DETERMINING
OPTIMAL
BIDS
IN
FIRST
PRICE
AUCTIONS
WILL
ALSO
APPLY
TO
ALL
PAY
AUCTIONS
AS
WE
WILL
SEE
IN
SECTION
COMMON
VALUES
AND
THE
WINNER
CURSE
THUS
FAR
WE
HAVE
ASSUMED
THAT
BIDDERS
VALUES
FOR
THE
ITEM
BEING
AUCTIONED
ARE
INDEPENDENT
EACH
BIDDER
KNOWS
HER
OWN
VALUE
FOR
THE
ITEM
AND
IS
NOT
CONCERNED
WITH
HOW
MUCH
IT
IS
WORTH
TO
ANYONE
ELSE
THIS
MAKES
SENSE
IN
A
LOT
OF
SITUATIONS
BUT
IT
CLEARLY
DOESN
T
APPLY
TO
A
SETTING
IN
WHICH
THE
BIDDERS
INTEND
TO
RESELL
THE
OBJECT
IN
THIS
CASE
THERE
IS
A
COMMON
EVENTUAL
VALUE
FOR
THE
OBJECT
THE
AMOUNT
IT
WILL
GENERATE
ON
RESALE
BUT
IT
IS
NOT
NECESSARILY
KNOWN
EACH
BIDDER
I
MAY
HAVE
SOME
PRIVATE
INFORMATION
ABOUT
THE
COMMON
VALUE
LEADING
TO
AN
ESTIMATE
VI
OF
THIS
VALUE
INDIVIDUAL
BIDDER
ESTIMATES
WILL
TYPICALLY
BE
SLIGHTLY
WRONG
AND
THEY
WILL
ALSO
TYPICALLY
NOT
BE
INDEPENDENT
OF
EACH
OTHER
ONE
POSSIBLE
MODEL
FOR
SUCH
ESTIMATES
IS
TO
SUPPOSE
THAT
THE
TRUE
VALUE
IS
V
AND
THAT
EACH
BIDDER
I
ESTIMATE
VI
IS
DEFINED
BY
VI
V
XI
WHERE
XI
IS
A
RANDOM
NUMBER
WITH
A
MEAN
OF
REPRESENTING
THE
ERROR
IN
I
ESTIMATE
COMMON
VALUES
AND
THE
WINNER
CURSE
AUCTIONS
WITH
COMMON
VALUES
INTRODUCE
NEW
SOURCES
OF
COMPLEXITY
TO
SEE
THIS
LET
START
BY
SUPPOSING
THAT
AN
ITEM
WITH
A
COMMON
VALUE
IS
SOLD
USING
A
SECOND
PRICE
AUCTION
IS
IT
STILL
A
DOMINANT
STRATEGY
FOR
BIDDER
I
TO
BID
VI
IN
FACT
IT
NOT
TO
GET
A
SENSE
FOR
WHY
THIS
IS
WE
CAN
USE
THE
MODEL
WITH
RANDOM
ERRORS
V
XI
SUPPOSE
THERE
ARE
MANY
BIDDERS
AND
THAT
EACH
BIDS
HER
ESTIMATE
OF
THE
TRUE
VALUE
THEN
FROM
THE
RESULT
OF
THE
AUCTION
THE
WINNING
BIDDER
NOT
ONLY
RECEIVES
THE
OBJECT
SHE
ALSO
LEARNS
SOMETHING
ABOUT
HER
ESTIMATE
OF
THE
COMMON
VALUE
THAT
IT
WAS
THE
HIGHEST
OF
ALL
THE
ESTIMATES
SO
IN
PARTICULAR
HER
ESTIMATE
IS
MORE
LIKELY
TO
BE
AN
OVER
ESTIMATE
OF
THE
COMMON
VALUE
THAN
AN
UNDER
ESTIMATE
MOREOVER
WITH
MANY
BIDDERS
THE
SECOND
PLACE
BID
WHICH
IS
WHAT
SHE
PAID
IS
ALSO
LIKELY
TO
BE
AN
OVER
ESTIMATE
AS
A
RESULT
SHE
WILL
LIKELY
LOSE
MONEY
ON
THE
RESALE
RELATIVE
TO
WHAT
SHE
PAID
THIS
IS
KNOWN
AS
THE
WINNER
CURSE
AND
IT
IS
A
PHENOMENON
THAT
HAS
A
RICH
HISTORY
IN
THE
STUDY
OF
AUCTIONS
RICHARD
THALER
REVIEW
OF
THIS
HISTORY
NOTES
THAT
THE
WINNER
CURSE
APPEARS
TO
HAVE
BEEN
FIRST
ARTICULATED
BY
RESEARCHERS
IN
THE
PETROLEUM
INDUSTRY
IN
THIS
DOMAIN
FIRMS
BID
ON
OIL
DRILLING
RIGHTS
FOR
TRACTS
OF
LAND
THAT
HAVE
A
COMMON
VALUE
EQUAL
TO
THE
VALUE
OF
THE
OIL
CONTAINED
IN
THE
TRACT
THE
WINNER
CURSE
HAS
ALSO
BEEN
STUDIED
IN
THE
CONTEXT
OF
COMPETITIVE
CONTRACT
OFFERS
TO
BASEBALL
FREE
AGENTS
WITH
THE
UNKNOWN
COMMON
VALUE
CORRESPONDING
TO
THE
FUTURE
PERFORMANCE
OF
THE
BASEBALL
PLAYER
BEING
COURTED
RATIONAL
BIDDERS
SHOULD
TAKE
THE
WINNER
CURSE
INTO
ACCOUNT
IN
DECIDING
ON
THEIR
BIDS
A
BIDDER
SHOULD
BID
HER
BEST
ESTIMATE
OF
THE
VALUE
OF
THE
OBJECT
CONDITIONAL
ON
BOTH
HER
PRIVATE
ESTIMATE
VI
AND
ON
WINNING
THE
OBJECT
AT
HER
BID
THAT
IS
IT
MUST
BE
THE
CASE
THAT
AT
AN
OPTIMAL
BID
IT
IS
BETTER
TO
WIN
THE
OBJECT
THAN
NOT
TO
WIN
IT
THIS
MEANS
IN
A
COMMON
VALUE
AUCTION
BIDDERS
WILL
SHADE
THEIR
BIDS
DOWNWARD
EVEN
WHEN
THE
SECOND
PRICE
FORMAT
IS
USED
WITH
THE
FIRST
PRICE
FORMAT
BIDS
WILL
BE
REDUCED
EVEN
FURTHER
DETERMINING
THE
OPTIMAL
BID
IS
FAIRLY
COMPLEX
AND
WE
WILL
NOT
PURSUE
THE
DETAILS
OF
IT
HERE
IT
IS
ALSO
WORTH
NOTING
THAT
IN
PRACTICE
THE
WINNER
CURSE
CAN
LEAD
TO
OUTRIGHT
LOSSES
ON
THE
PART
OF
THE
WINNING
BIDDER
SINCE
IN
A
LARGE
POOL
OF
BIDDERS
ANYONE
WHO
IN
FACT
MAKES
AN
ERROR
AND
OVERBIDS
IS
MORE
LIKELY
TO
BE
THE
WINNER
OF
THE
AUCTION
THESE
CASES
AS
WELL
AS
OTHERS
ONE
COULD
ARGUE
THAT
THE
MODEL
OF
COMMON
VALUES
IS
NOT
ENTIRELY
ACCURATE
ONE
OIL
COMPANY
COULD
IN
PRINCIPLE
BE
MORE
SUCCESSFUL
THAN
ANOTHER
AT
EXTRACTING
OIL
FROM
A
TRACT
OF
LAND
AND
A
BASEBALL
FREE
AGENT
MAY
FLOURISH
IF
HE
JOINS
ONE
TEAM
BUT
FAIL
IF
HE
JOINS
ANOTHER
BUT
COMMON
VALUES
ARE
A
REASONABLE
APPROXIMATION
TO
BOTH
SETTINGS
AS
TO
ANY
CASE
WHERE
THE
PURPOSE
OF
BIDDING
IS
TO
OBTAIN
AN
ITEM
THAT
HAS
SOME
INTRINSIC
BUT
UNKNOWN
FUTURE
VALUE
MOREOVER
THE
REASONING
BEHIND
THE
WINNER
CURSE
ARISES
EVEN
WHEN
THE
ITEM
BEING
AUCTIONED
HAS
RELATED
BUT
NON
IDENTICAL
VALUES
TO
THE
DIFFERENT
BIDDERS
ADVANCED
MATERIAL
BIDDING
STRATEGIES
IN
FIRST
PRICE
AND
ALL
PAY
AUCTIONS
IN
THE
PREVIOUS
TWO
SECTIONS
WE
OFFERED
SOME
INTUITION
ABOUT
THE
WAY
TO
BID
IN
FIRST
PRICE
AUCTIONS
AND
IN
ALL
PAY
AUCTIONS
BUT
WE
DID
NOT
DERIVE
OPTIMAL
BIDS
WE
NOW
DEVELOP
MODELS
OF
BIDDER
BEHAVIOR
UNDER
WHICH
WE
CAN
DERIVE
EQUILIBRIUM
BIDDING
STRATEGIES
IN
THESE
AUCTIONS
WE
THEN
EXPLORE
HOW
OPTIMAL
BEHAVIOR
VARIES
DEPENDING
ON
THE
NUMBER
OF
BIDDERS
AND
ON
THE
DISTRIBUTION
OF
VALUES
FINALLY
WE
ANALYZE
HOW
MUCH
REVENUE
THE
SELLER
CAN
EXPECT
TO
OBTAIN
FROM
VARIOUS
AUCTIONS
THE
ANALYSIS
IN
THIS
SECTION
WILL
USE
ELEMENTARY
CALCULUS
AND
PROBABILITY
THEORY
A
EQUILIBRIUM
BIDDING
IN
FIRST
PRICE
AUCTIONS
AS
THE
BASIS
FOR
THE
MODEL
WE
WANT
TO
CAPTURE
A
SETTING
IN
WHICH
BIDDERS
KNOW
HOW
MANY
COMPETITORS
THEY
HAVE
AND
THEY
HAVE
PARTIAL
INFORMATION
ABOUT
THEIR
COMPETITORS
VALUES
FOR
THE
ITEM
HOWEVER
THEY
DO
NOT
KNOW
THEIR
COMPETITORS
VALUES
EXACTLY
LET
START
WITH
A
SIMPLE
CASE
FIRST
AND
THEN
MOVE
ON
TO
A
MORE
GENERAL
FORMULATION
IN
THE
SIMPLE
CASE
SUPPOSE
THAT
THERE
ARE
TWO
BIDDERS
EACH
WITH
A
PRIVATE
VALUE
THAT
IS
INDEPENDENTLY
AND
UNIFORMLY
DISTRIBUTED
BETWEEN
AND
THIS
INFORMATION
IS
COMMON
KNOWLEDGE
AMONG
THE
TWO
BIDDERS
A
STRATEGY
FOR
A
BIDDER
IS
A
FUNCTION
V
B
THAT
MAPS
HER
TRUE
VALUE
V
TO
A
NON
NEGATIVE
BID
B
WE
WILL
MAKE
THE
FOLLOWING
SIMPLE
ASSUMPTIONS
ABOUT
THE
STRATEGIES
THE
BIDDERS
ARE
USING
I
IS
A
STRICTLY
INCREASING
DIFFERENTIABLE
FUNCTION
SO
IN
PARTICULAR
IF
TWO
BIDDERS
HAVE
DIFFERENT
VALUES
THEN
THEY
WILL
PRODUCE
DIFFERENT
BIDS
II
V
V
FOR
ALL
V
BIDDERS
CAN
SHADE
THEIR
BIDS
DOWN
BUT
THEY
WILL
NEVER
BID
ABOVE
THEIR
TRUE
VALUES
NOTICE
THAT
SINCE
BIDS
ARE
ALWAYS
NON
NEGATIVE
THIS
ALSO
MEANS
THAT
THESE
TWO
ASSUMPTIONS
PERMIT
A
WIDE
RANGE
OF
STRATEGIES
FOR
EXAMPLE
THE
STRATEGY
OF
BIDDING
YOUR
TRUE
VALUE
IS
REPRESENTED
BY
THE
FUNCTION
V
V
WHILE
THE
STRATEGY
OF
SHADING
YOUR
BID
DOWNWARD
TO
BY
A
FACTOR
OF
C
TIMES
YOUR
TRUE
VALUE
IS
REPRESENTED
BY
V
CV
MORE
COMPLEX
STRATEGIES
SUCH
AS
V
ARE
ALSO
ALLOWED
ALTHOUGH
WE
WILL
SEE
THAT
IN
FIRST
PRICE
AUCTIONS
THEY
ARE
NOT
OPTIMAL
THE
TWO
ASSUMPTIONS
HELP
US
NARROW
THE
SEARCH
FOR
EQUILIBRIUM
STRATEGIES
THE
SECOND
OF
OUR
ASSUMPTIONS
ONLY
RULES
OUT
STRATEGIES
BASED
ON
OVERBIDDING
THAT
ARE
NON
OPTIMAL
FACT
THAT
THE
AND
ARE
THE
LOWEST
AND
HIGHEST
POSSIBLE
VALUES
IS
NOT
CRUCIAL
BY
SHIFTING
AND
RE
SCALING
THESE
QUANTITIES
WE
COULD
EQUALLY
WELL
CONSIDER
VALUES
THAT
ARE
UNIFORMLY
DISTRIBUTED
BETWEEN
ANY
OTHER
PAIR
OF
ENDPOINTS
THE
FIRST
ASSUMPTION
RESTRICTS
THE
SCOPE
OF
POSSIBLE
EQUILIBRIUM
STRATEGIES
BUT
IT
MAKES
THE
ANALYSIS
EASIER
WHILE
STILL
ALLOWING
US
TO
STUDY
THE
IMPORTANT
ISSUES
FINALLY
SINCE
THE
TWO
BIDDERS
ARE
IDENTICAL
IN
ALL
WAYS
EXCEPT
THE
ACTUAL
VALUE
THEY
DRAW
FROM
THE
DISTRIBUTION
WE
WILL
NARROW
THE
SEARCH
FOR
EQUILIBRIA
IN
ONE
FURTHER
WAY
WE
WILL
CONSIDER
THE
CASE
IN
WHICH
THE
TWO
BIDDERS
FOLLOW
THE
SAME
STRATEGY
EQUILIBRIUM
WITH
TWO
BIDDERS
THE
REVELATION
PRINCIPLE
LET
CONSIDER
WHAT
SUCH
AN
EQUILIBRIUM
STRATEGY
SHOULD
LOOK
LIKE
FIRST
ASSUMPTION
I
SAYS
THAT
THE
BIDDER
WITH
THE
HIGHER
VALUE
WILL
ALSO
PRODUCE
THE
HIGHER
BID
IF
BIDDER
I
HAS
A
VALUE
OF
VI
THE
PROBABILITY
THAT
THIS
IS
HIGHER
THAN
THE
VALUE
OF
I
COMPETITOR
IN
THE
INTERVAL
IS
EXACTLY
VI
THEREFORE
I
WILL
WIN
THE
AUCTION
WITH
PROBABILITY
VI
IF
I
DOES
WIN
I
RECEIVES
A
PAYOFF
OF
VI
VI
PUTTING
ALL
THIS
TOGETHER
WE
SEE
THAT
I
EXPECTED
PAYOFF
IS
G
VI
VI
VI
VI
NOW
WHAT
DOES
IT
MEAN
FOR
TO
BE
AN
EQUILIBRIUM
STRATEGY
IT
MEANS
THAT
FOR
EACH
BIDDER
I
THERE
IS
NO
INCENTIVE
FOR
I
TO
DEVIATE
FROM
STRATEGY
IF
I
COMPETITOR
IS
ALSO
USING
STRATEGY
IT
NOT
IMMEDIATELY
CLEAR
HOW
TO
ANALYZE
DEVIATIONS
TO
AN
ARBITRARY
STRATEGY
SATISFYING
ASSUMPTIONS
I
AND
II
ABOVE
FORTUNATELY
THERE
IS
AN
ELEGANT
DEVICE
THAT
LETS
US
REASON
ABOUT
DEVIATIONS
AS
FOLLOWS
RATHER
THEN
ACTUALLY
SWITCHING
TO
A
DIFFERENT
STRATEGY
BIDDER
I
CAN
IMPLEMENT
HER
DEVIATION
BY
KEEPING
THE
STRATEGY
BUT
SUPPLYING
A
DIFFERENT
TRUE
VALUE
TO
IT
HERE
IS
HOW
THIS
WORKS
FIRST
IF
I
COMPETITOR
IS
ALSO
USING
STRATEGY
THEN
I
SHOULD
NEVER
ANNOUNCE
A
BID
ABOVE
SINCE
I
CAN
WIN
WITH
BID
AND
GET
A
HIGHER
PAYOFF
WITH
BID
THAN
WITH
ANY
BID
B
SO
IN
ANY
POSSIBLE
DEVIATION
BY
I
THE
BID
SHE
WILL
ACTUALLY
REPORT
WILL
LIE
BETWEEN
AND
THEREFORE
FOR
THE
PURPOSES
OF
THE
AUCTION
SHE
CAN
SIMULATE
HER
DEVIATION
TO
AN
ALTERNATE
STRATEGY
BY
FIRST
PRETENDING
THAT
HER
TRUE
VALUE
IS
VIT
RATHER
THAN
VI
AND
THEN
APPLYING
THE
EXISTING
FUNCTION
TO
VIT
INSTEAD
OF
VI
THIS
IS
A
SPECIAL
CASE
OF
A
MUCH
BROADER
IDEA
KNOWN
AS
THE
REVELATION
PRINCIPLE
FOR
OUR
PURPOSES
WE
CAN
THINK
OF
IT
AS
SAYING
THAT
DEVIATIONS
IN
THE
BIDDING
STRATEGY
FUNCTION
CAN
INSTEAD
BE
VIEWED
AS
DEVIATIONS
IN
THE
TRUE
VALUE
THAT
BIDDER
I
SUPPLIES
TO
HER
CURRENT
STRATEGY
WITH
THIS
IN
MIND
WE
CAN
WRITE
THE
CONDITION
THAT
I
DOES
NOT
WANT
TO
DEVIATE
FROM
STRATEGY
AS
FOLLOWS
VI
VI
VI
V
VI
V
FOR
ALL
POSSIBLE
ALTERNATE
TRUE
VALUES
V
BETWEEN
AND
THAT
BIDDER
I
MIGHT
WANT
TO
SUPPLY
TO
THE
FUNCTION
IS
THERE
A
FUNCTION
THAT
SATISFIES
THIS
PROPERTY
IN
FACT
IT
IS
NOT
HARD
TO
CHECK
THAT
V
V
SATISFIES
IT
TO
SEE
WHY
NOTICE
THAT
WITH
THIS
CHOICE
OF
THE
LEFT
HAND
SIDE
OF
INEQUALITY
BECOMES
VI
VI
VI
WHILE
THE
RIGHT
HAND
SIDE
BECOMES
V
VI
V
VVI
COLLECTING
ALL
THE
TERMS
ON
THE
LEFT
THE
INEQUALITY
BECOMES
SIMPLY
I
WHICH
HOLDS
BECAUSE
THE
LEFT
HAND
SIDE
IS
THE
SQUARE
V
VI
THUS
THE
CONCLUSION
IN
THIS
CASE
IS
QUITE
SIMPLE
TO
STATE
IF
TWO
BIDDERS
KNOW
THEY
ARE
COMPETING
AGAINST
EACH
OTHER
AND
KNOW
THAT
EACH
HAS
A
PRIVATE
VALUE
DRAWN
UNIFORMLY
AT
RANDOM
FROM
THE
INTERVAL
THEN
IT
IS
AN
EQUILIBRIUM
FOR
EACH
TO
SHADE
THEIR
BID
DOWN
BY
A
FACTOR
OF
BIDDING
HALF
YOUR
TRUE
VALUE
IS
OPTIMAL
BEHAVIOR
IF
THE
OTHER
BIDDER
IS
DOING
THIS
AS
WELL
NOTE
THAT
UNLIKE
THE
CASE
OF
THE
SECOND
PRICE
AUCTION
WE
HAVE
NOT
IDENTIFIED
A
DOMINANT
STRATEGY
ONLY
AN
EQUILIBRIUM
IN
SOLVING
FOR
A
BIDDER
OPTIMAL
STRATEGY
WE
USED
EACH
BIDDER
EXPECTATION
ABOUT
HER
COMPETITOR
BIDDING
STRATEGY
IN
AN
EQUILIBRIUM
THESE
EXPECTATIONS
ARE
CORRECT
BUT
IF
OTHER
BIDDERS
FOR
SOME
REASON
USE
NON
EQUILIBRIUM
STRATEGIES
THEN
ANY
BIDDER
SHOULD
OPTIMALLY
RESPOND
AND
POTENTIALLY
ALSO
PLAY
SOME
OTHER
BIDDING
STRATEGY
DERIVING
THE
TWO
BIDDER
EQUILIBRIUM
IN
OUR
DISCUSSION
OF
THE
EQUILIBRIUM
V
V
WE
INITIALLY
CONJECTURED
THE
FORM
OF
THE
FUNCTION
AND
THEN
CHECKED
THAT
IT
SATISFIED
INEQUALITY
BUT
THIS
APPROACH
DOES
NOT
SUGGEST
HOW
TO
DISCOVER
A
FUNCTION
TO
USE
AS
A
CONJECTURE
AN
ALTERNATE
APPROACH
IS
TO
DERIVE
DIRECTLY
BY
REASONING
ABOUT
THE
CONDITION
IN
INEQUALITY
HERE
IS
HOW
WE
CAN
DO
THIS
IN
ORDER
FOR
S
TO
SATISFY
INEQUALITY
IT
MUST
HAVE
THE
PROPERTY
THAT
FOR
ANY
TRUE
VALUE
VI
THE
EXPECTED
PAYOFF
FUNCTION
G
V
V
VI
S
V
IS
MAXIMIZED
BY
SETTING
V
VI
THEREFORE
VI
SHOULD
SATISFY
GT
VI
WHERE
GT
IS
THE
FIRST
DERIVATIVE
OF
G
WITH
RESPECT
TO
V
SINCE
GT
V
VI
S
V
VST
V
BY
THE
PRODUCT
RULE
FOR
DERIVATIVES
WE
SEE
THAT
S
MUST
SOLVE
THE
DIFFERENTIAL
EQUATION
ST
V
S
VI
VI
FOR
ALL
VI
IN
THE
INTERVAL
THIS
DIFFERENTIAL
EQUATION
IS
SOLVED
BY
THE
FUNCTION
S
VI
VI
EQUILIBRIUM
WITH
MANY
BIDDERS
NOW
LET
S
SUPPOSE
THAT
THERE
ARE
N
BIDDERS
WHERE
N
CAN
BE
LARGER
THAN
TWO
TO
START
WITH
WE
LL
CONTINUE
TO
ASSUME
THAT
EACH
BIDDER
I
DRAWS
HER
TRUE
VALUE
VI
INDEPENDENTLY
AND
UNIFORMLY
AT
RANDOM
FROM
THE
INTERVAL
BETWEEN
AND
MUCH
OF
THE
REASONING
FOR
THE
CASE
OF
TWO
BIDDERS
STILL
WORKS
HERE
ALTHOUGH
THE
BASIC
FORMULA
FOR
THE
EXPECTED
PAYOFF
CHANGES
SPECIFICALLY
ASSUMPTION
I
STILL
IMPLIES
THAT
THE
BIDDER
WITH
THE
HIGHEST
TRUE
VALUE
WILL
PRODUCE
THE
HIGHEST
BID
AND
HENCE
WIN
THE
AUCTION
FOR
A
GIVEN
BIDDER
I
WITH
TRUE
VALUE
VI
WHAT
IS
THE
PROBABILITY
THAT
HER
BID
IS
THE
HIGHEST
THIS
REQUIRES
EACH
OTHER
BIDDER
TO
HAVE
A
VALUE
BELOW
VI
SINCE
THE
VALUES
ARE
CHOSEN
INDEPENDENTLY
THIS
EVENT
HAS
A
PROBABILITY
OF
VN
THEREFORE
BIDDER
I
S
EXPECTED
PAYOFF
IS
G
VI
VN
VI
S
VI
THE
CONDITION
FOR
S
TO
BE
AN
EQUILIBRIUM
STRATEGY
REMAINS
THE
SAME
AS
IT
WAS
IN
THE
CASE
OF
TWO
BIDDERS
USING
THE
REVELATION
PRINCIPLE
WE
VIEW
A
DEVIATION
FROM
THE
BIDDING
STRATEGY
AS
SUPPLYING
A
FAKE
VALUE
V
TO
THE
FUNCTION
S
GIVEN
THIS
WE
REQUIRE
THAT
THE
TRUE
VALUE
VI
PRODUCES
AN
EXPECTED
PAYOFF
AT
LEAST
AS
HIGH
AS
THE
PAYOFF
FROM
ANY
DEVIATION
VN
VI
S
VI
VN
VI
S
V
FOR
ALL
V
BETWEEN
AND
FROM
THIS
WE
CAN
DERIVE
THE
FORM
OF
THE
BIDDING
FUNCTION
S
USING
THE
DIFFERENTIAL
EQUATION
APPROACH
THAT
WORKED
FOR
TWO
BIDDERS
THE
EXPECTED
PAYOFF
FUNCTION
G
V
VN
VI
S
V
MUST
BE
MAXIMIZED
BY
SETTING
V
VI
SETTING
THE
DERIVATIVE
GT
VI
AND
APPLYING
THE
PRODUCT
RULE
TO
DIFFERENTIATE
G
WE
GET
N
VN
N
VN
VI
VN
VI
FOR
ALL
VI
BETWEEN
AND
DIVIDING
THROUGH
BY
N
VN
AND
SOLVING
FOR
ST
VI
WE
GET
THE
EQUIVALENT
BUT
TYPOGRAPHICALLY
SIMPLER
EQUATION
ST
V
N
S
VI
FOR
ALL
VI
BETWEEN
AND
THIS
DIFFERENTIAL
EQUATION
IS
SOLVED
BY
THE
FUNCTION
S
V
N
V
SO
IF
EACH
BIDDER
SHADES
HER
BID
DOWN
BY
A
FACTOR
OF
N
N
THEN
THIS
IS
OPTIMAL
BEHAVIOR
GIVEN
WHAT
EVERYONE
ELSE
IS
DOING
NOTICE
THAT
WHEN
N
THIS
IS
OUR
TWO
BIDDER
STRATEGY
THE
FORM
OF
THIS
STRATEGY
HIGHLIGHTS
AN
IMPORTANT
PRINCIPLE
THAT
WE
DISCUSSED
IN
SECTION
ABOUT
STRATEGIC
BIDDING
IN
FIRST
PRICE
AUCTIONS
AS
THE
NUMBER
OF
BIDDERS
INCREASES
YOU
GENERALLY
HAVE
TO
BID
MORE
AGGRESSIVELY
SHADING
YOUR
BID
DOWN
LESS
IN
ORDER
TO
WIN
FOR
THE
SIMPLE
CASE
OF
VALUES
DRAWN
INDEPENDENTLY
FROM
THE
UNIFORM
DISTRIBUTION
OUR
ANALYSIS
HERE
QUANTIFIES
EXACTLY
HOW
THIS
INCREASED
AGGRESSIVENESS
SHOULD
DEPEND
ON
THE
NUMBER
OF
BIDDERS
N
GENERAL
DISTRIBUTIONS
IN
ADDITION
TO
CONSIDERING
LARGER
NUMBERS
OF
BIDDERS
WE
CAN
ALSO
RELAX
THE
ASSUMPTION
THAT
BIDDERS
VALUES
ARE
DRAWN
FROM
THE
UNIFORM
DISTRIBUTION
ON
AN
INTERVAL
SUPPOSE
THAT
EACH
BIDDER
HAS
HER
VALUE
DRAWN
FROM
A
PROBABILITY
DISTRIBUTION
OVER
THE
NON
NEGATIVE
REAL
NUMBERS
WE
CAN
REPRESENT
THE
PROBABILITY
DISTRIBUTION
BY
ITS
CUMULATIVE
DISTRIBUTION
FUNCTION
F
FOR
ANY
X
THE
VALUE
F
X
IS
THE
PROBABILITY
THAT
A
NUMBER
DRAWN
FROM
THE
DISTRIBUTION
IS
AT
MOST
X
WE
WILL
ASSUME
THAT
F
IS
A
DIFFERENTIABLE
FUNCTION
MOST
OF
THE
EARLIER
ANALYSIS
CONTINUES
TO
HOLD
AT
A
GENERAL
LEVEL
THE
PROBABILITY
THAT
A
BIDDER
I
WITH
TRUE
VALUE
VI
WINS
THE
AUCTION
IS
THE
PROBABILITY
THAT
NO
OTHER
BIDDER
HAS
A
LARGER
VALUE
SO
IT
IS
EQUAL
TO
F
VI
N
THEREFORE
THE
EXPECTED
PAYOFF
TO
VI
IS
CATALOGUE
DESCRIPTION
INTRODUCES
MORE
OF
THE
BASIC
CONCEPTS
OF
COMPUTER
SCIENCE
AND
OBJECT
ORIENTED
SOFTWARE
DEVELOPMENT
WITH
AN
EMPHASIS
ON
FUNDAMENTAL
DATA
STRUCTURES
LISTS
STACKS
QUEUES
TREES
AND
ASSOCIATED
ALGORITHMS
THIS
COURSE
INCLUDES
RECURSION
ABSTRACT
DATA
TYPES
AND
SELECTED
TOPICS
EXPLORING
SOME
OF
THE
BREADTH
OF
COMPUTER
SCIENCE
PREREQUISITE
CMPT
OR
CMPT
OR
CMPT
OR
CMPT
WITH
GRADE
AT
LEAST
COURSE
WEBSITE
ALL
COURSE
RELEVANT
INFORMATION
ANNOUNCEMENTS
COURSE
MATERIALS
ASSIGNMENTS
EXAM
SCHEDULES
ETC
WILL
BE
ON
THE
MOODLE
WEBSITE
HTTP
MOODLE
CS
USASK
CA
EACH
STUDENT
IS
RESPONSIBLE
FOR
CHECKING
THIS
WEBSITE
REGULARLY
IT
IS
ALSO
YOUR
RESPONSIBILITY
TO
CHECK
YOUR
PAWS
EMAIL
ACCOUNT
REGULARLY
COURSE
OVERVIEW
THIS
COURSE
INTRODUCES
THE
BASIC
CONCEPTS
OF
COMPUTER
SCIENCE
AND
OBJECT
ORIENTED
SOFTWARE
DEVELOPMENT
YOU
WILL
LEARN
ABOUT
FUNDAMENTAL
DATA
STRUCTURES
FOR
ORGANIZING
DATA
INCLUDING
LISTS
STACKS
QUEUES
TREES
AND
HASH
TABLES
AND
ASSOCIATED
ALGORITHMS
AS
WELL
AS
THEIR
TIME
AND
SPACE
EFFICIENCY
THE
COURSE
WILL
EMPHASIZE
ABSTRACT
DATA
TYPES
FOR
THE
DESIGN
OF
DATA
STORAGE
MECHANISMS
THAT
CAN
BE
REUSED
AND
REVISED
YOU
WILL
LEARN
THE
BASICS
OF
OBJECT
ORIENTED
PROGRAMMING
AS
A
NATURAL
TECHNOLOGICAL
EXTENSION
OF
ABSTRACT
DATA
TYPES
AS
THE
PRACTICAL
PART
OF
THE
COURSE
YOU
WILL
DEVELOP
A
FAMILIARITY
WITH
MEMORY
MANAGEMENT
INCLUDING
STATIC
AND
DYNAMIC
MEMORY
ALLOCATION
AND
POINTERS
THROUGH
HANDS
ON
IMPLEMENTATIONS
AN
UNDERLYING
THEME
OF
THE
COURSE
IS
FOR
STUDENTS
TO
GAIN
PROGRAMMING
AND
DEBUGGING
SKILLS
THE
CON
CEPTUAL
MATERIAL
COVERED
IN
THE
COURSE
IS
ACTUALLY
FAIRLY
STRAIGHTFORWARD
AND
CAN
BE
MASTERED
WITH
A
MODERATE
AMOUNT
OF
STUDY
THE
REAL
CHALLENGE
IN
THIS
COURSE
IS
TO
DEVELOP
THE
PROGRAMMING
SKILLS
NEEDED
TO
COMPLETE
THE
HOMEWORK
STUDENTS
SHOULD
PRACTICE
TIME
MANAGEMENT
PROBLEM
SOLVING
STRATEGIES
AND
CRITICAL
ANALYTICAL
AND
SCIENTIFIC
THINKING
LEARNING
OUTCOMES
BY
THE
END
OF
THIS
COURSE
YOUR
ARE
EXPECTED
TO
BE
ABLE
TO
BE
PROFICIENT
IN
FUNDAMENTALS
OF
PROCEDURAL
PROGRAMMING
SPECIFICALLY
PROGRAMMING
IN
THE
PROCEDURAL
SUBSET
OF
C
DESIGN
ALGORITHMS
USING
PSEUDOCODE
AND
ANALYZE
ALGORITHMS
WRITTEN
IN
PSEUDOCODE
ANALYZE
TIME
AND
SPACE
COMPLEXITY
OF
ALGORITHMS
AND
TO
COMPARE
AND
EVALUATE
ALGORITHMS
AND
DATA
STRUCTURES
UNDERSTAND
AND
USE
DYNAMIC
MEMORY
AND
STATIC
MEMORY
IN
PROCEDURAL
PROGRAMMING
DESCRIBE
AND
APPLY
THE
TECHNIQUES
ASSOCIATED
WITH
REFERENCES
POINTERS
AND
ADDRESSES
EXPLAIN
THE
CONCEPTS
BEHIND
THE
USE
OF
DATA
STRUCTURES
AND
DETERMINE
THE
APPROPRIATENESS
OF
DIFFERENT
DATA
STRUCTURES
FOR
VARIOUS
PURPOSES
DESIGN
IMPLEMENT
AND
APPLY
SPECIFIC
DATA
TYPES
LINKED
LISTS
ARRAYS
TREES
BINARY
SEARCH
TREES
AND
HASH
TABLE
DATA
STRUCTURES
EXPLAIN
THE
CONCEPT
OF
ABSTRACT
DATA
TYPES
IN
TERMS
OF
INTERFACE
AND
ENCAPSULATION
DESIGN
IMPLEMENT
AND
APPLY
ABSTRACT
DATA
TYPES
FOR
LINKED
LISTS
ARRAYS
TREES
BINARY
SEARCH
TREES
AND
HASH
TABLE
DATA
STRUCTURES
APPLY
RECURSION
TO
COMPUTATIONAL
TASKS
INVOLVING
DATA
STRUCTURES
DESCRIBE
AND
APPLY
THE
FUNDAMENTALS
OF
OBJECT
ORIENTED
PROGRAMMING
IN
C
SPECIFICALLY
AS
AN
EXTENSION
OF
THE
ADT
CONCEPT
RESOURCES
TEXTBOOK
INFORMATION
THERE
ARE
NO
REQUIRED
TEXTBOOKS
HOWEVER
WE
PROVIDE
THE
FOLLOWING
RECOMMENDED
REFERENCES
RICHARD
F
GILBERG
AND
BEHROUZ
A
FOROUZAN
DATA
STRUCTURES
A
PSEUDOCODE
APPROACH
IN
C
COURSE
TECH
NOLOGY
THOMPSON
K
N
KING
C
PROGRAMMING
A
MODERN
APPROACH
W
W
NORTON
COMPANY
SUBSTANTIAL
LECTURE
NOTES
WILL
BE
PROVIDED
ON
THE
COURSE
WEBPAGE
HOWEVER
STUDENTS
SHOULD
NOT
RELY
SOLELY
ON
THE
LECTURE
NOTES
FOR
THE
COURSE
GRADING
SCHEME
THE
GRADING
SCHEME
FOR
THIS
COURSE
APPEARS
IN
THE
FOLLOWING
TABLE
ASSIGNMENTS
EIGHT
ONE
TUTORIAL
EXERCISES
TEN
MIDTERM
EXAM
FEBRUARY
FINAL
EXAM
APRIL
TOTAL
ASSIGNMENTS
SEE
THE
SCHEDULE
ON
PAGE
FOR
THE
DUE
DATE
OF
EACH
ASSIGNMENT
THERE
WILL
BE
NINE
ASSIGNMENTS
IN
THIS
COURSE
ONE
APPROXIMATELY
EVERY
WEEK
EVEN
NUMBERED
ASSIGNMENTS
WILL
INVOLVE
NO
PROGRAMMING
BUT
WILL
HAVE
WRITTEN
ANALYTICAL
OR
DESIGN
PROBLEMS
ODD
NUMBERED
ASSIGNMENTS
WILL
BE
EXCLUSIVELY
PROGRAMMING
PROGRAMMING
WILL
OFTEN
BE
BASED
ON
A
DESIGN
OR
ANALYSIS
QUESTION
FROM
A
PREVIOUS
ASSIGNMENT
SUBMISSION
INSTRUCTIONS
WILL
BE
INCLUDED
WITH
EACH
ASSIGNMENT
DESCRIPTION
GENERALLY
YOU
WILL
UPLOAD
YOUR
SOLUTIONS
AS
FILES
TO
MOODLE
UNLESS
YOU
ARE
INSTRUCTED
OTHERWISE
GENERALLY
TEXT
FILES
ARE
PREFERRED
TO
DOCUMENTS
THAT
INCLUDE
FORMATTING
E
G
MSWORD
DOCUMENTS
A
DOCUMENT
THAT
CANNOT
BE
OPENED
WILL
RECEIVE
A
GRADE
OF
ZERO
DO
NOT
ASSUME
THE
MARKERS
WILL
TAKE
THE
TIME
TO
OPEN
YOUR
FILE
IF
IT
IS
IN
A
FILE
FORMAT
THAT
IS
NOT
STANDARD
NOTE
ALL
COMPUTER
PROGRAMS
MUST
BE
WRITTEN
IN
C
AND
MUST
COMPILE
USING
THE
GNU
C
COMPILER
G
UNDER
LINUX
THE
STANDARD
WILL
BE
THE
TUXWORLD
USASK
CA
CLUSTER
OF
MACHINES
WHICH
IS
THE
SAME
VERSION
OF
GNU
C
AS
FOUND
ON
THE
LINUX
DESKTOPS
IN
THE
LAB
INTRODUCTION
THERE
ARE
SEVERAL
CONCEPTS
THAT
ARE
ESSENTIAL
TO
AN
UNDERSTANDING
OF
THIS
TEXT
WE
DISCUSS
THESE
CONCEPTS
IN
THE
FIRST
TWO
CHAPTERS
CHAPTER
BASIC
CONCEPTS
COVERS
GENERAL
MATERIALS
THAT
WE
USE
THROUGHOUT
THE
BOOK
CHAPTER
RECURSION
DISCUSSES
THE
CONCEPT
OF
RECURSION
FIGURE
I
SHOWS
THE
ORGANIZATION
OF
PART
I
PART
I
INTRODUCTION
PSEUDOCODE
ABSTRACT
DATA
TYPE
IMPLEMENTATIONS
GENERIC
CODE
ALGORITHM
EFFICIENCY
FIGURE
I
PART
I
CONTENTS
RECURSION
VERSUS
REPETITION
RECURSIVE
ALGORITHMS
CHAPTERS
COVERED
THIS
PART
INCLUDES
TWO
CHAPTERS
CHAPTER
BASIC
CONCEPTS
THE
FIRST
CHAPTER
COVERS
CONCEPTS
THAT
WE
USE
THROUGHOUT
THE
TEXT
YOU
MAY
FIND
THAT
SOME
OF
THEM
ARE
A
REVIEW
OF
MATERIAL
FROM
YOUR
PROGRAMMING
COURSE
THE
MAJOR
CONCEPTS
ARE
OUTLINED
BELOW
PSEUDOCODE
IN
ALL
OF
OUR
TEXTS
WE
USE
THE
BASIC
TENET
DESIGN
COMES
BEFORE
CODE
THROUGHOUT
THE
TEXT
THEREFORE
WE
SEPARATE
ALGORITHM
DESIGN
FROM
THE
CODE
THAT
IMPLEMENTS
IT
IN
A
SPECIFIC
LANGUAGE
ALTHOUGH
THE
UNDERLYING
LANGUAGE
IN
THIS
BOOK
IS
C
PSEUDOCODE
ALLOWS
US
TO
SEPARATE
THE
ALGORITHM
FROM
THE
IMPLEMENTATION
ABSTRACT
DATA
TYPE
AN
ABSTRACT
DATA
TYPE
ADT
IMPLEMENTS
A
SET
OF
ALGORITHMS
GENERICALLY
SO
THAT
THEY
CAN
BE
APPLIED
TO
ANY
DATA
TYPE
OR
CONSTRUCT
THE
BEAUTY
OF
AN
ADT
IMPLEMENTATION
IS
THAT
THE
ALGORITHMS
CAN
HANDLE
ANY
DATA
TYPE
WHETHER
IT
IS
A
SIMPLE
INTEGER
OR
A
COMPLEX
RECORD
ADT
IMPLEMENTATIONS
IN
GENERAL
THERE
ARE
TWO
BASIC
DATA
STRUCTURES
THAT
CAN
BE
USED
TO
IMPLEMENT
AN
ABSTRACT
DATA
TYPE
ARRAYS
AND
LINKED
LISTS
WE
DISCUSS
BASIC
LINKED
LIST
CON
CEPTS
IN
CHAPTER
AND
EXPAND
ON
THEM
AS
NECESSARY
IN
SUBSEQUENT
CHAPTERS
PART
I
INTRODUCTION
GENERIC
CODE
FOR
ADTS
TO
IMPLEMENT
THE
ADT
CONCEPT
WE
NEED
TO
USE
GENERIC
CODE
EACH
LANGUAGE
PROVIDES
A
DIFFERENT
SET
OF
TOOLS
TO
IMPLEMENT
GENERIC
CODE
THE
C
LANGUAGE
USES
TWO
TOOLS
POINTER
TO
VOID
AND
POINTER
TO
FUNCTION
ALGORITHM
EFFICIENCY
WHILE
MANY
AUTHORS
ARGUE
THAT
TODAY
COMPUTERS
AND
COMPILERS
MAKE
ALGO
RITHM
EFFICIENCY
AN
ACADEMIC
DISCUSSION
WE
BELIEVE
THAT
AN
UNDERSTANDING
OF
ALGORITHM
EFFICIENCY
PROVIDES
THE
FRAMEWORK
FOR
WRITING
BETTER
ALGORITHMS
ALTHOUGH
WE
DISCUSS
THE
EFFICIENCY
OF
SPECIFIC
ALGORITHMS
WHEN
WE
DEVELOP
THEM
IN
THIS
CHAPTER
WE
DISCUSS
THE
BASIC
CONCEPTS
AND
TOOLS
FOR
DISCUSSING
ALGORITHM
EFFICIENCY
CHAPTER
RECURSION
IN
CHAPTER
WE
DISCUSS
RECURSION
A
CONCEPT
THAT
IS
OFTEN
SKIPPED
IN
AN
INTRODUCTORY
PROGRAMMING
COURSE
WE
NEED
TO
UNDERSTAND
RECURSION
TO
DIS
CUSS
DATA
STRUCTURES
BECAUSE
MANY
OF
THE
ABSTRACT
DATA
TYPES
ARE
RECURSIVE
BY
NATURE
AND
ALGORITHMS
THAT
HANDLE
THEM
CAN
BE
BETTER
UNDERSTOOD
USING
RECURSION
WE
USE
RECURSIVE
ALGORITHMS
EXTENSIVELY
ESPECIALLY
IN
PART
III
NON
LINEAR
LISTS
RECURSION
VERSUS
REPETITION
THE
FIRST
PART
OF
THE
CHAPTER
COMPARES
AND
CONTRASTS
RECURSION
AND
REPETITION
AND
WHEN
EACH
SHOULD
BE
USED
RECURSIVE
ALGORITHMS
ALTHOUGH
RECURSIVE
ALGORITHMS
ARE
GENERALLY
ELEGANT
THEY
CAN
BE
DIFFICULT
TO
UNDERSTAND
IN
THE
SECOND
PART
OF
THE
CHAPTER
WE
INTRODUCE
SEVERAL
ALGO
RITHMS
TO
MAKE
THE
RECURSIVE
CONCEPT
CLEAR
AND
TO
PROVIDE
A
SENSE
OF
DESIGN
FOR
CREATING
RECURSIVE
ALGORITHMS
CHAPTER
BASIC
CONCEPTS
THIS
TEXT
ASSUMES
THAT
THE
STUDENT
HAS
A
SOLID
FOUNDATION
IN
STRUCTURED
PRO
GRAMMING
PRINCIPLES
AND
HAS
WRITTEN
PROGRAMS
OF
MODERATE
COMPLEXITY
ALTHOUGH
THE
TEXT
USES
C
FOR
ALL
OF
ITS
IMPLEMENTATION
EXAMPLES
THE
DESIGN
AND
LOGIC
OF
THE
DATA
STRUCTURE
ALGORITHMS
ARE
BASED
ON
PSEUDOCODE
THIS
APPROACH
CREATES
A
LANGUAGE
INDEPENDENT
ENVIRONMENT
FOR
THE
ALGORITHMS
IN
THIS
CHAPTER
WE
ESTABLISH
A
BACKGROUND
FOR
THE
TOOLS
USED
IN
THE
REST
OF
THE
TEXT
MOST
SPECIFICALLY
PSEUDOCODE
THE
ABSTRACT
DATA
TYPE
ALGORITHM
EFFI
CIENCY
ANALYSIS
AND
THE
CONCEPTS
NECESSARY
TO
CREATE
GENERIC
CODE
PSEUDOCODE
ALTHOUGH
SEVERAL
TOOLS
ARE
USED
TO
DEFINE
ALGORITHMS
ONE
OF
THE
MOST
COMMON
IS
PSEUDOCODE
PSEUDOCODE
IS
AN
ENGLISH
LIKE
REPRESENTATION
OF
THE
ALGORITHM
LOGIC
IT
IS
PART
ENGLISH
PART
STRUCTURED
CODE
THE
ENGLISH
PART
PROVIDES
A
RELAXED
SYNTAX
THAT
DESCRIBES
WHAT
MUST
BE
DONE
WITHOUT
SHOWING
UNNECESSARY
DETAILS
SUCH
AS
ERROR
MESSAGES
THE
CODE
PART
CONSISTS
OF
AN
EXTENDED
VERSION
OF
THE
BASIC
ALGORITHMIC
CONSTRUCTS
SEQUENCE
SELECTION
AND
ITERATION
IN
THIS
TEXT
WE
USE
PSEUDOCODE
TO
REPRESENT
BOTH
DATA
STRUCTURES
AND
CODE
DATA
ITEMS
DO
NOT
NEED
TO
BE
DECLARED
THE
FIRST
TIME
WE
USE
A
DATA
NAME
IN
AN
ALGORITHM
IT
IS
AUTOMATICALLY
DECLARED
ITS
TYPE
IS
DETERMINED
BY
CONTEXT
THE
FOLLOWING
STATEMENT
DECLARES
A
NUMERIC
DATA
ITEM
NAMED
COUNT
AND
SETS
ITS
VALUE
TO
ZERO
SET
COUNT
TO
SECTION
PSEUDOCODE
THE
STRUCTURE
OF
THE
DATA
ON
THE
OTHER
HAND
MUST
BE
DECLARED
WE
USE
A
SIMPLE
SYNTACTICAL
STATEMENT
THAT
BEGINS
WITH
A
STRUCTURE
NAME
AND
CONCLUDES
WITH
THE
KEYWORD
END
AND
THE
NAME
OF
THE
STRUCTURE
WITHIN
THE
STRUCTURE
WE
LIST
THE
STRUCTURAL
ELEMENTS
BY
INDENTING
THE
DATA
ITEMS
AS
SHOWN
BELOW
THIS
DATA
DEFINITION
DESCRIBES
A
NODE
IN
A
SELF
REFERENTIAL
LIST
THAT
CONSISTS
OF
A
NESTED
STRUCTURE
DATA
AND
A
POINTER
TO
THE
NEXT
NODE
LINK
AN
ELE
MENT
TYPE
IS
IMPLIED
BY
ITS
NAME
AND
USAGE
IN
THE
ALGORITHM
AS
MENTIONED
PSEUDOCODE
IS
USED
TO
DESCRIBE
AN
ALGORITHM
TO
FACILITATE
A
DISCUSSION
OF
THE
ALGORITHM
STATEMENTS
WE
NUMBER
THEM
USING
THE
HIERAR
CHICAL
SYSTEM
SHOWN
IN
ALGORITHM
THE
FOLLOWING
SECTIONS
DESCRIBE
THE
COMPONENTS
OF
AN
ALGORITHM
COLORED
COMMENTS
PROVIDE
DOCUMENTATION
OR
CLARIFICATION
WHEN
REQUIRED
ALGORITHM
EXAMPLE
OF
PSEUDOCODE
ALGORITHM
HEADER
EACH
ALGORITHM
BEGINS
WITH
A
HEADER
THAT
NAMES
IT
LISTS
ITS
PARAMETERS
AND
DESCRIBES
ANY
PRECONDITIONS
AND
POSTCONDITIONS
THIS
INFORMATION
IS
IMPOR
TANT
BECAUSE
IT
SERVES
TO
DOCUMENT
THE
ALGORITHM
THEREFORE
THE
HEADER
INFORMATION
MUST
BE
COMPLETE
ENOUGH
TO
COMMUNICATE
TO
THE
PROGRAMMER
EVERYTHING
HE
OR
SHE
MUST
KNOW
TO
WRITE
THE
ALGORITHM
IN
ALGORITHM
THERE
IS
ONLY
ONE
PARAMETER
THE
PAGE
NUMBER
CHAPTER
BASIC
CONCEPTS
PURPOSE
CONDITIONS
AND
RETURN
THE
PURPOSE
IS
A
SHORT
STATEMENT
ABOUT
WHAT
THE
ALGORITHM
DOES
IT
NEEDS
TO
DESCRIBE
ONLY
THE
GENERAL
ALGORITHM
PROCESSING
IT
SHOULD
NOT
ATTEMPT
TO
DESCRIBE
ALL
OF
THE
PROCESSING
FOR
EXAMPLE
IN
ALGORITHM
THE
PURPOSE
DOES
NOT
NEED
TO
STATE
THAT
THE
FILE
WILL
BE
OPENED
OR
HOW
THE
REPORT
WILL
BE
PRINTED
SIMILARLY
IN
THE
SEARCH
EXAMPLE
THE
PURPOSE
DOES
NOT
NEED
TO
STATE
WHICH
OF
THE
POSSIBLE
ARRAY
SEARCHES
WILL
BE
USED
THE
PRECONDITION
LISTS
ANY
PRECURSOR
REQUIREMENTS
FOR
THE
PARAMETERS
FOR
EXAMPLE
IN
ALGORITHM
THE
ALGORITHM
THAT
CALLS
SAMPLE
MUST
PASS
THE
PAGE
NUMBER
BY
REFERENCE
SOMETIMES
THERE
ARE
NO
PRECONDITIONS
IN
WHICH
CASE
WE
STILL
LIST
THE
PRECONDITION
WITH
A
STATEMENT
THAT
NOTHING
IS
REQUIRED
AS
SHOWN
BELOW
IF
THERE
ARE
SEVERAL
INPUT
PARAMETERS
THE
PRECONDITION
SHOULD
BE
SHOWN
FOR
EACH
FOR
EXAMPLE
A
SIMPLE
ARRAY
SEARCH
ALGORITHM
HAS
THE
FOLLOWING
HEADER
IN
SEARCH
THE
PRECONDITION
SPECIFIES
THAT
THE
TWO
INPUT
PARAMETERS
LIST
AND
ARGUMENT
MUST
BE
INITIALIZED
IF
A
BINARY
SEARCH
WERE
BEING
USED
THE
PRECONDITION
WOULD
ALSO
STATE
THAT
THE
ARRAY
DATA
MUST
BE
SORTED
THE
POSTCONDITION
IDENTIFIES
ANY
ACTION
TAKEN
AND
THE
STATUS
OF
ANY
OUT
PUT
PARAMETERS
IN
ALGORITHM
THE
POSTCONDITION
CONTAINS
TWO
PARTS
FIRST
IT
STATES
THAT
THE
REPORT
HAS
BEEN
PRINTED
SECOND
THE
REFERENCE
PARAMETER
PAGENUMBER
CONTAINS
THE
UPDATED
NUMBER
OF
PAGES
IN
THE
REPORT
IN
THE
SEARCH
ALGORITHM
SHOWN
ABOVE
THERE
IS
ONLY
ONE
POSTCONDITION
WHICH
MAY
BE
ONE
OF
TWO
DIFFERENT
VALUES
IF
A
VALUE
IS
RETURNED
IT
IS
IDENTIFIED
BY
A
RETURN
CONDITION
OFTEN
THERE
IS
NONE
AND
NO
RETURN
CONDITION
IS
NEEDED
IN
ALGORITHM
WE
RETURN
THE
NUMBER
OF
LINES
PRINTED
THE
SEARCH
ALGORITHM
RETURNS
TRUE
IF
THE
ARGUMENT
WAS
FOUND
FALSE
IF
IT
WAS
NOT
FOUND
STATEMENT
NUMBERS
STATEMENTS
ARE
NUMBERED
USING
AN
ABBREVIATED
DECIMAL
NOTATION
IN
WHICH
ONLY
THE
LAST
OF
THE
NUMBER
SEQUENCE
IS
SHOWN
ON
EACH
STATEMENT
THE
EXPANDED
NUMBER
OF
THE
STATEMENT
IN
ALGORITHM
THAT
READS
THE
FILE
IS
SECTION
PSEUDOCODE
THE
STATEMENT
THAT
WRITES
THE
PAGE
HEADING
IS
THIS
TECHNIQUE
ALLOWS
US
TO
IDENTIFY
AN
INDIVIDUAL
STATEMENT
WHILE
PROVIDING
STATEMENTS
THAT
ARE
EASILY
READ
VARIABLES
TO
ENSURE
THAT
THE
MEANING
IS
UNDERSTOOD
WE
USE
INTELLIGENT
DATA
NAMES
THAT
IS
NAMES
THAT
DESCRIBE
THE
MEANING
OF
THE
DATA
HOWEVER
IT
IS
NOT
NECESSARY
TO
DEFINE
THE
VARIABLES
USED
IN
AN
ALGORITHM
ESPECIALLY
WHEN
THE
NAME
INDICATES
THE
CONTEXT
OF
THE
DATA
THE
SELECTION
OF
THE
NAME
FOR
AN
ALGORITHM
OR
VARIABLE
GOES
A
LONG
WAY
TOWARD
MAKING
THE
ALGORITHM
AND
ITS
CODED
IMPLEMENTATION
MORE
READABLE
IN
GENERAL
YOU
SHOULD
FOLLOW
THESE
RULES
DO
NOT
USE
SINGLE
CHARACTER
NAMES
DO
NOT
USE
GENERIC
NAMES
IN
APPLICATION
PROGRAMS
EXAMPLES
OF
GENERIC
NAMES
ARE
COUNT
SUM
TOTAL
ROW
COLUMN
AND
FILE
IN
A
PROGRAM
OF
ANY
SIZE
THERE
ARE
SEVERAL
COUNTS
SUMS
AND
TOTALS
RATHER
ADD
AN
INTELLIGENT
QUALIFIER
TO
THE
GENERIC
NAME
SO
THAT
THE
READER
KNOWS
EXACTLY
TO
WHICH
PIECE
OF
DATA
THE
NAME
REFERS
FOR
EXAMPLE
STUDENTCOUNT
AND
NUMBEROFSTUDENTS
ARE
BOTH
BETTER
THAN
COUNT
ABBREVIATIONS
ARE
NOT
EXCLUDED
AS
INTELLIGENT
DATA
NAMES
FOR
EXAMPLE
STUCNT
IS
A
GOOD
ABBREVIATION
FOR
STUDENT
COUNT
AND
NUMOFSTU
IS
A
GOOD
ABBREVIATION
FOR
NUMBER
OF
STUDENTS
NOTE
HOWEVER
THAT
NOSTU
WOULD
NOT
BE
A
GOOD
ABBREVIATION
FOR
NUMBER
OF
STUDENTS
BECAUSE
IT
IS
TOO
EASILY
READ
AS
NO
STUDENTS
STATEMENT
CONSTRUCTS
WHEN
HE
FIRST
PROPOSED
THE
STRUCTURED
PROGRAMMING
MODEL
EDSGER
DIJKSTRA
STATED
THAT
ANY
ALGORITHM
COULD
BE
WRITTEN
USING
ONLY
THREE
PROGRAMMING
CONSTRUCTS
SEQUENCE
SELECTION
AND
LOOP
OUR
PSEUDOCODE
CONTAINS
ONLY
THESE
THREE
BASIC
CONSTRUCTS
THE
IMPLEMENTATION
OF
THESE
CONSTRUCTS
RELIES
ON
THE
RICHNESS
OF
THE
IMPLEMENTATION
LANGUAGE
FOR
EXAMPLE
THE
LOOP
CAN
BE
IMPLEMENTED
AS
A
WHILE
DO
WHILE
OR
FOR
STATEMENT
IN
THE
C
LANGUAGE
SEQUENCE
A
SEQUENCE
IS
ONE
OR
MORE
STATEMENTS
THAT
DO
NOT
ALTER
THE
EXECUTION
PATH
WITHIN
AN
ALGORITHM
ALTHOUGH
IT
IS
OBVIOUS
THAT
STATEMENTS
SUCH
AS
ASSIGN
AND
ADD
ARE
SEQUENCE
STATEMENTS
IT
IS
NOT
SO
OBVIOUS
THAT
A
CALL
TO
OTHER
ALGORITHMS
IS
ALSO
CONSIDERED
A
SEQUENCE
STATEMENT
THE
REASON
CALLS
ARE
CONSIDERED
SEQUENTIAL
STATEMENTS
LIES
IN
THE
STRUCTURED
PROGRAMMING
CONCEPT
THAT
EACH
ALGORITHM
HAS
ONLY
ONE
ENTRY
AND
ONE
EXIT
FURTHERMORE
WHEN
AN
ALGORITHM
COMPLETES
IT
RETURNS
TO
THE
STATEMENT
IMMEDIATELY
AFTER
THE
CALL
THAT
INVOKED
IT
THEREFORE
WE
CAN
CONSIDER
AN
ALGORITHM
CALL
A
SEQUENCE
STATEMENT
IN
ALGORITHM
STATEMENTS
AND
ARE
SEQUENCE
STATEMENTS
CHAPTER
BASIC
CONCEPTS
SELECTION
A
SELECTION
STATEMENT
EVALUATES
A
CONDITION
AND
EXECUTES
ZERO
OR
MORE
ALTERNATIVES
THE
RESULTS
OF
THE
EVALUATION
DETERMINE
WHICH
ALTERNATES
ARE
TAKEN
THE
TYPICAL
SELECTION
STATEMENT
IS
THE
TWO
WAY
SELECTION
AS
IMPLEMENTED
IN
AN
IF
STATEMENT
WHEREAS
MOST
LANGUAGES
PROVIDE
FOR
MULTIWAY
SELECTIONS
SUCH
AS
THE
SWITCH
IN
C
WE
PROVIDE
NONE
IN
THE
PSEUDOCODE
THE
PARTS
OF
THE
SELECTION
ARE
IDENTIFIED
BY
INDENTATION
AS
SHOWN
IN
THE
SHORT
PSEUDOCODE
STATEMENT
BELOW
STATEMENT
IN
ALGORITHM
IS
AN
EXAMPLE
OF
A
SELECTION
STATEMENT
THE
END
OF
THE
SELECTION
IS
INDICATED
BY
THE
END
IF
IN
STATEMENT
LOOP
A
LOOP
STATEMENT
ITERATES
A
BLOCK
OF
CODE
THE
LOOP
THAT
WE
USE
IN
OUR
PSEUDOCODE
CLOSELY
RESEMBLES
THE
WHILE
LOOP
IT
IS
A
PRETEST
LOOP
THAT
IS
THE
CONDITION
IS
EVALUATED
BEFORE
THE
BODY
OF
THE
LOOP
IS
EXECUTED
IF
THE
CONDITION
IS
TRUE
THE
BODY
IS
EXECUTED
IF
THE
CONDITION
IS
FALSE
THE
LOOP
TERMINATES
IN
ALGORITHM
STATEMENT
IS
AN
EXAMPLE
OF
A
LOOP
THE
END
OF
THE
LOOP
IS
INDICATED
BY
END
LOOP
IN
STATEMENT
ALGORITHM
ANALYSIS
FOR
SELECTED
ALGORITHMS
WE
FOLLOW
THE
ALGORITHM
WITH
AN
ANALYSIS
SECTION
THAT
EXPLAINS
SOME
OF
ITS
SALIENT
POINTS
NOT
EVERY
LINE
OF
CODE
IS
EXPLAINED
RATHER
THE
ANALYSIS
EXAMINES
ONLY
THOSE
POINTS
THAT
EITHER
NEED
TO
BE
EMPHASIZED
OR
THAT
MAY
REQUIRE
SOME
CLARIFICATION
THE
ALGORITHM
ANALYSIS
ALSO
OFTEN
INTRO
DUCES
STYLE
OR
EFFICIENCY
CONSIDERATIONS
PSEUDOCODE
EXAMPLE
AS
ANOTHER
EXAMPLE
OF
PSEUDOCODE
CONSIDER
THE
LOGIC
REQUIRED
TO
CALCULATE
THE
DEVIATION
FROM
A
MEAN
IN
THIS
PROBLEM
WE
MUST
FIRST
READ
A
SERIES
OF
NUMBERS
AND
CALCULATE
THEIR
AVERAGE
THEN
WE
SUBTRACT
THE
MEAN
FROM
EACH
NUMBER
AND
PRINT
THE
NUMBER
AND
ITS
DEVIATION
AT
THE
END
OF
THE
CALCULATION
WE
ALSO
PRINT
THE
TOTALS
AND
THE
AVERAGE
THE
OBVIOUS
SOLUTION
IS
TO
PLACE
THE
DATA
IN
AN
ARRAY
AS
THEY
ARE
READ
ALGORITHM
CONTAINS
THE
CODE
FOR
THIS
SIMPLE
PROBLEM
AS
IT
WOULD
BE
IMPLE
MENTED
IN
A
CALLABLE
ALGORITHM
SECTION
THE
ABSTRACT
DATA
TYPE
ALGORITHM
PRINT
DEVIATION
FROM
MEAN
FOR
SERIES
ALGORITHM
ANALYSIS
THERE
ARE
TWO
POINTS
WORTH
MENTIONING
IN
ALGORITHM
FIRST
THERE
ARE
NO
PARAMETERS
SECOND
AS
PREVIOUSLY
EXPLAINED
WE
DO
NOT
DECLARE
VARIABLES
A
VARIABLE
TYPE
AND
PURPOSE
SHOULD
BE
EASILY
DETERMINED
BY
ITS
NAME
AND
USAGE
THE
ABSTRACT
DATA
TYPE
IN
THE
HISTORY
OF
PROGRAMMING
CONCEPTS
WE
STARTED
WITH
NONSTRUCTURED
LINEAR
PROGRAMS
KNOWN
AS
SPAGHETTI
CODE
IN
WHICH
THE
LOGIC
FLOW
WOUND
THROUGH
THE
PROGRAM
LIKE
SPAGHETTI
ON
A
PLATE
NEXT
CAME
THE
CONCEPT
OF
MODULAR
PROGRAMMING
IN
WHICH
PROGRAMS
WERE
ORGANIZED
IN
FUNCTIONS
EACH
OF
WHICH
STILL
USED
A
LIN
EAR
CODING
TECHNIQUE
IN
THE
THE
BASIC
PRINCIPLES
OF
STRUCTURED
PROGRAMMING
WERE
FORMULATED
BY
COMPUTER
SCIENTISTS
SUCH
AS
EDSGER
DIJKSTRA
AND
NIKLAUS
WIRTH
THEY
ARE
STILL
VALID
TODAY
ATOMIC
AND
COMPOSITE
DATA
ATOMIC
DATA
ARE
DATA
THAT
CONSIST
OF
A
SINGLE
PIECE
OF
INFORMATION
THAT
IS
THEY
CANNOT
BE
DIVIDED
INTO
OTHER
MEANINGFUL
PIECES
OF
DATA
FOR
EXAMPLE
THE
INTE
GER
MAY
BE
CONSIDERED
A
SINGLE
INTEGER
VALUE
OF
COURSE
WE
CAN
DECOM
POSE
IT
INTO
DIGITS
BUT
THE
DECOMPOSED
DIGITS
DO
NOT
HAVE
THE
SAME
CHARACTERISTICS
OF
THE
ORIGINAL
INTEGER
THEY
ARE
FOUR
SINGLE
DIGIT
INTEGERS
RANG
ING
FROM
TO
IN
SOME
LANGUAGES
ATOMIC
DATA
ARE
KNOWN
AS
SCALAR
DATA
BECAUSE
OF
THEIR
NUMERIC
PROPERTIES
THE
OPPOSITE
OF
ATOMIC
DATA
IS
COMPOSITE
DATA
COMPOSITE
DATA
CAN
BE
BRO
KEN
OUT
INTO
SUBFIELDS
THAT
HAVE
MEANING
AS
AN
EXAMPLE
OF
A
COMPOSITE
DATA
ITEM
CONSIDER
YOUR
TELEPHONE
NUMBER
A
TELEPHONE
NUMBER
ACTUALLY
HAS
THREE
DIFFERENT
PARTS
FIRST
THERE
IS
THE
AREA
CODE
THEN
WHAT
YOU
CON
SIDER
TO
BE
YOUR
PHONE
NUMBER
IS
ACTUALLY
TWO
DIFFERENT
DATA
ITEMS
A
PREFIX
CONSISTING
OF
A
THREE
DIGIT
EXCHANGE
AND
THE
NUMBER
WITHIN
THE
EXCHANGE
CHAPTER
BASIC
CONCEPTS
CONSISTING
OF
FOUR
DIGITS
IN
THE
PAST
THESE
PREFIXES
WERE
NAMES
SUCH
AS
DAVENPORT
AND
CYPRESS
DATA
TYPE
A
DATA
TYPE
CONSISTS
OF
TWO
PARTS
A
SET
OF
DATA
AND
THE
OPERATIONS
THAT
CAN
BE
PERFORMED
ON
THE
DATA
THUS
WE
SEE
THAT
THE
INTEGER
TYPE
CONSISTS
OF
VALUES
WHOLE
NUMBERS
IN
SOME
DEFINED
RANGE
AND
OPERATIONS
ADD
SUBTRACT
MULTI
PLY
DIVIDE
AND
ANY
OTHER
OPERATIONS
APPROPRIATE
FOR
THE
DATA
TABLE
SHOWS
THREE
DATA
TYPES
FOUND
IN
ALL
SYSTEMS
TYPE
VALUES
OPERATIONS
INTEGER
FLOATING
POINT
CHARACTER
A
B
A
B
TABLE
THREE
DATA
TYPES
DATA
STRUCTURE
A
DATA
STRUCTURE
IS
AN
AGGREGATION
OF
ATOMIC
AND
COMPOSITE
DATA
INTO
A
SET
WITH
DEFINED
RELATIONSHIPS
IN
THIS
DEFINITION
STRUCTURE
MEANS
A
SET
OF
RULES
THAT
HOLDS
THE
DATA
TOGETHER
IN
OTHER
WORDS
IF
WE
TAKE
A
COMBINATION
OF
DATA
AND
FIT
THEM
INTO
A
STRUCTURE
SUCH
THAT
WE
CAN
DEFINE
ITS
RELATING
RULES
WE
HAVE
MADE
A
DATA
STRUCTURE
DATA
STRUCTURES
CAN
BE
NESTED
WE
CAN
HAVE
A
DATA
STRUCTURE
THAT
CONSISTS
OF
OTHER
DATA
STRUCTURES
FOR
EXAMPLE
WE
CAN
DEFINE
THE
TWO
STRUCTURES
ARRAY
AND
RECORD
AS
SHOWN
IN
TABLE
ARRAY
RECORD
HOMOGENEOUS
SEQUENCE
OF
DATA
OR
DATA
TYPES
KNOWN
AS
ELEMENTS
HETEROGENEOUS
COMBINATION
OF
DATA
INTO
A
SINGLE
STRUCTURE
WITH
AN
IDENTI
FIED
KEY
POSITION
ASSOCIATION
AMONG
THE
ELEMENTS
NO
ASSOCIATION
TABLE
DATA
STRUCTURE
EXAMPLES
SECTION
THE
ABSTRACT
DATA
TYPE
MOST
OF
THE
PROGRAMMING
LANGUAGES
SUPPORT
SEVERAL
DATA
STRUCTURES
IN
ADDI
TION
MODERN
PROGRAMMING
LANGUAGES
ALLOW
PROGRAMMERS
TO
CREATE
NEW
DATA
STRUCTURES
FOR
AN
APPLICATION
ABSTRACT
DATA
TYPE
GENERALLY
SPEAKING
PROGRAMMERS
CAPABILITIES
ARE
DETERMINED
BY
THE
TOOLS
IN
THEIR
TOOL
KITS
THESE
TOOLS
ARE
ACQUIRED
BY
EDUCATION
AND
EXPERIENCE
A
KNOWLEDGE
OF
DATA
STRUCTURES
IS
ONE
OF
THOSE
TOOLS
WHEN
WE
FIRST
STARTED
PROGRAMMING
THERE
WERE
NO
ABSTRACT
DATA
TYPES
IF
WE
WANTED
TO
READ
A
FILE
WE
WROTE
THE
CODE
TO
READ
THE
PHYSICAL
FILE
DEVICE
IT
DID
NOT
TAKE
LONG
TO
REALIZE
THAT
WE
WERE
WRITING
THE
SAME
CODE
OVER
AND
OVER
AGAIN
SO
WE
CREATED
WHAT
IS
KNOWN
TODAY
AS
AN
ABSTRACT
DATA
TYPE
ADT
WE
WROTE
THE
CODE
TO
READ
A
FILE
AND
PLACED
IT
IN
A
LIBRARY
FOR
ALL
PRO
GRAMMERS
TO
USE
THIS
CONCEPT
IS
FOUND
IN
MODERN
LANGUAGES
TODAY
THE
CODE
TO
READ
THE
KEYBOARD
IS
AN
ADT
IT
HAS
A
DATA
STRUCTURE
A
CHARACTER
AND
A
SET
OF
OPERA
TIONS
THAT
CAN
BE
USED
TO
READ
THAT
DATA
STRUCTURE
USING
THE
ADT
WE
CAN
NOT
ONLY
READ
CHARACTERS
BUT
WE
CAN
ALSO
CONVERT
THEM
INTO
DIFFERENT
DATA
STRUC
TURES
SUCH
AS
INTEGERS
AND
STRINGS
WITH
AN
ADT
USERS
ARE
NOT
CONCERNED
WITH
HOW
THE
TASK
IS
DONE
BUT
RATHER
WITH
WHAT
IT
CAN
DO
IN
OTHER
WORDS
THE
ADT
CONSISTS
OF
A
SET
OF
DEFINI
TIONS
THAT
ALLOW
PROGRAMMERS
TO
USE
THE
FUNCTIONS
WHILE
HIDING
THE
IMPLEMEN
TATION
THIS
GENERALIZATION
OF
OPERATIONS
WITH
UNSPECIFIED
IMPLEMENTATIONS
IS
KNOWN
AS
ABSTRACTION
WE
ABSTRACT
THE
ESSENCE
OF
THE
PROCESS
AND
LEAVE
THE
IMPLEMENTATION
DETAILS
HIDDEN
CONSIDER
THE
CONCEPT
OF
A
LIST
AT
LEAST
FOUR
DATA
STRUCTURES
CAN
SUPPORT
A
LIST
WE
CAN
USE
A
MATRIX
A
LINEAR
LIST
A
TREE
OR
A
GRAPH
IF
WE
PLACE
OUR
LIST
IN
AN
ADT
USERS
SHOULD
NOT
BE
AWARE
OF
THE
STRUCTURE
WE
USE
AS
LONG
AS
THEY
CAN
INSERT
AND
RETRIEVE
DATA
IT
SHOULD
MAKE
NO
DIFFERENCE
HOW
WE
STORE
THE
DATA
FIGURE
SHOWS
FOUR
LOGICAL
STRUCTURES
THAT
MIGHT
BE
USED
TO
HOLD
A
LIST
CHAPTER
BASIC
CONCEPTS
B
LINEAR
LIST
A
MATRIX
C
TREE
FIGURE
SOME
DATA
STRUCTURES
D
GRAPH
AS
ANOTHER
EXAMPLE
CONSIDER
THE
SYSTEM
ANALYST
WHO
NEEDS
TO
SIMULATE
THE
WAITING
LINE
OF
A
BANK
TO
DETERMINE
HOW
MANY
TELLERS
ARE
NEEDED
TO
SERVE
CUSTOMERS
EFFICIENTLY
THIS
ANALYSIS
REQUIRES
THE
SIMULATION
OF
A
QUEUE
HOW
EVER
QUEUES
ARE
NOT
GENERALLY
AVAILABLE
IN
PROGRAMMING
LANGUAGES
EVEN
IF
A
QUEUE
TYPE
WERE
AVAILABLE
OUR
ANALYST
WOULD
STILL
NEED
SOME
BASIC
QUEUE
OPERATIONS
SUCH
AS
ENQUEUING
INSERTION
AND
DEQUEUING
DELETING
FOR
THE
SIMULATION
THERE
ARE
TWO
POTENTIAL
SOLUTIONS
TO
THIS
PROBLEM
WE
CAN
WRITE
A
PRO
GRAM
THAT
SIMULATES
THE
QUEUE
OUR
ANALYST
NEEDS
IN
THIS
CASE
OUR
SOLUTION
IS
GOOD
ONLY
FOR
THE
ONE
APPLICATION
AT
HAND
OR
WE
CAN
WRITE
A
QUEUE
ADT
THAT
CAN
BE
USED
TO
SOLVE
ANY
QUEUE
PROBLEM
IF
WE
CHOOSE
THE
LATTER
COURSE
OUR
ANALYST
STILL
NEEDS
TO
WRITE
A
PROGRAM
TO
SIMULATE
THE
BANKING
APPLICATION
BUT
DOING
SO
IS
MUCH
EASIER
AND
FASTER
BECAUSE
HE
OR
SHE
CAN
CONCENTRATE
ON
THE
APPLICATION
RATHER
THAN
THE
QUEUE
WE
ARE
NOW
READY
TO
DEFINE
ADT
AN
ABSTRACT
DATA
TYPE
IS
A
DATA
DECLARA
TION
PACKAGED
TOGETHER
WITH
THE
OPERATIONS
THAT
ARE
MEANINGFUL
FOR
THE
DATA
TYPE
IN
OTHER
WORDS
WE
ENCAPSULATE
THE
DATA
AND
THE
OPERATIONS
ON
THE
DATA
AND
THEN
WE
HIDE
THEM
FROM
THE
USER
WE
CANNOT
OVEREMPHASIZE
THE
IMPORTANCE
OF
HIDING
THE
IMPLEMENTATION
THE
USER
SHOULD
NOT
HAVE
TO
KNOW
THE
DATA
STRUCTURE
TO
USE
THE
ADT
REFERRING
TO
OUR
QUEUE
EXAMPLE
THE
APPLICATION
PROGRAM
SHOULD
HAVE
NO
KNOWLEDGE
OF
THE
DATA
STRUCTURE
ALL
REFERENCES
TO
AND
MANIPULATION
OF
THE
DATA
IN
THE
QUEUE
MUST
BE
HANDLED
THROUGH
DEFINED
INTERFACES
TO
THE
SECTION
MODEL
FOR
AN
ABSTRACT
DATA
TYPE
STRUCTURE
ALLOWING
THE
APPLICATION
PROGRAM
TO
DIRECTLY
REFERENCE
THE
DATA
STRUCTURE
IS
A
COMMON
FAULT
IN
MANY
IMPLEMENTATIONS
THIS
KEEPS
THE
ADT
FROM
BEING
FULLY
PORTABLE
TO
OTHER
APPLICATIONS
MODEL
FOR
AN
ABSTRACT
DATA
TYPE
THE
ADT
MODEL
IS
SHOWN
IN
FIGURE
THE
COLORED
AREA
WITH
AN
IRREGULAR
OUT
LINE
REPRESENTS
THE
ADT
INSIDE
THE
ADT
ARE
TWO
DIFFERENT
ASPECTS
OF
THE
MODEL
DATA
STRUCTURES
AND
FUNCTIONS
PUBLIC
AND
PRIVATE
BOTH
ARE
ENTIRELY
CONTAINED
IN
THE
MODEL
AND
ARE
NOT
WITHIN
THE
APPLICATION
PROGRAM
SCOPE
HOWEVER
THE
DATA
STRUCTURES
ARE
AVAILABLE
TO
ALL
OF
THE
ADT
FUNCTIONS
AS
NEEDED
AND
A
FUNCTION
MAY
CALL
ON
OTHER
FUNCTIONS
TO
ACCOMPLISH
ITS
TASK
IN
OTHER
WORDS
THE
DATA
STRUCTURES
AND
THE
FUNCTIONS
ARE
WITHIN
SCOPE
OF
EACH
OTHER
FIGURE
ABSTRACT
DATA
TYPE
MODEL
ADT
OPERATIONS
DATA
ARE
ENTERED
ACCESSED
MODIFIED
AND
DELETED
THROUGH
THE
EXTERNAL
INTER
FACE
DRAWN
AS
A
PASSAGEWAY
PARTIALLY
IN
AND
PARTIALLY
OUT
OF
THE
ADT
ONLY
THE
PUBLIC
FUNCTIONS
ARE
ACCESSIBLE
THROUGH
THIS
INTERFACE
FOR
EACH
ADT
OPERA
TION
THERE
IS
AN
ALGORITHM
THAT
PERFORMS
ITS
SPECIFIC
TASK
ONLY
THE
OPERATION
NAME
AND
ITS
PARAMETERS
ARE
AVAILABLE
TO
THE
APPLICATION
AND
THEY
PROVIDE
THE
ONLY
INTERFACE
TO
THE
ADT
CHAPTER
BASIC
CONCEPTS
ADT
DATA
STRUCTURE
WHEN
A
LIST
IS
CONTROLLED
ENTIRELY
BY
THE
PROGRAM
IT
IS
OFTEN
IMPLEMENTED
USING
SIMPLE
STRUCTURES
SIMILAR
TO
THOSE
USED
IN
YOUR
PROGRAMMING
CLASS
BECAUSE
THE
ABSTRACT
DATA
TYPE
MUST
HIDE
THE
IMPLEMENTATION
FROM
THE
USER
HOWEVER
ALL
DATA
ABOUT
THE
STRUCTURE
MUST
BE
MAINTAINED
INSIDE
THE
ADT
JUST
ENCAPSULATING
THE
STRUCTURE
IN
AN
ADT
IS
NOT
SUFFICIENT
IT
IS
ALSO
NECES
SARY
FOR
MULTIPLE
VERSIONS
OF
THE
STRUCTURE
TO
BE
ABLE
TO
COEXIST
CONSEQUENTLY
WE
MUST
HIDE
THE
IMPLEMENTATION
FROM
THE
USER
WHILE
BEING
ABLE
TO
STORE
DIF
FERENT
DATA
IN
THIS
TEXT
WE
DEVELOP
ADTS
FOR
STACKS
QUEUES
LISTS
BINARY
SEARCH
TREES
AVL
TREES
B
TREES
HEAPS
AND
GRAPHS
IF
YOU
WOULD
LIKE
A
PREVIEW
LOOK
AT
THE
STACK
ADT
IN
CHAPTER
ADT
IMPLEMENTATIONS
THERE
ARE
TWO
BASIC
STRUCTURES
WE
CAN
USE
TO
IMPLEMENT
AN
ADT
LIST
ARRAYS
AND
LINKED
LISTS
ARRAY
IMPLEMENTATIONS
IN
AN
ARRAY
THE
SEQUENTIALITY
OF
A
LIST
IS
MAINTAINED
BY
THE
ORDER
STRUCTURE
OF
ELEMENTS
IN
THE
ARRAY
INDEXES
ALTHOUGH
SEARCHING
AN
ARRAY
FOR
AN
INDIVIDUAL
ELEMENT
CAN
BE
VERY
EFFICIENT
ADDITION
AND
DELETION
OF
ELEMENTS
ARE
COMPLEX
AND
INEFFICIENT
PROCESSES
FOR
THIS
REASON
ARRAYS
ARE
SELDOM
USED
ESPECIALLY
WHEN
THE
LIST
CHANGES
FREQUENTLY
IN
ADDITION
ARRAY
IMPLEMENTATIONS
OF
NON
LINEAR
LISTS
CAN
BECOME
EXCESSIVELY
LARGE
ESPECIALLY
WHEN
THERE
ARE
SEVERAL
SUCCESSORS
FOR
EACH
ELEMENT
APPENDIX
F
PROVIDES
ARRAY
IMPLEMENTATIONS
FOR
TWO
ADTS
LINKED
LIST
IMPLEMENTATIONS
A
LINKED
LIST
IS
AN
ORDERED
COLLECTION
OF
DATA
IN
WHICH
EACH
ELEMENT
CONTAINS
THE
LOCATION
OF
THE
NEXT
ELEMENT
OR
ELEMENTS
IN
A
LINKED
LIST
EACH
ELEMENT
CON
TAINS
TWO
PARTS
DATA
AND
ONE
OR
MORE
LINKS
THE
DATA
PART
HOLDS
THE
APPLICATION
DATA
THE
DATA
TO
BE
PROCESSED
LINKS
ARE
USED
TO
CHAIN
THE
DATA
TOGETHER
THEY
CONTAIN
POINTERS
THAT
IDENTIFY
THE
NEXT
ELEMENT
OR
ELEMENTS
IN
THE
LIST
WE
CAN
USE
A
LINKED
LIST
TO
CREATE
LINEAR
AND
NON
LINEAR
STRUCTURES
IN
LIN
EAR
LINKED
LISTS
EACH
ELEMENT
HAS
ONLY
ZERO
OR
ONE
SUCCESSOR
IN
NON
LINEAR
LINKED
LISTS
EACH
ELEMENT
CAN
HAVE
ZERO
ONE
OR
MORE
SUCCESSORS
THE
MAJOR
ADVANTAGE
OF
THE
LINKED
LIST
OVER
THE
ARRAY
IS
THAT
DATA
ARE
EAS
ILY
INSERTED
AND
DELETED
IT
IS
NOT
NECESSARY
TO
SHIFT
ELEMENTS
OF
A
LINKED
LIST
TO
MAKE
ROOM
FOR
A
NEW
ELEMENT
OR
TO
DELETE
AN
ELEMENT
ON
THE
OTHER
HAND
BECAUSE
THE
ELEMENTS
ARE
NO
LONGER
PHYSICALLY
SEQUENCED
WE
ARE
LIMITED
TO
SEQUENTIAL
SEARCHES
WE
CANNOT
USE
A
BINARY
SEARCH
SEQUENTIAL
AND
BINARY
SEARCHES
ARE
DISCUSSED
IN
CHAPTER
WHEN
WE
EXAMINE
TREES
YOU
WILL
SEE
SEVERAL
DATA
STRUCTURES
THAT
ALLOW
FOR
EASY
UPDATES
AND
EFFICIENT
SEARCHES
SECTION
ADT
IMPLEMENTATIONS
FIGURE
A
SHOWS
A
LINKED
LIST
IMPLEMENTATION
OF
A
LINEAR
LIST
THE
LINK
IN
EACH
ELEMENT
EXCEPT
THE
LAST
POINTS
TO
ITS
UNIQUE
SUCCESSOR
THE
LINK
IN
THE
LAST
ELEMENT
CONTAINS
A
NULL
POINTER
INDICATING
THE
END
OF
THE
LIST
FIGURE
B
SHOWS
A
LINKED
LIST
IMPLEMENTATION
OF
A
NON
LINEAR
LIST
AN
ELEMENT
IN
A
NON
LINEAR
LIST
CAN
HAVE
TWO
OR
MORE
LINKS
HERE
EACH
ELEMENT
CONTAINS
TWO
LINKS
EACH
TO
ONE
SUCCESSOR
FIGURE
C
CONTAINS
AN
EXAM
PLE
OF
AN
EMPTY
LIST
LINEAR
OR
NON
LINEAR
WE
DEFINE
AN
EMPTY
LIST
AS
A
NULL
LIST
POINTER
LIST
DATA
LINK
DATA
LINK
DATA
LINK
A
LINEAR
LIST
DATA
LINK
LINK
DATA
LINK
B
NON
LINEAR
LIST
LINK
DATA
LINK
IN
THIS
SECTION
WE
DISCUSS
ONLY
THE
BASIC
CONCEPTS
FOR
LINKED
LISTS
WE
EXPAND
ON
THESE
CONCEPTS
IN
FUTURE
CHAPTERS
NODES
IN
LINKED
LIST
IMPLEMENTATION
THE
ELEMENTS
IN
A
LIST
ARE
CALLED
NODES
A
NODE
IS
A
STRUCTURE
THAT
HAS
TWO
PARTS
THE
DATA
AND
ONE
OR
MORE
LINKS
FIGURE
SHOWS
TWO
DIFFERENT
NODES
ONE
FOR
A
LINEAR
LIST
AND
THE
OTHER
FOR
A
NON
LINEAR
LIST
THE
NODES
IN
A
LINKED
LIST
ARE
CALLED
SELF
REFERENTIAL
STRUCTURES
IN
A
SELF
REFERENTIAL
STRUCTURE
EACH
INSTANCE
OF
THE
STRUCTURE
CONTAINS
ONE
OR
MORE
POINTERS
TO
OTHER
INSTANCES
OF
THE
SAME
STRUCTURAL
TYPE
IN
FIGURE
THE
COLORED
BOXES
WITH
ARROWS
ARE
THE
POINTERS
THAT
MAKE
THE
LINKED
LIST
A
SELF
REFERENTIAL
STRUCTURE
THE
DATA
PART
IN
A
NODE
CAN
BE
A
SINGLE
FIELD
MULTIPLE
FIELDS
OR
A
STRUC
TURE
THAT
CONTAINS
SEVERAL
FIELDS
BUT
IT
ALWAYS
ACTS
AS
A
SINGLE
FIELD
FIGURE
SHOWS
THREE
DESIGNS
FOR
A
NODE
OF
A
LINEAR
LIST
THE
UPPER
LEFT
NODE
CONTAINS
A
CHAPTER
BASIC
CONCEPTS
A
NODE
IN
A
LINEAR
LIST
B
NODE
IN
A
NON
LINEAR
LIST
FIGURE
NODES
SINGLE
FIELD
A
NUMBER
AND
A
LINK
THE
UPPER
RIGHT
NODE
IS
MORE
TYPICAL
IT
CONTAINS
THREE
DATA
FIELDS
A
NAME
AN
ID
AND
GRADE
POINTS
GRDPTS
AND
A
LINK
THE
THIRD
EXAMPLE
IS
THE
ONE
WE
RECOMMEND
THE
FIELDS
ARE
DEFINED
IN
THEIR
OWN
STRUCTURE
WHICH
IS
THEN
PUT
INTO
THE
DEFINITION
OF
A
NODE
STRUCTURE
FIGURE
LINKED
LIST
NODE
STRUCTURES
POINTERS
TO
LINKED
LISTS
A
LINKED
LIST
MUST
ALWAYS
HAVE
A
HEAD
POINTER
DEPENDING
ON
HOW
WE
USE
THE
LIST
WE
MAY
HAVE
SEVERAL
OTHER
POINTERS
AS
WELL
FOR
EXAMPLE
IF
WE
ARE
GOING
TO
SEARCH
A
LINKED
LIST
WE
WILL
NEED
AN
ADDITIONAL
POINTER
TO
THE
LOCATION
WHERE
WE
FOUND
THE
DATA
WE
WERE
LOOKING
FOR
FURTHERMORE
IN
MANY
STRUC
TURES
PROGRAMMING
IS
MORE
EFFICIENT
IF
THERE
IS
A
POINTER
TO
THE
LAST
NODE
IN
THE
LIST
AS
WELL
AS
A
HEAD
POINTER
GENERIC
CODE
FOR
ADTS
IN
DATA
STRUCTURES
WE
NEED
TO
CREATE
GENERIC
CODE
FOR
ABSTRACT
DATA
TYPES
GENERIC
CODE
ALLOWS
US
TO
WRITE
ONE
SET
OF
CODE
AND
APPLY
IT
TO
ANY
DATA
TYPE
FOR
SECTION
GENERIC
CODE
FOR
ADTS
EXAMPLE
WE
CAN
WRITE
GENERIC
FUNCTIONS
TO
IMPLEMENT
A
STACK
STRUCTURE
WE
CAN
THEN
USE
THE
GENERIC
FUNCTIONS
TO
IMPLEMENT
AN
INTEGER
STACK
A
FLOAT
STACK
A
DOUBLE
STACK
AND
SO
ON
ALTHOUGH
SOME
HIGH
LEVEL
LANGUAGES
SUCH
AS
C
AND
JAVA
PROVIDE
SPECIAL
TOOLS
TO
HANDLE
GENERIC
CODE
C
HAS
LIMITED
CAPABILITY
THROUGH
TWO
FEATURES
POINTER
TO
VOID
AND
POINTER
TO
FUNCTION
POINTER
TO
VOID
THE
FIRST
FEATURE
IS
POINTER
TO
VOID
BECAUSE
C
IS
STRONGLY
TYPED
OPERATIONS
SUCH
AS
ASSIGN
AND
COMPARE
MUST
USE
COMPATIBLE
TYPES
OR
BE
CAST
TO
COMPATIBLE
TYPES
THE
ONE
EXCEPTION
IS
THE
POINTER
TO
VOID
WHICH
CAN
BE
ASSIGNED
WITHOUT
A
CAST
IN
OTHER
WORDS
A
POINTER
TO
VOID
IS
A
GENERIC
POINTER
THAT
CAN
BE
USED
TO
REPRESENT
ANY
DATA
TYPE
DURING
COMPILATION
OR
RUN
TIME
FIGURE
SHOWS
THE
IDEA
OF
A
POINTER
TO
VOID
NOTE
THAT
A
POINTER
TO
VOID
IS
NOT
A
NULL
POINTER
IT
IS
POINTING
TO
A
GENERIC
DATA
TYPE
VOID
VOID
VOID
FIGURE
POINTER
TO
VOID
P
F
FIGURE
POINTERS
FOR
PROGRAM
PROGRAM
USES
A
POINTER
TO
VOID
THAT
WE
CAN
USE
TO
PRINT
EITHER
AN
INTEGER
OR
A
FLOATING
POINT
NUMBER
CHAPTER
BASIC
CONCEPTS
PROGRAM
DEMONSTRATE
POINTER
TO
VOID
DEMONSTRATE
POINTER
TO
VOID
WRITTEN
BY
DATE
INCLUDE
STDIO
H
INT
MAIN
LOCAL
DEFINITIONS
VOID
P
INT
I
FLOAT
F
STATEMENTS
P
I
PRINTF
I
CONTAINS
D
N
INT
P
P
F
PRINTF
F
CONTAINS
F
N
FLOAT
P
RETURN
MAIN
RESULTS
I
CONTAINS
F
CONTAINS
PROGRAM
ANALYSIS
THE
PROGRAM
IS
TRIVIAL
BUT
IT
DEMONSTRATES
THE
POINT
THE
POINTER
P
IS
DECLARED
AS
A
VOID
POINTER
BUT
IT
CAN
ACCEPT
THE
ADDRESS
OF
AN
INTEGER
OR
FLOATING
POINT
NUMBER
HOWEVER
WE
MUST
REMEMBER
A
VERY
IMPORT
POINT
ABOUT
POINTERS
TO
VOID
A
POINTER
TO
VOID
CANNOT
BE
DEREFERENCED
UNLESS
IT
IS
CAST
IN
OTHER
WORDS
WE
CANNOT
USE
P
WITHOUT
CASTING
THAT
IS
WHY
WE
NEED
TO
CAST
THE
POINTER
IN
THE
PRINT
FUNCTION
BEFORE
WE
USE
IT
FOR
PRINTING
EXAMPLE
AS
ANOTHER
EXAMPLE
LET
US
LOOK
AT
A
SYSTEM
FUNCTION
MALLOC
THIS
FUNCTION
RETURNS
A
POINTER
TO
VOID
THE
DESIGNERS
OF
THE
MALLOC
FUNCTION
NEEDED
TO
DYNAMICALLY
ALLOCATE
ANY
TYPE
OF
DATA
HOWEVER
INSTEAD
OF
USING
SEVERAL
MAL
LOC
FUNCTIONS
EACH
RETURNING
A
POINTER
TO
A
SPECIFIC
DATA
TYPE
INT
FLOAT
DOUBLE
AND
SO
ON
THEY
DESIGNED
A
GENERIC
FUNCTION
THAT
RETURNS
A
POINTER
TO
VOID
VOID
WHILE
IT
IS
NOT
REQUIRED
WE
RECOMMEND
THAT
THE
RETURNED
POINTER
BE
CAST
TO
THE
APPROPRIATE
TYPE
THE
FOLLOWING
SHOWS
THE
USE
OF
MALLOC
TO
CREATE
A
POINTER
TO
AN
INTEGER
INTPTR
INT
MALLOC
SIZEOF
INT
SECTION
GENERIC
CODE
FOR
ADTS
EXAMPLE
NOW
LET
LOOK
AT
AN
EXAMPLE
THAT
IS
SIMILAR
TO
WHAT
WE
USE
TO
IMPLEMENT
OUR
ADTS
WE
NEED
TO
HAVE
A
GENERIC
FUNCTION
TO
CREATE
A
NODE
STRUCTURE
THE
STRUCTURE
HAS
TWO
FIELDS
DATA
AND
LINK
THE
LINK
FIELD
IS
A
POINTER
TO
THE
NODE
STRUCTURE
THE
DATA
FIELD
HOWEVER
CAN
BE
ANY
TYPE
INTEGER
FLOATING
POINT
STRING
OR
EVEN
ANOTHER
STRUCTURE
TO
MAKE
THE
FUNCTION
GENERIC
SO
THAT
WE
CAN
STORE
ANY
TYPE
OF
DATA
IN
THE
NODE
WE
USE
A
VOID
POINTER
TO
DATA
STORED
IN
DYNAMIC
MEMORY
WE
DECLARE
THE
NODE
STRUCTURE
AS
SHOWN
IN
FIGURE
TO
NEXT
NODE
FIGURE
POINTER
TO
NODE
NODE
NOW
LET
WRITE
THE
PROGRAM
THAT
CALLS
A
FUNCTION
THAT
ACCEPTS
A
POINTER
TO
DATA
OF
ANY
TYPE
AND
CREATES
A
NODE
THAT
STORES
THE
DATA
POINTER
AND
A
LINK
POINTER
BECAUSE
WE
DON
T
KNOW
WHERE
THE
LINK
POINTER
WILL
BE
POINTING
WE
MAKE
IT
NULL
THE
POINTER
DESIGN
IS
SHOWN
IN
FIGURE
FIGURE
POINTERS
FOR
PROGRAMS
AND
TYPICALLY
ADTS
ARE
STORED
IN
THEIR
OWN
HEADER
FILES
WE
BEGIN
THEREFORE
BY
WRITING
THE
CODE
FOR
CREATING
THE
NODE
AND
PLACING
THE
CODE
IN
A
HEADER
FILE
THIS
CODE
IS
SHOWN
IN
PROGRAM
PROGRAM
CREATE
NODE
HEADER
FILE
HEADER
FILE
FOR
CREATE
NODE
STRUCTURE
CONTINUED
CHAPTER
BASIC
CONCEPTS
PROGRAM
CREATE
NODE
HEADER
FILE
CONTINUED
WRITTEN
BY
DATE
TYPEDEF
STRUCT
NODE
VOID
DATAPTR
STRUCT
NODE
LINK
NODE
CREATENODE
CREATES
A
NODE
IN
DYNAMIC
MEMORY
AND
STORES
DATA
POINTER
IN
IT
PRE
ITEMPTR
IS
POINTER
TO
DATA
TO
BE
STORED
POST
NODE
CREATED
AND
ITS
ADDRESS
RETURNED
NODE
CREATENODE
VOID
ITEMPTR
NODE
NODEPTR
NODEPTR
NODE
MALLOC
SIZEOF
NODE
NODEPTR
DATAPTR
ITEMPTR
NODEPTR
LINK
NULL
RETURN
NODEPTR
CREATENODE
NOW
THAT
WE
VE
CREATED
THE
DATA
STRUCTURE
AND
THE
CREATE
NODE
FUNCTION
WE
CAN
WRITE
PROGRAM
TO
DEMONSTRATE
THE
USE
OF
VOID
POINTERS
IN
A
NODE
PROGRAM
DEMONSTRATE
NODE
CREATION
FUNCTION
DEMONSTRATE
SIMPLE
GENERIC
NODE
CREATION
FUNCTION
WRITTEN
BY
DATE
INCLUDE
STDIO
H
INCLUDE
STDLIB
H
INCLUDE
H
HEADER
FILE
INT
MAIN
VOID
LOCAL
DEFINITIONS
INT
NEWDATA
INT
NODEDATA
NODE
NODE
STATEMENTS
NEWDATA
INT
MALLOC
SIZEOF
INT
NEWDATA
CONTINUED
SECTION
GENERIC
CODE
FOR
ADTS
PROGRAM
DEMONSTRATE
NODE
CREATION
FUNCTION
CONTINUED
NODE
CREATENODE
NEWDATA
NODEDATA
INT
NODE
DATAPTR
PRINTF
DATA
FROM
NODE
D
N
NODEDATA
RETURN
MAIN
RESULTS
DATA
FROM
NODE
PROGRAM
ANALYSIS
THERE
ARE
SEVERAL
IMPORTANT
CONCEPTS
IN
THIS
PROGRAM
FIRST
THE
DATA
TO
BE
STORED
IN
THE
NODE
IS
REPRESENTED
BY
A
VOID
POINTER
BECAUSE
THERE
ARE
USUALLY
MANY
INSTANCES
OF
THESE
NODES
IN
A
PROGRAM
THE
DATA
ARE
STORED
IN
DYNAMIC
MEMORY
THE
ALLOCATION
AND
STORAGE
OF
THE
DATA
ARE
THE
RESPONSIBILITY
OF
THE
PROGRAMMER
WE
SHOW
THESE
TWO
STEPS
IN
STATE
MENTS
AND
THE
CREATENODE
FUNCTION
ALLOCATES
A
NODE
STRUCTURE
IN
DYNAMIC
MEMORY
STORES
THE
DATA
VOID
POINTER
IN
THE
NODE
AND
THEN
RETURNS
THE
NODE
ADDRESS
IN
STATEMENT
WE
STORE
THE
VOID
POINTER
FROM
THE
NODE
INTO
AN
INTEGER
POINTER
BECAUSE
C
IS
STRONGLY
TYPED
THIS
ASSIGNMENT
MUST
BE
CAST
TO
AN
INTEGER
POINTER
SO
WHILE
WE
CAN
STORE
AN
ADDRESS
IN
A
VOID
POINTER
WITHOUT
KNOWING
ITS
TYPE
THE
REVERSE
IS
NOT
TRUE
TO
USE
A
VOID
POINTER
EVEN
IN
AN
ASSIGNMENT
IT
MUST
BE
CAST
EXAMPLE
ADT
STRUCTURES
GENERALLY
CONTAIN
SEVERAL
INSTANCES
OF
A
NODE
TO
BETTER
DEM
ONSTRATE
THE
ADT
CONCEPT
THEREFORE
LET
MODIFY
PROGRAM
TO
CONTAIN
TWO
DIFFERENT
NODES
IN
THIS
SIMPLE
EXAMPLE
WE
POINT
THE
FIRST
NODE
TO
THE
SECOND
NODE
THE
POINTER
STRUCTURE
FOR
THE
PROGRAM
IS
SHOWN
IN
FIGURE
FIGURE
STRUCTURE
FOR
TWO
LINKED
NODES
THE
POINTER
VALUES
IN
FIGURE
REPRESENT
THE
SETTINGS
AT
THE
END
OF
PROGRAM
CHAPTER
BASIC
CONCEPTS
PROGRAM
CREATE
LIST
WITH
TWO
LINKED
NODES
CREATE
A
LIST
WITH
TWO
LINKED
NODES
WRITTEN
BY
DATE
INCLUDE
STDIO
H
INCLUDE
STDLIB
H
INCLUDE
H
HEADER
FILE
INT
MAIN
VOID
LOCAL
DEFINITIONS
INT
NEWDATA
INT
NODEDATA
NODE
NODE
STATEMENTS
NEWDATA
INT
MALLOC
SIZEOF
INT
NEWDATA
NODE
CREATENODE
NEWDATA
NEWDATA
INT
MALLOC
SIZEOF
INT
NEWDATA
NODE
LINK
CREATENODE
NEWDATA
NODEDATA
INT
NODE
DATAPTR
PRINTF
DATA
FROM
NODE
D
N
NODEDATA
NODEDATA
INT
NODE
LINK
DATAPTR
PRINTF
DATA
FROM
NODE
D
N
NODEDATA
RETURN
MAIN
RESULTS
DATA
FROM
NODE
DATA
FROM
NODE
PROGRAM
ANALYSIS
THIS
PROGRAM
DEMONSTRATES
AN
IMPORTANT
POINT
IN
A
GENERIC
STRUCTURE
SUCH
AS
SHOWN
IN
THE
PROGRAM
THE
NODES
AND
THE
DATA
MUST
BOTH
BE
IN
DYNAMIC
MEMORY
WHEN
STUDY
ING
THE
PROGRAM
FOLLOW
THE
CODE
THROUGH
FIGURE
POINTER
TO
FUNCTION
THE
SECOND
TOOL
THAT
IS
REQUIRED
TO
CREATE
C
GENERIC
CODE
IS
POINTER
TO
FUNC
TION
IN
THIS
SECTION
WE
DISCUSS
HOW
TO
USE
IT
FUNCTIONS
IN
YOUR
PROGRAM
OCCUPY
MEMORY
THE
NAME
OF
THE
FUNCTION
IS
A
POINTER
CONSTANT
TO
ITS
FIRST
BYTE
OF
MEMORY
FOR
EXAMPLE
IMAGINE
THAT
YOU
HAVE
FOUR
FUNCTIONS
STORED
IN
MEMORY
MAIN
FUN
PUN
AND
SUN
THIS
SECTION
GENERIC
CODE
FOR
ADTS
RELATIONSHIP
IS
SHOWN
GRAPHICALLY
IN
FIGURE
THE
NAME
OF
EACH
FUNCTION
IS
A
POINTER
TO
ITS
CODE
IN
MEMORY
MAIN
INT
MAIN
VOID
VOID
FUN
VOID
INT
PUN
INT
INT
POINTERS
TO
FUNCTION
FIGURE
FUNCTIONS
IN
MEMORY
MEMORY
DOUBLE
SUN
FLOAT
DEFINING
POINTERS
TO
FUNCTIONS
JUST
AS
WITH
ALL
OTHER
POINTER
TYPES
WE
CAN
DEFINE
POINTERS
TO
FUNCTION
VARI
ABLES
AND
STORE
THE
ADDRESS
OF
FUN
PUN
AND
SUN
IN
THEM
TO
DECLARE
A
POINTER
TO
FUNCTION
WE
CODE
IT
AS
IF
IT
WERE
A
PROTOTYPE
DEFINITION
WITH
THE
FUNCTION
POINTER
IN
PARENTHESES
THIS
FORMAT
IS
SHOWN
IN
FIGURE
THE
PARENTHESES
ARE
IMPORTANT
WITHOUT
THEM
C
INTERPRETS
THE
FUNCTION
RETURN
TYPE
AS
A
POINTER
USING
POINTERS
TO
FUNCTIONS
NOW
THAT
YOU
VE
SEEN
HOW
TO
CREATE
AND
USE
POINTERS
TO
FUNCTIONS
LET
WRITE
A
GENERIC
FUNCTION
THAT
RETURNS
THE
LARGER
OF
ANY
TWO
PIECES
OF
DATA
THE
FUNC
TION
USES
TWO
POINTERS
TO
VOID
AS
DESCRIBED
IN
THE
PREVIOUS
SECTION
WHILE
OUR
FUNCTION
NEEDS
TO
DETERMINE
WHICH
OF
THE
TWO
VALUES
REPRESENTED
BY
THE
VOID
POINTERS
IS
LARGER
IT
CANNOT
DIRECTLY
COMPARE
THEM
BECAUSE
IT
DOESN
T
KNOW
WHAT
TYPE
CASTS
TO
USE
WITH
THE
VOID
POINTERS
ONLY
THE
APPLICATION
PROGRAM
KNOWS
THE
DATA
TYPES
THE
SOLUTION
IS
TO
WRITE
SIMPLE
COMPARE
FUNCTIONS
FOR
EACH
PROGRAM
THAT
USES
OUR
GENERIC
FUNCTION
THEN
WHEN
WE
CALL
THE
GENERIC
COMPARE
FUNCTION
WE
USE
A
POINTER
TO
FUNCTION
TO
PASS
IT
THE
SPECIFIC
COMPARE
FUNCTION
THAT
IT
MUST
USE
EXAMPLE
AS
WE
SAW
IN
OUR
DISCUSSION
OF
POINTERS
TO
VOID
WE
PLACE
OUR
GENERIC
FUNC
TION
WHICH
WE
CALL
LARGER
IN
A
HEADER
FILE
SO
THAT
IT
CAN
BE
EASILY
USED
THE
PROGRAM
INTERFACES
AND
POINTERS
ARE
SHOWN
IN
FIGURE
CHAPTER
BASIC
CONCEPTS
FIGURE
POINTERS
TO
FUNCTIONS
FIGURE
DESIGN
OF
LARGER
FUNCTION
THE
CODE
IS
SHOWN
IN
PROGRAM
PROGRAM
LARGER
COMPARE
FUNCTION
GENERIC
FUNCTION
TO
DETERMINE
THE
LARGER
OF
TWO
VALUES
REFERENCED
AS
VOID
POINTERS
PRE
AND
ARE
POINTERS
TO
VALUES
OF
AN
UNKNOWN
TYPE
PTRTOCMPFUN
IS
ADDRESS
OF
A
FUNCTION
THAT
KNOWS
THE
DATA
TYPES
POST
DATA
COMPARED
AND
LARGER
VALUE
RETURNED
CONTINUED
SECTION
GENERIC
CODE
FOR
ADTS
PROGRAM
LARGER
COMPARE
FUNCTION
CONTINUED
VOID
LARGER
VOID
VOID
INT
PTRTOCMPFUN
VOID
VOID
IF
PTRTOCMPFUN
RETURN
ELSE
RETURN
LARGER
PROGRAM
CONTAINS
AN
EXAMPLE
OF
HOW
TO
USE
OUR
GENERIC
COMPARE
PROGRAM
AND
PASS
IT
A
SPECIFIC
COMPARE
FUNCTION
PROGRAM
COMPARE
TWO
INTEGERS
DEMONSTRATE
GENERIC
COMPARE
FUNCTIONS
AND
POINTER
TO
FUNCTION
WRITTEN
BY
DATE
INCLUDE
STDIO
H
INCLUDE
STDLIB
H
INCLUDE
H
HEADER
FILE
INT
COMPARE
VOID
VOID
INT
MAIN
VOID
LOCAL
DEFINITIONS
INT
I
INT
J
INT
LRG
STATEMENTS
LRG
INT
LARGER
I
J
COMPARE
PRINTF
LARGER
VALUE
IS
D
N
LRG
RETURN
MAIN
COMPARE
INTEGER
SPECIFIC
COMPARE
FUNCTION
PRE
AND
ARE
POINTERS
TO
INTEGER
VALUES
POST
RETURNS
IF
RETURNS
IF
INT
COMPARE
VOID
VOID
CONTINUED
CHAPTER
BASIC
CONCEPTS
PROGRAM
COMPARE
TWO
INTEGERS
CONTINUED
IF
INT
INT
RETURN
ELSE
RETURN
COMPARE
RESULTS
LARGER
VALUE
IS
EXAMPLE
NOW
LET
WRITE
A
PROGRAM
THAT
COMPARES
TWO
FLOATING
POINT
NUMBERS
WE
CAN
USE
OUR
LARGER
FUNCTION
BUT
WE
NEED
TO
WRITE
A
NEW
COMPARE
FUNCTION
WE
REPEAT
PROGRAM
CHANGING
ONLY
THE
COMPARE
FUNCTION
AND
THE
DATA
SPECIFIC
STATEMENTS
IN
MAIN
THE
RESULT
IS
SHOWN
IN
PROGRAM
PROGRAM
COMPARE
TWO
FLOATING
POINT
VALUES
DEMONSTRATE
GENERIC
COMPARE
FUNCTIONS
AND
POINTER
TO
FUNCTION
WRITTEN
BY
DATE
INCLUDE
STDIO
H
INCLUDE
STDLIB
H
INCLUDE
H
HEADER
FILE
INT
COMPARE
VOID
VOID
INT
MAIN
VOID
LOCAL
DEFINITIONS
FLOAT
FLOAT
FLOAT
LRG
STATEMENTS
LRG
FLOAT
LARGER
COMPARE
PRINTF
LARGER
VALUE
IS
N
LRG
RETURN
MAIN
COMPARE
FLOAT
SPECIFIC
COMPARE
FUNCTION
PRE
AND
ARE
POINTERS
TO
INTEGER
VALUES
POST
RETURNS
IF
CONTINUED
SECTION
ALGORITHM
EFFICIENCY
PROGRAM
COMPARE
TWO
FLOATING
POINT
VALUES
CONTINUED
RETURNS
IF
INT
COMPARE
VOID
VOID
IF
FLOAT
FLOAT
RETURN
ELSE
RETURN
COMPARE
RESULTS
LARGER
VALUE
IS
ALGORITHM
EFFICIENCY
THERE
IS
SELDOM
A
SINGLE
ALGORITHM
FOR
ANY
PROBLEM
WHEN
COMPARING
TWO
DIFFERENT
ALGORITHMS
THAT
SOLVE
THE
SAME
PROBLEM
YOU
OFTEN
FIND
THAT
ONE
ALGORITHM
IS
AN
ORDER
OF
MAGNITUDE
MORE
EFFICIENT
THAN
THE
OTHER
IN
THIS
CASE
IT
ONLY
MAKES
SENSE
THAT
YOU
BE
ABLE
TO
RECOGNIZE
AND
CHOOSE
THE
MORE
EFFI
CIENT
ALGORITHM
ALTHOUGH
COMPUTER
SCIENTISTS
HAVE
STUDIED
ALGORITHMS
AND
ALGORITHM
EFFI
CIENCY
EXTENSIVELY
THE
FIELD
HAS
NOT
BEEN
GIVEN
AN
OFFICIAL
NAME
BRASSARD
AND
BRATLEY
COINED
THE
TERM
ALGORITHMICS
WHICH
THEY
DEFINE
AS
THE
SYSTEMATIC
STUDY
OF
THE
FUNDAMENTAL
TECHNIQUES
USED
TO
DESIGN
AND
ANALYZE
EFFICIENT
ALGO
RITHMS
WE
USE
THE
TERM
IN
THIS
BOOK
IF
A
FUNCTION
IS
LINEAR
THAT
IS
IF
IT
CONTAINS
NO
LOOPS
OR
RECURSIONS
ITS
EFFICIENCY
IS
A
FUNCTION
OF
THE
NUMBER
OF
INSTRUCTIONS
IT
CONTAINS
IN
THIS
CASE
ITS
EFFICIENCY
DEPENDS
ON
THE
SPEED
OF
THE
COMPUTER
AND
IS
GENERALLY
NOT
A
FAC
TOR
IN
THE
OVERALL
EFFICIENCY
OF
A
PROGRAM
ON
THE
OTHER
HAND
FUNCTIONS
THAT
USE
LOOPS
OR
RECURSION
VARY
WIDELY
IN
EFFICIENCY
THE
STUDY
OF
ALGORITHM
EFFI
CIENCY
THEREFORE
FOCUSES
ON
LOOPS
OUR
ANALYSIS
CONCENTRATES
ON
LOOPS
BECAUSE
RECURSION
CAN
ALWAYS
BE
CONVERTED
TO
A
LOOP
AS
WE
STUDY
SPECIFIC
EXAMPLES
WE
GENERALLY
DISCUSS
THE
ALGORITHM
EFFICIENCY
AS
A
FUNCTION
OF
THE
NUMBER
OF
ELEMENTS
TO
BE
PROCESSED
THE
GENERAL
FORMAT
IS
F
N
EFFICIENCY
THE
BASIC
CONCEPTS
ARE
DISCUSSED
IN
THIS
SECTION
GILLES
BRASSARD
AND
PAUL
BRATLEY
ALGORITHMICS
THEORY
AND
PRACTICE
ENGLEWOOD
CLIFFS
N
J
PRENTICE
HALL
XIII
CHAPTER
BASIC
CONCEPTS
LINEAR
LOOPS
LET
US
START
WITH
A
SIMPLE
LOOP
WE
WANT
TO
KNOW
HOW
MANY
TIMES
THE
BODY
OF
THE
LOOP
IS
REPEATED
IN
THE
FOLLOWING
CODE
ASSUMING
I
IS
AN
INTEGER
THE
ANSWER
IS
TIMES
THE
NUMBER
OF
ITERA
TIONS
IS
DIRECTLY
PROPORTIONAL
TO
THE
LOOP
FACTOR
THE
HIGHER
THE
FACTOR
THE
HIGHER
THE
NUMBER
OF
LOOPS
BECAUSE
THE
EFFICIENCY
IS
DIRECTLY
PROPOR
TIONAL
TO
THE
NUMBER
OF
ITERATIONS
IT
IS
F
N
N
HOWEVER
THE
ANSWER
IS
NOT
ALWAYS
AS
STRAIGHTFORWARD
AS
IT
IS
IN
THE
ABOVE
EXAMPLE
FOR
INSTANCE
CONSIDER
THE
FOLLOWING
LOOP
HOW
MANY
TIMES
IS
THE
BODY
REPEATED
IN
THIS
LOOP
HERE
THE
ANSWER
IS
TIMES
WHY
IN
THIS
EXAMPLE
THE
NUMBER
OF
ITERATIONS
IS
HALF
THE
LOOP
FACTOR
ONCE
AGAIN
HOWEVER
THE
HIGHER
THE
FACTOR
THE
HIGHER
THE
NUMBER
OF
LOOPS
THE
EFFICIENCY
OF
THIS
LOOP
IS
PROPORTIONAL
TO
HALF
THE
FACTOR
WHICH
MAKES
IT
F
N
N
IF
YOU
WERE
TO
PLOT
EITHER
OF
THESE
LOOP
EXAMPLES
YOU
WOULD
GET
A
STRAIGHT
LINE
FOR
THAT
REASON
THEY
ARE
KNOWN
AS
LINEAR
LOOPS
LOGARITHMIC
LOOPS
IN
A
LINEAR
LOOP
THE
LOOP
UPDATE
EITHER
ADDS
OR
SUBTRACTS
IN
A
LOGARITHMIC
LOOP
THE
CONTROLLING
VARIABLE
IS
MULTIPLIED
OR
DIVIDED
IN
EACH
ITERATION
HOW
MANY
TIMES
IS
THE
BODY
OF
THE
LOOPS
REPEATED
IN
THE
FOLLOWING
PROGRAM
SEGMENTS
TO
HELP
YOU
UNDERSTAND
THIS
PROBLEM
TABLE
ANALYZES
THE
VALUES
OF
I
FOR
EACH
ITERATION
AS
YOU
CAN
SEE
THE
NUMBER
OF
ITERATIONS
IS
IN
BOTH
CASES
THE
REASON
IS
THAT
IN
EACH
ITERATION
THE
VALUE
OF
I
DOUBLES
FOR
THE
MUL
TIPLY
LOOP
AND
IS
CUT
IN
HALF
FOR
THE
DIVIDE
LOOP
THUS
THE
NUMBER
OF
ITERATIONS
FOR
ALGORITHM
EFFICIENCY
ANALYSIS
WE
USE
C
CODE
SO
THAT
WE
CAN
CLEARLY
SEE
THE
LOOPING
CONSTRUCTS
SECTION
ALGORITHM
EFFICIENCY
MULTIPLY
DIVIDE
ITERATION
VALUE
OF
I
ITERATION
VALUE
OF
I
EXIT
EXIT
TABLE
ANALYSIS
OF
MULTIPLY
AND
DIVIDE
LOOPS
GENERALIZING
THE
ANALYSIS
WE
CAN
SAY
THAT
THE
ITERATIONS
IN
LOOPS
THAT
MULTIPLY
OR
DIVIDE
ARE
DETERMINED
BY
THE
FOLLOWING
FORMULA
F
N
LOGN
NESTED
LOOPS
LOOPS
THAT
CONTAIN
LOOPS
ARE
KNOWN
AS
NESTED
LOOPS
WHEN
WE
ANALYZE
NESTED
LOOPS
WE
MUST
DETERMINE
HOW
MANY
ITERATIONS
EACH
LOOP
COMPLETES
THE
TOTAL
IS
THEN
THE
PRODUCT
OF
THE
NUMBER
OF
ITERATIONS
IN
THE
INNER
LOOP
AND
THE
NUMBER
OF
ITERATIONS
IN
THE
OUTER
LOOP
ITERATIONS
OUTER
LOOP
ITERATIONS
X
INNER
LOOP
ITERATIONS
WE
NOW
LOOK
AT
THREE
NESTED
LOOPS
LINEAR
LOGARITHMIC
QUADRATIC
AND
DEPENDENT
QUADRATIC
CHAPTER
BASIC
CONCEPTS
LINEAR
LOGARITHMIC
THE
INNER
LOOP
IN
THE
FOLLOWING
CODE
IS
A
LOOP
THAT
MULTIPLIES
TO
SEE
THE
MUL
TIPLY
LOOP
LOOK
AT
THE
UPDATE
EXPRESSION
IN
THE
INNER
LOOP
THE
NUMBER
OF
ITERATIONS
IN
THE
INNER
LOOP
IS
THEREFORE
HOWEVER
BECAUSE
THE
INNER
LOOP
IS
CONTROLLED
BY
AN
OUTER
LOOP
THE
ABOVE
FORMULA
MUST
BE
MULTIPLIED
BY
THE
NUMBER
OF
TIMES
THE
OUTER
LOOP
EXECUTES
WHICH
IS
THIS
GIVES
US
WHICH
IS
GENERALIZED
AS
F
N
N
LOGN
QUADRATIC
IN
A
QUADRATIC
LOOP
THE
NUMBER
OF
TIMES
THE
INNER
LOOP
EXECUTES
IS
THE
SAME
AS
THE
OUTER
LOOP
CONSIDER
THE
FOLLOWING
EXAMPLE
THE
OUTER
LOOP
FOR
I
IS
EXECUTED
TIMES
FOR
EACH
OF
ITS
ITERATIONS
THE
INNER
LOOP
FOR
J
IS
ALSO
EXECUTED
TIMES
THE
ANSWER
THEREFORE
IS
WHICH
IS
THE
SQUARE
OF
THE
LOOPS
THIS
FORMULA
GENERALIZES
TO
DEPENDENT
QUADRATIC
IN
A
DEPENDENT
QUADRATIC
LOOP
THE
NUMBER
OF
ITERATIONS
OF
THE
INNER
LOOP
DEPENDS
ON
THE
OUTER
LOOP
CONSIDER
THE
NESTED
LOOP
SHOWN
IN
THE
FOLLOWING
EXAMPLE
SECTION
ALGORITHM
EFFICIENCY
THE
OUTER
LOOP
IS
THE
SAME
AS
THE
PREVIOUS
LOOP
HOWEVER
THE
INNER
LOOP
DEPENDS
ON
THE
OUTER
LOOP
FOR
ONE
OF
ITS
FACTORS
IT
IS
EXECUTED
ONLY
ONCE
THE
FIRST
ITERATION
TWICE
THE
SECOND
ITERATION
THREE
TIMES
THE
THIRD
ITERATION
AND
SO
FORTH
THE
NUMBER
OF
ITERATIONS
IN
THE
BODY
OF
THE
INNER
LOOP
IS
CALCULATED
AS
SHOWN
BELOW
IF
WE
COMPUTE
THE
AVERAGE
OF
THIS
LOOP
IT
IS
WHICH
IS
THE
SAME
AS
THE
NUMBER
OF
ITERATIONS
PLUS
DIVIDED
BY
MATHEMATICALLY
THIS
CALCULATION
IS
GENERALIZED
TO
MULTIPLYING
THE
INNER
LOOP
BY
THE
NUMBER
OF
TIMES
THE
OUTER
LOOP
IS
EXE
CUTED
GIVES
US
THE
FOLLOWING
FORMULA
FOR
A
DEPENDENT
QUADRATIC
LOOP
BIG
O
NOTATION
WITH
THE
SPEED
OF
COMPUTERS
TODAY
WE
ARE
NOT
CONCERNED
WITH
AN
EXACT
MEA
SUREMENT
OF
AN
ALGORITHM
EFFICIENCY
AS
MUCH
AS
WE
ARE
WITH
ITS
GENERAL
ORDER
OF
MAGNITUDE
IF
THE
ANALYSIS
OF
TWO
ALGORITHMS
SHOWS
THAT
ONE
EXECUTES
ITERATIONS
WHILE
THE
OTHER
EXECUTES
ITERATIONS
THEY
ARE
BOTH
SO
FAST
THAT
WE
CAN
T
SEE
THE
DIFFERENCE
ON
THE
OTHER
HAND
IF
ONE
ITERATES
TIMES
AND
THE
OTHER
TIMES
WE
SHOULD
BE
CONCERNED
WE
HAVE
SHOWN
THAT
THE
NUMBER
OF
STATEMENTS
EXECUTED
IN
THE
FUNCTION
FOR
N
ELEMENTS
OF
DATA
IS
A
FUNCTION
OF
THE
NUMBER
OF
ELEMENTS
EXPRESSED
AS
F
N
ALTHOUGH
THE
EQUATION
DERIVED
FOR
A
FUNCTION
MAY
BE
COMPLEX
A
DOMINANT
FAC
TOR
IN
THE
EQUATION
USUALLY
DETERMINES
THE
ORDER
OF
MAGNITUDE
OF
THE
RESULT
THEREFORE
WE
DON
T
NEED
TO
DETERMINE
THE
COMPLETE
MEASURE
OF
EFFICIENCY
ONLY
THE
FACTOR
THAT
DETERMINES
THE
MAGNITUDE
THIS
FACTOR
IS
THE
BIG
O
AS
IN
ON
THE
ORDER
OF
AND
IS
EXPRESSED
AS
O
N
THAT
IS
ON
THE
ORDER
OF
N
THIS
SIMPLIFICATION
OF
EFFICIENCY
IS
KNOWN
AS
BIG
O
ANALYSIS
FOR
EXAMPLE
IF
AN
ALGORITHM
IS
QUADRATIC
WE
WOULD
SAY
ITS
EFFICIENCY
IS
OR
ON
THE
ORDER
OF
N
SQUARED
THE
BIG
O
NOTATION
CAN
BE
DERIVED
FROM
F
N
USING
THE
FOLLOWING
STEPS
IN
EACH
TERM
SET
THE
COEFFICIENT
OF
THE
TERM
TO
CHAPTER
BASIC
CONCEPTS
KEEP
THE
LARGEST
TERM
IN
THE
FUNCTION
AND
DISCARD
THE
OTHERS
TERMS
ARE
RANKED
FROM
LOWEST
TO
HIGHEST
AS
SHOWN
BELOW
FOR
EXAMPLE
TO
CALCULATE
THE
BIG
O
NOTATION
FOR
WE
FIRST
REMOVE
ALL
COEFFICIENTS
THIS
GIVES
US
WHICH
AFTER
REMOVING
THE
SMALLER
FACTORS
GIVES
US
WHICH
IN
BIG
O
NOTATION
IS
STATED
AS
WE
FIRST
ELIMINATE
ALL
OF
THE
COEFFICIENTS
AS
SHOWN
BELOW
THE
LARGEST
TERM
IN
THIS
EXPRESSION
IS
THE
FIRST
ONE
SO
WE
CAN
SAY
THAT
THE
ORDER
OF
A
POLYNOMIAL
EXPRESSION
IS
STANDARD
MEASURES
OF
EFFICIENCY
COMPUTER
SCIENTISTS
HAVE
DEFINED
SEVEN
CATEGORIES
OF
ALGORITHM
EFFICIENCY
WE
LIST
THEM
IN
TABLE
IN
ORDER
OF
DECREASING
EFFICIENCY
AND
SHOW
THE
FIRST
FIVE
OF
THEM
GRAPHICALLY
IN
FIGURE
SECTION
ALGORITHM
EFFICIENCY
EFFICIENCY
BIG
O
ITERATIONS
ESTIMATED
TIME
LOGARITHMIC
O
LOGN
MICROSECONDS
LINEAR
O
N
SECONDS
LINEAR
LOGARITHMIC
O
N
LOGN
SECONDS
QUADRATIC
O
MINUTES
POLYNOMIAL
O
NK
HOURS
EXPONENTIAL
O
CN
INTRACTABLE
FACTORIAL
O
N
INTRACTABLE
TABLE
MEASURES
OF
EFFICIENCY
FOR
N
ANY
MEASURE
OF
EFFICIENCY
PRESUMES
THAT
A
SUFFICIENTLY
LARGE
SAMPLE
IS
BEING
CONSIDERED
IF
YOU
ARE
DEALING
WITH
ONLY
ELEMENTS
AND
THE
TIME
REQUIRED
IS
A
FRACTION
OF
A
SECOND
THERE
IS
NO
MEANINGFUL
DIFFERENCE
BETWEEN
TWO
ALGORITHMS
ON
THE
OTHER
HAND
AS
THE
NUMBER
OF
ELEMENTS
BEING
PRO
CESSED
GROWS
THE
DIFFERENCE
BETWEEN
ALGORITHMS
CAN
BE
STAGGERING
RETURNING
FOR
A
MOMENT
TO
THE
QUESTION
OF
WHY
WE
SHOULD
BE
CONCERNED
ABOUT
EFFICIENCY
CONSIDER
THE
SITUATION
IN
WHICH
YOU
CAN
SOLVE
A
PROBLEM
IN
THREE
WAYS
ONE
IS
LINEAR
ANOTHER
IS
LINEAR
LOGARITHMIC
AND
A
THIRD
IS
QUADRATIC
THE
MAGNITUDE
OF
THEIR
EFFICIENCY
FOR
A
PROBLEM
CONTAINING
O
N
NLOGN
N
LOGN
N
FIGURE
PLOT
OF
EFFECIENCY
MEASURES
CHAPTER
BASIC
CONCEPTS
ELEMENTS
SHOWS
THAT
THE
LINEAR
SOLUTION
REQUIRES
A
FRACTION
OF
A
SECOND
WHEREAS
THE
QUADRATIC
SOLUTION
REQUIRES
MINUTES
SEE
TABLE
LOOKING
AT
THE
PROBLEM
FROM
THE
OTHER
END
IF
WE
ARE
USING
A
COMPUTER
THAT
EXECUTES
A
MILLION
INSTRUCTIONS
PER
SECOND
AND
THE
LOOP
CONTAINS
INSTRUCTIONS
WE
SPEND
SECOND
FOR
EACH
ITERATION
OF
THE
LOOP
TABLE
ALSO
CONTAINS
AN
ESTIMATE
OF
THE
TIME
NEEDED
TO
SOLVE
THE
PROBLEM
GIVEN
DIFFER
ENT
EFFICIENCIES
BIG
O
ANALYSIS
EXAMPLES
TO
DEMONSTRATE
THE
CONCEPTS
WE
HAVE
BEEN
DISCUSSING
WE
EXAMINE
TWO
MORE
ALGORITHMS
ADD
AND
MULTIPLY
TWO
MATRICES
ADD
SQUARE
MATRICES
TO
ADD
TWO
SQUARE
MATRICES
WE
ADD
THEIR
CORRESPONDING
ELEMENTS
THAT
IS
WE
ADD
THE
FIRST
ELEMENT
OF
THE
FIRST
MATRIX
TO
THE
FIRST
ELEMENT
OF
THE
SECOND
MATRIX
THE
SECOND
ELEMENT
OF
THE
FIRST
MATRIX
TO
THE
SECOND
ELEMENT
OF
THE
SECOND
MATRIX
AND
SO
FORTH
OF
COURSE
THE
TWO
MATRICES
MUST
BE
THE
SAME
SIZE
THIS
CONCEPT
IS
SHOWN
IN
FIGURE
THE
PSEUDOCODE
TO
ADD
TWO
MATRICES
IS
SHOWN
IN
ALGORITHM
ALGORITHM
ADD
TWO
MATRICES
SECTION
ALGORITHM
EFFICIENCY
ALGORITHM
ANALYSIS
IN
THIS
ALGORITHM
WE
SEE
THAT
FOR
EACH
ELEMENT
IN
A
ROW
WE
ADD
ALL
OF
THE
ELEMENTS
IN
A
COLUMN
THIS
IS
THE
CLASSIC
QUADRATIC
LOOP
THE
EFFICIENCY
OF
THE
ALGORITHM
IS
THEREFORE
O
OR
O
MULTIPLY
SQUARE
MATRICES
WHEN
TWO
SQUARE
MATRICES
ARE
MULTIPLIED
WE
MUST
MULTIPLY
EACH
ELEMENT
IN
A
ROW
OF
THE
FIRST
MATRIX
BY
ITS
CORRESPONDING
ELEMENT
IN
A
COLUMN
OF
THE
SECOND
MATRIX
THE
VALUE
IN
THE
RESULTING
MATRIX
IS
THEN
THE
SUM
OF
THE
PRODUCTS
FOR
EXAMPLE
GIVEN
THE
MATRIX
IN
OUR
ADDITION
EXAMPLE
ABOVE
THE
FIRST
ELEMENT
IN
THE
RESULTING
MATRIX
THAT
IS
THE
ELEMENT
AT
IS
THE
SUM
OF
THE
PRODUCTS
OBTAINED
BY
MULTIPLYING
EACH
ELEMENT
IN
THE
FIRST
ROW
ROW
BY
ITS
CORRESPONDING
ELEMENT
IN
THE
FIRST
COLUMN
COLUMN
THE
VALUE
OF
THE
ELEMENT
AT
INDEX
LOCATION
IS
THE
SUM
OF
THE
PRODUCTS
OF
EACH
ELEMENT
IN
THE
FIRST
ROW
AGAIN
ROW
MULTIPLIED
BY
ITS
CORRESPONDING
ELEMENT
IN
THE
SECOND
COLUMN
COLUMN
THE
VALUE
OF
THE
ELEMENT
AT
INDEX
LOCATION
IS
THE
SUM
OF
THE
PRODUCTS
OF
EACH
ELEMENT
IN
THE
SECOND
ROW
MULTIPLIED
BY
THE
CORRESPONDING
ELEMENTS
IN
THE
THIRD
COLUMN
ONCE
AGAIN
THE
SQUARE
MATRICES
MUST
BE
THE
SAME
SIZE
FIGURE
GRAPHI
CALLY
SHOWS
HOW
TWO
MATRICES
ARE
MULTIPLIED
GENERALIZING
THIS
CONCEPT
WE
SEE
THAT
THE
PSEUDOCODE
USED
FOR
MULTIPLYING
MATRICES
IS
PROVIDED
IN
ALGORITHM
ALGORITHM
MULTIPLY
TWO
MATRICES
CONTINUED
CHAPTER
BASIC
CONCEPTS
ALGORITHM
MULTIPLY
TWO
MATRICES
CONTINUED
ALGORITHM
ANALYSIS
IN
THIS
ALGORITHM
WE
SEE
THREE
NESTED
LOOPS
BECAUSE
EACH
LOOP
STARTS
AT
THE
FIRST
ELE
MENT
WE
HAVE
A
CUBIC
LOOP
LOOPS
WITH
THREE
NESTED
LOOPS
HAVE
A
BIG
O
EFFICIENCY
OF
O
OR
O
IT
IS
ALSO
POSSIBLE
TO
MULTIPLY
TWO
MATRICES
IF
THE
NUMBER
OF
ROWS
IN
THE
FIRST
MATRIX
IS
THE
SAME
AS
THE
NUMBER
OF
COLUMNS
IN
THE
SECOND
WE
LEAVE
THE
SOLUTION
TO
THIS
PROB
LEM
AS
AN
EXERCISE
EXERCISE
FIGURE
MULTIPLY
MATRICES
SECTION
SUMMARY
KEY
TERMS
ABSTRACT
DATA
TYPE
ADT
ALGORITHMICS
ATOMIC
DATA
BIG
O
NOTATION
COMPOSITE
DATA
CONSTRUCT
DATA
DATA
STRUCTURE
DATA
TYPE
DEPENDENT
QUADRATIC
LOOP
EMPTY
LIST
ENCAPSULATION
GENERIC
CODE
INTELLIGENT
DATA
NAMES
LINEAR
LOOP
LINK
LINKED
LIST
LOGARITHMIC
LOOP
LOOP
MODULAR
PROGRAMMING
NESTED
LOOP
NODE
POINTER
TO
VOID
POINTER
TO
FUNCTION
PSEUDOCODE
QUADRATIC
LOOP
RETURN
CONDITION
SELF
REFERENTIAL
SELECTION
STATEMENT
SEQUENCE
SPAGHETTI
CODE
STRUCTURED
PROGRAMMING
SUMMARY
ONE
OF
THE
MOST
COMMON
TOOLS
USED
TO
DEFINE
ALGORITHMS
IS
PSEUDOCODE
PSEUDOCODE
IS
AN
ENGLISH
LIKE
REPRESENTATION
OF
THE
CODE
REQUIRED
FOR
AN
ALGORITHM
IT
IS
PART
ENGLISH
PART
STRUCTURED
CODE
ATOMIC
DATA
ARE
DATA
THAT
ARE
SINGLE
NONDECOMPOSABLE
ENTITIES
ATOMIC
DATA
TYPES
ARE
DEFINED
BY
A
SET
OF
VALUES
AND
A
SET
OF
OPERATIONS
THAT
ACT
ON
THE
VALUES
A
DATA
STRUCTURE
IS
AN
AGGREGATION
OF
ATOMIC
AND
COMPOSITE
DATA
WITH
A
DEFINED
RELATIONSHIP
AN
ABSTRACT
DATA
TYPE
ADT
IS
A
DATA
DECLARATION
PACKAGED
TOGETHER
WITH
THE
OPERATIONS
THAT
ARE
MEANINGFUL
FOR
THE
DATA
TYPE
THERE
ARE
TWO
BASIC
STRUCTURES
USED
TO
IMPLEMENT
AN
ADT
LIST
ARRAYS
AND
LINKED
LISTS
IN
AN
ARRAY
THE
SEQUENTIALITY
OF
A
LIST
IS
PRESERVED
BY
THE
ORDERED
STRUCTURE
OF
ELEMENTS
ALTHOUGH
SEARCHING
AN
ARRAY
IS
VERY
EFFICIENT
ADDING
AND
DELETING
IS
NOT
ALTHOUGH
ADDING
AND
DELETING
IN
A
LINKED
LIST
IS
EFFICIENT
SEARCHING
IS
NOT
BECAUSE
WE
MUST
USE
A
SEQUENTIAL
SEARCH
IN
A
LINKED
LIST
EACH
ELEMENT
CONTAINS
THE
LOCATION
OF
THE
NEXT
ELEMENT
OR
ELEMENTS
CHAPTER
BASIC
CONCEPTS
ABSTRACT
DATA
TYPES
REQUIRE
GENERIC
ALGORITHMS
WHICH
ALLOW
AN
ALGORITHM
TO
BE
USED
WITH
MULTIPLE
DATA
TYPES
THE
C
LANGUAGE
HAS
TWO
FEATURES
THAT
ALLOW
THE
CREATION
OF
GENERIC
CODE
POINTER
TO
VOID
AND
POINTER
TO
FUNCTION
A
VOID
POINTER
IS
A
GENERIC
POINTER
THAT
CAN
BE
USED
TO
REPRESENT
ANY
DATA
TYPE
A
POINTER
TO
VOID
CANNOT
BE
DEREFERENCED
WHICH
MEANS
THAT
NONASSIGN
MENT
REFERENCES
TO
A
VOID
POINTER
MUST
BE
CAST
TO
THE
CORRECT
TYPE
THE
NAME
OF
A
FUNCTION
IS
A
POINTER
CONSTANT
TO
THE
FIRST
BYTE
OF
A
FUNCTION
WE
CAN
USE
POINTER
TO
FUNCTION
AS
A
PLACE
HOLDER
FOR
THE
NAME
OF
A
FUNC
TION
IN
A
PARAMETER
LIST
OF
A
GENERIC
FUNCTION
ALGORITHM
EFFICIENCY
IS
GENERALLY
DEFINED
AS
A
FUNCTION
OF
THE
NUMBER
OF
ELEMENTS
BEING
PROCESSED
AND
THE
TYPE
OF
LOOP
BEING
USED
THE
EFFICIENCY
OF
A
LOGARITHMIC
LOOP
IS
F
N
LOGN
THE
EFFICIENCY
OF
A
LINEAR
LOOP
IS
F
N
N
THE
EFFICIENCY
OF
A
LINEAR
LOGARITHMIC
LOOP
IS
F
N
N
LOGN
THE
EFFICIENCY
OF
A
QUADRATIC
LOOP
IS
F
N
THE
EFFICIENCY
OF
A
DEPENDENT
QUADRATIC
LOOP
IS
F
N
N
N
THE
EFFICIENCY
OF
A
CUBIC
LOOP
IS
F
N
THE
SIMPLIFICATION
OF
EFFICIENCY
IS
KNOWN
AS
BIG
O
NOTATION
THE
SEVEN
STANDARD
MEASURES
OF
EFFICIENCIES
ARE
O
LOGN
O
N
O
N
LOGN
O
O
NK
O
CN
AND
O
N
PRACTICE
SETS
EXERCISES
STRUCTURE
CHARTS
AND
PSEUDOCODE
ARE
TWO
DIFFERENT
DESIGN
TOOLS
HOW
DO
THEY
DIFFER
AND
HOW
ARE
THEY
SIMILAR
USING
DIFFERENT
SYNTACTICAL
CONSTRUCTS
WRITE
AT
LEAST
TWO
PSEUDOCODE
STATE
MENTS
TO
ADD
TO
A
NUMBER
FOR
EXAMPLE
ANY
OF
THE
FOLLOWING
STATEMENTS
COULD
BE
USED
TO
GET
DATA
FROM
A
FILE
EXPLAIN
HOW
AN
ALGORITHM
IN
AN
APPLICATION
PROGRAM
DIFFERS
FROM
AN
ALGORITHM
IN
AN
ABSTRACT
DATA
TYPE
IDENTIFY
THE
ATOMIC
DATA
TYPES
FOR
YOUR
PRIMARY
PROGRAMMING
LANGUAGE
SECTION
PRACTICE
SETS
IDENTIFY
THE
COMPOSITE
DATA
TYPES
FOR
YOUR
PRIMARY
PROGRAMMING
LANGUAGE
REORDER
THE
FOLLOWING
EFFICIENCIES
FROM
SMALLEST
TO
LARGEST
A
B
N
C
D
E
NLOG
N
REORDER
THE
FOLLOWING
EFFICIENCIES
FROM
SMALLEST
TO
LARGEST
A
NLOG
N
B
N
C
D
DETERMINE
THE
BIG
O
NOTATION
FOR
THE
FOLLOWING
A
B
N
C
NLOG
N
D
CALCULATE
THE
RUN
TIME
EFFICIENCY
OF
THE
FOLLOWING
PROGRAM
SEGMENT
FOR
I
I
N
I
PRINTF
D
I
CALCULATE
THE
RUN
TIME
EFFICIENCY
OF
THE
FOLLOWING
PROGRAM
SEGMENT
FOR
I
I
N
I
FOR
J
J
N
J
FOR
K
K
N
K
PRINT
D
D
D
N
I
J
K
IF
THE
ALGORITHM
DOIT
HAS
AN
EFFICIENCY
FACTOR
OF
CALCULATE
THE
RUN
TIME
EFFICIENCY
OF
THE
FOLLOWING
PROGRAM
SEGMENT
FOR
I
I
N
I
DOIT
IF
THE
EFFICIENCY
OF
THE
ALGORITHM
DOIT
CAN
BE
EXPRESSED
AS
O
N
CAL
CULATE
THE
EFFICIENCY
OF
THE
FOLLOWING
PROGRAM
SEGMENT
FOR
I
I
N
I
FOR
J
J
N
J
DOIT
IF
THE
EFFICIENCY
OF
THE
ALGORITHM
DOIT
CAN
BE
EXPRESSED
AS
O
N
CAL
CULATE
THE
EFFICIENCY
OF
THE
FOLLOWING
PROGRAM
SEGMENT
FOR
I
I
N
I
DOIT
GIVEN
THAT
THE
EFFICIENCY
OF
AN
ALGORITHM
IS
IF
A
STEP
IN
THIS
ALGORITHM
TAKES
NANOSECOND
SECONDS
HOW
LONG
DOES
IT
TAKE
THE
ALGORITHM
TO
PROCESS
AN
INPUT
OF
SIZE
CHAPTER
BASIC
CONCEPTS
GIVEN
THAT
THE
EFFICIENCY
OF
AN
ALGORITHM
IS
IF
A
STEP
IN
THIS
ALGORITHM
TAKES
NANOSECOND
SECONDS
HOW
LONG
DOES
IT
TAKE
THE
ALGORITHM
TO
PROCESS
AN
INPUT
OF
SIZE
GIVEN
THAT
THE
EFFICIENCY
OF
AN
ALGORITHM
IS
N
IF
A
STEP
IN
THIS
ALGO
RITHM
TAKES
NANOSECOND
SECONDS
HOW
LONG
DOES
IT
TAKE
THE
ALGO
RITHM
TO
PROCESS
AN
INPUT
OF
SIZE
AN
ALGORITHM
PROCESSES
A
GIVEN
INPUT
OF
SIZE
N
IF
N
IS
THE
RUN
TIME
IS
MILLISECONDS
IF
N
IS
THE
RUN
TIME
IS
MILLISECONDS
WHAT
IS
THE
EFFICIENCY
WHAT
IS
THE
BIG
O
NOTATION
AN
ALGORITHM
PROCESSES
A
GIVEN
INPUT
OF
SIZE
N
IF
N
IS
THE
RUN
TIME
IS
MILLISECONDS
IF
N
IS
THE
RUN
TIME
IS
MILLISECONDS
WHAT
IS
THE
EFFICIENCY
WHAT
IS
THE
BIG
O
NOTATION
AN
ALGORITHM
PROCESSES
A
GIVEN
INPUT
OF
SIZE
N
IF
N
IS
THE
RUN
TIME
IS
MILLISECONDS
IF
N
IS
THE
RUN
TIME
IS
MILLISECONDS
WHAT
IS
THE
EFFICIENCY
WHAT
IS
THE
BIG
O
NOTATION
THREE
STUDENTS
WROTE
ALGORITHMS
FOR
THE
SAME
PROBLEM
THEY
TESTED
THE
THREE
ALGORITHMS
WITH
TWO
SETS
OF
DATA
AS
SHOWN
BELOW
A
CASE
N
RUN
TIME
FOR
STUDENT
RUN
TIME
FOR
STUDENT
RUN
TIME
FOR
STUDENT
WHAT
IS
THE
EFFICIENCY
FOR
EACH
ALGORITHM
WHICH
IS
THE
BEST
WHICH
IS
THE
WORST
WHAT
IS
THE
MINIMUM
NUMBER
OF
TEST
CASES
N
IN
WHICH
THE
BEST
ALGORITHM
HAS
THE
BEST
RUN
TIME
WE
CAN
MULTIPLY
TWO
MATRICES
IF
THE
NUMBER
OF
COLUMNS
IN
THE
FIRST
MATRIX
IS
THE
SAME
AS
THE
NUMBER
OF
ROWS
IN
THE
SECOND
WRITE
AN
ALGORITHM
THAT
MULTIPLIES
AN
M
N
MATRIX
BY
A
N
K
MATRIX
WRITE
A
COMPARE
FUNCTION
SEE
PROGRAM
TO
COMPARE
TWO
STRINGS
PROBLEMS
WRITE
A
PSEUDOCODE
ALGORITHM
FOR
DIALING
A
PHONE
NUMBER
WRITE
A
PSEUDOCODE
ALGORITHM
FOR
GIVING
ALL
EMPLOYEES
IN
A
COMPANY
A
COST
OF
LIVING
WAGE
INCREASE
OF
ASSUME
THAT
THE
PAYROLL
FILE
INCLUDES
ALL
CURRENT
EMPLOYEES
SECTION
PRACTICE
SETS
WRITE
A
LANGUAGE
SPECIFIC
IMPLEMENTATION
FOR
THE
PSEUDOCODE
ALGORITHM
IN
PROBLEM
WRITE
A
PSEUDOCODE
DEFINITION
FOR
A
TEXTBOOK
DATA
STRUCTURE
WRITE
A
PSEUDOCODE
DEFINITION
FOR
A
STUDENT
DATA
STRUCTURE
PROJECTS
YOUR
COLLEGE
BOOKSTORE
HAS
HIRED
YOU
AS
A
SUMMER
INTERN
TO
DESIGN
A
NEW
TEXTBOOK
INVENTORY
SYSTEM
IT
IS
TO
INCLUDE
THE
FOLLOWING
MAJOR
PROCESSES
A
ORDERING
TEXTBOOKS
B
RECEIVING
TEXTBOOKS
C
DETERMINING
RETAIL
PRICE
D
PRICING
USED
TEXTBOOKS
E
DETERMINING
QUANTITY
ON
HAND
F
RECORDING
TEXTBOOK
SALES
G
RECORDING
TEXTBOOK
RETURNS
WRITE
THE
ABSTRACT
DATA
TYPE
ALGORITHM
HEADERS
FOR
THE
INVENTORY
SYSTEM
EACH
HEADER
SHOULD
INCLUDE
NAME
PARAMETERS
PURPOSE
PRECONDITIONS
POSTCONDITIONS
AND
RETURN
VALUE
TYPES
YOU
MAY
ADD
ADDITIONAL
ALGORITHMS
AS
REQUIRED
BY
YOUR
ANALYSIS
WRITE
THE
PSEUDOCODE
FOR
AN
ALGORITHM
THAT
CONVERTS
A
NUMERIC
SCORE
TO
A
LETTER
GRADE
THE
GRADING
SCALE
IS
THE
TYPICAL
ABSOLUTE
SCALE
IN
WHICH
OR
MORE
IS
AN
A
TO
IS
A
B
TO
IS
A
C
AND
TO
IS
A
D
ANYTHING
BELOW
IS
AN
F
WRITE
THE
PSEUDOCODE
FOR
AN
ALGORITHM
THAT
RECEIVES
AN
INTEGER
AND
THEN
PRINTS
THE
NUMBER
OF
DIGITS
IN
THE
INTEGER
AND
THE
SUM
OF
THE
DIGITS
FOR
EXAMPLE
GIVEN
IT
WOULD
PRINT
THAT
THERE
ARE
DIGITS
WITH
A
SUM
OF
WRITE
THE
PSEUDOCODE
FOR
A
PROGRAM
THAT
BUILDS
A
FREQUENCY
ARRAY
FOR
DATA
VALUES
IN
THE
RANGE
TO
AND
THEN
PRINTS
THEIR
HISTOGRAM
THE
DATA
ARE
TO
BE
READ
FROM
A
FILE
THE
DESIGN
FOR
THE
PROGRAM
IS
SHOWN
IN
FIGURE
FIGURE
DESIGN
FOR
FREQUENCY
HISTOGRAM
PROGRAM
CHAPTER
BASIC
CONCEPTS
EACH
OF
THE
SUBALGORITHMS
IS
DESCRIBED
BELOW
A
THE
GETDATA
ALGORITHM
READS
THE
FILE
AND
STORES
THE
DATA
IN
AN
ARRAY
B
THE
PRINTDATA
ALGORITHM
PRINTS
THE
DATA
IN
THE
ARRAY
C
THE
MAKEFREQUENCY
ALGORITHM
EXAMINES
THE
DATA
IN
THE
ARRAY
ONE
ELE
MENT
AT
A
TIME
AND
ADDS
TO
THE
CORRESPONDING
ELEMENT
IN
A
FREQUENCY
ARRAY
BASED
ON
THE
DATA
VALUE
D
THE
MAKEHISTOGRAM
ALGORITHM
PRINTS
OUT
A
VERTICAL
HISTOGRAM
USING
ASTERISKS
FOR
EACH
OCCURRENCE
OF
AN
ELEMENT
FOR
EXAMPLE
IF
THERE
WERE
FIVE
VALUE
AND
EIGHT
VALUE
IN
THE
DATA
IT
WOULD
PRINT
REWRITE
PROGRAM
TO
CREATE
A
LIST
OF
NODES
EACH
NODE
CONSISTS
OF
TWO
FIELDS
THE
FIRST
FIELD
IS
A
POINTER
TO
A
STRUCTURE
THAT
CONTAINS
A
STUDENT
ID
INTEGER
AND
A
GRADE
POINT
AVERAGE
FLOAT
THE
SECOND
FIELD
IS
A
LINK
THE
DATA
ARE
TO
BE
READ
FROM
A
TEXT
FILE
THEN
WRITE
A
PROGRAM
TO
READ
A
FILE
OF
AT
LEAST
STUDENTS
AND
TEST
THE
FUNCTION
YOU
WROTE
YOU
WILL
ALSO
NEED
TO
USE
THE
GENERIC
COMPARE
CODE
IN
PROGRAM
IN
YOUR
PROGRAM
CATALOGUE
DESCRIPTION
CONTINUES
THE
DEVELOPMENT
OF
PROGRAMMING
SKILLS
STARTED
IN
CMPT
WITH
AN
EMPHASIS
ON
OBJECT
ORIENTED
PROGRAMMING
DATA
STRUCTURES
FOR
THE
STORAGE
AND
EFFICIENT
RETRIEVAL
OF
INFORMATION
WILL
BE
STUDIED
AND
ANALYZED
IN
PARTICULAR
STACKS
QUEUES
LINKED
LISTS
AND
SIMPLE
BINARY
TREES
EXAMPLES
AND
EXERCISES
WILL
BE
DRAWN
FROM
ENGINEERING
APPLICATIONS
AND
NUMERICAL
METHODS
PREREQUISITE
CMPT
OR
CMPT
WITH
GRADE
AT
LEAST
COURSE
WEBSITE
ALL
COURSE
RELEVANT
INFORMATION
ANNOUNCEMENTS
COURSE
MATERIALS
ASSIGNMENTS
EXAM
SCHEDULES
ETC
WILL
BE
ON
THE
MOODLE
WEBSITE
HTTP
MOODLE
CS
USASK
CA
EACH
STUDENT
IS
RESPONSIBLE
FOR
CHECKING
THIS
WEBSITE
REGULARLY
IT
IS
ALSO
YOUR
RESPONSIBILITY
TO
CHECK
YOUR
PAWS
EMAIL
ACCOUNT
REGULARLY
COURSE
OVERVIEW
THIS
COURSE
INTRODUCES
THE
BASIC
CONCEPTS
OF
COMPUTER
SCIENCE
AND
OBJECT
ORIENTED
SOFTWARE
DEVELOPMENT
YOU
WILL
LEARN
ABOUT
FUNDAMENTAL
DATA
STRUCTURES
FOR
ORGANIZING
DATA
INCLUDING
LISTS
STACKS
QUEUES
TREES
AND
HASH
TABLES
AND
ASSOCIATED
ALGORITHMS
AS
WELL
AS
THEIR
TIME
AND
SPACE
EFFICIENCY
THE
COURSE
WILL
EMPHASIZE
ABSTRACT
DATA
TYPES
FOR
THE
DESIGN
OF
DATA
STORAGE
MECHANISMS
THAT
CAN
BE
REUSED
AND
REVISED
YOU
WILL
LEARN
THE
BASICS
OF
OBJECT
ORIENTED
PROGRAMMING
AS
A
NATURAL
TECHNOLOGICAL
EXTENSION
OF
ABSTRACT
DATA
TYPES
AS
THE
PRACTICAL
PART
OF
THE
COURSE
YOU
WILL
DEVELOP
A
FAMILIARITY
WITH
MEMORY
MANAGEMENT
INCLUDING
STATIC
AND
DYNAMIC
MEMORY
ALLOCATION
AND
POINTERS
THROUGH
HANDS
ON
IMPLEMENTATIONS
AN
UNDERLYING
THEME
OF
THE
COURSE
IS
FOR
STUDENTS
TO
GAIN
PROGRAMMING
AND
DEBUGGING
SKILLS
THE
CON
CEPTUAL
MATERIAL
COVERED
IN
THE
COURSE
IS
ACTUALLY
FAIRLY
STRAIGHTFORWARD
AND
CAN
BE
MASTERED
WITH
A
MODERATE
AMOUNT
OF
STUDY
THE
REAL
CHALLENGE
IN
THIS
COURSE
IS
TO
DEVELOP
THE
PROGRAMMING
SKILLS
NEEDED
TO
COMPLETE
THE
HOMEWORK
STUDENTS
SHOULD
PRACTICE
TIME
MANAGEMENT
PROBLEM
SOLVING
STRATEGIES
AND
CRITICAL
ANALYTICAL
AND
SCIENTIFIC
THINKING
LEARNING
OUTCOMES
BY
THE
END
OF
THIS
COURSE
YOUR
ARE
EXPECTED
TO
BE
ABLE
TO
BE
PROFICIENT
IN
FUNDAMENTALS
OF
PROCEDURAL
PROGRAMMING
SPECIFICALLY
PROGRAMMING
IN
THE
PROCEDURAL
SUBSET
OF
C
DESIGN
ALGORITHMS
USING
PSEUDOCODE
AND
ANALYZE
ALGORITHMS
WRITTEN
IN
PSEUDOCODE
ANALYZE
TIME
AND
SPACE
COMPLEXITY
OF
ALGORITHMS
AND
TO
COMPARE
AND
EVALUATE
ALGORITHMS
AND
DATA
STRUCTURES
UNDERSTAND
AND
USE
DYNAMIC
MEMORY
AND
STATIC
MEMORY
IN
PROCEDURAL
PROGRAMMING
DESCRIBE
AND
APPLY
THE
TECHNIQUES
ASSOCIATED
WITH
REFERENCES
POINTERS
AND
ADDRESSES
EXPLAIN
THE
CONCEPTS
BEHIND
THE
USE
OF
DATA
STRUCTURES
AND
DETERMINE
THE
APPROPRIATENESS
OF
DIFFERENT
DATA
STRUCTURES
FOR
VARIOUS
PURPOSES
DESIGN
IMPLEMENT
AND
APPLY
SPECIFIC
DATA
TYPES
LINKED
LISTS
ARRAYS
TREES
BINARY
SEARCH
TREES
AND
HASH
TABLE
DATA
STRUCTURES
EXPLAIN
THE
CONCEPT
OF
ABSTRACT
DATA
TYPES
IN
TERMS
OF
INTERFACE
AND
ENCAPSULATION
DESIGN
IMPLEMENT
AND
APPLY
ABSTRACT
DATA
TYPES
FOR
LINKED
LISTS
ARRAYS
TREES
BINARY
SEARCH
TREES
AND
HASH
TABLE
DATA
STRUCTURES
APPLY
RECURSION
TO
COMPUTATIONAL
TASKS
INVOLVING
DATA
STRUCTURES
DESCRIBE
AND
APPLY
THE
FUNDAMENTALS
OF
OBJECT
ORIENTED
PROGRAMMING
IN
C
SPECIFICALLY
AS
AN
EXTENSION
OF
THE
ADT
CONCEPT
RESOURCES
TEXTBOOK
INFORMATION
THERE
ARE
NO
REQUIRED
TEXTBOOKS
HOWEVER
WE
PROVIDE
THE
FOLLOWING
RECOMMENDED
REFERENCES
RICHARD
F
GILBERG
AND
BEHROUZ
A
FOROUZAN
DATA
STRUCTURES
A
PSEUDOCODE
APPROACH
IN
C
COURSE
TECH
NOLOGY
THOMPSON
K
N
KING
C
PROGRAMMING
A
MODERN
APPROACH
W
W
NORTON
COMPANY
SUBSTANTIAL
LECTURE
NOTES
WILL
BE
PROVIDED
ON
THE
COURSE
WEBPAGE
HOWEVER
STUDENTS
SHOULD
NOT
RELY
SOLELY
ON
THE
LECTURE
NOTES
FOR
THE
COURSE
GRADING
SCHEME
THE
GRADING
SCHEME
FOR
THIS
COURSE
APPEARS
IN
THE
FOLLOWING
TABLE
ASSIGNMENTS
TEN
TUTORIAL
EXERCISES
TEN
MIDTERM
EXAM
FEBRUARY
EVENING
FINAL
EXAM
APRIL
TOTAL
ASSIGNMENTS
SEE
THE
SCHEDULE
ON
PAGE
FOR
THE
DUE
DATE
OF
EACH
ASSIGNMENT
THERE
WILL
BE
TEN
ASSIGNMENTS
IN
THIS
COURSE
ONE
APPROXIMATELY
EVERY
WEEK
ASSIGNMENTS
WILL
CONSIST
OF
TWO
PORTIONS
WRITTEN
QUESTIONS
THAT
REQUIRE
WRITTEN
ANSWERS
PROGRAMMING
QUESTIONS
WHICH
REQUIRE
YOU
TO
WRITE
COMPUTER
PROGRAMS
SUBMISSION
INSTRUCTIONS
WILL
BE
INCLUDED
WITH
EACH
ASSIGNMENT
DESCRIPTION
GENERALLY
YOU
WILL
UPLOAD
YOUR
SOLUTIONS
AS
FILES
TO
MOODLE
UNLESS
YOU
ARE
INSTRUCTED
OTHERWISE
GENERALLY
TEXT
FILES
ARE
PREFERRED
TO
DOCUMENTS
THAT
INCLUDE
FORMATTING
E
G
MSWORD
DOCUMENTS
A
DOCUMENT
THAT
CANNOT
BE
OPENED
WILL
RECEIVE
A
GRADE
OF
ZERO
DO
NOT
ASSUME
THE
MARKERS
WILL
TAKE
THE
TIME
TO
OPEN
YOUR
FILE
IF
IT
IS
IN
A
FILE
FORMAT
THAT
IS
NOT
STANDARD
NOTE
ALL
COMPUTER
PROGRAMS
MUST
BE
WRITTEN
IN
C
AND
MUST
COMPILE
USING
THE
GNU
C
COMPILER
G
UNDER
LINUX
THE
STANDARD
WILL
BE
THE
TUXWORLD
USASK
CA
CLUSTER
OF
MACHINES
WHICH
IS
THE
SAME
VERSION
OF
GNU
C
AS
FOUND
ON
THE
LINUX
DESKTOPS
IN
THE
LAB
TUTORIALS
TUTORIALS
HAVE
ASSOCIATED
EXERCISES
WHICH
WE
EXPECT
YOU
TO
DO
FOR
THE
SKILLS
YOU
LEARN
BY
DOING
THEM
YOU
ARE
EXPECTED
TO
SUBMIT
YOUR
TUTORIAL
EXERCISES
WEEKLY
ALONG
WITH
YOUR
ASSIGNMENT
SOLUTIONS
THESE
EXERCISES
WILL
BE
GRADED
AND
WILL
MAKE
UP
OF
YOUR
TOTAL
COURSE
GRADE
YOU
SHOULD
EXPECT
TO
COMPLETE
THESE
EXERCISES
IN
THE
TIME
ALLOTTED
FOR
TUTORIALS
AND
SHOULD
NOT
REQUIRE
ANY
TIME
OUTSIDE
THE
TUTORIALS
MID
TERM
EXAMINATION
THE
MIDTERM
EXAM
IS
SCHEDULED
FOR
THE
EVENING
OF
FEBRUARY
LOCATION
TBA
IT
WILL
BE
HELD
IN
COMMON
WITH
CMPT
AND
BOTH
LECTURE
SECTIONS
OF
CMPT
THERE
ARE
TWO
SEATINGS
THAT
STUDENTS
CAN
CHOOSE
FROM
TO
MEET
THEIR
SCHEDULE
TIME
NOTE
STUDENTS
CANNOT
LEAVE
EARLY
BEFORE
STUDENTS
WILL
NOT
BE
ALLOWED
TO
ENTER
LATE
AFTER
WE
LL
USE
MOODLE
TO
SIGN
UP
FOR
THE
MIDTERMS
STARTING
ABOUT
WEEKS
BEFORE
THE
RULES
ABOUT
LEAVING
EARLY
AND
ARRIVING
LATE
ARE
TO
ENSURE
FAIRNESS
IN
THE
EXAMINATION
THE
MID
TERM
EXAMINATION
IS
WRITTEN
CLOSED
BOOK
ONLY
BRING
WATER
YOUR
STUDENT
CARD
AND
WRITING
INSTRUMENTS
THE
MID
TERM
EXAMINATION
IS
INTENDED
TO
PROVIDE
PRACTICE
FOR
THE
FINAL
EXAM
AND
TO
PROVIDE
FEEDBACK
TO
STUDENTS
REGARDING
THEIR
CURRENT
PERFORMANCE
PLEASE
SEE
THE
SECTION
ON
POLICIES
FOR
IMPORTANT
INFORMATION
CONCERNING
MISSED
MIDTERMS
AND
FINAL
EXAMS
IN
THE
CASE
OF
A
MISSED
MIDTERM
THE
INSTRUCTOR
IN
CONSULTATION
WITH
THE
STUDENT
WILL
DETERMINE
HOW
THE
MISSED
WORK
WILL
BE
COMPENSATED
FOR
ONE
POTENTIAL
ALTERNATIVE
IS
TRANSFERRING
THE
WEIGHT
OF
THE
MIDTERM
ONTO
THE
FINAL
EXAMINATION
FINAL
EXAMINATION
THE
FINAL
EXAMINATION
COMMON
TO
CMPT
AND
BOTH
LECTURE
SECTIONS
OF
CMPT
WILL
BE
SCHEDULED
BY
CENTRAL
TIMETABLING
TO
OCCUR
DURING
THE
USUAL
FINAL
EXAMINATION
INTERVAL
IT
WILL
BE
THREE
HOURS
LONG
WRITTEN
CLOSED
BOOK
BRING
ONLY
WATER
YOUR
STUDENT
CARD
AND
WRITING
INSTRUMENTS
PLEASE
SEE
THE
SECTION
ON
POLICIES
FOR
IMPORTANT
INFORMATION
CONCERNING
MISSED
MIDTERMS
AND
FINAL
EXAMS
ATTENDANCE
EXPECTATIONS
WE
EXPECT
ATTENDANCE
IN
LECTURE
AND
IN
TUTORIAL
WITH
REASONABLE
ALLOWANCES
FOR
ILLNESS
AND
UNFORESEEN
LIFE
EVENTS
IN
OTHER
WORDS
TREAT
CMPT
AS
IF
YOU
WERE
AN
INTERN
AT
A
REAL
COMPANY
YOUR
BOSSES
THE
INSTRUCTORS
AND
TEACHING
ASSISTANTS
EXPECT
YOU
TO
SHOW
UP
ON
TIME
TO
ALL
LECTURES
AND
TUTORIALS
MASTER
YOUR
SKILLS
DO
YOUR
SHARE
OF
THE
WORK
AND
BEHAVE
PROFESSIONALLY
THERE
ARE
ALMOST
NO
CONSEQUENCES
FOR
MISSING
CLASS
OR
TUTORIAL
APART
FROM
THE
OPPORTUNITY
COST
OF
PAYING
TUITION
AND
NOT
BEING
PRESENT
TO
DISCUSS
COURSE
MATERIAL
WITH
INSTRUCTORS
TUTORIALS
AND
HELP
SESSIONS
TUTORIALS
TUTORIALS
IN
A
LABORATORY
SETTING
ARE
MANDATORY
AND
INCLUDE
NEW
MATERIAL
NOT
PRESENTED
IN
CLASS
LECTURES
EMPHASIZE
THE
DATA
ORGANIZATION
CONCEPTS
USING
PSEUDOCODE
TUTORIALS
FOCUS
ON
HOW
TO
IMPLEMENT
IN
C
THE
CONCEPTS
STUDIED
IN
LECTURE
MATERIAL
PRESENTED
IN
TUTORIAL
IS
EXAMINABLE
IF
YOU
MISS
A
TUTORIAL
SECTION
YOU
MAY
TRY
TO
ATTEND
ANOTHER
SECTION
DURING
THAT
WEEK
BUT
THERE
IS
CONSIDERABLE
RISK
YOU
WILL
NOT
BE
ABLE
TO
FIND
A
SEAT
SECTION
DAY
TIME
LOCATION
LEADER
MONDAY
SPINKS
MATTHEW
MILLER
TUESDAY
SPINKS
MATTHEW
MILLER
HELP
SESSIONS
OBSTACLES
TO
PROGRESS
AND
COMPLETION
OF
ASSIGNMENTS
CAN
SOMETIMES
BE
PART
OF
THE
HOMEWORK
I
E
SOMETHING
WE
WANT
YOU
TO
THINK
ABOUT
CAREFULLY
AND
SOMETIMES
BEYOND
THE
SCOPE
OF
THE
COURSE
I
E
A
PROBLEM
THAT
YOU
CAN
T
REALLY
BE
EXPECTED
TO
MANAGE
IN
FIRST
YEAR
AND
IT
CAN
BE
NEARLY
IMPOSSIBLE
TO
TELL
THE
DIFFERENCE
WITHOUT
SOME
ADVICE
FROM
A
TA
OR
INSTRUCTOR
THERE
ARE
SEVERAL
HELP
SESSIONS
IN
THE
SPINKS
COMPUTER
LAB
THAT
ARE
SPECIFICALLY
FOR
CMPT
STUDENTS
THE
TAS
ARE
ALL
PREPARED
FOR
THE
ASSIGNMENTS
AND
LAB
QUESTIONS
WE
HIGHLY
RECOMMEND
YOU
TO
WORK
IN
THE
COMPUTER
LAB
BECAUSE
IT
IS
VERY
HELPFUL
IF
YOU
CAN
GET
HELP
WHEN
YOU
HAVE
DIFFICULTIES
THE
SCHEDULE
WILL
BE
ANNOUNCED
IN
THE
FIRST
TWO
WEEKS
OF
THE
TERM
ON
MOODLE
LECTURE
TUTORIAL
SCHEDULE
AND
TOPICS
THE
FOLLOWING
SCHEDULE
IS
SUBJECT
TO
MINOR
ADJUSTMENTS
THE
TOPICS
MAY
SHIFT
A
BIT
BUT
DUE
DATES
WILL
NOT
DATE
LECTURE
TOPIC
TUTORIAL
TOPIC
WEEK
JAN
FIRST
DAY
OF
CLASSES
TOPIC
INTRODUCTION
TOPIC
SOFTWARE
DESIGN
TOPIC
ALGORITHM
ANALYSIS
NO
TUTORIALS
THIS
WEEK
WEEK
CMPT
TUTORIALS
START
THIS
WEEK
TOPIC
ALGORITHM
ANALYSIS
TOPIC
POINTERS
AND
REFERENCES
TUT
THE
UNIX
COMMAND
LINE
AND
THE
COM
PILER
ASSIGNMENT
DUE
ON
JAN
AT
PSEUDOCODE
SOFTWARE
DESIGN
ALGORITHM
COMPLEXITY
LAST
DAY
FOR
CHANGING
REGISTRATION
WEEK
TOPIC
POINTERS
AND
REFERENCES
TOPIC
MEMORY
TUT
DYNAMIC
MEMORY
POINTERS
REFS
AR
RAYS
AND
RECORDS
ASSIGNMENT
DUE
ON
JAN
AT
POINTERS
REFERENCES
C
STRINGS
ARRAYS
WEEK
TOPIC
ABSTRACT
DATA
TYPES
TOPIC
LISTS
TUT
MULTIPLE
FILE
COMPILATION
ASSIGNMENT
DUE
ON
JAN
AT
ADTS
MEMORY
REFERENCES
WEEK
FEB
TOPIC
LISTS
TOPIC
LIST
TRAVERSAL
TUT
C
STRINGS
AND
ARRAYS
AS
POINTERS
ASSIGNMENT
DUE
ON
FEB
AT
LISTS
DYNAMIC
MEMORY
WEEK
TOPIC
STACKS
TOPIC
RECURSION
TOPIC
QUEUES
TUT
SINGLY
LINKED
LIST
IMPLEMENTATION
ASSIGNMENT
DUE
ON
FEB
AT
STACKS
RECURSION
MID
TERM
BREAK
WEEK
FEB
TOPIC
QUEUES
TOPIC
TREES
NO
TUTORIAL
WORK
THIS
WEEK
TUTORIALS
OPEN
FOR
CONSULTING
FOR
MIDTERM
FEB
MID
TERM
EXAM
SEE
SECTION
ON
MIDTERM
EXAMINATION
NO
ASSIGNMENT
DUE
THIS
WEEK
WEEK
MAR
TOPIC
TREES
TOPIC
BINARY
SEARCH
TREES
TOPIC
OBJECTS
TUT
ARRAY
BASED
STACK
ADT
ASSIGNMENT
DUE
ON
MAR
AT
RECURSION
TREES
WEEK
TOPIC
OBJECTS
TOPIC
RECAP
LISTS
STACKS
QUEUES
AS
OBJECTS
TUT
BINARY
TREE
ADT
IMPLEMENTATION
ASSIGNMENT
DUE
ON
MAR
AT
BSTS
QUEUES
LAST
DAY
FOR
WITHDRAWING
WITHOUT
PENALTY
WEEK
TOPIC
RECAP
LISTS
STACKS
QUEUES
AS
OBJECTS
5HR
TOPIC
HASHING
5HR
TUT
OBJECT
ORIENTED
PROGRAMMING
ASSIGNMENT
DUE
ON
MAR
AT
OBJECT
ORIENTED
PROGRAMMING
WEEK
TOPIC
HASHING
TOPIC
TOPICS
TUT
TBA
ASSIGNMENT
DUE
ON
MAR
AT
OBJECT
ORIENTED
PROGRAMMING
WEEK
MAR
APR
TOPIC
TOPICS
TUT
TBA
ASSIGNMENT
DUE
ON
APR
AT
TBA
APR
GOOD
FRIDAY
UNIVERSITY
CLOSED
WEEK
APR
TOPIC
COURSE
REVIEW
NO
TUTORIALS
THIS
WEEK
LAST
DAY
OF
CLASSES
FINAL
EXAM
CENTRALLY
SCHEDULED
COURSE
SYLLABUS
CMPT
INTERMEDIATE
DATA
STRUCTURES
AND
ALGORITHMS
CATALOGUE
DESCRIPTION
OBJECT
ORIENTED
DESIGN
OF
FORMAL
ABSTRACT
DATA
TYPES
THIS
COURSE
FOCUSES
ON
DATA
STRUCTURE
DESIGN
AND
USE
IN
JAVA
BASIC
DATA
STRUCTURES
ARE
REVIEWED
IN
AN
OBJECT
ORIENTED
CONTEXT
AND
NEW
DATA
STRUCTURES
AND
RELATED
ALGORITHMS
ARE
INTRODUCED
ORDERED
TREES
BALANCED
TREES
SIMPLE
SPATIAL
TREES
GRAPH
REPRESENTATIONS
AND
SEARCHING
PATH
ALGORITHMS
DEPTH
BREADTH
FIRST
SEARCHES
DIRECT
AND
B
TREE
FILES
AND
ADVANCED
SORTING
ALGORITHMS
THERE
IS
EMPHASIS
ON
ALGORITHM
ANALYSIS
IN
THE
CONTEXT
OF
MEASURING
THE
EFFICIENCY
OF
VARIOUS
DATA
STRUCTURE
OPERATIONS
AND
SUITABILITY
OF
DATA
STRUCTURES
TO
VARIOUS
TASKS
PREREQUISITE
CMPT
COURSE
OBJECTIVES
UPON
COMPLETION
OF
THIS
COURSE
SUCCESSFUL
STUDENTS
SHOULD
BE
ABLE
TO
USE
AND
IMPLEMENT
DATA
STRUCTURES
FOR
EFFICIENT
STORAGE
AND
RETRIEVAL
OF
DATA
IN
COLLECTIONS
LISTS
QUEUES
BALANCED
TREES
USE
AND
IMPLEMENT
GRAPH
DATA
STRUCTURES
ADJACENCY
LIST
ADJACENCY
MATRIX
USE
AND
IMPLEMENT
ABSTRACT
ITERATION
MECHANISMS
FOR
CONTAINERS
AND
GRAPHS
CREATE
NEW
DATA
STRUCTURES
WITH
MINIMAL
EFFORT
AND
MAXIMUM
RE
USE
THROUGH
RESTRICTION
AND
EXTENSION
OF
EXISTING
DATA
STRUCTURES
IMPLEMENT
CUSTOMIZED
DATA
STRUCTURES
FROM
SCRATCH
WITHIN
AN
OBJECT
ORIENTED
DESIGN
FRAMEWORK
CHOOSE
APPROPRIATE
DATA
STRUCTURES
FOR
MAXIMIZING
EFFICIENCY
OF
DATA
STORAGE
AND
RETRIEVAL
FOR
A
GIVEN
TASK
SOLVE
PROBLEMS
THAT
CAN
BE
REPRESENTED
BY
A
GRAPH
USING
BASIC
GRAPH
ALGORITHMS
E
G
SPANNING
TREE
SHORTEST
PATH
ALGORITHMS
MAX
FLOW
AND
SELECT
FORM
AMONG
ADVANCED
SORTING
ALGORITHMS
THE
ONE
THAT
IS
MOST
SUITABLE
TO
A
PARTICULAR
DATA
SORTING
PROBLEM
BASED
ON
THE
NATURE
OF
THE
DATA
TO
BE
SORTED
STUDENT
EVALUATION
GRADING
SCHEME
ASSIGNMENTS
MIDTERM
EXAM
FINAL
EXAM
TOTAL
CRITERIA
THAT
MUST
BE
MET
TO
PASS
STUDENTS
MUST
WRITE
THE
FINAL
EXAM
IF
A
STUDENT
DOES
NOT
WRITE
THE
FINAL
EXAM
THE
STUDENT
WILL
RECEIVE
A
GRADE
OF
AT
MOST
ATTENDANCE
EXPECTATION
STUDENTS
ARE
EXPECTED
TO
ATTEND
EVERY
CLASS
AND
PARTICIPATE
ACTIVELY
THERE
WILL
BE
SHORT
READING
ASSIGN
MENTS
FOR
ALL
CLASSES
AND
STUDENTS
ARE
EXPECTED
TO
COME
TO
CLASS
HAVING
COMPLETED
THE
READINGS
THERE
WILL
BE
GROUP
PROBLEM
SOLVING
ACTIVITIES
IN
CLASS
COME
PREPARED
AND
DO
NOT
DISAPPOINT
YOUR
GROUP
THERE
IS
NO
PENALTY
FOR
MISSED
LECTURES
HOWEVER
ATTENDANCE
IN
CLASS
IS
CRUCIAL
FOR
SUCCESS
IN
THE
COURSE
STUDENTS
ARE
EXPECTED
TO
ATTEND
ALL
TUTORIAL
SESSIONS
THESE
ARE
OPPORTUNITIES
TO
PRACTICE
THE
COURSE
MATE
RIAL
WITH
THE
GUIDANCE
OF
A
TEACHING
ASSISTANT
THERE
WILL
ALSO
ON
OCCASION
BE
NEW
MATERIALS
PRESENTED
IN
TUTORIALS
THAT
ARE
NOT
PRESENTED
IN
CLASS
WHICH
WILL
BE
COVERED
ON
EXAMINATIONS
THIS
IS
BECAUSE
TUTORIALS
CONTAIN
SOME
FLEXIBLE
TIME
WHOSE
CONTENT
IS
DRIVEN
BY
THE
NEEDS
OF
THE
STUDENTS
SOMETIMES
THIS
MEANS
THAT
CONTENT
WILL
BE
PRESENTED
WITHOUT
BEING
PREPARED
IN
ADVANCE
AND
SUCH
CONTENT
WILL
NOT
APPEAR
IN
LECTURES
OR
BE
POSTED
ONLINE
BUT
WILL
STILL
BE
FAIR
GAME
FOR
TESTING
ON
EXAMINATIONS
THERE
IS
NO
PENALTY
FOR
MISSED
TUTORIAL
SESSIONS
BUT
IT
IS
EXPECTED
THAT
STUDENTS
WILL
ATTEND
AND
TAKE
ADVANTAGE
OF
THE
OPPORTUNITY
FOR
ASKING
QUESTIONS
SEEING
MORE
EXAMPLES
AND
GETTING
ADDITIONAL
PRACTICE
NOTE
ALL
STUDENTS
MUST
BE
PROPERLY
REGISTERED
IN
ORDER
TO
ATTEND
LECTURES
AND
RECEIVE
CREDIT
FOR
THIS
COURSE
MIDTERM
EXAMINATION
SCHEDULING
THE
MID
TERM
EXAM
DATE
WILL
BE
HELD
IN
CLASS
ON
WEDNESDAY
FEBRUARY
FINAL
EXAM
SCHEDULING
THE
REGISTRAR
SCHEDULES
ALL
FINAL
EXAMINATIONS
INCLUDING
DEFERRED
AND
SUPPLEMENTAL
EXAMINATIONS
STUDENTS
MUST
NOT
MAKE
TRAVEL
PLANS
OR
SCHEDULE
OTHER
ACTIVITIES
DURING
THE
PERIOD
SCHEDULED
FOR
EX
AMINATIONS
DEFERRED
EXAMINATIONS
ARE
NOT
GRANTED
FOR
THESE
REASONS
HTTP
WWW
USASK
CA
PROGRAMS
COLLEGES
SCHOOLS
ARTS
SCIENCE
DEFERREDANDSUPPLEMENTALEXAMINATIONS
COURSE
OVERVIEW
LECTURES
WILL
BE
OPPORTUNITIES
TO
APPLY
THE
CONCEPTS
COVERED
IN
THE
COURSE
DISCUSS
THEM
LOOK
AT
EXAMPLES
AND
SOLVE
PROBLEMS
AS
WELL
AS
TO
ASK
QUESTIONS
AND
RECEIVE
GUIDANCE
WE
WILL
NOT
USE
MUCH
CLASS
TIME
READING
SLIDES
TO
YOU
SHORT
READINGS
WILL
BE
ASSIGNED
BEFORE
EACH
CLASS
AND
YOU
WILL
BE
EXPECTED
TO
BE
PREPARED
TO
DISCUSS
ASK
QUESTIONS
AND
PARTICIPATE
TUTORIAL
TIMES
ARE
LISTED
BELOW
THESE
ARE
YOUR
OPPORTUNITIES
TO
REVIEW
AND
PRACTICE
THE
CURRENT
WEEK
MATERIAL
UNDER
THE
GUIDANCE
OF
A
TEACHING
ASSISTANT
WE
WILL
HAVE
ONE
MIDTERM
EXAMINATION
SEE
ABOVE
FOR
THE
SCHEDULE
THE
FINAL
EXAMINATION
IS
SCHEDULED
BY
THE
UNIVERSITY
ASSIGNMENTS
ARE
MOSTLY
WEEKLY
TO
ENSURE
THAT
ALL
THE
RELEVANT
MATERIAL
IS
PUT
INTO
REGULAR
CONSISTENT
PRACTICE
SOME
EARLY
ASSIGNMENTS
MAY
SEEM
EASY
AND
LATER
ASSIGNMENTS
WILL
DEFINITELY
CHALLENGE
YOU
EVEN
A
SIMPLE
ASSIGNMENT
CAN
TURN
INTO
A
TIME
CONSUMING
AFFAIR
IF
YOU
GET
STUCK
ON
SOMETHING
THAT
BLOCKS
YOUR
PROGRESS
WORKING
AT
THE
LAST
MINUTE
IS
A
GUARANTEED
SOURCE
OF
STRESS
AND
BURN
OUT
TO
MANAGE
YOUR
WORKLOAD
YOU
MUST
LEARN
EFFECTIVE
TIME
MANAGEMENT
START
EVERY
ASSIGNMENT
EARLY
TO
ALLOW
YOURSELF
TIME
TO
GET
HELP
IF
YOU
RUN
INTO
A
PROBLEM
MAKE
USE
OF
THE
TEACHING
RESOURCES
INSTRUCTORS
OFFICE
HOURS
TAS
LABS
LECTURES
DISCUSSION
FORUMS
ETC
AVAILABLE
TO
YOU
TEXTBOOK
INFORMATION
REQUIRED
TEXTS
AND
RESOURCES
REQUIRED
TEXTBOOK
M
ERAMIAN
INTERMEDIATE
DATA
STRUCTURES
AND
ALGORITHMS
COURSE
READINGS
FOR
CMPT
SECOND
EDITION
YOU
CANNOT
BUY
THIS
IN
THE
BOOKSTORE
THIS
BOOK
IS
AVAILABLE
FOR
FREE
ON
THE
COURSE
WEBSITE
RECOMMENDED
TEXTS
JAVA
REFERENCE
BIG
JAVA
EARLY
OBJECTS
EDITION
BY
CAY
HORSTMANN
WILEY
SONS
YOU
DON
T
HAVE
TO
BUY
THIS
BUT
IF
YOU
WANT
A
BOOK
ON
JAVA
THIS
ONE
IS
PRETTY
GOOD
DOES
NOT
INCLUDE
JAVA
BUT
WE
SHOULD
NOT
BE
USING
ANY
LANGUAGE
FEATURES
SPECIFIC
TO
JAVA
LECTURE
SCHEDULE
THE
FOLLOWING
SCHEDULE
IS
APPROXIMATE
OTHER
TOPICS
MAY
BE
ADDED
IF
TIME
ALLOWS
TOPIC
DETAILS
REVIEW
OF
LISTS
ARRAY
BASED
LISTS
SINGLY
LINKED
LIST
INSERTION
ALGORITHM
DOUBLY
CIRCULARLY
LINKED
VARIANTS
REGRESSION
TESTING
BLACK
BOX
WHITE
BOX
MANAGING
EXPECTED
AND
UNEXPECTED
EXCEPTIONS
GENERALIZED
COLLECTION
ITERATION
CURSORS
ITERATORS
ALGORITHM
TIMING
ANALYSIS
FORMAL
DEFINTION
STATEMENT
COUNTING
APPROACH
ACTIVE
OPERATION
APPROACH
BIG
O
BIG
THETA
NOTATION
ABSTRACT
DATA
TYPES
AND
SPECIFICATION
ADT
DEFINTION
REVIEW
FORMAL
SPECIFICATION
OF
ADTS
STANDARD
TREES
TREE
TRAVERSALS
ORDERED
TREES
GENERAL
TREES
SPECIALIZED
TREES
NOT
ALL
COVERED
IN
DETAIL
AVL
TREES
TREES
B
TREES
SPLAY
TREES
TRIES
RANGE
SEARCHING
K
D
TREES
GRAPHS
DIRECTED
AND
UNDIRECTED
GRAPHS
BREADTH
FIRST
AND
DEPTH
FIRST
SEARCH
SHORTEST
PATH
ALGORITHMS
E
G
DIJKSTRA
ALGOIRTHM
EFFICIENT
SORTING
ALGORITHMS
REVIEW
OF
O
SEARCHES
MERGE
SORT
QUICK
SORT
HEAP
SORT
LINEAR
SORTS
BUCKET
RADIX
EXTRA
TOPICS
TIME
PERMITTING
GREEDY
ALGORITHMS
BACKTRACKING
ALGORITHMS
DESIGN
OF
MORE
DATA
STRUCTURES
ASSIGNMENT
SCHEDULE
ASSIGNMENTS
WILL
BE
MOSTLY
WEEKLY
LATER
ASSIGNMENTS
WILL
BE
BI
WEEKLY
AND
WILL
BE
LENGTHIER
THE
ASSIGN
MENT
DEADLINE
SCHEDULE
FOLLOWS
IN
THE
HIGHLY
UNLIKELY
EVENT
THAT
THIS
SCHEDULE
IS
DISRUPTED
SO
MUCH
THAT
AN
ASSIGNMENT
NEEDS
TO
BE
CANCELLED
THE
WEIGHTING
OF
THE
REMAINING
ASSIGNMENTS
WILL
BE
PRO
RATED
SO
THAT
THEY
COMPRISE
THE
PERCENTAGE
OF
THE
FINAL
GRADE
LISTED
UNDER
THE
GRADING
SCHEME
SECTION
ABOVE
ASSIGNMENT
DUE
DATE
JANUARY
JANUARY
FEBRUARY
FEBRUARY
MARCH
2016
MARCH
2016
MARCH
2016
00PM
APRIL
2016
00PM
TUTORIAL
SECTIONS
TUTORIAL
SESSIONS
BEGIN
THE
WEEK
OF
JANUARY
SECTION
DAY
TIME
ROOM
WEDNESDAY
00PM
30PM
THORV
THURSDAY
00PM
30PM
THORV
THE
TUTORIAL
SESSIONS
WILL
BE
GUIDED
BY
TEACHING
ASSISTANTS
THE
CONTACT
INFORMATION
FOR
THE
TEACHING
ASSISTANTS
WILL
BE
MADE
AVAILABLE
ON
COURSE
MOODLE
WEBPAGE
HTTP
MOODLE
CS
USASK
CA
THE
OPEN
UNDERGRADUATE
COMPUTING
LABS
ON
THE
FLOOR
OF
THE
SPINKS
ADDITION
TO
THE
THORVALDSON
BUILD
ING
IS
AVAILABLE
FOR
STUDENT
USE
OUTSIDE
OF
LAB
TIME
MANY
TAS
AND
INSTRUCTORS
FOR
SEVERAL
CMPT
COURSES
WILL
HOLD
OFFICE
HOURS
IN
THE
OPEN
LAB
DON
T
BE
SHY
IF
YOU
SEE
AN
INSTRUCTOR
OR
TA
WHO
IS
NOT
YOUR
TA
OR
INSTRUCTOR
IN
THE
LAB
DON
T
HESITATE
TO
CALL
THEM
OVER
TO
HELP
YOU
DESCRIPTION
COMPUTERS
ARE
UBIQUITOUS
TOOLS
THAT
HAVE
AND
WILL
CONTINUE
TO
SHAPE
OUR
WORLD
IN
COMMON
USAGE
FOR
ONLY
HALF
OF
A
CENTURY
IN
THEIR
SHORT
EXISTENCE
THEY
HAVE
ALREADY
REVOLUTIONIZED
SCIENCE
ART
BUSINESS
AND
ENTERTAINMENT
HOWEVER
AT
THEIR
CORE
COMPUTERS
ARE
SIMPLE
MACHINES
THAT
CAN
ONLY
DO
BASIC
MATHEMATICAL
COMPUTATIONS
ADDITION
SUBTRACTION
MULTIPLICATION
DIVISION
ETC
AND
MAKE
DECISIONS
BASED
UPON
FUNDAMENTAL
RULES
OF
LOGIC
HOW
THEN
CAN
SUCH
BASIC
OPERATIONS
BE
UTILIZED
TO
MAKE
SOMETHING
SO
POWERFUL
THE
ACT
OF
PROGRAMMING
A
COMPUTER
REQUIRES
US
TO
TRANSLATE
A
PROBLEM
WE
WISH
TO
SOLVE
BE
IT
A
MATH
PROBLEM
A
BUSINESS
PROBLEM
OR
EVEN
A
VIDEO
GAME
INTO
A
REPRESENTATION
THAT
THE
COMPUTER
AND
ITS
SIMPLE
OPERATIONS
CAN
MANIPULATE
THIS
REQUIRES
AT
LEAST
TWO
STEPS
FIRST
WE
MUST
MODEL
THE
PROBLEM
AS
INFORMATION
WE
CALL
DATA
DATA
CAN
BE
ANYTHING
FROM
THE
VALUES
OF
A
SCIENCE
EXPERIMENT
TO
A
COLLECTION
OF
THE
VERY
LETTERS
THAT
COMPRISE
THE
SENTENCE
YOU
ARE
READING
FOR
REAL
LIFE
SIZED
PROBLEMS
WE
WILL
BUILD
AS
COMPLEX
OF
A
MODEL
AS
IS
NECESSARY
UP
FROM
SMALLER
COMPONENTS
STARTING
WITH
THOSE
FUNDAMENTAL
TO
A
COMPUTER
AND
TURNING
THEM
INTO
LARGER
UNITS
THAT
WE
WILL
CALL
OBJECTS
SECOND
WE
MUST
ENCODE
THE
INTERACTION
AND
MANIPULATION
OF
THOSE
OBJECTS
AS
CODE
THE
COLLECTION
OF
COMPUTER
OPERATIONS
THAT
TRANSFORMS
DATA
USING
WELL
DEFINED
RULES
IN
THIS
CLASS
WE
WILL
CHOOSE
TO
DESCRIBE
OUR
COMPUTER
PROGRAMS
IN
A
PROGRAMMING
LANGUAGE
CALLED
JAVA
JAVA
IS
A
PROGRAMMING
LANGUAGE
BUILT
AROUND
THE
CREATION
AND
MANAGEMENT
OF
OBJECTS
IN
TERMS
OF
THE
DATA
THEY
CONTAIN
AND
THE
CODE
THAT
ACTS
UPON
THEM
THERE
ARE
MANY
OBJECT
ORIENTED
PROGRAMMING
LANGUAGES
BUT
JAVA
IS
A
GOOD
CHOICE
FOR
BOTH
LEARNING
AND
REAL
LIFE
USE
THE
SKILLS
THAT
WE
LEARN
IN
JAVA
WILL
BE
EASILY
TRANSFERRABLE
TO
OTHER
PROGRAMMING
LANGUAGES
AND
EVEN
OTHER
PROGRAMMING
PARADIGMS
PREREQUISITES
THIS
CLASS
IS
MEANT
TO
BE
A
SECOND
OR
LATER
CLASS
IN
PROGRAMMING
THE
PREREQUISITE
IS
PRIOR
PROGRAMMING
EXPERIENCE
THAT
CAN
BE
IN
ANY
LANGUAGE
SINCE
MOST
SHARE
ENOUGH
IN
COMMON
IF
NOT
SYNTACTICALLY
THEN
AT
LEAST
IN
TERMS
OF
THE
ACT
OF
PROGRAMMING
PRIOR
EXPERIENCE
IN
JAVA
IS
A
PLUS
BUT
ANY
REASONABLE
LANGUAGE
WILL
DO
AND
THE
BEGINNING
OF
THE
TERM
WILL
BE
A
QUICK
INTRODUCTION
TO
THE
BASICS
OF
THE
JAVA
LANGUAGE
THIS
MEANS
THAT
THE
COURSE
WILL
NOT
TEACH
YOU
ABOUT
THE
BASIC
IDEAS
OF
VARIABLES
OR
CONTROL
STRUCTURES
AND
HOW
TO
USE
THEM
TO
EXPRESS
BASIC
IDEAS
AS
CODE
RATHER
WE
WILL
FOCUS
ON
THE
SPECIFIC
TASK
OF
TAKING
COMPUTATIONAL
THINKING
AND
EXPRESSING
IT
IN
THE
JAVA
PROGRAMMING
LANGUAGE
IF
YOU
HAVE
ANY
QUESTIONS
ABOUT
THE
PREREQUISITE
MATERIAL
FOR
THE
COURSE
PLEASE
ASK
AT
THE
BEGINNING
OF
THE
TERM
COURSE
PURPOSES
AND
GOALS
AT
THE
END
OF
THIS
COURSE
STUDENTS
WILL
BE
ABLE
TO
WRITE
PROGRAMS
IN
THE
JAVA
PROGRAMMING
LANGUAGE
THAT
UTILIZE
OBJECTS
FROM
THE
JAVA
CLASS
LIBRARY
AS
WELL
AS
CUSTOM
OBJECTS
THAT
MODEL
THE
PROBLEM
BEING
SOLVED
UNDERSTAND
AND
UTILIZE
THE
TOOLS
NECESSARY
TO
CREATE
AND
RUN
A
JAVA
PROGRAM
UNDERSTAND
THE
OUTPUT
WHEN
ERRORS
OCCUR
AND
TO
SOLVE
ERRORS
AT
COMPILE
TIME
AND
RUN
TIME
USING
THE
SKILL
OF
DEBUGGING
USE
AND
APPLY
SIMPLE
DATA
STRUCTURES
SUCH
AS
ARRAYS
AND
SIMILAR
COLLECTIONS
TO
HOLD
AGGREGATE
DATA
DEVELOP
AND
APPRECIATE
BASIC
ALGORITHMS
SUCH
AS
SEARCHING
AND
SORTING
HAVE
THE
FOUNDATION
NECESSARY
TO
PROCEED
TO
FURTHER
COURSES
IN
THE
COMPUTER
SCIENCE
ENGINEERING
AND
INFORMATION
SCIENCE
FIELDS
TEXTBOOKS
REQUIRED
TEXT
GADDIS
TONY
STARTING
OUT
WITH
JAVA
FROM
CONTROL
STRUCTURES
THROUGH
OBJECTS
SIXTH
EDITION
ADDISON
WESLEY
ISBN
CLASS
POLICIES
EXAMS
THERE
WILL
BE
TWO
MIDTERMS
AND
A
FINAL
THE
EXAMS
WILL
BE
CLOSED
BOOK
NOTES
THE
FINAL
EXAM
WILL
BE
WEDNESDAY
APRIL
FROM
IN
THE
NORMAL
CLASSROOM
CHEATING
ON
EXAMS
WILL
NOT
BE
TOLERATED
ANYONE
CAUGHT
CHEATING
WILL
BE
GIVEN
A
ZERO
FOR
THE
TEST
OR
FOR
THE
COURSE
AND
REPORTED
TO
THE
DEPARTMENT
FOLLOWING
UNIVERSITY
PROCEDURES
AT
THE
RISK
OF
SEEMING
LIKE
A
LUDDITE
SMART
WATCHES
WILL
BE
FORBIDDEN
ON
TEST
DAYS
PLEASE
KEEP
THEM
SOMEPLACE
OUT
OF
SIGHT
FOR
THE
DURATION
OF
THE
EXAM
PROJECTS
THERE
WILL
BE
OUT
OF
CLASS
ASSIGNMENTS
GIVEN
THESE
ARE
TO
BE
COMPLETED
IN
THE
GIVEN
TIME
NO
EXTENSIONS
WILL
BE
GIVEN
WITHOUT
A
VALID
EXCUSE
LATE
WORK
IS
NOT
ACCEPTED
CONTACT
ME
BEFORE
THE
DEADLINE
FOR
CLARIFICATIONS
THESE
ARE
MEANT
TO
BE
YOUR
OWN
WORK
ANYONE
FOUND
TO
BE
COLLABORATING
WILL
BE
DISCIPLINED
IN
ACCORDANCE
TO
UNIVERSITY
POLICY
CHEATING
MEANS
BUT
IS
NOT
LIMITED
TO
USING
CODE
FROM
PREVIOUS
TERMS
OTHER
UNIVERSITIES
YOUR
FRIENDS
FINDING
IT
ON
THE
INTERNET
GETING
HELP
FROM
UNAPPROVED
FORUMS
OR
OUTSOURCING
IT
WE
WILL
BE
USING
MOSS
A
TOOL
FROM
STANFORD
FOR
DETERMINING
INAPPROPRIATE
COLLABORATION
LABS
AND
QUIZZES
ATTENDING
LAB
IS
AN
IMPORTANT
PART
OF
THIS
COURSE
IN
LAB
YOU
WILL
BE
ABLE
TO
WORK
IN
A
STRUCTURED
SETING
WHILE
COMPLETING
SMALL
TASKS
CONCEPTS
FROM
CLASS
WILL
BE
EXPANDED
UPON
AND
TESTED
WITH
UNANNOUNCED
QUIZZES
PARTICIPATION
ATTENDANCE
WILL
NOT
BE
TAKEN
BUT
IN
A
SMALL
CLASS
ANY
ABSENCE
WILL
BE
NOTICED
SEVERAL
UNEXCUSED
MISSED
CLASSES
WILL
ADVERSELY
AFFECT
YOUR
GRADE
DUE
TO
THIS
CLASS
BEING
TAKEN
BY
STUDENTS
WITH
A
WIDE
VARIETY
OF
BACKGROUNDS
I
WILL
BE
DOING
MY
BEST
TO
ENSURE
A
COMFORTABLE
CLASSROOM
ENVIRONMENT
FOR
THOSE
WITH
LESS
PROGRAMMING
EXPERIENCE
IF
YOUR
PARTICIPATION
IN
TERMS
OF
ANSWERS
OR
QUESTIONS
ARE
WELL
BEYOND
THE
LEVEL
WE
ARE
CURRENTLY
AT
PLEASE
KEEP
THEM
TO
AFTER
CLASS
OFFICE
HOURS
OR
EMAILS
EXPECT
GENTLE
AND
IF
NECESSARY
NOT
SO
GENTLE
REMINDERS
OF
THIS
THROUGHOUT
THE
TERM
DISABILITY
RESOURCES
AND
SERVICES
IF
YOU
HAVE
A
DISABILITY
FOR
WHICH
YOU
ARE
REQUESTING
AN
ACCOMMODATION
YOU
ARE
ENCOURAGED
TO
CONTACT
BOTH
YOUR
INSTRUCTOR
AND
DISABILITY
RESOURCES
AND
SERVICES
WILLIAM
PITT
UNION
AS
EARLY
AS
POSSIBLE
IN
THE
TERM
DRS
WILL
VERIFY
YOUR
DISABILITY
AND
DETERMINE
REASONABLE
ACCOMMODATIONS
FOR
THIS
COURSE
ACADEMIC
INTEGRITY
STUDENTS
ARE
EXPECTED
TO
COMPLY
WITH
THE
UNIVERSITY
OF
PITTSBURGH
POLICY
ON
ACADEMIC
INTEGRITY
ANY
STUDENT
SUSPECTED
OF
VIOLATING
THIS
OBLIGATION
FOR
ANY
REASON
DURING
THE
SEMESTER
WILL
BE
REQUIRED
TO
PARTICIPATE
IN
THE
PROCEDURAL
PROCESS
AS
OUTLINED
IN
THE
UNIVERSITY
GUIDELINES
ON
ACADEMIC
INTEGRITY
FOR
FURTHER
INFORMATION
SEE
IN
THIS
FIRST
LAB
WE
WILL
INTRODUCE
THE
COMPUSTNG
ENVIRONMENT
IN
THE
LAB
CLASSROOM
GIVE
YOU
SOME
HINTS
ABOUT
HOW
TO
SET
UP
JAVA
AT
HOME
AND
WALK
YOU
THROUGH
THE
SUBMISSION
PROCESS
THAT
WE
WILL
USE
FOR
LABS
AND
PROJECTS
THROUGHOUT
THE
TERM
GETTING
STARTED
WITH
PROGRAMMING
IN
JAVA
THE
COMPUTERS
IN
OUR
LAB
ARE
RUNNING
WINDOWS
AND
ARE
ALREADY
CONFIGURED
WITH
THE
TOOLS
WE
WILL
NEED
TO
CREATE
AND
RUN
PROGRAMS
WRITTEN
IN
JAVA
AFTER
YOU
LOG
IN
YOU
LL
BE
PRESENTED
WITH
THE
LARGE
WINDOWS
START
MENU
FROM
THE
USTLISTES
COLUMN
YOU
MAY
NEED
TO
SCROLL
TO
THE
RIGHT
TO
SEE
IT
LAUNCH
THE
NOTEPAD
APPLICASTON
TEXT
EDITING
NOTEPAD
IS
ONE
OF
MANY
PROGRAMMERS
TEXT
EDITORS
THE
SOURCE
CODE
FOR
JAVA
IS
JUST
PLAIN
HUMAN
READABLE
TEXT
THERE
NO
FORMAFFLNG
OR
STYLES
LIKE
BOLD
OR
ITALIC
OR
UNDERLINE
JUST
LETTERS
PUNCTUASTON
AND
WHITESPACE
WE
COULD
THEN
WRITE
PROGRAMS
ENSTRELY
IN
A
BASIC
NO
FRILLS
TEXT
EDITOR
LIKE
WINDOWS
OWN
NOTEPAD
HOWEVER
THE
SPECIFIC
TASK
OF
PROGRAMMING
HAS
SOME
COMMON
CHALLENGES
THAT
THESE
MORE
SPECIALIZED
PROGRAMS
LIKE
NOTEPAD
HOPE
TO
MAKE
EASIER
ON
US
YOU
MAY
GET
A
DIALOG
BOX
ASKING
YOU
TO
UPDATE
SOME
PLUGINS
IT
DOUBUL
THIS
WOULD
INSTALL
CORRECTLY
DUE
TO
US
NOT
HAVING
PERMISSIONS
TO
INSTALL
SOFTWARE
ON
THE
LAB
COMPUTERS
SO
LET
JUST
SKIP
THAT
AT
HOME
IF
YOU
DECIDE
TO
USE
NOTEPAD
YOU
CAN
CERTAINLY
UPDATE
WHEN
IT
PROMPTS
YOU
TO
YOU
ARE
NOW
ABLE
TO
TYPE
SOMETHING
IN
SO
LET
TYPE
IN
THE
HELLO
WORLD
PROGRAM
WE
SAW
IN
CLASS
HERE
THE
CODE
IF
YOU
NEED
IT
I
SUGGEST
THAT
EACH
INDENTED
LINE
BE
INDENTED
WITH
A
TAB
SO
BEFORE
PUBLIC
HIT
TAB
ONCE
BEFORE
SYSTEM
HIT
TAB
AGAIN
YOU
LL
NOTE
THAT
YOU
DIDN
T
HAVE
TO
HIT
TAB
TWICE
SINCE
WHEN
YOU
HIT
ENTER
IT
REMEMBERED
YOUR
PREVIOUS
LEVEL
OF
INDENTASTON
THIS
IS
SOMETHING
A
BASIC
TEXT
EDITOR
WOULDN
T
DO
THAT
A
PROGRAMMER
TEXT
EDITOR
LIKE
NOTEPAD
WILL
DO
FOR
YOU
YOU
MIGHT
ALSO
NOSTCE
IT
HIGHLIGHSTNG
THE
LEFT
PARENTHESIS
WHEN
YOU
TYPE
A
RIGHT
PARENTHESIS
OR
THE
SAME
WHEN
YOU
TYPE
THE
CURLY
BRACES
AND
THESE
HELP
YOU
TO
KNOW
WHICH
OPEN
GROUPING
CHARACTER
YOU
ARE
CLOSING
SO
THAT
YOU
CAN
HAVE
THE
RIGHT
NUMBER
WHEN
THERE
ARE
MANY
BUT
THERE
MORE
THINGS
THAT
A
PROGRAMMER
TEXT
EDITOR
CAN
DO
IF
IT
KNOWS
WHAT
PROGRAMMING
LANGUAGE
YOU
ARE
WRISTNG
IN
RIGHT
NOW
NOTEPAD
DOESN
T
KNOW
THAT
YOU
WANT
TO
PROGRAM
IN
JAVA
YOU
CAN
TELL
IT
ONE
OF
TWO
WAYS
YOU
CAN
EITHER
SAVE
THE
FILE
WITH
A
JAVA
EXTENSION
OR
YOU
CAN
GO
TO
THE
LANGUAGE
MENU
AND
TELL
IT
WHICH
LANGUAGE
YOU
RE
PROGRAMMING
IN
SO
LET
TRY
BOTH
FIRST
GO
TO
THE
LANGUAGE
MENU
SELECT
THE
J
SUBMENU
AND
THEN
CHOOSE
JAVA
ALL
OF
A
SUDDEN
YOUR
PLAIN
TEXT
NO
LONGER
LOOKS
THAT
PLAIN
NOTEPAD
DOES
WHAT
IS
CALLED
SYNTAX
HIGHLIGH
NG
THIS
MEANS
THAT
WHEN
YOU
TYPE
SOMETHING
SPECIAL
A
RESERVED
WORD
A
STRING
A
NUMBER
ETC
SOMETHING
THAT
HAS
MEANING
IN
JAVA
IT
WILL
TURN
A
DIFFERENT
COLOR
THAN
THE
IDENSTFIERS
AND
EXPRESSIONS
WE
WRITE
THAT
GIVES
US
STRONG
HINTS
ABOUT
THE
STRUCTURE
OF
OUR
CODE
AND
REMINDS
US
TO
NOT
NAME
VARIABLES
WITH
WORDS
THAT
JAVA
FORBIDS
NOTEPAD
ALSO
DOES
SOMETHING
ELSE
AFTER
THE
SYSTEM
OUT
PRINTLN
HELLO
WORLD
LINE
HIT
ENTER
AND
ADD
A
NEW
LINE
LET
HAVE
YOU
PRINT
THE
STRING
GOODBYE
CRUEL
WORLD
AS
YOU
START
TO
TYPE
SYSTEM
YOU
LL
NOTE
THAT
IT
POPS
UP
A
BOX
THAT
SUGGESTS
WHAT
YOU
MIGHT
BE
TYPING
SIMILAR
TO
HOW
YOUR
SMARTPHONE
MIGHT
AT
ANY
POINT
YOU
CAN
HIT
THE
TAB
KEY
TO
HAVE
IT
FINISH
TYPING
WHAT
YOU
STARTED
IF
THE
HIGHLIGHTED
SELECSTON
IS
WHAT
YOU
WANT
IF
IT
ISN
T
YOU
CAN
KEEP
TYPING
TO
GET
BETTER
SUGGESSTONS
OR
USE
THE
MOUSE
TO
SELECT
A
DIFFERENT
OPSTON
NOTE
THOUGH
THAT
JUST
BECAUSE
IT
DOESN
T
SUGGEST
SOMETHING
DOESN
T
MEAN
YOU
RE
TYPING
SOMETHING
WRONG
IT
REALLY
ONLY
REMEMBERS
THINGS
YOU
VE
ALREADY
TYPED
THAT
YOU
MIGHT
REUSE
OR
SOME
COMMON
SNIPPETS
IT
CAN
GUESS
AT
SYNTAX
HIGHLIGHSTNG
AND
AUTO
COMPLESTON
CAN
MAKE
US
VERY
PRODUCSTVE
PROGRAMMERS
BUT
MAKE
SURE
THAT
THEY
DON
T
BECOME
A
CRUTCH
YOU
SSTLL
MUST
KNOW
THE
LANGUAGE
WELL
ENOUGH
TO
WRITE
CODE
ON
PAPER
ONE
OF
OUR
GOALS
IS
FLUENCY
SO
THAT
EVEN
IF
WE
DON
T
HAVE
THE
TOOLS
WE
ARE
USED
TO
WE
CAN
SSTLL
GET
WORK
DONE
COMPILING
AND
RUNNING
JAVA
NOW
SAVE
THE
FILE
YOU
ARE
EDISTNG
WITH
THE
NAME
HELLO
JAVA
THE
DEFAULT
LOCASTON
TO
SAVE
IS
PROBABLY
YOUR
DOCUMENTS
FOLDER
AND
WE
ARE
OKAY
WITH
THAT
IF
YOU
RE
SOMEWHERE
ELSE
NAVIGATE
TO
YOUR
DOCUMENTS
AND
SAVE
THERE
NOTEPAD
IS
NOT
A
FULL
INTEGRATED
DEVELOPMENT
ENVIRONMENT
IDE
AN
IDE
WOULD
GIVE
YOU
ONE
CLICK
ACCESS
TO
THE
COMPILER
AND
TO
RUN
THE
RESULSTNG
PROGRAM
IT
WOULD
HAVE
SYNTAX
HIGHLIGHSTNG
AND
EVEN
BETTER
AUTO
COMPLESTON
HOWEVER
THEY
ARE
COMPLEX
AND
CAN
HIDE
THE
DETAILS
OF
WHAT
YOU
ARE
DOING
TO
PREVENT
YOU
FROM
LEARNING
THE
BASICS
WE
WON
T
ADVOCATE
USING
AN
IDE
IN
THE
CLASS
SO
WE
ARE
GOING
TO
NEED
DIRECT
ACCESS
TO
THE
COMPILER
TO
BUILD
OUR
PROGRAM
BRING
UP
THE
WINDOWS
START
MENU
EITHER
BY
DRAGGING
YOUR
MOUSE
ALL
THE
WAY
INTO
THE
LOWER
LEFT
HAND
CORNER
OR
BY
HIFFLNG
THE
WINDOWS
KEY
ON
THE
KEYBOARD
FROM
THERE
FIND
THE
SYSTEM
ACCESSORIES
CATEGORY
OF
APPLICASTONS
AND
CHOOSE
THE
COMMAND
PROMPT
TO
RUN
YOU
LL
NOW
HAVE
A
SMALL
BLACK
WINDOW
POP
UP
WITH
A
CURSOR
THAT
IS
PROMPSTNG
YOU
TO
TYPE
A
COMMAND
THIS
IS
A
COMMAND
LINE
INTERFACE
AND
IT
IS
AN
OLDER
AND
IN
SOME
WAYS
SIMPLER
WAY
OF
INTERACSTNG
WITH
THE
COMPUTER
THAN
THE
GRAPHICAL
USER
INTERFACE
GUI
THAN
WHAT
YOU
RE
MAYBE
USED
TO
THE
LINE
SHOWING
LOWEST
ON
THE
SCREEN
WHERE
THE
CURSOR
IS
BLINKING
TELLS
YOU
WHAT
DIRECTORY
WE
ARE
CURRENTLY
IN
WE
WANT
TO
GO
INTO
OUR
DOCUMENTS
DIRECTORY
WHERE
WE
SAVED
OUR
HELLO
JAVA
FILE
SO
WE
MUST
ISSUE
A
COMMAND
RATHER
THAN
CLICKING
ON
AN
ICON
THAT
COMMAND
IS
CD
WHICH
STANDS
FOR
CHANGE
DIRECTORY
WE
TELL
IT
WHAT
THE
NAME
OF
THE
DIRECTORY
IS
AND
HIT
ENTER
SO
TYPE
AND
NOW
THE
TEXT
AT
THE
CURRENT
PROMPT
SHOULD
SAY
THAT
YOU
ARE
IN
THE
DOCUMENTS
DIRECTORY
THE
LAB
COMPUTERS
HAVE
BEEN
CONFIGURED
WITH
THE
SOFTWARE
AND
SEFFLNGS
NECESSARY
TO
COMPILE
AND
RUN
JAVA
WE
CAN
TEST
THAT
BY
ASKING
WHAT
VERSION
OF
JAVA
WE
HAVE
INSTALLED
EXECUTE
THE
COMMAND
IT
WILL
LIKELY
REPORT
BACK
A
VERSION
THAT
STARTS
WITH
AND
SOME
OTHER
NUMBERS
THAT
INDICATE
THAT
BUGS
HAVE
BEEN
FIXED
SEVERAL
STMES
THE
LATEST
VERSION
OF
JAVA
IS
ACTUALLY
AND
SO
IF
YOU
DO
THIS
AT
HOME
YOU
MIGHT
FIND
A
BIGGER
NUMBER
THAT
OKAY
IN
THIS
CLASS
WE
LL
MOSTLY
BE
OKAY
WITH
VERSION
OR
LATER
THAT
WAS
JUST
A
TEST
TO
SEE
IF
EVERYTHING
WAS
OKAY
WE
DON
T
NEED
TO
RUN
THAT
COMMAND
THAT
WAY
TO
BUILD
OUR
PROGRAM
LET
DO
THAT
NOW
TYPE
THE
COMMAND
AND
HIT
ENTER
THE
COMPILER
JAVAC
FOLLOWS
THE
UNIX
MODEL
OF
PROGRAM
OUTPUT
IF
YOU
SEE
NO
OUTPUT
ON
THE
SCREEN
NOTHING
WENT
WRONG
IF
YOU
DO
SEE
A
MESSAGE
IT
IS
TELLING
YOU
THAT
YOU
HAVE
TYPED
SOMETHING
AGAINST
THE
RULES
OF
THE
JAVA
LANGUAGE
IT
WILL
TELL
YOU
WHAT
LINE
IT
GUESSES
YOU
MESSED
UP
ON
IT
NOT
ALWAYS
RIGHT
BUT
IT
IS
USUALLY
CLOSE
DOUBLE
CHECK
WHAT
YOU
TYPED
WITH
WHAT
THE
PROGRAM
WAS
SUPPOSED
TO
BE
SAVE
AGAIN
AND
TRY
TO
RECOMPILE
WHEN
YOU
SUCCEED
YOU
LL
HAVE
PRODUCED
A
NEW
FILE
HELLO
CLASS
YOU
CAN
SEE
THE
LIST
OF
FILES
IN
THE
CURRENT
DIRECTORY
BY
TYPING
IF
YOU
MISTAKENLY
PUT
THE
CLASS
EXTENSION
OR
YOU
TRY
TO
RUN
THE
JAVA
FILE
WITHOUT
COMPILING
YOU
LL
GET
AN
ERROR
SUCH
AS
ERROR
COULD
NOT
FIND
OR
LOAD
MAIN
CLASS
HELLO
CLASS
TURNING
IT
IN
OPEN
UP
WINDOWS
EXPLORER
BY
CLICKING
THE
FOLDER
ICON
IN
THE
TASKBAR
NAVIGATE
TO
DOCUMENTS
IF
YOU
AREN
T
ALREADY
THERE
SO
THAT
YOU
CAN
SEE
THE
HELLO
JAVA
AND
HELLO
CLASS
FILES
YOU
CREATED
TO
SUBMIT
WE
ARE
GOING
TO
NEED
TO
CREATE
A
ZIP
FILE
AND
UPLOAD
IT
TO
THE
CLASS
SUBMISSION
SITE
TO
CREATE
A
ZIP
FILE
SELECT
THE
FILES
YOU
WANT
TO
COMPRESS
WHICH
IN
THIS
CASE
IS
JUST
HELLO
JAVA
WE
CAN
CREATE
HELLO
CLASS
FROM
THAT
SO
NO
NEED
TO
SUBMIT
IT
RIGHT
CLICK
AND
SAY
SEND
TO
COMPRESSED
ZIPPED
FOLDER
THIS
WILL
CREATE
HELLO
ZIP
NOW
GO
TO
THE
SUBMISSION
SITE
IN
YOUR
PREFERRED
WEB
BROWSER
LOG
IN
WITH
YOUR
PITT
EDU
EMAIL
ADDRESS
INCLUDE
THE
PITT
EDU
PART
AND
PEOPLESOFT
NUMBER
CLICK
THE
BROWSE
BUTTON
AND
NAVIGATE
TO
YOUR
HELLO
ZIP
FILE
IN
YOUR
DOCUMENTS
FOLDER
SELECT
IT
FOR
OPENING
AND
THEN
ON
THE
WEBPAGE
CLICK
THE
SEND
BUTTON
IF
YOU
TRY
THIS
FROM
OFF
CAMPUS
YOU
WILL
BE
MET
WITH
AN
UNAUTHORIZED
ERROR
PAGE
GO
INSTEAD
TO
THE
DIRECSTONS
ON
THAT
DUE
WEDNESDAY
MARCH
YOUR
THIRD
PROJECT
IS
TO
IMPLEMENT
THE
GAME
OF
MASTERMIND
IN
THIS
GAME
THE
COMPUTER
CHOOSES
PEGS
EACH
WITH
ONE
OF
COLORS
THE
PLAYER
JOB
IS
THEN
TO
GUESS
THE
COLORS
THAT
THE
COMPUTER
HAS
CHOSEN
IN
THE
PROPER
ORDER
AER
EACH
GUESS
BY
THE
PLAYER
IF
THE
PLAYER
GUESS
IS
NOT
CORRECT
THE
COMPUTER
WILL
GIVE
TWO
NUMBERS
AS
FEEDBACK
THE
FIRST
NUMBER
IS
HOW
MANY
PEGS
ARE
THE
PROPER
COLOR
AND
IN
THE
PROPER
POSITION
THE
SECOND
NUMBER
IS
HOW
MANY
PEGS
ARE
THE
PROPER
COLOR
BUT
NOT
IN
THE
CORRECT
POSITION
THE
GAME
ENDS
WHEN
THE
COLOR
STRING
IS
CORRECT
AND
THE
PLAYER
WINS
OR
THEY
GIVE
INCORRECT
GUESSES
AND
THEY
LOSE
WHAT
YOU
NEED
TO
DO
GENERATE
A
RANDOM
COMPUTER
GUESS
OF
FOUR
COLORS
OUT
OF
RED
ORANGE
YELLOW
GREEN
BLUE
PURPLE
READ
A
GUESS
FROM
THE
USER
AS
A
STRING
OF
COLORS
SCORE
THE
GUESS
AND
REPORT
THE
TWO
VALUES
BACK
TO
THE
USER
ALLOW
THE
USER
TO
CONTINUE
TO
GUESS
UNTIL
THEY
GET
IT
CORRECT
OR
REACH
TURNS
AND
THEY
LOSE
ALLOW
THE
USER
TO
PLAY
THE
GAME
MULTIPLE
TIMES
EXAMPLE
WELCOME
TO
MASTERMIND
WOULD
YOU
LIKE
TO
PLAY
YES
ENTER
GUESS
NUMBER
RRRR
COLORS
IN
THE
CORRECT
PLACE
COLORS
CORRECT
BUT
IN
WRONG
POSITION
ENTER
GUESS
NUMBER
MODEL
VIEW
CONTROLLER
A
COMMON
PATIERN
FOR
WRITING
PROGRAMS
IS
KNOWN
AS
MVC
MODEL
VIEW
CONTROLLER
THIS
PATIERN
APPLIES
WHENEVER
WE
HAVE
SOME
PROBLEM
WE
CAN
MODEL
LIKE
A
GAME
BOARD
AND
A
USER
INTERFACE
THAT
DISPLAYS
AND
INTERACTS
WITH
THAT
MODEL
THE
VIEW
THE
CONTROLLER
IS
THE
CODE
THAT
MANIPULATES
THE
MODEL
IN
RESPONSE
TO
ACTIONS
FROM
THE
VIEW
THE
IDEA
OF
MVC
IS
THAT
EACH
PART
OF
THE
PROGRAM
IS
SUFFICIENTLY
ABSTRACTED
FROM
EACH
OTHER
THAT
THEY
CAN
CHANGE
WITHOUT
NEEDING
TO
MODIFY
THE
OTHER
PARTS
FOR
INSTANCE
OUR
VIEW
IS
CURRENTLY
A
TEXTUAL
INTERFACE
BUT
LATER
IN
THE
COURSE
WE
COULD
ALTER
THIS
TO
BE
A
GRAPHICAL
USER
INTERFACE
IF
WE
DID
THAT
IDEALLY
WE
WOULD
NOT
NEED
TO
CHANGE
THE
MODEL
OR
THE
CONTROLLER
ONLY
THE
VIEW
CODE
FOR
US
THE
IMPLEMENTATION
OF
THE
MODEL
IS
VERY
SIMPLE
EITHER
AN
ARRAY
OR
STRING
OF
COLORS
INTS
CHARS
ETC
THAT
REPRESENTS
THE
RANDOMLY
CHOSEN
COLORS
WE
ARE
TRYING
TO
GUESS
THE
VIEW
IS
A
SIMPLE
TEXT
BASED
PROGRAM
AS
WE
VE
WRITIEN
MANY
TIMES
SO
FAR
IT
WILL
PROMPT
THE
USER
FOR
THEIR
GUESSES
AND
DISPLAY
IF
THE
GUESS
IS
CORRECT
OR
SHOW
THE
TWO
STATISTICS
THAT
WE
MUST
CALCULATE
THE
CONTROLLER
LINKS
THESE
TWO
THINGS
TOGETHER
WE
WILL
THEN
MAKE
THREE
CLASSES
A
MAIN
CLASS
NAMED
MASTERMIND
THAT
SERVES
AS
OUR
VIEW
CREATES
THE
MODEL
AND
CONTROLLER
AND
DEALS
WITH
USER
MASTERMIND
HTTP
PEOPLE
CS
PITT
EDU
JMISURDA
TEACHING
HTM
A
MAIN
CLASS
NAMED
MASTERMIND
THAT
SERVES
AS
OUR
VIEW
CREATES
THE
MODEL
AND
CONTROLLER
AND
DEALS
WITH
USER
INPUT
AND
OUTPUT
A
MODEL
CLASS
NAMED
MASTERMINDMODEL
THAT
STORES
THE
REPRESENTATION
OF
THE
COMPUTER
GUESS
AND
USES
A
CONSTRUCTOR
AND
ACCESSORS
TO
CREATE
AND
QUERY
THE
SOLUTION
THE
PLAYER
IS
TRYING
TO
GUESS
DEFINED
AS
FOLLOWS
CLASS
MASTERMINDMODEL
PRIVATE
VARIABLE
TO
STORE
THE
ANSWER
PUBLIC
MASTERMINDMODEL
MAKE
THE
ANSWER
PUBLIC
CHAR
GETCOLORAT
INT
INDEX
RETURN
COLOR
AT
POSITION
INDEX
AS
A
CHAR
FIRST
CONVERTED
IF
STORED
AS
A
NUMBER
A
CONTROLLER
CLASS
NAMED
MASTERMINDCONTROLLER
THAT
IS
DEFINED
AS
FOLLOWS
CLASS
MASTERMINDCONTROLLER
PUBLIC
MASTERMINDCONTROLLER
MASTERMINDMODEL
MODEL
PUBLIC
BOOLEAN
ISCORRECT
STRING
GUESS
PUBLIC
INT
GETRIGHTCOLORRIGHTPLACE
STRING
GUESS
PUBLIC
INT
GETRIGHTCOLORWRONGPLACE
STRING
GUESS
YOU
ARE
TO
PROVIDE
THE
IMPLEMENTATION
OF
ALL
THREE
CLASSES
BUT
YOU
MUST
DEFINE
YOUR
CONTROLLER
AND
MODEL
USING
AT
LEAST
THE
METHODS
ABOVE
ANY
ADDITIONAL
METHODS
OR
FIELDS
YOU
WANT
TO
ADD
MUST
BE
PRIVATE
TO
YOUR
CLASSES
HINTS
AND
NOTES
FOR
RIGHT
COLOR
WRONG
PLACE
YOU
WILL
NEED
TO
NOT
COUNT
COLORS
FROM
THE
GUESS
THAT
ARE
THE
RIGHT
COLOR
IN
THE
RIGHT
PLACE
YOU
ALSO
NEED
TO
AVOID
DOUBLE
COUNTING
A
COLOR
AS
BEING
IN
THE
WRONG
POSITION
TO
HELP
YOU
SOLVE
THESE
ISSUES
YOU
MAY
FIND
IT
NECESSARY
TO
MAKE
SOME
AUXILIARY
ARRAYS
THAT
KEEP
TRACK
OF
WHAT
YOU
HAVE
USED
ALREADY
YOU
MAY
WANT
TO
PLAY
THE
GAME
ON
PAPER
WHERE
YOU
CONSIDER
VARIOUS
GUESSES
AND
SOLUTIONS
AND
SCORE
THEM
TO
SEE
THE
ISSUE
THE
PERFECT
PLAYER
CAN
ALWAYS
WIN
THIS
GAME
IN
GUESSES
OR
LESS
SUBMISSION
CREATE
A
MASTERMIND
ZIP
FILE
THAT
CONTAINS
YOUR
THREE
JAVA
FILES
UPLOAD
IT
TO
THE
SUBMISSION
WEBSITE
AS
WE
HAVE
BEEN
DOING
WITH
LABS
MAKE
SURE
TO
DO
THIS
PRIOR
TO
THE
DEADLINE
NO
LATE
WORK
IS
ACCEPTED
IF
PRIOR
TO
THE
DEADLINE
YOU
REALIZE
THAT
YOU
NEED
TO
SUBMIT
A
DIFFERENT
VERSION
OF
YOUR
CODE
NAME
IT
MASTERMIND
ZIP
YOU
CAN
ADD
NEW
NUMBERS
AS
NECESSARY
BUT
TRY
NOT
TO
SUBMIT
MANY
TIMES
WE
WILL
GRADE
THE
LAST
SUBMISSION
DUE
ALL
SOURCE
FILES
PLUS
A
COMPLETED
ASSIGNMENT
INFORMATION
SHEET
ZIPPED
INTO
A
SINGLE
ZIP
FILE
AND
SUBMITTED
PROPERLY
TO
THE
SUBMISSION
SITE
BY
ON
FRIDAY
JANUARY
NOTE
SEE
THE
SUBMISSION
INFORMATION
PAGE
FOR
SUBMISSION
DETAILS
LATE
DUE
DATE
ON
MONDAY
JANUARY
PURPOSE
TO
REFRESH
YOUR
JAVA
PROGRAMMING
SKILLS
AND
TO
EMPHASIZE
THE
OBJECTORIENTED
PROGRAMMING
APPROACH
USED
IN
JAVA
SPECIFICALLY
YOU
WILL
WORK
WITH
CONTROL
STRUCTURES
CLASSBUILDING
INTERFACES
AND
GENERICS
TO
CREATE
AND
UTILIZE
A
SIMPLE
ARRAYBASED
DATA
STRUCTURE
GOAL
TO
DESIGN
AND
IMPLEMENT
A
SIMPLE
CLASS
MULTIDS
T
THAT
WILL
ACT
AS
A
SIMPLE
DATA
STRUCTURE
FOR
ACCESSING
JAVA
OBJECTS
YOUR
MULTIDS
T
CLASS
WILL
PRIMARILY
IMPLEMENT
INTERFACES
PRIMQ
T
AND
REORDER
THE
DETAILS
OF
THESE
INTERFACES
ARE
EXPLAINED
IN
THE
FILES
PRIMQ
JAVA
AND
REORDER
JAVA
READ
THESE
FILES
OVER
VERY
CAREFULLY
BEFORE
IMPLEMENTING
YOUR
MULTIDS
T
CLASS
GOAL
TO
UTILIZE
YOUR
MULTIDS
T
CLASS
BY
IMPLEMENTING
A
SIMPLE
VERSION
OF
THE
CARD
GAME
WAR
IN
THIS
CASE
YOUR
PROGRAM
WILL
BE
A
CLIENT
USING
MULTIDS
T
AND
THE
DETAILS
OF
THE
MULTIDS
T
IMPLEMENTATION
WILL
BE
ABSTRACTED
OUT
DETAILS
FOR
THE
DETAILS
ON
THE
FUNCTIONALITY
OF
YOUR
MULTIDS
T
CLASS
CAREFULLY
READ
OVER
THE
FILES
PRIMQ
JAVA
REORDER
JAVA
AND
JAVA
PROVIDED
ON
THE
WEB
SITE
YOU
MUST
USE
THESE
FILES
AS
SPECIFIED
AND
CANNOT
REMOVE
ALTER
ANY
OF
THE
CODE
THAT
IS
ALREADY
WRITTEN
IN
THEM
THERE
ARE
DIFFERENT
WAYS
OF
IMPLEMENTING
THE
PRIMQ
T
AND
REORDER
INTERFACE
METHODS
SOME
OF
WHICH
ARE
MORE
EFFICIENT
THAN
OTHERS
TRY
TO
THINK
OF
THE
BEST
WAY
OF
IMPLEMENTING
THESE
METHODS
IN
THIS
ASSIGNMENT
BUT
THE
MOST
IMPORTANT
THING
AT
THIS
POINT
IS
GETTING
THEM
TO
WORK
I
RECOMMEND
A
LOT
OF
PENCIL
AND
PAPER
WORK
BEFORE
ACTUALLY
STARTING
TO
WRITE
YOUR
CODE
LATER
WE
WILL
DISCUSS
THE
RELATIVE
MERITS
OF
DIFFERENT
IMPLEMENTATIONS
YOUR
MULTIDS
T
CLASS
HEADER
SHOULD
BE
PUBLIC
CLASS
MULTIDS
T
IMPLEMENTS
PRIMQ
T
REORDER
IMPORTANT
NOTE
THE
PRIMARY
DATA
WITHIN
YOUR
MULTIDS
T
CLASS
MUST
BE
AN
ARRAY
YOU
MAY
NOT
USE
ANY
PREDEFINED
JAVA
COLLECTION
CLASS
FOR
YOUR
MULTIDS
T
DATA
AFTER
YOU
HAVE
FINISHED
YOUR
CODING
OF
MULTIDS
T
THE
JAVA
FILE
PROVIDED
FOR
YOU
SHOULD
COMPILE
AND
RUN
CORRECTLY
AND
SHOULD
GIVE
OUTPUT
IDENTICAL
TO
THE
OUTPUT
SHOWN
IN
THE
SAMPLE
EXECUTIONS
EXCEPT
FOR
THE
SEGMENTS
WHERE
THE
DATA
IS
SHUFFLED
SINCE
IT
WILL
BE
PSEUDORANDOM
IN
THAT
CASE
DETAILS
WAR
IS
A
CARD
GAME
PLAYED
OFTEN
BY
CHILDREN
THAT
HAS
MANY
VARIATIONS
YOU
WILL
IMPLEMENT
THE
SIMPLE
VERSION
AS
DESCRIBED
BELOW
INITIALLY
SHUFFLE
A
STANDARD
DECK
OF
CARDS
DEAL
THE
CARDS
OUT
COMPLETELY
TO
TWO
PLAYERS
ALTERNATING
CARDS
TO
EACH
PLAYER
DO
THE
FOLLOWING
UNTIL
ONE
PLAYER
IS
OUT
OF
CARDS
OR
UNTIL
A
SET
NUMBER
OF
ROUNDS
HAVE
COMPLETED
EACH
PLAYER
PLAYS
THE
TOP
CARD
IN
HIS
HER
HAND
IF
ONE
PLAYER
CARD
BEATS
THE
OTHER
HAS
A
HIGHER
RANK
SUITS
DON
T
MATTER
THAT
PLAYER
PUTS
BOTH
CARDS
INTO
HIS
DISCARD
PILE
IF
THE
PLAYERS
TIE
IT
IS
A
WAR
SO
DO
THE
FOLLOWING
UNTIL
THE
WAR
IS
RESOLVED
EACH
PLAYER
PLAYS
A
CARD
WITHOUT
COMPARING
EACH
PLAYER
PLAYS
ONE
MORE
CARD
AND
COMPARES
IN
THE
SAME
WAY
AS
ABOVE
THE
WINNER
OF
THE
WAR
TAKES
ALL
PLAYED
CARDS
INITIALLY
COMPARED
CARDS
UNCOMPARED
CARDS
SECOND
COMPARED
CARDS
FOR
A
SINGLE
WAR
THIS
WILL
BE
TOTAL
CARDS
IF
THE
WAR
CARDS
ALSO
YIELD
A
TIE
REPEAT
THE
PROCESS
ONE
UNCOMPARED
CARD
ONE
COMPARED
CARD
UNTIL
THERE
IS
A
WINNER
THUS
A
SINGLE
ROUND
OF
THE
GAME
COULD
IN
FACT
HAVE
AN
ARBITRARY
NUMBER
OF
CARD
COMPARISONS
AND
PUT
AN
ARBITRARY
NUMBER
OF
CARDS
AT
RISK
THE
FOLLOWING
RULES
ALSO
APPLY
TO
THE
GAME
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
IF
AT
ANY
POINT
IN
THE
GAME
A
PLAYER
HAND
IS
EMPTY
THE
PLAYER
SHOULD
MOVE
THE
CARDS
IN
HIS
DISCARD
PILE
INTO
HIS
HAND
AND
SHUFFLE
THEM
IF
AT
ANY
POINT
IN
THE
GAME
EVEN
IN
THE
MIDDLE
OF
A
ROUND
A
PLAYER
HAS
NO
CARDS
REMAINING
IN
BOTH
HIS
HER
HAND
AND
HIS
HER
DISCARD
PILE
HE
SHE
HAS
LOST
THE
GAME
IF
THE
BOTH
PLAYERS
HAVE
CARDS
REMAINING
AFTER
A
SET
NUMBER
OF
ROUNDS
CAN
VARY
THE
PLAYER
WITH
THE
MOST
CARDS
HAND
DISCARD
PILE
IS
THE
WINNER
IN
THIS
CASE
IT
IS
POSSIBLE
FOR
A
TIE
TO
OCCUR
WITH
EACH
PLAYER
HAVING
CARDS
IMPLEMENTATION
REQUIREMENTS
YOUR
INITIAL
CARD
DECK
THE
PLAYER
HANDS
THE
PLAYER
DISCARD
PILES
AND
THE
CARDS
IN
PLAY
MUST
ALL
BE
STORED
IN
MULTIDS
CARD
OBJECTS
THE
CARD
CLASS
MUST
BE
USED
AS
PROVIDED
AND
CANNOT
BE
CHANGED
THE
MAXIMUM
NUMBER
OF
ROUNDS
FOR
THE
GAME
MUST
BE
READ
IN
FROM
THE
COMMAND
LINE
TO
ALLOW
BETTER
TESTING
OF
YOUR
PROGRAM
YOU
MUST
OUTPUT
WHEN
WARS
OCCUR
AND
WHEN
DISCARD
PILES
ARE
RESHUFFLED
SEE
THE
VARIOUS
SAMPLE
OUTPUT
FILES
FOR
REQUIRED
OUTPUT
INFORMATION
YOU
MUST
SUBMIT
IN
A
SINGLE
ZIP
FILE
MINIMALLY
THE
FOLLOWING
COMPLETE
WORKING
SOURCE
FILES
FOR
FULL
CREDIT
PRIMQ
JAVA
REORDER
JAVA
JAVA
CARD
JAVA
THE
ABOVE
FOUR
FILES
ARE
GIVEN
TO
YOU
AND
MUST
NOT
BE
ALTERED
IN
ANY
WAY
MULTIDS
JAVA
WAR
JAVA
THE
ABOVE
TWO
FILES
MUST
BE
CREATED
SO
THAT
THEY
WORK
AS
DESCRIBED
IF
YOU
CREATE
ANY
ADDITIONAL
FILES
BE
SURE
TO
INCLUDE
THOSE
AS
WELL
THE
IDEA
FROM
YOUR
SUBMISSION
IS
THAT
YOUR
TA
CAN
UNZIP
YOUR
ZIP
FILE
THEN
COMPILE
AND
RUN
BOTH
OF
THE
MAIN
PROGRAMS
JAVA
AND
WAR
JAVA
FROM
THE
COMMAND
LINE
WITHOUT
ANY
ADDITIONAL
FILES
OR
CHANGES
SO
BE
SURE
TO
TEST
IT
THOROUGHLY
BEFORE
SUBMITTING
IT
IF
YOU
CANNOT
GET
THE
PROGRAMS
WORKING
AS
GIVEN
CLEARLY
INDICATE
ANY
CHANGES
YOU
MADE
AND
CLEARLY
INDICATE
WHY
EX
I
COULD
NOT
GET
THE
REVERSE
METHOD
TO
WORK
SO
I
ELIMINATED
CODE
THAT
USED
IT
ON
YOUR
ASSIGNMENT
INFORMATION
SHEET
YOU
WILL
LOSE
SOME
CREDIT
FOR
NOT
GETTING
IT
TO
WORK
PROPERLY
BUT
GETTING
THE
MAIN
PROGRAMS
TO
WORK
WITH
MODIFICATIONS
IS
BETTER
THAN
NOT
GETTING
THEM
TO
WORK
AT
ALL
SEE
THE
CS
WEB
SITE
FOR
AN
ASSIGNMENT
INFORMATION
SHEET
TEMPLATE
YOU
DO
NOT
HAVE
TO
USE
THIS
TEMPLATE
BUT
YOUR
SHEET
SHOULD
CONTAIN
THE
SAME
INFORMATION
NOTE
IF
YOU
USE
AN
IDE
SUCH
AS
NETBEANS
TO
DEVELOP
YOUR
PROGRAMS
MAKE
SURE
THEY
WILL
COMPILE
AND
RUN
ON
THE
COMMAND
LINE
BEFORE
SUBMITTING
THIS
MAY
REQUIRE
SOME
MODIFICATIONS
TO
YOUR
PROGRAM
SUCH
AS
REMOVING
SOME
PACKAGE
INFORMATION
HINTS
NOTES
SEE
PROGRAM
JAVA
FOR
SOME
HELP
WITH
THE
CARD
CLASS
AND
USING
THE
MULTIDS
T
CLASS
WITH
CARD
OBJECTS
SEE
FILE
TXT
TO
SEE
HOW
YOUR
OUTPUT
FOR
SHOULD
LOOK
AS
NOTED
YOUR
OUTPUT
WHEN
RUNNING
JAVA
SHOULD
BE
IDENTICAL
TO
THIS
WITH
THE
EXCEPTION
OF
THE
ORDER
OF
THE
VALUES
AFTER
BEING
SHUFFLED
SEE
FILES
TXT
TXT
TXT
FOR
EXAMPLE
RUNS
OF
MY
WAR
JAVA
PROGRAM
YOUR
WAR
PROGRAM
OUTPUT
DOES
NOT
HAVE
TO
LOOK
EXACTLY
LIKE
THIS
BUT
THE
FUNCTIONALITY
SHOULD
BE
THE
SAME
YOUR
MULTIDS
T
CLASS
WILL
NEED
TO
ALLOW
FOR
A
VARIABLE
NUMBER
OF
OBJECTS
UP
TO
SOME
MAXIMUM
NUMBER
SET
BY
THE
INITIAL
SIZE
YOU
CAN
IMPLEMENT
THIS
BY
HAVING
AN
INTEGER
INSTANCE
VARIABLE
EX
COUNT
THAT
INDICATES
HOW
MANY
SLOTS
IN
THE
MULTIDS
T
ARE
FILLED
FOR
EXAMPLE
YOU
COULD
HAVE
A
MULTIDS
CARD
WITH
A
CAPACITY
OF
FOR
YOUR
HANDS
FOR
A
HAND
WITH
ANYWHERE
FROM
UP
TO
CARDS
IN
IT
IN
THIS
CASE
THE
ARRAY
LENGTH
I
E
PHYSICAL
SIZE
WOULD
BE
BUT
THE
COUNT
I
E
LOGICAL
SIZE
WOULD
BE
SOME
VALUE
BETWEEN
AND
WHEN
IMPLEMENTING
MULTIDS
T
BE
CAREFUL
TO
USE
THE
COUNT
VALUE
RATHER
THAN
THE
ARRAY
LENGTH
WHEN
DOING
OPERATIONS
SUCH
AS
THE
TOSTRING
METHOD
ONLINE
WEDNESDAY
FEBRUARY
DUE
ALL
SOURCE
JAVA
AND
DATA
FILES
PLUS
A
COMPLETED
ASSIGNMENT
INFORMATION
SHEET
ZIPPED
INTO
A
SINGLE
ZIP
FILE
AND
SUBMITTED
TO
THE
PROPER
DIRECTORY
IN
THE
SUBMISSION
SITE
BY
ON
THURSDAY
MARCH
NOTE
SEE
THE
SUBMISSION
INFORMATION
PAGE
FOR
SUBMISSION
DETAILS
LATE
DUE
DATE
ON
SATURDAY
MARCH
PURPOSE
WE
HAVE
DISCUSSED
RECURSION
AND
IN
PARTICULAR
BACKTRACKING
ALGORITHMS
SUCH
AS
EIGHT
QUEENS
IN
THIS
ASSIGNMENT
YOU
WILL
GET
SOME
PRACTICE
AT
RECURSIVE
PROGRAMMING
BY
WRITING
A
BACKTRACKING
ALGORITHM
TO
FIND
PHRASES
IN
A
PUZZLE
IDEA
WORD
SEARCH
PUZZLES
ARE
COMMON
IN
NEWSPAPERS
ON
RESTAURANT
PLACEMATS
AND
EVEN
IN
THEIR
OWN
COLLECTIONS
WITHIN
BOOKS
THESE
VARY
IN
FORMAT
FROM
PUZZLE
TO
PUZZLE
BUT
ONE
COMMON
FORMAT
IS
AS
FOLLOWS
A
USER
IS
PRESENTED
WITH
A
GRID
OF
LETTERS
AND
A
LIST
OF
WORDS
THE
USER
MUST
FIND
ALL
OF
THE
WORDS
FROM
THE
LIST
WITHIN
THE
GRID
INDICATING
WHERE
THEY
ARE
BY
DRAWING
OVALS
AROUND
THEM
WORDS
MAY
BE
FORMED
IN
ANY
DIRECTION
UP
DOWN
LEFT
OR
RIGHT
WE
WILL
NOT
ALLOW
DIAGONALS
EVEN
THOUGH
MOST
PUZZLES
DO
ALLOW
THEM
BUT
ALL
OF
THE
LETTERS
IN
A
WORD
MUST
BE
IN
A
STRAIGHT
LINE
THIS
IDEA
CAN
BE
EXTENDED
TO
ALLOW
PHRASES
TO
BE
EMBEDDED
IN
THE
GRIDS
HOWEVER
REQUIRING
AN
ENTIRE
PHRASE
TO
BE
IN
A
STRAIGHT
LINE
ON
THE
BOARD
IS
NOT
PRACTICAL
AS
THE
DIMENSIONS
OF
THE
BOARD
WOULD
NEED
TO
BE
OVERLY
LARGE
THEREFORE
WE
WILL
STILL
REQUIRE
THE
LETTERS
IN
EACH
WORD
TO
BE
IN
A
STRAIGHT
LINE
BUT
WE
ARE
ALLOWED
TO
CHANGE
DIRECTION
BETWEEN
WORDS
FOR
EXAMPLE
WE
MIGHT
BE
GIVEN
THE
FOLLOWING
GRID
OF
LETTERS
AND
THE
FOLLOWING
PHRASES
ABSTRACT
ABSTRACT
DATA
TYPES
ABSTRACT
DATA
TYPES
ARE
REALLY
COOL
ABSTRACT
DATA
TYPES
ARE
REALLY
AWESOME
UPON
SEARCHING
ASSUMING
THE
GRID
STARTS
IN
THE
UPPER
LEFT
CORNER
WITH
POSITION
AND
THAT
THE
ROW
IS
THE
FIRST
COORDINATE
ABSTRACT
WOULD
BE
FOUND
IN
TWO
PLACES
TO
AND
TO
ABSTRACT
DATA
TYPES
WOULD
ALSO
BE
FOUND
IN
TWO
PLACES
TO
TO
TO
AND
TO
TO
TO
ABSTRACT
DATA
TYPES
ARE
REALLY
COOL
WOULD
BE
FOUND
AT
TO
TO
TO
TO
TO
TO
ABSTRACT
DATA
TYPES
ARE
REALLY
AWESOME
WOULD
NOT
BE
FOUND
DETAILS
YOUR
TASK
IS
TO
WRITE
A
JAVA
PROGRAM
TO
READ
IN
A
GRID
OF
LETTERS
FROM
A
FILE
AND
THEN
INTERACTIVELY
ALLOW
A
USER
TO
ENTER
PHRASES
UNTIL
HE
OR
SHE
WANTS
TO
QUIT
FOR
EACH
PHRASE
YOUR
PROGRAM
MUST
OUTPUT
WHETHER
OR
NOT
THE
PHRASE
IS
FOUND
AND
IF
FOUND
SPECIFICALLY
WHERE
IT
IS
LOCATED
INPUT
DETAILS
THE
GRID
OF
LETTERS
FOR
YOUR
PROGRAM
WILL
BE
STORED
IN
A
TEXT
FILE
FORMATTED
AS
FOLLOWS
LINE
TWO
INTEGERS
R
AND
C
SEPARATED
BY
A
SINGLE
BLANK
SPACE
THESE
WILL
REPRESENT
THE
NUMBER
OF
ROWS
R
AND
COLUMNS
C
IN
THE
GRID
REMAINING
LINES
R
LINES
CONTAINING
C
LOWER
CASE
CHARACTERS
EACH
THE
USER
INPUT
WILL
BE
PHRASES
OF
WORDS
WITH
A
SINGLE
SPACE
BETWEEN
EACH
WORD
AND
NO
PUNCTUATION
EACH
PHRASE
WILL
BE
ENTERED
ON
A
SINGLE
LINE
THE
USER
MAY
ENTER
EITHER
UPPER
OR
LOWER
CASE
LETTERS
BUT
THE
STRING
SHOULD
BE
CONVERTED
TO
LOWER
CASE
BEFORE
SEARCHING
THE
GRID
THE
PROGRAM
WILL
END
WHEN
THE
USER
ENTERS
NO
DATA
FOR
THE
CURRENT
PHRASE
I
E
HITS
ENTER
WITHOUT
TYPING
ANY
CHARACTERS
BEFOREHAND
OUTPUT
DETAILS
IF
A
PHRASE
IS
NOT
FOUND
IN
THE
GRID
THE
OUTPUT
SHOULD
SIMPLY
STATE
THAT
FACT
IF
A
PHRASE
IS
FOUND
IN
THE
GRID
YOUR
PROGRAM
MUST
FIND
ONE
OCCURRENCE
OF
THE
PHRASE
AND
THE
OUTPUT
MUST
INDICATE
THIS
FACT
IN
TWO
WAYS
SHOW
THE
COORDINATES
OF
EACH
WORD
IN
THE
PHRASE
AS
A
PAIR
OF
ROW
COLUMN
PAIRS
SHOW
THE
GRID
WITH
THE
LETTERS
OF
THE
PHRASE
INDICATED
IN
UPPER
CASE
FOR
EXAMPLE
FOR
THE
GRID
ABOVE
AND
THE
PHRASE
ABSTRACT
DATA
TYPES
YOUR
OUTPUT
WOULD
BE
ABSTRACT
TO
DATA
TO
TYPES
TO
ALGORITHM
DETAILS
YOUR
SEARCH
ALGORITHM
MUST
BE
A
RECURSIVE
BACKTRACKING
ALGORITHM
NOTE
THAT
YOU
DO
NOT
NEED
RECURSION
TO
MATCH
THE
LETTERS
WITHIN
INDIVIDUAL
WORDS
ALTHOUGH
YOU
MAY
DO
THIS
RECURSIVELY
IF
YOU
PREFER
WHERE
THE
RECURSION
IS
NECESSARY
IS
WHEN
MOVING
FROM
ONE
WORD
TO
THE
NEXT
SINCE
IT
IS
HERE
WHERE
YOU
MAY
CHANGE
DIRECTION
TO
MAKE
THE
PROGRAM
MORE
CONSISTENT
AND
EASIER
TO
GRADE
WE
WILL
HAVE
THE
FOLLOWING
REQUIREMENTS
FOR
THE
RECURSIVE
PROCESS
NO
LETTER
LOCATION
ON
THE
GRID
MAY
APPEAR
MORE
THAN
ONE
TIME
IN
ANY
PART
OF
A
SOLUTION
WHEN
GIVEN
A
CHOICE
OF
DIRECTIONS
THE
OPTIONS
MUST
BE
TRIED
IN
THE
FOLLOWING
ORDER
RIGHT
DOWN
LEFT
UP
GIVEN
THIS
ORDERING
AND
THE
GRID
ABOVE
THE
SOLUTION
FOR
ABSTRACT
DATA
WOULD
BE
TO
TO
RATHER
THAN
TO
TO
SINCE
THE
RIGHT
DIRECTION
IS
TRIED
BEFORE
THE
LEFT
DIRECTION
IF
THE
LAST
LETTER
IN
A
WORD
IS
AT
LOCATION
I
J
THE
FIRST
LETTER
OF
THE
NEXT
WORD
MUST
BE
AT
ONE
OF
LOCATIONS
I
J
I
J
I
OR
J
THE
DIRECTION
CHOSEN
TO
FIND
THE
FIRST
LETTER
OF
A
WORD
IS
THE
SAME
DIRECTION
THAT
MUST
BE
USED
FOR
ALL
OF
THE
LETTERS
OF
THE
WORD
FOR
EXAMPLE
IN
THE
GRID
SHOWN
ABOVE
FOR
THE
PHRASE
ABSTRACT
DATA
THE
FOLLOWING
WOULD
NOT
BE
A
VALID
SOLUTION
TO
TO
THIS
SOLUTION
IS
NOT
LEGAL
BECAUSE
WE
PROCEEDED
RIGHT
FROM
THE
T
OF
ABSTRACT
TO
FIND
THE
D
IN
DATA
BUT
THEN
PROCEEDED
DOWN
TO
FIND
THE
REMAINING
LETTERS
IN
DATA
SIMILARLY
ALSO
IN
THE
GRID
SHOWN
ABOVE
FOR
THE
PHRASE
ABSTRACT
DATA
TYPES
ARE
THE
FOLLOWING
WOULD
NOT
BE
A
VALID
SOLUTION
TO
TO
TO
TO
THIS
SOLUTION
IS
NOT
LEGAL
BECAUSE
WE
PROCEEDED
DOWN
FROM
THE
S
OF
TYPES
TO
FIND
THE
A
IN
ARE
BUT
THEN
PROCEEDED
RIGHT
TO
FIND
THE
REMAINING
LETTERS
IN
ARE
THE
IDEA
IS
THAT
YOU
ARE
BUILDING
A
SOLUTION
WORD
BY
WORD
EACH
TIME
YOU
COMPLETE
A
WORD
YOU
CAN
LOOK
FOR
THE
NEXT
WORD
IN
ANY
OF
THE
FOUR
DIRECTIONS
THIS
IS
WHERE
THE
RECURSION
OCCURS
IF
THE
NEXT
WORD
CANNOT
BE
FOUND
IN
ANY
OF
THE
DIRECTIONS
YOU
MUST
DELETE
THE
MOST
RECENTLY
COMPLETED
WORD
AND
BACKTRACK
TO
THE
PREVIOUS
WORD
FOR
EXAMPLE
CONSIDER
THE
BOARD
ABOVE
WITH
THE
SEARCH
PHRASE
DATA
TYPES
ARE
REALLY
THE
ALGORITHM
FIRST
TRIES
TO
FIND
THE
WORD
DATA
STARTING
AT
POSITION
IT
TRIES
IN
ALL
FOUR
DIRECTIONS
AND
DOES
NOT
SUCCEED
IT
PROCEEDS
THROUGH
THE
OTHER
STARTING
POSITIONS
UNTIL
IT
FINDS
DATA
IN
LOCATIONS
TO
IT
NOW
RECURSIVELY
TRIES
TO
FIND
TYPES
IN
THE
FOLLOWING
WAYS
GOING
RIGHT
TO
POSITION
THIS
WILL
NOT
WORK
SINCE
IS
ALREADY
BEING
USED
IN
DATA
GOING
DOWN
TO
POSITION
THIS
WILL
SUCCEED
AND
TYPES
IS
FOUND
IN
LOCATIONS
TO
THE
ALGORITHM
NOW
RECURSES
AGAIN
THIS
TIME
LOOKING
FOR
ARE
IN
THE
FOLLOWING
WAYS
GOING
RIGHT
TO
POSITION
THIS
WILL
SUCCEED
AND
ARE
IS
FOUND
IN
LOCATIONS
TO
THE
ALGORITHM
NOW
RECURSES
AGAIN
THIS
TIME
LOOKING
FOR
REALLY
IN
THE
FOLLOWING
WAYS
GOING
RIGHT
TO
POSITION
THIS
WILL
NOT
WORK
SINCE
CHARACTER
IS
AN
GOING
DOWN
TO
POSITION
THIS
WILL
NOT
WORK
SINCE
CHARACTER
IS
A
D
GOING
LEFT
TO
POSITION
THIS
WILL
NOT
WORK
SINCE
IS
ALREADY
BEING
USED
IN
ARE
GOING
UP
TO
POSITION
THIS
WILL
NOT
WORK
SINCE
CHARACTER
IS
A
D
SINCE
ALL
DIRECTIONS
HAVE
BEEN
TRIED
THE
SEARCH
FOR
REALLY
HAS
FAILED
AND
THE
ALGORITHM
MUST
BACKTRACK
THE
WORD
ARE
IS
REMOVED
AND
THE
PREVIOUS
SEARCH
FOR
ARE
RESUMES
GOING
DOWN
TO
POSITION
THIS
WILL
SUCCEED
AND
ARE
IS
FOUND
IN
LOCATIONS
TO
THE
ALGORITHM
NOW
RECURSES
AGAIN
THIS
TIME
LOOKING
FOR
REALLY
IN
THE
FOLLOWING
WAYS
GOING
RIGHT
TO
POSITION
THIS
WILL
SUCCEED
AND
REALLY
IS
FOUND
IN
LOCATIONS
TO
THE
LAST
WORD
IN
THE
PHRASE
HAS
BEEN
FOUND
AND
THE
ALGORITHM
SUCCEEDS
CLEARLY
MORE
BACKTRACKING
MAY
BE
NECESSARY
IN
OTHER
SITUATIONS
I
RECOMMEND
TRACING
THROUGH
THE
PROCESS
WITH
SOME
EXAMPLE
PHRASES
BEFORE
YOU
START
CODING
YOUR
SOLUTION
A
NONTRIVIAL
PART
OF
THIS
ASSIGNMENT
IS
KEEPING
TRACK
OF
THE
PATH
OF
THE
SOLUTION
AND
PRINTING
THE
PATH
OUT
ONCE
THE
SOLUTION
HAS
BEEN
FOUND
YOU
WILL
LIKELY
NEED
TO
USE
SOME
DATA
STRUCTURE
TO
STORE
UPDATE
THIS
PATH
THINK
CAREFULLY
HOW
YOU
CAN
DO
THIS
PART
OF
THE
ASSIGNMENT
TEST
FILES
I
HAVE
PLACED
SEVERAL
TEST
FILES
AND
SOME
SAMPLE
OUTPUT
ONLINE
SEE
THE
CS
ASSIGNMENTS
PAGE
FOR
THESE
FILES
AND
MAKE
SURE
THAT
YOUR
PROGRAM
WORKS
CORRECTLY
FOR
ALL
OF
THE
SAMPLE
FILES
HELP
CS
COE
SPRING
ASSIGNMENT
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
HELP
IF
YOU
ARE
HAVING
TROUBLE
WITH
RECURSION
AND
BACKTRACKING
THE
PROGRAM
FINDWORD
JAVA
MAY
BE
OF
HELP
TO
YOU
THIS
PROGRAM
FINDS
INDIVIDUAL
WORDS
IN
A
GRID
OF
CHARACTERS
USING
RECURSION
AND
BACKTRACKING
IT
RECURSES
ON
INDIVIDUAL
CHARACTERS
RATHER
THAN
ON
WORDS
BUT
THE
RECURSIVE
PROCESS
IS
SIMILAR
IN
BOTH
PROGRAMS
SEE
ALSO
TEST
FILE
TXT
IMPORTANT
NOTE
THE
CODE
FROM
FINDWORD
JAVA
TO
READ
IN
AND
SET
UP
THE
GRID
CAN
BE
TAKEN
AND
USED
DIRECTLY
IN
YOUR
PROGRAM
IF
YOU
WISH
HOWEVER
YOU
SHOULD
NOT
USE
THE
RECURSIVE
PART
OF
FINDWORD
DIRECTLY
IN
YOUR
PROGRAM
SINCE
IT
IS
NOT
SOLVING
THE
PROBLEM
YOU
ARE
TRYING
TO
SOLVE
FURTHER
YOU
SHOULD
NOT
USE
THIS
CODE
TO
FIND
INDIVIDUAL
WORDS
IN
YOUR
GRID
SINCE
FINDWORD
ALLOWS
DIRECTIONS
TO
CHANGE
WITHIN
A
SINGLE
WORD
WHEREAS
IN
YOUR
ASSIGNMENT
YOU
ARE
ONLY
ALLOWED
TO
CHANGE
DIRECTIONS
BETWEEN
WORDS
SEE
ADDITIONAL
COMMENTS
IN
THE
FINDWORD
JAVA
CODE
SUBMISSION
MAKE
SURE
YOU
SUBMIT
ALL
OF
THE
FOLLOWING
IN
A
SINGLE
ZIP
FILE
ALL
SOURCE
FILES
THAT
YOU
EITHER
WROTE
OR
UTILIZED
EX
FROM
THE
AUTHOR
FILES
CALL
YOUR
MAIN
PROGRAM
FILE
JAVA
ALL
DATA
FILES
YOUR
COMPLETED
ASSIGNMENT
INFORMATION
SHEET
AS
WITH
ASSIGNMENTS
AND
THE
IDEA
FROM
YOUR
SUBMISSION
IS
THAT
YOUR
TA
CAN
COMPILE
AND
RUN
YOUR
PROGRAMS
WITHOUT
ANY
ADDITIONAL
FILES
SO
BE
SURE
TO
TEST
THEM
THOROUGHLY
BEFORE
SUBMITTING
THEM
IF
YOU
USE
AN
IDE
FOR
DEVELOPMENT
MAKE
SURE
YOUR
PROGRAM
RUNS
FROM
THE
COMMAND
LINE
WITHOUT
THE
IDE
BEFORE
SUBMITTING
IT
IF
YOU
CANNOT
GET
THE
PROGRAM
WORKING
AS
SPECIFIED
CLEARLY
INDICATE
ANY
CHANGES
YOU
MADE
AND
CLEARLY
INDICATE
WHY
SO
THAT
THE
TA
CAN
BEST
GIVE
YOU
PARTIAL
CREDIT
EXTRA
CREDIT
IDEA
ALLOW
YOUR
PROGRAM
TO
RECURSE
DIAGONALLY
AS
WELL
AS
HORIZONTALLY
AND
VERTICALLY
IF
YOU
DO
THIS
YOU
WILL
NEED
TO
MAKE
UP
YOUR
OWN
TEST
FILES
TO
DEMONSTRATE
THAT
YOUR
PROGRAM
WORKS
CORRECTLY
PURPOSE
TO
GIVE
YOU
EXPERIENCE
IMPLEMENTING
AND
USING
LINKED
LISTS
GOAL
TO
IMPLEMENT
A
SUBCLASS
OF
LLIST
ACTUALLY
THAT
ADDS
SOME
FUNCTIONALITY
TO
IT
AND
TO
IMPLEMENT
A
SUBCLASS
OF
THAT
CLASS
THAT
CAN
STORE
AND
MANIPULATE
ARBITRARY
LENGTH
INTEGERS
DETAILS
WE
CAN
THINK
OF
A
DECIMAL
INTEGER
AS
A
SEQUENCE
OF
DIGITS
FOR
EXAMPLE
THE
NUMBER
COULD
BE
STORED
AS
THE
DIGIT
FOLLOWED
BY
THE
DIGIT
FOLLOWED
BY
THE
DIGIT
FOLLOWED
BY
THE
DIGIT
WE
CAN
STORE
THESE
DIGITS
IN
AN
ARRAY
OR
AS
IS
REQUIRED
IN
THIS
ASSIGNMENT
IN
A
LINKED
LIST
CLEARLY
TO
PERFORM
OPERATIONS
ON
A
NUMBER
THAT
IS
STORED
IN
THIS
FASHION
WE
MUST
ACCESS
THE
DIGITS
ONE
AT
A
TIME
IN
SOME
SYSTEMATIC
WAY
MORE
SPECIFIC
DETAILS
FOLLOW
BELOW
PART
THE
FIRST
PART
OF
THIS
ASSIGNMENT
IS
TO
WRITE
A
NEW
SUBCLASS
OF
T
CALLED
LINKEDLISTPLUS
T
CLASS
T
IS
MOSTLY
THE
AUTHOR
LLIST
T
CLASS
WITH
A
FEW
CHANGES
I
HAVE
REMOVED
THE
LISTINTERFACE
AND
A
FEW
METHODS
AND
I
HAVE
CHANGED
THE
DATA
FROM
PRIVATE
TO
PROTECTED
THIS
WILL
ALLOW
YOU
TO
ACCESS
THE
INSTANCE
VARIABLES
DIRECTLY
FROM
THE
SUBCLASS
SEE
THE
CODE
IN
JAVA
TO
SEE
HOW
THE
DATA
IS
STORED
AND
HOW
THE
METHODS
ARE
IMPLEMENTED
LINKEDLISTPLUS
WILL
NOT
HAVE
ANY
NEW
INSTANCE
VARIABLES
BUT
WILL
EXTEND
BY
ADDING
THE
FOLLOWING
METHODS
PUBLIC
VOID
LEFTSHIFT
INT
NUM
SHIFT
THE
CONTENTS
OF
THE
LIST
NUM
PLACES
TO
THE
LEFT
ASSUME
THE
BEGINNING
IS
THE
LEFTMOST
NODE
REMOVING
THE
LEFTMOST
NUM
NODES
FOR
EXAMPLE
IF
A
LIST
HAS
NODES
IN
IT
NUMBERED
FROM
TO
A
LEFTSHIFT
OF
WOULD
SHIFT
OUT
NODES
AND
AND
THE
OLD
NODE
WOULD
NOW
BE
NODE
IF
NUM
LEFTSHIFT
SHOULD
DO
NOTHING
AND
IF
NUM
THE
LENGTH
OF
THE
LIST
THE
RESULT
SHOULD
BE
AN
EMPTY
LIST
PUBLIC
VOID
RIGHTSHIFT
INT
NUM
SAME
IDEA
AS
LEFTSHIFT
ABOVE
BUT
IN
THE
OPPOSITE
DIRECTION
FOR
EXAMPLE
IF
A
LIST
HAS
NODES
IN
IT
NUMBERED
FROM
TO
A
RIGHTSHIFT
OF
WOULD
SHIFT
OUT
NODES
AND
AND
THE
OLD
NODE
WOULD
NOW
BE
THE
LAST
NODE
IN
THE
LIST
IF
NUM
RIGHTSHIFT
SHOULD
DO
NOTHING
AND
IF
NUM
THE
LENGTH
OF
THE
LIST
THE
RESULT
SHOULD
BE
AN
EMPTY
LIST
PUBLIC
VOID
LEFTROTATE
INT
NUM
IN
THIS
METHOD
YOU
WILL
STILL
SHIFT
THE
CONTENTS
OF
THE
LIST
NUM
PLACES
TO
THE
LEFT
BUT
RATHER
THAN
REMOVING
NODES
FROM
THE
LIST
YOU
WILL
SIMPLY
CHANGE
THEIR
ORDERING
IN
A
CYCLIC
WAY
FOR
EXAMPLE
IF
A
LIST
HAS
NODES
IN
IT
NUMBERED
FROM
TO
A
LEFTROTATE
OF
WOULD
SHIFT
NODES
AND
TO
THE
END
OF
THE
ARRAY
SO
THAT
THE
OLD
NODE
WOULD
NOW
BE
NODE
AND
THE
OLD
NODES
AND
WOULD
NOW
BE
NODES
AND
IN
THAT
ORDER
THE
ROTATION
SHOULD
WORK
MODULO
THE
LENGTH
OF
THE
LIST
SO
FOR
EXAMPLE
IF
THE
LIST
IS
LENGTH
THEN
A
LEFTROTATE
OF
SHOULD
BE
EQUIVALENT
TO
A
LEFTROTATE
OF
IF
NUM
THE
ROTATION
SHOULD
STILL
BE
DONE
BUT
IT
WILL
IN
FACT
BE
A
RIGHT
ROTATION
RATHER
THAN
A
LEFT
ROTATION
PUBLIC
VOID
RIGHTROTATE
INT
NUM
SAME
IDEA
AS
LEFTROTATE
ABOVE
BUT
IN
THE
OPPOSITE
DIRECTION
FOR
EXAMPLE
IF
A
LIST
HAS
NODES
IN
IT
NUMBERED
FROM
TO
A
RIGHTROTATE
OF
WOULD
SHIFT
NODES
AND
TO
THE
BEGINNING
OF
THE
ARRAY
SO
THAT
THE
OLD
NODE
WOULD
NOW
BE
NODE
THE
OLD
NODE
WOULD
NOW
BE
NODE
AND
THE
OLD
NODE
WOULD
NOW
BE
NODE
THE
BEHAVIOR
FOR
NUM
THE
LENGTH
OF
THE
LIST
AND
FOR
NUM
SHOULD
BE
ANALOGOUS
TO
THAT
DESCRIBED
ABOVE
FOR
LEFTROTATE
PUBLIC
VOID
REVERSE
THIS
METHOD
SHOULD
REVERSE
THE
NODES
IN
THE
LIST
NOTE
THAT
IN
THE
METHODS
ABOVE
YOU
MAY
NOT
CREATE
ANY
NEW
NODE
OBJECTS
THE
PURPOSE
OF
THEM
IS
TO
REARRANGE
THE
NODES
THAT
ALREADY
EXIST
TO
SEE
HOW
THESE
SHOULD
WORK
I
STRONGLY
RECOMMEND
DRAWING
ONE
OR
MORE
PICTURES
YOU
WILL
ALSO
NEED
TO
WRITE
THE
FOLLOWING
CONSTRUCTORS
PUBLIC
LINKEDLISTPLUS
PUBLIC
LINKEDLISTPLUS
LINKEDLISTPLUS
T
OLDLIST
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
THE
FIRST
CONTRUCTOR
SIMPLY
INITIALIZES
THE
LIST
TO
AN
EMPTY
STATE
AND
THE
SECOND
GENERATES
A
NEW
LIST
THAT
IS
A
COPY
OF
THE
ARGUMENT
LIST
COPYING
ALL
OF
THE
NODES
INSIDE
THE
OLD
LIST
THUS
THIS
COPY
IS
DEEPISH
FINALLY
YOU
WILL
NEED
TO
OVERRIDE
THE
FOLLOWING
METHOD
PUBLIC
STRING
TOSTRING
THIS
METHOD
WILL
RETURN
A
STRING
THAT
IS
THE
RESULT
OF
ALL
OF
THE
DATA
IN
THE
LIST
BEING
APPENDED
TOGETHER
SEPARATED
BY
SPACES
IMPORTANT
NOTES
ALL
OF
YOUR
LINKEDLISTPLUS
METHODS
MUST
BE
IMPLEMENTED
IN
AN
EFFICIENT
WAY
UTILIZING
THE
UNDERLYING
LINKED
LIST
FOR
EXAMPLE
A
POOR
IMPLEMENTATION
OF
A
LEFT
ROTATION
COULD
BE
DONE
VIA
REPEATED
CALLS
TO
REMOVE
AND
ADD
THIS
GETLENGTH
X
HOWEVER
DOING
THIS
WOULD
REQUIRE
MULTIPLE
TRAVERSALS
OF
THE
LIST
AND
HAS
A
VERY
BAD
RUNTIME
THINK
ARITHMETIC
SERIES
THIS
AND
SIMILAR
IMPLEMENTATIONS
ARE
NOT
ALLOWED
AND
IF
IMPLEMENTED
IN
THIS
WAY
YOU
WILL
NOT
RECEIVE
CREDIT
THE
LEFTROTATE
RIGHTROTATE
AMD
REVERSE
METHODS
SHOULD
NOT
CREATE
ANY
NEW
NODE
OBJECTS
RATHER
THEY
SHOULD
MOVE
THE
NODE
OBJECTS
CURRENTLY
IN
THE
LIST
INTO
OTHER
LOCATIONS
YOU
MAY
USE
TEMPORARY
NODE
VARIABLES
FOR
THESE
METHODS
BUT
YOU
MAY
NOT
CREATE
ANY
NEW
NODES
TO
VERIFY
THAT
YOUR
LINKEDLISTPLUS
CLASS
WORKS
PROPERLY
YOU
WILL
USE
IT
WITH
THE
PROGRAM
LLPTEST
JAVA
WHICH
WILL
BE
PROVIDED
FOR
YOU
ON
THE
ASSIGNMENTS
WEB
PAGE
YOUR
OUTPUT
MUST
MATCH
THAT
SHOWN
IN
LLPTEST
TXT
TO
HELP
YOU
OUT
WITH
THE
ASSIGNMENT
I
HAVE
IMPLEMENTED
SOME
OF
THE
METHODS
ABOVE
FOR
YOU
WITH
COMMENTS
SEE
THE
CODE
IN
LINKEDLISTPLUS
JAVA
PART
THE
SECOND
PART
OF
THIS
ASSIGNMENT
IS
TO
WRITE
THE
REALLYLONGINT
CLASS
WITH
THE
SPECIFICATIONS
AS
GIVEN
BELOW
YOU
MAY
ASSUME
ALL
NUMBERS
WILL
BE
NONNEGATIVE
INHERITANCE
REALLYLONGINT
MUST
BE
A
SUBCLASS
OF
LINKEDLISTPLUS
HOWEVER
SINCE
LINKEDLISTPLUS
IS
GENERIC
WHILE
REALLYLONGINT
IS
NOT
GENERIC
YOU
SHOULD
USE
THE
FOLLOWING
HEADER
PUBLIC
CLASS
REALLYLONGINT
EXTENDS
LINKEDLISTPLUS
INTEGER
IMPLEMENTS
COMPARABLE
REALLYLONGINT
NOTE
THAT
RATHER
THAN
T
THE
UNDERLYING
ELEMENT
DATA
IS
NOW
INTEGER
THIS
MEANS
THAT
THE
INDIVIDUAL
DIGITS
OF
YOUR
REALLYLONGINT
WILL
BE
INTEGER
OBJECTS
DATA
THE
DATA
FOR
THIS
CLASS
IS
INHERITED
AND
YOU
MAY
NOT
ADD
ANY
ADDITIONAL
INSTANCE
VARIABLES
YOU
WILL
CERTAINLY
NEED
METHOD
VARIABLES
FOR
THE
VARIOUS
OPERATIONS
BUT
THE
ONLY
INSTANCE
VARIABLES
THAT
YOU
NEED
ARE
THOSE
INHERITED
FROM
VIA
LINKEDLISTPLUS
OPERATIONS
YOUR
REALLYLONGINT
CLASS
MUST
IMPLEMENT
THE
METHODS
SHOWN
BELOW
NOTE
THAT
THE
COMPARETO
METHOD
IS
NECESSARY
FOR
THE
COMPARABLE
INTERFACE
PRIVATE
REALLYLONGINT
THE
DEFAULT
CONSTRUCTOR
WILL
CREATE
AN
EMPTY
REALLYLONGINT
NOTE
THAT
THIS
LEAVES
THE
NUMBER
IN
AN
INCONSISTENT
STATE
HAVING
NO
ACTUAL
VALUE
SO
IT
SHOULD
ONLY
BE
USED
WITHIN
THE
CLASS
ITSELF
AS
A
UTILITY
METHOD
FOR
EXAMPLE
YOU
WILL
PROBABLY
NEED
IT
IN
YOUR
ADD
AND
SUBTRACT
METHODS
FOR
THIS
REASON
IT
IS
A
PRIVATE
METHOD
PUBLIC
REALLYLONGINT
STRING
THE
STRING
CONSISTS
OF
A
VALID
SEQUENCE
OF
DIGITS
WITH
NO
LEADING
ZEROS
EXCEPT
FOR
THE
NUMBER
ITSELF
SPECIAL
CASE
INSERT
THE
DIGITS
AS
INTEGER
OBJECTS
INTO
YOUR
LIST
SUCH
THAT
THE
LEAST
SIGNIFICANT
DIGIT
IS
AT
THE
BEGINNING
OF
THE
LIST
FOR
EXAMPLE
THE
STRING
WOULD
BE
STORED
IN
A
REALLYLONGINT
AS
FIRSTNODE
NOTE
ACTUAL
NODES
ARE
NOT
SHOWN
BUT
IMPLICIT
PUBLIC
REALLYLONGINT
REALLYLONGINT
RIGHTOP
THIS
JUST
REQUIRES
A
CALL
TO
SUPER
HOWEVER
IT
IS
DEPENDENT
UPON
A
CORRECT
IMPLEMENTATION
OF
THE
COPY
CONSTRUCTOR
FOR
THE
LINKEDLISTPLUS
CLASS
PUBLIC
STRING
TOSTRING
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
RETURN
A
STRING
THAT
ACCURATELY
SHOWS
THE
INTEGER
AS
WE
WOULD
EXPECT
TO
SEE
IT
BASED
ON
THE
WAY
WE
HAVE
STORED
THE
INTEGER
THIS
SHOULD
BE
ACCOMPLISHED
BY
GOING
BACKWARD
THROUGH
THE
LIST
SINCE
WE
CANNOT
ACTUALLY
DO
THAT
WE
WILL
REVERSE
THE
LIST
THEN
TRAVERSE
IT
THEN
REVERSE
IT
AGAIN
TO
HELP
YOU
OUT
WITH
THE
ASSIGNMENT
I
HAVE
IMPLEMENTED
THE
METHODS
ABOVE
FOR
YOU
WITH
COMMENTS
SEE
THE
CODE
IN
REALLYLONGINT
JAVA
PUBLIC
REALLYLONGINT
ADD
REALLYLONGINT
RIGHTOP
RETURN
A
NEW
REALLYLONGINT
THAT
IS
THE
SUM
OF
THE
CURRENT
REALLYLONGINT
AND
THE
PARAMETER
REALLYLONGINT
WITHOUT
ALTERING
THE
ORIGINAL
VALUES
FOR
EXAMPLE
REALLYLONGINT
X
NEW
REALLYLONGINT
REALLYLONGINT
Y
NEW
REALLYLONGINT
REALLYLONGINT
Z
Z
X
ADD
Y
SYSTEM
OUT
PRINTLN
X
Y
Z
SHOULD
PRODUCE
THE
OUTPUT
BE
CAREFUL
TO
HANDLE
CARRIES
CORRECTLY
AND
TO
PROCESS
THE
NODES
IN
THE
CORRECT
ORDER
SINCE
THE
NUMBERS
ARE
STORED
WITH
THE
LEAST
SIGNIFICANT
DIGIT
AT
THE
BEGINNING
THE
ADD
METHOD
CAN
BE
IMPLEMENTED
BY
TRAVERSING
BOTH
NUMBERS
IN
A
SYSTEMATIC
WAY
THIS
MUST
BE
DONE
EFFICIENTLY
USING
REFERENCES
TO
TRAVERSE
THE
LISTS
IN
OTHER
WORDS
YOU
SHOULD
START
AT
THE
BEGINNING
OF
EACH
REALLYLONGINT
AND
TRAVERSE
ONE
TIME
WHILE
DOING
THE
ADDITION
THINK
HOW
YOU
CAN
DO
THIS
WITH
REFERENCE
VARIABLES
ALSO
BE
CAREFUL
TO
HANDLE
NUMBERS
WITH
DIFFERING
NUMBERS
OF
DIGITS
PUBLIC
REALLYLONGINT
SUBTRACT
REALLYLONGINT
RIGHTOP
RETURN
A
NEW
REALLYLONGINT
THAT
IS
THE
DIFFERENCE
OF
THE
CURRENT
REALLYLONGINT
AND
THE
PARAMETER
REALLYLONGINT
SINCE
REALLYLONGINT
IS
SPECIFIED
TO
BE
NONNEGATIVE
IF
RIGHTOP
IS
GREATER
THAN
THE
CURRENT
REALLYLONGINT
YOU
SHOULD
THROW
AN
ARITHMETICEXCEPTION
OTHERWISE
SUBTRACT
DIGIT
BY
DIGIT
BORROWING
IF
NECESSARY
AS
EXPECTED
AS
WITH
THE
ADD
METHOD
YOU
MUST
IMPLEMENT
THIS
EFFICIENTLY
VIA
A
SINGLE
TRAVERSAL
OF
BOTH
LISTS
THIS
METHOD
IS
TRICKY
BECAUSE
IT
CAN
RESULT
IN
LEADING
ZEROS
WHICH
WE
DON
T
WANT
BE
CAREFUL
TO
HANDLE
THIS
CASE
AND
CONSIDER
THE
TOOLS
PROVIDED
BY
LINKEDLISTPLUS
THAT
WILL
ALLOW
YOU
TO
HANDLE
IT
FOR
EXAMPLE
REALLYLONGINT
X
NEW
REALLYLONGINT
REALLYLONGINT
Y
NEW
REALLYLONGINT
REALLYLONGINT
Z
Z
X
SUBTRACT
Y
SYSTEM
OUT
PRINTLN
X
Y
Z
SHOULD
PRODUCE
THE
OUTPUT
AS
WITH
THE
ADD
METHOD
BE
CAREFUL
TO
HANDLE
NUMBERS
WITH
DIFFERING
NUMBERS
OF
DIGITS
ALSO
NOTE
THAT
BORROWING
MAY
EXTEND
OVER
SEVERAL
DIGITS
SEE
RLITEST
JAVA
FOR
SOME
EXAMPLE
CASES
PUBLIC
INT
COMPARETO
REALLYLONGINT
RIGHTOP
DEFINED
THE
WAY
WE
EXPECT
COMPARETO
TO
BE
DEFINED
FOR
NUMBERS
IF
ONE
NUMBER
HAS
MORE
DIGITS
THAN
THE
OTHER
THEN
CLEARLY
IT
IS
BIGGER
SINCE
THERE
ARE
NO
LEADING
OTHERWISE
THE
NUMBERS
MUST
BE
COMPARED
DIGIT
BY
DIGIT
SINCE
THIS
REQUIRES
THE
MOST
SIGNIFICANT
DIGIT
TO
BE
PROCESSED
FIRST
WHICH
IS
AT
THE
END
OF
THE
LIST
WE
CANNOT
JUST
ITERATE
THROUGH
THE
DIGITS
AS
GIVEN
WITH
A
SINGLYLINKED
LIST
WE
CANNOT
GO
BACKWARD
EITHER
SO
WE
WILL
USE
WHAT
IS
GIVEN
IN
THE
LINKEDLISTPLUS
CLASS
FIRST
REVERSE
THE
NODES
IN
BOTH
NUMBERS
THEN
DO
THE
COMPARISON
IN
A
SEQUENTIAL
WAY
THEN
REVERSE
AGAIN
TO
RESTORE
THE
ORIGINAL
NUMBERS
PUBLIC
BOOLEAN
EQUALS
OBJECT
RIGHTOP
DEFINED
THE
WAY
WE
EXPECT
EQUALS
TO
BE
DEFINED
FOR
OBJECTS
COMPARING
THE
DATA
AND
NOT
THE
REFERENCE
DON
T
FORGET
TO
CAST
RIGHTOP
TO
REALLYLONGINT
SO
THAT
ITS
NODES
CAN
BE
ACCESSED
NOTE
THE
ARGUMENT
HERE
IS
OBJECT
RATHER
THAN
REALLYLONGINT
BECAUSE
WE
ARE
OVERRIDING
EQUALS
FROM
THE
VERSION
DEFINED
IN
CLASS
OBJECT
NOTE
THIS
METHOD
CAN
EASILY
BE
IMPLEMENTED
ONCE
COMPARETO
HAS
BEEN
COMPLETED
PUBLIC
VOID
MULTTENTOTHE
INT
NUM
MULTIPLY
THE
CURRENT
REALLYLONGINT
BY
NOTE
THAT
THIS
CAN
BE
DONE
VERY
SIMPLY
THROUGH
ADDING
OF
NODES
CONTAINING
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
ASSIGS
HTM
PUBLIC
VOID
DIVTENTOTHE
INT
NUM
DIVIDE
THE
CURRENT
REALLYLONGINT
BY
NOTE
THAT
THIS
CAN
BE
DONE
VERY
SIMPLY
THROUGH
SHIFTING
TO
VERIFY
THAT
YOUR
REALLYLONGINT
CLASS
WORKS
CORRECTLY
YOU
WILL
USE
IT
WITH
THE
PROGRAM
RLITEST
JAVA
WHICH
WILL
BE
PROVIDED
FOR
YOU
ON
THE
ASSIGNMENTS
PAGE
YOUR
OUTPUT
SHOULD
MATCH
THAT
SHOWN
IN
RLITEST
TXT
MORE
IMPORTANT
NOTES
WHEN
IMPLEMENTING
THESE
OPERATIONS
YOU
MAY
DISCOVER
THAT
IT
WOULD
BE
MUCH
EASIER
TO
DO
THEM
IF
THE
UNDERLYING
LINKED
LIST
WERE
BIDIRECTIONAL
I
E
A
DOUBLYLINKED
LIST
THIS
IS
ABSOLUTELY
TRUE
BUT
UNFORTUNATELY
YOU
ARE
REQUIRED
TO
USE
THE
SINGLYLINKED
LIST
THAT
IS
PROVIDED
BOTH
THE
ADD
AND
SUBTRACT
METHODS
ARE
TRICKY
AND
HAVE
DIFFERENT
CASES
TO
CONSIDER
FOR
THESE
METHODS
ESPECIALLY
I
RECOMMEND
WORKING
OUT
SOME
EXAMPLES
ON
PAPER
TO
SEE
WHAT
NEEDS
TO
BE
CONSIDERED
BEFORE
ACTUALLY
CODING
THEM
EXTRA
CREDIT
HERE
ARE
A
COUPLE
NONTRIVIAL
EXTRA
CREDIT
IDEAS
EITHER
ONE
DONE
WELL
COULD
GET
YOU
THE
FULL
EXTRA
CREDIT
POINTS
HOWEVER
DON
T
ATTEMPT
EITHER
UNTIL
YOU
ARE
CONFIDENT
THAT
YOUR
REQUIRED
CLASSES
ARE
WORKING
CORRECTLY
ALLOW
THE
NUMBERS
TO
BE
SIGNED
SO
THAT
WE
CAN
HAVE
BOTH
POSITIVE
AND
NEGATIVE
NUMBERS
THIS
MAY
REQUIRE
AN
EXTRA
INSTANCE
VARIABLE
FOR
THE
SIGN
AND
WILL
CLEARLY
AFFECT
MANY
OF
YOUR
METHODS
IF
YOU
CHOOSE
THIS
EXTRA
CREDIT
YOU
MUST
SUBMIT
IT
AS
A
SEPARATE
CLASS
IN
ADDITION
TO
YOUR
ORIGINAL
REALLYLONGINT
CLASS
YOU
MUST
ALSO
SUBMIT
A
SEPARATE
DRIVER
PROGRAM
TO
TEST
DEMONSTRATE
YOUR
SIGNED
CLASS
ADD
A
MULTIPLY
METHOD
TO
YOUR
REALLYLONGINT
CLASS
IF
YOU
IMPLEMENT
THIS
YOU
SHOULD
ALSO
SUBMIT
A
SEPARATE
DRIVER
PROGRAM
TO
TEST
DEMONSTRATE
THE
MULTIPLY
METHOD
SUBMISSION
YOU
MUST
SUBMIT
THE
FOLLOWING
COMPLETE
WORKING
SOURCE
FILES
FOR
FULL
CREDIT
JAVA
LLPTEST
JAVA
RLITEST
JAVA
THE
ABOVE
THREE
FILES
ARE
GIVEN
TO
YOU
AND
MUST
NOT
BE
ALTERED
IN
ANY
WAY
LINKEDLISTPLUS
JAVA
REALLYLONGINT
JAVA
THE
ABOVE
TWO
FILES
MUST
WRITTEN
BY
YOU
SO
THAT
THEY
WORK
AS
DESCRIBED
NOTE
THAT
I
HAVE
PROVIDED
PARTIAL
IMPLEMENTATIONS
OF
BOTH
DOWNLOAD
THOSE
AS
A
STARTING
POINT
THE
IDEA
FROM
YOUR
SUBMISSION
IS
THAT
YOUR
TA
CAN
COMPILE
AND
RUN
YOUR
PROGRAM
WITHOUT
ANY
ADDITIONAL
FILES
OR
PROCESSING
THIS
MEANS
COMPILATION
AND
EXECUTION
ON
THE
COMMAND
LINE
USING
THE
JAVAC
AND
JAVA
COMMANDS
TEST
YOUR
PROGRAMS
FROM
THE
COMMAND
LINE
BEFORE
SUBMITTING
ESPECIALLY
IF
YOU
USE
AN
IDE
SUCH
AS
NETBEANS
OR
ECLIPSE
TO
DEVELOP
YOUR
PROJECT
IF
YOU
CANNOT
GET
THE
PROGRAMS
WORKING
AS
GIVEN
CLEARLY
INDICATE
ANY
CHANGES
YOU
MADE
AND
CLEARLY
INDICATE
WHY
ON
YOUR
ASSIGNMENT
INFORMATION
SHEET
TRUE
FALSE
EXPLAIN
FALSE
STATEMENTS
FOR
FULL
CREDIT
POINTS
EACH
EX
GIVEN
NONNULL
STRING
VARIABLES
AND
THE
STATEMENT
WILL
TEST
IF
THEIR
STRING
VALUES
MATCH
EACH
OTHER
IN
THE
CS
COURSE
WE
USE
JAVA
CLASSES
TO
REPRESENT
ADTS
ABSTRACT
DATA
TYPES
IN
THE
AUTHOR
ALIST
IMPLEMENTATION
OF
THE
LIST
ADT
TO
DELETE
AN
ITEM
FROM
THE
MIDDLE
OF
THE
LIST
WE
SIMPLY
MOVE
THE
LAST
ITEM
TO
THAT
LOCATION
THEREBY
SAVING
THE
TIME
REQUIRED
FOR
SHIFTING
SHORT
ANSWERS
DEFINE
COMPARE
EXPLAIN
JUSTIFY
OR
OTHERWISE
ELABORATE
ON
THE
STATEMENTS
SHOWN
EX
IN
THE
ARRAYBAG
IMPLEMENTATION
OF
THE
BAGINTERFACE
EXPLAIN
HOW
THE
REMOVE
T
ANENTRY
METHOD
ACTUALLY
REMOVES
THAT
ITEM
FROM
THE
ARRAY
STATE
WHY
THIS
IS
ACCEPTABLE
AND
WHEN
IT
MAY
NOT
BE
ACCEPTABLE
TRACE
GIVE
ALL
OUTPUT
PRODUCED
BY
THE
EXECUTION
OF
A
GIVEN
JAVA
PROGRAM
IN
THE
CORRECT
ORDER
EX
SEE
CLASS
HANDOUTS
TRY
TRACING
THESE
BY
HAND
AND
THEN
RUNNING
THEM
TO
SEE
THE
ACTUAL
OUTPUT
CODING
WRITE
JAVA
CODE
AS
INSTRUCTED
IN
THE
PROBLEM
EX
CONSIDER
THE
CONTAINS
T
ANENTRY
METHOD
IN
THE
ARRAYBAG
IMPLEMENTATION
OF
THE
BAGINTERFACE
COMPLETE
THE
METHOD
RECALL
THE
INSTANCE
DATA
FOR
THE
ARRAYBAG
CLASS
PRIVATE
T
BAG
PRIVATE
INT
NUMBEROFENTRIES
SOLUTIONS
FILL
IN
THE
BLANKS
PROVIDE
THE
MOST
APPROPRIATE
ANSWERS
POINTS
EACH
PEOPLE
CS
PITT
EDU
RAMIREZ
QUIZHELP
HTML
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
QUIZHELP
HTML
EX
BECAUSE
THE
NODE
CLASS
USED
IN
A
LINKEDBAG
HAS
AN
INSTANCE
VARIABLE
OF
CLASS
NODE
IT
IS
CALLED
A
DATA
TYPE
IN
THE
LIST
BAG
ADT
THE
ORDER
THAT
THE
DATA
IS
STORED
DOES
NOT
MATTER
TRUE
FALSE
EXPLAIN
FALSE
STATEMENTS
FOR
FULL
CREDIT
POINTS
EACH
EX
GIVEN
NONNULL
STRING
VARIABLES
AND
THE
STATEMENT
WILL
TEST
IF
THEIR
STRING
VALUES
MATCH
EACH
OTHER
IT
WILL
TEST
IF
THE
REFERENCES
ARE
THE
IN
THE
CS
COURSE
WE
USE
JAVA
CLASSES
TO
REPRESENT
ADTS
ABSTRACT
DATA
TYPES
WE
USE
INTERFACES
TO
REPRESENT
IN
THE
AUTHOR
ALIST
IMPLEMENTATION
OF
THE
LIST
ADT
TO
DELETE
AN
ITEM
FROM
THE
MIDDLE
OF
THE
LIST
WE
SIMPLY
MOVE
THE
LAST
ITEM
TO
THAT
LOCATION
THEREBY
SAVING
THE
TIME
REQUIRED
FOR
SHIFTING
THE
LIST
ADT
MUST
MAINTAIN
POSITIONAL
SHORT
ANSWERS
DEFINE
COMPARE
EXPLAIN
JUSTIFY
OR
OTHERWISE
ELABORATE
ON
THE
STATEMENTS
SHOWN
EX
IN
THE
ARRAYBAG
IMPLEMENTATION
OF
THE
BAGINTERFACE
EXPLAIN
HOW
THE
REMOVE
T
ANENTRY
METHOD
ACTUALLY
REMOVES
THAT
ITEM
FROM
THE
ARRAY
STATE
WHY
THIS
IS
ACCEPTABLE
AND
WHEN
IT
MAY
NOT
BE
ACCEPTABLE
CONSIDER
AN
ITEM
SOMEWHERE
IN
THE
MIDDLE
OF
THE
ARRAY
THAT
WILL
BE
REMOVED
TO
REMOVE
IT
CREATES
A
HOLE
IN
THE
ARRAY
THAT
MUST
BE
FILLED
RATHER
THAN
FILLING
THE
HOLE
BY
SHIFTING
ALL
OF
THE
REMAINING
ITEMS
OVER
IN
THE
ARRAYBAG
THE
LAST
ITEM
IS
SIMPLY
COPIED
TO
THE
DELETED
INDEX
AND
THE
LAST
REFERENCE
IS
THEN
SET
TO
NULL
THIS
IN
EFFECT
MOVES
THE
LAST
ITEM
UP
TO
SOMEWHERE
IN
THE
MIDDLE
OF
THE
ARRAY
WHICH
IS
OK
SINCE
THE
DATA
IN
A
BAG
IS
UNORDERED
IF
ORDER
MATTERED
EX
A
GENERAL
LIST
THEN
WE
WOULD
HAVE
TO
SHIFT
RATHER
THAN
DOING
THIS
TECHNIQUE
TRACE
GIVE
ALL
OUTPUT
PRODUCED
BY
THE
EXECUTION
OF
A
GIVEN
JAVA
PROGRAM
IN
THE
CORRECT
ORDER
EX
SEE
CLASS
HANDOUTS
CODING
WRITE
JAVA
CODE
AS
INSTRUCTED
IN
THE
PROBLEM
EX
CONSIDER
THE
CONTAINS
T
ANENTRY
METHOD
IN
THE
ARRAYBAG
IMPLEMENTATION
OF
THE
BAGINTERFACE
COMPLETE
THE
METHOD
RECALL
THE
INSTANCE
DATA
FOR
THE
ARRAYBAG
CLASS
PRIVATE
T
BAG
PRIVATE
INT
NUMBEROFENTRIES
ONE
POSSIBLE
SOLUTION
FROM
TEXT
PUBLIC
BOOLEAN
CONTAINS
T
ANENTRY
PEOPLE
CS
PITT
EDU
RAMIREZ
QUIZHELP
HTML
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
QUIZHELP
HTML
RETURN
GETINDEXOF
ANENTRY
OR
END
CONTAINS
PRIVATE
INT
GETINDEXOF
T
ANENTRY
INT
WHERE
BOOLEAN
FOUND
FALSE
FOR
INT
INDEX
FOUND
INDEX
NUMBEROFENTRIES
INDEX
IF
ANENTRY
EQUALS
BAG
INDEX
FOUND
TRUE
WHERE
INDEX
END
IF
END
FOR
RETURN
WHERE
END
GETINDEXOF
PEOPLE
CS
PITT
EDU
RAMIREZ
HANDOUTS
CARRANO
LISTINTERFACE
JAVA
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
HANDOUTS
CARRANO
LISTINTERFACE
JAVA
AN
INTERFACE
FOR
THE
ADT
LIST
ENTRIES
IN
A
LIST
HAVE
POSITIONS
THAT
BEGIN
WITH
AUTHOR
FRANK
M
CARRANO
AUTHOR
TIMOTHY
M
HENRY
VERSION
PUBLIC
INTERFACE
LISTINTERFACE
T
ADDS
A
NEW
ENTRY
TO
THE
END
OF
THIS
LIST
ENTRIES
CURRENTLY
IN
THE
LIST
ARE
UNAFFECTED
THE
LIST
SIZE
IS
INCREASED
BY
PARAM
NEWENTRY
THE
OBJECT
TO
BE
ADDED
AS
A
NEW
ENTRY
PUBLIC
VOID
ADD
T
NEWENTRY
ADDS
A
NEW
ENTRY
AT
A
SPECIFIED
POSITION
WITHIN
THIS
LIST
ENTRIES
ORIGINALLY
AT
AND
ABOVE
THE
SPECIFIED
POSITION
ARE
AT
THE
NEXT
HIGHER
POSITION
WITHIN
THE
LIST
THE
LIST
SIZE
IS
INCREASED
BY
PARAM
NEWPOSITION
AN
INTEGER
THAT
SPECIFIES
THE
DESIRED
POSITION
OF
THE
NEW
ENTRY
PARAM
NEWENTRY
THE
OBJECT
TO
BE
ADDED
AS
A
NEW
ENTRY
THROWS
INDEXOUTOFBOUNDSEXCEPTION
IF
EITHER
NEWPOSITION
OR
NEWPOSITION
GETLENGTH
PUBLIC
VOID
ADD
INT
NEWPOSITION
T
NEWENTRY
REMOVES
THE
ENTRY
AT
A
GIVEN
POSITION
FROM
THIS
LIST
ENTRIES
ORIGINALLY
AT
POSITIONS
HIGHER
THAN
THE
GIVEN
POSITION
ARE
AT
THE
NEXT
LOWER
POSITION
WITHIN
THE
LIST
AND
THE
LIST
SIZE
IS
DECREASED
BY
PARAM
GIVENPOSITION
AN
INTEGER
THAT
INDICATES
THE
POSITION
OF
THE
ENTRY
TO
BE
REMOVED
RETURN
A
REFERENCE
TO
THE
REMOVED
ENTRY
THROWS
INDEXOUTOFBOUNDSEXCEPTION
IF
EITHER
GIVENPOSITION
OR
GIVENPOSITION
GETLENGTH
PUBLIC
T
REMOVE
INT
GIVENPOSITION
REMOVES
ALL
ENTRIES
FROM
THIS
LIST
PUBLIC
VOID
CLEAR
REPLACES
THE
ENTRY
AT
A
GIVEN
POSITION
IN
THIS
LIST
PARAM
GIVENPOSITION
AN
INTEGER
THAT
INDICATES
THE
POSITION
OF
THE
ENTRY
TO
BE
REPLACED
PARAM
NEWENTRY
THE
OBJECT
THAT
WILL
REPLACE
THE
ENTRY
AT
THE
POSITION
GIVENPOSITION
RETURN
THE
ORIGINAL
ENTRY
THAT
WAS
REPLACED
THROWS
INDEXOUTOFBOUNDSEXCEPTION
IF
EITHER
GIVENPOSITION
OR
GIVENPOSITION
GETLENGTH
PUBLIC
T
REPLACE
INT
GIVENPOSITION
T
NEWENTRY
RETRIEVES
THE
ENTRY
AT
A
GIVEN
POSITION
IN
THIS
LIST
PARAM
GIVENPOSITION
AN
INTEGER
THAT
INDICATES
THE
POSITION
OF
THE
DESIRED
ENTRY
RETURN
A
REFERENCE
TO
THE
INDICATED
ENTRY
THROWS
INDEXOUTOFBOUNDSEXCEPTION
IF
EITHER
GIVENPOSITION
OR
GIVENPOSITION
GETLENGTH
PUBLIC
T
GETENTRY
INT
GIVENPOSITION
RETRIEVES
ALL
ENTRIES
THAT
ARE
IN
THIS
LIST
IN
THE
ORDER
IN
WHICH
THEY
OCCUR
IN
THE
LIST
RETURN
A
NEWLY
ALLOCATED
ARRAY
OF
ALL
THE
ENTRIES
IN
THE
LIST
IF
THE
LIST
IS
EMPTY
THE
RETURNED
ARRAY
IS
EMPTY
PUBLIC
T
TOARRAY
PEOPLE
CS
PITT
EDU
RAMIREZ
HANDOUTS
CARRANO
LISTINTERFACE
JAVA
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
HANDOUTS
CARRANO
LISTINTERFACE
JAVA
SEES
WHETHER
THIS
LIST
CONTAINS
A
GIVEN
ENTRY
PARAM
ANENTRY
THE
OBJECT
THAT
IS
THE
DESIRED
ENTRY
RETURN
TRUE
IF
THE
LIST
CONTAINS
ANENTRY
OR
FALSE
IF
NOT
PUBLIC
BOOLEAN
CONTAINS
T
ANENTRY
GETS
THE
LENGTH
OF
THIS
LIST
RETURN
THE
INTEGER
NUMBER
OF
ENTRIES
CURRENTLY
IN
THE
LIST
PUBLIC
INT
GETLENGTH
SEES
WHETHER
THIS
LIST
IS
EMPTY
RETURN
TRUE
IF
THE
LIST
IS
EMPTY
OR
FALSE
IF
NOT
PUBLIC
BOOLEAN
ISEMPTY
END
LISTINTERFACE
GENERAL
EACH
STUDENT
IS
EXPECTED
TO
DO
HIS
HER
OWN
WORK
FOR
A
FIRST
OFFENSE
A
STUDENT
CAUGHT
COLLABORATING
CHEATING
IN
ANY
WAY
WILL
RECEIVE
A
ZERO
FOR
THE
EXAM
HOMEWORK
PROJECT
IN
QUESTION
IN
THE
EVENT
OF
A
SECOND
OFFENSE
THE
STUDENT
WILL
RECEIVE
AN
F
FOR
THE
COURSE
AND
MAY
BE
SUBJECT
TO
STRONGER
ACTION
NOTE
SUBMISSIONS
THAT
ARE
ALIKE
IN
A
SUBSTANTIVE
WAY
NOT
DUE
TO
COINCIDENCE
WILL
BE
CONSIDERED
TO
BE
CHEATING
BY
ALL
INVOLVED
PARTIES
PLEASE
PROTECT
YOURSELVES
BY
ONLY
STORING
YOUR
FILES
IN
PRIVATE
DIRECTORIES
AND
BY
RETRIEVING
ALL
PRINTOUTS
PROMPTLY
FOR
MORE
INFORMATION
ON
THE
ACADEMIC
INTEGRITY
POLICIES
OF
THE
SCHOOL
OF
ARTS
AND
SCIENCES
SEE
THIS
LINK
STUDENTS
ARE
ENCOURAGED
TO
ATTEND
ALL
LECTURES
WHICH
FREQUENTLY
INCLUDE
MATERIAL
THAT
IS
NOT
DIRECTLY
TAKEN
FROM
THE
TEXT
IF
A
STUDENT
MISSES
A
LECTURE
HE
SHE
IS
STILL
RESPONSIBLE
FOR
THE
MATERIAL
COVERED
AND
IS
ADVISED
TO
COPY
THE
NOTES
FROM
A
CLASSMATE
AN
ABUNDANCE
OF
INFORMATION
INCLUDING
ANNOUNCEMENTS
HANDOUTS
REVIEW
SHEETS
AND
SOLUTIONS
WILL
BE
POSTED
ON
MY
WEB
PAGE
AND
POSSIBLY
TA
PAGES
AS
WELL
THROUGHOUT
THE
TERM
STUDENTS
ARE
EXPECTED
TO
AWARE
OF
ALL
INFORMATION
THAT
IS
POSTED
ON
OUR
WEB
PAGES
AND
SHOULD
ACCESS
THEM
FREQUENTLY
ALL
GRADED
MATERIALS
THAT
A
STUDENT
RECEIVES
BACK
SHOULD
BE
SAVED
IN
A
SAFE
PLACE
UNTIL
AFTER
THE
TERM
HAS
ENDED
AND
HE
SHE
HAS
RECEIVED
AND
ACCEPTS
HIS
HER
FINAL
GRADE
IN
THIS
WAY
ANY
GRADE
DISCREPANCIES
CAN
BE
EASILY
RESOLVED
CS
HOME
PAGE
HTTP
PEOPLE
CS
PITT
EDU
RAMIREZ
STUDENTS
WITH
DISABILITIES
IF
YOU
HAVE
A
DISABILITY
FOR
WHICH
YOU
ARE
OR
MAY
BE
REQUESTING
AN
ACCOMMODATION
YOU
ARE
ENCOURAGED
TO
CONTACT
BOTH
YOUR
INSTRUCTOR
AND
DISABILITY
RESOURCES
AND
SERVICES
WILLIAM
PITT
UNION
AS
EARLY
AS
POSSIBLE
IN
THE
TERM
DRS
WILL
VERIFY
YOUR
DISABILITY
AND
DETERMINE
REASONABLE
ACCOMMODATIONS
FOR
THIS
COURSE
MORE
INFO
AT
HTTP
WWW
STUDENTAFFAIRS
PITT
EDU
DRS
EXAMS
THE
DATES
FOR
THE
EXAMS
ARE
LISTED
IN
THE
IMPORTANT
DATES
TABLE
STUDENTS
ARE
EXPECTED
TO
BE
PRESENT
FOR
BOTH
EXAMS
MAKEUP
EXAMS
WILL
ONLY
BE
GIVEN
IN
THE
EVENT
OF
AN
EMERGENCY
AND
ONLY
IF
I
AM
INFORMED
IN
ADVANCE
IF
YOU
CANNOT
CONTACT
ME
DIRECTLY
SEND
ME
EMAIL
OR
CALL
THE
CS
DEPARTMENT
AND
LEAVE
ME
A
MESSAGE
FAILURE
TO
NOTIFY
ME
PRIOR
TO
MISSING
AN
EXAM
WILL
RESULT
IN
A
ZERO
FOR
THE
EXAM
PROGRAMS
THERE
WILL
BE
APPROXIMATELY
PROGRAMS
TO
BE
WRITTEN
IN
JAVA
ASSIGNED
THROUGHOUT
THE
TERM
STUDENTS
ARE
EXPECTED
TO
HAND
IN
ALL
OF
THE
ASSIGNMENTS
FAILURE
TO
HAND
IN
TWO
ASSIGNMENTS
WILL
RESULT
IN
A
FINAL
GRADE
NO
HIGHER
THAN
A
C
FAILURE
TO
HAND
IN
THREE
OR
MORE
ASSIGNMENTS
WILL
RESULT
IN
A
FINAL
GRADE
NO
HIGHER
THAN
A
D
PROGRAMS
WILL
BE
SUBMITTED
ELECTRONICALLY
TO
A
SUBMISSION
SITE
SET
UP
FOR
THE
COURSE
MORE
DETAILS
ON
SUBMISSION
GUIDELINES
WILL
BE
PROVIDED
ON
THE
COURSE
WEB
SITE
ONTIME
PROJECTS
MUST
BE
RECEIVED
AT
THE
SUBMISSION
SITE
BY
ON
THE
DUE
DATE
ANY
PROJECT
RECEIVED
AFTER
THIS
TIME
WILL
BE
CONSIDERED
TO
BE
LATE
LATE
PROJECTS
MUST
BE
RECEIVED
AT
THE
SUBMISSION
SITE
BY
ON
THE
LATE
DUE
DATE
LATE
PROJECTS
WILL
BE
PENALIZED
POINTS
OUT
OF
PROJECTS
SUBMITTED
AFTER
THE
LATE
DUE
DATE
WILL
NOT
BE
GRADED
AND
WILL
RECEIVE
A
SCORE
OF
STUDENTS
ARE
EXPECTED
TO
HAVE
A
BACKUP
DISK
OR
STORAGE
SOMEWHERE
FOR
EVERY
ASSIGNMENT
THEY
TURN
IN
IN
THIS
WAY
IF
THERE
IS
ANY
PROBLEM
WITH
THE
PRIMARY
COPY
THE
WORK
WILL
NOT
BE
LOST
MORE
DETAILS
ON
THE
PROGRAMS
AND
SUBMISSION
GUIDELINES
WILL
BE
GIVEN
WITH
THE
FIRST
ASSIGNMENT
QUIZZES
QUIZZES
WILL
BE
GIVEN
DURING
RECITATIONS
AND
WILL
BE
ANNOUNCED
AT
LEAST
ONE
CLASS
OR
RECITATION
BEFORE
THEY
ARE
GIVEN
THEY
WILL
GENERALLY
INCLUDE
MATERIAL
COVERED
IN
THE
PREVIOUS
CLASS
ES
AND
RECITATION
S
TWO
QUIZZES
WILL
BE
GIVEN
EACH
COUNTING
FOR
OF
THE
FINAL
GRADE
AS
WITH
EXAMS
QUIZZES
CAN
ONLY
BE
MADE
UP
IF
YOU
CONTACT
THE
RECITATION
INSTRUCTOR
IN
ADVANCE
IF
YOU
MISS
A
QUIZ
WITHOUT
INFORMING
THE
RECITATION
INSTRUCTOR
YOU
WILL
RECEIVE
A
ZERO
FOR
THAT
QUIZ
QUESTIONS
OF
THE
DAY
AT
THE
END
OF
EACH
LECTURE
THERE
WILL
BE
A
VERY
SHORT
MINIQUIZ
TESTING
MATERIAL
FROM
THE
CURRENT
AND
PREVIOUS
LECTURES
FROM
HEREON
REFERRED
TO
AS
THE
QUESTIONS
OF
THE
DAY
QOTD
NO
QOTD
WILL
BE
GIVEN
DURING
LECTURES
IN
WHICH
EXAMS
ARE
GIVEN
THE
LOWEST
SCORES
WILL
BE
DROPPED
AND
THE
REMAINING
WILL
BE
AVERAGED
AND
WEIGHTED
FOR
OF
THE
OVERALL
COURSE
GRADE
QOTD
CANNOT
BE
MADE
UP
A
STUDENT
NOT
IN
ATTENDANCE
FOR
A
QOTD
WILL
RECEIVE
A
FOR
THAT
QOTD
TURNING
TECHNOLOGIES
RESPONSE
CARDS
WILL
BE
USED
FOR
THE
QOTD
AND
EACH
STUDENT
IS
REQUIRED
TO
HAVE
A
RESPONSE
CARD
FOR
THE
CS
COURSE
THESE
CAN
BE
PURCHASED
AT
THE
UNIVERSITY
STORE
ON
FIFTH
MOTIVATION
IN
CS
WE
OFTEN
DISCUSS
THE
IMPORTANCE
OF
DATA
STRUCTURE
DESIGN
AND
IMPLEMENTATION
TO
THE
WIDE
VARIETY
OF
COMPUTING
APPLICATIONS
DESPITE
DECADES
OF
STUDY
ORGANIZATIONS
MUST
STILL
REGULARLY
DEVELOP
CUSTOM
DATA
STRUCTURES
TO
FULFILL
THEIR
APPLICATIONS
SPECIFIC
NEEDS
AND
AS
SUCH
THE
FIELD
REMAINS
HUGELY
RELEVANT
TO
BOTH
COMPUTER
SCIENTISTS
AND
SOFTWARE
ENGINEERS
AS
AN
EXAMPLE
OF
THE
MAGNITUDE
OF
IMPACT
THAT
DATA
STRUCTURES
CAN
HAVE
ON
A
LARGE
SYSTEM
READ
THE
FOLLOWING
NEWS
ARTICLE
HTTP
WWW
PCWORLD
COM
ARTICLE
THE
TAO
OF
FACEBOOK
DATA
MANAGEMENT
HTML
IN
THIS
ASSIGNMENT
YOU
WILL
IMPLEMENT
TWO
DATA
STRUCTURES
TO
SATISFY
THEIR
SPECIFICATIONS
WHICH
ARE
PROVIDED
IN
THE
FORM
OF
INTERFACES
PROVIDED
CODE
FIRST
LOOK
OVER
THE
PROVIDED
CODE
YOU
CAN
FIND
THIS
CODE
ON
PITT
BOX
IN
A
FOLDER
NAMED
WHERE
IS
YOUR
PITT
USERNAME
THE
SETINTERFACE
E
INTERFACE
DESCRIBES
A
SET
A
DATA
STRUCTURE
SIMILAR
TO
A
BAG
EXCEPT
THAT
IT
DOES
NOT
ALLOW
DUPLICATES
IT
IS
A
GENERIC
INTERFACE
THAT
DECLARES
ABSTRACT
METHODS
FOR
ADDING
AN
ITEM
REMOVING
AN
ITEM
SPECIFIED
OR
UNSPECIFIED
CHECKING
IF
THE
SET
IS
EMPTY
CHECKING
THE
NUMBER
OF
ITEMS
IN
THE
SET
AND
FETCHING
THE
ITEMS
FROM
THE
SET
INTO
AN
ARRAY
YOU
SHOULD
NOT
MODIFY
THIS
INTERFACE
THE
SETFULLEXCEPTION
CLASS
IS
INCLUDED
TO
ALLOW
HYPOTHETICAL
IMPLEMENTATIONS
OF
SETINTERFACE
THAT
HAVE
A
FIXED
CAPACITY
YOUR
IMPLEMENTATION
SHOULD
NOT
BE
FIXED
CAPACITY
AND
THUS
SHOULD
NOT
THROW
THIS
EXCEPTION
THE
PROFILEINTERFACE
INTERFACE
DESCRIBES
A
SOCIAL
NETWORK
USER
PROFILE
IT
DECLARES
ABSTRACT
METHODS
FOR
SETTING
AND
GETTING
THE
USER
NAME
AND
ABOUT
ME
BLURB
FOLLOWING
OTHER
PROFILES
RETURNING
AN
ARRAY
OF
THE
PROFILE
FOLLOWED
PROFILES
AND
RECOMMENDING
A
NEW
USER
TO
FOLLOW
BASED
ON
THIS
PROFILE
FOLLOWED
BY
THOSE
I
FOLLOW
SET
YOU
SHOULD
NOT
MODIFY
THIS
INTERFACE
THE
SOCIALCLIENT
CLASS
IS
A
SAMPLE
CLIENT
OF
BOTH
SET
AND
PROFILE
IT
IS
A
SOCIAL
NETWORKING
SIMULATOR
THAT
ALLOWS
THE
USER
TO
CARRY
OUT
FOLLOWING
UNFOLLOWING
ETC
ON
A
SIMPLE
SOCIAL
NETWORK
THIS
CLASS
MAINTAINS
A
SET
OF
PROFILES
STORED
AS
SETINTERFACE
PROFILEINTERFACE
IT
ALSO
STORES
ITS
DATA
IN
A
FILE
SOCIALCLIENTDATA
BIN
WHEN
QUITTING
SO
THAT
IT
CAN
RESTORE
THIS
DATA
WHEN
IT
IS
RUN
AGAIN
AS
NOTED
ABOVE
THIS
CODE
IS
PROVIDED
ONLY
AS
AN
EXAMPLE
AND
MAY
NOT
TEST
ALL
FUNCTIONALITY
OF
THE
REQUIRED
CLASSES
TASKS
IMPLEMENT
SET
POINTS
DEVELOP
THE
GENERIC
CLASS
SET
E
A
DYNAMIC
CAPACITY
ARRAY
BASED
IMPLEMENTATION
OF
THE
SET
ADT
DESCRIBED
IN
SETINTERFACE
E
READ
THE
INTERFACE
CAREFULLY
INCLUDING
COMMENTS
TO
ENSURE
YOU
IMPLEMENT
IT
PROPERLY
IT
WILL
BE
GRADED
USING
A
CLIENT
THAT
ASSUMES
ALL
OF
THE
FUNCTIONALITY
DESCRIBED
IN
THE
SETINTERFACE
NOT
JUST
THE
BEHAVIOR
DEMONSTRATED
IN
SOCIALCLIENT
YOU
MUST
INCLUDE
A
CONSTRUCTOR
PUBLIC
SET
INT
CAPACITY
THAT
INITIALIZES
THE
ARRAY
TO
THE
SPECIFIED
INITIAL
CAPACITY
AND
A
CONSTRUCTOR
PUBLIC
SET
THAT
USES
A
REASONABLE
DEFAULT
INITIAL
CAPACITY
WHENEVER
THE
CAPACITY
IS
REACHED
THE
ARRAY
SHOULD
RESIZE
USING
THE
TECHNIQUES
DISCUSSED
IN
LECTURE
I
E
YOU
SHOULD
NEVER
THROW
SETFULLEXCEPTION
METHOD
POINTS
SET
SET
INT
INT
GETCURRENTSIZE
BOOLEAN
ISEMPTY
BOOLEAN
ADD
E
BOOLEAN
REMOVE
E
E
REMOVE
VOID
CLEAR
BOOLEAN
CONTAINS
E
E
TOARRAY
IMPLEMENT
PROFILE
POINTS
DEVELOP
THE
PROFILE
CLASS
AN
IMPLEMENTATION
OF
THE
ADT
DESCRIBED
IN
PROFILEINTERFACE
READ
THE
INTERFACE
CAREFULLY
INCLUDING
COMMENTS
TO
ENSURE
YOU
IMPLEMENT
IT
PROPERLY
AS
WITH
SET
IT
WILL
BE
GRADED
USING
A
CLIENT
THAT
EXPECTS
THE
FUNCTIONALITY
DESCRIBED
IN
ITS
INTERFACE
THE
PROFILE
CLASS
SHOULD
BE
A
CLIENT
OF
THE
SET
DATA
STRUCTURE
USE
COMPOSITION
WITH
YOUR
SET
E
CLASS
TO
STORE
THE
FOLLOWING
SET
AS
A
DATA
MEMBER
OF
TYPE
SET
PROFILE
OR
SET
PROFILEINTERFACE
YOU
MUST
INCLUDE
A
CONSTRUCTOR
PUBLIC
PROFILE
THAT
INITIALIZES
THE
NAME
AND
ABOUT
ME
BLURB
TO
BE
EMPTY
STRINGS
AND
A
CONSTRUCTOR
PUBLIC
PROFILE
STRING
NAME
STRING
ABOUT
THAT
INITIAL
IZES
THESE
DATA
MEMBERS
WITH
THE
SPECIFIED
VALUES
IN
THE
LATTER
YOU
MUST
CHECK
FOR
NULL
VALUES
FOR
BOTH
AND
REPLACE
ANY
NULL
VALUE
WITH
AN
EMPTY
STRING
METHOD
POINTS
PROFILE
PROFILE
STRING
STRING
VOID
SETNAME
STRING
STRING
GETNAME
VOID
SETABOUT
STRING
STRING
GETABOUT
BOOLEAN
FOLLOW
PROFILEINTERFACE
BOOLEAN
UNFOLLOW
PROFILEINTERFACE
PROFILEINTERFACE
FOLLOWING
INT
PROFILEINTERFACE
RECOMMEND
TESTING
SOCIALCLIENT
IS
PROVIDED
AS
AN
EXAMPLE
CLIENT
OF
THE
PROFILE
AND
SET
CLASSES
IT
DOES
NOT
EX
HAUSTIVELY
TEST
THE
FUNCTIONALITY
OF
THESE
CLASSES
YOU
ARE
RESPONSIBLE
FOR
ENSURING
YOUR
IMPLEMENTATIONS
WORK
PROPERLY
IN
ALL
CASES
EVEN
THOSE
NOT
TESTED
BY
SOCIALCLIENT
AND
FOLLOW
THE
ADTS
DESCRIBED
IN
THE
PROVIDED
INTERFACES
THUS
IT
IS
HIGHLY
RECOMMENDED
THAT
YOU
WRITE
ADDITIONAL
TEST
CLIENT
CODE
TO
TEST
ALL
OF
THE
CORNER
CASES
DESCRIBED
IN
THE
INTERFACES
FOR
HELP
GETTING
STARTED
RE
READ
THE
SECTION
OF
THE
TEXTBOOK
STARTING
AT
CHAPTER
SUBMISSION
UPLOAD
YOUR
JAVA
FILES
IN
THE
PROVIDED
BOX
DIRECTORY
IF
YOU
OVERWRITE
THE
PROVIDED
INTERFACES
REMEMBER
TO
RESTORE
THEM
TO
THEIR
ORIGINAL
VERSIONS
ALL
PROGRAMS
WILL
BE
TESTED
ON
THE
COMMAND
LINE
SO
IF
YOU
USE
AN
IDE
TO
DEVELOP
YOUR
PROGRAM
YOU
MUST
EXPORT
THE
JAVA
FILES
FROM
THE
IDE
AND
ENSURE
THAT
THEY
COMPILE
AND
RUN
ON
THE
COMMAND
LINE
DO
NOT
SUBMIT
THE
IDE
PROJECT
FILES
YOUR
TA
SHOULD
BE
ABLE
TO
DOWNLOAD
YOUR
DIRECTORY
FROM
BOX
AND
COMPILE
AND
RUN
YOUR
CODE
AS
DISCUSSED
IN
LAB
FOR
INSTANCE
JAVAC
SOCIALCLIENT
JAVA
AND
JAVA
SOCIALCLIENT
MUST
COMPILE
AND
RUN
SOCIALCLIENT
IN
ADDITION
TO
YOUR
CODE
YOU
MAY
WISH
TO
INCLUDE
A
README
TXT
FILE
THAT
DESCRIBES
FEATURES
OF
YOUR
PROGRAM
THAT
ARE
NOT
WORKING
AS
EXPECTED
TO
ASSIST
THE
TA
IN
GRADING
THE
PORTIONS
THAT
DO
WORK
AS
EXPECTED
YOUR
PROJECT
IS
DUE
AT
PM
ON
THURSDAY
FEBRUARY
YOU
SHOULD
UPLOAD
YOUR
PROGRESS
FREQUENTLY
EVEN
FAR
IN
ADVANCE
OF
THIS
DEADLINE
NO
LATE
ASSIGNMENTS
WILL
BE
ACCEPTED
MOTIVATION
IN
LECTURE
WE
DISCUSSED
AN
STACK
ALGORITHM
FOR
CONVERTING
AN
INFIX
EXPRESSION
TO
A
POSTFIX
EXPRESSION
AND
ANOTHER
FOR
EVALUATING
POSTFIX
EXPRESSIONS
WE
BRIEFLY
DESCRIBED
HOW
ONE
MIGHT
PIPELINE
THESE
ALGORITHMS
TO
EVALUATE
AN
INFIX
EXPRESSION
IN
A
SINGLE
PASS
USING
TWO
STACKS
WITHOUT
GENERATING
THE
FULL
POSTFIX
EXPRESSION
IN
BETWEEN
IN
THIS
ASSIGNMENT
YOU
WILL
BE
IMPLEMENTING
THIS
COMBINED
ALGORITHM
YOUR
COMPLETED
PROGRAM
WILL
EVALUATE
AN
INFIX
ARITHMETIC
EXPRESSION
USING
TWO
STACKS
YOU
ARE
PROVIDED
WITH
THE
SKELETON
OF
INFIXEXPRESSIONEVALUATOR
THIS
CLASS
ACCEPTS
INPUT
FROM
AN
INPUTSTREAM
AND
PARSES
IT
INTO
TOKENS
WHEN
IT
DETECTS
AN
INVALID
TOKEN
IT
THROWS
AN
EXPRESSIONERROR
TO
END
EXECUTION
TO
FACILITATE
EASE
OF
USE
THIS
CLASS
ALSO
CONTAINS
A
MAIN
METHOD
THIS
METHOD
INSTANTIATES
AN
OBJECT
OF
TYPE
INFIXEXPRESSIONEVALUATOR
TO
READ
FROM
SYSTEM
IN
THEN
EVALUATES
WHATEVER
EXPRESSION
IS
TYPED
IT
ALSO
CATCHES
ANY
POTENTIAL
EXPRESSIONERRORS
AND
PRINTS
THE
REASON
FOR
THE
ERROR
INFIXEXPRESSIONEVALUATOR
USES
COMPOSITION
TO
STORE
THE
OPERATOR
AND
OPERAND
STACKS
AND
CALLS
SEVERAL
PRIVATE
HELPER
METHODS
TO
MANIPULATE
THESE
STACKS
WHEN
PROCESSING
VARIOUS
TOKENS
YOU
WILL
NEED
TO
COMPLETE
THESE
HELPER
METHODS
AND
ADD
ERROR
CHECKING
TO
ENSURE
THE
EXPRESSION
IS
VALID
TASKS
FIRST
CAREFULLY
READ
THE
PROVIDED
CODE
YOU
CAN
FIND
THIS
CODE
ON
PITT
BOX
IN
A
FOLDER
NAMED
WHERE
IS
YOUR
PITT
USERNAME
IMPLEMENT
HELPER
METHODS
POINTS
AS
TOKENS
ARE
PARSED
HELPER
METHODS
ARE
CALLED
TO
PROCESS
THEM
IN
THE
INCLUDED
CODE
THESE
HELPER
METHODS
DO
NOT
DO
ANYTHING
YOU
MUST
IMPLEMENT
THE
FOLLOWING
METHODS
TO
PROCESS
THE
VARIOUS
TYPES
OF
TOKENS
PROCESSOPERAND
DOUBLE
EACH
TIME
THE
EVALUATOR
ENCOUNTERS
AN
OPERAND
IT
PASSES
IT
AS
A
DOUBLE
TO
THIS
METHOD
WHICH
SHOULD
PROCESS
IT
BY
MANIPULATING
THE
OPERAND
AND
OR
OPERATOR
STACK
ACCORDING
TO
THE
INFIX
TO
POSTFIX
AND
POSTFIX
EVALUATION
ALGORITHMS
PROCESSOPERATOR
CHAR
EACH
TIME
THE
EVALUATOR
ENCOUNTERS
AN
OPERATOR
IT
PASSES
IT
AS
A
CHAR
TO
THIS
METHOD
WHICH
SHOULD
PROCESS
IT
BY
MANIPULATING
THE
OPERAND
AND
OR
OPERATOR
STACK
ACCORDING
TO
THE
INFIX
TO
POSTFIX
AND
POSTFIX
EVALUATION
ALGORITHMS
EACH
OF
THE
FOLLOWING
OPERATORS
MUST
BE
SUPPORTED
FOLLOW
STANDARD
OPERATOR
PRECE
DENCE
YOU
CAN
ASSUME
THAT
IS
ALWAYS
THE
BINARY
SUBTRACTION
OPERATOR
ADDITION
SUBTRACTION
MULTIPLICATION
DIVISION
EXPONENTIATION
PROCESSOPENBRACKET
CHAR
EACH
TIME
THE
EVALUATOR
ENCOUNTERS
AN
OPEN
BRACKET
IT
PASSES
IT
AS
A
CHAR
TO
THIS
METHOD
WHICH
SHOULD
PROCESS
IT
BY
MANIPULATING
THE
OPERAND
AND
OR
OPERATOR
STACK
ACCORDING
TO
THE
INFIX
TO
POSTFIX
AND
POSTFIX
EVALUATION
ALGO
RITHMS
YOU
MUST
SUPPORT
BOTH
ROUND
BRACKETS
AND
SQUARE
BRACKETS
THESE
BRACKETS
CAN
BE
USED
INTERCHANGEABLY
BUT
MUST
BE
NESTED
PROPERLY
A
CANNOT
BE
CLOSED
WITH
A
AND
VICE
VERSA
PROCESSCLOSEBRACKET
CHAR
EACH
TIME
THE
EVALUATOR
ENCOUNTERS
A
CLOSE
BRACKET
IT
PASSES
IT
AS
A
CHAR
TO
THIS
METHOD
WHICH
SHOULD
PROCESS
IT
BY
MANIPULATING
THE
OPERAND
AND
OR
OPERATOR
STACK
ACCORDING
TO
THE
INFIX
TO
POSTFIX
AND
POSTFIX
EVALUATION
ALGO
RITHMS
PROCESSREMAININGOPERATORS
WHEN
THE
EVALUATOR
ENCOUNTERS
THE
END
OF
THE
EXPRESSION
IT
CALLS
THIS
METHOD
TO
HANDLE
THE
REMAINING
OPERATORS
ON
THE
OPERATOR
STACK
ERROR
CHECKING
POINTS
THIS
TASK
REQUIRES
THAT
YOU
MODIFY
YOUR
PROGRAM
TO
ACCOUNT
FOR
ERRORS
IN
THE
INPUT
EXPRES
SION
THE
PROVIDED
CODE
THROWS
EXPRESSIONERROR
WHEN
ENCOUNTERING
AN
UNKNOWN
TOKEN
FOR
INSTANCE
YOU
MUST
MODIFY
YOUR
PROGRAM
TO
THROW
THIS
EXCEPTION
WITH
AN
APPROPRIATE
MESSAGE
WHENEVER
THE
EXPRESSION
IS
INVALID
THIS
REQUIRES
CAREFUL
CONSIDERATION
OF
ALL
THE
POSSIBLE
SYNTAX
ERRORS
WHAT
IF
AN
OPERAND
FOLLOWS
ANOTHER
OPERAND
AN
OPERATOR
FOLLOWING
AN
OPEN
BRACKET
WHAT
ABOUT
BRACKETS
THAT
DO
NOT
NEST
PROPERLY
ALL
SUCH
SYNTAX
ERRORS
MUST
BE
HANDLED
USING
EXPRESSIONERROR
GRADING
THE
FOLLOWING
POINTS
BREAKDOWN
WILL
BE
USED
TO
ASSIGN
GRADES
POINTS
ARE
ALLOCATED
FOR
CORRECTLY
EVALUATING
VALID
EXPRESSIONS
THESE
EXPRESSIONS
WILL
RANGE
FROM
VERY
SIMPLE
TO
VERY
COMPLEX
BUT
NONE
WILL
CONTAIN
SYNTAX
ERRORS
YOU
SHOULD
TEST
YOUR
PROGRAM
EXTENSIVELY
TO
ENSURE
THAT
IT
WORKS
PROPERLY
EVEN
FOR
COMPLEX
EXPRESSIONS
POINTS
ARE
ALLOCATED
FOR
CORRECTLY
IDENTIFYING
THE
SYNTAX
ERRORS
IN
INVALID
EXPRES
SIONS
THESE
EXPRESSIONS
WILL
CONTAIN
A
WIDE
VARIETY
OF
SYNTAX
ERRORS
YOU
SHOULD
TEST
YOUR
PROGRAM
WITH
MANY
INVALID
EXPRESSIONS
TO
ENSURE
THAT
IT
CORRECTLY
DETECTS
ALL
POSSIBLE
SYNTAX
ERRORS
SUBMISSION
UPLOAD
YOUR
JAVA
FILES
IN
THE
PROVIDED
BOX
DIRECTORY
AS
EDITS
OR
ADDITIONS
TO
THE
PROVIDED
CODE
ALL
PROGRAMS
WILL
BE
TESTED
ON
THE
COMMAND
LINE
SO
IF
YOU
USE
AN
IDE
TO
DEVELOP
YOUR
PROGRAM
YOU
MUST
EXPORT
THE
JAVA
FILES
FROM
THE
IDE
AND
ENSURE
THAT
THEY
COMPILE
AND
RUN
ON
THE
COMMAND
LINE
DO
NOT
SUBMIT
THE
IDE
PROJECT
FILES
YOUR
TA
SHOULD
BE
ABLE
TO
DOWNLOAD
YOUR
DIRECTORY
FROM
BOX
AND
COMPILE
AND
RUN
YOUR
CODE
SPECIFICALLY
JAVAC
INFIXEXPRESSIONEVALUATOR
JAVA
AND
JAVA
INFIXEXPRESSIONEVALUATOR
MUST
COMPILE
AND
RUN
YOUR
PROGRAM
WHEN
EXECUTED
FROM
THE
ROOT
OF
YOUR
DIRECTORY
IN
ADDITION
TO
YOUR
CODE
YOU
MAY
WISH
TO
INCLUDE
A
README
TXT
FILE
THAT
DESCRIBES
FEATURES
OF
YOUR
PROGRAM
THAT
ARE
NOT
WORKING
AS
EXPECTED
TO
ASSIST
THE
TA
IN
GRADING
THE
PORTIONS
THAT
DO
WORK
AS
EXPECTED
YOUR
PROJECT
IS
DUE
AT
PM
ON
THURSDAY
FEBRUARY
YOU
SHOULD
UPLOAD
YOUR
PROGRESS
FREQUENTLY
EVEN
FAR
IN
ADVANCE
OF
THIS
DEADLINE
NO
LATE
ASSIGNMENTS
WILL
BE
ACCEPTED
MOTIVATION
IN
THIS
ASSIGNMENT
YOU
WILL
USE
BACKTRACKING
TO
SOLVE
THE
SUDOKU
PUZZLE
IF
YOU
ARE
NOT
FAMILIAR
WITH
THIS
PUZZLE
REVIEW
THE
RULES
HERE
HTTP
WWW
SUDOKU
NAME
RULES
EN
PROVIDED
FILES
FIRST
CAREFULLY
READ
THE
PROVIDED
FILES
YOU
CAN
FIND
THESE
FILES
ON
PITT
BOX
IN
A
FOLDER
NAMED
WHERE
IS
YOUR
PITT
USERNAME
PROVIDED
CODE
THE
QUEENS
CLASS
INCLUDES
A
BACKTRACKING
SOLUTION
TO
THE
QUEENS
PROBLEM
IF
YOU
RUN
THIS
CLASS
WITH
THE
T
FLAG
IT
WILL
TEST
ITS
REJECT
ISFULLSOLUTION
EXTEND
NEXT
METHODS
THE
SUDOKU
CLASS
INCLUDES
THE
BASIC
SKELETON
OF
A
BACKTRACKING
SOLUTION
TO
THE
SUDOKU
PUZZLE
THIS
CLASS
INCLUDES
THE
METHOD
READBOARD
WHICH
READS
IN
A
BOARD
AND
RETURNS
IT
AS
A
INT
ARRAY
THIS
ARRAY
WILL
CONTAIN
A
FOR
ALL
EMPTY
CELLS
IT
ALSO
INCLUDES
THE
METHOD
PRINTBOARD
WHICH
PRINTS
OUT
A
BOARD
TO
SYSTEM
OUT
IT
IS
RECOMMENDED
THAT
YOU
USE
THIS
PROVIDED
CODE
AS
A
STARTING
POINT
HOWEVER
YOU
MAY
CHOOSE
NOT
TO
USE
THIS
PROVIDED
CODE
AS
LONG
AS
YOUR
PROGRAM
READS
THE
SAME
INPUT
FORMAT
AND
USES
THE
REQUIRED
BACKTRACKING
TECHNIQUES
EXAMPLE
INPUTS
EXAMPLE
SUDOKU
BOARDS
ARE
AVAILABLE
FOR
YOU
TO
TEST
YOUR
CODE
IN
THE
BOARDS
DIRECTORY
WITHIN
YOUR
PERSONAL
BOX
FOLDER
TASKS
YOU
MUST
WRITE
A
BACKTRACKING
PROGRAM
TO
FIND
VALUES
FOR
ALL
OF
THE
CELLS
IN
A
SUDOKU
PUZZLE
WITHOUT
CHANGING
ANY
OF
THE
CELLS
SPECIFIED
IN
THE
ORIGINAL
PUZZLE
YOU
MUST
ALSO
SATISFY
THE
SUDOKU
RULES
NO
NUMBER
MAY
APPEAR
TWICE
IN
ANY
ROW
COLUMN
OR
REGION
YOU
MUST
ACCOMPLISH
THIS
USING
THE
BACKTRACKING
TECHNIQUES
DISCUSSED
AND
DEMONSTRATED
IN
LECTURE
AND
IN
QUEENS
JAVA
THAT
IS
YOU
NEED
TO
BUILD
UP
A
SOLUTION
RECURSIVELY
ONE
CELL
AT
A
TIME
UNTIL
YOU
DETERMINE
THAT
THE
CURRENT
BOARD
ASSIGNMENT
IS
IMPOSSIBLE
TO
COMPLETE
IN
WHICH
CASE
YOU
WILL
BACKTRACK
AND
TRY
ANOTHER
ASSIGNMENT
OR
THAT
THE
CURRENT
BOARD
ASSIGNMENT
IS
COMPLETE
AND
VALID
YOUR
PROGRAM
WILL
READ
IN
THE
INITIAL
BOARD
FROM
A
FILE
THIS
INITIAL
BOARD
WILL
HAVE
SEVERAL
CELLS
ALREADY
FILLED
THE
REMAINING
CELLS
WILL
BE
EMPTY
THE
GOAL
IS
TO
FIND
THE
VALUES
OF
ALL
THE
CELLS
IN
THE
PUZZLE
WITHOUT
CHANGING
ANY
OF
THE
CELLS
SPECIFIED
IN
THE
ORIGINAL
PUZZLE
THIS
FILE
WILL
CONTAIN
LINES
OF
TEXT
EACH
CONTAINING
CHARACTERS
EACH
CHARACTER
WILL
EITHER
BE
A
DIGIT
THROUGH
OR
A
NON
NUMERIC
CHARACTER
SUCH
AS
A
SPACE
OR
A
DOT
DESIGNATING
AN
EMPTY
CELL
YOUR
CLASS
MUST
BE
NAMED
SUDOKU
AND
THEREFORE
MUST
BE
IN
A
FILE
WITH
THE
NAME
SUDOKU
JAVA
IT
MUST
ALSO
BE
IN
THE
PACKAGE
YOUR
PROGRAM
MUST
BE
USABLE
FROM
THE
COMMAND
LINE
USING
THE
FOLLOWING
COMMAND
JAVA
SUDOKU
SU
IF
THERE
IS
A
WAY
TO
SOLVE
THE
PUZZLE
DESCRIBED
IN
SU
YOUR
PROGRAM
SHOULD
OUTPUT
THE
COMPLETED
PUZZLE
YOU
DO
NOT
NEED
TO
FIND
EVERY
POSSIBLE
SOLUTION
IF
THERE
ARE
MULTIPLE
SOLUTIONS
JUST
ONE
SOLUTION
WILL
DO
IF
THERE
IS
NO
SOLUTION
YOUR
PROGRAM
SHOULD
OUTPUT
A
MESSAGE
INDICATING
AS
SUCH
REQUIRED
METHODS
AS
STATED
ABOVE
YOU
MUST
USE
THE
TECHNIQUES
WE
DISCUSSED
IN
LECTURE
FOR
RECURSIVE
BACKTRACKING
AS
SUCH
YOU
WILL
THEN
NEED
TO
WRITE
THE
FOLLOWING
METHODS
TO
SUPPORT
YOUR
BACKTRACKING
ALGORITHM
ISFULLSOLUTION
A
METHOD
THAT
ACCEPTS
A
PARTIAL
SOLUTION
AND
RETURNS
TRUE
IF
IT
IS
A
COMPLETE
VALID
SOLUTION
REJECT
A
METHOD
THAT
ACCEPTS
A
PARTIAL
SOLUTION
AND
RETURNS
TRUE
IF
IT
SHOULD
BE
REJECTED
BECAUSE
IT
CAN
NEVER
BE
EXTENDED
INTO
A
COMPLETE
SOLUTION
EXTEND
A
METHOD
THAT
ACCEPTS
A
PARTIAL
SOLUTION
AND
RETURNS
ANOTHER
PARTIAL
SOLUTION
THAT
INCLUDES
ONE
ADDITIONAL
CHOICE
ADDED
ON
THIS
METHOD
WILL
RETURN
NULL
IF
THERE
ARE
NO
MORE
CHOICES
TO
ADD
TO
THE
SOLUTION
NEXT
A
METHOD
THAT
ACCEPTS
A
PARTIAL
SOLUTION
AND
RETURNS
ANOTHER
PARTIAL
SOLUTION
IN
WHICH
THE
MOST
RECENT
CHOICE
THAT
WAS
ADDED
HAS
BEEN
CHANGED
TO
ITS
NEXT
OPTION
THIS
METHOD
WILL
RETURN
NULL
IF
THERE
ARE
NO
MORE
OPTIONS
FOR
THE
MOST
RECENT
CHOICE
THAT
WAS
MADE
TEST
METHODS
WHEN
DEVELOPING
A
COMPLEX
PROGRAM
SUCH
AS
THIS
ONE
IT
IS
IMPORTANT
TO
TEST
YOUR
PROGRESS
AS
YOU
GO
FOR
THIS
REASON
IN
ADDITION
TO
THE
BACKTRACKING
SUPPORTING
METHODS
ABOVE
YOU
WILL
BE
REQUIRED
TO
TEST
YOUR
METHODS
AS
YOU
DEVELOP
THEM
RE
READ
STARTING
AT
CHAPTER
TO
REVIEW
THE
CONCEPTS
BEHIND
WRITING
TEST
METHODS
TO
TEST
EACH
OF
THE
BACKTRACKING
METHODS
YOU
NEED
TO
WRITE
THE
FOLLOWING
TEST
METHODS
FOR
EACH
ONE
YOU
SHOULD
CREATE
A
WIDE
VARIETY
OF
PARTIAL
SOLUTIONS
THAT
FIT
AS
MANY
CORNER
CASES
AS
YOU
CAN
THINK
OF
INCLUDE
ENOUGH
TEST
CASES
THAT
THE
CORRECT
OUTPUT
CONVINCES
YOU
THAT
YOUR
METHOD
WORKS
PROPERLY
IN
ALL
SITUATIONS
TESTISFULLSOLUTION
A
METHOD
THAT
GENERATES
PARTIAL
SOLUTIONS
AND
ENSURES
THAT
THE
ISFULLSOLUTION
METHOD
CORRECTLY
DETERMINES
WHETHER
EACH
IS
A
COMPLETE
SOLUTION
TESTREJECT
A
METHOD
THAT
GENERATES
PARTIAL
SOLUTIONS
AND
ENSURES
THAT
THE
REJECT
METHOD
CORRECTLY
DETERMINES
WHETHER
EACH
SHOULD
BE
REJECTED
TESTEXTEND
A
METHOD
THAT
GENERATES
PARTIAL
SOLUTIONS
AND
ENSURES
THAT
THE
EXTEND
METHOD
CORRECTLY
EXTENDS
EACH
WITH
THE
CORRECT
NEXT
CHOICE
TESTNEXT
A
METHOD
THAT
GENERATES
PARTIAL
SOLUTIONS
AND
ENSURES
THAT
THE
IN
EACH
NEXT
METHOD
CORRECTLY
CHANGES
THE
MOST
RECENT
CHOICE
THAT
WAS
ADDED
TO
ITS
NEXT
OPTION
YOU
MAY
EITHER
HARDCODE
YOUR
TEST
PARTIAL
SOLUTIONS
OR
UPLOAD
SU
FILES
CONTAINING
THE
BOARDS
YOU
WANT
TO
TEST
IN
EITHER
CASE
WHEN
YOUR
PROGRAM
IS
RUN
WITH
THE
T
FLAG
YOUR
PROGRAM
MUST
RUN
THE
ABOVE
FOUR
TEST
METHODS
AND
OUTPUT
THE
RESULTS
GRADING
YOUR
GRADE
FOR
THIS
ASSIGNMENT
WILL
BE
BASED
ON
YOUR
PROGRAM
SUCCESS
AT
SOLVING
A
SERIES
OF
UNKNOWN
SUDOKU
PUZZLES
AND
THE
THOROUGHNESS
OF
YOUR
TEST
METHODS
SUBMISSION
UPLOAD
YOUR
JAVA
FILES
IN
THE
PROVIDED
BOX
DIRECTORY
AS
EDITS
OR
ADDITIONS
TO
THE
PROVIDED
CODE
ALL
PROGRAMS
WILL
BE
TESTED
ON
THE
COMMAND
LINE
SO
IF
YOU
USE
AN
IDE
TO
DEVELOP
YOUR
PROGRAM
YOU
MUST
EXPORT
THE
JAVA
FILES
FROM
THE
IDE
AND
ENSURE
THAT
THEY
COMPILE
AND
RUN
ON
THE
COMMAND
LINE
DO
NOT
SUBMIT
THE
IDE
PROJECT
FILES
YOUR
TA
SHOULD
BE
ABLE
TO
DOWNLOAD
YOUR
DIRECTORY
FROM
BOX
AND
COMPILE
AND
RUN
YOUR
CODE
SPECIFICALLY
JAVAC
SUDOKU
JAVA
AND
JAVA
SUDOKU
SU
MUST
COMPILE
AND
RUN
YOUR
PROGRAM
WHEN
EXECUTED
FROM
THE
ROOT
OF
YOUR
DIRECTORY
IN
ADDITION
TO
YOUR
CODE
YOU
MAY
WISH
TO
INCLUDE
A
README
TXT
FILE
THAT
DESCRIBES
FEATURES
OF
YOUR
PROGRAM
THAT
ARE
NOT
WORKING
AS
EXPECTED
TO
ASSIST
THE
TA
IN
GRADING
THE
PORTIONS
THAT
DO
WORK
AS
EXPECTED
YOUR
PROJECT
IS
DUE
AT
PM
ON
SATURDAY
MARCH
YOU
SHOULD
UPLOAD
YOUR
PROGRESS
FREQUENTLY
EVEN
FAR
IN
ADVANCE
OF
THIS
DEADLINE
NO
LATE
SUBMISSIONS
WILL
BE
ACCEPTED
MOTIVATION
IMAGINE
THAT
YOU
ARE
STARTING
A
STREAMING
RADIO
BUSINESS
PARTNERSHIPS
HAVE
BEEN
ESTABLISHED
TO
PROVIDE
YOU
WITH
AUDIO
CONTENT
AND
YOU
WILL
STREAM
THAT
CONTENT
TO
USERS
YOU
PLAN
TO
USE
YOUR
KNOWLEDGE
OF
WHAT
SONGS
YOUR
USERS
LIKE
DISLIKE
TO
MAKE
EFFECTIVE
SUGGESTIONS
FOR
NEW
SONGS
THAT
THEY
WILL
LIKE
IN
THIS
ASSIGNMENT
YOU
WILL
CONSIDER
SUCH
A
STREAMING
RADIO
SERVICE
YOU
WILL
BE
DE
SIGNING
AN
ABSTRACT
DATA
TYPE
ADT
THAT
STORES
THE
SERVICE
MUSIC
LIBRARY
AND
USERS
LIKE
DISLIKE
OF
SONGS
THIS
ADT
REPRESENTS
A
DATA
STRUCTURE
THAT
WILL
BE
USED
BY
BOTH
CLIENT
APPLICATIONS
AND
FOR
ADMINISTRATIVE
USES
E
G
ADDING
NEW
SONGS
TO
THE
LIBRARY
ONCE
YOU
COMPLETE
THIS
ADT
YOU
COULD
PROVIDE
IT
TO
THE
PROGRAMMERS
OF
THE
CLIENT
APPLICATIONS
AND
THEY
WILL
BE
ABLE
TO
DEVELOP
APPLICATIONS
BASED
ON
THIS
SPECIFICATION
MUCH
LIKE
YOU
WERE
TASKED
WITH
DOING
IN
ON
THE
OTHER
HAND
YOU
CAN
ALSO
DISTRIBUTE
THE
ADT
TO
THE
ENGINEERS
IN
CHARGE
OF
IMPLEMENTING
THE
FUNCTIONALITY
OF
THE
DATA
STRUCTURE
THUS
THESE
TWO
PARTIES
CAN
WORK
IN
PARALLEL
ON
THEIR
RESPECTIVE
COMPONENTS
WHICH
CAN
WORK
TOGETHER
BY
VIRTUE
OF
BOTH
FOLLOWING
THE
CONTRACT
THAT
YOUR
ADT
PROVIDES
PROVIDED
FILES
FIRST
CAREFULLY
READ
THE
PROVIDED
FILES
YOU
CAN
FIND
THESE
FILES
ON
PITT
BOX
IN
A
FOLDER
NAMED
WHERE
IS
YOUR
PITT
USERNAME
THE
STREAMINGRADIO
INTERFACE
IS
A
SKELETON
OF
YOUR
ADT
MANY
DETAILS
WILL
NEED
TO
BE
FILLED
IN
SEE
TASKS
THE
USER
SONG
AND
STATION
INTERFACES
ARE
PROVIDED
AS
TYPES
FOR
YOUR
METHODS
PARAMETERS
AND
OR
RETURN
TYPES
THE
DOC
DIRECTORY
CONTAINS
JAVADOC
STYLE
DOCUMENTATION
OF
THE
PROVIDED
CODE
OPEN
INDEX
HTML
TASKS
YOU
MUST
WRITE
AN
ABSTRACT
DATA
TYPE
AS
A
JAVA
INTERFACE
YOU
WILL
NEED
TO
DECLARE
SEVERAL
ABSTRACT
METHODS
THAT
THE
DATA
STRUCTURE
WOULD
NEED
TO
SUPPORT
YOU
SHOULD
CONSIDER
ALL
POSSIBLE
CORNER
CASES
IN
YOUR
SPECIFICATION
AND
DESCRIBE
WHAT
THE
CLASS
SHOULD
DO
IN
ALL
CASES
A
CLIENT
THAT
READS
YOUR
ADT
SHOULD
KNOW
ALL
THE
THINGS
THAT
COULD
GO
WRONG
AND
HOW
THEY
WILL
BE
HANDLED
FOR
SOME
OF
THESE
CORNER
CASES
YOU
WILL
NEED
TO
MAKE
A
DESIGN
DECISION
REGARDING
THE
BEST
WAY
TO
HANDLE
THEM
HELPER
TYPES
WHEN
DEVELOPING
YOUR
ADT
YOU
CAN
ASSUME
THE
FOLLOWING
TYPES
EXIST
USER
REPRESENTS
A
USER
SONG
REPRESENTS
A
SONG
STATION
REPRESENTS
A
COLLECTION
OF
SONGS
A
PLAYLIST
FOR
A
RADIO
STATION
YOU
DO
NOT
NEED
TO
MAKE
ANY
ASSUMPTIONS
NOR
WRITE
ANY
CODE
REGARDING
THE
DETAILS
OF
THESE
DATA
STRUCTURES
THEY
ARE
PROVIDED
TO
HELP
YOU
SPECIFY
PARAMETER
AND
RETURN
TYPES
CORRECTLY
INTERFACES
REPRESENTING
THESE
TYPES
ARE
PROVIDED
BUT
DO
NOT
DECLARE
ANY
METHODS
SINCE
THEIR
DETAILS
ARE
NOT
NEEDED
IN
THIS
ASSIGNMENT
YOU
CAN
ASSUME
THAT
THESE
INTERFACES
AND
THEIR
IMPLEMENTATIONS
WOULD
BE
DEVELOPED
SEPARATELY
ABSTRACT
METHODS
TO
DECLARE
YOU
WILL
NEED
TO
DECLARE
EACH
OF
THE
FOLLOWING
ABSTRACT
METHODS
IN
YOUR
STREAMINGRADIO
INTERFACE
ADDSONG
ADDS
A
NEW
SONG
TO
THE
SYSTEM
REMOVESONG
REMOVES
AN
EXISTING
SONG
FROM
THE
SYSTEM
ADDTOSTATION
ADDS
AN
EXISTING
SONG
TO
THE
PLAYLIST
FOR
AN
EXISTING
RADIO
STATION
REMOVEFROMSTATION
REMOVES
A
SONG
FROM
THE
PLAYLIST
FOR
A
RADIO
STATION
RATESONG
SETS
AN
EXISTING
USER
RATING
FOR
AN
EXISTING
SONG
AS
EITHER
LIKE
OR
DISLIKE
CLEARRATING
CLEARS
AN
EXISTING
USER
RATING
ON
A
SONG
PREDICTRATING
PREDICTS
WHETHER
A
USER
WILL
LIKE
OR
DISLIKE
A
SONG
THAT
THEY
HAVE
NOT
YET
RATED
SUGGESTSONG
SUGGESTS
A
SONG
FOR
A
USER
THAT
THEY
ARE
PREDICTED
TO
LIKE
YOU
CAN
ASSUME
THAT
THE
SET
OF
USERS
AND
THE
SET
OF
RADIO
STATIONS
ARE
FIXED
E
G
AT
INITIAL
IZATION
AND
THUS
YOU
DO
NOT
NEED
TO
INCLUDE
OPERATIONS
TO
CHANGE
THESE
COLLECTIONS
YOU
WILL
BE
COMPLETING
THE
INTERFACE
STREAMINGRADIO
A
TEMPLATE
OF
WHICH
IS
INCLUDED
IN
THE
PROVIDED
CODE
WE
HAVE
COMPLETED
CLEARRATING
FOR
YOU
AS
AN
EXAMPLE
TO
HELP
YOU
GET
STARTED
YOU
ARE
ALLOWED
TO
MODIFY
THIS
METHOD
FOR
CONSISTENCY
WITH
THE
OTHERS
IF
YOU
TAKE
A
DIFFERENT
APPROACH
THAN
THAT
PRESENTED
THE
OTHER
ABSTRACT
METHODS
ARE
INITIALLY
DECLARED
AS
VOID
METHODS
WITH
NO
PARAMETERS
YOU
NEED
TO
EXPAND
EACH
DECLARATION
TO
SPECIFY
A
RETURN
TYPE
AND
PARAMETERS
AS
NECESSARY
YOU
ALSO
NEED
TO
INCLUDE
A
DETAILED
COMMENT
FOR
EACH
ABSTRACT
METHOD
DESCRIBING
ITS
EFFECT
ITS
INPUT
PARAMETERS
ITS
RETURN
VALUE
ANY
CORNER
CASES
THAT
THE
CLIENT
MAY
NEED
TO
CONSIDER
ANY
EXCEPTIONS
THE
METHOD
MAY
THROW
INCLUDING
A
DESCRIPTION
OF
THE
CIRCUMSTANCES
UNDER
WHICH
THIS
WILL
HAPPEN
AND
SO
ON
YOU
SHOULD
INCLUDE
ENOUGH
DETAILS
THAT
A
CLIENT
COULD
USE
THIS
DATA
STRUCTURE
WITHOUT
EVER
BEING
SURPRISED
OR
NOT
KNOWING
WHAT
WILL
HAPPEN
EVEN
THOUGH
THEY
HAVEN
T
SEEN
THE
IMPLEMENTATION
FINALLY
YOU
SHOULD
USE
JAVADOC
STYLE
COMMENTS
WHERE
APPROPRIATE
SO
THAT
RUNNING
JAVADOC
ON
YOUR
CODE
WILL
PRODUCE
A
READABLE
DOCUMENTATION
PAGE
YOU
DO
NOT
NEED
TO
USE
ADVANCED
FEATURES
OF
JAVADOC
BUT
YOU
SHOULD
INCLUDE
PARAM
RETURN
AND
THROWS
COMMENTS
AS
IN
OUR
EXAMPLE
CODE
FROM
CLASS
AND
THE
TEXTBOOK
A
DOCUMENTATION
PAGE
FOR
THE
INITIAL
STREAMINGRADIO
INTERFACE
IS
INCLUDED
IN
THE
PROVIDED
CODE
THIS
WAS
GENERATED
USING
THE
FOLLOWING
COMMAND
JAVADOC
D
DOC
JAVA
NOTE
HERE
THAT
JAVA
SPECIFIES
THAT
ALL
JAVA
FILES
WITHIN
SHOULD
BE
PROCESSED
AND
D
DOC
SPECIFIES
THAT
THE
JAVADOC
OUTPUT
SHOULD
BE
CREATED
IN
A
DIRECTORY
NAMED
DOC
FINALLY
TO
TEST
IF
YOUR
INTERFACE
IS
WELL
FORMED
YOU
SHOULD
COMPILE
IT
USING
JAVAC
FROM
THE
COMMAND
LINE
YOU
MUST
INCLUDE
YOUR
CODE
IN
THE
PACKAGE
YOU
WILL
NOT
BE
ABLE
TO
RUN
YOUR
PROGRAM
BECAUSE
YOU
WILL
NOT
BE
WRITING
ANY
EXECUTABLE
CODE
MUCH
LESS
A
MAIN
METHOD
IT
SHOULD
HOWEVER
COMPILE
SUCCESSFULLY
GRADING
YOUR
GRADE
WILL
BE
ASSIGNED
BASED
ON
WHETHER
THE
CODE
IS
IN
THE
CORRECT
FORM
AND
COMPILES
SUCCESSFULLY
WHETHER
JAVADOC
GENERATES
DOCUMENTATION
CORRECTLY
AND
YOUR
SPECIFICATION
OF
EACH
OF
THE
REQUIRED
ABSTRACT
METHODS
ADDSONG
REMOVESONG
ADDTOSTATION
REMOVEFROMSTATION
RATESONG
PREDICTRATING
AND
SUGGESTSONG
SUBMISSION
UPLOAD
YOUR
JAVA
FILES
IN
THE
PROVIDED
BOX
DIRECTORY
AS
EDITS
OR
ADDITIONS
TO
THE
PROVIDED
CODE
ALL
PROGRAMS
WILL
BE
TESTED
ON
THE
COMMAND
LINE
SO
IF
YOU
USE
AN
IDE
TO
DEVELOP
YOUR
PROGRAM
YOU
MUST
EXPORT
THE
JAVA
FILES
FROM
THE
IDE
AND
ENSURE
THAT
THEY
COMPILE
AND
GENERATE
JAVADOC
DOCUMENTATION
FROM
THE
COMMAND
LINE
DO
NOT
SUBMIT
THE
IDE
PROJECT
FILES
YOUR
PROJECT
IS
DUE
AT
PM
ON
THURSDAY
MARCH
YOU
SHOULD
UPLOAD
YOUR
PROGRESS
FREQUENTLY
EVEN
FAR
IN
ADVANCE
OF
THIS
DEADLINE
NO
LATE
SUBMISSIONS
WILL
BE
ACCEPTED
CS
DATA
STRUCTURES
HTTPS
PEOPLE
CS
PITT
EDU
BILL
HOME
CS
DATA
STRUCTURES
SECTION
B
SPRING
HOME
POLICY
LECTURES
LABS
ASSIGNMENTS
GENERAL
INFORMATION
CS
DATA
STRUCTURES
HTTPS
PEOPLE
CS
PITT
EDU
BILL
HOME
COURSE
DESCRIPTION
THIS
COURSE
EMPHASIZES
THE
STUDY
OF
THE
BASIC
DATA
STRUCTURES
OF
COMPUTER
SCIENCE
E
G
BAGS
LISTS
STACKS
QUEUES
TREES
AND
THEIR
IMPLEMENTATIONS
USING
THE
JAVA
LANGUAGE
WE
WILL
COVER
OBJECTS
AND
REFERENCE
VARIABLES
AS
WELL
AS
PROGRAMMING
TECHNIQUES
THAT
USE
RECURSION
STUDENTS
WILL
BE
INTRODUCED
TO
VARIOUS
SEARCHING
AND
SORTING
METHODS
AND
WILL
DEVELOP
AN
INTUITIVE
UNDERSTANDING
OF
THE
COMPLEXITY
OF
ALGORITHMS
TEXTBOOK
FRANK
M
CARRANO
AND
TIMOTHY
M
HENRY
DATA
STRUCTURES
AND
ABSTRACTIONS
WITH
JAVA
EDITION
PEARSON
ISBN
ONLINE
TEXTBOOK
RESOURCES
AVAILABLE
HERE
TOP
HAT
STUDENTS
MUST
SUBSCRIBE
TO
TOP
HAT
THE
PLATFORM
WE
WILL
USE
FOR
LECTURE
PARTICIPATION
PLEASE
SEE
LECTURES
FOR
INSTRUCTIONS
GRADING
EXAMS
HIGHER
GRADE
IS
ASSIGNMENTS
LOWEST
GRADE
IS
WEIGHTED
THE
OTHERS
TOP
HAT
ATTENDANCE
AND
LECTURE
QUESTIONS
RECITATION
QUIZZES
CS
DATA
STRUCTURES
SPRING
MIDTERM
EXAMINATION
STUDY
GUIDE
JAVA
PREREQUISITES
TOPICS
CLASSES
OBJECTS
AND
REFERENCES
ACCESS
MODIFIERS
ARGUMENTS
AND
PARAMETERS
GARBAGE
COLLECTION
SELF
TEST
QUESTIONS
APPENDIX
C
DESIGNING
CLASSES
TOPICS
COMPOSITION
AND
INHERITANCE
ACCESS
MODIFIERS
STATIC
KEYWORD
OVERRIDING
METHODS
DYNAMIC
BINDING
AND
METHOD
POLYMORPHISM
REFERENCE
TYPE
VS
OBJECT
TYPE
INTERFACES
TYPECASTING
GENERIC
INTERFACES
CLASSES
AND
METHODS
GENERIC
TYPE
DECLARATIONS
INCLUDING
BOUNDED
TYPES
TYPE
WILDCARDS
AND
BOUNDED
WILDCARDS
ASSERTIONS
SELF
TEST
QUESTIONS
APPENDIX
D
PRELUDE
JAVA
INTERLUDES
EXERCISES
PRELUDE
BAG
NOTE
SINCE
THIS
WAS
OUR
FIRST
DATA
STRUCTURE
WE
COVERED
SEVERAL
TOPICS
IN
THIS
SECTION
EVEN
THOUGH
THEY
WEREN
T
SPECIFIC
ONLY
TO
BAGS
TOPICS
ADTS
COLLECTIONS
DATA
STRUCTURES
AND
THEIR
RELATION
TO
INTERFACES
AND
CLASSES
CLIENT
VS
IMPLEMENTER
CONSIDERING
CORNER
CASES
TEST
METHODS
BAG
ADT
AND
INTERFACE
BAG
ARRAY
VS
LINKED
IMPLEMENTATIONS
RESIZING
ARRAYS
INNER
CLASSES
STATIC
AND
NON
STATIC
SELF
TEST
QUESTIONS
CHAPTERS
EXERCISES
CHAPTER
CHAPTER
CHAPTER
ALGORITHM
ANALYSIS
TOPICS
ASYMPTOTIC
ANALYSIS
BIG
O
NOTATION
GROWTH
RATES
AMORTIZED
ANALYSIS
SUM
OF
THE
FIRST
N
INTEGERS
ANALYSIS
OF
BAG
IMPLEMENTATIONS
SELF
TEST
QUESTIONS
CHAPTER
EXERCISES
CHAPTER
STACK
TOPICS
STACK
INTERFACE
USING
STACKS
TO
MATCH
BRACKETS
USING
STACKS
TO
EVALUATE
POSTFIX
USING
STACKS
TO
CONVERT
INFIX
TO
POSTFIX
ARRAY
VS
LINKED
IMPLEMENTATIONS
OF
STACK
RUNTIME
MEMORY
USAGE
PROGRAM
STACK
RUN
TIME
STACK
SELF
TEST
QUESTIONS
CHAPTERS
EXERCISES
CHAPTER
CHAPTER
RECURSION
TOPICS
BREAKING
PROBLEMS
INTO
SUBPROBLEMS
REQUIREMENTS
FOR
RECURSION
TO
WORK
ACTIVATION
RECORDS
DIVIDE
CONQUER
VS
GENERAL
RECURSION
TAIL
RECURSION
EASY
VS
HARD
RECURSIVE
ALGORITHMS
TO
MAKE
ITERATIVE
OVERHEADS
OF
RECURSION
RECURSIVE
BACKTRACKING
GENERAL
GOALS
THE
SPECIFIC
STRUCTURE
WE
USED
NEXT
EXTEND
ISFULLSOLN
REJECT
ANALYZING
RECURSIVE
METHODS
WITH
RECURSION
TREES
PROCESSING
ARRAYS
RECURSIVELY
BY
SPECIFYING
BOUNDS
OF
SUBARRAY
SELF
TEST
QUESTIONS
CHAPTERS
EXERCISES
CHAPTER
16
CHAPTER
SORTING
TOPICS
SIMPLE
SORTS
SELECTION
SORT
BUBBLE
SORT
INSERTION
SORT
SHELL
SORT
RUNTIME
ANALYSIS
OF
SORT
METHODS
SELF
TEST
QUESTIONS
CHAPTERS
EXERCISES
CHAPTER
3
JAVA
BY
DISSECTION
EDITION
IRA
POHL
CHARLIE
MCDOWELL
UNIVERSITY
OF
CALIFORNIA
SANTA
CRUZ
II
COPYRIGHT
C
BY
IRA
POHL
AND
CHARLIE
MCDOWELL
ISBN
TABLE
OF
CONTENTS
TABLE
OF
CONTENTS
III
PREFACE
XI
ACKNOWLEDGMENTS
XIV
CHAPTER
INTRODUCTION
RECIPES
ALGORITHMS
BEING
PRECISE
IMPLEMENTING
OUR
ALGORITHM
IN
JAVA
WHY
JAVA
NETWORK
COMPUTING
AND
THE
WEB
HUMAN
COMPUTER
INTERACTION
AND
THE
GUI
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
PROGRAM
FUNDAMENTALS
HELLO
WORLD
IN
JAVA
COMPILING
AND
RUNNING
YOUR
JAVA
PROGRAM
LEXICAL
ELEMENTS
WHITE
SPACE
COMMENTS
KEYWORDS
IDENTIFIERS
LITERALS
OPERATORS
AND
PUNCTUATION
DATA
TYPES
AND
VARIABLE
DECLARATIONS
VARIABLES
VARIABLE
INITIALIZATION
AN
EXAMPLE
STRING
CONCATENATION
STRINGS
VERSUS
IDENTIFIERS
VERSUS
VARIABLES
USER
INPUT
CALLING
PREDEFINED
METHODS
PRINT
PRINTLN
AND
PRINTF
FORMATTING
OUTPUT
WITH
PRINTF
NUMBER
TYPES
THE
INTEGER
TYPES
THE
FLOATING
POINT
TYPES
THE
CHAR
TYPE
NUMBERS
VERSUS
STRINGS
ARITHMETIC
EXPRESSIONS
AN
INTEGER
ARITHMETIC
EXAMPLE
CHANGE
TYPE
CONVERSION
ASSIGNMENT
OPERATORS
THE
INCREMENT
AND
DECREMENT
OPERATORS
PRECEDENCE
AND
ASSOCIATIVITY
OF
OPERATORS
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
APPLET
EXERCISE
CHAPTER
STATEMENTS
AND
CONTROL
FLOW
EXPRESSION
BLOCK
AND
EMPTY
STATEMENTS
EMPTY
STATEMENT
BOOLEAN
EXPRESSIONS
RELATIONAL
AND
EQUALITY
OPERATORS
LOGICAL
OPERATORS
THE
IF
STATEMENT
PROBLEM
SOLVING
WITH
THE
IF
STATEMENT
THE
IF
ELSE
STATEMENT
NESTED
IF
ELSE
STATEMENTS
IF
ELSE
IF
ELSE
IF
THE
DANGLING
ELSE
PROBLEM
THE
WHILE
STATEMENT
PROBLEM
SOLVING
WITH
LOOPS
THE
DO
STATEMENT
THE
FOR
STATEMENT
LOCAL
VARIABLES
IN
THE
FOR
STATEMENT
THE
BREAK
AND
CONTINUE
STATEMENTS
THE
SWITCH
STATEMENT
USING
THE
LAWS
OF
BOOLEAN
ALGEBRA
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
APPLET
EXERCISE
CHAPTER
METHODS
FUNCTIONAL
ABSTRACTION
METHOD
INVOCATION
STATIC
METHOD
DEFINITIONS
THE
RETURN
STATEMENT
SCOPE
OF
VARIABLES
TOP
DOWN
DESIGN
PROBLEM
SOLVING
RANDOM
NUMBERS
A
SIMULATION
PROBABILITY
CALCULATIONS
INVOCATION
AND
CALL
BY
VALUE
PROBLEM
SOLVING
A
COMPUTER
GAME
TWENTY
ONE
PICKUP
REQUIREMENTS
ANALYSIS
TWENTY
ONE
PICKUP
DESIGN
TWENTY
ONE
PICKUP
IMPLEMENTATION
TWENTY
ONE
PICKUP
TESTING
RECURSION
PROBLEM
SOLVING
MATHEMATICAL
FUNCTIONS
METHOD
OVERLOADING
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
APPLET
EXERCISE
CHAPTER
ARRAYS
AND
CONTAINERS
ONE
DIMENSIONAL
ARRAYS
INDEXING
AN
ARRAY
ELEMENT
ARRAY
INITIALIZATION
ARRAY
MEMBER
LENGTH
THE
FOR
ITERATOR
STATEMENT
PASSING
ARRAYS
TO
METHODS
ARRAY
ASSIGNMENT
FINDING
THE
MINIMUM
AND
MAXIMUM
OF
AN
ARRAY
A
SIMPLE
SORTING
METHOD
SEARCHING
AN
ORDERED
ARRAY
BIG
OH
CHOOSING
THE
BEST
ALGORITHM
TYPE
AND
ARRAY
BOOLEANS
THE
SIEVE
OF
ERATOSTHENES
CHAR
USING
A
LINE
BUFFER
DOUBLE
ACCUMULATE
TWO
DIMENSIONAL
ARRAYS
TWO
DIMENSIONAL
INITIALIZER
LISTS
AN
ELEMENTARY
SIMULATION
THE
GAME
OF
LIFE
THE
GAME
OF
LIFE
REQUIREMENTS
ANALYSIS
THE
GAME
OF
LIFE
DESIGN
THE
GAME
OF
LIFE
IMPLEMENTATION
ARRAYS
OF
NONPRIMITIVE
TYPES
ARRAYS
OF
STRINGS
THE
CONTAINER
ARRAYLIST
PROBLEM
SOLVING
PALINDROMES
PROGRAMMING
STYLE
COUNTING
FROM
ZERO
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
OBJECTS
DATA
ABSTRACTION
THE
ENUMERATION
TYPES
ENUM
METHODS
INSTANCE
METHODS
ENUMERATION
OPERATIONS
A
SIMPLEST
CLASS
MEMBER
ACCESS
OPERATOR
ADDING
INSTANCE
METHODS
CLASS
COUNTER
ACCESS
PUBLIC
AND
PRIVATE
DATA
HIDING
CONSTRUCTOR
METHODS
AND
OBJECT
CREATION
STATIC
FIELDS
AND
METHODS
CALLING
METHODS
A
RECAP
CALLING
A
METHOD
IN
THE
SAME
CLASS
CALLING
INSTANCE
METHODS
CALLING
CLASS
METHODS
PROBLEM
SOLVING
MAKING
CHANGE
ACCESSING
ANOTHER
OBJECT
PRIVATE
FIELDS
PASSING
OBJECTS
REFERENCE
TYPES
SCOPE
NESTED
CLASSES
KEYWORD
FINAL
AND
CLASS
CONSTANTS
ARRAYS
OF
OBJECTS
OBJECT
ORIENTED
DESIGN
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
APPLET
EXERCISE
CHAPTER
INHERITANCE
A
STUDENT
IS
A
PERSON
OVERRIDING
INSTANCE
METHODS
CALLING
PRINT
AND
PRINTLN
THE
ACCESS
MODIFIERS
PRIVATE
AND
PUBLIC
REVISITED
PACKAGES
USING
PACKAGES
CREATING
PACKAGES
THE
ACCESS
MODIFIER
PROTECTED
TYPE
OBJECT
AND
INHERITANCE
ABSTRACT
CLASSES
AN
EXAMPLE
PREDATOR
PREY
SIMULATION
INTERFACES
MULTIPLE
INHERITANCE
INHERITANCE
AND
DESIGN
TYPE
CONVERSIONS
AND
POLYMORPHISM
THE
OPERATOR
INSTANCEOF
AUTOMATIC
BOXING
OF
PRIMITIVES
AUTOMATIC
UNBOXING
OF
PRIMITIVES
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
I
HELLO
WORLD
BUTTON
LISTENING
TO
EVENTS
TEXT
AND
NUMERICAL
INPUT
USING
SEVERAL
COMPONENTS
DRAWING
WITH
SWING
THE
LAYOUT
MANAGER
FLOWLAYOUT
A
SIMPLE
DRAWING
PROGRAM
APPLETS
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
II
ARRANGING
COMPONENTS
IN
A
GUI
THE
CLASS
BORDERLAYOUT
NESTING
CONTAINERS
IN
OTHER
CONTAINERS
GETTING
A
COMPONENT
TO
RESIZE
PROBLEM
SOLVING
PLOTTING
DATA
THE
CLASS
GRAPHICS
CHANGING
THE
STROKE
USED
IN
DRAWING
ADDING
MENUS
TO
A
GUI
EVENT
LISTENERS
AND
ADAPTERS
LISTENER
ADAPTER
CLASSES
POP
UPS
AND
DIALOGS
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
READING
AND
WRITING
FILES
TYPES
OF
FILES
WRITING
TEXT
FILES
READING
TEXT
FILES
PARSING
TEXT
STREAMS
FORMATTING
TEXT
OUTPUT
CONVERSION
CHARACTERS
WIDTH
AND
PRECISION
SPECIFICATIONS
SELECTING
ARGUMENTS
FOR
CONVERSION
JAVA
PRINTF
VERSUS
C
VAR
ARGS
PROBLEM
SOLVING
ENCRYPTING
TEXT
FILES
READING
AND
WRITING
BINARY
FILES
DETECTING
THE
END
OF
AN
INPUT
STREAM
SERIALIZATION
AND
WRITING
OBJECTS
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
COPING
WITH
ERRORS
EXCEPTIONS
EXCEPTION
HANDLING
WITH
TRY
AND
CATCH
CATCHING
AN
EOFEXCEPTION
ABRUPT
RETURN
FROM
METHODS
CATCHING
SEVERAL
DIFFERENT
EXCEPTIONS
THE
FINALLY
CLAUSE
PROGRAM
CORRECTNESS
THROWING
AN
EXCEPTION
RUNTIMEEXCEPTIONS
AND
THE
THROWS
CLAUSE
TESTING
TESTING
WITH
JUNIT
ASSERTIONS
ADDING
ASSERT
STATEMENTS
TO
YOUR
PROGRAM
ENABLING
AND
DISABLING
ASSERTIONS
PRECONDITIONS
POSTCONDITIONS
AND
INVARIANTS
DEBUGGING
JDB
JDB
ON
PROGRAMS
THAT
READ
FROM
SYSTEM
IN
OTHER
JDB
COMMANDS
A
DEBUGGER
WITH
A
GUI
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
DYNAMIC
DATA
STRUCTURES
SELF
REFERENTIAL
STRUCTURES
A
LINKED
LIST
IMPLEMENTATION
OF
A
STACK
A
SINGLY
LINKED
LIST
MORE
OPERATIONS
ON
LISTS
TOSTRING
FOR
THE
CLASS
INTLIST
DOUBLY
LINKED
LISTS
A
GENERIC
STACK
AN
EXAMPLE
POLISH
NOTATION
AND
STACK
EVALUATION
QUEUES
ITERATORS
USING
ITERATORS
TO
IMPLEMENT
APPEND
SORTING
A
LINKED
LIST
ITERATORS
AND
THE
INTERFACE
ITERATOR
DELETING
OBJECTS
PACKAGES
PACKAGE
ACCESS
USING
PACKAGES
CREATING
PACKAGES
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
CHAPTER
THREADS
CONCURRENT
PROGRAMMING
IMPLICIT
THREADS
FROM
AWT
CREATING
THREADS
THE
INTERFACE
RUNNABLE
COMMUNICATION
BETWEEN
TWO
THREADS
SYNCHRONIZING
TWO
THREADS
MUTUAL
EXCLUSION
USING
SYNCHRONIZED
SIGNAL
WAIT
SYNCHRONIZATION
CONDITION
VARIABLES
VERSUS
SEMAPHORES
ARRAYBLOCKINGQUEUE
PASSING
MESSAGES
TO
ANOTHER
COMPUTER
A
MULTITHREADED
SERVER
REUSING
WORKER
THREADS
METHODS
SLEEP
WAIT
AND
NOTIFY
CALLING
SLEEP
FROM
ANYWHERE
CALLING
WAIT
AND
NOTIFY
THE
METHOD
NOTIFYALL
FUTURES
PROGRAMMING
STYLE
SUMMARY
REVIEW
QUESTIONS
EXERCISES
APPENDIX
GETTING
DOWN
TO
THE
BITS
A
INTEGER
BINARY
REPRESENTATION
A
TWO
COMPLEMENT
BINARY
ARITHMETIC
A
FLOATING
POINT
REPRESENTATIONS
A
MANIPULATING
BITS
A
BITWISE
OPERATORS
A
SHIFT
OPERATORS
REFERENCE
TABLES
B
OPERATOR
PRECEDENCE
TABLE
B
THE
STANDARD
JAVA
MATH
FUNCTIONS
SUMMARY
OF
SELECTED
SWING
COMPONENTS
C
THE
CLASS
JBUTTON
C
THE
CLASS
JCOMBOBOX
C
THE
CLASS
JLIST
C
THE
CLASS
JLABEL
C
THE
CLASS
JTEXTFIELD
C
THE
CLASS
JTEXTAREA
C
THE
CLASS
JPANEL
C
THE
CLASS
JSCROLLPANE
INDEX
JAVA
BY
DISSECTION
IS
AN
INTRODUCTION
TO
PROGRAMMING
IN
JAVA
THAT
ASSUMES
NO
PRIOR
PROGRAMMING
EXPERI
ENCE
IT
THOROUGHLY
TEACHES
MODERN
PROGRAMMING
TECHNIQUES
USING
JAVA
WITH
GENERICS
IT
SHOWS
HOW
ALL
THE
BASIC
DATA
TYPES
AND
CONTROL
STATEMENTS
ARE
USED
TRADITIONALLY
THE
BOOK
THEN
PROGRESSES
TO
THE
OBJECT
ORI
ENTED
FEATURES
OF
THE
LANGUAGE
AND
THEIR
IMPORTANCE
TO
PROGRAM
DESIGN
AS
SUCH
THE
FIRST
HALF
OF
THE
BOOK
CAN
BE
USED
IN
A
FIRST
PROGRAMMING
COURSE
FOR
COLLEGE
STUDENTS
BY
CAREFUL
CHOICE
OF
EXERCISES
AND
SUPPLEMENTAL
MATERIAL
IT
COULD
BE
USED
FOR
A
GENTLE
INTRODUCTION
TO
PROGRAMMING
FOR
COMPUTER
SCIENCE
OR
ENGINEERING
MAJORS
ALSO
THE
SECOND
HALF
OF
THE
BOOK
EXPLAINS
IN
DETAIL
MUCH
THAT
IS
SOPHISTICATED
ABOUT
JAVA
SUCH
AS
ITS
THREADING
EXCEPTION
HANDLING
GRAPHICAL
USER
INTERFACE
GUI
GENERICS
AND
FILE
MANIPULATION
CAPABILITIES
AS
SUCH
THE
BOOK
IS
SUITABLE
AS
THE
PRIMARY
TEXT
IN
AN
ADVANCED
PROGRAMMING
COURSE
OR
AS
A
SUPPLEMENTARY
TEXT
IN
A
COURSE
ON
DATA
STRUCTURES
SOFTWARE
METHODOLOGY
COMPARATIVE
LANGUAGES
OR
OTHER
COURSE
IN
WHICH
THE
INSTRUCTOR
WANTS
JAVA
TO
BE
THE
LANGUAGE
OF
CHOICE
JAVA
INVENTED
AT
SUN
MICROSYSTEMS
IN
THE
MID
IS
A
POWERFUL
MODERN
SUCCESSOR
LANGUAGE
TO
C
AND
C
JAVA
LIKE
C
ADDS
TO
C
THE
OBJECT
ORIENTED
PROGRAMMING
CONCEPTS
OF
CLASS
INHERITANCE
AND
RUN
TIME
TYPE
BINDING
THE
CLASS
MECHANISM
PROVIDES
USER
DEFINED
TYPES
ALSO
CALLED
ABSTRACT
DATA
TYPES
WHILE
SHARING
MANY
SYNTACTIC
FEATURES
WITH
C
AND
C
JAVA
ADDS
A
NUMBER
OF
IMPROVEMENTS
INCLUDING
AUTOMATIC
MEMORY
RECLAMATION
CALLED
GARBAGE
COLLECTION
BOUNDS
CHECKING
ON
ARRAYS
AND
STRONG
TYPING
IN
ADDITION
THE
STAN
DARD
JAVA
LIBRARIES
CALLED
PACKAGES
IN
JAVA
PROVIDE
PLATFORM
INDEPENDENT
SUPPORT
FOR
DISTRIBUTED
PROGRAM
MING
MULTI
THREADING
AND
GRAPHICAL
USER
INTERFACES
ALTHOUGH
JAVA
SHARES
MANY
SYNTACTIC
SIMILARITIES
TO
C
UNLIKE
C
JAVA
IS
NOT
A
SUPERSET
OF
C
THIS
HAS
ALLOWED
THE
CREATORS
OF
JAVA
TO
MAKE
A
NUMBER
OF
SYNTACTIC
IMPROVEMENTS
THAT
MAKE
JAVA
A
MUCH
SAFER
PRO
GRAMMING
LANGUAGE
THAN
C
AS
A
RESULT
JAVA
IS
MUCH
BETTER
AS
A
FIRST
PROGRAMMING
LANGUAGE
JAVA
BY
DISSECTION
BEGINS
WITH
A
CLASSICAL
PROGRAMMING
STYLE
STARTING
WITH
PROGRAMS
AS
A
SIMPLE
SEQUENCE
OF
INSTRUCTIONS
THEN
ADDING
IN
CONTROL
FLOW
AND
FUNCTIONAL
ABSTRACTION
AFTER
THAT
COMES
ARRAYS
AND
DATA
ABSTRACTION
USING
CLASSES
WHICH
CAN
BE
COVERED
IN
EITHER
ORDER
ARRAYS
FIRST
OR
DATA
ABSTRACTION
WITH
CLASSES
FIRST
THEN
COMES
THE
MATERIAL
ON
INHERITANCE
AND
GRAPHICAL
USER
INTERFACES
AGAIN
THE
CHAPTER
ON
INHERITANCE
CAN
BE
COVERED
BEFORE
OR
AFTER
THE
FIRST
CHAPTER
ON
GRAPHICAL
USER
INTERFACES
FINALLY
COME
THE
ADVANCED
CHAPTERS
THE
FOLLOWING
FIGURE
ILLUSTRATES
THE
FLEXIBILITY
IN
THE
ORDER
IN
WHICH
THE
MATERIAL
CAN
BE
COVERED
INTRODUCTION
FUNDAMENTALS
CONTROL
FLOW
METHODS
ARRAYS
OBJECTS
DATA
STRUCTURES
GUIS
INHERITANCE
GUIS
PART
II
FILES
EXCEPTIONS
THREADS
THE
BOOK
EMPHASIZES
WORKING
CODE
ONE
OR
MORE
PROGRAMS
PARTICULARLY
ILLUSTRATIVE
OF
THE
CHAPTER
THEMES
ARE
ANALYZED
BY
DISSECTION
WHICH
IS
SIMILAR
TO
A
STRUCTURED
WALK
THROUGH
OF
THE
CODE
DISSECTION
EXPLAINS
TO
THE
READER
NEWLY
ENCOUNTERED
PROGRAMMING
ELEMENTS
AND
IDIOMS
BECAUSE
JAVA
INCLUDES
A
RELATIVELY
EASY
TO
USE
STANDARD
PACKAGE
FOR
CREATING
GRAPHICAL
USER
INTERFACES
IT
IS
POSSIBLE
TO
INTRODUCE
THE
USE
OF
GUIS
IN
A
BEGINNING
PROGRAMMING
BOOK
CREATING
PROGRAMS
WITH
GUIS
IS
AS
FUNDAMENTAL
TODAY
AS
BEING
ABLE
TO
CREATE
NICELY
FORMATTED
TEXT
OUTPUT
TO
FULLY
UNDERSTAND
THE
GUI
PACK
AGES
IN
JAVA
IT
IS
NECESSARY
TO
HAVE
SOME
UNDERSTANDING
OF
OOP
AND
INHERITANCE
THE
MAIN
CHAPTERS
ON
GUI
BUILDING
IMMEDIATELY
FOLLOW
THE
CHAPTERS
ON
OBJECTS
AND
INHERITANCE
FOR
THOSE
STUDENTS
INTERESTED
IN
GETTING
AN
EARLY
EXPOSURE
TO
SOME
OF
THE
GRAPHICAL
ASPECTS
OF
JAVA
WE
HAVE
PROVIDED
A
SERIES
OF
EXTENDED
EXERCISES
AT
THE
END
OF
THE
EARLY
CHAPTERS
THAT
INTRODUCE
GUIS
AND
APPLETS
THESE
EXERCISES
PROVIDE
TEMPLATES
FOR
SOME
SIMPLE
APPLETS
WITHOUT
PROVIDING
COMPLETE
EXPLANATIONS
OF
SOME
OF
THE
LANGUAGE
FEATURES
REQUIRED
THE
FOLLOWING
SUMMARIZES
THE
PRIMARY
DESIGN
FEATURES
THAT
ARE
INCORPORATED
INTO
THIS
BOOK
DISSECTIONS
EACH
CHAPTER
HAS
SEVERAL
IMPORTANT
EXAMPLE
PROGRAMS
MAJOR
ELEMENTS
OF
THESE
PROGRAMS
ARE
EXPLAINED
BY
DISSECTION
THIS
STEP
BY
STEP
DISCUSSION
OF
NEW
PROGRAMMING
IDEAS
HELPS
THE
READER
ENCOUNTER
ING
THESE
IDEAS
FOR
THE
FIRST
TIME
TO
UNDERSTAND
THEM
THIS
METHODOLOGY
HAS
BEEN
PROVEN
EFFECTIVE
IN
NUMER
OUS
PROGRAMMING
BOOKS
SINCE
ITS
FIRST
USE
IN
A
BOOK
ON
C
IN
TEACHING
BY
EXAMPLE
THE
BOOK
IS
A
TUTORIAL
THAT
STRESSES
EXAMPLES
OF
WORKING
CODE
RIGHT
FROM
THE
START
THE
STUDENT
IS
INTRODUCED
TO
FULL
WORKING
PROGRAMS
EXERCISES
ARE
INTEGRATED
WITH
THE
EXAMPLES
TO
ENCOURAGE
EXPERIMENTATION
EXCESSIVE
DETAIL
IS
AVOIDED
IN
EXPLAINING
THE
LARGER
ELEMENTS
OF
WRITING
WORKING
CODE
EACH
CHAPTER
HAS
SEVERAL
IMPORTANT
EXAMPLE
PROGRAMS
MAJOR
ELEMENTS
OF
THESE
PROGRAMS
ARE
EXPLAINED
BY
DISSEC
TION
OBJECT
ORIENTED
PROGRAMMING
OOP
THE
READER
IS
LED
GRADUALLY
TO
AN
UNDERSTANDING
OF
THE
OBJECT
ORIENTED
STYLE
OBJECTS
AS
DATA
VALUES
ARE
INTRODUCED
IN
CHAPTER
PROGRAM
FUNDAMENTALS
THIS
ALLOWS
AN
INSTRUCTOR
PARTIAL
TO
THE
OBJECTS
EARLY
APPROACH
TO
EMPHASIZE
OO
FROM
THE
START
CHAPTER
OBJECTS
DATA
ABSTRACTION
SHOWS
HOW
THE
PROGRAMMER
CAN
BENEFIT
IN
IMPORTANT
WAYS
FROM
JAVA
AND
OBJECT
ORIENTED
PROGRAMMING
OBJECT
ORIENTED
CONCEPTS
ARE
DEFINED
AND
THE
WAY
IN
WHICH
THESE
CONCEPTS
ARE
SUPPORTED
BY
JAVA
IS
INTRO
DUCED
CHAPTER
INHERITANCE
DEVELOPS
INHERITANCE
AND
DYNAMIC
METHOD
DISPATCH
TWO
KEY
ELEMENTS
IN
THE
OOP
PARADIGM
PREFACE
XIII
TERMINAL
INPUT
AND
OUTPUT
JAVA
HAS
ADDED
A
SCANNER
CLASS
THAT
MAKES
TERMINAL
INPUT
EASY
THIS
REPLACES
OUR
FIRST
EDITION
TIO
PACKAGE
WHICH
IS
NO
LONGER
NEEDED
ALSO
THE
ADDITION
OF
PRINTF
FOR
VARIABLE
ARGU
MENT
FROMATTED
OUTPUT
IS
DISCUSSED
CONTAINER
CLASSES
AND
GENERICS
IN
JAVA
THE
TEXT
COVERS
THIS
ADDED
FEATURE
TO
JAVA
CONTAINERS
ARE
IMPLE
MENTED
AS
GENERICS
STANDARD
CONTAINERS
INCLUDE
VECTOR
LINKEDLIST
ARRAYLIST
AND
PRIORITYQUEUE
THESE
ALSO
ALLOW
ITERATOR
ACCESS
AND
CAN
BE
USED
WITH
THE
FOR
ITERATOR
STATEMENT
THAT
HIDES
INDEXING
SWING
AND
GRAPHICAL
USER
INTERFACES
AN
IMPORTANT
PART
OF
JAVA
IS
ITS
SUPPORT
FOR
PLATFORM
INDEPENDENT
CRE
ATION
OF
GRAPHICAL
USER
INTERFACES
AND
THE
WEB
BASED
PROGRAMS
CALLED
APPLETS
INCHAPTER
GRAPHICAL
USER
INTERFACES
PART
I
AND
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
II
WE
PRESENT
A
BASIC
INTRODUCTION
TO
USING
THE
STANDARD
JAVA
PACKAGE
SWING
FOR
BUILDING
GUIS
THESE
CHAPTERS
PROVIDE
ENOUGH
INFORMATION
TO
CREATE
USEFUL
AND
INTERESTING
APPLETS
AND
GUIS
A
FEW
ADDITIONAL
GUI
COMPONENTS
ARE
PRESENTED
BRIEFLY
IN
APPENDIX
C
SUMMARY
OF
SELECTED
SWING
COMPONENTS
FOR
STUDENTS
ANXIOUS
TO
BEGIN
WRITING
APPLETS
SIMPLE
APPLETS
ARE
INTRODUCED
IN
A
SERIES
OF
EXERCISES
BEGINNING
IN
CHAPTER
PROGRAM
FUNDAMENTALS
THESE
EXERCISES
ARE
COM
PLETELY
OPTIONAL
THE
COVERAGE
OF
APPLETS
AND
GUIS
IN
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
I
AND
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
II
DOES
NOT
DEPEND
UPON
THE
STUDENT
HAVING
DONE
OR
READ
THE
EARLIER
APPLET
EXERCISES
THREADS
MULTI
THREADED
PROGRAMMING
IS
NOT
USUALLY
DISCUSSED
IN
A
BEGINNING
TEXT
HOWEVER
SOME
UNDER
STANDING
OF
THREADS
IS
ESSENTIAL
FOR
A
TRUE
UNDERSTANDING
OF
THE
WORKINGS
OF
EVENT
DRIVEN
GUI
BASED
PRO
GRAMS
IN
ADDITION
THE
AUTHORS
FEEL
THAT
THREAD
BASED
PROGRAMMING
WILL
BECOME
INCREASINGLY
IMPORTANT
AT
ALL
LEVELS
OF
THE
PROGRAMMING
CURRICULUM
THREADING
IS
EXPLAINED
IN
CHAPTER
THREADS
CONCURRENT
PROGRAM
MING
AND
USED
TO
INTRODUCE
THE
READER
TO
CLIENT
SERVER
COMPUTING
THIS
BOOK
GIVES
A
TREATMENT
SUITABLE
TO
THE
BEGINNING
PROGRAMMER
THAT
HAS
MASTERED
THE
TOPICS
IN
THE
PRECEDING
CHAPTERS
COURSE
TESTED
THIS
BOOK
IS
THE
BASIS
OF
COURSES
GIVEN
BY
THE
AUTHORS
WHO
HAVE
USED
ITS
CONTENTS
TO
TRAIN
STU
DENTS
IN
VARIOUS
FORUMS
SINCE
THE
MATERIAL
IS
COURSE
TESTED
AND
REFLECTS
THE
AUTHOR
CONSIDERABLE
TEACHING
AND
CONSULTING
EXPERIENCE
CODE
EXAMPLES
ALL
THE
MAJOR
PIECES
OF
CODE
WERE
TESTED
A
CONSISTENT
AND
PROPER
CODING
STYLE
IS
ADOPTED
FROM
THE
BEGINNING
AND
IS
ONE
CHOSEN
BY
PROFESSIONALS
IN
THE
JAVA
COMMUNITY
THE
CODE
IS
AVAILABLE
AT
THE
ADDISON
WESLEY
LONGMAN
WEB
SITE
WWW
AWL
COM
COMMON
PROGRAMMING
ERRORS
MANY
TYPICAL
PROGRAMMING
BUGS
ALONG
WITH
TECHNIQUES
FOR
AVOIDING
THEM
ARE
DESCRIBED
THIS
BOOKS
EXPLAINS
HOW
COMMON
JAVA
ERRORS
ARE
MADE
AND
WHAT
MUST
BE
DONE
TO
CORRECT
THEM
THE
NEW
EDITION
ALSO
DESCRIBES
THE
USE
OF
ASSERTIONS
THAT
CAME
IN
WITH
EXERCISES
THE
EXERCISES
TEST
AND
OFTEN
ADVANCE
THE
STUDENT
KNOWLEDGE
OF
THE
LANGUAGE
MANY
ARE
INTENDED
TO
BE
DONE
INTERACTIVELY
WHILE
READING
THE
TEXT
ENCOURAGING
SELF
PACED
INSTRUCTION
WEB
SITE
THE
EXAMPLES
BOTH
WITHIN
THE
BOOK
ARE
INTENDED
TO
EXHIBIT
GOOD
PROGRAMMING
STYLE
ALL
EXAMPLES
FOR
THIS
BOOK
ARE
AVAILABLE
ON
THE
WEB
AT
WWW
SOE
UCSC
EDU
POHL
JAVA
NEW
IN
THE
SECOND
EDITION
JAVA
CAME
OUT
IN
SEPTEMBER
OF
WITH
IMPORTANT
CHANGES
OVER
THE
ORIGINAL
LANGUAGE
THESE
INCLUDE
CONTAINER
BASED
GENERICS
ENUM
TYPES
ASSERTIONS
MORE
THREADING
REFINEMENTS
TER
MINAL
IO
USING
SCANNER
AND
FORMATTED
IO
USING
PRINTF
WE
HAVE
INCLUDED
ALL
THESE
IMPORTANT
TOPICS
AND
WHERE
POSSIBLE
REVISED
THE
TEXT
TO
TAKE
ADVANTAGE
OF
THEM
COURSE
USE
FIRST
COURSE
IN
PROGRAMMING
JAVA
BY
DISSECTION
IS
DESIGNED
TO
BE
USED
AS
A
BASIC
FIRST
PROGRAMMING
COURSE
SIMILAR
IN
SCOPE
TO
COURSES
THAT
USED
C
PASCAL
OR
C
CHAPTERS
COVER
SUCH
A
CURRICULUM
FIRST
COURSE
IN
PROGRAMMING
SWING
EMPHASIS
BY
USING
SUPPLEMENTARY
MATERIAL
AT
THE
END
OF
EACH
OF
THE
FIRST
CHAPTERS
THE
INSTRUCTOR
CAN
TAKE
A
GUI
APPROACH
AS
OPPOSED
TO
THE
TRADITIONAL
TERMINAL
I
O
APPROACH
COURSE
IN
PROGRAMMING
BY
COVERING
MATERIAL
AT
A
MORE
RAPID
PACE
FOR
WELL
PREPARED
COMPUTER
SCI
ENCE
MAJORS
THE
BOOK
CAN
FUNCTION
AS
THE
PRIMARY
TEXT
IN
A
SEQUENCE
THE
INSTRUCTOR
WOULD
SELECT
MORE
ADVANCED
EXERCISES
AND
COVER
MATERIAL
THROUGH
CHAPTER
SECOND
COURSE
IN
PROGRAMMING
THE
BOOK
CAN
BE
USED
AS
A
SECOND
OR
ADVANCED
COURSE
COVERING
OBJECT
ORIENTED
PROGRAMMING
CHAPTERS
CAN
BE
SKIMMED
BY
ANYONE
ALREADY
FAMILIAR
WITH
A
PROCEDURAL
PRO
GRAMMING
LANGUAGE
SUCH
AS
C
OR
PASCAL
A
PROGRAMMER
ALREADY
FAMILIAR
WITH
OOP
CONCEPTS
COULD
ALSO
SKIM
CHAPTERS
AND
CHAPTERS
PROVIDE
A
MIX
OF
INTERESTING
ADVANCED
TOPICS
NOT
GENERALLY
COVERED
IN
A
BEGINNING
PROGRAMMING
COURSE
ACKNOWLEDGMENTS
OUR
SPECIAL
THANKS
GO
TO
DEBRA
DOLSBERRY
AND
LINDA
WERNER
FOR
THEIR
ENCOURAGEMENT
AND
CAREFUL
READING
AND
SUGGESTIONS
FOR
IMPROVEMENT
DEBRA
WAS
ESPECIALLY
HELPFUL
WITH
TYPESETTING
ISSUES
OUR
STUDENT
SARAH
BERNER
WAS
AN
IMPORTANT
CONTRIBUTOR
TO
THE
EFFECTIVENESS
OF
THE
TEXT
IN
ITS
FIRST
EDITION
AND
ESPECIALLY
HELPFUL
IN
CON
VERTING
MANY
EXAMPLES
AND
EXERCISES
OVER
TO
SWING
THANKS
TO
UWE
F
MAYER
FOR
HIS
CAREFUL
REVIEW
OF
THE
SECOND
EDITION
WHICH
CAUGHT
NUMEROUS
ERRORS
CHARLIE
MCDOWELL
AND
IRA
POHL
UNIVERSITY
OF
CALIFORNIA
SANTA
CRUZ
JAVA
IS
THE
FIRST
MAJOR
PROGRAMMING
LANGUAGE
TO
BE
SHAPED
BY
THE
WORLD
WIDE
WEB
THE
WEB
JAVA
ALLOWS
YOU
TO
DO
TRADITIONAL
PROGRAMMING
JAVA
ALSO
HAS
MANY
SPECIAL
FEATURES
AND
LIBRARIES
THAT
ALLOW
YOU
CONVENIENTLY
TO
WRITE
PROGRAMS
THAT
CAN
USE
THE
WEB
RESOURCES
THESE
INCLUDE
EXTENSIVE
SUPPORT
FOR
GRAPHICAL
USER
INTER
FACES
THE
ABILITY
TO
EMBED
A
JAVA
PROGRAM
IN
A
WEB
DOCUMENT
EASY
COMMUNICATION
WITH
OTHER
COMPUTERS
AROUND
THE
WORLD
AND
THE
ABILITY
TO
WRITE
PROGRAMS
THAT
RUN
IN
PARALLEL
OR
ON
SEVERAL
COMPUTERS
AT
THE
SAME
TIME
IN
THIS
CHAPTER
WE
GIVE
AN
OVERVIEW
OF
HOW
TO
SOLVE
A
PROBLEM
ON
A
COMPUTER
IN
THIS
PROCESS
YOU
MUST
FIRST
CONSTRUCT
A
RECIPE
FOR
SOLVING
THE
PROBLEM
THEN
YOU
MUST
CONVERT
THE
RECIPE
INTO
A
DETAILED
SET
OF
STEPS
THAT
THE
COMPUTER
CAN
FOLLOW
FINALLY
YOU
MUST
USE
A
PROGRAMMING
LANGUAGE
SUCH
AS
JAVA
TO
EXPRESS
THE
STEPS
IN
A
FORM
UNDERSTANDABLE
BY
THE
COMPUTER
THE
JAVA
FORM
OF
THE
SOLUTION
IS
THEN
TRANSLATED
BY
A
PROGRAM
CALLED
A
COMPILER
INTO
THE
LOW
LEVEL
OPERATIONS
THAT
THE
COMPUTER
HARDWARE
CAN
FOLLOW
DIRECTLY
WE
THEN
DISCUSS
WHY
JAVA
IS
CREATING
SUCH
A
FUSS
IN
THE
COMPUTING
WORLD
IN
GENERAL
TERMS
WE
EXPLAIN
THE
IMPORTANCE
OF
COMPUTING
ON
THE
WEB
AND
THE
CHARACTER
OF
THE
GRAPHICAL
USER
INTERFACES
OR
GUIS
THAT
ARE
PARTLY
BEHIND
THE
SWITCH
TO
JAVA
THROUGHOUT
THIS
TEXT
WE
FEATURE
CAREFULLY
DESCRIBED
EXAMPLES
MANY
OF
WHICH
ARE
COMPLETE
PROGRAMS
WE
OFTEN
DISSECT
THEM
ALLOWING
YOU
TO
SEE
IN
DETAIL
HOW
EACH
JAVA
PROGRAMMING
CONSTRUCT
WORKS
TOPICS
INTRO
DUCED
IN
THIS
CHAPTER
ARE
PRESENTED
AGAIN
IN
LATER
CHAPTERS
WITH
MORE
DETAILED
EXPLANATIONS
THE
CODE
AND
EXAMPLES
ARE
MEANT
TO
CONVEY
THE
FLAVOR
OF
HOW
TO
PROGRAM
YOU
SHOULD
NOT
BE
CONCERNED
ABOUT
UNDERSTAND
ING
THE
DETAILS
OF
THE
EXAMPLES
THEY
ARE
GIVEN
IN
THE
SPIRIT
OF
PROVIDING
AN
OVERVIEW
IF
YOU
ARE
ALREADY
FAMIL
IAR
WITH
WHAT
A
PROGRAM
IS
AND
WANT
TO
START
IMMEDIATELY
ON
THE
NITTY
GRITTY
OF
JAVA
PROGRAMMING
YOU
MAY
SKIP
OR
SCAN
THIS
CHAPTER
COMPUTER
PROGRAMS
ARE
DETAILED
LISTS
OF
INSTRUCTIONS
FOR
PERFORMING
A
SPECIFIC
TASK
OR
FOR
SOLVING
A
PARTICULAR
TYPE
OF
PROBLEM
PROGRAMLIKE
INSTRUCTION
LISTS
SOMETIMES
CALLED
ALGORITHMS
FOR
PROBLEM
SOLVING
AND
TASK
PERFORMANCE
ARE
COMMONLY
FOUND
IN
EVERYDAY
SITUATIONS
EXAMPLES
INCLUDE
DETAILED
INSTRUCTIONS
FOR
KNITTING
A
SWEATER
MAKING
A
DRESS
COOKING
A
FAVORITE
MEAL
REGISTERING
FOR
CLASSES
AT
A
UNIVERSITY
TRAVELING
FROM
ONE
DESTINATION
TO
ANOTHER
AND
USING
A
VENDING
MACHINE
EXAMINING
ONE
OF
THESE
EXAMPLES
IS
INSTRUCTIVE
CONSIDER
THIS
RECIPE
FOR
PREPARING
A
MEAT
ROAST
THE
RECIPE
IS
TYPICALLY
IMPRECISE
WHAT
DOES
SPRINKLE
MEAN
WHERE
IS
THE
THERMOMETER
TO
BE
INSERTED
AND
WHAT
IS
A
SUFFICIENT
AMOUNT
OF
PAN
DRIPPINGS
HOWEVER
THE
RECIPE
CAN
BE
FORMULATED
MORE
PRECISELY
AS
A
LIST
OF
INSTRUCTIONS
BY
TAKING
SOME
LIBERTIES
AND
READING
BETWEEN
THE
LINES
COOKING
A
ROAST
SPRINKLE
ROAST
WITH
TEASPOON
SALT
AND
PEPPER
TURN
OVEN
ON
TO
C
INSERT
MEAT
THERMOMETER
INTO
CENTER
OF
ROAST
WAIT
A
FEW
MINUTES
IF
OVEN
DOES
NOT
YET
REGISTER
C
GO
BACK
TO
STEP
PLACE
ROAST
IN
OVEN
WAIT
A
FEW
MINUTES
CHECK
MEAT
THERMOMETER
IF
TEMPERATURE
IS
LESS
THAN
C
GO
BACK
TO
STEP
REMOVE
ROAST
FROM
OVEN
IF
THERE
IS
AT
LEAST
CUP
OF
PAN
DRIPPINGS
GO
TO
STEP
PREPARE
GRAVY
FROM
MEAT
STOCK
AND
GO
TO
STEP
PREPARE
GRAVY
FROM
PAN
DRIPPINGS
SERVE
ROAST
WITH
GRAVY
THESE
STEPS
COMPRISE
THREE
CATEGORIES
OF
INSTRUCTIONS
AND
ACTIVITIES
THOSE
THAT
INVOLVE
MANIPULATING
OR
CHANGING
THE
INGREDIENTS
OR
EQUIPMENT
THOSE
THAT
JUST
EXAMINE
OR
TEST
THE
STATE
OF
THE
SYSTEM
AND
THOSE
THAT
TRANSFER
TO
THE
NEXT
STEP
STEPS
AND
ARE
EXAMPLES
OF
THE
FIRST
CATEGORY
THE
TEMPERATURE
TEST
IN
STEP
AND
THE
PAN
DRIPPING
TEST
IN
STEP
ARE
INSTANCES
OF
THE
SECOND
CATEGORY
AND
THE
TRANSFERS
IN
STEPS
AND
GO
TO
STEP
X
ARE
EXAMPLES
OF
THE
LAST
CATEGORY
BY
USING
SUITABLE
GRAPHICAL
SYMBOLS
FOR
EACH
OF
THESE
CATEGORIES
A
SIMPLE
TWO
DIMENSIONAL
REPRESENTATION
OF
OUR
COOKING
ALGORITHM
CAN
BE
OBTAINED
AS
SHOWN
IN
THE
FOLLOWING
ILLUSTRATION
SUCH
A
FIGURE
IS
CALLED
A
FLOWCHART
TO
PERFORM
THE
PROGRAM
PREPARE
THE
ROAST
JUST
FOLLOW
THE
ARROWS
AND
THE
INSTRUCTIONS
IN
EACH
BOX
THE
MANIPULATION
ACTIVITIES
ARE
CONTAINED
IN
RECTANGLES
THE
TESTS
ARE
SHOWN
IN
DIA
MONDS
AND
THE
TRANSFER
OR
FLOW
OF
CONTROL
IS
DETERMINED
BY
THE
ARROWS
BECAUSE
OF
THEIR
VISUAL
APPEAL
AND
CLARITY
FLOWCHARTS
ARE
OFTEN
USED
INSTEAD
OF
LISTS
OF
INSTRUCTIONS
FOR
INFORMALLY
DESCRIBING
PROGRAMS
SOME
COOKBOOK
AUTHORS
EVEN
EMPLOY
FLOWCHARTS
EXTENSIVELY
IN
THIS
BOOK
WE
USE
FLOWCHARTS
IN
CHAPTER
STATE
MENTS
AND
CONTROL
FLOW
WHEN
DESCRIBING
THE
BEHAVIOR
OF
SOME
JAVA
LANGUAGE
CONSTRUCTS
OUR
RECIPE
FOR
PREPARING
A
ROAST
CAN
T
BE
EXECUTED
BY
A
COMPUTER
BECAUSE
THE
INDIVIDUAL
INSTRUCTIONS
ARE
TOO
LOOSELY
SPECIFIED
LET
CONSIDER
ANOTHER
EXAMPLE
ONE
THAT
MANIPULATES
NUMBERS
INSTEAD
OF
FOOD
YOU
NEED
TO
PAY
FOR
SOME
PURCHASE
WITH
A
DOLLAR
BILL
AND
GET
CHANGE
IN
DIMES
AND
PENNIES
THE
PROBLEM
IS
TO
DETERMINE
THE
CORRECT
CHANGE
WITH
THE
FEWEST
PENNIES
MOST
PEOPLE
DO
THIS
SIMPLE
EVERYDAY
TRANSACTION
UNTHINKINGLY
BUT
HOW
DO
WE
PRECISELY
DESCRIBE
THIS
ALGORITHM
IN
SOLVING
SUCH
A
PROBLEM
TRYING
A
SPECIFIC
CASE
CAN
BE
USEFUL
LET
SAY
THAT
YOU
NEED
TO
PAY
CENTS
AND
NEED
CHANGE
FOR
A
DOLLAR
YOU
CAN
EASILY
SEE
THAT
ONE
DOLLAR
MINUS
THE
CENTS
LEAVES
YOU
WITH
CENTS
IN
CHANGE
THE
CORRECT
CHANGE
HAVING
THE
FEWEST
COINS
IN
DIMES
AND
PENNIES
WOULD
BE
TWO
DIMES
AND
THREE
PEN
NIES
THE
NUMBER
OF
DIMES
IS
THE
INTEGER
RESULT
OF
DIVIDING
BY
AND
DISCARDING
ANY
FRACTION
OR
REMAIN
DER
THE
NUMBER
OF
PENNIES
IS
THE
REMAINDER
OF
DIVIDING
THE
CENTS
BY
AN
ALGORITHM
FOR
PERFORMING
THIS
CHANGE
FOR
A
DOLLAR
IS
GIVEN
BY
THE
FOLLOWING
STEPS
CHANGE
MAKING
ALGORITHM
ASSUME
THAT
THE
PRICE
IS
WRITTEN
IN
A
BOX
LABELED
PRICE
SUBTRACT
THE
VALUE
OF
PRICE
FROM
AND
PLACE
IT
IN
A
BOX
LABELED
CHANGE
DIVIDE
THE
VALUE
IN
CHANGE
BY
DISCARD
THE
REMAINDER
AND
PLACE
THE
RESULT
IN
A
BOX
LABELED
DIMES
TAKE
THE
INTEGER
REMAINDER
OF
CHANGE
DIVIDED
BY
AND
PLACE
IT
IN
A
BOX
LABELED
PENNIES
PRINT
OUT
THE
VALUES
IN
THE
BOXES
DIMES
AND
PENNIES
WITH
APPROPRIATE
LABELS
HALT
THIS
ALGORITHM
HAS
FOUR
BOXES
NAMELY
PRICE
CHANGE
DIMES
AND
PENNIES
LET
EXECUTE
THIS
ALGORITHM
WITH
THE
VALUES
GIVEN
SUPPOSE
THAT
THE
PRICE
IS
CENTS
ALWAYS
START
WITH
THE
FIRST
INSTRUCTION
THE
CONTENTS
OF
THE
FOUR
BOXES
AT
VARIOUS
STAGES
OF
EXECUTION
ARE
SHOWN
IN
THE
FOLLOWING
TABLE
BOX
STEP
STEP
STEP
STEP
STEP
PRICE
CHANGE
DIMES
PENNIES
TO
EXECUTE
STEP
PLACE
THE
FIRST
NUMBER
IN
THE
BOX
PRICE
AT
THE
END
OF
INSTRUCTION
THE
RESULT
OF
SUB
TRACTING
FROM
IS
WHICH
IS
PLACED
IN
THE
BOX
CHANGE
EACH
STEP
OF
THE
ALGORITHM
PERFORMS
A
SMALL
PART
OF
THE
COMPUTATION
BY
STEP
THE
CORRECT
VALUES
ARE
ALL
IN
THEIR
RESPECTIVE
BOXES
AND
ARE
PRINTED
OUT
STUDY
THE
EXAMPLE
UNTIL
YOU
RE
CONVINCED
THAT
THIS
ALGORITHM
WILL
WORK
CORRECTLY
FOR
ANY
PRICE
UNDER
A
GOOD
WAY
TO
DO
SO
IS
TO
ACT
THE
PART
OF
A
COMPUTER
FOLLOWING
THE
RECIPE
FOLLOWING
A
SET
OF
INSTRUCTIONS
IN
THIS
WAY
FORMULATED
AS
A
COMPUTER
PROGRAM
IS
CALLED
HAND
SIMULATION
OR
BENCH
TESTING
IT
IS
A
GOOD
WAY
TO
FIND
ERRORS
IN
AN
ALGORITHM
OR
PROGRAM
IN
COMPUTER
PARLANCE
THESE
ERRORS
ARE
CALLED
BUGS
AND
FINDING
AND
REMOV
ING
THEM
IS
CALLED
DEBUGGING
WE
EXECUTED
THE
CHANGE
MAKING
ALGORITHM
BY
ACTING
AS
AN
AGENT
MECHANICALLY
FOLLOWING
A
LIST
OF
INSTRUCTIONS
THE
EXECUTION
OF
A
SET
OF
INSTRUCTIONS
BY
AN
AGENT
IS
CALLED
A
COMPUTATION
USUALLY
THE
AGENT
IS
A
COMPUTER
IN
THAT
CASE
THE
SET
OF
INSTRUCTIONS
IS
A
COMPUTER
PROGRAM
IN
THE
REMAINDER
OF
THIS
BOOK
UNLESS
EXPLICITLY
STATED
OTHERWISE
WE
USE
PROGRAM
TO
MEAN
COMPUTER
PROGRAM
THE
ALGORITHM
FOR
MAKING
CHANGE
HAS
SEVERAL
IMPORTANT
FEATURES
THAT
ARE
CHARACTERISTIC
OF
ALL
ALGORITHMS
CHARACTERISTICS
OF
ALGORITHMS
THE
SEQUENCE
OF
INSTRUCTIONS
WILL
TERMINATE
THE
INSTRUCTIONS
ARE
PRECISE
EACH
INSTRUCTION
IS
UNAMBIGUOUS
AND
SUBJECT
TO
ONLY
ONE
INTERPRE
TATION
THE
INSTRUCTIONS
ARE
SIMPLE
TO
PERFORM
EACH
INSTRUCTION
IS
WITHIN
THE
CAPABILITIES
OF
THE
EXECUT
ING
AGENT
AND
CAN
BE
CARRIED
OUT
EXACTLY
IN
A
FINITE
AMOUNT
OF
TIME
SUCH
INSTRUCTIONS
ARE
CALLED
EFFECTIVE
THERE
ARE
INPUTS
AND
OUTPUTS
AN
ALGORITHM
HAS
ONE
OR
MORE
OUTPUTS
ANSWERS
THAT
DEPEND
ON
THE
PARTICULAR
INPUT
DATA
THE
INPUT
TO
THE
CHANGE
MAKING
ALGORITHM
IS
THE
PRICE
OF
THE
ITEM
PUR
CHASED
THE
OUTPUT
IS
THE
NUMBER
OF
DIMES
AND
PENNIES
OUR
DESCRIPTION
OF
THE
CHANGE
MAKING
ALGORITHM
ALTHOUGH
RELATIVELY
PRECISE
IS
NOT
WRITTEN
IN
ANY
FORMAL
PRO
GRAMMING
LANGUAGE
SUCH
INFORMAL
NOTATIONS
FOR
ALGORITHMS
ARE
CALLED
PSEUDOCODE
WHEREAS
REAL
CODE
IS
SOMETHING
SUITABLE
FOR
A
COMPUTER
WHERE
APPROPRIATE
WE
USE
PSEUDOCODE
TO
DESCRIBE
ALGORITHMS
DOING
SO
ALLOWS
US
TO
EXPLAIN
AN
ALGORITHM
OR
COMPUTATION
TO
YOU
WITHOUT
ALL
THE
NECESSARY
DETAIL
NEEDED
BY
A
COM
PUTER
THE
TERM
ALGORITHM
HAS
A
LONG
INVOLVED
HISTORY
ORIGINALLY
STEMMING
FROM
THE
NAME
OF
A
WELL
KNOWN
ARABIC
MATHEMATICIAN
OF
THE
NINTH
CENTURY
ABU
JAFAR
MUHAMMED
MUSA
AL
KHWARIZMI
IT
LATER
BECAME
ASSOCIATED
WITH
ARITHMETIC
PROCESSES
AND
THEN
MORE
PARTICULARLY
WITH
EUCLID
ALGORITHM
FOR
COMPUTING
THE
GREATEST
COMMON
DIVISOR
OF
TWO
INTEGERS
SINCE
THE
DEVELOPMENT
OF
COMPUTERS
THE
WORD
HAS
TAKEN
ON
A
MORE
PRECISE
MEANING
THAT
DEFINES
A
REAL
OR
ABSTRACT
COMPUTER
AS
THE
ULTIMATE
EXECUTING
AGENT
ANY
TERMINATING
COMPUTA
TION
BY
A
COMPUTER
IS
AN
ALGORITHM
AND
ANY
ALGORITHM
CAN
BE
PROGRAMMED
FOR
A
COMPUTER
IN
THIS
SECTION
WE
IMPLEMENT
OUR
CHANGE
MAKING
ALGORITHM
IN
THE
JAVA
PROGRAMMING
LANGUAGE
YOU
NEED
NOT
WORRY
ABOUT
FOLLOWING
THE
JAVA
DETAILS
AT
THIS
POINT
WE
COVER
ALL
OF
THEM
FULLY
IN
THE
NEXT
TWO
CHAPTERS
WE
SPECIFICALLY
REVISIT
THIS
EXAMPLE
IN
SECTION
AN
INTEGER
ARITHMETIC
EXAMPLE
CHANGE
ON
PAGE
FOR
NOW
SIMPLY
NOTE
THE
SIMILARITY
BETWEEN
THE
FOLLOWING
JAVA
PROGRAM
AND
THE
INFORMAL
ALGORITHM
PRESENTED
EARLIER
YOU
NOT
ONLY
HAVE
TO
BE
ABLE
TO
FORMULATE
A
RECIPE
AND
MAKE
IT
ALGORITHMIC
BUT
YOU
FINALLY
HAVE
TO
EXPRESS
IT
IN
A
COMPUTER
LANGUAGE
MAKECHANGE
JAVA
CHANGE
IN
DIMES
AND
PENNIES
IMPORT
JAVA
UTIL
USE
SCANNER
FOR
INPUT
CLASS
MAKECHANGE
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
PRICE
CHANGE
DIMES
PENNIES
SCANNER
SCAN
NEW
SCANNER
SYSTEM
IN
SYSTEM
OUT
PRINTLN
TYPE
PRICE
TO
PRICE
SCAN
NEXTINT
CHANGE
PRICE
HOW
MUCH
CHANGE
DIMES
CHANGE
NUMBER
OF
DIMES
PENNIES
CHANGE
NUMBER
OF
PENNIES
SYSTEM
OUT
PRINT
THE
CHANGE
IS
SYSTEM
OUT
PRINT
DIMES
SYSTEM
OUT
PRINT
DIMES
SYSTEM
OUT
PRINT
PENNIES
SYSTEM
OUT
PRINT
PENNIES
N
PRICE
SCAN
NEXTINT
THE
SCAN
NEXTINT
IS
USED
TO
OBTAIN
THE
INPUT
FROM
THE
KEYBOARD
THE
VALUE
READ
IS
STORED
IN
THE
VARI
ABLE
PRICE
THE
SYMBOL
IS
CALLED
THE
ASSIGNMENT
OPERATOR
READ
THE
FIRST
LINE
AS
PRICE
IS
ASSIGNED
THE
VALUE
OBTAINED
FROM
THE
TYPING
AN
INTEGER
ON
YOUR
KEYBOARD
AT
THIS
POINT
YOU
MUST
TYPE
IN
AN
INTEGER
PRICE
FOR
EXAMPLE
YOU
WOULD
TYPE
AND
THEN
HIT
ENTER
CHANGE
PRICE
HOW
MUCH
CHANGE
THIS
LINE
COMPUTES
THE
AMOUNT
OF
CHANGE
DIMES
CHANGE
NUMBER
OF
DIMES
PENNIES
CHANGE
NUMBER
OF
PENNIES
THE
NUMBER
OF
DIMES
IS
THE
INTEGER
OR
WHOLE
PART
OF
THE
RESULT
OF
DIVIDING
CHANGE
BY
THE
SYMBOL
WHEN
USED
WITH
TWO
INTEGERS
COMPUTES
THE
WHOLE
NONFRACTION
PART
OF
THE
DIVISION
THE
NUMBER
OF
PEN
NIES
IS
THE
INTEGER
REMAINDER
OF
CHANGE
DIVIDED
BY
THE
SYMBOL
IS
THE
INTEGER
REMAINDER
OR
MODULO
OPERATOR
IN
JAVA
SO
IF
CHANGE
IS
THE
INTEGER
DIVIDE
OF
IS
AND
THE
INTEGER
REMAINDER
OR
MODULO
OF
IS
SYSTEM
OUT
PRINT
THE
CHANGE
IS
SYSTEM
OUT
PRINT
DIMES
SYSTEM
OUT
PRINT
DIMES
SYSTEM
OUT
PRINT
PENNIES
SYSTEM
OUT
PRINT
PENNIES
N
IN
THIS
EXAMPLE
THE
SYSTEM
OUT
PRINT
STATEMENTS
CAUSE
THE
VALUES
BETWEEN
THE
PARENTHESES
TO
BE
PRINTED
ON
THE
COMPUTER
CONSOLE
THE
FIRST
ONE
JUST
PRINTS
OUT
THE
CHARACTERS
BETWEEN
THE
QUOTATION
MARKS
THE
SECOND
ONE
CONVERTS
THE
VALUE
IN
DIMES
TO
THE
SEQUENCE
OF
DIGITS
AND
PRINTS
THOSE
DIGITS
THE
OTHER
PRINT
STATEMENTS
ARE
SIMILAR
FOR
AN
INPUT
VALUE
OF
THE
OUTPUT
WOULD
BE
THE
N
IN
THE
LAST
PRINT
STATEMENT
INDICATES
THAT
A
NEWLINE
SHOULD
BE
SENT
TO
THE
CONSOLE
ENDING
THE
LINE
OF
OUTPUT
A
VARIETY
OF
PROGRAMMING
LANGUAGES
ARE
AVAILABLE
FOR
EXPRESSING
PROGRAMS
BUT
THE
MOST
USEFUL
ONES
ARE
SUITABLE
FOR
BOTH
MACHINE
AND
HUMAN
CONSUMPTION
IN
THIS
BOOK
WE
COVER
PROGRAMMING
BY
USING
ONE
SUCH
LANGUAGE
THE
PROGRAMMING
LANGUAGE
JAVA
JAVA
IS
A
RELATIVELY
NEW
PROGRAMMING
LANGUAGE
FIRST
INTRODUCED
IN
IN
THIS
BOOK
A
LANGUAGE
IS
NEEDED
THAT
ALLOWS
ALGORITHMS
TO
BE
EASILY
UNDERSTOOD
DESIGNED
ANALYZED
AND
IMPLEMENTED
AS
COMPUTER
PROGRAMS
THE
FOLLOWING
IS
AN
EXCERPT
FROM
THE
ORIGINAL
PAPER
INTRODUCING
JAVA
TO
THE
WORLD
NETWORK
COMPUTING
AND
THE
WEB
IN
HIS
SCIENCE
FICTION
NOVEL
THE
ROLLING
STONES
ROBERT
A
HEINLEIN
COMMENTS
EVERY
TECHNOLOGY
GOES
THROUGH
THREE
STAGES
FIRST
A
CRUDELY
SIMPLE
AND
QUITE
UNSATISFACTORY
GADGET
SECOND
AN
ENORMOUSLY
COMPLICATED
GROUP
OF
GADGETS
DESIGNED
TO
OVERCOME
THE
SHORT
COMINGS
OF
THE
ORIGINAL
AND
ACHIEVING
THEREBY
SOMEWHAT
SATISFACTORY
PERFORMANCE
THROUGH
EXTREMELY
COMPLEX
COMPROMISE
THIRD
A
FINAL
PROPER
DESIGN
THEREFROM
HEINLEIN
COMMENT
COULD
WELL
DESCRIBE
THE
EVOLUTION
OF
MANY
PROGRAMMING
LANGUAGES
JAVA
PRESENTS
A
NEW
VIEWPOINT
IN
THE
EVOLUTION
OF
PROGRAMMING
LANGUAGES
CREATION
OF
A
SMALL
AND
SIMPLE
LANGUAGE
THAT
STILL
SUFFICIENTLY
COMPREHENSIVE
TO
ADDRESS
A
WIDE
VARIETY
OF
SOFTWARE
APPLICATION
DEVELOPMENT
ALTHOUGH
JAVA
IS
SUPERFICIALLY
SIMILAR
TO
C
AND
C
JAVA
GAINED
ITS
SIMPLICITY
FROM
THE
SYSTEMATIC
REMOVAL
OF
FEATURES
FROM
ITS
PREDECESSORS
WE
AGREE
WITH
ITS
CREATORS
THAT
JAVA
HAS
TO
A
LARGE
EXTENT
LIVED
UP
TO
THE
PROMISE
OF
A
SMALL
SIMPLE
YET
COM
PREHENSIVE
PROGRAMMING
LANGUAGE
AS
SUCH
JAVA
IS
BOTH
AN
EXCELLENT
PROGRAMMING
LANGUAGE
FOR
REAL
PRO
GRAM
DEVELOPMENT
AND
A
GOOD
FIRST
PROGRAMMING
LANGUAGE
POSSIBLY
EVEN
MORE
IMPORTANT
FOR
JAVA
INITIAL
SUCCESS
ARE
THE
FEATURES
THAT
MAKE
IT
APPROPRIATE
FOR
DEVELOP
MENT
OF
PROGRAMS
DISTRIBUTED
OVER
THE
INTERNET
THESE
PROGRAMS
CALLED
APPLETS
EXECUTE
INSIDE
INTERNET
BROWSERS
SUCH
AS
FIREFOX
MOZILLA
NETSCAPE
AND
INTERNET
EXPLORER
MUCH
OF
MODERN
COMPUTING
IS
DONE
IN
A
CONNECTED
ENVIRONMENT
THAT
IS
COMPUTERS
ARE
CONNECTED
TO
OTHER
COMPUTERS
IN
A
NETWORK
THIS
CONNECTION
ALLOWS
THE
COMPUTERS
TO
EXCHANGE
INFORMATION
OR
TO
TALK
TO
EACH
OTHER
JAVA
WAS
DEVELOPED
WITH
NETWORK
COMPUTING
AS
THE
NORMAL
ENVIRONMENT
IT
HAS
MANY
FEATURES
AND
LIBRARIES
OF
PARTS
OF
PROGRAMS
THAT
PROMOTE
NETWORKING
EARLIER
LANGUAGES
AND
SYSTEMS
VIEWED
A
COMPUTER
AS
A
LONE
INSTRUMENT
DOING
SIGNIFICANT
COMPUTATIONS
THE
RESULTS
OF
WHICH
WOULD
LARGELY
BE
OUTPUT
TO
A
SCREEN
OR
PRINTER
BY
PROMOTING
NETWORKING
WHEREBY
COMPUTERS
ARE
CONNECTED
AND
PASS
RESULTS
TO
EACH
OTHER
DYNAMI
CALLY
AND
COOPERATE
ON
LARGE
SCALE
COMPUTATIONS
JAVA
BECAME
THE
PRINCIPAL
LANGUAGE
FOR
COMPUTING
ON
NETWORKS
THE
LARGEST
NETWORK
IS
THE
GLOBAL
NETWORK
CALLED
THE
INTERNET
USING
THE
INTERNET
RESEARCHERS
AT
THE
EUROPEAN
PARTICLE
PHYSICS
LABORATORY
CERN
DEVELOPED
A
WAY
TO
SHARE
INFORMATION
VIA
A
FORMATTING
LANGUAGE
CALLED
HYPER
TEXT
MARKUP
LANGUAGE
OR
HTML
THE
COMPUTERS
EXCHANGED
HTML
DOCUMENTS
BY
MEANS
OF
A
PROTOCOL
CALLED
HYPER
TEXT
TRANSFER
PROTOCOL
OR
HTTP
A
PROTOCOL
IS
LIKE
A
LANGUAGE
THAT
COMPUTERS
USE
TO
TALK
TO
EACH
OTHER
HTML
ALLOWS
ONE
ELECTRONIC
DOCUMENT
TO
LINK
TO
ANOTHER
ELECTRONIC
DOCUMENT
ON
A
DIFFERENT
COMPUTER
THE
PROGRAM
USED
TO
VIEW
HTML
DOCUMENTS
AND
FOLLOW
THE
LINKS
IS
CALLED
A
BROWSER
WITH
THE
CLICK
OF
A
BUT
TON
A
USER
COULD
MOVE
FROM
ONE
DOCUMENT
ON
ONE
COMPUTER
TO
ANOTHER
RELATED
DOCUMENT
ON
ANOTHER
COM
PUTER
BECAUSE
OF
THESE
LINKS
THE
RESULTING
WEB
OF
DOCUMENTS
WAS
DUBBED
THE
WORLD
WIDE
WEB
OR
SIMPLY
THE
WEB
TODAY
MANY
PEOPLE
EQUATE
THE
WEB
WITH
THE
INTERNET
BUT
THE
WEB
IS
ONLY
ONE
APPLICATION
OF
THE
TECH
NOLOGY
KNOWN
AS
THE
INTERNET
JAVA
PROGRAMS
CALLED
APPLETS
CAN
BE
WRITTEN
TO
AUTOMATICALLY
LOAD
AND
EXECUTE
BY
FOLLOWING
A
LINK
IN
THE
WEB
THIS
ABILITY
TO
EMBED
JAVA
PROGRAMS
IN
HTML
DOCUMENTS
WAS
A
PRIMARY
FACTOR
IN
THE
EARLY
SUCCESS
OF
JAVA
WITH
JAVA
APPLETS
WEB
DOCUMENTS
ARE
NO
LONGER
STATIC
TEXT
IMAGES
OR
VIDEO
SEGMENTS
WEB
DOCUMENTS
CAN
PROVIDE
ALL
THE
INTERACTION
OF
ANY
PROGRAM
WE
DISCUSS
GRAPHICAL
USER
INTERFACES
AND
APPLETS
IN
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
I
IF
YOU
RE
INTERESTED
IN
AN
EARLY
EXPOSURE
TO
APPLETS
WE
ALSO
PROVIDE
TEMPLATES
FOR
SIMPLE
APPLETS
IN
THE
EXER
CISES
AT
THE
END
OF
CHAPTERS
THROUGH
FROM
THE
WORLD
WIDE
WEB
WWW
AND
HTTP
YOU
CAN
BEGIN
TO
MAKE
SOME
SENSE
OF
THE
UBIQUITOUS
INTERNET
ADDRESSES
SUCH
AS
HTTP
WWW
COMPANY
COM
THIS
TYPE
OF
ADDRESS
IS
CALLED
A
UNIVERSAL
RESOURCE
LOCATOR
OR
URL
THESE
ARE
ADDRESSES
EMBEDDED
IN
HTML
DOCUMENTS
LINKING
ONE
DOCUMENT
TO
ANOTHER
CLIENT
SERVER
COMPUTING
IS
AN
ESSENTIAL
NEW
ELEMENT
IN
COMPUTERS
THAT
MANAGE
COMMUNICATIONS
AND
COMPU
TATIONS
THE
SERVER
TYPICALLY
A
FAST
COMPUTER
WITH
A
VERY
LARGE
AMOUNT
OF
HARD
DISK
STORAGE
GIVES
OUT
INFOR
MATION
TO
CLIENTS
UPON
REQUEST
AN
EXAMPLE
WOULD
BE
A
SERVER
GIVING
OUT
STOCK
MARKET
QUOTES
TO
CLIENTS
THAT
REQUEST
IT
THE
NETWORK
SUPPORT
IN
JAVA
MAKES
IMPLEMENTING
CLIENT
SERVER
PROGRAMMING
SOLUTIONS
EASY
IN
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
II
WE
SHOW
YOU
HOW
TO
IMPLEMENT
A
SIMPLE
JAVA
SERVER
PROGRAM
THAT
CAN
CONNECT
AND
RESPOND
TO
REQUESTS
FROM
MULTIPLE
CLIENTS
ON
OTHER
COMPUTERS
HUMAN
COMPUTER
INTERACTION
AND
THE
GUI
IN
THE
EARLY
DAYS
OF
COMPUTING
MOST
INTERACTION
BETWEEN
A
COMPUTER
AND
A
HUMAN
BEING
WAS
IN
THE
FORM
OF
TYPED
INPUT
TO
THE
COMPUTER
AND
PRINTED
OUTPUT
TO
THE
PERSON
MOST
HUMAN
COMPUTER
INTERACTION
TODAY
IS
DONE
WITH
A
GRAPHICAL
USER
INTERFACE
GUI
PRONOUNCED
GOOEY
THE
USER
HAS
A
KEYBOARD
USUALLY
SIMILAR
TO
A
STANDARD
TYPEWRITER
KEYBOARD
A
POINTING
DEVICE
USUALLY
A
MOUSE
AND
A
DISPLAY
DEVICE
CAPABLE
OF
DISPLAYING
BOTH
TEXT
AND
GRAPHICS
THE
USER
DISPLAY
IS
USUALLY
DIVIDED
INTO
VIEWING
AREAS
CALLED
WINDOWS
ASSOCIATED
WITH
THE
WINDOWS
ARE
MENUS
OF
COMMANDS
RELATING
TO
MANIPULATION
OF
THE
DATA
DISPLAYED
IN
THE
WINDOW
THE
DISPLAY
SCREEN
MAY
ALSO
CONTAIN
ICONS
OR
SMALL
GRAPHICAL
IMAGES
WHOSE
VISUAL
APPEARANCE
IS
DESIGNED
TO
SIGNIFY
THEIR
FUNCTIONS
FOR
EXAMPLE
A
PICTURE
OF
A
TRASH
CAN
REPRESENTS
DELETING
A
FILE
AND
AN
ARROWHEAD
IS
USED
TO
SCROLL
A
VIEWING
SCREEN
THE
FOLLOWING
SCREEN
SHOT
OF
A
TYPICAL
DESKTOP
SHOWS
SEVERAL
WINDOWS
ICONS
AND
A
ROW
OF
MENUS
ACROSS
THE
TOP
OF
EACH
WINDOW
FOR
MANY
YEARS
THE
TASK
OF
CREATING
A
GRAPHICAL
USER
INTERFACE
FOR
A
NEW
APPLICATION
WAS
EXTREMELY
TIME
CON
SUMING
AND
DIFFICULT
THE
PROGRAMMING
LANGUAGES
AND
OPERATING
SYSTEMS
IN
USE
DID
NOT
MAKE
BUILDING
SUCH
INTERFACES
EASY
THESE
INTERFACES
WERE
USUALLY
BUILT
FROM
LIBRARIES
OF
PROGRAM
PARTS
THAT
WERE
SUITABLE
ONLY
FOR
ONE
PARTICULAR
OPERATING
SYSTEM
IF
A
COMPANY
BUILDING
A
NEW
PROGRAM
WANTED
TO
HAVE
ITS
PROGRAM
RUN
ON
COMPUTERS
WITH
DIFFERENT
OPERATING
SYSTEMS
IT
WOULD
HAVE
TO
CREATE
MULTIPLE
VERSIONS
OF
THE
PROGRAMS
JAVA
PROVIDES
A
SOLUTION
SOFTWARE
COMPANIES
NOW
SELL
PROGRAMS
THAT
MAKE
BUILDING
GRAPHICAL
USER
INTERFACES
RELATIVELY
EASY
JAVA
INCLUDES
A
LIBRARY
OF
PROGRAM
PARTS
CALLED
SWING
FOR
BUILDING
GRAPHICAL
USER
INTERFACES
THE
PROGRAM
PARTS
IN
SWING
CAN
BE
USED
ON
ANY
COMPUTER
THAT
CAN
RUN
JAVA
PROGRAMS
THUS
A
PROGRAMMER
CAN
NOW
WRITE
ONE
VERSION
OF
A
PROGRAM
AND
HAVE
IT
RUN
ON
MANY
DIFFERENT
KINDS
OF
COMPUTERS
ALTHOUGH
IN
DEPTH
COVERAGE
OF
SWING
IS
BEYOND
THE
SCOPE
OF
THIS
BOOK
SWING
IS
SIMPLE
ENOUGH
TO
USE
THAT
EVEN
BEGINNING
PROGRAMMERS
CAN
BEGIN
TO
BUILD
PROGRAMS
WITH
GRAPHICAL
USER
INTERFACES
WE
DISCUSS
SWING
FURTHER
IN
CHAP
TER
GRAPHICAL
USER
INTERFACES
PART
I
AND
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
II
BY
THE
END
OF
THIS
BOOK
YOU
WILL
BE
WRITING
YOUR
OWN
SOPHISTICATED
APPLETS
AND
REGULAR
JAVA
PROGRAMS
WITH
GUIS
IF
YOU
VE
USED
A
JAVA
ENABLED
BROWSER
SUCH
AS
NETSCAPE
OR
EXPLORER
YOU
VE
PROBABLY
UNKNOWINGLY
MADE
USE
OF
AN
APPLET
IF
NOT
YOU
CAN
TRY
OUT
A
SIMPLE
APPLET
CALCULATOR
RIGHT
NOW
BY
GOING
TO
WWW
SOE
UCSC
EDU
CHARLIE
JAVA
JBD
MINICALCAPPLET
HTML
THIS
IS
THE
SAME
APPLET
PRESENTED
IN
SECTION
APPLETS
ON
PAGE
SUMMARY
INFORMALLY
AN
ALGORITHM
IS
A
LIST
OF
INSTRUCTIONS
FOR
PERFORMING
A
SPECIFIC
TASK
OR
FOR
SOLVING
A
PARTICULAR
TYPE
OF
PROBLEM
ALGORITHMLIKE
SPECIFICATIONS
FOR
PROBLEM
SOLVING
AND
TASK
PERFORMANCE
ARE
COMMONLY
FOUND
IN
EVERYDAY
SITUATIONS
A
RECIPE
IS
A
KIND
OF
ALGORITHM
ONE
GRAPHICAL
REPRESENTATION
OF
AN
ALGORITHM
IS
A
FLOW
CHART
TO
PERFORM
THE
ALGORITHM
THE
USER
JUST
FOL
LOWS
THE
ARROWS
AND
THE
INSTRUCTIONS
IN
EACH
BOX
THE
MANIPULATION
ACTIVITIES
ARE
CONTAINED
IN
RECTANGLES
THE
TESTS
ARE
SHOWN
IN
DIAMONDS
AND
THE
TRANSFER
OR
FLOW
OF
CONTROL
IS
DETERMINED
BY
THE
ARROWS
BECAUSE
OF
THEIR
VISUAL
APPEAL
AND
CLARITY
FLOW
CHARTS
ARE
OFTEN
USED
INSTEAD
OF
LISTS
OF
INSTRUCTIONS
FOR
INFORMALLY
DESCRIBING
ALGORITHMS
ALGORITHMS
THAT
CAN
BE
EXECUTED
ON
COMPUTERS
ARE
CALLED
PROGRAMS
PROGRAMS
ARE
WRITTEN
IN
SPECIAL
LAN
GUAGES
CALLED
PROGRAMMING
LANGUAGES
SUCH
AS
JAVA
WHICH
WE
USE
IN
THIS
BOOK
MODERN
COMPUTING
IS
DONE
IN
A
CONNECTED
ENVIRONMENT
A
COMPUTER
IS
CONNECTED
TO
OTHER
COMPUTERS
IN
A
NETWORK
THIS
CONNECTION
ALLOWS
THE
COMPUTERS
TO
EXCHANGE
INFORMATION
OR
TO
TALK
TO
EACH
OTHER
JAVA
WAS
DEVELOPED
WITH
NETWORK
COMPUTING
AS
THE
NORMAL
ENVIRONMENT
THE
LARGEST
NETWORK
IS
THE
GLOBAL
NETWORK
CALLED
THE
INTERNET
THIS
NETWORK
IS
USED
TO
EXCHANGE
DOCUMENTS
THROUGHOUT
THE
WORLD
WITH
A
COMMON
FORMAT
CALLED
HTML
THIS
FORMAT
ALLOWS
LINKS
TO
BE
FOLLOWED
ACROSS
THE
INTERNET
BECAUSE
OF
THESE
LINKS
THE
RESULTING
WEB
OF
DOCUMENTS
WAS
NAMED
THE
WORLD
WIDE
WEB
OR
SIMPLY
THE
WEB
IT
IS
POSSIBLE
TO
WRITE
JAVA
PROGRAMS
CALLED
APPLETS
THAT
ARE
AUTOMATICALLY
LOADED
AND
EXECUTED
AS
THE
RESULT
OF
FOLLOWING
A
LINK
IN
THE
WEB
THIS
ABILITY
TO
EMBED
JAVA
PROGRAMS
IN
HTML
DOCUMENTS
IS
A
PRI
MARY
FACTOR
IN
THE
SUCCESS
OF
JAVA
WITH
JAVA
APPLETS
WEB
DOCUMENTS
ARE
NO
LONGER
STATIC
TEXT
IMAGES
OR
VIDEO
SEGMENTS
WEB
DOCUMENTS
CAN
PROVIDE
ALL
THE
INTERACTIONS
OF
ANY
PROGRAM
REVIEW
QUESTIONS
WHAT
IS
AN
ALGORITHM
A
GRAPHICAL
DESCRIPTION
OF
A
COMPUTATION
USING
BOXES
AND
ARROWS
IS
CALLED
A
INFORMAL
BUT
RELATIVELY
PRECISE
DESCRIPTIONS
OF
ALGORITHMS
ARE
CALLED
WHAT
IS
BENCH
TESTING
WHY
IS
IT
IMPORTANT
WHAT
DID
JAVA
UTIL
REFER
TO
IN
THE
MAKECHANGE
JAVA
PROGRAM
WHAT
WAS
SYSTEM
OUT
PRINT
USED
FOR
IN
THE
JAVA
PROGRAM
WHAT
IS
HTML
WHAT
IS
HTTP
WHAT
IS
URL
WHAT
IS
A
BROWSER
NAME
A
COMMONLY
USED
BROWSER
WHAT
ARE
THE
PRIMARY
COMPONENTS
OF
A
TYPICAL
HUMAN
COMPUTER
INTERFACE
TODAY
THE
INFORMATION
PROVIDED
BY
THE
USER
TO
A
PROGRAM
WHEN
IT
EXECUTES
IS
CALLED
THE
THE
ANSWERS
PROVIDED
BY
THE
PROGRAM
ARE
CALLED
THE
WHAT
IS
SWING
EXERCISES
WRITE
A
FLOW
CHART
FOR
THE
FOLLOWING
RECIPE
FOR
COOKING
BAKED
BEANS
TAKEN
FROM
THE
NATURAL
FOODS
COOK
BOOK
NITTY
GRITTY
PRODUCTIONS
CONCORD
CALIFORNIA
LET
M
AND
N
BE
POSITIVE
INTEGERS
DRAW
A
FLOWCHART
FOR
THE
FOLLOWING
ALGORITHM
FOR
COMPUTING
THE
QUO
TIENT
Q
AND
REMAINDER
R
OF
DIVIDING
M
BY
N
SET
Q
TO
IF
M
N
THEN
STOP
Q
IS
THE
QUOTIENT
AND
M
IS
THE
REMAINDER
REPLACE
M
BY
M
N
INCREMENT
Q
BY
GO
TO
STEP
BENCH
TEST
THE
ALGORITHM
IN
THE
PREVIOUS
EXERCISE
USE
M
AND
N
AS
VALUES
LET
A
RECTANGLE
THAT
IS
ALIGNED
WITH
THE
COORDINATE
AXES
BE
REPRESENTED
BY
THE
COORDINATES
OF
ITS
LOWER
LEFT
AND
UPPER
RIGHT
CORNERS
XMIN
YMIN
AND
XMAX
YMAX
RESPECTIVELY
AS
SHOWN
IN
THE
FOLLOWING
ILLUSTRA
TION
GIVEN
TWO
SUCH
RECTANGLES
AND
DEVISE
AN
ALGORITHM
THAT
FINDS
THE
RECTANGLE
IF
ANY
THAT
IS
COMMON
TO
BOTH
AND
THE
INPUT
DATA
ARE
THE
EIGHT
REAL
NUMBERS
REPRESENTING
THE
COORDINATES
OF
THE
RECTANGLES
CORNERS
THE
ILLUSTRATION
SHOWS
TWO
RECTANGLES
THAT
HAVE
A
COMMON
RECTANGLE
SHOWN
IN
GREY
SUPPOSE
THAT
A
LINE
SEGMENT
IS
REPRESENTED
BY
ITS
TWO
ENDPOINTS
PE
XE
YE
AND
PP
XP
YP
FOR
TWO
LINE
SEGMENTS
AND
DEVISE
AN
ALGORITHM
THAT
COMPUTES
THE
COORDINATES
OF
THEIR
POINT
OF
INTERSEC
TION
IF
ANY
TWO
LINE
SEGMENTS
INTERSECT
IF
THEY
HAVE
ONLY
ONE
POINT
IN
COMMON
MAKE
A
LIST
OF
ALL
THE
AUTOMATIC
INTERACTIONS
THAT
YOU
HAVE
WITH
COMPUTERS
FOR
EXAMPLE
UTILITY
BILLS
AUTOMATIC
MAILING
LISTS
CLASS
SCHEDULING
AND
SO
ON
GIVE
A
DETAILED
STEP
BY
STEP
PROCEDURE
ALSO
CALLED
AN
ALGORITHM
FOR
TRAVELING
FROM
YOUR
PLACE
OF
RESIDENCE
TO
SCHOOL
OR
WORK
MANUALLY
DIVIDING
ONE
NUMBER
BY
ANOTHER
LONG
DIVISION
TAKING
AN
UNORDERED
SET
OF
NUMBERS
AND
PUTTING
THEM
IN
ASCENDING
SEQUENCE
I
E
SORTING
THE
NUMBERS
IN
ASCENDING
SEQUENCE
OR
PLAYING
AND
NEVER
LOSING
THE
GAME
OF
TIC
TAC
TOE
IN
THIS
CHAPTER
WE
INTRODUCE
PROGRAMMING
FUNDAMENTALS
IN
JAVA
WE
WRITE
A
JAVA
PROGRAM
BY
USING
DIFFERENT
ELEMENTS
OF
THE
JAVA
LANGUAGE
THE
MOST
BASIC
ELEMENTS
ARE
THE
TOKENS
OF
THE
LANGUAGE
TOKENS
ARE
THE
WORDS
THAT
MAKE
UP
THE
SENTENCES
OF
THE
PROGRAM
PROGRAMMING
IS
COMPARABLE
TO
WRITING
TO
WRITE
AN
ESSAY
WE
WRITE
WORDS
THAT
MAKE
UP
SENTENCES
SENTENCES
THAT
MAKE
UP
PARAGRAPHS
AND
PARAGRAPHS
THAT
MAKE
UP
ESSAYS
IN
THIS
CHAPTER
WE
CONCENTRATE
ON
HOW
TO
USE
THE
WORDS
AND
COMBINE
THEM
INTO
THE
PROGRAM
EQUIV
ALENT
OF
USEFUL
SENTENCES
AND
PARAGRAPHS
HELLO
WORLD
IN
JAVA
A
SIMPLE
FIRST
JAVA
PROGRAM
IS
THE
CLASSIC
HELLO
WORLD
PROGRAM
SO
NAMED
BECAUSE
IT
PRINTS
THE
MESSAGE
HELLO
WORLD
ON
THE
COMPUTER
SCREEN
HELLOWORLD
JAVA
PURPOSE
THE
CLASSIC
HELLO
WORLD
PROGRAM
IT
PRINTS
A
MESSAGE
TO
THE
SCREEN
AUTHOR
JANE
PROGRAMMER
AS
DERIVED
FROM
KERNIGHAN
AND
RICHIE
CLASS
HELLOWORLD
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
SYSTEM
OUT
PRINTLN
HELLO
WORLD
DISSECTION
OF
THE
HELLOWORLD
PROGRAM
HELLOWORLD
JAVA
PURPOSE
EVERYTHING
BETWEEN
A
AND
A
IS
A
COMMENT
COMMENTS
ARE
IGNORED
BY
THE
JAVA
COMPILER
AND
ARE
INSERTED
TO
MAKE
THE
PROGRAM
MORE
UNDERSTANDABLE
TO
THE
HUMAN
READER
EVERY
PROGRAM
SHOULD
BEGIN
WITH
A
COMMENT
SUCH
AS
THE
ONE
IN
THIS
EXAMPLE
IN
OUR
EXAMPLES
THE
NAME
OF
THE
FILE
APPEARS
IN
THE
COMMENT
THIS
EXAMPLE
INDICATES
THAT
IT
IS
FROM
THE
FILE
HELLOWORLD
JAVA
OTHER
THINGS
TO
INCLUDE
IN
PRO
GRAM
COMMENTS
ARE
THE
FUNCTION
OR
PURPOSE
OF
THE
PROGRAM
THE
AUTHOR
OF
THE
PROGRAM
AND
A
REVISION
HISTORY
WITH
DATES
INDICATING
MAJOR
MODIFICATIONS
TO
THE
PROGRAM
CLASS
HELLOWORLD
THE
WORD
CLASS
IS
A
KEYWORD
PRECEDING
THE
NAME
OF
THE
CLASS
A
KEYWORD
HAS
A
PREDEFINED
SPECIAL
PUR
POSE
A
CLASS
IS
A
NAMED
COLLECTION
OF
DATA
AND
INSTRUCTIONS
THE
NAME
OF
THE
CLASS
BEING
DEFINED
IN
THIS
EXAMPLE
IS
HELLOWORLD
THE
LEFT
BRACE
BEGINS
THE
DEFINITION
OF
A
CLASS
A
MATCHING
RIGHT
BRACE
IS
NEEDED
TO
END
THE
CLASS
DEFINITION
FORGETTING
TO
MATCH
BRACES
IS
A
COMMON
ERROR
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
THIS
LINE
DECLARES
THAT
THE
CLASS
HELLOWORLD
CONTAINS
A
METHOD
WITH
THE
NAME
MAIN
A
METHOD
IS
A
NAMED
GROUP
OF
INSTRUCTIONS
WITHIN
A
CLASS
IN
THIS
EXAMPLE
ONLY
ONE
METHOD
NAMED
MAIN
IS
DEFINED
FOR
THE
CLASS
HELLOWORLD
IN
CHAPTER
METHODS
FUNCTIONAL
ABSTRACTION
WE
CREATE
CLASSES
THAT
CONTAIN
SEVERAL
METHODS
IN
A
SINGLE
CLASS
WHEN
WE
USE
THE
NAME
OF
A
METHOD
WE
ADD
PARENTHESES
AT
THE
END
TO
REMIND
YOU
THAT
IT
IS
A
METHOD
THIS
CONVENTION
COMES
FROM
ACTUAL
JAVA
CODE
WHEREIN
THE
NAME
OF
A
METHOD
IS
ALWAYS
FOLLOWED
BY
PARENTHESES
THE
METHOD
DEFINED
BY
THIS
LINE
IS
THUS
REFERRED
TO
AS
MAIN
THERE
ARE
TWO
KINDS
OF
JAVA
PROGRAMS
STAND
ALONE
APPLICATIONS
AND
APPLETS
THE
METHOD
MAIN
APPEARS
IN
EVERY
STAND
ALONE
JAVA
PROGRAM
INDICATING
WHERE
PROGRAM
EXECUTION
WILL
BEGIN
LATER
WE
USE
A
DIFFERENT
LINE
THAT
SERVES
A
SIMILAR
PURPOSE
FOR
APPLETS
AN
EXPLANATION
OF
THE
WORDS
PUBLIC
STATIC
AND
VOID
IN
THIS
LINE
IS
LEFT
UNTIL
LATER
SYSTEM
OUT
PRINTLN
HELLO
WORLD
THE
ENTIRE
BODY
OF
THE
METHOD
MAIN
THE
REAL
INSTRUCTIONS
TO
THE
COMPUTER
APPEARS
BETWEEN
THE
BRACES
IN
THIS
EXAMPLE
JUST
ONE
INSTRUCTION
PRINTS
THE
DESIRED
MESSAGE
YOU
CAN
MEMORIZE
THIS
INSTRUC
TION
AND
USE
IT
AS
AN
INCANTATION
TO
GET
SOMETHING
PRINTED
OUT
ON
YOUR
COMPUTER
SCREEN
WHAT
GETS
PRINTED
IS
BETWEEN
THE
QUOTATION
MARKS
COMPILING
AND
RUNNING
YOUR
JAVA
PROGRAM
YOU
WILL
BE
DEALING
WITH
TWO
DIFFERENT
REPRESENTATIONS
OF
YOUR
PROGRAMS
THE
PART
YOU
WRITE
AND
A
FORM
MORE
SUITABLE
FOR
THE
COMPUTER
TO
USE
WHEN
IT
FINALLY
RUNS
YOUR
PROGRAM
THE
TEXT
YOU
WRITE
TO
GIVE
THE
COMPUTER
INSTRUCTIONS
IS
CALLED
THE
SOURCE
CODE
OR
SIMPLY
THE
SOURCE
THIS
SOURCE
CODE
WILL
BE
COMPILED
BY
THE
JAVA
COM
PILER
INTO
A
FORM
MORE
SUITABLE
AS
INSTRUCTIONS
TO
THE
COMPUTER
CALLED
OBJECT
CODE
THE
SOURCE
CODE
FORM
OF
COMPILING
AND
RUNNING
YOUR
JAVA
PROGRAM
THE
PROGRAM
IS
REPRESENTED
IN
THE
LANGUAGE
JAVA
THAT
YOU
WILL
BE
LEARNING
INFORMALLY
YOU
CAN
THINK
OF
THE
SOURCE
CODE
AS
THE
RAW
FORM
OF
THE
PROGRAM
IN
CONTRAST
TO
THE
OBJECT
CODE
WHICH
IS
THE
COOKED
OR
COMPILED
FORM
IN
JAVA
ALL
SOURCE
CODE
FILE
NAMES
HAVE
THE
SUFFIX
JAVA
SUCH
AS
HELLOWORLD
JAVA
THE
RESULT
OF
CORRECTLY
COMPILING
HELLOWORLD
JAVA
IS
THE
OBJECT
CODE
HELLOWORLD
CLASS
IN
SOME
SITUATIONS
THE
NAME
OF
THE
FILE
WITH
OUT
THE
JAVA
AND
THE
NAME
OF
THE
CLASS
DEFINED
IN
THE
FILE
MUST
BE
THE
SAME
ALTHOUGH
THIS
REQUIREMENT
DOES
NOT
APPLY
TO
THE
PROGRAMS
IN
THE
FIRST
PART
OF
THIS
BOOK
WE
FOLLOW
THAT
PRACTICE
EVEN
WHEN
IT
ISN
T
REQUIRED
AND
SUGGEST
THAT
YOU
DO
THE
SAME
THERE
ARE
MANY
NAMES
AND
FORMS
FOR
THE
MACHINE
REPRESENTATION
OF
A
PROGRAM
AFTER
IT
HAS
BEEN
PROCESSED
SOMEWHAT
BY
THE
COMPUTER
A
COMMON
FIRST
STEP
IN
PROCESSING
SOURCE
CODE
IS
TO
COMPILE
IT
WHICH
MEANS
TO
TRANSLATE
IT
INTO
A
FORM
MORE
SUITABLE
FOR
THE
COMPUTER
FOR
MOST
COMMON
PROGRAMMING
LANGUAGES
THIS
COM
PILED
FORM
IS
CALLED
THE
MACHINE
CODE
OBJECT
CODE
OR
BINARY
FORM
WHEN
YOU
BUY
A
PIECE
OF
SOFTWARE
YOU
USU
ALLY
GET
BINARIES
OR
AN
EXECUTABLE
IMAGE
FOR
JAVA
THIS
FORM
IS
A
BIT
DIFFERENT
AND
IS
CALLED
JAVA
BYTECODE
THESE
BYTECODES
ARE
THE
SAME
WHETHER
YOU
ARE
RUNNING
ON
A
MACINTOSH
ON
AN
INTEL
MACHINE
WITH
MICROSOFT
WINDOWS
OR
ON
A
MACHINE
FROM
SUN
RUNNING
UNIX
THIS
SAMENESS
IS
AN
IMPORTANT
ADVANTAGE
OF
JAVA
PRO
GRAMS
AS
THEY
CAN
BE
WRITTEN
TO
BE
PLATFORM
INDEPENDENT
WHICH
IS
GENERALLY
NOT
TRUE
FOR
MOST
OTHER
PRO
GRAMMING
LANGUAGES
SUCH
AS
C
OR
COBOL
IN
JAVA
ALL
BYTECODE
FILES
MUST
HAVE
A
NAME
THAT
ENDS
IN
CLASS
SUCH
AS
HELLOWORLD
CLASS
THE
WORD
CLASS
IS
USED
BECAUSE
IN
JAVA
PROGRAMS
ARE
BROKEN
INTO
CHUNKS
CALLED
CLASSES
MUCH
LIKE
A
CHAPTER
IS
BROKEN
INTO
SECTIONS
THE
FOLLOWING
DIAGRAM
ILLUSTRATES
THE
COMPILATION
PROCESS
AND
THE
CONVENTIONS
JUST
DESCRIBED
THE
COMPILATION
PROCESS
HELLOWORLD
CLASS
BYTECODE
THERE
ARE
TWO
PRINCIPAL
METHODS
FOR
COMPILING
AND
RUNNING
JAVA
PROGRAMS
ONE
METHOD
USES
AN
INTEGRATED
DEVELOPMENT
ENVIRONMENT
IDE
OF
WHICH
THERE
ARE
MANY
FOR
JAVA
THE
ACTUAL
DETAILS
OF
COMPILING
FOR
EACH
OF
THE
IDES
VARY
SLIGHTLY
BUT
THE
BASIC
STEPS
ARE
THE
SAME
JAVA
VIA
THE
IDE
USE
THE
EDITOR
THAT
COMES
WITH
THE
IDE
TO
CREATE
THE
SOURCE
FILE
THESE
EDITORS
GENERALLY
HELP
WITH
SYNTAX
BY
USING
SPECIAL
FONTS
OR
COLORS
FOR
KEYWORDS
AND
HELPING
YOU
MATCH
BRACES
AND
SO
ON
CREATE
A
PROJECT
AND
ADD
YOUR
SOURCE
FILE
TO
THE
PROJECT
SELECT
RUN
FROM
A
MENU
THE
IDE
WILL
AUTOMATICALLY
DETERMINE
THAT
THE
SOURCE
FILE
NEEDS
TO
BE
COMPILED
AND
COMPILE
IT
BEFORE
TRYING
TO
RUN
THE
PROGRAM
THE
OTHER
PRINCIPAL
METHOD
IS
THE
COMMAND
LINE
APPROACH
IN
IT
YOU
RUN
THE
COMPILER
YOURSELF
FROM
THE
COM
MAND
LINE
OF
EITHER
A
COMMAND
PROMPT
IN
WINDOWS
OR
UNIX
TERMINAL
OR
SHELL
PROGRAM
FOR
BOTH
UNIX
AND
WINDOWS
THE
STEPS
ARE
THE
SAME
JAVA
VIA
THE
COMMAND
LINE
USE
YOUR
FAVORITE
TEXT
EDITOR
TO
CREATE
THE
SOURCE
FILE
SAVE
THE
SOURCE
INTO
A
FILE
ENDING
WITH
THE
EXTENSION
JAVA
COMPILE
THE
PROGRAM
WITH
THE
COMMAND
JAVAC
FOLLOWED
BY
THE
SOURCE
FILE
NAME
FOR
EXAMPLE
JAVAC
HELLOWORLD
JAVA
IF
THE
PROGRAM
COMPILES
WITHOUT
ERRORS
RUN
THE
PROGRAM
WITH
THE
COMMAND
JAVA
FOLLOWED
BY
THE
NAME
OF
THE
CLASS
DO
NOT
APPEND
CLASS
AS
IN
HELLOWORLD
CLASS
USE
ONLY
THE
CLASS
NAME
FOR
EXAMPLE
JAVA
HELLOWORLD
THE
LAST
TWO
STEPS
ARE
SHOWN
AS
FOLLOWS
FOR
THE
PROGRAM
HELLOWORLD
OS
PROMPT
JAVAC
HELLOWORLD
JAVA
OS
PROMPT
JAVA
HELLOWORLD
HELLO
WORLD
OS
PROMPT
JAVA
HAS
RULES
ABOUT
HOW
ITS
LANGUAGE
ELEMENTS
CAN
BE
PUT
TOGETHER
TO
FORM
A
COMPLETE
PROGRAM
IN
THIS
SEC
TION
WE
BEGIN
BY
LOOKING
AT
THE
VARIOUS
WORDS
AND
SYMBOLS
CALLED
LEXICAL
ELEMENTS
THAT
ARE
USED
TO
CONSTRUCT
JAVA
PROGRAMS
THE
MOST
FUNDAMENTAL
ELEMENT
IN
THE
STRUCTURE
OF
A
PROGRAM
IS
A
SINGLE
CHARACTER
THAT
CAN
BE
DISPLAYED
ON
A
COMPUTER
SCREEN
OR
TYPED
AT
A
COMPUTER
KEYBOARD
PRIOR
TO
JAVA
MOST
PROGRAMMING
LANGUAGES
SUCH
AS
C
AND
C
USED
THE
ASCII
CHARACTER
SET
IT
PROVIDES
FOR
DIFFERENT
CHARACTERS
WHICH
IS
ENOUGH
TO
REPRESENT
ALL
THE
CHARACTERS
ON
THE
CONVENTIONAL
ENGLISH
LANGUAGE
KEYBOARD
THIS
SET
MAY
SEEM
LIKE
A
LOT
BUT
WHEN
YOU
CONSIDER
ALL
THE
HUMAN
LANGUAGES
IN
THE
WORLD
AND
THE
VARIOUS
SYMBOLS
THEY
USE
IT
IS
INADEQUATE
BECAUSE
JAVA
WAS
DESIGNED
TO
BE
USED
THROUGHOUT
THE
WORLD
NOT
JUST
IN
ENGLISH
SPEAKING
COUNTRIES
JAVA
DEVELOPERS
ADOPTED
THE
UNICODE
CHARACTER
SET
IT
PROVIDES
FOR
MORE
THAN
DIFFERENT
CHARACTERS
WHEN
A
JAVA
COMPILER
FIRST
BEGINS
TO
ANALYZE
A
JAVA
PROGRAM
IT
GROUPS
THE
INDIVIDUAL
CHARACTERS
INTO
LARGER
LEXICAL
ELEMENTS
USUALLY
CALLED
TOKENS
SOME
TOKENS
SUCH
AS
THE
PLUS
SIGN
WHICH
IS
THE
JAVA
SYMBOL
USED
TO
ADD
TWO
NUMBERS
ARE
ONLY
ONE
CHARACTER
LONG
OTHER
TOKENS
SUCH
AS
THE
KEYWORDS
CLASS
AND
PUBLIC
ARE
MANY
CHARACTERS
LONG
THESE
BASIC
TOKENS
ARE
THEN
COMBINED
INTO
LARGER
LANGUAGE
FORMS
SUCH
AS
EXPRES
SIONS
AN
EXAMPLE
OF
AN
EXPRESSION
COMPRISING
THREE
TOKENS
IS
X
Y
THERE
ARE
FIVE
TYPES
OF
TOKENS
KEYWORDS
IDENTIFIERS
LITERALS
OPERATORS
AND
PUNCTUATION
WHITE
SPACE
AND
COMMENTS
ARE
TWO
ADDITIONAL
LEXICAL
ELEMENTS
THAT
ARE
DISCARDED
EARLY
IN
THE
COMPILATION
PROCESS
WHITE
SPACE
WHITE
SPACE
IN
JAVA
REFERS
TO
THE
SPACE
CHARACTER
WHICH
YOU
GET
WHEN
YOU
STRIKE
THE
SPACE
BAR
ON
THE
KEY
BOARD
THE
TAB
CHARACTER
WHICH
IS
ACTUALLY
ONE
CHARACTER
ALTHOUGH
IT
MAY
APPEAR
AS
SEVERAL
SPACES
ON
YOUR
SCREEN
AND
THE
NEWLINE
CHARACTER
WHICH
YOU
GET
WHEN
YOU
HIT
THE
RETURN
OR
ENTER
KEY
ON
THE
KEYBOARD
WHITE
SPACE
IS
USED
PRIMARILY
TO
MAKE
THE
PROGRAM
LOOK
NICE
AND
ALSO
SERVES
TO
SEPARATE
ADJACENT
TOKENS
THAT
ARE
NOT
SEPARATED
BY
ANY
OTHER
PUNCTUATION
AND
WOULD
OTHERWISE
BE
CONSIDERED
A
SINGLE
LONGER
TOKEN
FOR
EXAM
PLE
WHITE
SPACE
IS
USED
TO
SEPARATE
THE
FOLLOWING
THREE
TOKENS
PUBLIC
STATIC
VOID
IN
THE
HELLOWORLD
PROGRAM
IN
SUCH
SITUATIONS
WHERE
ONE
WHITE
SPACE
CHARACTER
IS
REQUIRED
ANY
NUMBER
OF
WHITE
SPACE
CHARACTERS
CAN
BE
USED
FOR
EXAMPLE
WE
COULD
HAVE
PUT
EACH
OF
THE
WORDS
PUBLIC
STATIC
AND
VOID
ON
SEPARATE
LINES
OR
PUT
LOTS
OF
SPACES
BETWEEN
THEM
AS
IN
PUBLIC
STATIC
VOID
MAIN
EXCEPT
FOR
STRING
LITERALS
WHICH
WE
DISCUSS
SHORTLY
ANY
NUMBER
OF
ADJACENT
WHITE
SPACE
CHARACTERS
EVEN
MIXING
TAB
SPACE
AND
NEWLINE
CHARACTERS
IS
THE
SAME
AS
JUST
ONE
WHITE
SPACE
CHARACTER
AS
FAR
AS
THE
STRUC
TURE
AND
MEANING
OF
THE
PROGRAM
ARE
CONCERNED
STATED
ANOTHER
WAY
IF
YOU
CAN
LEGALLY
PUT
IN
ONE
SPACE
YOU
CAN
PUT
IN
AS
MANY
SPACES
TABS
AND
NEWLINES
AS
YOU
WANT
YOU
CAN
T
PUT
WHITE
SPACE
IN
THE
MIDDLE
OF
A
KEY
WORD
OR
IDENTIFIER
SUCH
AS
A
VARIABLE
OR
CLASS
NAME
WE
DISCUSS
KEYWORDS
IDENTIFIERS
AND
VARIABLES
LATER
IN
THIS
CHAPTER
COMMENTS
COMMENTS
COMMENTS
ARE
VERY
IMPORTANT
IN
WRITING
GOOD
CODE
AND
ARE
TOO
OFTEN
NEGLECTED
THE
PURPOSE
OF
A
COMMENT
IS
TO
PROVIDE
ADDITIONAL
INFORMATION
TO
THE
PERSON
READING
A
PROGRAM
IT
SERVES
AS
A
CONCISE
FORM
OF
PROGRAM
DOCUMENTATION
AS
FAR
AS
THE
COMPUTER
IS
CONCERNED
THE
COMMENT
DOES
NOT
RESULT
IN
A
TOKEN
IT
SEPARATES
OTHER
TOKENS
OR
IS
IGNORED
COMPLETELY
WHEN
IT
ISN
T
NEEDED
TO
SEPARATE
TOKENS
JAVA
HAS
THREE
WAYS
TO
SPECIFY
COMMENTS
A
SINGLE
LINE
COMMENT
BEGINS
WITH
AND
CAUSES
THE
REST
OF
THE
LINE
ALL
CHARACTERS
TO
THE
NEXT
NEWLINE
TO
BE
TREATED
AS
A
COMMENT
AND
IGNORED
BY
THE
COMPILER
IT
IS
CALLED
A
SINGLE
LINE
COMMENT
BECAUSE
THE
COMMENT
CAN
T
BE
LONGER
THAN
A
SINGLE
LINE
BY
DEFINITION
THE
COMMENT
ENDS
AT
THE
END
OF
THE
LINE
CONTAINING
THE
A
MULTILINE
COMMENT
CAN
EXTEND
ACROSS
SEVERAL
LINES
IN
A
PROGRAM
THE
BEGINNING
OF
THE
COMMENT
IS
MARKED
WITH
AND
THE
END
OF
THE
COMMENT
IS
MARKED
WITH
EVERYTHING
BETWEEN
THE
MARKS
AND
THE
MARKS
THEM
SELVES
IS
A
COMMENT
AND
IS
IGNORED
HERE
IS
THE
MULTILINE
COMMENT
FROM
OUR
FIRST
JAVA
PROGRAM
HELLOWORLD
JAVA
PURPOSE
THIS
IS
THE
CLASSIC
HELLO
WORLD
PROGRAM
IT
SIMPLY
PRINTS
A
MESSAGE
TO
THE
SCREEN
AUTHOR
JANE
PROGRAMMER
AS
DERIVED
FROM
KERNIGHAN
AND
RICHIE
THE
SINGLE
ASTERISKS
ON
THE
INTERMEDIATE
LINES
ARE
NOT
REQUIRED
AND
ARE
USED
MERELY
TO
ACCENT
THE
EXTENT
OF
THE
COMMENT
THESE
COMMENTS
ARE
ALSO
CALLED
BLOCK
COMMENTS
THE
THIRD
STYLE
OF
COMMENT
IS
A
MINOR
VARIATION
ON
THE
MULTILINE
COMMENT
THE
BEGINNING
MARKER
HAS
AN
ADDITIONAL
ASTERISK
THAT
IS
THE
BEGINNING
OF
THE
COMMENT
IS
MARKED
WITH
AND
THE
END
OF
THE
COMMENT
IS
MARKED
WITH
THESE
COMMENTS
ARE
IDENTICAL
TO
THE
MULTILINE
COMMENT
EXCEPT
THAT
THEY
ARE
RECOGNIZED
BY
A
SPECIAL
PROGRAM
CALLED
JAVADOC
THAT
AUTOMATICALLY
EXTRACTS
SUCH
COMMENTS
AND
PRODUCES
DOCUMENTATION
FOR
THE
PROGRAM
ORGANIZED
AS
AN
HTML
DOCUMENT
SEE
SECTION
PROGRAMMING
STYLE
ON
PAGE
FOR
MORE
ABOUT
JAVADOC
KEYWORDS
KEYWORDS
ALSO
KNOWN
AS
RESERVED
WORDS
HAVE
A
PREDEFINED
SPECIAL
PURPOSE
AND
CAN
T
BE
USED
FOR
ANY
BUT
THAT
PURPOSE
EACH
OF
THE
KEYWORDS
IN
JAVA
HAS
A
SPECIAL
MEANING
TO
THE
JAVA
COMPILER
A
KEYWORD
MUST
BE
SEPARATED
FROM
OTHER
KEYWORDS
OR
IDENTIFIERS
BY
WHITE
SPACE
A
COMMENT
OR
SOME
OTHER
PUNCTUATION
SYMBOL
THE
FOLLOWING
TABLE
SHOWS
ALL
THE
JAVA
KEYWORDS
ABSTRACT
CONTINUE
FOR
NEW
SYNCHRONIZED
ASSERT
DEFAULT
GOTO
PACKAGE
THIS
BOOLEAN
DO
IF
PRIVATE
THROW
BREAK
DOUBLE
IMPLEMENTS
PROTECTED
THROWS
BYTE
ELSE
IMPORT
PUBLIC
TRANSIENT
CASE
ENUM
INSTANCEOF
RETURN
TRY
CATCH
EXTENDS
INT
SHORT
VOID
CHAR
FINAL
INTERFACE
STATIC
VOLATILE
CLASS
FINALLY
LONG
SUPER
WHILE
CONST
FLOAT
NATIVE
SWITCH
THE
KEYWORDS
CONST
AND
GOTO
HAVE
NO
MEANING
IN
JAVA
THEY
ARE
KEYWORDS
IN
C
A
LANGUAGE
THAT
WAS
A
PRECURSOR
TO
JAVA
THEY
ARE
INCLUDED
AS
KEYWORDS
TO
FACILITATE
ERROR
REPORTING
WHEN
PROGRAMMERS
WITH
C
EXPERIENCE
ACCIDENTALLY
USE
THEM
IN
ADDITION
THE
WORDS
NULL
TRUE
AND
FALSE
LOOK
LIKE
KEYWORDS
IN
THAT
THEY
HAVE
A
PREDEFINED
MEANING
BUT
THEY
ARE
IN
FACT
LITERALS
AS
DISCUSSED
LATER
IDENTIFIERS
IDENTIFIERS
ARE
THE
NAMES
USED
TO
SPECIFY
DIFFERENT
ELEMENTS
OF
A
JAVA
PROGRAM
SUCH
AS
A
CLASS
METHOD
OR
VARIABLE
WE
DISCUSS
VARIABLES
IN
SECTION
VARIABLES
ON
PAGE
AN
IDENTIFIER
IN
OUR
FIRST
PROGRAM
WAS
HELLOWORLD
A
NAME
WE
PICKED
FOR
THE
CLASS
ANOTHER
IDENTIFIER
WAS
THE
LIBRARY
METHOD
NAME
PRINTLN
A
NAME
PICKED
BY
THE
JAVA
DEVELOPERS
IN
BOTH
CASES
THE
NAME
GIVES
A
CLUE
AS
TO
THE
USE
OF
THAT
ELEMENT
OF
THE
PROGRAM
AN
IDENTIFIER
IS
ANY
SEQUENCE
OF
JAVA
LETTERS
AND
DIGITS
THE
FIRST
OF
WHICH
MUST
BE
A
JAVA
LETTER
WITH
TWO
EXCEPTIONS
A
KEYWORD
CAN
T
BE
AN
IDENTIFIER
AND
THE
SPECIAL
LITERAL
TERMS
TRUE
FALSE
AND
NULL
CAN
T
BE
USED
AS
IDENTIFIERS
THE
JAVA
LETTERS
AND
DIGITS
INCLUDE
THE
LETTER
AND
DIGIT
SYMBOLS
FOR
MANY
MODERN
WRITTEN
LANGUAGES
THE
JAVA
LETTERS
INCLUDE
THE
ENGLISH
LANGUAGE
UPPERCASE
AND
LOWERCASE
LETTERS
THE
AND
THE
UNDERSCORE
THE
LAST
TWO
ARE
INCLUDED
BECAUSE
OF
JAVA
CLOSE
KINSHIP
TO
THE
PROGRAMMING
LANGUAGE
C
WHICH
INCLUDED
THESE
SYMBOLS
AS
LEGAL
CHARACTERS
IN
IDENTIFIERS
THE
JAVA
DIGITS
ARE
THROUGH
IN
OUR
EXAM
PLES
WE
USE
ONLY
ENGLISH
LETTERS
AND
DIGITS
THE
FOLLOWING
ARE
SOME
EXAMPLES
OF
LEGAL
IDENTIFIERS
ALONG
WITH
COMMENTS
PROVIDING
SOME
EXPLANATION
DATA
VARIABLE
NAME
CONVEYING
ITS
USE
HELLOWORLD
CLASS
NAME
YOUCANALMOSTMAKEASENTENCE
UNLIKELY
NEXTINT
METHOD
NAME
FROM
SCANNER
CLASS
X
SIMPLE
VARIABLE
USUALLY
DOUBLE
OBSCURE
NAME
A
POOR
CHOICE
THE
FOLLOWING
ARE
SOME
ILLEGAL
IDENTIFIERS
ALONG
WITH
COMMENTS
INDICATING
WHAT
THE
SEQUENCE
OF
SYMBOLS
REALLY
IS
A
DIGIT
OR
INTEGER
LITERAL
X
Y
AN
EXPRESSION
WHERE
X
AND
Y
ARE
IDENTIFIERS
SOME
NAME
ILLEGAL
INTERNAL
CHARACTERS
NO
SPACE
INTENDED
WAS
NOSPACE
CANNOT
START
WITH
A
DIGIT
CLASS
KEYWORD
CANNOT
BE
USED
AS
AN
IDENTIFIER
LITERALS
JAVA
HAS
BUILT
IN
TYPES
FOR
NUMBERS
CHARACTERS
AND
BOOLEANS
JAVA
ALSO
HAS
A
STANDARD
CLASS
TYPE
FOR
STRINGS
THE
TYPE
OF
A
DATA
VALUE
TELLS
THE
COMPUTER
HOW
TO
INTERPRET
THE
DATA
THESE
BUILT
IN
TYPES
ARE
CALLED
PRIMITIVE
TYPES
IN
JAVA
LITERALS
ALSO
CALLED
CONSTANTS
ARE
THE
LITERAL
PROGRAM
REPRESENTATIONS
OF
VALUES
FOR
THE
PRIMITIVE
NUMERIC
TYPES
THE
PRIMITIVE
TYPE
BOOLEAN
THE
PRIMITIVE
CHARACTER
TYPE
CHAR
AND
THE
STANDARD
CLASS
STRING
TYPE
STRING
WITHOUT
GOING
INTO
THE
DETAILS
OF
THESE
VARIOUS
TYPES
THE
FOLLOWING
ARE
SOME
EXAMPLES
OF
LITERAL
VALUES
JAVA
TYPE
EXPLANATION
EXAMPLES
INT
INTEGERS
NUMBERS
WITHOUT
FRACTIONAL
PARTS
DOUBLE
DOUBLE
PRECISION
NUMBERS
WITH
FRACTIONAL
PARTS
STRING
ARBITRARY
STRINGS
OF
CHARACTERS
OH
J
BOOLEAN
LOGICAL
VALUES
TRUE
OR
FALSE
TRUE
FALSE
CHAR
SINGLE
CHARACTERS
A
OPERATORS
AND
PUNCTUATION
LIKE
KEYWORDS
THE
SYMBOLS
TRUE
AND
FALSE
CAN
T
BE
USED
AS
IDENTIFIERS
THEY
ARE
RESERVED
TO
REPRESENT
THE
TWO
POSSIBLE
BOOLEAN
VALUES
WE
EXPLAIN
LATER
IN
MORE
DETAIL
WHAT
CONSTITUTES
AN
ACCEPTABLE
LITERAL
FOR
EACH
DATA
TYPE
OPERATORS
AND
PUNCTUATION
IN
ADDITION
TO
KEYWORDS
IDENTIFIERS
AND
LITERALS
A
JAVA
PROGRAM
CONTAINS
OPERATORS
AND
SEPARATORS
OR
PUNC
TUATION
THE
OPERATORS
ARE
THINGS
LIKE
AND
THE
SEPARATORS
ARE
THINGS
LIKE
THE
THAT
TERMINATES
SOME
STATEMENTS
AND
THE
BRACES
USED
TO
GROUP
THINGS
TO
FULLY
UNDERSTAND
OPERATORS
YOU
NEED
TO
UNDERSTAND
TYPE
PRECEDENCE
AND
ASSOCIATIVITY
TYPE
DETERMINES
THE
KIND
OF
VALUE
COMPUTED
SUCH
AS
INT
OR
DOUBLE
PRECEDENCE
DETERMINES
AMONG
OPERATORS
SUCH
AS
AND
USED
IN
AN
EXPRESSION
WHICH
IS
DONE
FIRST
ASSOCIA
TIVITY
IS
THE
ORDER
IN
WHICH
OPERATORS
OF
THE
SAME
PRECEDENCE
ARE
EVALUATED
AND
IS
USUALLY
LEFT
MOST
FIRST
FOR
EXAMPLE
INT
N
N
N
AN
ASSIGNMENT
EXPRESSION
THE
VARIABLE
N
IS
AN
INTEGER
VARIABLE
INITIALIZED
TO
NEXT
N
IS
MULTIPLIED
BY
THE
INTEGER
LITERAL
THIS
RESULT
IS
ADDED
TO
AND
FINALLY
THIS
VALUE
IS
ASSIGNED
TO
N
REPLACING
THE
ORIGINAL
VALUE
OF
WITH
THE
NEW
VALUE
OF
PRECEDENCE
OF
THE
MULTIPLICATION
OPERATOR
IS
HIGHER
THAN
SO
THE
MULTIPLICATION
IS
DONE
BEFORE
THE
ADDI
TION
PRECEDENCE
OF
THE
ASSIGNMENT
OPERATOR
IS
LOWEST
SO
ASSIGNMENT
OCCURS
AS
THE
LAST
ACTION
IN
THIS
EXPRESSION
WE
DISCUSS
PRECEDENCE
AND
ASSOCIATIVITY
OF
OPERATORS
FURTHER
IN
SECTION
PRECEDENCE
AND
ASSOCIATIVITY
OF
OPERATORS
ON
PAGE
IN
ORDER
TO
DO
SOMETHING
USEFUL
COMPUTER
PROGRAMS
MUST
STORE
AND
MANIPULATE
DATA
MANY
PROGRAMMING
LANGUAGES
INCLUDING
JAVA
REQUIRE
THAT
EACH
DATA
ITEM
HAVE
A
DECLARED
TYPE
THAT
IS
YOU
MUST
SPECIFY
THE
KIND
OF
INFORMATION
REPRESENTED
BY
THE
DATA
OR
THE
DATA
TYPE
THE
DATA
TYPE
DETERMINES
HOW
DATA
IS
REPRE
SENTED
IN
THE
COMPUTER
MEMORY
AND
WHAT
OPERATIONS
CAN
BE
PERFORMED
ON
THE
DATA
DIFFERENT
PROGRAMMING
LANGUAGES
SUPPORT
DIFFERENT
DATA
TYPES
A
DATA
TYPE
CAN
BE
SOMETHING
AS
FUNDAMEN
TAL
AS
A
TYPE
FOR
REPRESENTING
INTEGERS
OR
AS
COMPLEX
AS
A
TYPE
FOR
REPRESENTING
A
DIGITAL
MOVIE
SOME
EXAM
PLES
OF
DATA
TYPES
FOUND
IN
JAVA
ARE
INT
FOR
REPRESENTING
INTEGERS
OR
WHOLE
NUMBERS
DOUBLE
FOR
REPRESENTING
NUMBERS
HAVING
A
FRACTION
STRING
FOR
REPRESENTING
TEXT
BUTTON
FOR
REPRESENTING
A
PUSH
BUTTON
IN
A
GRAPHICAL
USER
INTERFACE
AND
POINT
FOR
REPRESENTING
POINTS
IN
A
PLANE
THE
TYPES
OF
DATA
THAT
ARE
CREATED
STORED
AND
MANIPULATED
BY
JAVA
PROGRAMS
CAN
BE
SEPARATED
INTO
TWO
MAIN
GROUPS
PRIMITIVE
TYPES
AND
CLASS
TYPES
OR
SIMPLY
CLASSES
THERE
ARE
EIGHT
PRIMITIVE
TYPES
THE
NUMERIC
TYPES
BYTE
SHORT
INT
LONG
FLOAT
AND
DOUBLE
FOR
STORING
NUMERIC
VALUES
THE
CHARACTER
TYPE
CHAR
FOR
STORING
A
SINGLE
ALPHABETIC
CHARACTER
DIGIT
OR
SYMBOL
AND
THE
TYPE
BOOLEAN
FOR
STORING
TRUE
OR
FALSE
PRIMITIVE
DATA
VALUES
CAN
BE
CREATED
BY
USING
LITERALS
SUCH
AS
A
AND
TRUE
PRIMITIVE
VALUES
CAN
ALSO
BE
OPERATED
ON
BY
USING
BUILT
IN
OPERATORS
SUCH
AS
FOR
ADDITION
AND
FOR
SUBTRACTION
OF
TWO
NUMERIC
VALUES
PRODUCING
A
NEW
PRIMITIVE
VALUE
FOR
EXAMPLE
USES
ADDITION
TO
OPERATE
ON
THE
TWO
NUMERIC
LITERAL
VALUES
AND
TO
PRODUCE
THE
NEW
PRIMITIVE
VALUE
STANDARD
JAVA
HAS
MORE
THAN
CLASSES
THE
STRING
BUTTON
AND
POINT
TYPES
MENTIONED
PREVIOUSLY
ARE
STANDARD
JAVA
CLASSES
YOU
WILL
LEARN
IN
CHAPTER
OBJECTS
DATA
ABSTRACTION
THAT
YOU
CAN
CREATE
YOUR
OWN
CLASSES
ALSO
IN
CHAPTER
ARRAYS
AND
CONTAINERS
WE
DISCUSS
ARRAYS
WHICH
ARE
A
SPECIAL
CASE
OF
CLASS
TYPES
THE
DATA
VALUES
THAT
ARE
CLASS
TYPES
ARE
CALLED
OBJECTS
YOU
CAN
CREATE
OBJECT
DATA
VALUES
BY
USING
THE
SPECIAL
OPERATOR
NEW
FOLLOWED
BY
THE
CLASS
NAME
AND
POSSIBLY
SOME
ADDITIONAL
VALUES
NEEDED
TO
CREATE
THE
NEW
OBJECT
FOR
EXAMPLE
NEW
BUTTON
QUIT
CREATES
A
NEW
OBJECT
DESCRIBING
A
BUTTON
WITH
THE
LABEL
QUIT
YOU
CAN
CREATE
NEW
OBJECTS
OF
TYPE
STRING
AS
A
SPECIAL
CASE
BY
USING
THE
STRING
LITERAL
NOTATION
THAT
SUR
ROUNDS
THE
TEXT
OF
THE
STRING
WITH
DOUBLE
QUOTATION
MARKS
FOR
EXAMPLE
HELLO
WORLD
CREATES
A
NEW
STRING
OBJECT
IN
MOST
CASES
THE
OPERATIONS
SUPPORTED
FOR
THE
PARTICULAR
CLASS
ARE
GIVEN
A
NAME
AND
INVOKED
BY
PLACING
THE
NAME
AFTER
THE
OBJECT
VALUE
SEPARATED
BY
A
DOT
FOR
EXAMPLE
HELLO
WORLD
LENGTH
OPERATES
ON
THE
LITERAL
STRING
HELLO
WORLD
AND
EVALUATES
TO
THE
NUMBER
OF
CHARACTERS
IN
THIS
STRING
INCLUDING
ANY
BLANKS
OPERATIONS
SUCH
AS
LENGTH
DEFINED
FOR
A
PARTICULAR
CLASS
ARE
CALLED
METHODS
WE
DIS
CUSS
METHODS
IN
GREAT
DETAIL
IN
SUBSEQUENT
CHAPTERS
VARIABLES
IN
ALL
BUT
THE
MOST
TRIVIAL
PROGRAMS
SUCH
AS
HELLOWORLD
YOU
WILL
DECLARE
VARIABLES
THAT
ARE
IDENTIFIERS
USED
TO
REFER
TO
DATA
VALUES
THAT
ARE
STORED
IN
THE
COMPUTER
MEMORY
THESE
ARE
CALLED
VARIABLES
BECAUSE
A
VARI
ABLE
ACTUALLY
REFERS
TO
A
PARTICULAR
PLACE
IN
THE
COMPUTER
MEMORY
AND
THE
VALUE
STORED
IN
THE
COMPUTER
MEMORY
CAN
VARY
AS
THE
PROGRAM
RUNS
A
VARIABLE
DECLARATION
ALWAYS
BEGINS
WITH
A
TYPE
AND
ENDS
WITH
A
SEMI
COLON
THE
TYPE
IS
USED
TO
IDENTIFY
THE
KIND
OF
DATA
THAT
WILL
BE
STORED
IN
THE
MEMORY
LOCATION
ASSOCIATED
WITH
THE
VARIABLE
BEING
DECLARED
SOME
EXAMPLES
OF
VARIABLE
DECLARATIONS
ARE
INT
I
J
STRING
SENTENCE
BOOLEAN
HOT
COLD
LUKEWARM
BUTTON
CLICKTOEXIT
NOTE
THAT
YOU
CAN
DECLARE
SEVERAL
VARIABLES
OF
THE
SAME
TYPE
BY
SEPARATING
THE
NAMES
WITH
A
COMMA
GOOD
CHOICE
OF
VARIABLE
NAMES
IS
IMPORTANT
TO
WRITING
CLEARLY
UNDERSTANDABLE
CODE
STYLISTICALLY
CHOOSE
VARIABLE
NAMES
THAT
ARE
MEANINGFUL
ALSO
VARIABLE
NAMES
USUALLY
START
IN
LOWERCASE
AND
IF
THEY
ARE
MULTIWORD
THE
INTERNAL
WORDS
START
WITH
AN
UPPERCASE
CHARACTER
AS
IN
CLICKTOEXIT
VARIABLE
INITIALIZATION
VARIABLES
CAN
BE
GIVEN
INITIAL
VALUES
THE
PRECEDING
SET
OF
DECLARATIONS
GIVEN
INITIAL
VALUES
FOR
EACH
VARIABLE
BECOMES
INT
I
J
STRING
SENTENCE
I
AM
A
CAMERA
BOOLEAN
HOT
TRUE
COLD
FALSE
LUKEWARM
FALSE
BUTTON
CLICKTOEXIT
NEW
BUTTON
EXIT
INITIALIZING
VARIABLES
WITH
LITERALS
OF
THEIR
RESPECTIVE
TYPE
IS
NORMAL
IN
THIS
EXAMPLE
THE
INT
VARIABLE
I
IS
INI
TIALLY
GIVEN
THE
VALUE
THE
BOOLEAN
VARIABLE
HOT
IS
INITIALLY
TRUE
THE
STRING
VARIABLE
SENTENCE
IS
INITIAL
IZED
WITH
A
STRING
LITERAL
AN
EXAMPLE
STRING
CONCATENATION
WITH
THE
EXCEPTION
OF
STRING
JAVA
HAS
NO
LITERALS
FOR
CREATING
OBJECT
VALUES
YOU
INITIALIZE
THE
BUTTON
VARI
ABLE
BY
CREATING
A
BUTTON
OBJECT
USING
NEW
AS
DISCUSSED
BRIEFLY
EARLIER
WE
DISCUSS
OBJECT
CREATION
IN
CHAPTER
OBJECTS
DATA
ABSTRACTION
THE
FOLLOWING
EXAMPLE
IS
A
COMPLETE
PROGRAM
THAT
DECLARES
THREE
VARIABLES
AND
SENTENCE
VALUES
ARE
THEN
ASSIGNED
TO
THE
PARTS
OF
THE
COMPUTER
MEMORY
REFERRED
TO
BY
THOSE
VARIABLES
JAVA
SIMPLE
VARIABLE
DECLARATIONS
CLASS
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
STRING
DECLARE
A
STRING
VARIABLE
STRING
SENTENCE
DECLARE
TWO
MORE
HELLO
WORLD
SENTENCE
CONCAT
SYSTEM
OUT
PRINTLN
SENTENCE
DISSECTION
OF
THE
PROGRAM
STRING
DECLARE
A
STRING
VARIABLE
STRING
SENTENCE
DECLARE
TWO
MORE
WHENEVER
YOU
INTRODUCE
A
NEW
IDENTIFIER
YOU
MUST
DECLARE
IT
YOU
DECLARE
THAT
AN
IDENTIFIER
IS
A
VARIABLE
BY
FIRST
WRITING
THE
NAME
OF
THE
KIND
OF
VALUE
THE
VARIABLE
REFERS
TO
CALLED
THE
TYPE
THE
TYPE
IS
STRING
IN
THIS
EXAMPLE
INSERT
THE
NAME
OF
THE
NEW
VARIABLE
AFTER
THE
TYPE
FOR
VARIABLES
IN
JAVA
THE
COMPUTER
MUST
ALWAYS
KNOW
THE
TYPE
OF
VALUE
TO
BE
STORED
IN
THE
MEMORY
LOCATION
ASSOCIATED
WITH
THAT
VARIABLE
AS
SHOWN
IN
THE
SECOND
LINE
YOU
CAN
DECLARE
MORE
THAN
ONE
VARIABLE
AT
A
TIME
BY
GIVING
FIRST
THE
TYPE
AND
THEN
A
COMMA
SEPARATED
LIST
OF
NEW
IDENTIFIERS
HELLO
WORLD
THE
SYMBOL
IS
CALLED
THE
ASSIGNMENT
OPERATOR
AND
IS
USED
TO
STORE
VALUES
IN
VARIABLES
READ
THE
FIRST
STATEMENT
AS
GETS
THE
VALUE
HELLO
OR
IS
ASSIGNED
THE
VALUE
HELLO
HERE
IT
IS
USED
TO
ASSIGN
THE
STRING
LITERALS
HELLO
AND
WORLD
TO
THE
NEWLY
DECLARED
VARIABLES
AND
RESPECTIVELY
THE
VARIABLE
NAME
WILL
ALWAYS
BE
ON
THE
LEFT
AND
THE
NEW
VALUE
TO
BE
ASSIGNED
TO
THE
VARI
ABLE
WILL
ALWAYS
BE
ON
THE
RIGHT
SAYING
ASSIGN
THE
VALUE
HELLO
TO
THE
VARIABLE
REALLY
MEANS
TO
STORE
THE
STRING
VALUE
HELLO
IN
THE
COMPUTER
MEMORY
LOCATION
ASSOCIATED
WITH
THE
VARIABLE
SENTENCE
CONCAT
THIS
STATEMENT
CONTAINS
AN
EXPRESSION
USED
TO
CREATE
A
THIRD
STRING
VALUE
WHICH
IS
THEN
ASSIGNED
TO
THE
VARIABLE
SENTENCE
THIS
EXPRESSION
USES
THE
METHOD
CONCAT
WHICH
IS
DEFINED
FOR
VALUES
OF
TYPE
STRING
RECALL
THAT
OPERATIONS
ON
OBJECTS
ARE
CALLED
METHODS
THIS
PARTICULAR
OPERATION
REQUIRES
A
SEC
OND
STRING
VALUE
PLACED
BETWEEN
THE
PARENTHESES
THE
METHOD
NAME
CONCAT
IS
SHORT
FOR
CONCATENATION
THE
CONCATENATION
OF
TWO
STRINGS
IS
A
NEW
STRING
THAT
CONTAINS
THE
SYMBOLS
FROM
THE
FIRST
STRING
FOLLOWED
BY
THE
SYMBOLS
FROM
THE
SECOND
STRING
NOTE
THAT
THE
FIRST
STRING
CONTAINS
A
SPACE
AT
THE
END
THUS
WHEN
WE
CONCATENATE
THE
TWO
STRINGS
WE
GET
THE
NEW
STRING
HELLO
WORLD
WHICH
IS
ASSIGNED
TO
THE
VARIABLE
SENTENCE
AS
WE
SHOWED
EARLIER
WHEN
A
VARIABLE
IS
DECLARED
IT
CAN
BE
GIVEN
AN
INITIAL
VALUE
THIS
APPROACH
ESSENTIALLY
COMBINES
AN
ASSIGNMENT
WITH
THE
DECLARATION
USING
THIS
NOTATION
YOU
CAN
NOW
WRITE
THE
BODY
OF
MAIN
IN
AS
STRING
HELLO
STRING
WORLD
STRING
SENTENCE
CONCAT
SYSTEM
OUT
PRINTLN
SENTENCE
YOU
COULD
EVEN
COMBINE
TWO
INITIALIZATIONS
IN
A
SINGLE
STATEMENT
STRING
WORLD
SENTENCE
CONCAT
ALTHOUGH
AS
A
GENERAL
RULE
MULTIPLE
COMPLEX
INITIALIZATIONS
SUCH
AS
THIS
SHOULD
BE
PLACED
ON
SEPARATE
LINES
STRINGS
VERSUS
IDENTIFIERS
VERSUS
VARIABLES
A
STRING
IS
A
PARTICULAR
DATA
VALUE
THAT
A
PROGRAM
CAN
MANIPULATE
A
VARIABLE
IS
A
PLACE
IN
THE
COMPUTER
MEMORY
WITH
AN
ASSOCIATED
IDENTIFIER
THE
FOLLOWING
EXAMPLE
USES
THE
IDENTIFIER
HELLO
TO
REFER
TO
A
VARIABLE
OF
TYPE
STRING
THE
IDENTIFIER
STRINGVARY
REFERS
TO
A
SECOND
VARIABLE
OF
TYPE
STRING
WE
FIRST
ASSIGN
STRINGVARY
THE
VALUE
ASSOCIATED
WITH
THE
STRING
VARIABLE
HELLO
LATER
WE
REASSIGN
IT
THE
STRING
VALUE
HELLO
STRINGVSID
JAVA
CONTRAST
STRINGS
AND
IDENTIFIERS
CLASS
STRINGVSID
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
STRING
HELLO
HELLO
WORLD
STRING
STRINGVARY
STRINGVARY
HELLO
SYSTEM
OUT
PRINTLN
STRINGVARY
STRINGVARY
HELLO
SYSTEM
OUT
PRINTLN
STRINGVARY
THE
OUTPUT
OF
THIS
PROGRAM
IS
THE
PROGRAM
DEMONSTRATES
TWO
IMPORTANT
POINTS
FIRST
IT
SHOWS
THE
DIFFERENCE
BETWEEN
THE
IDENTIFIER
HELLO
WHICH
IN
FACT
REFERS
TO
THE
STRING
HELLO
WORLD
AND
THE
STRING
HELLO
WHICH
IS
REFERRED
TO
AT
ONE
POINT
BY
THE
VARIABLE
STRINGVARY
THIS
EXAMPLE
ALSO
SHOWS
THAT
A
VARIABLE
CAN
VARY
THE
VARIABLE
STRINGVARY
FIRST
REFERS
TO
THE
VALUE
HELLO
WORLD
BUT
LATER
REFERS
TO
THE
VALUE
HELLO
IN
THE
PROGRAMS
PRESENTED
SO
FAR
WE
HAVE
GENERATED
OUTPUT
ONLY
BY
USING
SYSTEM
OUT
PRINTLN
MOST
PROGRAMS
INPUT
SOME
DATA
AS
WELL
AS
GENERATE
OUTPUT
THERE
ARE
LOTS
OF
WAYS
TO
INPUT
DATA
IN
JAVA
BUT
THE
SIMPLEST
IS
TO
USE
A
CLASS
SCANNER
PROVIDED
IN
THE
PACKAGE
JAVA
UTIL
AS
SHOWN
IN
THE
FOLLOWING
EXAMPLE
AREA
JAVA
READING
FROM
THE
KEYBOARD
IMPORT
JAVA
UTIL
CLASS
AREA
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
DOUBLE
WIDTH
HEIGHT
AREA
SCANNER
SCAN
NEW
SCANNER
SYSTEM
IN
SYSTEM
OUT
PRINTLN
TYPE
TWO
DOUBLES
FOR
THE
WIDTH
AND
HEIGHT
OF
A
RECTANGLE
WIDTH
SCAN
NEXTDOUBLE
HEIGHT
SCAN
NEXTDOUBLE
ASSERT
WIDTH
HEIGHT
AREA
WIDTH
HEIGHT
SYSTEM
OUT
PRINT
THE
AREA
IS
SYSTEM
OUT
PRINTLN
AREA
HERE
IS
A
TABLE
OF
SOME
OF
THE
METHODS
USED
FOR
GETTING
INPUT
FROM
THE
TERMINAL
USING
A
SCANNER
AS
YOU
CAN
SEE
THE
BASIC
DATA
TYPES
HAVE
A
CORRESPONDING
NEXTTYPE
METHOD
FOR
READING
AND
RETURNING
AN
INPUT
OF
THAT
TYPE
IF
THE
INPUT
IS
OF
THE
WRONG
TYPE
THESE
METHODS
FAIL
AND
THROW
AN
EXCEPTION
TO
AVOID
THIS
WE
CAN
USE
METHODS
OF
THE
FORM
HASNEXTTYPE
THAT
RETURN
TRUE
IF
THE
NEXT
INPUT
CAN
BE
CORRECTLY
INTERPRETED
AN
EXAM
PLE
WOULD
BE
HASNEXTINT
THAT
CHECKS
THAT
THE
INPUT
CAN
BE
INTERPRETED
AS
AN
INT
SCANNER
METHOD
EXPLANATION
EXAMPLES
NEXTINT
INTEGERS
EXPECTED
NEXTDOUBLE
DOUBLES
EXPECTED
NEXT
ARBITRARY
STRINGS
JAVA
NEXTBOOLEAN
LOGICAL
VALUES
TRUE
FALSE
SCANNER
ATTACHES
SOURCE
OF
INPUT
NEW
SCANNER
SYSTEM
IN
A
METHOD
IS
A
GROUP
OF
INSTRUCTIONS
HAVING
A
NAME
IN
THE
PROGRAMS
INTRODUCED
SO
FAR
WE
VE
DEFINED
A
SINGLE
METHOD
CALLED
MAIN
IN
ADDITION
WE
VE
USED
SOME
METHODS
FROM
OTHER
CLASSES
THAT
WERE
STANDARD
JAVA
CLASSES
THE
METHODS
HAVE
NAMES
WHICH
MAKES
IT
POSSIBLE
FOR
YOU
TO
REQUEST
THE
COMPUTER
TO
PERFORM
THE
INSTRUCTIONS
THAT
COMPRISE
THE
METHOD
THAT
WHAT
WE
RE
DOING
BY
USING
THE
EXPRESSION
SYSTEM
OUT
PRINTLN
HELLO
WORLD
WE
RE
CALLING
A
METHOD
WITH
THE
NAME
PRINTLN
AND
ASKING
THAT
THE
INSTRUC
TIONS
BE
EXECUTED
JUST
AS
TWO
PEOPLE
CAN
HAVE
THE
SAME
NAME
TWO
METHODS
CAN
HAVE
THE
SAME
NAME
WE
MUST
THEREFORE
IN
GENERAL
TELL
JAVA
WHERE
TO
LOOK
FOR
THE
METHOD
USING
SYSTEM
OUT
TELLS
JAVA
THAT
WE
RE
INTERESTED
IN
THE
PRINTLN
METHOD
ASSOCIATED
WITH
THE
OBJECT
IDENTIFIED
BY
SYSTEM
OUT
WE
MUST
STILL
POSTPONE
A
FULL
EXPLANATION
OF
THE
MEANING
OF
SYSTEM
OUT
AS
WE
HAVE
SHOWN
THE
SAME
METHOD
CAN
BE
CALLED
SEVERAL
TIMES
IN
ONE
PROGRAM
IN
SIMPLEINPUT
WE
CALLED
THE
METHOD
PRINTLN
TWICE
FOR
MANY
METHODS
WE
NEED
TO
PROVIDE
SOME
DATA
VALUES
IN
ORDER
FOR
THE
METHOD
TO
PERFORM
ITS
JOB
THESE
VALUES
ARE
PROVIDED
TO
THE
METHOD
BY
PLACING
THEM
BETWEEN
PARENTHESES
FOLLOWING
THE
NAME
OF
THE
METHOD
THESE
VALUES
ARE
CALLED
THE
PARAMETERS
OF
THE
METHOD
AND
WE
SAY
THAT
WE
ARE
PASSING
THE
PARAMETERS
TO
THE
METHOD
THE
PRINTLN
METHOD
REQUIRES
ONE
PARAMETER
WHICH
IS
THE
VALUE
TO
BE
PRINTED
AS
WE
INDICATED
PREVIOUSLY
THIS
PARAMETER
CAN
BE
EITHER
A
STRING
OR
A
NUMERIC
VALUE
IN
THE
LATTER
CASE
THE
NUMERIC
VALUE
WILL
BE
CONVERTED
BY
THE
PRINTLN
METHOD
TO
A
STRING
AND
THEN
PRINTED
IF
MORE
THAN
ONE
PARAMETER
IS
REQUIRED
WE
SEPARATE
THE
PARAMETER
VALUES
BY
COMMAS
FOR
EXAMPLE
THE
PREDEFINED
METHOD
MATH
MIN
IS
USED
TO
DETERMINE
THE
MINIMUM
OF
TWO
NUMBERS
THE
FOLLOWING
PROGRAM
FRAGMENT
WILL
PRINT
OUT
INT
NUMBERONE
NUMBERTWO
SMALLEST
SMALLEST
MATH
MIN
NUMBERONE
NUMBERTWO
SYSTEM
OUT
PRINTLN
SMALLEST
THE
METHOD
MIN
IS
CONTAINED
IN
THE
STANDARD
JAVA
CLASS
MATH
WHICH
INCLUDES
OTHER
COMMON
MATHEMATICAL
FUNCTIONS
SUCH
AS
MATH
SQRT
THAT
IS
USED
TO
FIND
THE
SQUARE
ROOT
OF
A
NUMBER
HERE
ARE
SOME
OF
THE
PREDEFINED
METHODS
THAT
WE
VE
MENTIONED
SO
FAR
SYSTEM
OUT
PRINT
X
PRINT
THE
VALUE
OF
X
SYSTEM
OUT
PRINTLN
X
PRINT
THE
VALUE
OF
X
FOLLOWED
BY
A
NEWLINE
SCAN
NEXTINT
GET
AN
INT
FROM
THE
KEYBOARD
MATH
MIN
X
Y
FIND
THE
SMALLER
OF
X
AND
Y
MATH
SQRT
X
FIND
THE
SQUARE
ROOT
OF
X
CONCAT
CONCATENATE
THE
STRINGS
AND
WORD
LENGTH
FIND
THE
LENGTH
OF
THE
STRING
WORD
JAVA
INCLUDES
A
RICH
SET
OF
MANY
MORE
PREDEFINED
METHODS
THEY
INCLUDE
METHODS
FOR
THE
MOST
COMMON
MATHEMATICAL
FUNCTIONS
SEE
APPENDIX
B
REFERENCE
TABLES
FOR
CREATING
GRAPHICAL
USER
INTERFACES
SEE
CHAP
TER
GRAPHICAL
USER
INTERFACES
PART
I
AND
CHAPTER
GRAPHICAL
USER
INTERFACES
PART
II
FOR
READING
AND
WRIT
ING
INFORMATION
FROM
AND
TO
FILES
SEE
CHAPTER
READING
AND
WRITING
FILES
FOR
COMMUNICATING
WITH
PROGRAMS
ON
OTHER
COMPUTERS
USING
A
NETWORK
SEE
CHAPTER
THREADS
CONCURRENT
PROGRAMMING
AND
MANY
MORE
AN
IMPORTANT
ASPECT
OF
JAVA
IS
THE
ABILITY
TO
USE
PARTS
OF
PROGRAMS
CREATED
BY
OTHERS
THE
PRINT
AND
PRINTLN
METHODS
CAN
PRINT
ALL
THE
PRIMITIVE
TYPES
THE
METHOD
SYSTEM
OUT
PRINTLN
IS
A
CONVENIENT
VARIANT
OF
SYSTEM
OUT
PRINT
WHICH
APPENDS
A
NEWLINE
TO
THE
END
OF
THE
OUTPUT
YOU
CAN
ALWAYS
ACHIEVE
THE
SAME
EFFECT
BY
ADDING
N
TO
THE
END
OF
WHAT
IS
BEING
PRINTED
FOR
EXAMPLE
THE
FOLLOWING
TWO
LINES
ARE
EQUIVALENT
SYSTEM
OUT
PRINT
HELLO
WORLD
N
SYSTEM
OUT
PRINTLN
HELLO
WORLD
RECALL
HOWEVER
THAT
YOU
CAN
T
PUT
A
AN
ACTUAL
NEWLINE
IN
THE
MIDDLE
OF
A
STRING
SO
THE
FOLLOWING
WOULD
NOT
BE
LEGAL
SYSTEM
OUT
PRINTLN
TYPE
TWO
INTEGERS
FOR
THE
WIDTH
AND
HEIGHT
OF
A
BOX
IN
THE
SAME
WAY
THAT
YOU
CAN
COMBINE
TWO
STRINGS
WITH
THE
STRING
CONCATENATION
OPERATOR
YOU
CAN
ALSO
COM
BINE
ONE
STRING
AND
ONE
VALUE
OF
ANY
OTHER
TYPE
IN
THIS
CASE
THE
NONSTRING
OPERAND
IS
FIRST
CONVERTED
INTO
A
NEW
STRING
AND
THEN
THE
TWO
STRINGS
ARE
CONCATENATED
THIS
ALLOWS
REWRITING
THE
PRINTING
OF
THE
RESULT
IN
AREA
FROM
SECTION
USER
INPUT
ON
PAGE
IN
THE
FORM
SYSTEM
OUT
PRINTLN
THE
AREA
IS
AREA
THIS
VERSION
EMPHASIZES
THAT
ONE
MESSAGE
WILL
APPEAR
ON
A
SINGLE
LINE
OF
THE
OUTPUT
THE
DOUBLE
VALUE
AREA
IS
FIRST
CONVERTED
TO
A
STRING
AND
THEN
COMBINED
WITH
THE
OTHER
STRING
USING
STRING
CONCATENATION
WHAT
ABOUT
THE
OPPOSITE
WHAT
IF
YOU
WANTED
TO
HAVE
AN
OUTPUT
MESSAGE
THAT
SPANNED
SEVERAL
OUTPUT
LINES
BUT
WITH
A
SINGLE
PRINTLN
YOU
CAN
DO
SO
BY
PUTTING
THE
SYMBOLS
N
IN
A
STRING
LITERAL
TO
REPRESENT
NEW
LINES
WITHIN
THE
STRING
SUCH
A
STRING
WILL
PRINT
ON
MORE
THAN
ONE
OUTPUT
LINE
THUS
FOR
SYSTEM
OUT
PRINTLN
ONE
NWORD
NPER
NLINE
THE
OUTPUT
IS
THE
PAIR
OF
SYMBOLS
N
WHEN
USED
IN
A
STRING
LITERAL
MEAN
TO
PUT
A
NEWLINE
AT
THIS
POINT
IN
THE
STRING
THIS
ESCAPE
SEQUENCE
ALLOWS
YOU
TO
ESCAPE
FROM
THE
NORMAL
MEANING
OF
THE
SYMBOLS
AND
N
WHEN
USED
SEPA
RATELY
YOU
CAN
FIND
OUT
MORE
ABOUT
ESCAPE
SEQUENCES
IN
SECTION
THE
CHAR
TYPE
ON
PAGE
CARE
MUST
BE
TAKEN
WHEN
YOU
RE
USING
STRING
CONCATENATION
TO
COMBINE
SEVERAL
NUMBERS
SOMETIMES
PAREN
THESES
ARE
NECESSARY
TO
BE
SURE
THAT
THE
IS
INTERPRETED
AS
STRING
CONCATENATION
NOT
NUMERIC
ADDITION
FOR
INT
X
Y
SYSTEM
OUT
PRINTLN
X
Y
X
Y
THE
OUTPUT
IS
X
Y
BECAUSE
THE
STRING
X
Y
IS
FIRST
CONCATENATED
WITH
THE
STRING
AND
THEN
IS
CONCATENATED
ONTO
THE
END
OF
THE
STRING
X
Y
TO
PRINT
X
Y
YOU
SHOULD
USE
PARENTHESES
FIRST
TO
FORCE
THE
ADDITION
OF
X
AND
Y
AS
INTEGERS
AND
THEN
CONCATENATE
THE
STRING
REPRESENTATION
OF
THE
RESULT
WITH
THE
INITIAL
STRING
AS
IN
SYSTEM
OUT
PRINTLN
X
Y
X
Y
FORMATTING
OUTPUT
WITH
PRINTF
THE
METHOD
PRINTF
WAS
INTRODUCED
IN
JAVA
IT
PROVIDES
FORMATTED
OUTPUT
AS
IS
DONE
IN
C
THE
PRINTF
METHOD
IS
PASSED
A
LIST
OF
ARGUMENTS
THAT
CAN
BE
THOUGHT
OF
AS
AND
WHERE
IS
A
STRING
AND
MAY
CONTAIN
CONVERSION
SPECIFICATIONS
OR
FORMATS
A
CONVERSION
SPECIFI
CATION
BEGINS
WITH
A
CHARACTER
AND
ENDS
WITH
A
CONVERSION
CHARACTER
FOR
EXAMPLE
IN
THE
FORMAT
THE
LET
TER
IS
THE
CONVERSION
CHARACTER
PRINTF
ABC
THE
FORMAT
CAUSES
THE
ARGUMENT
ABC
TO
BE
PRINTED
IN
THE
FORMAT
OF
A
STRING
YET
ANOTHER
WAY
TO
DO
THIS
IS
WITH
THE
STATEMENT
PRINTF
C
C
C
A
B
C
SINGLE
QUOTES
ARE
USED
TO
DESIGNATE
CHARACTER
CONSTANTS
THUS
A
IS
THE
CHARACTER
CONSTANT
CORRESPONDING
TO
THE
LOWERCASE
LETTER
A
THE
FORMAT
C
PRINTS
THE
VALUE
OF
AN
EXPRESSION
AS
A
CHARACTER
NOTICE
THAT
A
CON
STANT
BY
ITSELF
IS
CONSIDERED
AN
EXPRESSION
PRINTF
CONVERSION
CHARACTERS
CONVERSION
CHARACTER
HOW
THE
CORRESPONDING
ARGUMENT
IS
PRINTED
C
AS
A
CHARACTER
D
AS
A
DECIMAL
INTEGER
E
AS
A
FLOATING
POINT
NUMBER
IN
SCIENTIFIC
NOTA
TION
F
AS
A
FLOATING
POINT
NUMBER
G
IN
THE
E
FORMAT
OR
F
FORMAT
WHICHEVER
IS
SHORTER
AS
A
STRING
WHEN
AN
ARGUMENT
IS
PRINTED
THE
PLACE
WHERE
IT
IS
PRINTED
IS
CALLED
ITS
FIELD
AND
THE
NUMBER
OF
CHAR
ACTERS
IN
ITS
FIELD
IS
CALLED
ITS
FIELD
WIDTH
THE
FIELD
WIDTH
AND
A
PRECISION
SPECIFIER
CAN
BE
SPECIFIED
IN
A
FORMAT
AS
TWO
INTEGERS
SEPARATED
BY
A
DOT
OCCURRING
BETWEEN
THE
AND
THE
CONVERSION
CHARACTER
THUS
THE
STATEMENT
PRINTF
AIRFARE
IS
NPARKING
IS
N
SPECIFIES
THAT
THE
TWO
NUMBERS
SHOULD
BE
PRINTED
IN
A
FIELD
OF
CHARACTERS
WITH
TWO
DIGITS
THE
PRECISION
TO
THE
RIGHT
OF
THE
DECIMAL
POINT
IT
WILL
PRINT
WE
WILL
EXPLAIN
THE
VARIOUS
DETAILED
CONVENTIONS
FOR
USING
FORMATS
IN
CHAPTER
ON
PAGE
THERE
ARE
TWO
BASIC
REPRESENTATIONS
FOR
NUMBERS
IN
MOST
MODERN
PROGRAMMING
LANGUAGES
INTEGER
REPRESEN
TATIONS
AND
FLOATING
POINT
REPRESENTATIONS
THE
INTEGER
TYPES
ARE
USED
TO
REPRESENT
INTEGERS
OR
WHOLE
NUM
BERS
THE
FLOATING
POINT
TYPES
ARE
USED
TO
REPRESENT
NUMBERS
THAT
CONTAIN
FRACTIONAL
PARTS
OR
FOR
NUMBERS
WHOSE
MAGNITUDE
EXCEEDS
THE
CAPACITY
OF
THE
INTEGER
TYPES
THE
INTEGER
TYPES
A
BIT
IS
THE
SMALLEST
UNIT
OF
INFORMATION
THAT
CAN
BE
STORED
IN
A
COMPUTER
IT
CAN
REPRESENT
ONLY
TWO
VALUES
SUCH
AS
OR
ON
OFF
OR
TRUE
FALSE
A
SEQUENCE
OF
BITS
CAN
BE
USED
TO
REPRESENT
A
LARGER
RANGE
OF
VALUES
FOR
THE
INTEGER
TYPES
THE
BITS
ARE
INTERPRETED
WITH
THE
BINARY
NUMBER
SYSTEM
THE
BINARY
NUMBER
SYSTEM
HAS
ONLY
TWO
DIGITS
AND
THESE
TWO
DIGITS
CAN
BE
COMBINED
TO
REPRESENT
ANY
NUMBER
IN
THE
SAME
WAY
THAT
THE
DIGITS
OF
THE
NORMAL
DECIMAL
NUMBER
SYSTEM
CAN
BE
COMBINED
TO
FORM
ANY
NUMBER
SEE
APPENDIX
A
GET
TING
DOWN
TO
THE
BITS
SOME
MECHANISM
IS
NEEDED
TO
REPRESENT
POSITIVE
AND
NEGATIVE
NUMBERS
ONE
SIMPLE
SOLUTION
WOULD
BE
TO
SET
ASIDE
ONE
BIT
TO
REPRESENT
THE
SIGN
OF
THE
NUMBER
HOWEVER
THIS
RESULTS
IN
TWO
DIFFERENT
REPRESENTATIONS
OF
ZERO
AND
WHICH
CAUSES
PROBLEMS
FOR
COMPUTER
ARITHMETIC
THEREFORE
AN
ALTERNATIVE
SYSTEM
CALLED
TWO
COMPLEMENT
IS
USED
AN
BIT
VALUE
CALLED
A
BYTE
CAN
REPRESENT
DIFFERENT
VALUES
JAVA
SUPPORTS
FIVE
INTEGRAL
NUMERIC
TYPES
THE
TYPE
CHAR
ALTHOUGH
NORMALLY
USED
TO
REPRESENT
SYMBOLIC
CHARACTERS
IN
A
BIT
FORMAT
CALLED
UNICODE
CAN
BE
INTERPRETED
AS
AN
INTEGER
AS
DISCUSSED
SHORTLY
THE
RESULT
OF
COMBINING
A
CHAR
VALUE
WITH
ANOTHER
NUMERIC
VALUE
WILL
NEVER
BE
OF
TYPE
CHAR
THE
CHAR
VALUE
IS
FIRST
CONVERTED
TO
ONE
OF
THE
OTHER
NUMERIC
TYPES
THESE
TYPES
ARE
SUMMARIZED
IN
THE
FOLLOWING
TABLE
TYPE
NUMBER
OF
BITS
RANGE
OF
VALUES
BYTE
TO
SHORT
TO
CHAR
TO
INT
TO
LONG
TO
THE
ASYMMETRY
IN
THE
MOST
NEGATIVE
VALUE
AND
THE
MOST
POSITIVE
VALUE
OF
THE
INTEGER
TYPES
RESULTS
FROM
THE
TWO
COMPLEMENT
SYSTEM
USED
IN
JAVA
TO
REPRESENT
NEGATIVE
VALUES
LITERAL
INTEGER
VALUES
ARE
REPRESENTED
BY
A
SEQUENCE
OF
DIGITS
POSSIBLY
PRECEDED
BY
A
MINUS
SIGN
AN
INTEGER
LITERAL
IS
EITHER
AN
INT
OR
LONG
AN
EXPLICIT
CONVERSION
CALLED
A
CAST
OF
AN
INT
LITERAL
MUST
BE
USED
TO
ASSIGN
THEM
TO
THE
SMALLER
INTEGER
TYPES
SHORT
AND
BYTE
SEE
SECTION
TYPE
CONVERSION
ON
PAGE
INTEGER
LITERALS
CAN
BE
EXPRESSED
IN
BASE
DECIMAL
BASE
OCTAL
AND
BASE
HEXADECIMAL
NUMBER
SYSTEMS
DECIMAL
LITERALS
BEGIN
WITH
A
DIGIT
OCTAL
LITERALS
BEGIN
WITH
THE
DIGIT
AND
HEXADECIMAL
LITERALS
BEGIN
WITH
THE
TWO
CHARACTER
SEQUENCE
TO
SPECIFY
A
LONG
LITERAL
INSTEAD
OF
AN
INT
LITERAL
APPEND
THE
LETTER
EL
UPPERCASE
OR
LOWERCASE
TO
THE
SEQUENCE
OF
DIGITS
HERE
ARE
SOME
EXAMPLES
THE
DECIMAL
VALUE
TWO
HUNDRED
SEVENTEEN
AN
OCTAL
NUMBER
EQUIVALENT
TO
IN
THE
DECIMAL
SYSTEM
WOULD
BE
ILLEGAL
BECAUSE
IS
NOT
A
VALID
OCTAL
DIGIT
ONLY
ARE
OCTAL
DIGITS
A
HEXADECIMAL
NUMBER
EQUIVALENT
TO
IN
THE
DECIMAL
SYSTEM
THE
HEXADECIMAL
DIGITS
INCLUDE
PLUS
A
B
C
D
E
AND
F
A
LONG
DECIMAL
LITERAL
WITHOUT
THE
L
THIS
WOULD
BE
AN
ERROR
BECAUSE
IS
TOO
LARGE
TO
STORE
IN
THE
BITS
OF
AN
INT
TYPE
INTEGER
THE
FLOATING
POINT
TYPES
JAVA
SUPPORTS
TWO
FLOATING
POINT
NUMERIC
TYPES
A
FLOATING
POINT
NUMBER
CONSISTS
OF
THREE
PARTS
A
SIGN
A
MAGNITUDE
AND
AN
EXPONENT
THESE
TWO
TYPES
ARE
SUMMARIZED
IN
THE
FOLLOWING
TABLE
TYPE
NUMBER
OF
BITS
APPROXIMATE
RANGE
OF
VALUES
APPROXIMATE
PRECISION
FLOAT
TO
DECIMAL
DIGITS
DOUBLE
TO
DECIMAL
DIGITS
TO
REPRESENT
FLOATING
POINT
LITERALS
YOU
CAN
SIMPLY
INSERT
A
DECIMAL
POINT
INTO
A
SEQUENCE
OF
DIGITS
AS
IN
IF
THE
MAGNITUDE
OF
THE
NUMBER
IS
TOO
LARGE
OR
TOO
SMALL
TO
REPRESENT
IN
THIS
FASHION
THEN
A
NOTA
TION
ANALOGOUS
TO
SCIENTIFIC
NOTATION
IS
USED
THE
LETTER
E
FROM
EXPONENT
IS
USED
TO
INDICATE
THE
EXPONENT
OF
AS
SHOWN
IN
THE
FOLLOWING
EXAMPLES
JAVA
REPRESENTATION
VALUE
X
X
UNLESS
SPECIFIED
OTHERWISE
A
FLOATING
POINT
LITERAL
IS
OF
TYPE
DOUBLE
TO
SPECIFY
A
FLOATING
POINT
LITERAL
OF
TYPE
FLOAT
APPEND
EITHER
F
OR
F
TO
THE
LITERAL
FOR
EXAMPLE
THE
CHAR
TYPE
JAVA
PROVIDES
CHAR
VARIABLES
TO
REPRESENT
AND
MANIPULATE
CHARACTERS
THIS
TYPE
IS
AN
INTEGER
TYPE
AND
CAN
BE
MIXED
WITH
THE
OTHER
INTEGER
TYPES
EACH
CHAR
IS
STORED
IN
MEMORY
IN
BYTES
THIS
SIZE
IS
LARGE
ENOUGH
TO
STORE
THE
INTEGER
VALUES
THROUGH
AS
DISTINCT
CHARACTER
CODES
OR
NONNEGATIVE
INTEGERS
AND
THESE
CODES
ARE
CALLED
UNICODE
UNICODE
USES
MORE
STORAGE
PER
CHARACTER
THAN
PREVIOUS
COMMON
CHARACTER
ENCODINGS
BECAUSE
IT
WAS
DESIGNED
TO
REPRESENT
ALL
THE
WORLD
ALPHABETS
NOT
JUST
ONE
PARTICULAR
ALPHABET
FOR
ENGLISH
A
SUBSET
OF
THESE
VALUES
REPRESENTS
ACTUAL
PRINTING
CHARACTERS
THESE
INCLUDE
THE
LOWERCASE
AND
UPPERCASE
LETTERS
DIGITS
PUNCTUATION
AND
SPECIAL
CHARACTERS
SUCH
AS
AND
THE
CHARACTER
SET
ALSO
INCLUDES
THE
WHITE
SPACE
CHARACTERS
BLANK
TAB
AND
NEWLINE
THIS
IMPORTANT
SUBSET
IS
REPRESENTED
BY
THE
FIRST
CODES
WHICH
ARE
ALSO
KNOWN
AS
THE
ASCII
CODES
EARLIER
LANGUAGES
SUCH
AS
C
AND
C
WORKED
ONLY
WITH
THIS
MORE
LIMITED
SET
OF
CODES
AND
STORED
THEM
IN
BYTE
THE
FOLLOWING
TABLE
ILLUSTRATES
THE
CORRESPONDENCE
BETWEEN
SOME
CHARACTER
LITERALS
AND
INTEGER
VALUES
CHAR
ACTER
LITERALS
ARE
WRITTEN
BY
PLACING
A
SINGLE
CHARACTER
BETWEEN
SINGLE
QUOTES
AS
IN
A
SOME
CHARACTER
CONSTANTS
AND
THEIR
CORRESPONDING
INTEGER
VALUES
CHARACTER
CONSTANTS
A
B
C
Z
CORRESPONDING
VALUES
CHARACTER
CONSTANTS
A
B
C
Z
CORRESPONDING
VALUES
CHARACTER
CONSTANTS
CORRESPONDING
VALUES
CHARACTER
CONSTANTS
CORRESPONDING
VALUES
THERE
IS
NO
PARTICULAR
RELATIONSHIP
BETWEEN
THE
VALUE
OF
THE
CHARACTER
CONSTANT
REPRESENTING
A
DIGIT
AND
THE
DIGIT
INTRINSIC
INTEGER
VALUE
THAT
IS
THE
VALUE
OF
IS
NOT
THE
PROPERTY
THAT
THE
VALUES
FOR
A
B
C
AND
SO
ON
OCCUR
IN
ORDER
IS
IMPORTANT
IT
MAKES
THE
SORTING
OF
CHARACTERS
WORDS
AND
LINES
INTO
LEXICOGRAPHI
CAL
ORDER
CONVENIENT
NOTE
THAT
CHARACTER
LITERALS
ARE
DIFFERENT
FROM
STRING
LITERALS
WHICH
USE
DOUBLE
QUOTES
AS
IN
HELLO
STRING
LITERALS
CAN
BE
ONLY
ONE
CHARACTER
LONG
BUT
THEY
ARE
STILL
STRING
VALUES
NOT
CHAR
VALUES
FOR
EXAMPLE
A
IS
A
STRING
LITERAL
SOME
NONPRINTING
AND
HARD
TO
PRINT
CHARACTERS
REQUIRE
AN
ESCAPE
SEQUENCE
THE
HORIZONTAL
TAB
CHARACTER
FOR
EXAMPLE
IS
WRITTEN
AS
T
IN
CHARACTER
CONSTANTS
AND
IN
STRINGS
EVEN
THOUGH
IT
IS
BEING
DESCRIBED
BY
THE
TWO
CHARACTERS
AND
T
IT
REPRESENTS
A
SINGLE
CHARACTER
THE
BACKSLASH
CHARACTER
IS
CALLED
THE
ESCAPE
CHARACTER
AND
IS
USED
TO
ESCAPE
THE
USUAL
MEANING
OF
THE
CHARACTER
THAT
FOLLOWS
IT
ANOTHER
WAY
TO
WRITE
A
CHARACTER
CONSTANT
IS
BY
MEANS
OF
A
HEXADECIMAL
DIGIT
ESCAPE
SEQUENCE
AS
IN
THIS
IS
THE
ALERT
CHARACTER
OR
THE
AUDIBLE
BELL
THESE
HEXADECIMAL
DIGITS
ARE
PREFIXED
BY
THE
LETTER
U
TO
INDICATE
THEIR
USE
AS
A
UNICODE
LIT
ERAL
THE
UNICODE
CHARACTERS
CAN
BE
WRITTEN
IN
HEXADECIMAL
FORM
FROM
TO
UFFFF
THE
FOLLOWING
TABLE
CONTAINS
SOME
NONPRINTING
AND
HARD
TO
PRINT
CHARACTERS
NAME
OF
CHARACTER
ESCAPE
INT
HEX
BACKSLASH
BACKSPACE
B
CARRIAGE
RETURN
R
DOUBLE
QUOTE
FORMFEED
F
HORIZONTAL
TAB
T
U0009
NEWLINE
N
SINGLE
QUOTE
NULL
CHARACTER
ALERT
THE
ALERT
CHARACTER
IS
SPECIAL
IT
CAUSES
THE
BELL
TO
RING
TO
HEAR
THE
BELL
TRY
EXECUTING
A
PROGRAM
THAT
CONTAINS
THE
LINE
SYSTEM
OUT
PRINT
CHARACTER
VALUES
ARE
SMALL
INTEGERS
AND
CONVERSELY
SMALL
INTEGER
VALUES
CAN
BE
CHARACTERS
CONSIDER
THE
DEC
LARATION
CHAR
C
A
THE
VARIABLE
C
CAN
BE
PRINTED
EITHER
AS
A
CHARACTER
OR
AS
AN
INTEGER
SYSTEM
OUT
PRINTF
C
C
A
IS
PRINTED
SYSTEM
OUT
PRINTF
D
C
IS
PRINTED
NUMBERS
VERSUS
STRINGS
THE
SEQUENCE
OF
AND
INSIDE
A
COMPUTER
USED
TO
STORE
THE
STRING
VALUE
IS
DIFFERENT
FROM
THE
SEQUENCE
OF
AND
USED
TO
STORE
THE
INT
VALUE
WHICH
IS
DIFFERENT
FROM
THE
SEQUENCE
OF
AND
USED
TO
STORE
THE
DOUBLE
VALUE
THE
STRING
FORM
IS
MORE
CONVENIENT
FOR
CERTAIN
TYPES
OF
MANIPULA
TION
SUCH
AS
PRINTING
ON
THE
SCREEN
OR
FOR
COMBINING
WITH
OTHER
STRINGS
THE
INT
FORM
IS
BETTER
FOR
SOME
NUMERIC
CALCULATIONS
AND
THE
DOUBLE
FORM
IS
BETTER
FOR
OTHERS
SO
HOW
DOES
THE
COMPUTER
KNOW
HOW
TO
INTER
PRET
A
PARTICULAR
SEQUENCE
OF
AND
THE
ANSWER
IS
LOOK
AT
THE
TYPE
OF
THE
VARIABLE
USED
TO
STORE
THE
VALUE
THIS
ANSWER
IS
PRECISELY
WHY
YOU
MUST
SPECIFY
A
TYPE
FOR
EACH
VARIABLE
WITHOUT
THE
TYPE
INFORMATION
THE
SEQUENCE
OF
AND
COULD
BE
MISINTERPRETED
WE
DO
SOMETHING
SIMILAR
WITH
WORDS
ALL
THE
TIME
JUST
AS
COMPUTERS
INTERPRET
SEQUENCES
OF
AND
HUMAN
BEINGS
INTERPRET
SEQUENCES
OF
ALPHABETIC
SYMBOLS
HOW
PEOPLE
INTERPRET
THOSE
SYMBOLS
DEPENDS
ON
THE
CON
TEXT
IN
WHICH
THE
SYMBOLS
APPEAR
FOR
EXAMPLE
AT
TIMES
THE
SAME
WORD
CAN
BE
A
NOUN
AND
AT
OTHER
TIMES
IT
CAN
BE
A
VERB
ALSO
CERTAIN
SEQUENCES
OF
LETTERS
MEAN
DIFFERENT
THINGS
IN
DIFFERENT
LANGUAGES
TAKE
THE
WORD
PIE
FOR
EXAMPLE
WHAT
DOES
IT
MEAN
IF
IT
IS
ENGLISH
IT
IS
SOMETHING
GOOD
TO
EAT
IF
IT
IS
SPANISH
IT
MEANS
FOOT
FROM
THE
CONTEXT
OF
THE
SURROUNDING
WORDS
WE
CAN
USUALLY
FIGURE
OUT
WHAT
THE
TYPE
OF
THE
WORD
IS
VERB
OR
NOUN
ENGLISH
OR
SPANISH
SOME
PROGRAMMING
LANGUAGES
DO
SOMETHING
SIMILAR
AND
FIGURE
OUT
THE
TYPE
OF
A
VARIABLE
THESE
PROGRAMMING
LANGUAGES
ARE
GENERALLY
CONSIDERED
TO
BE
MORE
ERROR
PRONE
THAN
LANGUAGES
SUCH
AS
JAVA
WHICH
REQUIRE
THE
PROGRAMMER
TO
SPECIFY
THE
TYPE
OF
EACH
VARIABLE
LANGUAGES
SUCH
AS
JAVA
ARE
CALLED
STRONGLY
TYPED
LANGUAGES
THE
BASIC
ARITHMETIC
OPERATORS
IN
JAVA
ARE
ADDITION
SUBTRACTION
MULTIPLICATION
DIVISION
AND
MODULUS
YOU
CAN
USE
ALL
ARITHMETIC
OPERATORS
WITH
ALL
PRIMITIVE
NUMERIC
TYPES
CHAR
BYTE
SHORT
INT
LONG
FLOAT
AND
DOUBLE
IN
ADDITION
YOU
CAN
COMBINE
ANY
TWO
NUMERIC
TYPES
BY
USING
THESE
OPERATORS
IN
WHAT
IS
KNOWN
AS
MIXED
MODE
ARITHMETIC
ALTHOUGH
YOU
CAN
USE
THE
OPERATORS
WITH
ANY
NUMERIC
TYPE
JAVA
ACTUALLY
DOES
ARITHMETIC
ONLY
WITH
THE
TYPES
INT
LONG
FLOAT
AND
DOUBLE
THEREFORE
THE
FOLLOWING
RULES
ARE
USED
FIRST
TO
CONVERT
BOTH
OPERANDS
INTO
ONE
OF
FOUR
TYPES
IF
EITHER
OPERAND
IS
A
DOUBLE
THEN
THE
OTHER
IS
CONVERTED
TO
DOUBLE
OTHERWISE
IF
EITHER
OPERAND
IS
A
FLOAT
THEN
THE
OTHER
IS
CONVERTED
TO
FLOAT
OTHERWISE
IF
EITHER
OPERAND
IS
A
LONG
THEN
THE
OTHER
IS
CONVERTED
TO
A
LONG
OTHERWISE
BOTH
ARE
CONVERTED
TO
INT
THIS
CONVERSION
IS
CALLED
BINARY
NUMERIC
PROMOTION
AND
IS
ALSO
USED
WITH
THE
BINARY
RELATIONAL
OPERATORS
DIS
CUSSED
IN
SECTION
RELATIONAL
AND
EQUALITY
OPERATORS
ON
PAGE
WHEN
BOTH
OPERANDS
ARE
INTEGER
TYPES
THE
OPERATIONS
OF
ADDITION
SUBTRACTION
AND
MULTIPLICATION
ARE
SELF
EVIDENT
EXCEPT
WHEN
THE
RESULT
IS
TOO
LARGE
TO
BE
REPRESENTED
BY
THE
TYPE
OF
THE
OPERANDS
INTEGER
VALUES
CAN
T
REPRESENT
FRACTIONS
IN
JAVA
INTEGER
DIVISION
TRUNCATES
TOWARD
FOR
EXAMPLE
IS
AND
IS
A
COMMON
MISTAKE
IS
TO
FORGET
THAT
INTEGER
DIVISION
OF
NONZERO
VALUES
CAN
RESULT
IN
TO
OBTAIN
FRACTIONAL
RESULTS
YOU
MUST
FORCE
ONE
OF
THE
OPERANDS
TO
BE
A
FLOATING
POINT
TYPE
IN
EXPRESSIONS
INVOLVING
LITERALS
YOU
CAN
DO
SO
BY
ADDING
A
DECIMAL
POINT
AS
IN
WHICH
RESULTS
IN
THE
FLOATING
POINT
VALUE
IN
ADDITION
INTEGER
DIVISION
BY
ZERO
WILL
RESULT
IN
AN
ERROR
CALLED
AN
ARITHMETICEXCEPTION
AN
EXCEPTION
AS
THE
NAME
IMPLIES
IS
SOMETHING
UNEXPECTED
JAVA
PROVIDES
A
WAY
FOR
YOU
TO
TELL
THE
COMPUTER
AN
INTEGER
ARITHMETIC
EXAMPLE
CHANGE
WHAT
TO
DO
WHEN
EXCEPTIONS
OCCUR
IF
YOU
DON
T
DO
ANYTHING
AND
SUCH
AN
ERROR
OCCURS
THE
PROGRAM
WILL
PRINT
AN
APPROPRIATE
ERROR
MESSAGE
AND
TERMINATE
WE
DISCUSS
EXCEPTIONS
IN
CHAPTER
COPING
WITH
ERRORS
UNLIKE
SOME
PROGRAMMING
LANGUAGES
JAVA
DOESN
T
GENERATE
AN
EXCEPTION
WHEN
INTEGER
ARITHMETIC
RESULTS
IN
A
VALUE
THAT
IS
TOO
LARGE
INSTEAD
THE
EXTRA
BITS
OF
THE
TRUE
RESULT
ARE
LOST
AND
IN
SOME
CASES
POLLUTE
THE
BIT
USED
FOR
THE
SIGN
FOR
EXAMPLE
ADDING
TWO
VERY
LARGE
POSITIVE
NUMBERS
COULD
GENERATE
A
NEGATIVE
RESULT
LIKEWISE
SUBTRACTING
A
VERY
LARGE
POSITIVE
NUMBER
FROM
A
NEGATIVE
NUMBER
COULD
GENERATE
A
POSITIVE
RESULT
IF
VALUES
ARE
EXPECTED
TO
BE
NEAR
THE
LIMIT
FOR
A
PARTICULAR
TYPE
YOU
SHOULD
EITHER
USE
A
LARGER
TYPE
OR
CHECK
THE
RESULT
TO
DETERMINE
WHETHER
SUCH
AN
OVERFLOW
HAS
OCCURRED
WHEN
ONE
OF
THE
OPERANDS
IS
A
FLOATING
POINT
TYPE
BUT
BOTH
OPERANDS
ARE
NOT
OF
THE
SAME
TYPE
ONE
OF
THEM
IS
CONVERTED
TO
THE
OTHER
AS
DESCRIBED
EARLIER
UNLIKE
SOME
PROGRAMMING
LANGUAGES
FLOATING
POINT
ARITHMETIC
OPERATIONS
IN
JAVA
WILL
NEVER
GENERATE
AN
EXCEPTION
INSTEAD
THREE
SPECIAL
VALUES
CAN
RESULT
POSITIVE
INFINITY
NEGATIVE
INFINITY
AND
NOT
A
NUMBER
SEE
APPENDIX
A
GETTING
DOWN
TO
THE
BITS
FOR
MORE
DETAILS
THE
MODULUS
OPERATOR
RETURNS
THE
REMAINDER
FROM
INTEGER
DIVISION
FOR
EXAMPLE
IS
BECAUSE
DIVIDED
BY
IS
WITH
A
REMAINDER
OF
THE
MODULUS
OPERATOR
IS
MOSTLY
USED
WITH
INTEGER
OPERANDS
HOW
EVER
IN
JAVA
IT
CAN
BE
USED
WITH
FLOATING
POINT
OPERANDS
FOR
FLOATING
POINT
VALUES
X
Y
IS
N
WHERE
N
IS
THE
LARGEST
INTEGER
SUCH
THAT
Y
N
IS
LESS
THAN
OR
EQUAL
TO
X
AN
INTEGER
ARITHMETIC
EXAMPLE
CHANGE
THE
COMPUTATION
IN
SECTION
IMPLEMENTING
OUR
ALGORITHM
IN
JAVA
ON
PAGE
WHEREBY
WE
MADE
CHANGE
FOR
A
DOLLAR
IS
A
PERFECT
ILLUSTRATION
OF
THE
USE
OF
THE
TWO
INTEGER
DIVISION
OPERATORS
AND
MAKECHANGE
JAVA
CHANGE
IN
DIMES
AND
PENNIES
IMPORT
JAVA
UTIL
CLASS
MAKECHANGE
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
PRICE
CHANGE
DIMES
PENNIES
SCANNER
SCAN
NEW
SCANNER
SYSTEM
IN
SYSTEM
OUT
PRINTLN
TYPE
PRICE
TO
PRICE
SCAN
NEXTINT
CHANGE
PRICE
HOW
MUCH
CHANGE
DIMES
CHANGE
NUMBER
OF
DIMES
PENNIES
CHANGE
NUMBER
OF
PENNIES
SYSTEM
OUT
PRINT
THE
CHANGE
IS
SYSTEM
OUT
PRINTLN
DIMES
DIMES
PENNIES
PENNIES
TYPE
CONVERSION
YOU
MAY
WANT
OR
NEED
TO
CONVERT
FROM
ONE
PRIMITIVE
NUMERIC
TYPE
TO
ANOTHER
AS
MENTIONED
IN
THE
PRECEDING
SECTION
JAVA
WILL
SOMETIMES
AUTOMATICALLY
CONVERT
THE
OPERANDS
OF
A
NUMERIC
OPERATOR
THESE
AUTOMATIC
CON
VERSIONS
ARE
ALSO
CALLED
WIDENING
PRIMITIVE
CONVERSIONS
THESE
CONVERSIONS
ALWAYS
CONVERT
TO
A
TYPE
THAT
REQUIRES
AT
LEAST
AS
MANY
BITS
AS
THE
TYPE
BEING
CONVERTED
HENCE
THE
TERM
WIDENING
IN
MOST
BUT
NOT
ALL
CASES
A
WIDENING
PRIMITIVE
CONVERSION
DOESN
T
RESULT
IN
ANY
LOSS
OF
INFORMATION
AN
EXAMPLE
OF
A
WIDENING
PRIMI
TIVE
CONVERSION
THAT
CAN
LOSE
SOME
PRECISION
IS
THE
CONVERSION
OF
THE
INT
VALUE
TO
A
FLOAT
VALUE
WHICH
RESULTS
IN
TO
UNDERSTAND
THIS
LOSS
OF
INFORMATION
SEE
APPENDIX
A
GETTING
DOWN
TO
THE
BITS
THE
FOLLOWING
ARE
THE
POSSIBLE
WIDENING
PRIMITIVE
CONVERSIONS
FROM
TO
BYTE
SHORT
INT
LONG
FLOAT
OR
DOUBLE
SHORT
INT
LONG
FLOAT
OR
DOUBLE
CHAR
INT
LONG
FLOAT
OR
DOUBLE
INT
LONG
FLOAT
OR
DOUBLE
LONG
FLOAT
OR
DOUBLE
FLOAT
DOUBLE
IN
ADDITION
TO
PERFORMING
WIDENING
CONVERSIONS
AUTOMATICALLY
AS
PART
OF
MIXED
MODE
ARITHMETIC
WIDENING
PRIMITIVE
CONVERSIONS
ARE
ALSO
USED
TO
CONVERT
AUTOMATICALLY
THE
RIGHT
HAND
SIDE
OF
AN
ASSIGNMENT
OPERATOR
TO
THE
TYPE
OF
THE
VARIABLE
ON
THE
LEFT
FOR
EXAMPLE
THE
FOLLOWING
ASSIGNMENT
WILL
AUTOMATICALLY
CONVERT
THE
INTEGER
RESULT
TO
A
FLOATING
POINT
VALUE
INT
X
Y
FLOAT
Z
Z
X
Y
AUTOMATIC
WIDENING
FROM
INT
TO
FLOAT
A
NARROWING
PRIMITIVE
CONVERSION
IS
A
CONVERSION
BETWEEN
PRIMITIVE
NUMERIC
TYPES
THAT
MAY
RESULT
IN
SIGNIFI
CANT
INFORMATION
LOSS
THE
FOLLOWING
ARE
NARROWING
PRIMITIVE
CONVERSIONS
TYPE
CONVERSION
FROM
TO
BYTE
CHAR
SHORT
BYTE
OR
CHAR
CHAR
BYTE
OR
SHORT
INT
BYTE
SHORT
OR
CHAR
LONG
BYTE
SHORT
CHAR
OR
INT
FLOAT
BYTE
SHORT
CHAR
INT
OR
LONG
DOUBLE
BYTE
SHORT
CHAR
INT
LONG
OR
FLOAT
NARROWING
PRIMITIVE
CONVERSIONS
GENERALLY
RESULT
ONLY
FROM
AN
EXPLICIT
TYPE
CONVERSION
CALLED
A
CAST
A
CAST
IS
WRITTEN
AS
TYPE
EXPRESSION
WHERE
THE
EXPRESSION
TO
BE
CONVERTED
IS
PRECEDED
BY
THE
NEW
TYPE
IN
PARENTHE
SES
A
CAST
IS
AN
OPERATOR
AND
AS
THE
TABLE
IN
SECTION
PRECEDENCE
AND
ASSOCIATIVITY
OF
OPERATORS
ON
PAGE
INDICATES
HAS
HIGHER
PRECEDENCE
THAN
THE
FIVE
BASIC
ARITHMETIC
OPERATORS
FOR
EXAMPLE
IF
YOU
ARE
INTER
ESTED
ONLY
IN
THE
INTEGER
PORTION
OF
THE
FLOATING
POINT
VARIABLE
SOMEFLOAT
THEN
YOU
CAN
STORE
IT
IN
SOME
INTEGER
AS
IN
INT
SOMEINTEGER
FLOAT
SOMEFLOAT
SOMEINTEGER
INT
SOMEFLOAT
SYSTEM
OUT
PRINTLN
SOMEINTEGER
THE
OUTPUT
IS
IF
THE
CAST
IS
BETWEEN
TWO
INTEGRAL
TYPES
THE
MOST
SIGNIFICANT
BITS
ARE
SIMPLY
DISCARDED
IN
ORDER
TO
FIT
THE
RESULTING
FORMAT
THIS
DISCARDING
CAN
CAUSE
THE
RESULT
TO
HAVE
A
DIFFERENT
SIGN
FROM
THE
ORIGINAL
VALUE
THE
FOL
LOWING
EXAMPLE
SHOWS
HOW
A
NARROWING
CONVERSION
CAN
CAUSE
A
CHANGE
OF
SIGN
INT
I
J
BYTE
IASBYTE
BYTE
I
JASBYTE
BYTE
J
SYSTEM
OUT
PRINTLN
IASBYTE
SYSTEM
OUT
PRINTLN
JASBYTE
THE
OUTPUT
IS
THE
LARGEST
POSITIVE
VALUE
THAT
CAN
BE
STORED
IN
A
BYTE
IS
ATTEMPTING
TO
FORCE
A
NARROWING
CONVERSION
ON
A
VALUE
GREATER
THAN
WILL
RESULT
IN
THE
LOSS
OF
SIGNIFICANT
INFORMATION
IN
THIS
CASE
THE
SIGN
IS
REVERSED
TO
UNDERSTAND
EXACTLY
WHAT
HAPPENS
IN
THIS
EXAMPLE
SEE
APPENDIX
A
TO
CHANGE
THE
VALUE
OF
A
VARIABLE
WE
HAVE
ALREADY
MADE
USE
OF
ASSIGNMENT
STATEMENTS
SUCH
AS
A
B
C
ASSIGNMENT
IS
AN
OPERATOR
AND
ITS
PRECEDENCE
IS
LOWER
THAN
ALL
THE
OPERATORS
WE
VE
DISCUSSED
SO
FAR
THE
ASSOCIATIVITY
FOR
THE
ASSIGNMENT
OPERATOR
IS
RIGHT
TO
LEFT
IN
THIS
SECTION
WE
EXPLAIN
IN
DETAIL
ITS
SIGNIFICANCE
TO
UNDERSTAND
AS
AN
OPERATOR
LET
FIRST
CONSIDER
FOR
THE
SAKE
OF
COMPARISON
THE
BINARY
OPERATOR
TAKES
TWO
OPERANDS
AS
IN
THE
EXPRESSION
A
B
THE
VALUE
OF
THE
EXPRESSION
IS
THE
SUM
OF
THE
VALUES
OF
A
AND
B
BY
COMPARISON
A
SIMPLE
ASSIGNMENT
EXPRESSION
IS
OF
THE
FORM
VARIABLE
RIGHTHANDSIDE
WHERE
RIGHTHANDSIDE
IS
ITSELF
AN
EXPRESSION
A
SEMICOLON
PLACED
AT
THE
END
WOULD
MAKE
THIS
AN
ASSIGNMENT
STATEMENT
THE
ASSIGNMENT
OPERATOR
HAS
THE
TWO
OPERANDS
VARIABLE
AND
RIGHTHANDSIDE
THE
VALUE
OF
RIGHT
HANDSIDE
IS
ASSIGNED
TO
VARIABLE
AND
THAT
VALUE
BECOMES
THE
VALUE
OF
THE
ASSIGNMENT
EXPRESSION
AS
A
WHOLE
TO
ILLUSTRATE
LET
CONSIDER
THE
STATEMENTS
B
C
A
B
C
WHERE
THE
VARIABLES
ARE
ALL
OF
TYPE
INT
BY
MAKING
USE
OF
ASSIGNMENT
EXPRESSIONS
WE
CAN
CONDENSE
THESE
STATEMENTS
TO
A
B
C
THE
ASSIGNMENT
EXPRESSION
B
ASSIGNS
THE
VALUE
TO
THE
VARIABLE
B
AND
THE
ASSIGNMENT
EXPRESSION
ITSELF
TAKES
ON
THIS
VALUE
SIMILARLY
THE
ASSIGNMENT
EXPRESSION
C
ASSIGNS
THE
VALUE
TO
THE
VARIABLE
C
AND
THE
ASSIGNMENT
EXPRESSION
ITSELF
TAKES
ON
THIS
VALUE
FINALLY
THE
VALUES
OF
THE
TWO
ASSIGNMENT
EXPRESSIONS
ARE
ADDED
AND
THE
RESULTING
VALUE
IS
ASSIGNED
TO
A
ALTHOUGH
THIS
EXAMPLE
IS
ARTIFICIAL
IN
MANY
SITUATIONS
ASSIGNMENT
OCCURS
NATURALLY
AS
PART
OF
AN
EXPRESSION
A
FREQUENTLY
OCCURRING
SITUATION
IS
MULTIPLE
ASSIGNMENT
CONSIDER
THE
STATEMENT
ASSIGNMENT
OPERATORS
A
B
C
BECAUSE
THE
OPERATOR
ASSOCIATES
FROM
RIGHT
TO
LEFT
AN
EQUIVALENT
STATEMENT
IS
A
B
C
FIRST
C
IS
ASSIGNED
THE
VALUE
AND
THE
EXPRESSION
C
HAS
VALUE
THEN
B
IS
ASSIGNED
THE
VALUE
AND
THE
EXPRESSION
B
C
HAS
VALUE
FINALLY
A
IS
ASSIGNED
THE
VALUE
AND
THE
EXPRESSION
A
B
C
HAS
VALUE
IN
ADDITION
TO
THERE
ARE
OTHER
ASSIGNMENT
OPERATORS
SUCH
AS
AND
AN
EXPRESSION
SUCH
AS
K
K
WILL
ADD
TO
THE
OLD
VALUE
OF
K
AND
ASSIGN
THE
RESULT
TO
K
AND
THE
EXPRESSION
AS
A
WHOLE
WILL
HAVE
THAT
VALUE
THE
EXPRESSION
K
ACCOMPLISHES
THE
SAME
TASK
THE
FOLLOWING
LIST
CONTAINS
ALL
THE
ASSIGNMENT
OPERATORS
ASSIGNMENT
OPERATORS
ALL
THESE
OPERATORS
HAVE
THE
SAME
PRECEDENCE
AND
ALL
HAVE
RIGHT
TO
LEFT
ASSOCIATIVITY
THE
MEANING
IS
SPECI
FIED
BY
VARIABLE
OP
EXPRESSION
WHICH
IS
EQUIVALENT
TO
VARIABLE
VARIABLE
OP
EXPRESSION
WITH
THE
EXCEPTION
THAT
IF
VARIABLE
IS
ITSELF
AN
EXPRESSION
IT
IS
EVALUATED
ONLY
ONCE
NOTE
CAREFULLY
THAT
AN
ASSIGNMENT
EXPRESSION
SUCH
AS
J
K
IS
EQUIVALENT
TO
J
J
K
RATHER
THAN
J
J
K
THE
FOLLOWING
TABLE
ILLUSTRATES
HOW
ASSIGNMENT
EXPRESSIONS
ARE
EVALUATED
DECLARATIONS
AND
INITIALIZATIONS
INT
I
J
K
M
EXPRESSION
EQUIVALENT
EXPRESSION
EQUIVALENT
EXPRESSION
VALUE
I
J
K
J
K
M
I
J
K
J
K
M
I
I
J
K
J
J
K
M
THE
INCREMENT
AND
DECREMENT
OPERATORS
COMPUTERS
ARE
VERY
GOOD
AT
COUNTING
AS
A
RESULT
MANY
PROGRAMS
INVOLVE
HAVING
AN
INTEGER
VARIABLE
THAT
TAKES
ON
THE
VALUES
ONE
WAY
TO
ADD
TO
A
VARIABLE
IS
I
I
WHICH
CHANGES
THE
VALUE
STORED
IN
THE
VARIABLE
I
TO
BE
MORE
THAN
IT
WAS
BEFORE
THIS
STATEMENT
WAS
EXECUTED
THIS
PROCEDURE
IS
CALLED
INCREMENTING
A
VARIABLE
BECAUSE
IT
IS
SO
COMMON
JAVA
LIKE
ITS
PREDECESSOR
C
INCLUDES
A
SHORTHAND
NOTATION
FOR
INCREMENTING
A
VARIABLE
THE
FOLLOWING
STATEMENT
GIVES
THE
IDENTICAL
RESULT
I
THE
OPERATOR
IS
KNOWN
AS
THE
INCREMENT
OPERATOR
SIMILARLY
THERE
IS
A
DECREMENT
OPERATOR
SO
THAT
THE
FOLLOWING
TWO
STATEMENTS
ARE
EQUIVALENT
I
I
I
HERE
IS
A
SIMPLE
PROGRAM
THAT
DEMONSTRATES
THE
INCREMENT
OPERATOR
INCREMENT
JAVA
DEMONSTRATE
INCREMENTING
CLASS
INCREMENT
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
I
SYSTEM
OUT
PRINTLN
I
I
I
I
SYSTEM
OUT
PRINTLN
I
I
I
SYSTEM
OUT
PRINTLN
I
I
I
SYSTEM
OUT
PRINTLN
I
I
THE
OUTPUT
OF
THIS
PROGRAM
IS
NOTE
THAT
BOTH
INCREMENT
AND
DECREMENT
OPERATORS
ARE
PLACED
AFTER
THE
VARIABLE
TO
BE
INCREMENTED
WHEN
PLACED
AFTER
ITS
ARGUMENT
THEY
ARE
CALLED
THE
POSTFIX
INCREMENT
AND
POSTFIX
DECREMENT
OPERATORS
THESE
OPERA
TORS
ALSO
CAN
BE
USED
BEFORE
THE
VARIABLE
THEY
ARE
THEN
CALLED
THE
PREFIX
INCREMENT
AND
PREFIX
DECREMENT
OPERATORS
EACH
OF
THE
EXPRESSIONS
I
PREFIX
AND
I
POSTFIX
HAS
A
VALUE
MOREOVER
EACH
CAUSES
THE
STORED
VALUE
OF
I
IN
MEMORY
TO
BE
INCREMENTED
BY
THE
EXPRESSION
I
CAUSES
THE
STORED
VALUE
OF
I
TO
BE
INCRE
MENTED
FIRST
WITH
THE
EXPRESSION
THEN
TAKING
AS
ITS
VALUE
THE
NEW
STORED
VALUE
OF
I
IN
CONTRAST
THE
EXPRES
SION
I
HAS
AS
ITS
VALUE
THE
CURRENT
VALUE
OF
I
THEN
THE
EXPRESSION
CAUSES
THE
STORED
VALUE
OF
I
TO
BE
INCREMENTED
THE
FOLLOWING
CODE
ILLUSTRATES
THE
SITUATION
PRECEDENCE
AND
ASSOCIATIVITY
OF
OPERATORS
INT
A
B
C
A
C
B
C
SYSTEM
OUT
PRINTLN
A
A
A
IS
PRINTED
SYSTEM
OUT
PRINTLN
B
B
B
IS
PRINTED
SYSTEM
OUT
PRINTLN
C
C
C
IS
PRINTED
SIMILARLY
I
CAUSES
THE
STORED
VALUE
OF
I
IN
MEMORY
TO
BE
DECREMENTED
BY
FIRST
WITH
THE
EXPRESSION
THEN
TAKING
THIS
NEW
STORED
VALUE
AS
ITS
VALUE
WITH
I
THE
VALUE
OF
THE
EXPRESSION
IS
THE
CURRENT
VALUE
OF
I
THEN
THE
EXPRESSION
CAUSES
THE
STORED
VALUE
OF
I
IN
MEMORY
TO
BE
DECREMENTED
BY
NOTE
THAT
AND
CAUSE
THE
VALUE
OF
A
VARIABLE
IN
MEMORY
TO
BE
CHANGED
OTHER
OPERATORS
DO
NOT
DO
SO
FOR
EXAMPLE
AN
EXPRESSION
SUCH
AS
A
B
LEAVES
THE
VALUES
OF
THE
VARIABLES
A
AND
B
UNCHANGED
THESE
IDEAS
ARE
EXPRESSED
BY
SAYING
THAT
THE
OPERATORS
AND
HAVE
A
SIDE
EFFECT
NOT
ONLY
DO
THESE
OPERATORS
YIELD
A
VALUE
BUT
THEY
ALSO
CHANGE
THE
STORED
VALUE
OF
A
VARIABLE
IN
MEMORY
OF
COURSE
THIS
IS
ALSO
TRUE
OF
THE
ASSIGNMENT
OPERATOR
IN
SOME
CASES
WE
CAN
USE
IN
EITHER
PREFIX
OR
POSTFIX
POSITION
WITH
BOTH
USES
PRODUCING
EQUIVALENT
RESULTS
FOR
EXAMPLE
EACH
OF
THE
TWO
STATEMENTS
I
AND
I
IS
EQUIVALENT
TO
I
I
IN
SIMPLE
SITUATIONS
YOU
CAN
CONSIDER
AND
AS
OPERATORS
THAT
PROVIDE
CONCISE
NOTATION
FOR
THE
INCRE
MENTING
AND
DECREMENTING
OF
A
VARIABLE
IN
OTHER
SITUATIONS
YOU
MUST
PAY
CAREFUL
ATTENTION
AS
TO
WHETHER
PREFIX
OR
POSTFIX
POSITION
IS
USED
PRECEDENCE
AND
ASSOCIATIVITY
OF
OPERATORS
WHEN
EVALUATING
EXPRESSIONS
WITH
SEVERAL
OPERATORS
YOU
NEED
TO
UNDERSTAND
THE
ORDER
OF
EVALUATION
OF
EACH
OPERATOR
AND
ITS
ARGUMENTS
OPERATOR
PRECEDENCE
GIVES
A
HIERARCHY
THAT
HELPS
DETERMINE
THE
ORDER
IN
WHICH
OPERATIONS
ARE
EVALUATED
FOR
EXAMPLE
PRECEDENCE
DETERMINES
WHICH
ARITHMETIC
OPERATIONS
ARE
EVALUATED
FIRST
IN
X
B
MATH
SQRT
B
B
A
C
A
WHICH
YOU
MAY
RECOGNIZE
AS
THE
EXPRESSION
TO
COMPUTE
ONE
OF
THE
ROOTS
OF
A
QUADRATIC
EQUATION
WRITTEN
LIKE
THIS
IN
YOUR
MATHEMATICS
CLASS
X
TO
TAKE
A
SIMPLER
EXAMPLE
WHAT
IS
THE
VALUE
OF
INTEGER
VARIABLE
X
AFTER
THE
ASSIGNMENT
X
THE
ANSWER
IS
NOT
WHICH
IS
THE
REASON
IS
THAT
MULTIPLICATION
HAS
HIGHER
PRECEDENCE
THAN
ADDI
TION
THEREFORE
IS
EVALUATED
BEFORE
IS
ADDED
TO
THE
RESULT
IN
ADDITION
TO
SOME
OPERATORS
HAVING
HIGHER
PRECEDENCE
THAN
OTHERS
JAVA
SPECIFIES
THE
ASSOCIATIVITY
OR
THE
ORDER
IN
WHICH
OPERATORS
OF
EQUAL
PRECEDENCE
ARE
TO
BE
EVALUATED
FOR
EXAMPLE
THE
VALUE
OF
IS
NOT
THIS
IS
BECAUSE
AND
HAVE
EQUAL
PRECEDENCE
AND
ARITHMETIC
OPERATORS
OF
EQUAL
PRECEDENCE
ARE
EVALUATED
FROM
LEFT
TO
RIGHT
IF
YOU
WANTED
TO
DO
THE
MULTIPLICATION
BEFORE
THE
DIVISION
YOU
WOULD
WRITE
THE
EXPRESSION
AS
PARENTHESES
CAN
BE
USED
TO
OVERRIDE
THE
NORMAL
OPERATOR
PRECEDENCE
RULES
THIS
LEFT
TO
RIGHT
ORDERING
IS
IMPORTANT
IN
SOME
CASES
THAT
MIGHT
NOT
APPEAR
OBVIOUS
CONSIDER
THE
EXPRESSION
X
Y
Z
FROM
SIMPLE
ALGEBRA
THE
ASSOCIATIVITY
OF
ADDITION
TELLS
US
THAT
X
Y
Z
IS
THE
SAME
AS
X
Y
Z
UNFORTUNATELY
THIS
IS
TRUE
ONLY
WHEN
YOU
HAVE
NUMBERS
WITH
INFINITE
PRECISION
SUPPOSE
THAT
Y
IS
THE
LARGEST
POSITIVE
INTEGER
THAT
JAVA
CAN
REPRESENT
X
IS
AND
Z
IS
EVALUATING
Y
Z
FIRST
WILL
RESULT
IN
INTEGER
OVERFLOW
WHICH
IN
JAVA
WILL
BE
EQUIVALENT
TO
SOME
VERY
LARGE
NEGATIVE
NUMBER
CLEARLY
NOT
THE
EXPECTED
RESULT
IF
INSTEAD
X
Y
IS
EVALUATED
FIRST
THEN
ADDING
Z
WILL
RESULT
IN
AN
INTEGER
THAT
IS
STILL
IN
RANGE
AND
THE
RESULT
WILL
BE
THE
CORRECT
VALUE
THE
PRECEDENCE
AND
ASSOCIATIVITY
OF
ALL
JAVA
OPERATORS
IS
GIVEN
IN
APPENDIX
APPENDIX
B
REFERENCE
TABLES
THE
FOLLOWING
TABLE
GIVES
THE
RULES
OF
PRECEDENCE
AND
ASSOCIATIVITY
FOR
THE
OPERATORS
OF
JAVA
THAT
WE
HAVE
USED
SO
FAR
OPERATOR
PRECEDENCE
AND
ASSOCIATIVITY
OPERATOR
ASSOCIATIVITY
POSTFIX
POSTFIX
LEFT
TO
RIGHT
UNARY
UNARY
PREFIX
PREFIX
RIGHT
TO
LEFT
NEW
TYPE
EXPR
RIGHT
TO
LEFT
LEFT
TO
RIGHT
LEFT
TO
RIGHT
ETC
RIGHT
TO
LEFT
ALL
THE
OPERATORS
ON
THE
SAME
LINE
SUCH
AS
AND
HAVE
EQUAL
PRECEDENCE
WITH
RESPECT
TO
EACH
OTHER
BUT
HAVE
HIGHER
PRECEDENCE
THAN
ALL
THE
OPERATORS
THAT
OCCUR
ON
THE
LINES
BELOW
THEM
THE
ASSOCIATIVITY
RULE
FOR
ALL
THE
OPERATORS
ON
EACH
LINE
APPEARS
IN
THE
RIGHT
HAND
COLUMN
IN
ADDITION
TO
THE
BINARY
WHICH
REPRESENTS
ADDITION
THERE
IS
A
UNARY
AND
BOTH
OPERATORS
ARE
REPRESENTED
BY
A
PLUS
SIGN
THE
MINUS
SIGN
ALSO
HAS
BINARY
AND
UNARY
MEANINGS
THE
FOLLOWING
TABLE
GIVES
SOME
ADDITIONAL
EXAMPLES
OF
PRECEDENCE
AND
ASSOCIATIVITY
OF
OPERATORS
DECLARATIONS
AND
INITIALIZATIONS
INT
A
B
C
D
EXPRESSION
EQUIVALENT
EXPRESSION
VALUE
A
B
C
A
B
C
A
B
C
A
B
C
A
B
C
A
B
C
B
D
B
D
A
CLEAR
CONSISTENT
STYLE
IS
IMPORTANT
TO
WRITING
GOOD
CODE
WE
USE
A
STYLE
THAT
IS
LARGELY
ADAPTED
FROM
THE
JAVA
PROFESSIONAL
PROGRAMMING
COMMUNITY
HAVING
A
STYLE
THAT
IS
READILY
UNDERSTANDABLE
BY
THE
REST
OF
THE
PROGRAMMING
COMMUNITY
IS
IMPORTANT
WE
VE
ALREADY
MENTIONED
THE
IMPORTANCE
OF
COMMENTS
FOR
DOCUMENTING
A
PROGRAM
ANYTHING
THAT
AIDS
IN
EXPLAINING
WHAT
IS
OTHERWISE
NOT
CLEAR
IN
THE
PROGRAM
SHOULD
BE
PLACED
IN
A
COMMENT
COMMENTS
HELP
THE
PROGRAMMER
KEEP
TRACK
OF
DECISIONS
MADE
WHILE
WRITING
THE
CODE
WITHOUT
GOOD
DOCUMENTATION
YOU
MAY
RETURN
TO
SOME
CODE
YOU
HAVE
WRITTEN
ONLY
TO
DISCOVER
THAT
YOU
HAVE
FORGOTTEN
WHY
YOU
DID
SOME
PARTICULAR
THING
THE
DOCUMENTATION
SHOULD
ENABLE
SOMEONE
OTHER
THAN
THE
ORIGINAL
PROGRAMMER
TO
PICK
UP
USE
AND
MODIFY
THE
CODE
ALL
BUT
THE
MOST
TRIVIAL
METHODS
SHOULD
HAVE
COMMENTS
AT
THE
BEGINNING
CLEARLY
STATING
THE
PURPOSE
OF
THE
METHOD
ALSO
COMPLICATED
BLOCKS
OF
STATEMENTS
SHOULD
BE
PRECEDED
BY
COMMENTS
SUMMARIZ
ING
THE
FUNCTION
OF
THE
BLOCK
COMMENTS
SHOULD
ADD
TO
THE
CLARITY
OF
THE
CODE
NOT
SIMPLY
RESTATE
THE
PRO
GRAM
STATEMENT
BY
STATEMENT
HERE
IS
AN
EXAMPLE
OF
A
USELESS
COMMENT
AREA
WIDTH
HEIGHT
COMPUTE
THE
AREA
GOOD
DOCUMENTATION
INCLUDES
PROPER
CHOICE
OF
IDENTIFIERS
IDENTIFIERS
SHOULD
HAVE
MEANINGFUL
NAMES
CER
TAIN
SIMPLE
ONE
CHARACTER
NAMES
ARE
USED
TO
INDICATE
AUXILIARY
VARIABLES
SUCH
AS
I
J
OR
K
AS
INTEGER
VARI
ABLES
THE
CODE
SHOULD
BE
EASY
TO
READ
VISIBILITY
IS
ENHANCED
BY
THE
USE
OF
WHITE
SPACE
IN
GENERAL
WE
PRESENT
ONLY
ONE
STATEMENT
TO
A
LINE
AND
IN
ALL
EXPRESSIONS
SEPARATE
OPERATORS
FROM
ARGUMENTS
BY
A
SPACE
AS
WE
PROGRESS
TO
MORE
COMPLEX
PROGRAMS
WE
SHALL
PRESENT
BY
EXAMPLE
OR
EXPLICIT
MENTION
ACCEPTED
LAYOUT
RULES
FOR
PRO
GRAM
ELEMENTS
SOME
NAMING
CONVENTIONS
USED
BY
MANY
JAVA
PROGRAMMERS
CLASS
NAMES
START
WITH
UPPERCASE
AND
EMBEDDED
WORDS
AS
IN
HELLOWORLD
ARE
CAPITALIZED
METHODS
AND
VARIABLES
START
WITH
LOWERCASE
AND
EMBEDDED
WORDS
AS
IN
READINT
DATA
TOSTRING
AND
LOOPINDEX
ARE
CAPITALIZED
ALTHOUGH
LEGAL
THE
DOLLAR
SIGN
SHOULD
NOT
BE
USED
EXCEPT
IN
MACHINE
GENERATED
JAVA
PRO
GRAMS
SUMMARY
TO
CREATE
A
JAVA
PROGRAM
FIRST
DEFINE
A
CLASS
GIVE
THE
CLASS
A
METHOD
CALLED
MAIN
PUT
WHATEVER
INSTRUCTIONS
YOU
WANT
THE
COMPUTER
TO
EXECUTE
INSIDE
THE
BODY
OF
THE
METHOD
MAIN
A
PROGRAM
STORES
DATA
IN
VARIABLES
EACH
VARIABLE
IS
GIVEN
A
TYPE
SUCH
AS
INT
FOR
STORING
INTEGERS
OR
STRING
FOR
STORING
STRINGS
YOU
CAN
USE
LITERALS
TO
EMBED
CONSTANT
VALUES
OF
VARIOUS
TYPES
IN
A
PROGRAM
SUCH
AS
IN
THE
CONSTANT
STRING
HELLO
WORLD
OR
THE
INTEGER
CONSTANT
YOU
CAN
COMBINE
LITERALS
AND
VARIABLES
IN
EXPRESSIONS
BY
USING
OPERATORS
SUCH
AS
FOR
ADDITION
OR
STRING
CONCATENATION
AND
FOR
NUMERIC
MULTIPLICATION
YOU
CAN
STORE
THE
RESULT
OF
EVALUATING
AN
EXPRESSION
IN
A
VARIABLE
BY
USING
THE
ASSIGNMENT
OPERATOR
THE
VARIABLE
IS
ALWAYS
ON
THE
LEFT
AND
THE
EXPRESSION
BEING
ASSIGNED
TO
THE
VARIABLE
IS
ALWAYS
ON
THE
RIGHT
YOU
CAN
CALL
A
METHOD
FROM
ANOTHER
CLASS
BY
WRITING
THE
NAME
OF
THE
CLASS
FOLLOWED
BY
A
DOT
AND
THE
NAME
OF
THE
METHOD
FOR
EXAMPLE
MATH
SQRT
THE
LEXICAL
ELEMENTS
OF
A
JAVA
PROGRAM
ARE
KEYWORDS
IDENTIFIERS
LITERALS
OPERATOR
SYMBOLS
PUNCTUATION
COMMENTS
AND
WHITE
SPACE
YOU
CAN
PRINT
STRINGS
AND
NUMBERS
TO
THE
SCREEN
BY
USING
THE
METHOD
SYSTEM
OUT
PRINT
OR
SYS
TEM
OUT
PRINTLN
THE
LATTER
APPENDS
A
NEWLINE
TO
WHATEVER
IS
PRINTED
THESE
METHODS
ARE
PART
OF
THE
STANDARD
JAVA
CLASSES
JAVA
INTRODUCED
PRINTF
WHICH
ALLOWS
FORMATTED
PRINTING
AS
DERIVED
FROM
THE
C
LANGUAGE
YOU
CAN
INPUT
FROM
THE
KEYBOARD
BY
USING
THE
METHODS
OF
CLASS
SCANNER
THESE
INCLUDE
NEXT
FOR
STRINGS
NEXTINT
FOR
INTEGERS
AND
NEXTDOUBLE
FOR
DOUBLES
JAVA
SUPPORTS
THE
PRIMITIVE
INTEGER
TYPES
CHAR
BYTE
SHORT
INT
AND
LONG
IT
ALSO
SUPPORTS
TWO
FLOATING
POINT
TYPES
FLOAT
AND
DOUBLE
INTEGER
DIVISION
TRUNCATES
TOWARD
ZERO
IT
DOESN
T
ROUND
TO
THE
NEAREST
WHOLE
NUMBER
YOU
CAN
USE
MATH
ROUND
IF
ROUNDING
IS
WHAT
YOU
WANT
REVIEW
QUESTIONS
WHAT
LINE
APPEARS
IN
EVERY
COMPLETE
JAVA
PROGRAM
INDICATING
WHERE
TO
BEGIN
EXECUTING
THE
PROGRAM
WHAT
ONE
LINE
INSTRUCTION
WOULD
YOU
USE
TO
HAVE
A
JAVA
PROGRAM
PRINT
GOODBYE
WHAT
AFFECT
DO
STRINGS
SUCH
AS
WHAT
IS
THIS
HAVE
ON
THE
EXECUTION
OF
A
JAVA
PROGRAM
WHAT
IS
A
VARIABLE
WHAT
IS
A
METHOD
COMPLETE
THE
FOLLOWING
TABLE
TEXT
LEGAL
ID
WHY
OR
WHY
NOT
NO
DIGIT
IS
FIRST
CHARACTER
A
B
MAIN
COUNT
CLASS
WHAT
DOES
THE
SYMBOL
DO
IN
JAVA
PROGRAMMERS
SAY
A
METHOD
WHEN
THEY
MEAN
GO
AND
EXECUTE
THE
INSTRUCTIONS
FOR
THE
METHOD
TRUE
OR
FALSE
A
MULTILINE
COMMENT
CAN
BE
PLACED
ANYWHERE
WHITE
SPACE
COULD
BE
PLACED
TRUE
OR
FALSE
KEYWORDS
CAN
ALSO
BE
USED
AS
VARIABLES
BUT
THEN
THE
SPECIAL
MEANING
OF
THE
KEYWORD
IS
OVERRIDDEN
WHAT
CONVENTION
FOR
IDENTIFIERS
GIVEN
IN
THIS
CHAPTER
IS
USED
IN
WHATAMI
HOWABOUTTHIS
SOMENAME
WHAT
PRIMITIVE
TYPES
ARE
USED
TO
STORE
WHOLE
NUMBERS
WHAT
IS
THE
DIFFERENCE
BETWEEN
X
A
AND
X
A
WHAT
IS
THE
DIFFERENCE
BETWEEN
HELLO
AND
HELLO
WHICH
VERSION
OF
THE
JAVA
PROGRAM
HELLOWORLD
IS
THE
ONE
YOU
CAN
VIEW
AND
EDIT
WITH
A
TEXT
EDITOR
HEL
LOWORLD
JAVA
OR
HELLOWORLD
CLASS
WHAT
DOES
THE
OTHER
ONE
CONTAIN
WHAT
PROGRAM
CREATED
THE
ONE
YOU
DO
NOT
EDIT
WHAT
IS
UNICODE
LIST
THE
PRIMITIVE
TYPES
IN
JAVA
BEFORE
IT
CAN
BE
USED
EVERY
VARIABLE
MUST
BE
DECLARED
AND
GIVEN
A
WHAT
IS
THE
VALUE
OF
THE
JAVA
EXPRESSION
DON
T
IGNORE
THE
QUOTATION
MARKS
THEY
ARE
CRUCIAL
WRITE
A
JAVA
STATEMENT
THAT
COULD
BE
USED
TO
READ
AN
INTEGER
VALUE
FROM
THE
KEYBOARD
AND
STORE
IT
IN
THE
VARIABLE
SOMENUMBER
WHAT
IS
WRONG
WITH
THE
FOLLOWING
JAVA
STATEMENT
SYSTEM
OUT
PRINTLN
THIS
STATEMENT
IS
SUPPOSED
TO
PRINT
A
MESSAGE
WHAT
IS
WRONG
EVERY
GROUP
OF
INPUT
STATEMENTS
SHOULD
BE
PRECEDED
BY
WHAT
HOW
DO
YOU
WRITE
X
TIMES
Y
IN
JAVA
WHAT
IS
THE
DIFFERENCE
BETWEEN
SYSTEM
OUT
PRINT
MESSAGE
AND
SYSTEM
OUT
PRINTLN
MES
SAGE
WRITE
A
SINGLE
JAVA
STATEMENT
THAT
WILL
PRODUCE
THE
FOLLOWING
OUTPUT
APPROXIMATELY
WHAT
IS
THE
LARGEST
VALUE
THAT
CAN
BE
STORED
IN
THE
PRIMITIVE
TYPE
INT
ONE
THOUSAND
ONE
MILLION
ONE
BILLION
ONE
TRILLION
EVEN
LARGER
WHAT
PRIMITIVE
JAVA
TYPE
CAN
STORE
THE
LARGEST
NUMBERS
WHAT
IS
THE
VALUE
OF
THE
FOLLOWING
JAVA
EXPRESSIONS
EXERCISES
WRITE
A
JAVA
PROGRAM
THAT
PRINTS
HELLO
YOUR
NAME
YOU
CAN
DO
THIS
BY
A
SIMPLE
MODIFICATION
TO
THE
HEL
LOWORLD
PROGRAM
COMPILE
AND
RUN
THIS
PROGRAM
ON
YOUR
COMPUTER
WRITE
A
JAVA
PROGRAM
THAT
PRINTS
A
FAVORITE
POEM
OF
AT
LEAST
EIGHT
LINES
BE
SURE
TO
PRINT
IT
OUT
NEATLY
ALIGNED
AT
THE
END
OF
THE
POEM
PRINT
TWO
BLANK
LINES
AND
THEN
THE
AUTHOR
NAME
DESIGN
YOUR
OWN
SIGNATURE
LOGO
SUCH
AS
A
SAILBOAT
ICON
IF
YOU
LIKE
SAILING
AND
PRINT
IT
FOLLOWED
BY
YOURS
TRULY
YOUR
NAME
A
SAILBOAT
SIGNATURE
LOGO
MIGHT
LOOK
LIKE
YOURS
TRULY
BRUCE
MCPOHL
WRITE
A
JAVA
PROGRAM
TO
READ
IN
TWO
NUMBERS
AND
PRINT
THE
SUM
BE
SURE
TO
INCLUDE
A
MESSAGE
TO
PROMPT
THE
USER
FOR
INPUT
AND
A
MESSAGE
IDENTIFYING
THE
OUTPUT
SEE
WHAT
HAPPENS
IF
YOU
TYPE
IN
SOMETHING
THAT
IS
NOT
A
NUMBER
WHEN
THE
PROGRAM
IS
RUN
SEE
HOW
LARGE
A
NUMBER
YOU
CAN
TYPE
IN
AND
STILL
HAVE
THE
PRO
GRAM
WORK
CORRECTLY
THE
FOLLOWING
CODE
CONTAINS
THREE
SYNTAX
ERRORS
AND
PRODUCES
TWO
SYNTAX
ERROR
MESSAGES
FROM
JAVAC
FIX
THE
PROBLEMS
JAVA
FIXING
SYNTAX
ERRORS
CLASS
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
SYSTEM
OUT
PRINTLN
HELLO
WORLD
THE
JAVAC
COMPILER
MESSAGE
READS
THE
FOLLOWING
CODE
PRODUCES
ONE
SYNTAX
ERROR
MESSAGE
FROM
JAVAC
FIX
THE
PROBLEM
JAVA
MORE
SYNTAX
ERRORS
CLASS
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
COUNT
I
SYSTEM
OUT
PRINTLN
COUNT
I
COUNT
I
THE
JAVAC
COMPILER
MESSAGE
READS
HERE
UNLIKE
THE
PREVIOUS
EXERCISE
THE
COMPILER
DOESN
T
AS
CLEARLY
POINT
TO
THE
ERRORS
FREQUENTLY
ERRORS
IN
PUNCTUATION
LEAD
TO
SYNTAX
ERROR
MESSAGES
THAT
ARE
HARD
TO
DECIPHER
AFTER
YOU
FIX
THE
FIRST
SYNTAX
ERROR
IN
THE
CODE
A
SECOND
ERROR
WILL
BE
IDENTIFIED
CONTINUE
WITH
THE
CODE
CLASS
IF
YOU
FIXED
JUST
THE
SYNTAX
ERRORS
YOU
MAY
GET
A
RUNNING
PROGRAM
THAT
STILL
HAS
A
RUN
TIME
BUG
NAMELY
THE
OUTPUT
MAY
NOT
BE
THE
SUM
OF
COUNT
I
FIXING
RUN
TIME
OR
SEMANTIC
BUGS
IS
HARDER
THAN
FIXING
SYNTAX
BUGS
BECAUSE
SOMETHING
IS
WRONG
WITH
YOUR
UNDERSTANDING
OF
HOW
TO
PROGRAM
THE
SOLUTION
WITHOUT
INTRODUCING
ANY
OTHER
VARIABLES
FIX
THE
RUN
TIME
BUG
WRITE
A
PROGRAM
THAT
DRAWS
A
BOX
LIKE
THE
ONE
SHOWN
USING
A
SINGLE
PRINTLN
STATEMENT
USE
SCAN
NEXTDOUBLE
TO
READ
IN
ONE
DOUBLE
PRECISION
FLOATING
POINT
NUMBER
AND
THEN
PRINT
THE
RESULTS
OF
CALLING
MATH
SIN
MATH
COS
MATH
ASIN
MATH
EXP
MATH
LOG
MATH
FLOOR
AND
MATH
ROUND
WITH
THE
INPUT
VALUE
AS
A
PARAMETER
BE
SURE
TO
PROMPT
THE
USER
FOR
INPUT
AND
LABEL
THE
OUTPUT
WRITE
A
PROGRAM
TO
READ
TWO
DOUBLE
PRECISION
FLOATING
POINT
NUMBERS
USING
NEXTDOUBLE
PRINT
THE
SUM
DIFFERENCE
PRODUCT
AND
QUOTIENT
OF
THE
TWO
NUMBERS
TRY
TWO
VERY
SMALL
NUMBERS
TWO
VERY
LARGE
NUMBERS
AND
ONE
VERY
SMALL
NUMBER
WITH
ONE
VERY
LARGE
NUMBER
YOU
CAN
USE
THE
SAME
NOTATION
USED
FOR
LITERALS
TO
ENTER
THE
NUMBERS
FOR
EXAMPLE
IS
A
VERY
SMALL
NUMBER
WRITE
A
PROGRAM
TO
COMPUTE
THE
AREA
OF
A
CIRCLE
GIVEN
ITS
RADIUS
LET
RADIUS
BE
A
VARIABLE
OF
TYPE
DOUBLE
AND
USE
NEXTDOUBLE
TO
READ
IN
ITS
VALUE
BE
SURE
THAT
THE
OUTPUT
IS
UNDERSTANDABLE
THE
JAVA
CLASS
MATH
CONTAINS
DEFINITIONS
FOR
THE
CONSTANTS
E
AND
PI
SO
YOU
CAN
USE
MATH
PI
IN
YOUR
PROGRAM
EXTEND
THE
PREVIOUS
PROGRAM
TO
WRITE
OUT
THE
CIRCUMFERENCE
OF
A
CIRCLE
AND
THE
VOLUME
OF
A
SPHERE
GIVEN
THE
RADIUS
AS
INPUT
RECALL
THAT
THE
VOLUME
OF
A
SPHERE
IS
V
WRITE
A
PROGRAM
THAT
ASKS
FOR
A
DOUBLE
AND
THEN
PRINTS
IT
OUT
THEN
ASK
FOR
A
SECOND
DOUBLE
THIS
TIME
PRINTING
OUT
THE
SUM
AND
AVERAGE
OF
THE
TWO
DOUBLES
THEN
ASK
FOR
A
THIRD
DOUBLE
AND
AGAIN
PRINT
OUT
THE
ACCUMULATED
SUM
AND
THE
AVERAGE
OF
THE
THREE
DOUBLES
USE
VARIABLES
AND
SUM
LATER
WHEN
WE
DISCUSS
LOOPS
YOU
WILL
SEE
HOW
THIS
IS
EASILY
DONE
FOR
AN
ARBITRARY
NUMBER
OF
INPUT
VAL
UES
WRITE
A
PROGRAM
THAT
READS
IN
AN
INTEGER
AND
PRINTS
IT
AS
A
CHARACTER
REMEMBER
THAT
CHARACTER
CODES
CAN
BE
NONPRINTING
WRITE
A
PROGRAM
THAT
ASKS
FOR
THE
NUMBER
OF
QUARTERS
DIMES
NICKELS
AND
PENNIES
YOU
HAVE
THEN
COM
PUTE
THE
TOTAL
VALUE
OF
YOUR
CHANGE
AND
PRINT
THE
NUMBER
OF
DOLLARS
AND
THE
REMAINING
CENTS
WRITE
A
PROGRAM
CAPABLE
OF
CONVERTING
ONE
CURRENCY
TO
ANOTHER
FOR
EXAMPLE
GIVEN
U
S
DOLLARS
IT
SHOULD
PRINT
OUT
THE
EQUIVALENT
NUMBER
OF
EUROS
LOOK
UP
THE
EXCHANGE
RATE
AND
USE
IT
AS
INPUT
CHANGE
THE
MAKECHANGE
PROGRAM
TO
USE
VARIABLES
THAT
ARE
DOUBLES
RUN
THE
PROGRAM
AND
SEE
WHAT
GOES
WRONG
CLASS
MAKECHANGE
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
DOUBLE
PRICE
CHANGE
DIMES
PENNIES
THE
FOLLOWING
IS
A
C
PROGRAM
FOR
PRINTING
HELLO
WORLD
HELLO
WORLD
IN
C
PURPOSE
THE
CLASSIC
HELLO
WORLD
PROGRAM
IT
SIMPLY
PRINTS
A
MESSAGE
TO
THE
SCREEN
AUTHOR
JANE
PROGRAMMER
AS
DERIVED
FROM
KERNIGHAN
AND
RICHIE
INCLUDE
STDIO
H
NEEDED
FOR
IO
INT
MAIN
VOID
PRINTF
HELLO
WORLD
N
RETURN
UNNEEDED
IN
JAVA
NOTE
HOW
SIMILAR
THIS
PROGRAM
IS
TO
THE
JAVA
VERSION
A
KEY
DIFFERENCE
IS
THE
LACK
OF
CLASS
ENCAPSULATION
OF
MAIN
AS
IN
JAVA
MAIN
STARTS
THE
PROGRAM
EXECUTION
IN
C
METHODS
ARE
KNOWN
AS
FUNCTIONS
THE
PRINTF
FUNCTION
IS
FOUND
IN
THE
STANDARD
INPUT
OUTPUT
LIBRARY
IMPORTED
BY
THE
C
COMPILER
FOR
USE
IN
THIS
PROGRAM
THE
RETURN
ENDS
PROGRAM
EXECUTION
AND
IS
NOT
USED
IN
JAVA
CONVERT
THE
FOLLOWING
C
PROGRAM
TO
JAVA
INCLUDE
STDIO
H
INT
MAIN
VOID
PRINTF
HELLO
WORLD
N
PRINTF
MY
NAME
IS
GEORGE
N
PRINTF
YADA
YADA
YADA
N
RETURN
APPLET
EXERCISE
THE
FOLLOWING
PROGRAM
IS
AN
EXAMPLE
OF
A
JAVA
APPLET
THIS
PROGRAM
USES
SEVERAL
FEATURES
OF
JAVA
THAT
WE
EXPLAIN
LATER
NOTE
THAT
THERE
IS
NO
METHOD
MAIN
INSTEAD
THERE
IS
THE
METHOD
PAINT
FOR
NOW
JUST
CON
CENTRATE
ON
THE
BODY
OF
THE
METHOD
PAINT
TREATING
THE
SURROUNDING
CODE
AS
A
TEMPLATE
TO
BE
COPIED
VERBA
TIM
BY
INVOKING
THE
APPROPRIATE
DRAWING
OPERATIONS
ON
THE
GRAPHICS
OBJECT
G
YOU
CAN
DRAW
ON
THE
APPLET
TO
PLACE
THIS
APPLET
IN
A
WEB
PAGE
ADD
THE
FOLLOWING
TWO
LINES
TO
THE
HTML
DOCUMENT
FOR
THE
PAGE
APPLET
CODE
FIRSTAPPLET
CLASS
WIDTH
HEIGHT
APPLET
AWT
AND
SWING
TOGETHER
COMPRISE
THE
COLLECTION
OF
CLASSES
USED
FOR
BUILDING
GRAPHICAL
JAVA
PROGRAMS
IMPORT
JAVA
AWT
REQUIRED
FOR
PROGRAMS
THAT
DRAW
IMPORT
JAVAX
SWING
REQUIRED
FOR
SWING
APPLETS
PUBLIC
CLASS
FIRSTAPPLET
EXTENDS
JAPPLET
PUBLIC
VOID
PAINT
GRAPHICS
G
DRAW
A
LINE
FROM
THE
UPPER
LEFT
CORNER
TO
PIXELS
BELOW
THE
TOP
CENTER
OF
THE
APPLET
G
DRAWLINE
DRAW
A
LINE
FROM
THE
END
OF
THE
PREVIOUS
LINE
UP
TO
THE
TOP
CENTER
OF
THE
APPLET
G
DRAWLINE
DRAW
AN
OVAL
INSCRIBED
IN
AN
INVISIBLE
RECTANGLE
WITH
ITS
UPPER
LEFT
CORNER
AT
THE
INTERSECTION
OF
THE
TWO
LINES
DRAWN
ABOVE
G
DRAWOVAL
THE
CLASS
GRAPHICS
IS
USED
FOR
SIMPLE
DRAWING
AND
MANY
DRAWING
OPERATIONS
ARE
DEFINED
FOR
IT
IN
THIS
EXAM
PLE
WE
USE
THE
METHOD
DRAWLINE
TO
DRAW
A
LINE
THE
FIRST
TWO
NUMBERS
IN
PARENTHESES
FOR
THE
DRAWLINE
OPERATION
ARE
THE
XY
COORDINATES
OF
ONE
END
OF
THE
LINE
AND
THE
LAST
TWO
NUMBERS
ARE
THE
XY
COORDINATES
OF
THE
OTHER
END
AS
YOU
CAN
SEE
FROM
THE
OUTPUT
OF
THE
PROGRAM
THE
LOCATION
IS
IN
THE
UPPER
LEFT
CORNER
WITH
INCREASING
X
MOVING
TO
THE
RIGHT
AND
INCREASING
Y
MOVING
DOWN
TO
DRAW
AN
OVAL
GIVE
THE
COORDINATES
OF
THE
UPPER
LEFT
CORNER
AND
THE
WIDTH
AND
HEIGHT
ON
AN
INVISIBLE
RECTANGLE
THE
OVAL
WILL
BE
INSCRIBED
INSIDE
THE
RECTANGLE
TO
EXECUTE
AN
APPLET
FIRST
COMPILE
IT
LIKE
YOU
DO
OTHER
JAVA
PROGRAMS
THEN
YOU
CAN
EITHER
RUN
THE
PROGRAM
APPLETVIEWER
OR
USE
A
WEB
BROWSER
TO
VIEW
THE
APPLET
TO
VIEW
THE
APPLET
FIRSTAPPLET
USING
THE
APPLET
VIEWER
ON
UNIX
AND
WINDOWS
MACHINES
TYPE
THE
FOLLOWING
AT
A
COMMAND
LINE
PROMPT
APPLETVIEWER
FIRSTAPPLET
JAVA
NOTICE
THAT
WE
ARE
PASSING
FIRSTAPPLET
JAVA
NOT
FIRSTAPPLET
OR
FIRSTAPPLET
CLASS
TO
THE
APPLET
VIEWER
THIS
PROCEDURE
IS
DIFFERENT
FROM
RUNNING
REGULAR
JAVA
PROGRAMS
IN
FACT
APPLETVIEWER
JUST
LOOKS
IN
THE
TEXT
FILE
PASSED
TO
IT
FOR
AN
APPLET
ELEMENT
AN
APPLET
ELEMENT
BEGINS
WITH
APPLET
AND
ENDS
WITH
APPLET
ANY
TEXT
FILE
CONTAINING
THE
APPLET
ELEMENT
SHOWN
IN
THE
OPENING
COMMENT
FOR
FIRSTAPPLET
JAVA
WOULD
WORK
JUST
AS
WELL
TO
VIEW
THE
APPLET
IN
A
WEB
BROWSER
CREATE
A
FILE
FOR
EXAMPLE
FIRSTAPPLET
HTML
PUT
THE
APPLET
TAG
IN
THE
HTML
FILE
PUT
THE
HTML
FILE
IN
THE
SAME
DIRECTORY
AS
YOUR
APPLET
AND
THEN
OPEN
THE
HTML
FILE
WITH
A
WEB
BROWSER
THE
APPLET
LOOKS
LIKE
THE
FOLLOWING
WHEN
RUN
WITH
AN
APPLETVIEWER
MODIFY
THIS
APPLET
TO
DRAW
A
SIMPLE
PICTURE
LOOK
UP
THE
DOCUMENTATION
FOR
GRAPHICS
ON
THE
WEB
AT
HTTP
JAVA
SUN
COM
DOCS
API
JAVA
AWT
GRAPHICS
HTML
AND
USE
AT
LEAST
ONE
METHOD
OPERATION
OF
GRAPHICS
NOT
USED
IN
FIRSTAPPLET
THE
PROGRAM
EXAMPLES
PRESENTED
UNTIL
NOW
HAVE
EXECUTED
FROM
TOP
TO
BOTTOM
WITHOUT
MAKING
ANY
DECISIONS
IN
THIS
CHAPTER
WE
HAVE
PROGRAMS
SELECT
AMONG
TWO
OR
MORE
ALTERNATIVES
WE
ALSO
DEMONSTRATE
HOW
TO
WRITE
PROGRAMS
THAT
REPEATEDLY
EXECUTE
THE
SAME
SEQUENCE
OF
INSTRUCTIONS
BOTH
INSTRUCTIONS
TO
COMPUTERS
AND
INSTRUCTIONS
IN
EVERYDAY
LIFE
ARE
FILLED
WITH
CONDITIONAL
AND
ITERATIVE
STATEMENTS
A
CONDITIONAL
INSTRUCTION
FOR
YOUR
MICROWAVE
OVEN
MIGHT
SAY
IF
YOU
WISH
TO
DEFROST
PRESS
THE
DEFROST
BUTTON
OTHERWISE
PRESS
THE
FULL
POWER
BUTTON
AN
ITERATIVE
INSTRUCTION
FOR
BAKING
A
LOAF
OF
BREAD
MIGHT
SAY
LET
THE
DOUGH
RISE
IN
A
WARM
PLACE
UNTIL
IT
HAS
DOUBLED
IN
SIZE
CONDITIONAL
AND
ITERATIVE
STATEMENTS
ARE
CONTROLLED
BY
BOOLEAN
EXPRES
SIONS
A
BOOLEAN
EXPRESSION
IS
EITHER
TRUE
OR
FALSE
IF
IT
IS
RAINING
WEAR
YOUR
RAINCOAT
IS
AN
INSTRUCTION
GIVEN
BY
MANY
PARENTS
AND
IS
FOLLOWED
IF
IT
IS
TRUE
THAT
IT
IS
RAINING
IN
JAVA
EXPRESSIONS
THAT
EVALUATE
AS
TRUE
OR
FALSE
ARE
OF
TYPE
BOOLEAN
TO
DIRECT
THE
FLOW
OF
CONTROL
PROPERLY
YOU
NEED
TO
LEARN
HOW
TO
WRITE
BOOLEAN
EXPRESSIONS
EXPRESSION
BLOCK
AND
EMPTY
STATEMENTS
JAVA
HAS
MANY
KINDS
OF
STATEMENTS
MOST
OF
THE
STATEMENTS
THAT
WE
HAVE
SHOWN
HAVE
SPECIFIED
THE
EVALUATION
OF
AN
EXPRESSION
WE
LL
SOON
LOOK
AT
STATEMENTS
THAT
SELECT
BETWEEN
TWO
ALTERNATIVES
AND
STATEMENTS
THAT
REPEAT
MANY
TIMES
BEFORE
DOING
THAT
WE
NEED
TO
LOOK
MORE
CLOSELY
AT
THE
STATEMENTS
THAT
WE
HAVE
BEEN
USING
THE
NORMAL
FLOW
OF
INSTRUCTIONS
IN
JAVA
IS
TO
EXECUTE
THE
STATEMENTS
OF
THE
PROGRAM
IN
SEQUENTIAL
ORDER
FROM
TOP
TO
BOTTOM
ALL
THE
STATEMENTS
USED
SO
FAR
HAVE
BEEN
EITHER
VARIABLE
DECLARATION
STATEMENTS
OR
EXPRESSION
STATEMENTS
VARIABLE
DECLARATION
STATEMENTS
BEGIN
WITH
A
TYPE
SUCH
AS
INT
OR
STRING
AND
END
WITH
A
SEMICOLON
AS
IN
INT
WIDTH
HEIGHT
AREA
STRING
HELLO
HELLO
WORLD
DOUBLE
SIZE
X
THE
FIRST
DECLARES
THREE
VARIABLES
OF
TYPE
INT
THE
SECOND
DECLARES
ONE
VARIABLE
OF
TYPE
STRING
AND
INITIALIZES
IT
THE
THIRD
DECLARES
AND
INITIALIZES
THE
VARIABLE
SIZE
BUT
NOT
THE
VARIABLE
X
DECLARATION
STATEMENTS
START
WITH
A
TYPE
AND
ARE
FOLLOWED
BY
ONE
OR
MORE
VARIABLES
SEPARATED
BY
COMMAS
THE
VARIABLES
MAY
BE
INITIALIZED
BY
USING
THE
EQUALS
SIGN
FOLLOWED
TYPICALLY
BY
A
LITERAL
IN
JAVA
ALL
VARIABLES
NEED
TO
BE
DECLARED
EXPRESSION
STATEMENTS
ARE
FORMED
BY
ADDING
A
SEMICOLON
TO
THE
END
OF
AN
EXPRESSION
EXPRESSIONS
ARE
BASIC
TO
PERFORMING
COMPUTATIONS
NOT
ALL
EXPRESSIONS
ARE
VALID
IN
EXPRESSION
STATEMENTS
THE
TWO
TYPES
OF
EXPRES
SIONS
USED
SO
FAR
THAT
ARE
VALID
IN
EXPRESSION
STATEMENTS
ARE
ASSIGNMENT
EXPRESSIONS
AND
METHOD
CALL
EXPRES
SIONS
AN
ASSIGNMENT
EXPRESSION
IS
ANY
EXPRESSION
INVOLVING
THE
ASSIGNMENT
OPERATOR
A
METHOD
CALL
EXPRESSION
DOES
NOT
INVOLVE
AN
ASSIGNMENT
OPERATOR
THE
FOLLOWING
ARE
EXAMPLES
OF
EXPRESSION
STATEMENTS
AREA
WIDTH
HEIGHT
SIMPLE
ASSIGNMENT
STATEMENT
SYSTEM
OUT
PRINTLN
METHOD
CALL
EXPRESSION
A
STATEMENT
USED
FOR
GROUPING
A
NUMBER
OF
STATEMENTS
IS
A
BLOCK
A
BLOCK
IS
A
SEQUENCE
OF
ONE
OR
MORE
STATE
MENTS
ENCLOSED
BY
BRACES
A
BLOCK
IS
ITSELF
A
STATEMENT
A
SIMPLE
EXAMPLE
IS
X
Y
X
SYSTEM
OUT
PRINTLN
Y
SYSTEM
OUT
PRINTLN
X
STATEMENTS
INSIDE
A
BLOCK
CAN
ALSO
BE
BLOCKS
THE
INSIDE
BLOCK
IS
CALLED
AN
INNER
BLOCK
WHICH
IS
NESTED
IN
THE
OUTER
BLOCK
AN
EXAMPLE
IS
OUTER
BLOCK
X
INNER
BLOCK
Y
SYSTEM
OUT
PRINTLN
Y
END
OF
INNER
BLOCK
SYSTEM
OUT
PRINTLN
X
THIS
EXAMPLE
MERELY
DEMONSTRATES
THE
SYNTAX
OF
A
BLOCK
WE
WOULDN
T
NORMALLY
PUT
A
BLOCK
INSIDE
ANOTHER
BLOCK
FOR
NO
REASON
MOST
NESTED
BLOCKS
INVOLVE
DECLARATION
STATEMENTS
THAT
CREATE
LOCAL
VARIABLES
A
SIMPLE
EXAMPLE
OF
A
BLOCK
WITH
DECLARATIONS
IS
INT
I
J
I
IS
CREATED
IN
THIS
BLOCK
J
IS
FROM
ELSEWHERE
END
OF
BLOCK
I
DISAPPEARS
IN
THIS
EXAMPLE
THE
INT
VARIABLE
I
IS
CREATED
WHEN
THIS
BLOCK
IS
EXECUTED
WHEN
THIS
BLOCK
IS
STARTED
I
IS
PLACED
IN
MEMORY
WITH
ITS
INITIAL
VALUE
CALCULATED
AS
PLUS
THE
VALUE
OF
J
WHEN
THE
BLOCK
IS
EXITED
THE
VARI
ABLE
DISAPPEARS
BLOCKS
ARE
NOT
TERMINATED
BY
SEMICOLONS
RATHER
THEY
ARE
TERMINATED
BY
A
CLOSING
BRACE
ALSO
CALLED
THE
RIGHT
BRACE
RECALL
THAT
THE
SEMICOLON
WHEN
USED
IS
PART
OF
THE
STATEMENT
NOT
SOMETHING
ADDED
TO
THE
STATEMENT
FOR
EXAMPLE
THE
SEMICOLON
TURNS
AN
EXPRESSION
INTO
A
STATEMENT
UNDERSTANDING
THIS
WILL
MAKE
IT
MUCH
EAS
IER
FOR
YOU
TO
CREATE
SYNTACTICALLY
CORRECT
PROGRAMS
WITH
THE
NEW
STATEMENT
TYPES
THAT
WE
INTRODUCE
IN
THIS
CHAPTER
EMPTY
STATEMENT
THE
SIMPLEST
STATEMENT
IS
THE
EMPTY
STATEMENT
OR
NULL
STATEMENT
IT
IS
JUST
A
SEMICOLON
ALL
BY
ITSELF
AND
RESULTS
IN
NO
ACTION
A
SEMICOLON
PLACED
AFTER
A
BLOCK
IS
AN
EMPTY
STATEMENT
AND
IS
IRRELEVANT
TO
THE
PRO
GRAM
ACTIONS
THE
FOLLOWING
CODE
FRAGMENT
PRODUCES
EXACTLY
THE
SAME
RESULT
AS
THE
NESTED
BLOCK
EXAMPLE
IN
THE
PRECEDING
SECTION
THE
STRING
OF
SEMICOLONS
SIMPLY
CREATE
SEVEN
EMPTY
STATEMENTS
FOLLOWING
THE
INNER
BLOCK
BOOLEAN
EXPRESSIONS
X
Y
SYSTEM
OUT
PRINTLN
Y
SYSTEM
OUT
PRINTLN
X
A
BOOLEAN
EXPRESSION
IS
ANY
EXPRESSION
THAT
EVALUATES
TO
EITHER
TRUE
OR
FALSE
JAVA
INCLUDES
A
PRIMITIVE
TYPE
BOOLEAN
THE
TWO
SIMPLEST
BOOLEAN
EXPRESSIONS
ARE
THE
BOOLEAN
LITERALS
TRUE
AND
FALSE
IN
ADDITION
TO
THESE
TWO
LITERALS
BOOLEAN
VALUES
RESULT
FROM
EXPRESSIONS
INVOLVING
EITHER
RELATIONAL
OPERATORS
FOR
COMPARING
NUM
BERS
OR
LOGICAL
OPERATORS
THAT
ACT
ON
BOOLEAN
VALUES
RELATIONAL
AND
EQUALITY
OPERATORS
ALL
CONDITIONAL
STATEMENTS
REQUIRE
SOME
BOOLEAN
EXPRESSION
TO
DECIDE
WHICH
EXECUTION
PATH
TO
FOLLOW
JAVA
USES
FOUR
RELATIONAL
OPERATORS
LESS
THAN
GREATER
THAN
LESS
THAN
OR
EQUAL
AND
GREATER
THAN
OR
EQUAL
JAVA
ALSO
CONTAINS
TWO
EQUALITY
OPERATORS
EQUAL
AND
NOT
EQUAL
THEY
CAN
BE
USED
BETWEEN
ANY
TWO
NUMERIC
VALUES
THE
EQUALITY
OPERATORS
MAY
ALSO
BE
USED
WHEN
COMPARING
NONNUMERIC
TYPES
THEY
ARE
LISTED
IN
THE
FOLLOWING
TABLE
OPERATOR
NAME
EXAMPLE
LESS
THAN
IS
TRUE
GREATER
THAN
IS
FALSE
EQUAL
IS
FALSE
LESS
THAN
OR
EQUAL
IS
TRUE
GREATER
THAN
OR
EQUAL
IS
TRUE
NOT
EQUAL
IS
TRUE
THE
RELATIONAL
OPERATORS
CAN
BE
USED
IN
ASSIGNMENT
TO
BOOLEAN
VARIABLES
AS
IN
INT
I
J
BOOLEAN
FLAG
FLAG
FLAG
IS
NOW
TRUE
FLAG
I
J
FLAG
IS
NOW
FALSE
FLAG
J
FLAG
IS
NOW
TRUE
LOGICAL
OPERATORS
ONCE
YOU
HAVE
A
BOOLEAN
VALUE
EITHER
STORED
IN
A
VARIABLE
REPRESENTING
A
PRIMITIVE
BOOLEAN
VALUE
FOR
EXAM
PLE
BOOLEAN
DONE
FALSE
OR
AS
THE
RESULT
OF
AN
EXPRESSION
INVOLVING
A
RELATIONAL
OPERATOR
FOR
EXAMPLE
X
Y
YOU
CAN
COMBINE
THESE
BOOLEAN
VALUES
BY
USING
THE
LOGICAL
OPERATORS
JAVA
PROVIDES
THREE
LOGICAL
OPERATORS
AND
OR
AND
NOT
THE
MEANING
OF
THESE
OPERATORS
IS
GIVEN
IN
THE
FOLLOWING
TABLE
OPERATOR
NAME
DESCRIPTION
EXAMPLE
ASSUME
X
IS
AND
Y
IS
AND
THE
EXPRESSION
X
Y
IS
TRUE
IF
BOTH
X
AND
Y
ARE
TRUE
AND
FALSE
OTHERWISE
X
Y
IS
TRUE
OR
THE
EXPRESSION
X
Y
IS
TRUE
IF
EITHER
X
OR
Y
OR
BOTH
IS
TRUE
AND
FALSE
OTHERWISE
X
Y
IS
TRUE
NOT
THE
EXPRESSION
X
IS
TRUE
IF
X
IS
FALSE
AND
FALSE
OTHERWISE
X
IS
FALSE
FOR
EXAMPLE
IF
YOU
WANTED
TO
DETERMINE
WHETHER
A
PERSON
IN
A
DATABASE
WAS
AN
ADULT
BUT
NOT
A
SENIOR
CITI
ZEN
YOU
COULD
CHECK
IF
THEIR
AGE
WAS
GREATER
THAN
OR
EQUAL
TO
AND
THEIR
AGE
WAS
LESS
THAN
THE
FOLLOW
ING
JAVA
CODE
FRAGMENT
WILL
PRINT
OUT
FULL
FARE
ADULT
IS
TRUE
IF
THIS
CONDITION
IS
MET
OTHERWISE
IT
PRINTS
FULL
FARE
ADULT
IS
FALSE
BOOLEAN
B
AGEOFPERSON
AGEOFPERSON
SYSTEM
OUT
PRINTLN
FULL
FARE
ADULT
IS
B
FOR
AN
EXAMPLE
OF
THE
USE
OF
OR
CONSIDER
THE
OPPOSITE
SITUATION
AS
ABOVE
WHERE
YOU
WANTED
TO
FIND
OUT
IF
A
REDUCED
FAIR
WAS
APPROPRIATE
YOU
MIGHT
WRITE
B
AGEOFPERSON
AGEOFPERSON
SYSTEM
OUT
PRINTLN
REDUCED
FARE
IS
B
THE
LOGICAL
OPERATORS
AND
USE
SHORT
CIRCUIT
EVALUATION
IN
THE
PRECEDING
EXAMPLE
OF
A
LOGICAL
AND
EXPRESSION
IF
THE
AGEOFPERSON
WERE
THEN
THE
TEST
FOR
AGEOFPERSON
WOULD
BE
OMITTED
USED
PARTLY
FOR
EFFICIENCY
REASONS
THIS
APPROACH
IS
HELPFUL
WHEN
THE
SECOND
PART
OF
SUCH
AN
EXPRESSION
COULD
LEAD
TO
AN
UNDESIRABLE
RESULT
SUCH
AS
PROGRAM
TERMINATION
AS
WITH
OTHER
OPERATORS
THE
RELATIONAL
EQUALITY
AND
LOGICAL
OPERATORS
HAVE
RULES
OF
PRECEDENCE
AND
ASSOCIA
TIVITY
THAT
DETERMINE
PRECISELY
HOW
EXPRESSIONS
INVOLVING
THESE
OPERATORS
ARE
EVALUATED
AS
SHOWN
IN
THE
FOL
LOWING
TABLE
T
OPERATOR
PRECEDENCE
AND
ASSOCIATIVITY
OPERATORS
ASSOCIATIVITY
POSTFIX
POSTFIX
LEFT
TO
RIGHT
UNARY
UNARY
PREFIX
PREFIX
RIGHT
TO
LEFT
LEFT
TO
RIGHT
LEFT
TO
RIGHT
LEFT
TO
RIGHT
LEFT
TO
RIGHT
LEFT
TO
RIGHT
LEFT
TO
RIGHT
ETC
RIGHT
TO
LEFT
NOTE
THAT
WITH
THE
EXCEPTION
OF
THE
BOOLEAN
UNARY
OPERATOR
NEGATION
THE
RELATIONAL
BOOLEAN
AND
EQUALITY
OPERATORS
HAVE
LOWER
PRECEDENCE
THAN
THE
ARITHMETIC
OPERATORS
ONLY
THE
ASSIGNMENT
OPERATORS
HAVE
LOWER
PRECEDENCE
THE
IF
STATEMENT
COMPUTERS
MAKE
DECISIONS
BY
EVALUATING
EXPRESSIONS
AND
EXECUTING
DIFFERENT
STATEMENTS
BASED
ON
THE
VALUE
OF
THE
EXPRESSION
THE
SIMPLEST
TYPE
OF
DECISION
IS
ONE
THAT
CAN
HAVE
ONLY
TWO
POSSIBLE
OUTCOMES
SUCH
AS
GO
LEFT
VERSUS
GO
RIGHT
OR
CONTINUE
VERSUS
STOP
IN
JAVA
WE
USE
BOOLEAN
EXPRESSIONS
TO
CONTROL
DECISIONS
THAT
HAVE
TWO
POSSIBLE
OUTCOMES
THE
IF
STATEMENT
IS
A
CONDITIONAL
STATEMENT
AN
IF
STATEMENT
HAS
THE
GENERAL
FORM
IF
BOOLEANEXPR
STATEMENT
IF
THE
EXPRESSION
BOOLEANEXPR
IS
TRUE
THEN
THE
STATEMENT
STATEMENT
IS
EXECUTED
OTHERWISE
STATEMENT
IS
SKIPPED
STATEMENT
IS
CALLED
THE
THEN
STATEMENT
IN
SOME
PROGRAMMING
LANGUAGES
BUT
NOT
JAVA
THEN
IS
USED
TO
SIGNAL
THE
THEN
STATEMENT
AFTER
THE
IF
STATEMENT
HAS
BEEN
EXECUTED
CONTROL
PASSES
TO
THE
NEXT
STATEMENT
THE
FLOW
OF
EXECUTION
CAN
SKIP
AROUND
STATEMENT
AS
SHOWN
IN
THE
FOLLOWING
DIAGRAM
EXECUTION
ENTERS
IF
STATEMENT
CONTINUE
WITH
REST
OF
PROGRAM
NOTE
THE
ABSENCE
OF
SEMICOLONS
IN
THE
GENERAL
FORM
OF
THE
IF
STATEMENT
RECALL
THAT
THE
SEMICOLON
WHEN
REQUIRED
IS
PART
OF
THE
STATEMENT
AND
IS
NOT
USED
TO
SEPARATE
STATEMENTS
AS
IN
IF
TEMPERATURE
SYSTEM
OUT
PRINTLN
WARNING
BELOW
FREEZING
SYSTEM
OUT
PRINTLN
IT
TEMPERATURE
DEGREES
THE
MESSAGE
WARNING
BELOW
FREEZING
IS
PRINTED
ONLY
WHEN
THE
TEMPERATURE
IS
LESS
THAN
THE
SEC
OND
PRINT
STATEMENT
IS
ALWAYS
EXECUTED
THIS
EXAMPLE
HAS
A
SEMICOLON
AT
THE
END
OF
THE
IF
STATEMENT
BECAUSE
THE
STATEMENT
INSIDE
THE
IF
STATEMENT
IS
AN
EXPRESSION
STATEMENT
THAT
ENDS
WITH
A
SEMICOLON
WHEN
THE
STATEMENT
INSIDE
AN
IF
STATEMENT
IS
A
BLOCK
YOU
GET
IF
STATEMENTS
THAT
LOOK
LIKE
IF
TEMPERATURE
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
SYSTEM
OUT
PRINTLN
WARNING
BELOW
FREEZING
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
HERE
YOU
CAN
SEE
THE
IMPORTANCE
OF
THE
BLOCK
AS
A
MEANS
OF
GROUPING
STATEMENTS
IN
THIS
EXAMPLE
WHAT
OTH
ERWISE
WOULD
BE
THREE
SEPARATE
STATEMENTS
ARE
GROUPED
AND
ALL
ARE
EXECUTED
WHEN
THE
BOOLEAN
EXPRESSION
IS
TRUE
THE
FORMATTING
SHOWN
OF
THE
IF
STATEMENT
WITH
A
BLOCK
AS
THE
STATEMENT
ALIGNS
VERTICALLY
WITH
THE
BRACES
OF
THE
BLOCK
STATEMENT
AN
ALTERNATIVE
FORMATTING
AND
THE
ONE
THAT
WE
USE
PLACES
THE
OPENING
BRACE
ON
THE
SAME
LINE
AS
THE
KEYWORD
IF
AND
THEN
ALIGNS
THE
CLOSING
BRACE
WITH
THE
KEYWORD
AS
SHOWN
HERE
IF
TEMPERATURE
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
SYSTEM
OUT
PRINTLN
WARNING
BELOW
FREEZING
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
AT
THE
END
OF
THIS
CHAPTER
WE
DISCUSS
FURTHER
WHICH
STYLE
TO
CHOOSE
PROBLEM
SOLVING
WITH
THE
IF
STATEMENT
A
DIFFERENT
NUMBER
IS
INITIALLY
PLACED
IN
EACH
OF
THREE
BOXES
LABELED
A
B
AND
C
RESPECTIVELY
THE
PROBLEM
IS
TO
REARRANGE
OR
SORT
THE
NUMBERS
SO
THAT
THE
FINAL
NUMBER
IN
BOX
A
IS
LESS
THAN
THAT
IN
BOX
B
AND
THAT
THE
NUMBER
IN
BOX
B
IS
LESS
THAN
THAT
IN
BOX
C
INITIAL
AND
FINAL
STATES
FOR
A
PARTICULAR
SET
OF
NUMBERS
ARE
AS
FOL
LOWS
BEFORE
AFTER
A
A
B
B
C
C
PSEUDOCODE
FOR
PERFORMING
THIS
SORTING
TASK
INVOLVES
THE
FOLLOWING
STEPS
PSEUDOCODE
FOR
THREE
NUMBER
SORT
PLACE
THE
FIRST
NUMBER
IN
BOX
A
PLACE
THE
SECOND
NUMBER
IN
BOX
B
PLACE
THE
THIRD
NUMBER
IN
BOX
C
IF
THE
NUMBER
IN
A
IS
NOT
LARGER
THAN
THE
NUMBER
IN
B
GO
TO
STEP
INTERCHANGE
THE
NUMBER
IN
A
WITH
THAT
IN
B
IF
THE
NUMBER
IN
B
IS
LARGER
THAN
THE
NUMBER
IN
C
THEN
GO
TO
STEP
OTHERWISE
HALT
INTERCHANGE
THE
NUMBERS
IN
B
AND
C
IF
THE
NUMBER
IN
A
IS
LARGER
THAN
THAT
IN
B
THEN
GO
TO
STEP
OTHERWISE
HALT
INTERCHANGE
THE
NUMBERS
IN
A
AND
B
HALT
LET
EXECUTE
THIS
PSEUDOCODE
WITH
THE
THREE
SPECIFIC
NUMBERS
PREVIOUSLY
GIVEN
AND
IN
THAT
ORDER
WE
ALWAYS
START
WITH
THE
FIRST
INSTRUCTION
THE
CONTENTS
OF
THE
THREE
BOXES
AT
VARIOUS
STAGES
OF
EXECUTION
ARE
SHOWN
IN
THE
FOLLOWING
TABLE
BOX
STEP
STEP
STEP
STEP
STEP
A
B
C
PROBLEM
SOLVING
WITH
THE
IF
STATEMENT
TO
EXECUTE
STEP
WE
PLACE
THE
FIRST
NUMBER
IN
BOX
A
SIMILARLY
AT
THE
END
OF
INSTRUCTION
THE
HAS
BEEN
INSERTED
INTO
BOX
B
AND
BOX
C
CONTAINS
THE
AS
IS
LARGER
THAN
THE
CONDITION
TESTED
IN
STEP
IS
FALSE
AND
WE
PROCEED
TO
INSTRUCTION
THIS
STEP
SWITCHES
THE
VALUES
INTO
BOXES
A
AND
B
SO
THAT
BOX
A
NOW
CON
TAINS
THE
AND
BOX
B
HAS
THE
STEP
HAS
NOW
BEEN
REACHED
AND
WE
COMPARE
THE
NUMBER
IN
BOX
B
TO
THAT
IN
BOX
C
IS
GREATER
THAN
SO
A
TRANSFER
IS
MADE
TO
STEP
THE
NUMBERS
IN
BOXES
B
AND
C
ARE
THEN
INTERCHANGED
SO
THAT
BOX
B
HAS
THE
AND
BOX
C
HAS
THE
THE
TEST
IN
STEP
8
FAILS
IS
NOT
LARGER
THAN
AND
THE
COMPUTATION
THEN
HALTS
THE
THREE
NUMBERS
HAVE
BEEN
SORTED
IN
ASCENDING
SEQUENCE
I
E
11
YOU
SHOULD
CONVINCE
YOURSELF
BY
BENCH
TESTING
THIS
ALGORITHM
WITH
OTHER
VALUES
OF
A
B
AND
C
THAT
THE
COMPUTATION
DESCRIBED
BY
THE
PSEUDOCODE
WILL
WORK
CORRECTLY
FOR
ANY
THREE
NUMBERS
A
FLOWCHART
OF
THE
SORT
ING
ALGORITHM
IS
SHOWN
IN
THE
FOLLOWING
DIAGRAM
NOTE
THAT
WE
DECOMPOSED
THE
OPERATION
OF
INTERCHANGING
TWO
NUMBERS
INTO
THREE
MORE
PRIMITIVE
INSTRUC
TIONS
BOX
T
IS
USED
AS
TEMPORARY
STORAGE
TO
HOLD
INTERMEDIATE
RESULTS
IN
ORDER
TO
INTERCHANGE
OR
SWITCH
THE
TWO
NUMBERS
A
AND
B
WE
FIRST
TEMPORARILY
STORE
ONE
OF
THE
NUMBERS
SAY
A
IN
T
T
F
A
NEXT
THE
OTHER
NUM
BER
IS
STORED
IN
A
A
F
B
AND
LAST
THE
FIRST
NUMBER
IS
PLACED
IN
B
B
F
T
NOTE
THAT
THE
INSTRUCTION
SEQUENCE
A
F
B
B
F
A
WILL
NOT
INTERCHANGE
A
AND
B
BECAUSE
THE
FIRST
INSTRUCTION
EFFECTIVELY
DESTROYS
THE
OLD
VALUE
IN
A
IN
COMPUTER
TERMS
THE
LABELED
BOXES
ARE
ANALOGOUS
TO
MEMORY
OR
STORAGE
AREAS
THAT
CAN
CONTAIN
VALUES
NEXT
WE
CODE
IN
JAVA
THE
PSEUDOCODE
VERSION
OF
OUR
SORTING
PROGRAM
SORTINPUT
JAVA
SORT
THREE
NUMBERS
IMPORT
JAVA
UTIL
CLASS
SORTINPUT
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
A
B
C
T
SCANNER
SCAN
NEW
SCANNER
SYSTEM
IN
SYSTEM
OUT
PRINTLN
TYPE
THREE
INTEGERS
A
SCAN
NEXTINT
B
SCAN
NEXTINT
C
SCAN
NEXTINT
IF
A
B
T
A
A
B
B
T
IF
B
C
T
B
B
C
C
T
IF
A
B
T
A
A
B
B
T
SYSTEM
OUT
PRINT
THE
SORTED
ORDER
IS
SYSTEM
OUT
PRINTLN
A
B
C
DISSECTION
OF
THE
SORTINPUT
PROGRAM
INT
A
B
C
T
THIS
PROGRAM
DECLARES
FOUR
INTEGER
VARIABLES
THE
VARIABLES
A
B
AND
C
ARE
INPUTS
TO
BE
SORTED
AND
T
IS
TO
BE
USED
FOR
TEMPORARY
PURPOSES
AS
DESCRIBED
IN
THE
PSEUDOCODE
SYSTEM
OUT
PRINTLN
TYPE
THREE
INTEGERS
THIS
LINE
IS
USED
TO
PROMPT
THE
USER
TO
TYPE
THE
THREE
NUMBERS
TO
BE
SORTED
WHENEVER
A
PROGRAM
IS
EXPECTING
THE
USER
TO
DO
SOMETHING
IT
SHOULD
PRINT
OUT
A
PROMPT
TELLING
THE
USER
WHAT
TO
DO
A
SCAN
NEXTINT
B
SCAN
NEXTINT
C
SCAN
NEXTINT
THE
METHOD
CALL
EXPRESSION
SCAN
NEXTINT
IS
USED
TO
OBTAIN
THE
INPUT
FROM
THE
KEYBOARD
THREE
SEPA
RATE
INTEGERS
NEED
TO
BE
TYPED
THE
VALUES
READ
WILL
BE
STORED
IN
THE
THREE
VARIABLES
IF
A
B
T
A
A
B
B
T
IF
B
C
T
B
B
C
C
T
IF
A
B
T
A
A
B
B
T
THE
IF
STATEMENTS
AND
RESULTING
ASSIGNMENTS
ARE
JAVA
NOTATION
FOR
THE
SAME
ACTIONS
DESCRIBED
IN
THE
SORT
FLOW
CHART
TO
COMPREHEND
THESE
ACTIONS
YOU
NEED
TO
UNDERSTAND
WHY
THE
INTERCHANGE
OR
SWAPPING
OF
VALUES
BETWEEN
TWO
VARIABLES
SUCH
AS
A
AND
B
REQUIRES
THE
USE
OF
THE
TEMPORARY
T
ALSO
NOTE
HOW
THE
THREE
ASSIGNMENTS
ARE
GROUPED
AS
A
BLOCK
ALLOWING
EACH
IF
EXPRESSION
TO
CONTROL
A
GROUP
OF
ACTIONS
THE
IF
ELSE
STATEMENT
CLOSELY
RELATED
TO
THE
IF
STATEMENT
IS
THE
IF
ELSE
STATEMENT
AN
IF
ELSE
STATEMENT
HAS
THE
FOLLOWING
GEN
ERAL
FORM
IF
BOOLEANEXPR
ELSE
IF
THE
EXPRESSION
BOOLEANEXPR
IS
TRUE
THEN
IS
EXECUTED
AND
IS
SKIPPED
IF
BOOLEANEXPR
IS
FALSE
THEN
IS
SKIPPED
AND
IS
EXECUTED
IS
CALLED
THE
ELSE
STATEMENT
AFTER
THE
IF
ELSE
STATEMENT
HAS
BEEN
EXECUTED
CONTROL
PASSES
TO
THE
NEXT
STATEMENT
THE
FLOW
OF
EXECUTION
BRANCHES
AND
THEN
REJOINS
AS
SHOWN
IN
THE
FOLLOWING
DIAGRAM
EXECUTION
ENTERS
IF
ELSE
STATEMENT
CONTINUE
WITH
REST
OF
PROGRAM
CONSIDER
THE
FOLLOWING
CODE
IF
X
Y
MIN
X
ELSE
MIN
Y
SYSTEM
OUT
PRINTLN
MIN
MIN
IF
X
Y
IS
TRUE
THEN
MIN
WILL
BE
ASSIGNED
THE
VALUE
OF
X
IF
IT
IS
FALSE
THEN
MIN
WILL
BE
ASSIGNED
THE
VALUE
OF
Y
AFTER
THE
IF
ELSE
STATEMENT
IS
EXECUTED
MIN
IS
PRINTED
AS
WITH
THE
IF
STATEMENT
EITHER
BRANCH
OF
AN
IF
ELSE
STATEMENT
CAN
CONTAIN
A
BLOCK
AS
SHOWN
IN
THE
FOLLOW
ING
EXAMPLE
IF
TEMPERATURE
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
SYSTEM
OUT
PRINTLN
TEMPERATURE
DEGREES
BELOW
FREEZING
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
ELSE
SYSTEM
OUT
PRINTLN
IT
TEMPERATURE
DEGREES
FAHRENHEIT
NESTED
IF
ELSE
STATEMENTS
3
NESTED
IF
ELSE
STATEMENTS
THE
IF
STATEMENT
IS
A
FULL
FLEDGED
STATEMENT
AND
CAN
BE
USED
ANYWHERE
A
STATEMENT
IS
EXPECTED
SO
YOU
COULD
PUT
ANOTHER
IF
STATEMENT
IN
EITHER
BRANCH
OF
AN
IF
STATEMENT
FOR
EXAMPLE
YOU
COULD
REWRITE
THE
EARLIER
AIR
FARE
CHECKING
STATEMENT
AS
IF
AGEOFPERSON
IF
AGEOFPERSON
SYSTEM
OUT
PRINTLN
FULL
FARE
ADULT
IF
THE
EXPRESSION
AGEOFPERSON
IS
TRUE
THEN
THE
STATEMENT
IF
AGEOFPERSON
SYSTEM
OUT
PRINTLN
FULL
FARE
ADULT
IS
EVALUATED
THE
TRUE
BRANCH
FOR
THE
AGEOFPERSON
IF
STATEMENT
IS
ITSELF
AN
IF
STATEMENT
IN
GENERAL
IF
THE
TRUE
BRANCH
OF
AN
IF
STATEMENT
CONTAINS
ONLY
ANOTHER
IF
STATEMENT
WRITING
IT
AS
A
SINGLE
IF
STATEMENT
IS
MORE
EFFICIENT
COMBINING
THE
EXPRESSIONS
WITH
THE
OPERATOR
AS
WE
DID
IN
SECTION
3
2
LOGICAL
OPERA
TORS
ON
PAGE
USING
IN
MOST
CASES
IS
ALSO
CLEARER
THESE
NESTED
IF
STATEMENTS
CAN
T
ALWAYS
BE
COLLAPSED
CONSIDER
THE
FOLLOWING
VARIATION
ON
OUR
EARLIER
EXAM
PLE
INVOLVING
TEMPERATURE
IF
TEMPERATURE
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
IF
TEMPERATURE
SYSTEM
OUT
PRINTLN
TEMPERATURE
DEGREES
BELOW
ZERO
ELSE
SYSTEM
OUT
PRINTLN
TEMPERATURE
F
BELOW
FREEZING
SYSTEM
OUT
PRINTLN
WARNING
WARNING
WARNING
ELSE
SYSTEM
OUT
PRINTLN
IT
IS
TEMPERATURE
DEGREES
FAHRENHEIT
THE
THEN
STATEMENT
FOR
THE
OUTER
IF
ELSE
STATEMENT
IS
A
BLOCK
CONTAINING
ANOTHER
IF
ELSE
STATEMENT
3
4
2
IF
ELSE
IF
ELSE
IF
IN
THE
PRECEDING
EXAMPLE
THE
NESTING
WAS
ALL
DONE
IN
THE
THEN
STATEMENT
PART
OF
THE
IF
ELSE
STATEMENT
NOW
WE
NEST
IN
THE
ELSE
STATEMENT
PART
OF
THE
IF
ELSE
STATEMENT
IF
AGEOFPERSON
SYSTEM
OUT
PRINTLN
CHILD
FARE
ELSE
IF
AGEOFPERSON
SYSTEM
OUT
PRINTLN
ADULT
FARE
ELSE
SYSTEM
OUT
PRINTLN
SENIOR
FARE
THE
BRACES
ARE
NOT
NEEDED
WE
ADDED
THEM
ONLY
FOR
CLARITY
THIS
FORM
IS
SO
COMMON
THAT
EXPERIENCED
PRO
GRAMMERS
USUALLY
DROP
THE
BRACES
IN
ADDITION
THE
ELSE
AND
THE
FOLLOWING
IF
ARE
USUALLY
PLACED
ON
THE
SAME
LINE
AS
IN
IF
AGEOFPERSON
SYSTEM
OUT
PRINTLN
CHILD
FARE
ELSE
IF
AGEOFPERSON
SYSTEM
OUT
PRINTLN
ADULT
FARE
ELSE
SYSTEM
OUT
PRINTLN
SENIOR
FARE
NOTE
THAT
THE
SECOND
IF
STATEMENT
IS
A
SINGLE
STATEMENT
THAT
CONSTITUTES
THE
ELSE
BRANCH
OF
THE
FIRST
STATE
MENT
THE
TWO
FORMS
PRESENTED
ARE
EQUIVALENT
YOU
SHOULD
BE
SURE
THAT
YOU
UNDERSTAND
WHY
THEY
ARE
IF
YOU
NEED
TO
LOOK
BACK
AT
THE
GENERAL
FORM
OF
THE
IF
STATEMENT
AND
RECALL
THAT
AN
ENTIRE
IF
ELSE
STATEMENT
IS
A
STATEMENT
ITSELF
THIS
FACT
IS
ILLUSTRATED
IN
THE
FOLLOWING
FIGURE
WHEREIN
EACH
STATEMENT
IS
SURROUNDED
BY
A
BOX
AS
YOU
CAN
SEE
THERE
ARE
FIVE
DIFFERENT
STATEMENTS
ELSE
IF
AGEOFPERSON
SYSTEM
OUT
PRINTLN
ADULT
FARE
ELSE
SYSTEM
OUT
PRINTLN
SENIOR
FARE
SOMETIMES
THIS
CHAIN
OF
IF
ELSE
IF
ELSE
IF
ELSE
CAN
GET
RATHER
LONG
TEDIOUS
AND
INEFFICIENT
FOR
THIS
REASON
A
SPECIAL
CONSTRUCT
CAN
BE
USED
TO
DEAL
WITH
THIS
SITUATION
WHEN
THE
CONDITION
BEING
TESTED
IS
OF
THE
RIGHT
FORM
IF
YOU
WANT
TO
DO
DIFFERENT
THINGS
BASED
ON
DISTINCT
VALUES
OF
A
SINGLE
INTEGER
EXPRESSION
THEN
YOU
CAN
USE
THE
SWITCH
STATEMENT
WHICH
WE
DISCUSS
IN
SECTION
3
9
THE
SWITCH
STATEMENT
ON
PAGE
3
4
3
THE
DANGLING
ELSE
PROBLEM
WHEN
YOU
USE
SEQUENCES
OF
NESTED
IF
ELSE
STATEMENTS
A
POTENTIAL
PROBLEM
CAN
ARISE
AS
TO
WHAT
IF
AN
ELSE
GOES
WITH
AS
FOR
EXAMPLE
IN
IF
IF
ELSE
THE
INDENTING
SUGGESTS
THAT
IS
EXECUTED
WHENEVER
IS
FALSE
HOWEVER
THAT
ISN
T
THE
CASE
RATHER
IS
EXECUTED
ONLY
WHEN
IS
TRUE
AND
IS
FALSE
THE
PROPER
INDENTING
IS
IF
IF
ELSE
THE
RULE
USED
IN
JAVA
IS
THAT
AN
ELSE
IS
ALWAYS
MATCHED
WITH
THE
NEAREST
PRECEDING
IF
THAT
DOESN
T
HAVE
AN
ELSE
TO
CAUSE
TO
BE
EXECUTED
WHENEVER
IS
FALSE
AS
SUGGESTED
BY
THE
FIRST
INDENTING
EXAMPLE
YOU
CAN
USE
BRACES
TO
GROUP
THE
STATEMENTS
AS
SHOWN
IF
IF
ELSE
THE
BRACES
ARE
LIKE
PARENTHESES
IN
ARITHMETIC
EXPRESSIONS
THAT
ARE
USED
TO
OVERRIDE
THE
NORMAL
PRECEDENCE
RULES
THE
NESTED
OR
INNER
IF
STATEMENT
IS
NOW
INSIDE
A
BLOCK
THAT
PREVENTS
IT
FROM
BEING
MATCHED
WITH
THE
ELSE
WE
HAVE
ADDED
THE
ABILITY
TO
CHOOSE
AMONG
ALTERNATIVES
BUT
OUR
PROGRAMS
STILL
EXECUTE
EACH
INSTRUCTION
AT
MOST
ONCE
AND
PROGRESS
FROM
THE
TOP
TO
THE
BOTTOM
THE
WHILE
STATEMENT
ALLOWS
US
TO
WRITE
PROGRAMS
THAT
RUN
REPEATEDLY
THE
GENERAL
FORM
OF
A
WHILE
STATEMENT
IN
JAVA
IS
WHILE
BOOLEANEXPR
STATEMENT
STATEMENT
IS
EXECUTED
REPEATEDLY
AS
LONG
AS
THE
EXPRESSION
BOOLEANEXPR
IS
TRUE
AS
SHOWN
IN
THE
FOLLOWING
FLOWCHART
EXECUTION
ENTERS
WHILE
STATEMENT
CONTINUE
WITH
REST
OF
PROGRAM
THIS
FLOWCHART
IS
THE
SAME
AS
THE
ONE
FOR
THE
IF
STATEMENT
WITH
THE
ADDITION
OF
AN
ARROW
RETURNING
TO
THE
TEST
BOX
NOTE
THAT
STATEMENT
MAY
NOT
BE
EXECUTED
THAT
WILL
OCCUR
WHEN
BOOLEANEXPR
EVALUATES
TO
FALSE
THE
FIRST
TIME
NOTE
ALSO
THAT
LIKE
THE
DESCRIPTION
OF
THE
IF
ELSE
STATEMENT
THERE
ARE
NO
SEMICOLONS
IN
THE
GENERAL
FORM
OF
THE
WHILE
STATEMENT
THE
SEMICOLON
IF
ANY
WOULD
BE
PART
OF
THE
STATEMENT
THAT
FOLLOWS
THE
PARENTHESIZED
BOOLEAN
EXPRESSION
A
SIMPLE
EXAMPLE
FOR
USE
ON
VALENTINE
DAY
IS
VALENTINE
JAVA
A
SIMPLE
WHILE
LOOP
CLASS
VALENTINE
PUBLIC
STATIC
VOID
MAIN
STRING
ARGS
INT
HOWMUCH
WHILE
HOWMUCH
SYSTEM
OUT
PRINTLN
I
LOVE
YOU
THE
OUTPUT
IS
WHEN
THE
BODY
OF
THE
LOOP
IS
A
BLOCK
YOU
GET
WHILE
BOOLEANEXPR
MODIFYING
OUR
EARLIER
EXAMPLE
GIVES
INT
HOWMUCH
WHILE
HOWMUCH
SYSTEM
OUT
PRINT
I
LOVE
YOU
SYSTEM
OUT
PRINTLN
MY
ROSE
WHICH
RESULTS
IN
THE
OUTPUT
MOST
WHILE
STATEMENTS
ARE
PRECEDED
BY
SOME
INITIALIZATION
STATEMENTS
OUR
EXAMPLE
INITIALIZED
THE
LOOP
COUNTING
VARIABLE
HOWMUCH
3
PROBLEM
SOLVING
WITH
LOOPS
SUPPOSE
THAT
YOU
WANTED
TO
HAVE
A
PROGRAM
THAT
COULD
READ
IN
AN
ARBITRARY
NUMBER
OF
NONZERO
VALUES
AND
COMPUTE
THE
AVERAGE
IF
YOU
WERE
TO
USE
PSEUDOCODE
THE
PROGRAM
MIGHT
LOOK
LIKE
THE
FOLLOWING
PSEUDOCODE
FOR
AVERAGE
USING
GOTO
GET
A
NUMBER
2
IF
THE
NUMBER
IS
GO
TO
STEP
6
3
ADD
THE
NUMBER
TO
THE
RUNNING
TOTAL
4
INCREMENT
THE
COUNT
OF
NUMBERS
READ
IN
GO
BACK
TO
STEP
6
DIVIDE
THE
RUNNING
TOTAL
BY
THE
COUNT
OF
NUMBERS
IN
ORDER
TO
GET
THE
AVERAGE
7
PRINT
THE
AVERAGE
IN
THIS
PSEUDOCODE
STEP
GOES
BACK
TO
THE
BEGINNING
OF
THE
INSTRUCTION
SEQUENCE
FORMING
A
LOOP
IN
THE
AND
MANY
PROGRAMMING
LANGUAGES
USED
A
GOTO
STATEMENT
TO
IMPLEMENT
STEP
5
FOR
CODING
SUCH
A
LOOP
THESE
GOTO
STATEMENTS
RESULTED
IN
PROGRAMS
THAT
WERE
HARD
TO
FOLLOW
BECAUSE
THEY
COULD
JUMP
ALL
OVER
THE
PLACE
THEIR
USE
WAS
SOMETIMES
CALLED
SPAGHETTI
CODE
IN
JAVA
THERE
IS
NO
GOTO
STATEMENT
JAVA
INCLUDES
GOTO
AS
A
KEYWORD
THAT
HAS
NO
USE
SO
THAT
THE
COMPILER
CAN
ISSUE
AN
ERROR
MESSAGE
IF
IT
IS
USED
INADVERTENTLY
BY
A
PROGRAMMER
FAMILIAR
WITH
C
OR
C
TODAY
STRUCTURED
CONTROL
CONSTRUCTS
CAN
DO
ALL
THE
GOOD
THINGS
BUT
NONE
OF
THE
BAD
THINGS
THAT
YOU
COULD
DO
WITH
GOTO
STATEMENTS
A
LOOP
IS
A
SEQUENCE
OF
STATEMENTS
THAT
ARE
TO
BE
REPEATED
POSSIBLY
MANY
TIMES
THE
PRECEDING
PSEUDOCODE
HAS
A
LOOP
THAT
BEGINS
AT
STEP
1
AND
ENDS
AT
STEP
5
MODERN
PROGRAMS
REQUIRE
THAT
YOU
USE
A
CONSTRUCT
TO
INDI
CATE
EXPLICITLY
THE
BEGINNING
AND
THE
END
OF
THE
LOOP
THE
STRUCTURED
EQUIVALENT
STILL
IN
PSEUDOCODE
MIGHT
LOOK
LIKE
THE
FOLLOWING
PSEUDOCODE
WITH
LOOP
PSEUDOCODE
FOR
AVERAGE
WITHOUT
USING
GOTO
GET
A
NUMBER
WHILE
THE
NUMBER
IS
NOT
DO
THE
FOLLOWING
ADD
THE
NUMBER
TO
THE
RUNNING
TOTAL
INCREMENT
THE
COUNT
OF
NUMBERS
READ
IN
GET
A
NUMBER
WHEN
THE
LOOP
EXITS
DIVIDE
THE
RUNNING
TOTAL
BY
THE
COUNT
OF
NUMBERS
TO
GET
THE
AVERAGE
PRINT
THE
AVERAGE
THE
LOOP
INITIALIZATION
IN
THIS
CASE
IS
READING
IN
THE
FIRST
NUMBER
SOMEWHERE
WITHIN
A
LOOP
TYPICALLY
AT
THE
END
IS
SOMETHING
THAT
PREPARES
THE
NEXT
ITERATION
OF
THE
LOOP
GETTING
A
NEW
NUMBER
IN
OUR
EXAMPLE
SO
ALTHOUGH
NOT
PART
OF
THE
REQUIRED
SYNTAX
WHILE
STATEMENTS
GENERALLY
LOOK
LIKE
THE
FOLLOWING
STATEMENTINIT
INITIALIZATION
FOR
THE
LOOP
WHILE
BOOLEANEXPR
STATEMENTNEXT
PREPARE
FOR
NEXT
ITERATION
THE
WHILE
STATEMENT
IS
MOST
OFTEN
USED
WHEN
THE
NUMBER
OF
ITERATIONS
ISN
T
KNOWN
IN
ADVANCE
THIS
SITUA
TION
MIGHT
OCCUR
IF
THE
PROGRAM
WAS
SUPPOSED
TO
READ
IN
VALUES
PROCESSING
THEM
IN
SOME
WAY
UNTIL
A
SPECIAL
VALUE
CALLED
A
SENTINEL
WAS
READ
IN
SUCH
IS
THE
CASE
FOR
OUR
COMPUTE
THE
AVERAGE
PROGRAM
IT
READS
IN
NUM
BERS
UNTIL
THE
SENTINEL
VALUE
0
IS
READ
IN
WE
CAN
NOW
DIRECTLY
TRANSLATE
INTO
JAVA
THE
PSEUDOCODE
FOR
COMPUTING
AN
AVERAGE
